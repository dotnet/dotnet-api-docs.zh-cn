<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7083e7582001df42ff506251c7763e0fae3c7151" /><Meta Name="ms.sourcegitcommit" Value="57ccffdf8fe8e719b7e778b859bf1ca216879f31" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/28/2020" /><Meta Name="ms.locfileid" Value="87328960" /></Metadata><TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;xamarinmac-3.0" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageQueue&#xA;Inherits Component&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageQueue : System::ComponentModel::Component, System::Collections::IEnumerable" />
  <TypeSignature Language="F#" Value="type MessageQueue = class&#xA;    inherit Component&#xA;    interface IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" FrameworkAlternate="netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.ComponentModel.DefaultEvent("ReceiveCompleted")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultEvent("ReceiveCompleted")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName Language="C#">[System.ComponentModel.Designer("Microsoft.VisualStudio.Install.MessageQueueInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.Designer("Microsoft.VisualStudio.Install.MessageQueueInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName Language="C#">[System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName Language="C#">[System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName Language="C#">[System.Messaging.MessagingDescription("MessageQueueDesc")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MessageQueueDesc")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="b3203-101">提供对“消息队列”服务器上的队列的访问。</span><span class="sxs-lookup"><span data-stu-id="b3203-101">Provides access to a queue on a Message Queuing server.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-102">消息队列技术允许在不同时间运行的应用程序在异类网络和可能暂时脱机的系统之间进行通信。</span><span class="sxs-lookup"><span data-stu-id="b3203-102">The Message Queuing technology allows applications running at different times to communicate across heterogeneous networks and systems that might be temporarily offline.</span></span> <span data-ttu-id="b3203-103">应用程序发送、接收或查看 (读取，而不从队列中移除) 消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-103">Applications send, receive, or peek (read without removing) messages from queues.</span></span> <span data-ttu-id="b3203-104">消息队列是 [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] 和 WINDOWS NT 的可选组件，并且必须单独安装。</span><span class="sxs-lookup"><span data-stu-id="b3203-104">Message Queuing is an optional component of [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] and Windows NT, and must be installed separately.</span></span>  
  
 <span data-ttu-id="b3203-105"><xref:System.Messaging.MessageQueue>类是消息队列周围的包装器。</span><span class="sxs-lookup"><span data-stu-id="b3203-105">The <xref:System.Messaging.MessageQueue> class is a wrapper around Message Queuing.</span></span> <span data-ttu-id="b3203-106">有多个版本的消息队列，使用 <xref:System.Messaging.MessageQueue> 类可能会产生略微不同的行为，具体取决于所使用的操作系统。</span><span class="sxs-lookup"><span data-stu-id="b3203-106">There are multiple versions of Message Queuing, and using the <xref:System.Messaging.MessageQueue> class can result in slightly different behavior, depending on the operating system you are using.</span></span> <span data-ttu-id="b3203-107">有关每个版本的消息队列的特定功能的信息，请参阅 MSDN 中的平台 SDK 中的 "消息队列新增功能" 主题。</span><span class="sxs-lookup"><span data-stu-id="b3203-107">For information about specific features of each version of Message Queuing, see the topic "What's New in Message Queuing" in the Platform SDK in MSDN.</span></span>  
  
 <span data-ttu-id="b3203-108"><xref:System.Messaging.MessageQueue>类提供对 "消息队列" 队列的引用。</span><span class="sxs-lookup"><span data-stu-id="b3203-108">The <xref:System.Messaging.MessageQueue> class provides a reference to a Message Queuing queue.</span></span> <span data-ttu-id="b3203-109">你可以在构造函数中指定一个路径 <xref:System.Messaging.MessageQueue.%23ctor%2A> 以连接到现有资源，或者可以在服务器上创建一个新队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-109">You can specify a path in the <xref:System.Messaging.MessageQueue.%23ctor%2A> constructor to connect to an existing resource, or you can create a new queue on the server.</span></span> <span data-ttu-id="b3203-110"><xref:System.Messaging.MessageQueue.Send%28System.Object%29> <xref:System.Messaging.MessageQueue.Peek%2A> <xref:System.Messaging.MessageQueue.Receive%2A> 必须先将类的新实例 <xref:System.Messaging.MessageQueue> 与现有队列相关联，然后才能调用、或。</span><span class="sxs-lookup"><span data-stu-id="b3203-110">Before you can call <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, or <xref:System.Messaging.MessageQueue.Receive%2A>, you must associate the new instance of the <xref:System.Messaging.MessageQueue> class with an existing queue.</span></span> <span data-ttu-id="b3203-111">此时，你可以操作队列属性，例如 <xref:System.Messaging.MessageQueue.Category%2A> 和 <xref:System.Messaging.MessageQueue.Label%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-111">At that point, you can manipulate the queue properties such as <xref:System.Messaging.MessageQueue.Category%2A> and <xref:System.Messaging.MessageQueue.Label%2A>.</span></span>  
  
 <span data-ttu-id="b3203-112"><xref:System.Messaging.MessageQueue> 支持两种类型的消息检索：同步和异步。</span><span class="sxs-lookup"><span data-stu-id="b3203-112"><xref:System.Messaging.MessageQueue> supports two types of message retrieval: synchronous and asynchronous.</span></span> <span data-ttu-id="b3203-113">同步方法和将 <xref:System.Messaging.MessageQueue.Peek%2A> <xref:System.Messaging.MessageQueue.Receive%2A> 导致进程线程等待指定的时间间隔，以使新消息到达队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-113">The synchronous methods, <xref:System.Messaging.MessageQueue.Peek%2A> and <xref:System.Messaging.MessageQueue.Receive%2A>, cause the process thread to wait a specified time interval for a new message to arrive in the queue.</span></span> <span data-ttu-id="b3203-114">使用异步方法 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 和 <xref:System.Messaging.MessageQueue.BeginReceive%2A> ，可以在消息到达队列之前，在单独的线程中继续执行主应用程序任务。</span><span class="sxs-lookup"><span data-stu-id="b3203-114">The asynchronous methods, <xref:System.Messaging.MessageQueue.BeginPeek%2A> and <xref:System.Messaging.MessageQueue.BeginReceive%2A>, allow the main application tasks to continue in a separate thread until a message arrives in the queue.</span></span> <span data-ttu-id="b3203-115">这些方法的工作方式是使用回调对象和状态对象在线程之间传递信息。</span><span class="sxs-lookup"><span data-stu-id="b3203-115">These methods work by using callback objects and state objects to communicate information between threads.</span></span>  
  
 <span data-ttu-id="b3203-116">创建类的新实例时 <xref:System.Messaging.MessageQueue> ，不会创建新的 "消息队列" 队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-116">When you create a new instance of the <xref:System.Messaging.MessageQueue> class, you are not creating a new Message Queuing queue.</span></span> <span data-ttu-id="b3203-117">相反，您可以使用 <xref:System.Messaging.MessageQueue.Create%28System.String%29> 、 <xref:System.Messaging.MessageQueue.Delete%28System.String%29> 和 <xref:System.Messaging.MessageQueue.Purge%2A> 方法管理服务器上的队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-117">Instead, you can use the <xref:System.Messaging.MessageQueue.Create%28System.String%29>, <xref:System.Messaging.MessageQueue.Delete%28System.String%29>, and <xref:System.Messaging.MessageQueue.Purge%2A> methods to manage queues on the server.</span></span>  
  
 <span data-ttu-id="b3203-118">与 <xref:System.Messaging.MessageQueue.Purge%2A> 、 <xref:System.Messaging.MessageQueue.Create%28System.String%29> 和 <xref:System.Messaging.MessageQueue.Delete%28System.String%29> 是 `static` 成员不同，因此你可以在不创建类的新实例的情况下调用它们 <xref:System.Messaging.MessageQueue> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-118">Unlike <xref:System.Messaging.MessageQueue.Purge%2A>, <xref:System.Messaging.MessageQueue.Create%28System.String%29> and <xref:System.Messaging.MessageQueue.Delete%28System.String%29> are `static` members, so you can call them without creating a new instance of the <xref:System.Messaging.MessageQueue> class.</span></span>  
  
 <span data-ttu-id="b3203-119">可以将 <xref:System.Messaging.MessageQueue> 对象的属性设置 <xref:System.Messaging.MessageQueue.Path%2A> 为以下三个名称之一：友好名称、 <xref:System.Messaging.MessageQueue.FormatName%2A> 或 <xref:System.Messaging.MessageQueue.Label%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-119">You can set the <xref:System.Messaging.MessageQueue> object's <xref:System.Messaging.MessageQueue.Path%2A> property with one of three names: the friendly name, the <xref:System.Messaging.MessageQueue.FormatName%2A>, or the <xref:System.Messaging.MessageQueue.Label%2A>.</span></span> <span data-ttu-id="b3203-120">友好名称由队列的 <xref:System.Messaging.MessageQueue.MachineName%2A> 和 <xref:System.Messaging.MessageQueue.QueueName%2A> 属性定义，适用 <xref:System.Messaging.MessageQueue.MachineName%2A> \\ <xref:System.Messaging.MessageQueue.QueueName%2A> 于公用队列和 <xref:System.Messaging.MessageQueue.MachineName%2A> \\ `Private$` \\ <xref:System.Messaging.MessageQueue.QueueName%2A> 专用队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-120">The friendly name, which is defined by the queue's <xref:System.Messaging.MessageQueue.MachineName%2A> and <xref:System.Messaging.MessageQueue.QueueName%2A> properties, is <xref:System.Messaging.MessageQueue.MachineName%2A>\\<xref:System.Messaging.MessageQueue.QueueName%2A> for a public queue, and <xref:System.Messaging.MessageQueue.MachineName%2A>\\`Private$`\\<xref:System.Messaging.MessageQueue.QueueName%2A> for a private queue.</span></span> <span data-ttu-id="b3203-121"><xref:System.Messaging.MessageQueue.FormatName%2A>属性允许脱机访问消息队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-121">The <xref:System.Messaging.MessageQueue.FormatName%2A> property allows offline access to message queues.</span></span> <span data-ttu-id="b3203-122">最后，可以使用队列的 <xref:System.Messaging.MessageQueue.Label%2A> 属性设置队列的 <xref:System.Messaging.MessageQueue.Path%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-122">Lastly, you can use the queue's <xref:System.Messaging.MessageQueue.Label%2A> property to set the queue's <xref:System.Messaging.MessageQueue.Path%2A>.</span></span>  
  
 <span data-ttu-id="b3203-123">有关实例的初始属性值的列表 <xref:System.Messaging.MessageQueue> ，请参见 <xref:System.Messaging.MessageQueue.%23ctor%2A> 构造函数。</span><span class="sxs-lookup"><span data-stu-id="b3203-123">For a list of initial property values for an instance of <xref:System.Messaging.MessageQueue>, see the <xref:System.Messaging.MessageQueue.%23ctor%2A> constructor.</span></span>
  
## Examples  
 <span data-ttu-id="b3203-124">下面的代码示例 <xref:System.Messaging.MessageQueue> 使用各种路径名称语法类型创建新的对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-124">The following code example creates new <xref:System.Messaging.MessageQueue> objects using various path name syntax types.</span></span> <span data-ttu-id="b3203-125">在每种情况下，它会将消息发送到其路径在构造函数中定义的队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-125">In each case, it sends a message to the queue whose path is defined in the constructor.</span></span>  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 <span data-ttu-id="b3203-126">下面的代码示例使用名为的应用程序特定的类向队列发送消息，并从队列接收消息 `Order` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-126">The following code example sends a message to a queue, and receives a message from a queue, using an application-specific class called `Order`.</span></span>  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="b3203-127">只有 <see cref="M:System.Messaging.MessageQueue.GetAllMessages" /> 方法是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="b3203-127">Only the <see cref="M:System.Messaging.MessageQueue.GetAllMessages" /> method is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="T:System.Messaging.MessageQueueException" />
    <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
    <altmember cref="P:System.Messaging.MessageQueue.Path" />
    <altmember cref="P:System.Messaging.MessageQueue.Label" />
    <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
    <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
    <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b3203-128">初始化 <see cref="T:System.Messaging.MessageQueue" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="b3203-128">Initializes a new instance of the <see cref="T:System.Messaging.MessageQueue" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b3203-129">初始化 <see cref="T:System.Messaging.MessageQueue" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="b3203-129">Initializes a new instance of the <see cref="T:System.Messaging.MessageQueue" /> class.</span></span> <span data-ttu-id="b3203-130">无参数构造函数初始化新实例后，必须设置该实例的 <see cref="P:System.Messaging.MessageQueue.Path" /> 属性才能使用该实例。</span><span class="sxs-lookup"><span data-stu-id="b3203-130">After the parameterless constructor initializes the new instance, you must set the instance's <see cref="P:System.Messaging.MessageQueue.Path" /> property before you can use the instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-131">使用此重载创建 <xref:System.Messaging.MessageQueue> 类的新实例，该实例不会立即绑定到消息队列服务器上的队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-131">Use this overload to create a new instance of the <xref:System.Messaging.MessageQueue> class that is not immediately tied to a queue on the Message Queuing server.</span></span> <span data-ttu-id="b3203-132">使用此实例之前，必须通过设置属性将其连接到现有的 "消息队列" 队列 <xref:System.Messaging.MessageQueue.Path%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-132">Before using this instance, you must connect it to an existing Message Queuing queue by setting the <xref:System.Messaging.MessageQueue.Path%2A> property.</span></span> <span data-ttu-id="b3203-133">另外，还可以设置对 <xref:System.Messaging.MessageQueue> 该方法的 <xref:System.Messaging.MessageQueue.Create%28System.String%29> 返回值的引用，从而创建新的 "消息队列" 队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-133">Alternatively, you can set the <xref:System.Messaging.MessageQueue> reference to the <xref:System.Messaging.MessageQueue.Create%28System.String%29> method's return value, thereby creating a new Message Queuing queue.</span></span>  
  
 <span data-ttu-id="b3203-134"><xref:System.Messaging.MessageQueue.%23ctor%2A>构造函数实例化类的新实例 <xref:System.Messaging.MessageQueue> ; 它不会创建新的 "消息队列" 队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-134">The <xref:System.Messaging.MessageQueue.%23ctor%2A> constructor instantiates a new instance of the <xref:System.Messaging.MessageQueue> class; it does not create a new Message Queuing queue.</span></span>  
  
 <span data-ttu-id="b3203-135">下表显示了实例的初始属性值 <xref:System.Messaging.MessageQueue> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-135">The following table shows initial property values for an instance of <xref:System.Messaging.MessageQueue>.</span></span>  
  
|<span data-ttu-id="b3203-136">Property</span><span class="sxs-lookup"><span data-stu-id="b3203-136">Property</span></span>|<span data-ttu-id="b3203-137">初始值</span><span class="sxs-lookup"><span data-stu-id="b3203-137">Initial value</span></span>|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|<span data-ttu-id="b3203-138">由类的无参数构造函数设置的值 <xref:System.Messaging.DefaultPropertiesToSend> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-138">The values set by the parameterless constructor of the <xref:System.Messaging.DefaultPropertiesToSend> class.</span></span>|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|<span data-ttu-id="b3203-139">由类的无参数构造函数设置的值 <xref:System.Messaging.MessagePropertyFilter> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-139">The values set by the parameterless constructor of the <xref:System.Messaging.MessagePropertyFilter> class.</span></span> <span data-ttu-id="b3203-140">所有筛选器值均设置为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-140">All the filter values are set to `true`.</span></span>|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-141">下面的代码示例创建一个新的 <xref:System.Messaging.MessageQueue> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-141">The following code example creates a new <xref:System.Messaging.MessageQueue>.</span></span>  
  
 [!code-csharp[MessageQueue#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b3203-142">此 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列的位置。</span><span class="sxs-lookup"><span data-stu-id="b3203-142">The location of the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />.</span></span></param>
        <summary><span data-ttu-id="b3203-143">初始化 <see cref="T:System.Messaging.MessageQueue" /> 类的新实例，该实例引用指定路径处的“消息队列”队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-143">Initializes a new instance of the <see cref="T:System.Messaging.MessageQueue" /> class that references the Message Queuing queue at the specified path.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-144">若要将新的 <xref:System.Messaging.MessageQueue> 实例绑定到特定的 "消息队列" 队列，请使用此重载。</span><span class="sxs-lookup"><span data-stu-id="b3203-144">Use this overload when you want to tie the new <xref:System.Messaging.MessageQueue> instance to a particular Message Queuing queue, for which you know the path, format name, or label.</span></span> <span data-ttu-id="b3203-145">如果要授予对引用队列的第一个应用程序的独占访问权限，则必须将 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> 属性设置为 `true` 或使用传递读访问限制参数的构造函数。</span><span class="sxs-lookup"><span data-stu-id="b3203-145">If you want to grant exclusive access to the first application that references the queue, you must set the <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> property to `true` or use the constructor that passes a read-access restriction parameter.</span></span>  
  
 <span data-ttu-id="b3203-146"><xref:System.Messaging.MessageQueue.%23ctor%2A>构造函数实例化类的新实例 <xref:System.Messaging.MessageQueue> ; 它不会创建新的 "消息队列" 队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-146">The <xref:System.Messaging.MessageQueue.%23ctor%2A> constructor instantiates a new instance of the <xref:System.Messaging.MessageQueue> class; it does not create a new Message Queuing queue.</span></span> <span data-ttu-id="b3203-147">若要在消息队列中创建新队列，请使用 <xref:System.Messaging.MessageQueue.Create%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-147">To create a new queue in Message Queuing, use <xref:System.Messaging.MessageQueue.Create%28System.String%29>.</span></span>  
  
 <span data-ttu-id="b3203-148">参数的语法 `path` 取决于它所引用的队列的类型，如下表所示。</span><span class="sxs-lookup"><span data-stu-id="b3203-148">The syntax of the `path` parameter depends on the type of queue it references, as shown in the following table.</span></span>  
  
|<span data-ttu-id="b3203-149">队列类型</span><span class="sxs-lookup"><span data-stu-id="b3203-149">Queue type</span></span>|<span data-ttu-id="b3203-150">语法</span><span class="sxs-lookup"><span data-stu-id="b3203-150">Syntax</span></span>|  
|----------------|------------|  
|<span data-ttu-id="b3203-151">公用队列</span><span class="sxs-lookup"><span data-stu-id="b3203-151">Public queue</span></span>|`MachineName`\\`QueueName`|  
|<span data-ttu-id="b3203-152">专用队列</span><span class="sxs-lookup"><span data-stu-id="b3203-152">Private queue</span></span>|`MachineName`\\`Private$`\\`QueueName`|  
|<span data-ttu-id="b3203-153">日志队列</span><span class="sxs-lookup"><span data-stu-id="b3203-153">Journal queue</span></span>|`MachineName`\\`QueueName`\\`Journal$`|  
|<span data-ttu-id="b3203-154">计算机日志队列</span><span class="sxs-lookup"><span data-stu-id="b3203-154">Machine journal queue</span></span>|`MachineName`\\`Journal$`|  
|<span data-ttu-id="b3203-155">计算机死信队列</span><span class="sxs-lookup"><span data-stu-id="b3203-155">Machine dead-letter queue</span></span>|`MachineName`\\`Deadletter$`|  
|<span data-ttu-id="b3203-156">计算机事务性死信队列</span><span class="sxs-lookup"><span data-stu-id="b3203-156">Machine transactional dead-letter queue</span></span>|`MachineName`\\`XactDeadletter$`|  
  
 <span data-ttu-id="b3203-157">或者，可以使用 <xref:System.Messaging.MessageQueue.FormatName%2A> 或 <xref:System.Messaging.MessageQueue.Label%2A> 来描述队列路径，如下表所示。</span><span class="sxs-lookup"><span data-stu-id="b3203-157">Alternatively, you can use the <xref:System.Messaging.MessageQueue.FormatName%2A> or <xref:System.Messaging.MessageQueue.Label%2A> to describe the queue path, as shown in the following table.</span></span>  
  
|<span data-ttu-id="b3203-158">参考</span><span class="sxs-lookup"><span data-stu-id="b3203-158">Reference</span></span>|<span data-ttu-id="b3203-159">语法</span><span class="sxs-lookup"><span data-stu-id="b3203-159">Syntax</span></span>|<span data-ttu-id="b3203-160">示例</span><span class="sxs-lookup"><span data-stu-id="b3203-160">Example</span></span>|  
|---------------|------------|-------------|  
|<span data-ttu-id="b3203-161">格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-161">Format name</span></span>|<span data-ttu-id="b3203-162">`FormatName:` [ *格式名* ]</span><span class="sxs-lookup"><span data-stu-id="b3203-162">`FormatName:` [ *format name* ]</span></span>|<span data-ttu-id="b3203-163">`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112</span><span class="sxs-lookup"><span data-stu-id="b3203-163">`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112</span></span><br /><br /> <span data-ttu-id="b3203-164">`FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`</span><span class="sxs-lookup"><span data-stu-id="b3203-164">`FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`</span></span><br /><br /> <span data-ttu-id="b3203-165">`FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`</span><span class="sxs-lookup"><span data-stu-id="b3203-165">`FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`</span></span><br /><br /> <span data-ttu-id="b3203-166">`FormatName:DIRECT=OS:` `MachineName`\\`QueueName`</span><span class="sxs-lookup"><span data-stu-id="b3203-166">`FormatName:DIRECT=OS:` `MachineName`\\`QueueName`</span></span>|  
|<span data-ttu-id="b3203-167">Label</span><span class="sxs-lookup"><span data-stu-id="b3203-167">Label</span></span>|<span data-ttu-id="b3203-168">`Label:` [ *标签* ]</span><span class="sxs-lookup"><span data-stu-id="b3203-168">`Label:` [ *label* ]</span></span>|<span data-ttu-id="b3203-169">`Label:` TheLabel</span><span class="sxs-lookup"><span data-stu-id="b3203-169">`Label:` TheLabel</span></span>|  
  
 <span data-ttu-id="b3203-170">若要脱机工作，必须使用格式名语法，而不是构造函数的路径名称语法。</span><span class="sxs-lookup"><span data-stu-id="b3203-170">To work offline, you must use the format name syntax, not the path name syntax for the constructor.</span></span> <span data-ttu-id="b3203-171">否则，会引发异常，因为主域控制器不可用于解析格式名称的路径。</span><span class="sxs-lookup"><span data-stu-id="b3203-171">Otherwise, an exception is thrown because the primary domain controller is not available to resolve the path to the format name.</span></span>  
  
 <span data-ttu-id="b3203-172">下表显示了实例的初始属性值 <xref:System.Messaging.MessageQueue> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-172">The following table shows initial property values for an instance of <xref:System.Messaging.MessageQueue>.</span></span> <span data-ttu-id="b3203-173">这些值基于具有参数指定的路径的 "消息队列" 队列的属性 `path` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-173">These values are based on the properties of the Message Queuing queue with the path specified by the `path` parameter.</span></span>  
  
|<span data-ttu-id="b3203-174">Property</span><span class="sxs-lookup"><span data-stu-id="b3203-174">Property</span></span>|<span data-ttu-id="b3203-175">初始值</span><span class="sxs-lookup"><span data-stu-id="b3203-175">Initial value</span></span>|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|<span data-ttu-id="b3203-176">0</span><span class="sxs-lookup"><span data-stu-id="b3203-176">0</span></span>|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|<span data-ttu-id="b3203-177">由类的无参数构造函数设置的值 <xref:System.Messaging.DefaultPropertiesToSend> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-177">The values set by the parameterless constructor of the <xref:System.Messaging.DefaultPropertiesToSend> class.</span></span>|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|<span data-ttu-id="b3203-178">`true`如果 "消息队列" 队列的隐私级别设置为 "正文"，则为否则为 `false` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-178">`true`, if the Message Queuing queue's privacy level setting is "Body"; otherwise, `false`.</span></span>|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|<span data-ttu-id="b3203-179">"消息队列" 队列的 "计算机名" 属性的值。</span><span class="sxs-lookup"><span data-stu-id="b3203-179">The value of the Message Queuing queue's computer name property.</span></span>|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|<span data-ttu-id="b3203-180">由类的无参数构造函数设置的值 <xref:System.Messaging.MessagePropertyFilter> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-180">The values set by the parameterless constructor of the <xref:System.Messaging.MessagePropertyFilter> class.</span></span>|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<span data-ttu-id="b3203-181"><xref:System.String.Empty>如果构造函数未设置，则为。</span><span class="sxs-lookup"><span data-stu-id="b3203-181"><xref:System.String.Empty>, if not set by the constructor.</span></span>|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<span data-ttu-id="b3203-182"><xref:System.String.Empty>如果构造函数未设置，则为。</span><span class="sxs-lookup"><span data-stu-id="b3203-182"><xref:System.String.Empty>, if not set by the constructor.</span></span>|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|<span data-ttu-id="b3203-183">`true`如果启用了消息队列对象的日志设置，则为;否则为 `false` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-183">`true`, if the Message Queuing object's journal setting is enabled; otherwise, `false`.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-184">下面的代码示例 <xref:System.Messaging.MessageQueue> 使用各种路径名称语法类型创建新的对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-184">The following code example creates new <xref:System.Messaging.MessageQueue> objects using various path name syntax types.</span></span> <span data-ttu-id="b3203-185">在每种情况下，它会将消息发送到其路径在构造函数中定义的队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-185">In each case, it sends a message to the queue whose path is defined in the constructor.</span></span>  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-186"><see cref="P:System.Messaging.MessageQueue.Path" /> 属性无效，很可能因为尚未设置该属性。</span><span class="sxs-lookup"><span data-stu-id="b3203-186">The <see cref="P:System.Messaging.MessageQueue.Path" /> property is not valid, possibly because it has not been set.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b3203-187">此 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列的位置，它对于本地计算机可以是“.”。</span><span class="sxs-lookup"><span data-stu-id="b3203-187">The location of the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />, which can be "." for the local computer.</span></span></param>
        <param name="sharedModeDenyReceive"><span data-ttu-id="b3203-188"><see langword="true" />，授予访问该队列的第一个应用程序独占读访问权；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-188"><see langword="true" /> to grant exclusive read access to the first application that accesses the queue; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="b3203-189">初始化 <see cref="T:System.Messaging.MessageQueue" /> 类的新实例，该实例引用位于指定路径处而且具有指定读访问限制的“消息队列”队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-189">Initializes a new instance of the <see cref="T:System.Messaging.MessageQueue" /> class that references the Message Queuing queue at the specified path and with the specified read-access restriction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-190">若要将新的绑定 <xref:System.Messaging.MessageQueue> 到特定的 "消息队列" 队列，请使用此重载。</span><span class="sxs-lookup"><span data-stu-id="b3203-190">Use this overload when you want to tie the new <xref:System.Messaging.MessageQueue> to a particular Message Queuing queue, for which you know the path, format name, or label.</span></span> <span data-ttu-id="b3203-191">如果要授予对引用队列的第一个应用程序的独占访问权限，请将 `sharedModeDenyReceive` 参数设置为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-191">If you want to grant exclusive access to the first application that references the queue, set the `sharedModeDenyReceive` parameter to `true`.</span></span> <span data-ttu-id="b3203-192">否则，将设置 `sharedModeDenyReceive` 为 `false` 或使用只有一个参数的构造函数 `path` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-192">Otherwise, set `sharedModeDenyReceive` to `false` or use the constructor that has only a `path` parameter.</span></span>  
  
 <span data-ttu-id="b3203-193">设置 `sharedModeDenyReceive` 为 `true` 会影响访问 "消息队列" 队列的所有对象，包括其他应用程序。</span><span class="sxs-lookup"><span data-stu-id="b3203-193">Setting `sharedModeDenyReceive` to `true` affects all objects that access the Message Queuing queue, including other applications.</span></span> <span data-ttu-id="b3203-194">此参数的效果并不限于此应用程序。</span><span class="sxs-lookup"><span data-stu-id="b3203-194">The effects of the parameter are not restricted to this application.</span></span>  
  
 <span data-ttu-id="b3203-195"><xref:System.Messaging.MessageQueue.%23ctor%2A>构造函数创建类的新实例 <xref:System.Messaging.MessageQueue> ; 它不会创建新的 "消息队列" 队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-195">The <xref:System.Messaging.MessageQueue.%23ctor%2A> constructor creates a new instance of the <xref:System.Messaging.MessageQueue> class; it does not create a new Message Queuing queue.</span></span> <span data-ttu-id="b3203-196">若要在消息队列中创建新队列，请使用 <xref:System.Messaging.MessageQueue.Create%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-196">To create a new queue in Message Queuing, use <xref:System.Messaging.MessageQueue.Create%28System.String%29>.</span></span>  
  
 <span data-ttu-id="b3203-197">参数的语法 `path` 取决于队列的类型。</span><span class="sxs-lookup"><span data-stu-id="b3203-197">The syntax of the `path` parameter depends on the type of queue.</span></span>  
  
|<span data-ttu-id="b3203-198">队列类型</span><span class="sxs-lookup"><span data-stu-id="b3203-198">Queue type</span></span>|<span data-ttu-id="b3203-199">语法</span><span class="sxs-lookup"><span data-stu-id="b3203-199">Syntax</span></span>|  
|----------------|------------|  
|<span data-ttu-id="b3203-200">公用队列</span><span class="sxs-lookup"><span data-stu-id="b3203-200">Public queue</span></span>|`MachineName`\\`QueueName`|  
|<span data-ttu-id="b3203-201">专用队列</span><span class="sxs-lookup"><span data-stu-id="b3203-201">Private queue</span></span>|`MachineName`\\`Private$`\\`QueueName`|  
|<span data-ttu-id="b3203-202">日志队列</span><span class="sxs-lookup"><span data-stu-id="b3203-202">Journal queue</span></span>|`MachineName`\\`QueueName`\\`Journal$`|  
|<span data-ttu-id="b3203-203">计算机日志队列</span><span class="sxs-lookup"><span data-stu-id="b3203-203">Machine journal queue</span></span>|`MachineName`\\`Journal$`|  
|<span data-ttu-id="b3203-204">计算机死信队列</span><span class="sxs-lookup"><span data-stu-id="b3203-204">Machine dead-letter queue</span></span>|`MachineName`\\`Deadletter$`|  
|<span data-ttu-id="b3203-205">计算机事务性死信队列</span><span class="sxs-lookup"><span data-stu-id="b3203-205">Machine transactional dead-letter queue</span></span>|`MachineName`\\`XactDeadletter$`|  
  
 <span data-ttu-id="b3203-206">或者，您可以使用 "消息队列" 队列的格式名称或标签来描述队列路径。</span><span class="sxs-lookup"><span data-stu-id="b3203-206">Alternatively, you can use the format name or label of a Message Queuing queue to describe the queue path.</span></span>  
  
|<span data-ttu-id="b3203-207">参考</span><span class="sxs-lookup"><span data-stu-id="b3203-207">Reference</span></span>|<span data-ttu-id="b3203-208">语法</span><span class="sxs-lookup"><span data-stu-id="b3203-208">Syntax</span></span>|<span data-ttu-id="b3203-209">示例</span><span class="sxs-lookup"><span data-stu-id="b3203-209">Example</span></span>|  
|---------------|------------|-------------|  
|<span data-ttu-id="b3203-210">格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-210">Format name</span></span>|<span data-ttu-id="b3203-211">`FormatName:` [ *格式名* ]</span><span class="sxs-lookup"><span data-stu-id="b3203-211">`FormatName:` [ *format name* ]</span></span>|<span data-ttu-id="b3203-212">`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112</span><span class="sxs-lookup"><span data-stu-id="b3203-212">`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112</span></span><br /><br /> <span data-ttu-id="b3203-213">`FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`</span><span class="sxs-lookup"><span data-stu-id="b3203-213">`FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`</span></span><br /><br /> <span data-ttu-id="b3203-214">`FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`</span><span class="sxs-lookup"><span data-stu-id="b3203-214">`FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`</span></span><br /><br /> <span data-ttu-id="b3203-215">`FormatName:DIRECT=OS:` `MachineName`\\`QueueName`</span><span class="sxs-lookup"><span data-stu-id="b3203-215">`FormatName:DIRECT=OS:` `MachineName`\\`QueueName`</span></span>|  
|<span data-ttu-id="b3203-216">Label</span><span class="sxs-lookup"><span data-stu-id="b3203-216">Label</span></span>|<span data-ttu-id="b3203-217">`Label:` [ *标签* ]</span><span class="sxs-lookup"><span data-stu-id="b3203-217">`Label:` [ *label* ]</span></span>|<span data-ttu-id="b3203-218">`Label:` TheLabel</span><span class="sxs-lookup"><span data-stu-id="b3203-218">`Label:` TheLabel</span></span>|  
  
 <span data-ttu-id="b3203-219">若要脱机工作，必须使用格式名语法，而不是友好名称语法。</span><span class="sxs-lookup"><span data-stu-id="b3203-219">To work offline, you must use the format name syntax, rather than the friendly name syntax.</span></span> <span data-ttu-id="b3203-220">否则，会引发异常，因为 Active Directory 所在的主域控制器 () 不可用于解析格式名称的路径。</span><span class="sxs-lookup"><span data-stu-id="b3203-220">Otherwise, an exception is thrown because the primary domain controller (on which Active Directory resides) is not available to resolve the path to the format name.</span></span>  
  
 <span data-ttu-id="b3203-221">如果 <xref:System.Messaging.MessageQueue> 打开的队列的 `sharedModeDenyReceive` 参数设置为，则 `true` <xref:System.Messaging.MessageQueue> 随后尝试从队列中读取的任何都将生成， <xref:System.Messaging.MessageQueueException> 因为存在共享冲突。</span><span class="sxs-lookup"><span data-stu-id="b3203-221">If a <xref:System.Messaging.MessageQueue> opens a queue with the `sharedModeDenyReceive` parameter set to `true`, any <xref:System.Messaging.MessageQueue> that subsequently tries to read from the queue generates a <xref:System.Messaging.MessageQueueException> because of a sharing violation.</span></span> <span data-ttu-id="b3203-222"><xref:System.Messaging.MessageQueueException>如果 <xref:System.Messaging.MessageQueue> 尝试以独占模式访问队列，而另一个 <xref:System.Messaging.MessageQueue> 已具有对队列的非独占访问权限，则也会引发。</span><span class="sxs-lookup"><span data-stu-id="b3203-222">A <xref:System.Messaging.MessageQueueException> is also thrown if a <xref:System.Messaging.MessageQueue> tries to access the queue in exclusive mode while another <xref:System.Messaging.MessageQueue> already has non-exclusive access to the queue.</span></span>  
  
 <span data-ttu-id="b3203-223">下表显示了实例的初始属性值 <xref:System.Messaging.MessageQueue> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-223">The following table shows initial property values for an instance of <xref:System.Messaging.MessageQueue>.</span></span> <span data-ttu-id="b3203-224">这些值基于 "消息队列" 队列的属性，具有参数指定的路径 `path` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-224">These values are based on the properties of the Message Queuing queue, with the path specified by the `path` parameter.</span></span>  
  
|<span data-ttu-id="b3203-225">Property</span><span class="sxs-lookup"><span data-stu-id="b3203-225">Property</span></span>|<span data-ttu-id="b3203-226">初始值</span><span class="sxs-lookup"><span data-stu-id="b3203-226">Initial value</span></span>|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|<span data-ttu-id="b3203-227">`false`。</span><span class="sxs-lookup"><span data-stu-id="b3203-227">`false`.</span></span>|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|<span data-ttu-id="b3203-228">0.</span><span class="sxs-lookup"><span data-stu-id="b3203-228">0.</span></span>|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<span data-ttu-id="b3203-229"><xref:System.Guid.Empty>。</span><span class="sxs-lookup"><span data-stu-id="b3203-229"><xref:System.Guid.Empty>.</span></span>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|<span data-ttu-id="b3203-230">由类的无参数构造函数设置的值 <xref:System.Messaging.DefaultPropertiesToSend> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-230">The values set by the parameterless constructor of the <xref:System.Messaging.DefaultPropertiesToSend> class.</span></span>|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|<span data-ttu-id="b3203-231">`true`如果 "消息队列" 队列的隐私级别设置为 "正文"，则为否则为 `false` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-231">`true`, if the Message Queuing queue's privacy level setting is "Body"; otherwise, `false`.</span></span>|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<span data-ttu-id="b3203-232"><xref:System.Messaging.XmlMessageFormatter>。</span><span class="sxs-lookup"><span data-stu-id="b3203-232"><xref:System.Messaging.XmlMessageFormatter>.</span></span>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<span data-ttu-id="b3203-233"><xref:System.String.Empty>。</span><span class="sxs-lookup"><span data-stu-id="b3203-233"><xref:System.String.Empty>.</span></span>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|<span data-ttu-id="b3203-234">"消息队列" 队列的 "计算机名" 属性的值。</span><span class="sxs-lookup"><span data-stu-id="b3203-234">The value of the Message Queuing queue's computer name property.</span></span>|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<span data-ttu-id="b3203-235"><xref:System.Messaging.MessageQueue.InfiniteQueueSize>。</span><span class="sxs-lookup"><span data-stu-id="b3203-235"><xref:System.Messaging.MessageQueue.InfiniteQueueSize>.</span></span>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<span data-ttu-id="b3203-236"><xref:System.Messaging.MessageQueue.InfiniteQueueSize>。</span><span class="sxs-lookup"><span data-stu-id="b3203-236"><xref:System.Messaging.MessageQueue.InfiniteQueueSize>.</span></span>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|<span data-ttu-id="b3203-237">由类的无参数构造函数设置的值 <xref:System.Messaging.MessagePropertyFilter> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-237">The values set by the parameterless constructor of the <xref:System.Messaging.MessagePropertyFilter> class.</span></span>|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<span data-ttu-id="b3203-238"><xref:System.String.Empty>如果构造函数未设置，则为。</span><span class="sxs-lookup"><span data-stu-id="b3203-238"><xref:System.String.Empty>, if not set by the constructor.</span></span>|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<span data-ttu-id="b3203-239"><xref:System.String.Empty>如果构造函数未设置，则为。</span><span class="sxs-lookup"><span data-stu-id="b3203-239"><xref:System.String.Empty>, if not set by the constructor.</span></span>|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|<span data-ttu-id="b3203-240">`sharedModeDenyReceive` 参数的值。</span><span class="sxs-lookup"><span data-stu-id="b3203-240">The value of the `sharedModeDenyReceive` parameter.</span></span>|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|<span data-ttu-id="b3203-241">`true`如果启用了消息队列对象的日志设置，则为;否则为 `false` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-241">`true`, if the Message Queuing object's journal setting is enabled; otherwise, `false`.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-242">下面的代码示例创建一个 <xref:System.Messaging.MessageQueue> 具有独占访问权限的新，设置其路径，并将消息发送到队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-242">The following code example creates a new <xref:System.Messaging.MessageQueue> with exclusive access, sets its path, and sends a message to the queue.</span></span>  
  
 [!code-cpp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-243"><see cref="P:System.Messaging.MessageQueue.Path" /> 属性无效，很可能因为尚未设置该属性。</span><span class="sxs-lookup"><span data-stu-id="b3203-243">The <see cref="P:System.Messaging.MessageQueue.Path" /> property is not valid, possibly because it has not been set.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b3203-244">此 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列的位置，它对于本地计算机可以是“.”。</span><span class="sxs-lookup"><span data-stu-id="b3203-244">The location of the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />, which can be "." for the local computer.</span></span></param>
        <param name="accessMode"><span data-ttu-id="b3203-245"><see cref="T:System.Messaging.QueueAccessMode" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="b3203-245">One of the <see cref="T:System.Messaging.QueueAccessMode" /> values.</span></span></param>
        <summary><span data-ttu-id="b3203-246">初始化 <see cref="T:System.Messaging.MessageQueue" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="b3203-246">Initializes a new instance of the <see cref="T:System.Messaging.MessageQueue" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="enableCache" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b3203-247">此 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列的位置，它对于本地计算机可以是“.”。</span><span class="sxs-lookup"><span data-stu-id="b3203-247">The location of the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />, which can be "." for the local computer.</span></span></param>
        <param name="sharedModeDenyReceive"><span data-ttu-id="b3203-248"><see langword="true" />，授予访问该队列的第一个应用程序独占读访问权；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-248"><see langword="true" /> to grant exclusive read access to the first application that accesses the queue; otherwise, <see langword="false" />.</span></span></param>
        <param name="enableCache"><span data-ttu-id="b3203-249">如果创建和使用连接缓存，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-249"><see langword="true" /> to create and use a connection cache; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="b3203-250">初始化 <see cref="T:System.Messaging.MessageQueue" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="b3203-250">Initializes a new instance of the <see cref="T:System.Messaging.MessageQueue" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="b3203-251">下面的代码示例创建一个 <xref:System.Messaging.MessageQueue> 具有独占读取访问权限且已启用连接缓存的新。</span><span class="sxs-lookup"><span data-stu-id="b3203-251">The following code example creates a new <xref:System.Messaging.MessageQueue> with exclusive read access and with connection caching enabled.</span></span>  
  
 [!code-cpp[MessageQueue4#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="enableCache" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b3203-252">此 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列的位置，它对于本地计算机可以是“.”。</span><span class="sxs-lookup"><span data-stu-id="b3203-252">The location of the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />, which can be "." for the local computer.</span></span></param>
        <param name="sharedModeDenyReceive"><span data-ttu-id="b3203-253"><see langword="true" />，授予访问该队列的第一个应用程序独占读访问权；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-253"><see langword="true" /> to grant exclusive read access to the first application that accesses the queue; otherwise, <see langword="false" />.</span></span></param>
        <param name="enableCache"><span data-ttu-id="b3203-254">如果创建和使用连接缓存，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-254"><see langword="true" /> to create and use a connection cache; otherwise, <see langword="false" />.</span></span></param>
        <param name="accessMode"><span data-ttu-id="b3203-255"><see cref="T:System.Messaging.QueueAccessMode" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="b3203-255">One of the <see cref="T:System.Messaging.QueueAccessMode" /> values.</span></span></param>
        <summary><span data-ttu-id="b3203-256">初始化 <see cref="T:System.Messaging.MessageQueue" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="b3203-256">Initializes a new instance of the <see cref="T:System.Messaging.MessageQueue" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessMode As QueueAccessMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::QueueAccessMode AccessMode { System::Messaging::QueueAccessMode get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessMode : System.Messaging.QueueAccessMode" Usage="System.Messaging.MessageQueue.AccessMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-257">获取一个值，该值指示队列的访问模式。</span><span class="sxs-lookup"><span data-stu-id="b3203-257">Gets a value that indicates the access mode for the queue.</span></span></summary>
        <value><span data-ttu-id="b3203-258"><see cref="T:System.Messaging.QueueAccessMode" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="b3203-258">One of the <see cref="T:System.Messaging.QueueAccessMode" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-259">队列的默认访问模式为 `QueueAccessMode.SendAndReceive` ，除非在调用构造函数时另行指定。</span><span class="sxs-lookup"><span data-stu-id="b3203-259">The default access mode for a queue is `QueueAccessMode.SendAndReceive`, unless you specify otherwise when calling the constructor.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberSignature Language="VB.NET" Value="Public Property Authenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Authenticate : bool with get, set" Usage="System.Messaging.MessageQueue.Authenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_Authenticate")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_Authenticate")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-260">获取或设置一个值，该值指示队列是否仅接受经过身份验证的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-260">Gets or sets a value that indicates whether the queue accepts only authenticated messages.</span></span></summary>
        <value><span data-ttu-id="b3203-261">如果队列仅接受已经过身份验证的消息，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-261"><see langword="true" /> if the queue accepts only authenticated messages; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="b3203-262">默认值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-262">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-263">消息身份验证提供了一种方法，可确保消息的完整性并验证发送消息的用户。</span><span class="sxs-lookup"><span data-stu-id="b3203-263">Message authentication provides a way to ensure message integrity and to verify who sent the message.</span></span> <span data-ttu-id="b3203-264">为了请求身份验证，发送应用程序会设置消息的身份验证级别。</span><span class="sxs-lookup"><span data-stu-id="b3203-264">To request authentication, the sending application sets the message's authentication level.</span></span>  
  
 <span data-ttu-id="b3203-265">当你将设置为时， <xref:System.Messaging.MessageQueue.Authenticate%2A> `true` 将限制对服务器上的队列的访问，而不仅限于此 <xref:System.Messaging.MessageQueue> 实例。</span><span class="sxs-lookup"><span data-stu-id="b3203-265">When you set <xref:System.Messaging.MessageQueue.Authenticate%2A> to `true`, you are restricting access to the queue on the server, not only to this <xref:System.Messaging.MessageQueue> instance.</span></span> <span data-ttu-id="b3203-266">针对同一个 "消息队列" 队列的所有客户端都将受到影响。</span><span class="sxs-lookup"><span data-stu-id="b3203-266">All clients working against the same Message Queuing queue will be affected.</span></span>  
  
 <span data-ttu-id="b3203-267">仅接受经过身份验证的消息的队列将拒绝未经过身份验证的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-267">A queue that accepts only authenticated messages will reject a non-authenticated message.</span></span> <span data-ttu-id="b3203-268">若要请求拒绝消息，发送应用程序可以设置消息的 <xref:System.Messaging.Message.AcknowledgeType%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="b3203-268">To request notification of message rejection, a sending application can set the <xref:System.Messaging.Message.AcknowledgeType%2A> property of the message.</span></span> <span data-ttu-id="b3203-269">由于不存在消息拒绝的其他指示，因此发送应用程序可能会丢失消息，除非你请求将该消息发送到死信队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-269">Because no other indication of message rejection exists, the sending application can lose the message unless you request that it be sent to the dead-letter queue.</span></span>  
  
 <span data-ttu-id="b3203-270">下表显示了此属性在各种工作组模式下是否可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-270">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-271">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-271">Workgroup mode</span></span>|<span data-ttu-id="b3203-272">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-272">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-273">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-273">Local computer</span></span>|<span data-ttu-id="b3203-274">是</span><span class="sxs-lookup"><span data-stu-id="b3203-274">Yes</span></span>|  
|<span data-ttu-id="b3203-275">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-275">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-276">是</span><span class="sxs-lookup"><span data-stu-id="b3203-276">Yes</span></span>|  
|<span data-ttu-id="b3203-277">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-277">Remote computer</span></span>|<span data-ttu-id="b3203-278">否</span><span class="sxs-lookup"><span data-stu-id="b3203-278">No</span></span>|  
|<span data-ttu-id="b3203-279">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-279">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-280">否</span><span class="sxs-lookup"><span data-stu-id="b3203-280">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-281">下面的代码示例获取并设置消息队列属性的值 <xref:System.Messaging.MessageQueue.Authenticate%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-281">The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.Authenticate%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-282">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-282">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public Property BasePriority As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short BasePriority { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int16 with get, set" Usage="System.Messaging.MessageQueue.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_BasePriority")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_BasePriority")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-283">获取或设置基优先级，“消息队列”使用该基优先级在网络上传送公共队列的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-283">Gets or sets the base priority Message Queuing uses to route a public queue's messages over the network.</span></span></summary>
        <value><span data-ttu-id="b3203-284">发送到（公共）队列的所有消息的单个基本优先级。</span><span class="sxs-lookup"><span data-stu-id="b3203-284">The single base priority for all messages sent to the (public) queue.</span></span> <span data-ttu-id="b3203-285">默认值为零 (0)。</span><span class="sxs-lookup"><span data-stu-id="b3203-285">The default is zero (0).</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-286">消息队列的基本优先级指定消息发送到该队列的消息在通过网络传输时的处理方式。</span><span class="sxs-lookup"><span data-stu-id="b3203-286">A message queue's base priority specifies how a message en route to that queue is treated as it travels through the network.</span></span> <span data-ttu-id="b3203-287">您可以设置 <xref:System.Messaging.MessageQueue.BasePriority%2A> 属性，以对发送到指定队列的所有消息授予更高或较低的优先级。</span><span class="sxs-lookup"><span data-stu-id="b3203-287">You can set the <xref:System.Messaging.MessageQueue.BasePriority%2A> property to confer a higher or lower priority to all messages sent to the specified queue than those sent to other queues.</span></span> <span data-ttu-id="b3203-288">设置此属性将修改 "消息队列" 队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-288">Setting this property modifies the Message Queuing queue.</span></span> <span data-ttu-id="b3203-289">因此， <xref:System.Messaging.MessageQueue> 此更改会影响任何其他实例。</span><span class="sxs-lookup"><span data-stu-id="b3203-289">Therefore, any other <xref:System.Messaging.MessageQueue> instances are affected by the change.</span></span>  
  
 <span data-ttu-id="b3203-290">消息队列 <xref:System.Messaging.MessageQueue.BasePriority%2A> 与 <xref:System.Messaging.Message.Priority%2A> 消息的属性无关，后者指定传入消息在队列中的排列顺序。</span><span class="sxs-lookup"><span data-stu-id="b3203-290">A message queue's <xref:System.Messaging.MessageQueue.BasePriority%2A> is not related to the <xref:System.Messaging.Message.Priority%2A> property of a message, which specifies the order in which an incoming message is placed in the queue.</span></span>  
  
 <span data-ttu-id="b3203-291"><xref:System.Messaging.MessageQueue.BasePriority%2A> 仅适用于其路径是使用格式名称指定的公用队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-291"><xref:System.Messaging.MessageQueue.BasePriority%2A> applies only to public queues whose paths are specified using the format name.</span></span> <span data-ttu-id="b3203-292">专用队列的基本优先级始终为零 (0) 。</span><span class="sxs-lookup"><span data-stu-id="b3203-292">The base priority of a private queue is always zero (0).</span></span>  
  
 <span data-ttu-id="b3203-293">下表显示了此属性在各种工作组模式下是否可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-293">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-294">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-294">Workgroup mode</span></span>|<span data-ttu-id="b3203-295">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-295">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-296">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-296">Local computer</span></span>|<span data-ttu-id="b3203-297">是</span><span class="sxs-lookup"><span data-stu-id="b3203-297">Yes</span></span>|  
|<span data-ttu-id="b3203-298">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-298">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-299">是</span><span class="sxs-lookup"><span data-stu-id="b3203-299">Yes</span></span>|  
|<span data-ttu-id="b3203-300">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-300">Remote computer</span></span>|<span data-ttu-id="b3203-301">否</span><span class="sxs-lookup"><span data-stu-id="b3203-301">No</span></span>|  
|<span data-ttu-id="b3203-302">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-302">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-303">否</span><span class="sxs-lookup"><span data-stu-id="b3203-303">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-304">下面的代码示例获取并设置消息队列属性的值 <xref:System.Messaging.MessageQueue.BasePriority%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-304">The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.BasePriority%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-305">基优先级被设置为无效值。</span><span class="sxs-lookup"><span data-stu-id="b3203-305">The base priority was set to an invalid value.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-306">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-306">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPeek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe><span data-ttu-id="b3203-307">方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="b3203-307">The method is not thread safe.</span></span></threadsafe>
        <summary><span data-ttu-id="b3203-308">通过通知“消息队列”开始查看消息并在完成后通知事件处理程序，启动一个异步查看操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-308">Initiates an asynchronous peek operation by telling Message Queuing to begin peeking a message and notify the event handler when finished.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek();" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : unit -&gt; IAsyncResult" Usage="messageQueue.BeginPeek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b3203-309">启动一个未设置超时的异步查看操作。直到队列中有可用消息时，操作才会完成。</span><span class="sxs-lookup"><span data-stu-id="b3203-309">Initiates an asynchronous peek operation that has no time-out. The operation is not complete until a message becomes available in the queue.</span></span></summary>
        <returns><span data-ttu-id="b3203-310">该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</span><span class="sxs-lookup"><span data-stu-id="b3203-310">The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-311">在异步处理过程中， <xref:System.Messaging.MessageQueue.BeginPeek%2A> <xref:System.Messaging.MessageQueue.PeekCompleted> 当消息在队列中可用时，使用来引发事件。</span><span class="sxs-lookup"><span data-stu-id="b3203-311">In asynchronous processing, you use <xref:System.Messaging.MessageQueue.BeginPeek%2A> to raise the <xref:System.Messaging.MessageQueue.PeekCompleted> event when a message becomes available in the queue.</span></span>  
  
 <span data-ttu-id="b3203-312"><xref:System.Messaging.MessageQueue.PeekCompleted> 如果队列中已经存在消息，也会引发。</span><span class="sxs-lookup"><span data-stu-id="b3203-312"><xref:System.Messaging.MessageQueue.PeekCompleted> is also raised if a message already exists in the queue.</span></span>  
  
 <span data-ttu-id="b3203-313">若要使用 <xref:System.Messaging.MessageQueue.BeginPeek%2A> ，请创建一个事件处理程序，用于处理异步操作的结果，并将其与事件委托相关联。</span><span class="sxs-lookup"><span data-stu-id="b3203-313">To use <xref:System.Messaging.MessageQueue.BeginPeek%2A>, create an event handler that processes the results of the asynchronous operation, and associate it with your event delegate.</span></span> <span data-ttu-id="b3203-314"><xref:System.Messaging.MessageQueue.BeginPeek%2A> 启动异步查看操作; <xref:System.Messaging.MessageQueue> <xref:System.Messaging.MessageQueue.PeekCompleted> 当消息到达队列时，会通过引发事件通知。</span><span class="sxs-lookup"><span data-stu-id="b3203-314"><xref:System.Messaging.MessageQueue.BeginPeek%2A> initiates an asynchronous peek operation; the <xref:System.Messaging.MessageQueue> is notified, through the raising of the <xref:System.Messaging.MessageQueue.PeekCompleted> event, when a message arrives in the queue.</span></span> <span data-ttu-id="b3203-315"><xref:System.Messaging.MessageQueue>然后，可以通过调用 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 或通过使用检索结果来访问消息 <xref:System.Messaging.PeekCompletedEventArgs> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-315">The <xref:System.Messaging.MessageQueue> can then access the message by calling <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> or by retrieving the result using the <xref:System.Messaging.PeekCompletedEventArgs>.</span></span>  
  
 <span data-ttu-id="b3203-316"><xref:System.Messaging.MessageQueue.BeginPeek%2A>方法会立即返回，但在调用事件处理程序之前，不会完成异步操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-316">The <xref:System.Messaging.MessageQueue.BeginPeek%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</span></span>  
  
 <span data-ttu-id="b3203-317">由于 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 是异步的，因此你可以调用它来查看队列，而不会阻止当前的执行线程。</span><span class="sxs-lookup"><span data-stu-id="b3203-317">Because <xref:System.Messaging.MessageQueue.BeginPeek%2A> is asynchronous, you can call it to peek the queue without blocking the current thread of execution.</span></span> <span data-ttu-id="b3203-318">若要同步查看队列，请使用 <xref:System.Messaging.MessageQueue.Peek%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-318">To synchronously peek the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.</span></span>  
  
 <span data-ttu-id="b3203-319">异步操作完成后，可以 <xref:System.Messaging.MessageQueue.BeginPeek%2A> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 在事件处理程序中调用或再次运行以继续接收通知。</span><span class="sxs-lookup"><span data-stu-id="b3203-319">Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.</span></span>  
  
 <span data-ttu-id="b3203-320">返回的将 <xref:System.IAsyncResult> <xref:System.Messaging.MessageQueue.BeginPeek%2A> 标识该方法启动的异步操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-320">The <xref:System.IAsyncResult> that <xref:System.Messaging.MessageQueue.BeginPeek%2A> returns identifies the asynchronous operation that the method started.</span></span> <span data-ttu-id="b3203-321">可以在 <xref:System.IAsyncResult> 操作的整个生存期内使用此方法，不过，在调用之前，通常不使用此方法 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-321">You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> is called.</span></span> <span data-ttu-id="b3203-322">但是，如果您启动多个异步操作，则可以将它们的 <xref:System.IAsyncResult> 值放在数组中，并指定是否等待所有操作或任何操作完成。</span><span class="sxs-lookup"><span data-stu-id="b3203-322">However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete.</span></span> <span data-ttu-id="b3203-323">在这种情况下，可以使用 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 的属性 <xref:System.IAsyncResult> 来标识已完成的操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-323">In this case, you use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.</span></span>  
  
 <span data-ttu-id="b3203-324">如果 <xref:System.Messaging.MessageQueue.CanRead%2A> 为 `false` ，则引发完成事件，但在调用时将引发异常 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-324">If <xref:System.Messaging.MessageQueue.CanRead%2A> is `false`, the completion event is raised, but an exception will be thrown when calling <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.</span></span>  
  
 <span data-ttu-id="b3203-325">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-325">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-326">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-326">Workgroup mode</span></span>|<span data-ttu-id="b3203-327">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-327">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-328">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-328">Local computer</span></span>|<span data-ttu-id="b3203-329">是</span><span class="sxs-lookup"><span data-stu-id="b3203-329">Yes</span></span>|  
|<span data-ttu-id="b3203-330">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-330">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-331">是</span><span class="sxs-lookup"><span data-stu-id="b3203-331">Yes</span></span>|  
|<span data-ttu-id="b3203-332">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-332">Remote computer</span></span>|<span data-ttu-id="b3203-333">否</span><span class="sxs-lookup"><span data-stu-id="b3203-333">No</span></span>|  
|<span data-ttu-id="b3203-334">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-334">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-335">是</span><span class="sxs-lookup"><span data-stu-id="b3203-335">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-336">下面的代码示例创建一个名为的事件处理程序 `MyPeekCompleted` ，将其附加到 <xref:System.Messaging.MessageQueue.PeekCompleted> 事件处理程序委托，并调用 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 以对位于路径 ".\myQueue" 的队列启动异步查看操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-336">The following code example creates an event handler named `MyPeekCompleted`, attaches it to the <xref:System.Messaging.MessageQueue.PeekCompleted> event handler delegate, and calls <xref:System.Messaging.MessageQueue.BeginPeek%2A> to initiate an asynchronous peek operation on the queue that is located at the path ".\myQueue".</span></span> <span data-ttu-id="b3203-337"><xref:System.Messaging.MessageQueue.PeekCompleted>引发事件时，该示例将扫视消息，并将其正文写入屏幕。</span><span class="sxs-lookup"><span data-stu-id="b3203-337">When a <xref:System.Messaging.MessageQueue.PeekCompleted> event is raised, the example peeks the message and writes its body to the screen.</span></span> <span data-ttu-id="b3203-338">然后，该示例 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 再次调用以启动新的异步查看操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-338">The example then calls <xref:System.Messaging.MessageQueue.BeginPeek%2A> again to initiate a new asynchronous peek operation.</span></span>  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-339">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-339">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="b3203-340">方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="b3203-340">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginPeek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="b3203-341">一个 <see cref="T:System.TimeSpan" /> 指示等待消息变为可用所用的时间间隔。</span><span class="sxs-lookup"><span data-stu-id="b3203-341">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</span></span></param>
        <summary><span data-ttu-id="b3203-342">启动具有指定超时的异步查看操作。直到队列中有可用消息或发生超时，操作才会完成。</span><span class="sxs-lookup"><span data-stu-id="b3203-342">Initiates an asynchronous peek operation that has a specified time-out. The operation is not complete until either a message becomes available in the queue or the time-out occurs.</span></span></summary>
        <returns><span data-ttu-id="b3203-343">该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</span><span class="sxs-lookup"><span data-stu-id="b3203-343">The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-344">在异步处理过程中， <xref:System.Messaging.MessageQueue.BeginPeek%2A> <xref:System.Messaging.MessageQueue.PeekCompleted> 当消息在队列中可用或指定的时间间隔到期时，使用来引发事件。</span><span class="sxs-lookup"><span data-stu-id="b3203-344">In asynchronous processing, you use <xref:System.Messaging.MessageQueue.BeginPeek%2A> to raise the <xref:System.Messaging.MessageQueue.PeekCompleted> event when a message becomes available in the queue or when the specified interval of time has expired.</span></span>  
  
 <span data-ttu-id="b3203-345"><xref:System.Messaging.MessageQueue.PeekCompleted> 如果队列中已经存在消息，也会引发。</span><span class="sxs-lookup"><span data-stu-id="b3203-345"><xref:System.Messaging.MessageQueue.PeekCompleted> is also raised if a message already exists in the queue.</span></span>  
  
 <span data-ttu-id="b3203-346">若要使用 <xref:System.Messaging.MessageQueue.BeginPeek%2A> ，请创建一个事件处理程序，用于处理异步操作的结果，并将其与事件委托相关联。</span><span class="sxs-lookup"><span data-stu-id="b3203-346">To use <xref:System.Messaging.MessageQueue.BeginPeek%2A>, create an event handler that processes the results of the asynchronous operation, and associate it with your event delegate.</span></span> <span data-ttu-id="b3203-347"><xref:System.Messaging.MessageQueue.BeginPeek%2A> 启动异步查看操作; <xref:System.Messaging.MessageQueue> <xref:System.Messaging.MessageQueue.PeekCompleted> 当消息到达队列时，会通过引发事件通知。</span><span class="sxs-lookup"><span data-stu-id="b3203-347"><xref:System.Messaging.MessageQueue.BeginPeek%2A> initiates an asynchronous peek operation; the <xref:System.Messaging.MessageQueue> is notified, through the raising of the <xref:System.Messaging.MessageQueue.PeekCompleted> event, when a message arrives in the queue.</span></span> <span data-ttu-id="b3203-348"><xref:System.Messaging.MessageQueue>然后，可以通过调用 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 或通过使用检索结果来访问消息 <xref:System.Messaging.PeekCompletedEventArgs> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-348">The <xref:System.Messaging.MessageQueue> can then access the message by calling <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> or by retrieving the result using the <xref:System.Messaging.PeekCompletedEventArgs>.</span></span>  
  
 <span data-ttu-id="b3203-349"><xref:System.Messaging.MessageQueue.BeginPeek%2A>方法会立即返回，但在调用事件处理程序之前，不会完成异步操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-349">The <xref:System.Messaging.MessageQueue.BeginPeek%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</span></span>  
  
 <span data-ttu-id="b3203-350">由于 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 是异步的，因此你可以调用它来查看队列，而不会阻止当前的执行线程。</span><span class="sxs-lookup"><span data-stu-id="b3203-350">Because <xref:System.Messaging.MessageQueue.BeginPeek%2A> is asynchronous, you can call it to peek the queue without blocking the current thread of execution.</span></span> <span data-ttu-id="b3203-351">若要同步查看队列，请使用 <xref:System.Messaging.MessageQueue.Peek%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-351">To synchronously peek the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.</span></span>  
  
 <span data-ttu-id="b3203-352">异步操作完成后，可以 <xref:System.Messaging.MessageQueue.BeginPeek%2A> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 在事件处理程序中调用或再次运行以继续接收通知。</span><span class="sxs-lookup"><span data-stu-id="b3203-352">Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.</span></span>  
  
 <span data-ttu-id="b3203-353">返回的将 <xref:System.IAsyncResult> <xref:System.Messaging.MessageQueue.BeginPeek%2A> 标识该方法启动的异步操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-353">The <xref:System.IAsyncResult> that <xref:System.Messaging.MessageQueue.BeginPeek%2A> returns identifies the asynchronous operation that the method started.</span></span> <span data-ttu-id="b3203-354">可以在 <xref:System.IAsyncResult> 操作的整个生存期内使用此方法，不过，在调用之前，通常不使用此方法 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-354">You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> is called.</span></span> <span data-ttu-id="b3203-355">但是，如果您启动多个异步操作，则可以将它们的 <xref:System.IAsyncResult> 值放在数组中，并指定是否等待所有操作或任何操作完成。</span><span class="sxs-lookup"><span data-stu-id="b3203-355">However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete.</span></span> <span data-ttu-id="b3203-356">在这种情况下，可以使用 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 的属性 <xref:System.IAsyncResult> 来标识已完成的操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-356">In this case, you use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.</span></span>  
  
 <span data-ttu-id="b3203-357">此重载指定超时。如果参数指定的间隔 `timeout` 过期，此组件将引发 <xref:System.Messaging.MessageQueue.PeekCompleted> 事件。</span><span class="sxs-lookup"><span data-stu-id="b3203-357">This overload specifies a time-out. If the interval specified by the `timeout` parameter expires, this component raises the <xref:System.Messaging.MessageQueue.PeekCompleted> event.</span></span> <span data-ttu-id="b3203-358">由于不存在任何消息，对的后续调用 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 将引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-358">Because no message exists, a subsequent call to <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> will throw an exception.</span></span>  
  
 <span data-ttu-id="b3203-359">如果 <xref:System.Messaging.MessageQueue.CanRead%2A> 为 `false` ，则引发完成事件，但在调用时将引发异常 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-359">If <xref:System.Messaging.MessageQueue.CanRead%2A> is `false`, the completion event is raised, but an exception will be thrown when calling <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.</span></span>  
  
 <span data-ttu-id="b3203-360">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-360">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-361">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-361">Workgroup mode</span></span>|<span data-ttu-id="b3203-362">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-362">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-363">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-363">Local computer</span></span>|<span data-ttu-id="b3203-364">是</span><span class="sxs-lookup"><span data-stu-id="b3203-364">Yes</span></span>|  
|<span data-ttu-id="b3203-365">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-365">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-366">是</span><span class="sxs-lookup"><span data-stu-id="b3203-366">Yes</span></span>|  
|<span data-ttu-id="b3203-367">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-367">Remote computer</span></span>|<span data-ttu-id="b3203-368">否</span><span class="sxs-lookup"><span data-stu-id="b3203-368">No</span></span>|  
|<span data-ttu-id="b3203-369">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-369">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-370">是</span><span class="sxs-lookup"><span data-stu-id="b3203-370">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-371">下面的代码示例使用队列路径 ".\myQueue" 创建异步查看操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-371">The following code example creates an asynchronous peek operation, using the queue path ".\myQueue".</span></span> <span data-ttu-id="b3203-372">它创建事件处理程序， `MyPeekCompleted` 并将其附加到 <xref:System.Messaging.MessageQueue.PeekCompleted> 事件处理程序委托。</span><span class="sxs-lookup"><span data-stu-id="b3203-372">It creates an event handler, `MyPeekCompleted`, and attaches it to the <xref:System.Messaging.MessageQueue.PeekCompleted> event handler delegate.</span></span> <span data-ttu-id="b3203-373"><xref:System.Messaging.MessageQueue.BeginPeek%2A> 在一分钟的超时时间内调用以启动异步查看操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-373"><xref:System.Messaging.MessageQueue.BeginPeek%2A> is called with a time-out of one minute, to initiate the asynchronous peek operation.</span></span> <span data-ttu-id="b3203-374">当 <xref:System.Messaging.MessageQueue.PeekCompleted> 引发事件或超时过期时，将检索消息（如果存在），并将其正文写入屏幕。</span><span class="sxs-lookup"><span data-stu-id="b3203-374">When a <xref:System.Messaging.MessageQueue.PeekCompleted> event is raised or the time-out expires, the message is retrieved if one exists, and its body is written to the screen.</span></span> <span data-ttu-id="b3203-375">然后 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 再次调用，以使用相同的超时启动新的异步查看操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-375">Then <xref:System.Messaging.MessageQueue.BeginPeek%2A> is called again to initiate a new asynchronous peek operation with the same time-out.</span></span>  
  
 [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-376">为 <paramref name="timeout" /> 参数指定的值无效。</span><span class="sxs-lookup"><span data-stu-id="b3203-376">The value specified for the <paramref name="timeout" /> parameter is not valid.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-377">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-377">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="b3203-378">方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="b3203-378">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="b3203-379">一个 <see cref="T:System.TimeSpan" /> 指示等待消息变为可用所用的时间间隔。</span><span class="sxs-lookup"><span data-stu-id="b3203-379">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</span></span></param>
        <param name="stateObject"><span data-ttu-id="b3203-380">应用程序指定的状态对象，包含与异步操作关联的信息。</span><span class="sxs-lookup"><span data-stu-id="b3203-380">A state object, specified by the application, that contains information associated with the asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="b3203-381">启动具有指定超时设定和指定状态对象的异步查看操作，此状态对象在操作的整个生存期内提供相关信息。</span><span class="sxs-lookup"><span data-stu-id="b3203-381">Initiates an asynchronous peek operation that has a specified time-out and a specified state object, which provides associated information throughout the operation's lifetime.</span></span> <span data-ttu-id="b3203-382">直到队列中出现消息时或发生超时时才完成操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-382">The operation is not complete until either a message becomes available in the queue or the time-out occurs.</span></span></summary>
        <returns><span data-ttu-id="b3203-383">该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</span><span class="sxs-lookup"><span data-stu-id="b3203-383">The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-384">在异步处理过程中， <xref:System.Messaging.MessageQueue.BeginPeek%2A> <xref:System.Messaging.MessageQueue.PeekCompleted> 当消息在队列中可用或指定的时间间隔到期时，使用来引发事件。</span><span class="sxs-lookup"><span data-stu-id="b3203-384">In asynchronous processing, you use <xref:System.Messaging.MessageQueue.BeginPeek%2A> to raise the <xref:System.Messaging.MessageQueue.PeekCompleted> event when a message becomes available in the queue or when the specified interval of time has expired.</span></span>  
  
 <span data-ttu-id="b3203-385"><xref:System.Messaging.MessageQueue.PeekCompleted> 如果队列中已经存在消息，也会引发。</span><span class="sxs-lookup"><span data-stu-id="b3203-385"><xref:System.Messaging.MessageQueue.PeekCompleted> is also raised if a message already exists in the queue.</span></span>  
  
 <span data-ttu-id="b3203-386">使用此重载将信息与将在操作的整个生存期内保留的操作相关联。</span><span class="sxs-lookup"><span data-stu-id="b3203-386">Use this overload to associate information with the operation that will be preserved throughout the operation's lifetime.</span></span> <span data-ttu-id="b3203-387">事件处理程序可以通过查看 <xref:System.IAsyncResult.AsyncState%2A> 与操作关联的的属性来访问此信息 <xref:System.IAsyncResult> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-387">The event handler can access this information by looking at the <xref:System.IAsyncResult.AsyncState%2A> property of the <xref:System.IAsyncResult> that is associated with the operation.</span></span>  
  
 <span data-ttu-id="b3203-388">若要使用 <xref:System.Messaging.MessageQueue.BeginPeek%2A> ，请创建一个事件处理程序，用于处理异步操作的结果，并将其与事件委托相关联。</span><span class="sxs-lookup"><span data-stu-id="b3203-388">To use <xref:System.Messaging.MessageQueue.BeginPeek%2A>, create an event handler that processes the results of the asynchronous operation, and associate it with your event delegate.</span></span> <span data-ttu-id="b3203-389"><xref:System.Messaging.MessageQueue.BeginPeek%2A> 启动异步查看操作; <xref:System.Messaging.MessageQueue> <xref:System.Messaging.MessageQueue.PeekCompleted> 当消息到达队列时，会通过引发事件通知。</span><span class="sxs-lookup"><span data-stu-id="b3203-389"><xref:System.Messaging.MessageQueue.BeginPeek%2A> initiates an asynchronous peek operation; the <xref:System.Messaging.MessageQueue> is notified, through the raising of the <xref:System.Messaging.MessageQueue.PeekCompleted> event, when a message arrives in the queue.</span></span> <span data-ttu-id="b3203-390"><xref:System.Messaging.MessageQueue>然后，可以通过调用 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 或通过使用检索结果来访问消息 <xref:System.Messaging.PeekCompletedEventArgs> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-390">The <xref:System.Messaging.MessageQueue> can then access the message by calling <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> or by retrieving the result using the <xref:System.Messaging.PeekCompletedEventArgs>.</span></span>  
  
 <span data-ttu-id="b3203-391"><xref:System.Messaging.MessageQueue.BeginPeek%2A>方法会立即返回，但在调用事件处理程序之前，不会完成异步操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-391">The <xref:System.Messaging.MessageQueue.BeginPeek%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</span></span>  
  
 <span data-ttu-id="b3203-392">由于 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 是异步的，因此你可以调用它来查看队列，而不会阻止当前的执行线程。</span><span class="sxs-lookup"><span data-stu-id="b3203-392">Because <xref:System.Messaging.MessageQueue.BeginPeek%2A> is asynchronous, you can call it to peek the queue without blocking the current thread of execution.</span></span> <span data-ttu-id="b3203-393">若要同步查看队列，请使用 <xref:System.Messaging.MessageQueue.Peek%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-393">To synchronously peek the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.</span></span>  
  
 <span data-ttu-id="b3203-394">异步操作完成后，可以 <xref:System.Messaging.MessageQueue.BeginPeek%2A> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 在事件处理程序中调用或再次运行以继续接收通知。</span><span class="sxs-lookup"><span data-stu-id="b3203-394">Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.</span></span>  
  
 <span data-ttu-id="b3203-395"><xref:System.Messaging.MessageQueue.BeginPeek%2A> 返回一个 <xref:System.IAsyncResult> ，它标识该方法启动的异步操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-395"><xref:System.Messaging.MessageQueue.BeginPeek%2A> returns a <xref:System.IAsyncResult> that identifies the asynchronous operation that the method started.</span></span> <span data-ttu-id="b3203-396">可以在 <xref:System.IAsyncResult> 操作的整个生存期内使用此方法，不过，在调用之前，通常不使用此方法 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-396">You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> is called.</span></span> <span data-ttu-id="b3203-397">但是，如果您启动多个异步操作，则可以将它们的 <xref:System.IAsyncResult> 值放在数组中，并指定是否等待所有操作或任何操作完成。</span><span class="sxs-lookup"><span data-stu-id="b3203-397">However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete.</span></span> <span data-ttu-id="b3203-398">在这种情况下，可以使用 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 的属性 <xref:System.IAsyncResult> 来标识已完成的操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-398">In this case, you use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.</span></span>  
  
 <span data-ttu-id="b3203-399">此重载指定超时和状态对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-399">This overload specifies a time-out and a state object.</span></span> <span data-ttu-id="b3203-400">如果参数指定的间隔 `timeout` 过期，此组件将引发 <xref:System.Messaging.MessageQueue.PeekCompleted> 事件。</span><span class="sxs-lookup"><span data-stu-id="b3203-400">If the interval specified by the `timeout` parameter expires, this component raises the <xref:System.Messaging.MessageQueue.PeekCompleted> event.</span></span> <span data-ttu-id="b3203-401">由于不存在任何消息，对的后续调用 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 将引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-401">Because no message exists, a subsequent call to <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> will throw an exception.</span></span>  
  
 <span data-ttu-id="b3203-402">状态对象将状态信息与操作相关联。</span><span class="sxs-lookup"><span data-stu-id="b3203-402">The state object associates state information with the operation.</span></span> <span data-ttu-id="b3203-403">例如，如果 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 多次调用来启动多个操作，则可以通过定义的单独状态对象标识每个操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-403">For example, if you call <xref:System.Messaging.MessageQueue.BeginPeek%2A> multiple times to initiate multiple operations, you can identify each operation through a separate state object that you define.</span></span> <span data-ttu-id="b3203-404">有关此方案的说明，请参阅 "示例" 部分。</span><span class="sxs-lookup"><span data-stu-id="b3203-404">For an illustration of this scenario, see the Example section.</span></span>  
  
 <span data-ttu-id="b3203-405">你还可以使用状态对象跨进程线程传递信息。</span><span class="sxs-lookup"><span data-stu-id="b3203-405">You can also use the state object to pass information across process threads.</span></span> <span data-ttu-id="b3203-406">如果线程已启动，但回调在异步方案中的其他线程上，则将对状态对象进行封送处理，并将其与事件中的信息一起传递回来。</span><span class="sxs-lookup"><span data-stu-id="b3203-406">If a thread is started but the callback is on a different thread in an asynchronous scenario, the state object is marshaled and passed back along with information from the event.</span></span>  
  
 <span data-ttu-id="b3203-407">如果 <xref:System.Messaging.MessageQueue.CanRead%2A> 为 `false` ，则引发完成事件，但在调用时将引发异常 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-407">If <xref:System.Messaging.MessageQueue.CanRead%2A> is `false`, the completion event is raised, but an exception will be thrown when calling <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.</span></span>  
  
 <span data-ttu-id="b3203-408">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-408">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-409">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-409">Workgroup mode</span></span>|<span data-ttu-id="b3203-410">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-410">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-411">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-411">Local computer</span></span>|<span data-ttu-id="b3203-412">是</span><span class="sxs-lookup"><span data-stu-id="b3203-412">Yes</span></span>|  
|<span data-ttu-id="b3203-413">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-413">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-414">是</span><span class="sxs-lookup"><span data-stu-id="b3203-414">Yes</span></span>|  
|<span data-ttu-id="b3203-415">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-415">Remote computer</span></span>|<span data-ttu-id="b3203-416">否</span><span class="sxs-lookup"><span data-stu-id="b3203-416">No</span></span>|  
|<span data-ttu-id="b3203-417">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-417">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-418">是</span><span class="sxs-lookup"><span data-stu-id="b3203-418">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-419">下面的代码示例使用队列路径 ".\myQueue" 创建异步查看操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-419">The following code example creates an asynchronous peek operation, using the queue path ".\myQueue".</span></span> <span data-ttu-id="b3203-420">它创建事件处理程序， `MyPeekCompleted` 并将其附加到 <xref:System.Messaging.MessageQueue.PeekCompleted> 事件处理程序委托。</span><span class="sxs-lookup"><span data-stu-id="b3203-420">It creates an event handler, `MyPeekCompleted`, and attaches it to the <xref:System.Messaging.MessageQueue.PeekCompleted> event handler delegate.</span></span> <span data-ttu-id="b3203-421"><xref:System.Messaging.MessageQueue.BeginPeek%2A> 调用时，超时为一分钟。</span><span class="sxs-lookup"><span data-stu-id="b3203-421"><xref:System.Messaging.MessageQueue.BeginPeek%2A> is called, with a time-out of one minute.</span></span> <span data-ttu-id="b3203-422">对的每个调用 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 都具有唯一的关联整数，该整数标识特定操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-422">Each call to <xref:System.Messaging.MessageQueue.BeginPeek%2A> has a unique associated integer that identifies that particular operation.</span></span> <span data-ttu-id="b3203-423">当 <xref:System.Messaging.MessageQueue.PeekCompleted> 引发事件或超时过期时，将检索消息（如果存在），并在屏幕上写入消息体和特定于操作的整数标识符。</span><span class="sxs-lookup"><span data-stu-id="b3203-423">When a <xref:System.Messaging.MessageQueue.PeekCompleted> event is raised or the time-out expired, the message, if one exists, is retrieved and its body and the operation-specific integer identifier are written to the screen.</span></span> <span data-ttu-id="b3203-424">然后 <xref:System.Messaging.MessageQueue.BeginPeek%2A> ，再次调用来启动一个新的异步查看操作，该操作具有相同的超时和刚完成的操作的关联整数。</span><span class="sxs-lookup"><span data-stu-id="b3203-424">Then <xref:System.Messaging.MessageQueue.BeginPeek%2A> is called again to initiate a new asynchronous peek operation with the same time-out and the associated integer of the just completed operation.</span></span>  
  
 [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-425">为 <paramref name="timeout" /> 参数指定的值无效。</span><span class="sxs-lookup"><span data-stu-id="b3203-425">The value specified for the <paramref name="timeout" /> parameter is not valid.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-426">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-426">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="b3203-427">方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="b3203-427">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="b3203-428">一个 <see cref="T:System.TimeSpan" /> 指示等待消息变为可用所用的时间间隔。</span><span class="sxs-lookup"><span data-stu-id="b3203-428">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</span></span></param>
        <param name="stateObject"><span data-ttu-id="b3203-429">应用程序指定的状态对象，包含与异步操作关联的信息。</span><span class="sxs-lookup"><span data-stu-id="b3203-429">A state object, specified by the application, that contains information associated with the asynchronous operation.</span></span></param>
        <param name="callback"><span data-ttu-id="b3203-430">该 <see cref="T:System.AsyncCallback" /> 将接收异步操作完成通知。</span><span class="sxs-lookup"><span data-stu-id="b3203-430">The <see cref="T:System.AsyncCallback" /> that will receive the notification of the asynchronous operation completion.</span></span></param>
        <summary><span data-ttu-id="b3203-431">启动具有指定超时设定和指定状态对象的异步查看操作，此状态对象在操作的整个生存期内提供相关信息。</span><span class="sxs-lookup"><span data-stu-id="b3203-431">Initiates an asynchronous peek operation that has a specified time-out and a specified state object, which provides associated information throughout the operation's lifetime.</span></span> <span data-ttu-id="b3203-432">此重载通过回调接收操作的事件处理程序标识的通知。</span><span class="sxs-lookup"><span data-stu-id="b3203-432">This overload receives notification, through a callback, of the identity of the event handler for the operation.</span></span> <span data-ttu-id="b3203-433">直到队列中出现消息时或发生超时时才完成操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-433">The operation is not complete until either a message becomes available in the queue or the time-out occurs.</span></span></summary>
        <returns><span data-ttu-id="b3203-434">该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</span><span class="sxs-lookup"><span data-stu-id="b3203-434">The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-435">使用此重载时，当消息在队列中可用或指定的时间间隔到期时，将直接调用在回调参数中指定的回调; <xref:System.Messaging.MessageQueue.PeekCompleted> 不引发该事件。</span><span class="sxs-lookup"><span data-stu-id="b3203-435">When you use this overload, the callback specified in the callback parameter is invoked directly when a message becomes available in the queue or when the specified interval of time has expired; the <xref:System.Messaging.MessageQueue.PeekCompleted> event is not raised.</span></span> <span data-ttu-id="b3203-436">的其他重载 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 依赖于此组件来引发 <xref:System.Messaging.MessageQueue.PeekCompleted> 事件。</span><span class="sxs-lookup"><span data-stu-id="b3203-436">The other overloads of <xref:System.Messaging.MessageQueue.BeginPeek%2A> rely on this component to raise the <xref:System.Messaging.MessageQueue.PeekCompleted> event.</span></span>  
  
 <span data-ttu-id="b3203-437"><xref:System.Messaging.MessageQueue.PeekCompleted> 如果队列中已经存在消息，也会引发。</span><span class="sxs-lookup"><span data-stu-id="b3203-437"><xref:System.Messaging.MessageQueue.PeekCompleted> is also raised if a message already exists in the queue.</span></span>  
  
 <span data-ttu-id="b3203-438"><xref:System.Messaging.MessageQueue.BeginPeek%2A>方法会立即返回，但在调用事件处理程序之前，不会完成异步操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-438">The <xref:System.Messaging.MessageQueue.BeginPeek%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</span></span>  
  
 <span data-ttu-id="b3203-439">由于 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 是异步的，因此你可以调用它来查看队列，而不会阻止当前的执行线程。</span><span class="sxs-lookup"><span data-stu-id="b3203-439">Because <xref:System.Messaging.MessageQueue.BeginPeek%2A> is asynchronous, you can call it to peek the queue without blocking the current thread of execution.</span></span> <span data-ttu-id="b3203-440">若要同步查看队列，请使用 <xref:System.Messaging.MessageQueue.Peek%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-440">To synchronously peek the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.</span></span>  
  
 <span data-ttu-id="b3203-441">异步操作完成后，可以 <xref:System.Messaging.MessageQueue.BeginPeek%2A> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 在事件处理程序中调用或再次运行以继续接收通知。</span><span class="sxs-lookup"><span data-stu-id="b3203-441">Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.</span></span>  
  
 <span data-ttu-id="b3203-442"><xref:System.Messaging.MessageQueue.BeginPeek%2A> 返回一个 <xref:System.IAsyncResult> ，它标识该方法启动的异步操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-442"><xref:System.Messaging.MessageQueue.BeginPeek%2A> returns a <xref:System.IAsyncResult> that identifies the asynchronous operation that the method started.</span></span> <span data-ttu-id="b3203-443">可以在 <xref:System.IAsyncResult> 操作的整个生存期内使用此方法，不过，在调用之前，通常不使用此方法 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-443">You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> is called.</span></span> <span data-ttu-id="b3203-444">但是，如果您启动多个异步操作，则可以将它们的 <xref:System.IAsyncResult> 值放在数组中，并指定是否等待所有操作或任何操作完成。</span><span class="sxs-lookup"><span data-stu-id="b3203-444">However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete.</span></span> <span data-ttu-id="b3203-445">在这种情况下，可以使用 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 的属性 <xref:System.IAsyncResult> 来标识已完成的操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-445">In this case, you use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.</span></span>  
  
 <span data-ttu-id="b3203-446">状态对象将状态信息与操作相关联。</span><span class="sxs-lookup"><span data-stu-id="b3203-446">The state object associates state information with the operation.</span></span> <span data-ttu-id="b3203-447">例如，如果 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 多次调用来启动多个操作，则可以通过定义的单独状态对象标识每个操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-447">For example, if you call <xref:System.Messaging.MessageQueue.BeginPeek%2A> multiple times to initiate multiple operations, you can identify each operation through a separate state object that you define.</span></span>  
  
 <span data-ttu-id="b3203-448">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-448">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-449">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-449">Workgroup mode</span></span>|<span data-ttu-id="b3203-450">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-450">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-451">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-451">Local computer</span></span>|<span data-ttu-id="b3203-452">是</span><span class="sxs-lookup"><span data-stu-id="b3203-452">Yes</span></span>|  
|<span data-ttu-id="b3203-453">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-453">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-454">是</span><span class="sxs-lookup"><span data-stu-id="b3203-454">Yes</span></span>|  
|<span data-ttu-id="b3203-455">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-455">Remote computer</span></span>|<span data-ttu-id="b3203-456">否</span><span class="sxs-lookup"><span data-stu-id="b3203-456">No</span></span>|  
|<span data-ttu-id="b3203-457">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-457">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-458">是</span><span class="sxs-lookup"><span data-stu-id="b3203-458">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-459">下面的代码示例创建一个异步查看操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-459">The following code example creates an asynchronous peek operation.</span></span> <span data-ttu-id="b3203-460">此代码示例将一条消息发送到本地消息队列，然后调用 <xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29> 并传入：超时值为10秒; 唯一的整数，用于标识该特定消息; 以及 <xref:System.AsyncCallback> 标识事件处理程序的的新实例 `MyPeekCompleted` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-460">The code example sends a message to a local message queue, then calls <xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, passing in: a time-out value of ten seconds; a unique integer that identifies that particular message; and a new instance of <xref:System.AsyncCallback> that identifies the event handler, `MyPeekCompleted`.</span></span> <span data-ttu-id="b3203-461"><xref:System.Messaging.MessageQueue.PeekCompleted>引发事件时，事件处理程序将查看该消息，并将消息正文和整数消息标识符写入屏幕。</span><span class="sxs-lookup"><span data-stu-id="b3203-461">When a <xref:System.Messaging.MessageQueue.PeekCompleted> event is raised, the event handler peeks at the message and writes the message body and the integer message identifier to the screen.</span></span>  
  
 [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-462">为 <paramref name="timeout" /> 参数指定的值无效。</span><span class="sxs-lookup"><span data-stu-id="b3203-462">The value specified for the <paramref name="timeout" /> parameter is not valid.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-463">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-463">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="b3203-464">方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="b3203-464">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, cursor As Cursor, action As PeekAction, state As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, cursor, action, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="b3203-465">一个 <see cref="T:System.TimeSpan" /> 指示等待消息变为可用所用的时间间隔。</span><span class="sxs-lookup"><span data-stu-id="b3203-465">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</span></span></param>
        <param name="cursor"><span data-ttu-id="b3203-466">维持消息队列中特定位置的 <see cref="T:System.Messaging.Cursor" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-466">A <see cref="T:System.Messaging.Cursor" /> that maintains a specific position in the message queue.</span></span></param>
        <param name="action"><span data-ttu-id="b3203-467"><see cref="T:System.Messaging.PeekAction" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="b3203-467">One of the <see cref="T:System.Messaging.PeekAction" /> values.</span></span> <span data-ttu-id="b3203-468">指示是查看队列中的当前消息还是下一条消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-468">Indicates whether to peek at the current message in the queue, or the next message.</span></span></param>
        <param name="state"><span data-ttu-id="b3203-469">应用程序指定的状态对象，包含与异步操作关联的信息。</span><span class="sxs-lookup"><span data-stu-id="b3203-469">A state object, specified by the application, that contains information associated with the asynchronous operation.</span></span></param>
        <param name="callback"><span data-ttu-id="b3203-470">该 <see cref="T:System.AsyncCallback" /> 将接收异步操作完成通知。</span><span class="sxs-lookup"><span data-stu-id="b3203-470">The <see cref="T:System.AsyncCallback" /> that receives the notification of the asynchronous operation completion.</span></span></param>
        <summary><span data-ttu-id="b3203-471">启动异步查看操作，此操作具有指定的超时并使用指定的游标、指定的查看操作和指定的状态对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-471">Initiates an asynchronous peek operation that has a specified time-out and that uses a specified cursor, a specified peek action, and a specified state object.</span></span> <span data-ttu-id="b3203-472">状态对象在操作的整个生存期内提供相关的信息。</span><span class="sxs-lookup"><span data-stu-id="b3203-472">The state object provides associated information throughout the lifetime of the operation.</span></span> <span data-ttu-id="b3203-473">此重载通过回调接收操作的事件处理程序标识的通知。</span><span class="sxs-lookup"><span data-stu-id="b3203-473">This overload receives notification, through a callback, of the identity of the event handler for the operation.</span></span> <span data-ttu-id="b3203-474">直到队列中出现消息时或发生超时时才完成操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-474">The operation is not complete until either a message becomes available in the queue or the time-out occurs.</span></span></summary>
        <returns><span data-ttu-id="b3203-475">该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</span><span class="sxs-lookup"><span data-stu-id="b3203-475">The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-476">使用此重载时，当消息在队列中可用或指定的时间间隔过期时，将直接调用在回调参数中指定的回调。</span><span class="sxs-lookup"><span data-stu-id="b3203-476">When you use this overload, the callback specified in the callback parameter is invoked directly when a message becomes available in the queue or when the specified interval of time has expired.</span></span> <span data-ttu-id="b3203-477"><xref:System.Messaging.MessageQueue.PeekCompleted>不引发该事件。</span><span class="sxs-lookup"><span data-stu-id="b3203-477">The <xref:System.Messaging.MessageQueue.PeekCompleted> event is not raised.</span></span> <span data-ttu-id="b3203-478">的其他重载 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 依赖于此组件来引发 <xref:System.Messaging.MessageQueue.PeekCompleted> 事件。</span><span class="sxs-lookup"><span data-stu-id="b3203-478">The other overloads of <xref:System.Messaging.MessageQueue.BeginPeek%2A> rely on this component to raise the <xref:System.Messaging.MessageQueue.PeekCompleted> event.</span></span>  
  
 <span data-ttu-id="b3203-479"><xref:System.Messaging.MessageQueue.PeekCompleted> 如果队列中已经存在消息，也会引发。</span><span class="sxs-lookup"><span data-stu-id="b3203-479"><xref:System.Messaging.MessageQueue.PeekCompleted> is also raised if a message already exists in the queue.</span></span>  
  
 <span data-ttu-id="b3203-480"><xref:System.Messaging.MessageQueue.BeginPeek%2A>方法会立即返回，但在调用事件处理程序之前，不会完成异步操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-480">The <xref:System.Messaging.MessageQueue.BeginPeek%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</span></span>  
  
 <span data-ttu-id="b3203-481">由于 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 是异步的，因此你可以调用它来查看队列，而不会阻止当前的执行线程。</span><span class="sxs-lookup"><span data-stu-id="b3203-481">Because <xref:System.Messaging.MessageQueue.BeginPeek%2A> is asynchronous, you can call it to peek the queue without blocking the current thread of execution.</span></span> <span data-ttu-id="b3203-482">若要同步查看队列，请使用 <xref:System.Messaging.MessageQueue.Peek%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-482">To synchronously peek the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.</span></span>  
  
 <span data-ttu-id="b3203-483">异步操作完成后，可以 <xref:System.Messaging.MessageQueue.BeginPeek%2A> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 在事件处理程序中调用或再次运行以继续接收通知。</span><span class="sxs-lookup"><span data-stu-id="b3203-483">Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.</span></span>  
  
 <span data-ttu-id="b3203-484"><xref:System.Messaging.MessageQueue.BeginPeek%2A> 返回一个 <xref:System.IAsyncResult> ，它标识由方法启动的异步操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-484"><xref:System.Messaging.MessageQueue.BeginPeek%2A> returns a <xref:System.IAsyncResult> that identifies the asynchronous operation started by the method.</span></span> <span data-ttu-id="b3203-485">可以在 <xref:System.IAsyncResult> 操作的整个生存期内使用此方法，不过，在调用之前，通常不使用此方法 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-485">You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> is called.</span></span> <span data-ttu-id="b3203-486">但是，如果您启动多个异步操作，则可以将它们的 <xref:System.IAsyncResult> 值放在数组中，并指定是否等待所有操作或任何操作完成。</span><span class="sxs-lookup"><span data-stu-id="b3203-486">However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete.</span></span> <span data-ttu-id="b3203-487">在这种情况下，请使用 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 的属性 <xref:System.IAsyncResult> 来标识已完成的操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-487">In this case, use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.</span></span>  
  
 <span data-ttu-id="b3203-488">状态对象将状态信息与操作相关联。</span><span class="sxs-lookup"><span data-stu-id="b3203-488">The state object associates state information with the operation.</span></span> <span data-ttu-id="b3203-489">例如，如果 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 多次调用来启动多个操作，则可以通过定义的单独状态对象标识每个操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-489">For example, if you call <xref:System.Messaging.MessageQueue.BeginPeek%2A> multiple times to initiate multiple operations, you can identify each operation through a separate state object that you define.</span></span>  
  
 <span data-ttu-id="b3203-490">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-490">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-491">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-491">Workgroup mode</span></span>|<span data-ttu-id="b3203-492">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-492">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-493">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-493">Local computer</span></span>|<span data-ttu-id="b3203-494">是</span><span class="sxs-lookup"><span data-stu-id="b3203-494">Yes</span></span>|  
|<span data-ttu-id="b3203-495">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-495">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-496">是</span><span class="sxs-lookup"><span data-stu-id="b3203-496">Yes</span></span>|  
|<span data-ttu-id="b3203-497">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-497">Remote computer</span></span>|<span data-ttu-id="b3203-498">否</span><span class="sxs-lookup"><span data-stu-id="b3203-498">No</span></span>|  
|<span data-ttu-id="b3203-499">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-499">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-500">是</span><span class="sxs-lookup"><span data-stu-id="b3203-500">Yes</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b3203-501">为 <paramref name="action" /> 参数指定的值不是 <see langword="PeekAction.Current" /> 和 <see langword="PeekAction.Next" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-501">A value other than <see langword="PeekAction.Current" /> or <see langword="PeekAction.Next" /> was specified for the <paramref name="action" /> parameter.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3203-502"><paramref name="cursor" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-502">The <paramref name="cursor" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-503">为 <paramref name="timeout" /> 参数指定的值无效。</span><span class="sxs-lookup"><span data-stu-id="b3203-503">The value specified for the <paramref name="timeout" /> parameter is not valid.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-504">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-504">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="b3203-505">方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="b3203-505">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe><span data-ttu-id="b3203-506">方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="b3203-506">The method is not thread safe.</span></span></threadsafe>
        <summary><span data-ttu-id="b3203-507">通过通知“消息队列”开始接收消息并在完成后通知事件处理程序，启动一个异步接收操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-507">Initiates an asynchronous receive operation by telling Message Queuing to begin receiving a message and notify the event handler when finished.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive();" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : unit -&gt; IAsyncResult" Usage="messageQueue.BeginReceive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b3203-508">启动一个未设置超时的异步接收操作。直到队列中有可用消息时，操作才会完成。</span><span class="sxs-lookup"><span data-stu-id="b3203-508">Initiates an asynchronous receive operation that has no time-out. The operation is not complete until a message becomes available in the queue.</span></span></summary>
        <returns><span data-ttu-id="b3203-509">该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</span><span class="sxs-lookup"><span data-stu-id="b3203-509">The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-510">在异步处理过程中， <xref:System.Messaging.MessageQueue.BeginReceive%2A> <xref:System.Messaging.MessageQueue.ReceiveCompleted> 当消息已从队列中移除时，使用引发事件。</span><span class="sxs-lookup"><span data-stu-id="b3203-510">In asynchronous processing, you use <xref:System.Messaging.MessageQueue.BeginReceive%2A> to raise the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event when a message has been removed from the queue.</span></span>  
  
 <span data-ttu-id="b3203-511"><xref:System.Messaging.MessageQueue.ReceiveCompleted> 如果队列中已经存在消息，也会引发。</span><span class="sxs-lookup"><span data-stu-id="b3203-511"><xref:System.Messaging.MessageQueue.ReceiveCompleted> is also raised if a message already exists in the queue.</span></span>  
  
 <span data-ttu-id="b3203-512">若要使用 <xref:System.Messaging.MessageQueue.BeginReceive%2A> ，请创建一个事件处理程序，用于处理异步操作的结果并将其与事件委托相关联。</span><span class="sxs-lookup"><span data-stu-id="b3203-512">To use <xref:System.Messaging.MessageQueue.BeginReceive%2A>, create an event handler that processes the results of the asynchronous operation and associate it with your event delegate.</span></span> <span data-ttu-id="b3203-513"><xref:System.Messaging.MessageQueue.BeginReceive%2A> 启动异步接收操作; <xref:System.Messaging.MessageQueue> <xref:System.Messaging.MessageQueue.ReceiveCompleted> 当消息到达队列时，会通过引发事件通知。</span><span class="sxs-lookup"><span data-stu-id="b3203-513"><xref:System.Messaging.MessageQueue.BeginReceive%2A> initiates an asynchronous receive operation; the <xref:System.Messaging.MessageQueue> is notified, through the raising of the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event, when a message arrives in the queue.</span></span> <span data-ttu-id="b3203-514"><xref:System.Messaging.MessageQueue>然后，可以通过调用来访问消息 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-514">The <xref:System.Messaging.MessageQueue> can then access the message by calling <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.</span></span>  
  
 <span data-ttu-id="b3203-515"><xref:System.Messaging.MessageQueue.BeginReceive%2A>方法会立即返回，但在调用事件处理程序之前，不会完成异步操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-515">The <xref:System.Messaging.MessageQueue.BeginReceive%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</span></span>  
  
 <span data-ttu-id="b3203-516">由于 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 是异步的，因此你可以调用它来接收队列中的消息，而不会阻止当前的执行线程。</span><span class="sxs-lookup"><span data-stu-id="b3203-516">Because <xref:System.Messaging.MessageQueue.BeginReceive%2A> is asynchronous, you can call it to receive a message from the queue without blocking the current thread of execution.</span></span> <span data-ttu-id="b3203-517">若要以同步方式接收消息，请使用 <xref:System.Messaging.MessageQueue.Receive%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-517">To synchronously receive a message, use the <xref:System.Messaging.MessageQueue.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="b3203-518">异步操作完成后，可以 <xref:System.Messaging.MessageQueue.BeginPeek%2A> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 在事件处理程序中调用或再次运行以继续接收通知。</span><span class="sxs-lookup"><span data-stu-id="b3203-518">Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.</span></span>  
  
 <span data-ttu-id="b3203-519">返回的将 <xref:System.IAsyncResult> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 标识该方法启动的异步操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-519">The <xref:System.IAsyncResult> that <xref:System.Messaging.MessageQueue.BeginReceive%2A> returns identifies the asynchronous operation that the method started.</span></span> <span data-ttu-id="b3203-520">可以在 <xref:System.IAsyncResult> 操作的整个生存期内使用此方法，不过，在调用之前，通常不使用此方法 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-520">You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> is called.</span></span> <span data-ttu-id="b3203-521">但是，如果您启动多个异步操作，则可以将它们的 <xref:System.IAsyncResult> 值放在数组中，并指定是否等待所有操作或任何操作完成。</span><span class="sxs-lookup"><span data-stu-id="b3203-521">However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete.</span></span> <span data-ttu-id="b3203-522">在这种情况下，可以使用 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 的属性 <xref:System.IAsyncResult> 来标识已完成的操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-522">In this case, you use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.</span></span>  
  
 <span data-ttu-id="b3203-523">如果 <xref:System.Messaging.MessageQueue.CanRead%2A> 为 `false` ，则引发完成事件，但在调用时将引发异常 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-523">If <xref:System.Messaging.MessageQueue.CanRead%2A> is `false`, the completion event is raised, but an exception will be thrown when calling <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.</span></span>  
  
 <span data-ttu-id="b3203-524">不要对事务使用异步调用 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-524">Do not use the asynchronous call <xref:System.Messaging.MessageQueue.BeginReceive%2A> with transactions.</span></span> <span data-ttu-id="b3203-525">如果要执行事务异步操作，请调用 <xref:System.Messaging.MessageQueue.BeginPeek%2A> ，并在 <xref:System.Messaging.MessageQueue.Receive%2A> 为查看操作创建的事件处理程序中放置事务和 (同步) 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-525">If you want to perform a transactional asynchronous operation, call <xref:System.Messaging.MessageQueue.BeginPeek%2A>, and put the transaction and the (synchronous) <xref:System.Messaging.MessageQueue.Receive%2A> method within the event handler you create for the peek operation.</span></span> <span data-ttu-id="b3203-526">你的事件处理程序可能包含以下 c # 代码中所示的功能。</span><span class="sxs-lookup"><span data-stu-id="b3203-526">Your event handler might contain functionality as shown in the following C# code.</span></span>  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 <span data-ttu-id="b3203-527">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-527">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-528">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-528">Workgroup mode</span></span>|<span data-ttu-id="b3203-529">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-529">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-530">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-530">Local computer</span></span>|<span data-ttu-id="b3203-531">是</span><span class="sxs-lookup"><span data-stu-id="b3203-531">Yes</span></span>|  
|<span data-ttu-id="b3203-532">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-532">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-533">是</span><span class="sxs-lookup"><span data-stu-id="b3203-533">Yes</span></span>|  
|<span data-ttu-id="b3203-534">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-534">Remote computer</span></span>|<span data-ttu-id="b3203-535">否</span><span class="sxs-lookup"><span data-stu-id="b3203-535">No</span></span>|  
|<span data-ttu-id="b3203-536">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-536">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-537">是</span><span class="sxs-lookup"><span data-stu-id="b3203-537">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-538">下面的代码示例将异步请求链接在一起。</span><span class="sxs-lookup"><span data-stu-id="b3203-538">The following code example chains asynchronous requests.</span></span> <span data-ttu-id="b3203-539">它假设本地计算机上有一个名为 "myQueue" 的队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-539">It assumes there is a queue on the local computer called "myQueue".</span></span> <span data-ttu-id="b3203-540">`Main`函数开始由例程处理的异步操作 `MyReceiveCompleted` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-540">The `Main` function begins the asynchronous operation that is handled by the `MyReceiveCompleted` routine.</span></span> <span data-ttu-id="b3203-541">`MyReceiveCompleted` 处理当前消息并开始新的异步接收操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-541">`MyReceiveCompleted` processes the current message and begins a new asynchronous receive operation.</span></span>  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 <span data-ttu-id="b3203-542">下面的代码示例将异步请求排队。</span><span class="sxs-lookup"><span data-stu-id="b3203-542">The following code example queues asynchronous requests.</span></span> <span data-ttu-id="b3203-543">对的调用将 <xref:System.Messaging.MessageQueue.BeginReceive%2A> <xref:System.IAsyncResult.AsyncWaitHandle%2A> 在其返回值中使用。</span><span class="sxs-lookup"><span data-stu-id="b3203-543">The call to <xref:System.Messaging.MessageQueue.BeginReceive%2A> uses the <xref:System.IAsyncResult.AsyncWaitHandle%2A> in its return value.</span></span> <span data-ttu-id="b3203-544">`Main`例程等待所有异步操作在退出前完成。</span><span class="sxs-lookup"><span data-stu-id="b3203-544">The `Main` routine waits for all asynchronous operations to be completed before exiting.</span></span>  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-545">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-545">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="b3203-546">方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="b3203-546">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginReceive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="b3203-547">一个 <see cref="T:System.TimeSpan" /> 指示等待消息变为可用所用的时间间隔。</span><span class="sxs-lookup"><span data-stu-id="b3203-547">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</span></span></param>
        <summary><span data-ttu-id="b3203-548">启动具有指定超时的异步接收操作。直到队列中有可用消息时或发生超时，操作才会完成。</span><span class="sxs-lookup"><span data-stu-id="b3203-548">Initiates an asynchronous receive operation that has a specified time-out. The operation is not complete until either a message becomes available in the queue or the time-out occurs.</span></span></summary>
        <returns><span data-ttu-id="b3203-549">该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</span><span class="sxs-lookup"><span data-stu-id="b3203-549">The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-550">在异步处理过程中， <xref:System.Messaging.MessageQueue.BeginReceive%2A> <xref:System.Messaging.MessageQueue.ReceiveCompleted> 当消息在队列中可用或指定的时间间隔到期时，使用来引发事件。</span><span class="sxs-lookup"><span data-stu-id="b3203-550">In asynchronous processing, you use <xref:System.Messaging.MessageQueue.BeginReceive%2A> to raise the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event when a message becomes available in the queue or when the specified interval of time has expired.</span></span>  
  
 <span data-ttu-id="b3203-551"><xref:System.Messaging.MessageQueue.ReceiveCompleted> 如果队列中已经存在消息，也会引发。</span><span class="sxs-lookup"><span data-stu-id="b3203-551"><xref:System.Messaging.MessageQueue.ReceiveCompleted> is also raised if a message already exists in the queue.</span></span>  
  
 <span data-ttu-id="b3203-552">若要使用 <xref:System.Messaging.MessageQueue.BeginReceive%2A> ，请创建一个事件处理程序，用于处理异步操作的结果并将其与事件委托相关联。</span><span class="sxs-lookup"><span data-stu-id="b3203-552">To use <xref:System.Messaging.MessageQueue.BeginReceive%2A>, create an event handler that processes the results of the asynchronous operation and associate it with your event delegate.</span></span> <span data-ttu-id="b3203-553"><xref:System.Messaging.MessageQueue.BeginReceive%2A> 启动异步接收操作; <xref:System.Messaging.MessageQueue> <xref:System.Messaging.MessageQueue.ReceiveCompleted> 当消息到达队列时，会通过引发事件通知。</span><span class="sxs-lookup"><span data-stu-id="b3203-553"><xref:System.Messaging.MessageQueue.BeginReceive%2A> initiates an asynchronous receive operation; the <xref:System.Messaging.MessageQueue> is notified, through the raising of the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event, when a message arrives in the queue.</span></span> <span data-ttu-id="b3203-554"><xref:System.Messaging.MessageQueue>然后，可以通过调用 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 或使用检索结果来访问消息 <xref:System.Messaging.ReceiveCompletedEventArgs> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-554">The <xref:System.Messaging.MessageQueue> can then access the message by calling <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> or retrieving the result using the <xref:System.Messaging.ReceiveCompletedEventArgs>.</span></span>  
  
 <span data-ttu-id="b3203-555"><xref:System.Messaging.MessageQueue.BeginReceive%2A>方法会立即返回，但在调用事件处理程序之前，不会完成异步操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-555">The <xref:System.Messaging.MessageQueue.BeginReceive%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</span></span>  
  
 <span data-ttu-id="b3203-556">由于 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 是异步的，因此你可以调用它来接收队列中的消息，而不会阻止当前的执行线程。</span><span class="sxs-lookup"><span data-stu-id="b3203-556">Because <xref:System.Messaging.MessageQueue.BeginReceive%2A> is asynchronous, you can call it to receive a message from the queue without blocking the current thread of execution.</span></span> <span data-ttu-id="b3203-557">若要以同步方式接收消息，请使用 <xref:System.Messaging.MessageQueue.Receive%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-557">To synchronously receive a message, use the <xref:System.Messaging.MessageQueue.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="b3203-558">异步操作完成后，可以 <xref:System.Messaging.MessageQueue.BeginPeek%2A> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 在事件处理程序中调用或再次运行以继续接收通知。</span><span class="sxs-lookup"><span data-stu-id="b3203-558">Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.</span></span>  
  
 <span data-ttu-id="b3203-559">如果 <xref:System.Messaging.MessageQueue.CanRead%2A> 为 `false` ，则引发完成事件，但在调用时将引发异常 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-559">If <xref:System.Messaging.MessageQueue.CanRead%2A> is `false`, the completion event is raised, but an exception will be thrown when calling <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.</span></span>  
  
 <span data-ttu-id="b3203-560">返回的将 <xref:System.IAsyncResult> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 标识该方法启动的异步操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-560">The <xref:System.IAsyncResult> that <xref:System.Messaging.MessageQueue.BeginReceive%2A> returns identifies the asynchronous operation that the method started.</span></span> <span data-ttu-id="b3203-561">可以在 <xref:System.IAsyncResult> 操作的整个生存期内使用此方法，不过，在调用之前，通常不使用此方法 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-561">You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> is called.</span></span> <span data-ttu-id="b3203-562">但是，如果您启动多个异步操作，则可以将它们的 <xref:System.IAsyncResult> 值放在数组中，并指定是否等待所有操作或任何操作完成。</span><span class="sxs-lookup"><span data-stu-id="b3203-562">However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete.</span></span> <span data-ttu-id="b3203-563">在这种情况下，可以使用 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 的属性 <xref:System.IAsyncResult> 来标识已完成的操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-563">In this case, you use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.</span></span>  
  
 <span data-ttu-id="b3203-564">此重载指定超时。如果参数指定的间隔 `timeout` 过期，此组件将引发 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 事件。</span><span class="sxs-lookup"><span data-stu-id="b3203-564">This overload specifies a time-out. If the interval specified by the `timeout` parameter expires, this component raises the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event.</span></span> <span data-ttu-id="b3203-565">由于不存在任何消息，对的后续调用 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 将引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-565">Because no message exists, a subsequent call to <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> will throw an exception.</span></span>  
  
 <span data-ttu-id="b3203-566">不要对事务使用异步调用 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-566">Do not use the asynchronous call <xref:System.Messaging.MessageQueue.BeginReceive%2A> with transactions.</span></span> <span data-ttu-id="b3203-567">如果要执行事务异步操作，请调用 <xref:System.Messaging.MessageQueue.BeginPeek%2A> ，并在 <xref:System.Messaging.MessageQueue.Receive%2A> 为查看操作创建的事件处理程序中放置事务和 (同步) 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-567">If you want to perform a transactional asynchronous operation, call <xref:System.Messaging.MessageQueue.BeginPeek%2A>, and put the transaction and the (synchronous) <xref:System.Messaging.MessageQueue.Receive%2A> method within the event handler you create for the peek operation.</span></span> <span data-ttu-id="b3203-568">你的事件处理程序可能包含以下 c # 代码中所示的功能。</span><span class="sxs-lookup"><span data-stu-id="b3203-568">Your event handler might contain functionality as shown in the following C# code.</span></span>  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 <span data-ttu-id="b3203-569">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-569">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-570">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-570">Workgroup mode</span></span>|<span data-ttu-id="b3203-571">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-571">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-572">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-572">Local computer</span></span>|<span data-ttu-id="b3203-573">是</span><span class="sxs-lookup"><span data-stu-id="b3203-573">Yes</span></span>|  
|<span data-ttu-id="b3203-574">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-574">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-575">是</span><span class="sxs-lookup"><span data-stu-id="b3203-575">Yes</span></span>|  
|<span data-ttu-id="b3203-576">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-576">Remote computer</span></span>|<span data-ttu-id="b3203-577">否</span><span class="sxs-lookup"><span data-stu-id="b3203-577">No</span></span>|  
|<span data-ttu-id="b3203-578">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-578">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-579">是</span><span class="sxs-lookup"><span data-stu-id="b3203-579">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-580">下面的代码示例创建一个异步接收操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-580">The following code example creates an asynchronous receive operation.</span></span> <span data-ttu-id="b3203-581">此代码示例创建一个事件处理程序， `MyReceiveCompleted` 并将其附加到 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 事件处理程序委托。</span><span class="sxs-lookup"><span data-stu-id="b3203-581">The code example creates an event handler, `MyReceiveCompleted`, and attaches it to the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event handler delegate.</span></span> <span data-ttu-id="b3203-582">此代码示例将消息发送到本地消息队列，然后调用 <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29> ，并传入10秒的超时值。</span><span class="sxs-lookup"><span data-stu-id="b3203-582">The code example sends a message to a local message queue, then calls <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>, passing in a time-out value of ten seconds.</span></span> <span data-ttu-id="b3203-583"><xref:System.Messaging.MessageQueue.ReceiveCompleted>引发事件时，事件处理程序会接收消息，并将消息正文写入屏幕。</span><span class="sxs-lookup"><span data-stu-id="b3203-583">When a <xref:System.Messaging.MessageQueue.ReceiveCompleted> event is raised, the event handler receives the message and writes the message body to the screen.</span></span>  
  
 [!code-cpp[MessageQueueBeginReceive1#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-584">为 <paramref name="timeout" /> 参数指定的值无效，可能是因为它表示负数。</span><span class="sxs-lookup"><span data-stu-id="b3203-584">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly because it represents a negative number.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-585">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-585">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="b3203-586">方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="b3203-586">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="b3203-587">一个 <see cref="T:System.TimeSpan" /> 指示等待消息变为可用所用的时间间隔。</span><span class="sxs-lookup"><span data-stu-id="b3203-587">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</span></span></param>
        <param name="stateObject"><span data-ttu-id="b3203-588">应用程序指定的状态对象，包含与异步操作关联的信息。</span><span class="sxs-lookup"><span data-stu-id="b3203-588">A state object, specified by the application, that contains information associated with the asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="b3203-589">启动具有指定超时设定和指定状态对象的异步接收操作，此状态对象在操作的整个生存期内提供相关信息。</span><span class="sxs-lookup"><span data-stu-id="b3203-589">Initiates an asynchronous receive operation that has a specified time-out and a specified state object, which provides associated information throughout the operation's lifetime.</span></span> <span data-ttu-id="b3203-590">直到队列中出现消息时或发生超时时才完成操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-590">The operation is not complete until either a message becomes available in the queue or the time-out occurs.</span></span></summary>
        <returns><span data-ttu-id="b3203-591">该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</span><span class="sxs-lookup"><span data-stu-id="b3203-591">The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-592">在异步处理过程中， <xref:System.Messaging.MessageQueue.BeginReceive%2A> <xref:System.Messaging.MessageQueue.ReceiveCompleted> 当消息在队列中可用或指定的时间间隔到期时，使用来引发事件。</span><span class="sxs-lookup"><span data-stu-id="b3203-592">In asynchronous processing, you use <xref:System.Messaging.MessageQueue.BeginReceive%2A> to raise the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event when a message becomes available in the queue or when the specified interval of time has expired.</span></span>  
  
 <span data-ttu-id="b3203-593"><xref:System.Messaging.MessageQueue.ReceiveCompleted> 如果队列中已经存在消息，也会引发。</span><span class="sxs-lookup"><span data-stu-id="b3203-593"><xref:System.Messaging.MessageQueue.ReceiveCompleted> is also raised if a message already exists in the queue.</span></span>  
  
 <span data-ttu-id="b3203-594">使用此重载将信息与将在操作的整个生存期内保留的操作相关联。</span><span class="sxs-lookup"><span data-stu-id="b3203-594">Use this overload to associate information with the operation that will be preserved throughout the operation's lifetime.</span></span> <span data-ttu-id="b3203-595">事件处理程序可以通过查看 <xref:System.IAsyncResult.AsyncState%2A> 与操作关联的的属性来检测此信息 <xref:System.IAsyncResult> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-595">The event handler can detect this information by looking at the <xref:System.IAsyncResult.AsyncState%2A> property of the <xref:System.IAsyncResult> that is associated with the operation.</span></span>  
  
 <span data-ttu-id="b3203-596">若要使用 <xref:System.Messaging.MessageQueue.BeginReceive%2A> ，请创建一个事件处理程序，用于处理异步操作的结果并将其与事件委托相关联。</span><span class="sxs-lookup"><span data-stu-id="b3203-596">To use <xref:System.Messaging.MessageQueue.BeginReceive%2A>, create an event handler that processes the results of the asynchronous operation and associate it with your event delegate.</span></span> <span data-ttu-id="b3203-597"><xref:System.Messaging.MessageQueue.BeginReceive%2A> 启动异步接收操作; <xref:System.Messaging.MessageQueue> <xref:System.Messaging.MessageQueue.ReceiveCompleted> 当消息到达队列时，会通过引发事件通知。</span><span class="sxs-lookup"><span data-stu-id="b3203-597"><xref:System.Messaging.MessageQueue.BeginReceive%2A> initiates an asynchronous receive operation; the <xref:System.Messaging.MessageQueue> is notified, through the raising of the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event, when a message arrives in the queue.</span></span> <span data-ttu-id="b3203-598"><xref:System.Messaging.MessageQueue>然后，可以通过调用 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 或使用检索结果来访问消息 <xref:System.Messaging.ReceiveCompletedEventArgs> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-598">The <xref:System.Messaging.MessageQueue> can then access the message by calling <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> or retrieving the result using the <xref:System.Messaging.ReceiveCompletedEventArgs>.</span></span>  
  
 <span data-ttu-id="b3203-599"><xref:System.Messaging.MessageQueue.BeginReceive%2A>方法会立即返回，但在调用事件处理程序之前，不会完成异步操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-599">The <xref:System.Messaging.MessageQueue.BeginReceive%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</span></span>  
  
 <span data-ttu-id="b3203-600">由于 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 是异步的，因此你可以调用它来接收队列中的消息，而不会阻止当前的执行线程。</span><span class="sxs-lookup"><span data-stu-id="b3203-600">Because <xref:System.Messaging.MessageQueue.BeginReceive%2A> is asynchronous, you can call it to receive a message from the queue without blocking the current thread of execution.</span></span> <span data-ttu-id="b3203-601">若要以同步方式接收消息，请使用 <xref:System.Messaging.MessageQueue.Receive%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-601">To synchronously receive a message, use the <xref:System.Messaging.MessageQueue.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="b3203-602">异步操作完成后，可以 <xref:System.Messaging.MessageQueue.BeginPeek%2A> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 在事件处理程序中调用或再次运行以继续接收通知。</span><span class="sxs-lookup"><span data-stu-id="b3203-602">Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.</span></span>  
  
 <span data-ttu-id="b3203-603">返回的将 <xref:System.IAsyncResult> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 标识该方法启动的异步操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-603">The <xref:System.IAsyncResult> that <xref:System.Messaging.MessageQueue.BeginReceive%2A> returns identifies the asynchronous operation that the method started.</span></span> <span data-ttu-id="b3203-604">可以在 <xref:System.IAsyncResult> 操作的整个生存期内使用此方法，不过，在调用之前，通常不使用此方法 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-604">You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> is called.</span></span> <span data-ttu-id="b3203-605">但是，如果您启动多个异步操作，则可以将它们的 <xref:System.IAsyncResult> 值放在数组中，并指定是否等待所有操作或任何操作完成。</span><span class="sxs-lookup"><span data-stu-id="b3203-605">However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete.</span></span> <span data-ttu-id="b3203-606">在这种情况下，可以使用 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 的属性 <xref:System.IAsyncResult> 来标识已完成的操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-606">In this case, you use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.</span></span>  
  
 <span data-ttu-id="b3203-607">此重载指定超时和状态对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-607">This overload specifies a time-out and a state object.</span></span> <span data-ttu-id="b3203-608">如果参数指定的间隔 `timeout` 过期，此组件将引发 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 事件。</span><span class="sxs-lookup"><span data-stu-id="b3203-608">If the interval specified by the `timeout` parameter expires, this component raises the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event.</span></span> <span data-ttu-id="b3203-609">由于不存在任何消息，对的后续调用 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 将引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-609">Because no message exists, a subsequent call to <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> will throw an exception.</span></span>  
  
 <span data-ttu-id="b3203-610">状态对象将状态信息与操作相关联。</span><span class="sxs-lookup"><span data-stu-id="b3203-610">The state object associates state information with the operation.</span></span> <span data-ttu-id="b3203-611">例如，如果 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 多次调用来启动多个操作，则可以通过定义的单独状态对象标识每个操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-611">For example, if you call <xref:System.Messaging.MessageQueue.BeginReceive%2A> multiple times to initiate multiple operations, you can identify each operation through a separate state object that you define.</span></span>  
  
 <span data-ttu-id="b3203-612">你还可以使用状态对象跨进程线程传递信息。</span><span class="sxs-lookup"><span data-stu-id="b3203-612">You can also use the state object to pass information across process threads.</span></span> <span data-ttu-id="b3203-613">如果线程已启动，但回调在异步方案中的其他线程上，则将对状态对象进行封送处理，并将其与事件中的信息一起传递回来。</span><span class="sxs-lookup"><span data-stu-id="b3203-613">If a thread is started but the callback is on a different thread in an asynchronous scenario, the state object is marshaled and passed back along with information from the event.</span></span>  
  
 <span data-ttu-id="b3203-614">不要对事务使用异步调用 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-614">Do not use the asynchronous call <xref:System.Messaging.MessageQueue.BeginReceive%2A> with transactions.</span></span> <span data-ttu-id="b3203-615">如果要执行事务异步操作，请调用 <xref:System.Messaging.MessageQueue.BeginPeek%2A> ，并在 <xref:System.Messaging.MessageQueue.Receive%2A> 为查看操作创建的事件处理程序中放置事务和 (同步) 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-615">If you want to perform a transactional asynchronous operation, call <xref:System.Messaging.MessageQueue.BeginPeek%2A>, and put the transaction and the (synchronous) <xref:System.Messaging.MessageQueue.Receive%2A> method within the event handler you create for the peek operation.</span></span> <span data-ttu-id="b3203-616">你的事件处理程序可能包含以下 c # 代码中所示的功能。</span><span class="sxs-lookup"><span data-stu-id="b3203-616">Your event handler might contain functionality as shown in the following C# code.</span></span>  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 <span data-ttu-id="b3203-617">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-617">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-618">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-618">Workgroup mode</span></span>|<span data-ttu-id="b3203-619">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-619">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-620">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-620">Local computer</span></span>|<span data-ttu-id="b3203-621">是</span><span class="sxs-lookup"><span data-stu-id="b3203-621">Yes</span></span>|  
|<span data-ttu-id="b3203-622">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-622">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-623">是</span><span class="sxs-lookup"><span data-stu-id="b3203-623">Yes</span></span>|  
|<span data-ttu-id="b3203-624">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-624">Remote computer</span></span>|<span data-ttu-id="b3203-625">否</span><span class="sxs-lookup"><span data-stu-id="b3203-625">No</span></span>|  
|<span data-ttu-id="b3203-626">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-626">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-627">是</span><span class="sxs-lookup"><span data-stu-id="b3203-627">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-628">下面的代码示例创建一个异步接收操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-628">The following code example creates an asynchronous receive operation.</span></span> <span data-ttu-id="b3203-629">此代码示例创建一个事件处理程序， `MyReceiveCompleted` 并将其附加到 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 事件处理程序委托。</span><span class="sxs-lookup"><span data-stu-id="b3203-629">The code example creates an event handler, `MyReceiveCompleted`, and attaches it to the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event handler delegate.</span></span> <span data-ttu-id="b3203-630">此代码示例将一条消息发送到本地消息队列，然后调用 <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29> ，传入10秒的超时值和一个标识该特定消息的唯一整数。</span><span class="sxs-lookup"><span data-stu-id="b3203-630">The code example sends a message to a local message queue, then calls <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>, passing in a time-out value of ten seconds and a unique integer that identifies that particular message.</span></span> <span data-ttu-id="b3203-631"><xref:System.Messaging.MessageQueue.ReceiveCompleted>引发事件时，事件处理程序会接收消息，并将消息正文和整数消息标识符写入屏幕。</span><span class="sxs-lookup"><span data-stu-id="b3203-631">When a <xref:System.Messaging.MessageQueue.ReceiveCompleted> event is raised, the event handler receives the message and writes the message body and the integer message identifier to the screen.</span></span>  
  
 [!code-cpp[MessageQueueBeginReceive2#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-632">为 <paramref name="timeout" /> 参数指定的值无效。</span><span class="sxs-lookup"><span data-stu-id="b3203-632">The value specified for the <paramref name="timeout" /> parameter is not valid.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-633">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-633">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="b3203-634">方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="b3203-634">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="b3203-635">一个 <see cref="T:System.TimeSpan" /> 指示等待消息变为可用所用的时间间隔。</span><span class="sxs-lookup"><span data-stu-id="b3203-635">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</span></span></param>
        <param name="stateObject"><span data-ttu-id="b3203-636">应用程序指定的状态对象，包含与异步操作关联的信息。</span><span class="sxs-lookup"><span data-stu-id="b3203-636">A state object, specified by the application, that contains information associated with the asynchronous operation.</span></span></param>
        <param name="callback"><span data-ttu-id="b3203-637">该 <see cref="T:System.AsyncCallback" /> 将接收异步操作完成通知。</span><span class="sxs-lookup"><span data-stu-id="b3203-637">The <see cref="T:System.AsyncCallback" /> that will receive the notification of the asynchronous operation completion.</span></span></param>
        <summary><span data-ttu-id="b3203-638">启动具有指定超时设定和指定状态对象的异步接收操作，此状态对象在操作的整个生存期内提供相关信息。</span><span class="sxs-lookup"><span data-stu-id="b3203-638">Initiates an asynchronous receive operation that has a specified time-out and a specified state object, which provides associated information throughout the operation's lifetime.</span></span> <span data-ttu-id="b3203-639">此重载通过回调接收操作的事件处理程序标识的通知。</span><span class="sxs-lookup"><span data-stu-id="b3203-639">This overload receives notification, through a callback, of the identity of the event handler for the operation.</span></span> <span data-ttu-id="b3203-640">直到队列中出现消息时或发生超时时才完成操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-640">The operation is not complete until either a message becomes available in the queue or the time-out occurs.</span></span></summary>
        <returns><span data-ttu-id="b3203-641">该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</span><span class="sxs-lookup"><span data-stu-id="b3203-641">The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-642">使用此重载时，当消息在队列中可用或指定的时间间隔到期时，将直接调用在回调参数中指定的回调; <xref:System.Messaging.MessageQueue.ReceiveCompleted> 不引发该事件。</span><span class="sxs-lookup"><span data-stu-id="b3203-642">When you use this overload, the callback specified in the callback parameter is invoked directly when a message becomes available in the queue or when the specified interval of time has expired; the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event is not raised.</span></span> <span data-ttu-id="b3203-643">的其他重载 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 依赖于此组件来引发 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 事件。</span><span class="sxs-lookup"><span data-stu-id="b3203-643">The other overloads of <xref:System.Messaging.MessageQueue.BeginReceive%2A> rely on this component to raise the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event.</span></span>  
  
 <span data-ttu-id="b3203-644"><xref:System.Messaging.MessageQueue.ReceiveCompleted> 如果队列中已经存在消息，也会引发。</span><span class="sxs-lookup"><span data-stu-id="b3203-644"><xref:System.Messaging.MessageQueue.ReceiveCompleted> is also raised if a message already exists in the queue.</span></span>  
  
 <span data-ttu-id="b3203-645">若要使用 <xref:System.Messaging.MessageQueue.BeginReceive%2A> ，请创建一个事件处理程序，用于处理异步操作的结果并将其与事件委托相关联。</span><span class="sxs-lookup"><span data-stu-id="b3203-645">To use <xref:System.Messaging.MessageQueue.BeginReceive%2A>, create an event handler that processes the results of the asynchronous operation and associate it with your event delegate.</span></span> <span data-ttu-id="b3203-646"><xref:System.Messaging.MessageQueue.BeginReceive%2A> 启动异步接收操作; <xref:System.Messaging.MessageQueue> <xref:System.Messaging.MessageQueue.ReceiveCompleted> 当消息到达队列时，会通过引发事件通知。</span><span class="sxs-lookup"><span data-stu-id="b3203-646"><xref:System.Messaging.MessageQueue.BeginReceive%2A> initiates an asynchronous receive operation; the <xref:System.Messaging.MessageQueue> is notified, through the raising of the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event, when a message arrives in the queue.</span></span> <span data-ttu-id="b3203-647"><xref:System.Messaging.MessageQueue>然后，可以通过调用 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 或使用检索结果来访问消息 <xref:System.Messaging.ReceiveCompletedEventArgs> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-647">The <xref:System.Messaging.MessageQueue> can then access the message by calling <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> or retrieving the result using the <xref:System.Messaging.ReceiveCompletedEventArgs>.</span></span>  
  
 <span data-ttu-id="b3203-648"><xref:System.Messaging.MessageQueue.BeginReceive%2A>方法会立即返回，但在调用事件处理程序之前，不会完成异步操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-648">The <xref:System.Messaging.MessageQueue.BeginReceive%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</span></span>  
  
 <span data-ttu-id="b3203-649">由于 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 是异步的，因此你可以调用它来接收队列中的消息，而不会阻止当前的执行线程。</span><span class="sxs-lookup"><span data-stu-id="b3203-649">Because <xref:System.Messaging.MessageQueue.BeginReceive%2A> is asynchronous, you can call it to receive a message from the queue without blocking the current thread of execution.</span></span> <span data-ttu-id="b3203-650">若要以同步方式接收消息，请使用 <xref:System.Messaging.MessageQueue.Receive%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-650">To synchronously receive a message, use the <xref:System.Messaging.MessageQueue.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="b3203-651">异步操作完成后，可以 <xref:System.Messaging.MessageQueue.BeginPeek%2A> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 在事件处理程序中调用或再次运行以继续接收通知。</span><span class="sxs-lookup"><span data-stu-id="b3203-651">Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.</span></span>  
  
 <span data-ttu-id="b3203-652">返回的将 <xref:System.IAsyncResult> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 标识该方法启动的异步操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-652">The <xref:System.IAsyncResult> that <xref:System.Messaging.MessageQueue.BeginReceive%2A> returns identifies the asynchronous operation that the method started.</span></span> <span data-ttu-id="b3203-653">可以在 <xref:System.IAsyncResult> 操作的整个生存期内使用此方法，不过，在调用之前，通常不使用此方法 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-653">You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> is called.</span></span> <span data-ttu-id="b3203-654">但是，如果您启动多个异步操作，则可以将它们的 <xref:System.IAsyncResult> 值放在数组中，并指定是否等待所有操作或任何操作完成。</span><span class="sxs-lookup"><span data-stu-id="b3203-654">However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete.</span></span> <span data-ttu-id="b3203-655">在这种情况下，可以使用 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 的属性 <xref:System.IAsyncResult> 来标识已完成的操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-655">In this case, you use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.</span></span>  
  
 <span data-ttu-id="b3203-656">状态对象将状态信息与操作相关联。</span><span class="sxs-lookup"><span data-stu-id="b3203-656">The state object associates state information with the operation.</span></span> <span data-ttu-id="b3203-657">例如，如果 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 多次调用来启动多个操作，则可以通过定义的单独状态对象标识每个操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-657">For example, if you call <xref:System.Messaging.MessageQueue.BeginReceive%2A> multiple times to initiate multiple operations, you can identify each operation through a separate state object that you define.</span></span>  
  
 <span data-ttu-id="b3203-658">你还可以使用状态对象跨进程线程传递信息。</span><span class="sxs-lookup"><span data-stu-id="b3203-658">You can also use the state object to pass information across process threads.</span></span> <span data-ttu-id="b3203-659">如果线程已启动，但回调在异步方案中的其他线程上，则将对状态对象进行封送处理，并将其与事件中的信息一起传递回来。</span><span class="sxs-lookup"><span data-stu-id="b3203-659">If a thread is started but the callback is on a different thread in an asynchronous scenario, the state object is marshaled and passed back along with information from the event.</span></span>  
  
 <span data-ttu-id="b3203-660">不要对事务使用异步调用 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-660">Do not use the asynchronous call <xref:System.Messaging.MessageQueue.BeginReceive%2A> with transactions.</span></span> <span data-ttu-id="b3203-661">如果要执行事务异步操作，请调用 <xref:System.Messaging.MessageQueue.BeginPeek%2A> ，并在 <xref:System.Messaging.MessageQueue.Receive%2A> 为查看操作创建的事件处理程序中放置事务和 (同步) 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-661">If you want to perform a transactional asynchronous operation, call <xref:System.Messaging.MessageQueue.BeginPeek%2A>, and put the transaction and the (synchronous) <xref:System.Messaging.MessageQueue.Receive%2A> method within the event handler you create for the peek operation.</span></span> <span data-ttu-id="b3203-662">你的事件处理程序可能包含以下 c # 代码中所示的功能。</span><span class="sxs-lookup"><span data-stu-id="b3203-662">Your event handler might contain functionality as shown in the following C# code.</span></span>  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 <span data-ttu-id="b3203-663">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-663">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-664">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-664">Workgroup mode</span></span>|<span data-ttu-id="b3203-665">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-665">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-666">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-666">Local computer</span></span>|<span data-ttu-id="b3203-667">是</span><span class="sxs-lookup"><span data-stu-id="b3203-667">Yes</span></span>|  
|<span data-ttu-id="b3203-668">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-668">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-669">是</span><span class="sxs-lookup"><span data-stu-id="b3203-669">Yes</span></span>|  
|<span data-ttu-id="b3203-670">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-670">Remote computer</span></span>|<span data-ttu-id="b3203-671">否</span><span class="sxs-lookup"><span data-stu-id="b3203-671">No</span></span>|  
|<span data-ttu-id="b3203-672">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-672">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-673">是</span><span class="sxs-lookup"><span data-stu-id="b3203-673">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-674">下面的代码示例创建一个异步接收操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-674">The following code example creates an asynchronous receive operation.</span></span> <span data-ttu-id="b3203-675">此代码示例将一条消息发送到本地消息队列，然后调用 <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29> 并传入：超时值为10秒; 唯一的整数，用于标识该特定消息; 以及 <xref:System.AsyncCallback> 标识事件处理程序的的新实例 `MyReceiveCompleted` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-675">The code example sends a message to a local message queue, then calls <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, passing in: a time-out value of ten seconds; a unique integer that identifies that particular message; and a new instance of <xref:System.AsyncCallback> that identifies the event handler, `MyReceiveCompleted`.</span></span> <span data-ttu-id="b3203-676"><xref:System.Messaging.MessageQueue.ReceiveCompleted>引发事件时，事件处理程序会接收消息，并将消息正文和整数消息标识符写入屏幕。</span><span class="sxs-lookup"><span data-stu-id="b3203-676">When a <xref:System.Messaging.MessageQueue.ReceiveCompleted> event is raised, the event handler receives the message and writes the message body and the integer message identifier to the screen.</span></span>  
  
 [!code-cpp[MessageQueueBeginReceive3#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-677">为 <paramref name="timeout" /> 参数指定的值无效。</span><span class="sxs-lookup"><span data-stu-id="b3203-677">The value specified for the <paramref name="timeout" /> parameter is not valid.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-678">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-678">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="b3203-679">方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="b3203-679">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, cursor As Cursor, state As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * System.Messaging.Cursor * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, cursor, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="b3203-680">一个 <see cref="T:System.TimeSpan" /> 指示等待消息变为可用所用的时间间隔。</span><span class="sxs-lookup"><span data-stu-id="b3203-680">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</span></span></param>
        <param name="cursor"><span data-ttu-id="b3203-681">维持消息队列中特定位置的 <see cref="T:System.Messaging.Cursor" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-681">A <see cref="T:System.Messaging.Cursor" /> that maintains a specific position in the message queue.</span></span></param>
        <param name="state"><span data-ttu-id="b3203-682">应用程序指定的状态对象，包含与异步操作关联的信息。</span><span class="sxs-lookup"><span data-stu-id="b3203-682">A state object, specified by the application, that contains information associated with the asynchronous operation.</span></span></param>
        <param name="callback"><span data-ttu-id="b3203-683">该 <see cref="T:System.AsyncCallback" /> 将接收异步操作完成通知。</span><span class="sxs-lookup"><span data-stu-id="b3203-683">The <see cref="T:System.AsyncCallback" /> that receives the notification of the asynchronous operation completion.</span></span></param>
        <summary><span data-ttu-id="b3203-684">启动异步接收操作，此操作具有指定的超时并使用指定的游标和指定的状态对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-684">Initiates an asynchronous receive operation that has a specified time-out and uses a specified cursor and a specified state object.</span></span> <span data-ttu-id="b3203-685">状态对象在操作的整个生存期内提供相关的信息。</span><span class="sxs-lookup"><span data-stu-id="b3203-685">The state object provides associated information throughout the lifetime of the operation.</span></span> <span data-ttu-id="b3203-686">此重载通过回调接收操作的事件处理程序标识的通知。</span><span class="sxs-lookup"><span data-stu-id="b3203-686">This overload receives notification, through a callback, of the identity of the event handler for the operation.</span></span> <span data-ttu-id="b3203-687">直到队列中出现消息时或发生超时时才完成操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-687">The operation is not complete until either a message becomes available in the queue or the time-out occurs.</span></span></summary>
        <returns><span data-ttu-id="b3203-688">该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</span><span class="sxs-lookup"><span data-stu-id="b3203-688">The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-689">使用此重载时，当消息在队列中可用或指定的时间间隔到期时，将直接调用在回调参数中指定的回调; <xref:System.Messaging.MessageQueue.ReceiveCompleted> 不引发该事件。</span><span class="sxs-lookup"><span data-stu-id="b3203-689">When you use this overload, the callback specified in the callback parameter is invoked directly when a message becomes available in the queue or when the specified interval of time has expired; the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event is not raised.</span></span> <span data-ttu-id="b3203-690">的其他重载 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 依赖于此组件来引发 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 事件。</span><span class="sxs-lookup"><span data-stu-id="b3203-690">The other overloads of <xref:System.Messaging.MessageQueue.BeginReceive%2A> rely on this component to raise the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event.</span></span>  
  
 <span data-ttu-id="b3203-691"><xref:System.Messaging.MessageQueue.ReceiveCompleted> 如果队列中已经存在消息，也会引发。</span><span class="sxs-lookup"><span data-stu-id="b3203-691"><xref:System.Messaging.MessageQueue.ReceiveCompleted> is also raised if a message already exists in the queue.</span></span>  
  
 <span data-ttu-id="b3203-692">若要使用 <xref:System.Messaging.MessageQueue.BeginReceive%2A> ，请创建一个事件处理程序，用于处理异步操作的结果并将其与事件委托相关联。</span><span class="sxs-lookup"><span data-stu-id="b3203-692">To use <xref:System.Messaging.MessageQueue.BeginReceive%2A>, create an event handler that processes the results of the asynchronous operation and associate it with your event delegate.</span></span> <span data-ttu-id="b3203-693"><xref:System.Messaging.MessageQueue.BeginReceive%2A> 启动异步接收操作; <xref:System.Messaging.MessageQueue> <xref:System.Messaging.MessageQueue.ReceiveCompleted> 当消息到达队列时，会通过引发事件通知。</span><span class="sxs-lookup"><span data-stu-id="b3203-693"><xref:System.Messaging.MessageQueue.BeginReceive%2A> initiates an asynchronous receive operation; the <xref:System.Messaging.MessageQueue> is notified, through the raising of the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event, when a message arrives in the queue.</span></span> <span data-ttu-id="b3203-694"><xref:System.Messaging.MessageQueue>然后，可以通过调用 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 或使用检索结果来访问消息 <xref:System.Messaging.ReceiveCompletedEventArgs> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-694">The <xref:System.Messaging.MessageQueue> can then access the message by calling <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> or retrieving the result using the <xref:System.Messaging.ReceiveCompletedEventArgs>.</span></span>  
  
 <span data-ttu-id="b3203-695"><xref:System.Messaging.MessageQueue.BeginReceive%2A>方法会立即返回，但在调用事件处理程序之前，不会完成异步操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-695">The <xref:System.Messaging.MessageQueue.BeginReceive%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</span></span>  
  
 <span data-ttu-id="b3203-696">由于 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 是异步的，因此你可以调用它来接收队列中的消息，而不会阻止当前的执行线程。</span><span class="sxs-lookup"><span data-stu-id="b3203-696">Because <xref:System.Messaging.MessageQueue.BeginReceive%2A> is asynchronous, you can call it to receive a message from the queue without blocking the current thread of execution.</span></span> <span data-ttu-id="b3203-697">若要以同步方式接收消息，请使用 <xref:System.Messaging.MessageQueue.Receive%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-697">To synchronously receive a message, use the <xref:System.Messaging.MessageQueue.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="b3203-698">异步操作完成后，可以 <xref:System.Messaging.MessageQueue.BeginPeek%2A> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 在事件处理程序中调用或再次运行以继续接收通知。</span><span class="sxs-lookup"><span data-stu-id="b3203-698">Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.</span></span>  
  
 <span data-ttu-id="b3203-699">返回的将 <xref:System.IAsyncResult> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 标识该方法启动的异步操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-699">The <xref:System.IAsyncResult> that <xref:System.Messaging.MessageQueue.BeginReceive%2A> returns identifies the asynchronous operation that the method started.</span></span> <span data-ttu-id="b3203-700">可以在 <xref:System.IAsyncResult> 操作的整个生存期内使用此方法，不过，在调用之前，通常不使用此方法 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-700">You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> is called.</span></span> <span data-ttu-id="b3203-701">但是，如果您启动多个异步操作，则可以将它们的 <xref:System.IAsyncResult> 值放在数组中，并指定是否等待所有操作或任何操作完成。</span><span class="sxs-lookup"><span data-stu-id="b3203-701">However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete.</span></span> <span data-ttu-id="b3203-702">在这种情况下，请使用 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 的属性 <xref:System.IAsyncResult> 来标识已完成的操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-702">In this case, use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.</span></span>  
  
 <span data-ttu-id="b3203-703">状态对象将状态信息与操作相关联。</span><span class="sxs-lookup"><span data-stu-id="b3203-703">The state object associates state information with the operation.</span></span> <span data-ttu-id="b3203-704">例如，如果 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 多次调用来启动多个操作，则可以通过定义的单独状态对象标识每个操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-704">For example, if you call <xref:System.Messaging.MessageQueue.BeginReceive%2A> multiple times to initiate multiple operations, you can identify each operation through a separate state object that you define.</span></span>  
  
 <span data-ttu-id="b3203-705">你还可以使用状态对象跨进程线程传递信息。</span><span class="sxs-lookup"><span data-stu-id="b3203-705">You can also use the state object to pass information across process threads.</span></span> <span data-ttu-id="b3203-706">如果线程已启动，但回调在异步方案中的其他线程上，则将对状态对象进行封送处理，并将其与事件中的信息一起传递回来。</span><span class="sxs-lookup"><span data-stu-id="b3203-706">If a thread is started but the callback is on a different thread in an asynchronous scenario, the state object is marshaled and passed back along with information from the event.</span></span>  
  
 <span data-ttu-id="b3203-707">不要对事务使用异步调用 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-707">Do not use the asynchronous call <xref:System.Messaging.MessageQueue.BeginReceive%2A> with transactions.</span></span> <span data-ttu-id="b3203-708">如果要执行事务异步操作，请调用 <xref:System.Messaging.MessageQueue.BeginPeek%2A> ，并在 <xref:System.Messaging.MessageQueue.Receive%2A> 为查看操作创建的事件处理程序中放置事务和 (同步) 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-708">If you want to perform a transactional asynchronous operation, call <xref:System.Messaging.MessageQueue.BeginPeek%2A>, and put the transaction and the (synchronous) <xref:System.Messaging.MessageQueue.Receive%2A> method within the event handler you create for the peek operation.</span></span> <span data-ttu-id="b3203-709">你的事件处理程序可能包含以下 c # 代码中所示的功能。</span><span class="sxs-lookup"><span data-stu-id="b3203-709">Your event handler might contain functionality as shown in the following C# code.</span></span>  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 <span data-ttu-id="b3203-710">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-710">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-711">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-711">Workgroup mode</span></span>|<span data-ttu-id="b3203-712">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-712">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-713">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-713">Local computer</span></span>|<span data-ttu-id="b3203-714">是</span><span class="sxs-lookup"><span data-stu-id="b3203-714">Yes</span></span>|  
|<span data-ttu-id="b3203-715">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-715">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-716">是</span><span class="sxs-lookup"><span data-stu-id="b3203-716">Yes</span></span>|  
|<span data-ttu-id="b3203-717">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-717">Remote computer</span></span>|<span data-ttu-id="b3203-718">否</span><span class="sxs-lookup"><span data-stu-id="b3203-718">No</span></span>|  
|<span data-ttu-id="b3203-719">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-719">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-720">是</span><span class="sxs-lookup"><span data-stu-id="b3203-720">Yes</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3203-721"><paramref name="cursor" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-721">The <paramref name="cursor" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-722">为 <paramref name="timeout" /> 参数指定的值无效。</span><span class="sxs-lookup"><span data-stu-id="b3203-722">The value specified for the <paramref name="timeout" /> parameter is not valid.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-723">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-723">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="b3203-724">方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="b3203-724">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Messaging.MessageQueue.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_CanRead")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_CanRead")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-725">获取一个值，该值指示 <see cref="T:System.Messaging.MessageQueue" /> 是否可读。</span><span class="sxs-lookup"><span data-stu-id="b3203-725">Gets a value that indicates whether the <see cref="T:System.Messaging.MessageQueue" /> can be read.</span></span></summary>
        <value><span data-ttu-id="b3203-726">如果存在 <see cref="T:System.Messaging.MessageQueue" /> 而且应用程序可从其中读取，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-726"><see langword="true" /> if the <see cref="T:System.Messaging.MessageQueue" /> exists and the application can read from it; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-727"><xref:System.Messaging.MessageQueue.CanRead%2A> 指示应用程序是否能够查看或接收来自队列的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-727"><xref:System.Messaging.MessageQueue.CanRead%2A> indicates whether the application is able to peek or receive messages from the queue.</span></span> <span data-ttu-id="b3203-728">如果 <xref:System.Messaging.MessageQueue.CanRead%2A> 为 `true` ，则 <xref:System.Messaging.MessageQueue> 可以接收或查看队列中的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-728">If <xref:System.Messaging.MessageQueue.CanRead%2A> is `true`, the <xref:System.Messaging.MessageQueue> can receive or peek messages from the queue.</span></span> <span data-ttu-id="b3203-729">否则，不能。</span><span class="sxs-lookup"><span data-stu-id="b3203-729">Otherwise, it cannot.</span></span>  
  
 <span data-ttu-id="b3203-730"><xref:System.Messaging.MessageQueue.CanRead%2A>`false`如果队列已使用独占读取访问 (权限打开，或者它是使用非独占访问权限打开的，并且这 <xref:System.Messaging.MessageQueue> 请求) 独占访问权限，或者应用程序没有足够的权限访问它，则为。</span><span class="sxs-lookup"><span data-stu-id="b3203-730"><xref:System.Messaging.MessageQueue.CanRead%2A> is `false` if a queue is already open with exclusive read access (or if it's open with non-exclusive access and this <xref:System.Messaging.MessageQueue> requests exclusive access), or if the application does not have sufficient rights to access it.</span></span> <span data-ttu-id="b3203-731">如果你的应用程序在为时尝试从队列读取 <xref:System.Messaging.MessageQueue.CanRead%2A> `false` ，则拒绝访问。</span><span class="sxs-lookup"><span data-stu-id="b3203-731">If your application tries to read from a queue when <xref:System.Messaging.MessageQueue.CanRead%2A> is `false`, access is denied.</span></span>  
  
 <span data-ttu-id="b3203-732">下表显示了此属性在各种工作组模式下是否可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-732">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-733">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-733">Workgroup mode</span></span>|<span data-ttu-id="b3203-734">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-734">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-735">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-735">Local computer</span></span>|<span data-ttu-id="b3203-736">是</span><span class="sxs-lookup"><span data-stu-id="b3203-736">Yes</span></span>|  
|<span data-ttu-id="b3203-737">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-737">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-738">是</span><span class="sxs-lookup"><span data-stu-id="b3203-738">Yes</span></span>|  
|<span data-ttu-id="b3203-739">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-739">Remote computer</span></span>|<span data-ttu-id="b3203-740">否</span><span class="sxs-lookup"><span data-stu-id="b3203-740">No</span></span>|  
|<span data-ttu-id="b3203-741">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-741">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-742">是</span><span class="sxs-lookup"><span data-stu-id="b3203-742">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-743">下面的代码示例显示消息队列属性的值 <xref:System.Messaging.MessageQueue.CanRead%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-743">The following code example displays the value of a message queue's <xref:System.Messaging.MessageQueue.CanRead%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Messaging.MessageQueue.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_CanWrite")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_CanWrite")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-744">获取一个值，该值指示 <see cref="T:System.Messaging.MessageQueue" /> 是否可写。</span><span class="sxs-lookup"><span data-stu-id="b3203-744">Gets a value that indicates whether the <see cref="T:System.Messaging.MessageQueue" /> can be written to.</span></span></summary>
        <value><span data-ttu-id="b3203-745">如果存在 <see cref="T:System.Messaging.MessageQueue" /> 而且应用程序可向其中写入，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-745"><see langword="true" /> if the <see cref="T:System.Messaging.MessageQueue" /> exists and the application can write to it; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-746"><xref:System.Messaging.MessageQueue.CanWrite%2A> 指示应用程序是否能够将消息发送到队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-746"><xref:System.Messaging.MessageQueue.CanWrite%2A> indicates whether the application is able to send messages to the queue.</span></span> <span data-ttu-id="b3203-747">如果 <xref:System.Messaging.MessageQueue.CanWrite%2A> 为 `true` ，则 <xref:System.Messaging.MessageQueue> 可以将消息发送到队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-747">If <xref:System.Messaging.MessageQueue.CanWrite%2A> is `true`, the <xref:System.Messaging.MessageQueue> can send messages to the queue.</span></span> <span data-ttu-id="b3203-748">否则，不能。</span><span class="sxs-lookup"><span data-stu-id="b3203-748">Otherwise, it cannot.</span></span>  
  
 <span data-ttu-id="b3203-749"><xref:System.Messaging.MessageQueue.CanWrite%2A>`false`如果队列已使用独占写入访问 (权限打开，或者它是使用非独占访问权限打开的，并且这 <xref:System.Messaging.MessageQueue> 请求) 独占访问权限，或者应用程序没有足够的权限访问它，则为。</span><span class="sxs-lookup"><span data-stu-id="b3203-749"><xref:System.Messaging.MessageQueue.CanWrite%2A> is `false` if a queue is already open with exclusive write access (or if it's open with non-exclusive access and this <xref:System.Messaging.MessageQueue> requests exclusive access), or if the application does not have sufficient rights to access it.</span></span> <span data-ttu-id="b3203-750">如果你的应用程序在为时尝试写入 <xref:System.Messaging.MessageQueue.CanWrite%2A> 队列 `false` ，则拒绝访问。</span><span class="sxs-lookup"><span data-stu-id="b3203-750">If your application tries to write to a queue when <xref:System.Messaging.MessageQueue.CanWrite%2A> is `false`, access is denied.</span></span>  
  
 <span data-ttu-id="b3203-751">下表显示了此属性在各种工作组模式下是否可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-751">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-752">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-752">Workgroup mode</span></span>|<span data-ttu-id="b3203-753">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-753">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-754">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-754">Local computer</span></span>|<span data-ttu-id="b3203-755">是</span><span class="sxs-lookup"><span data-stu-id="b3203-755">Yes</span></span>|  
|<span data-ttu-id="b3203-756">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-756">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-757">是</span><span class="sxs-lookup"><span data-stu-id="b3203-757">Yes</span></span>|  
|<span data-ttu-id="b3203-758">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-758">Remote computer</span></span>|<span data-ttu-id="b3203-759">否</span><span class="sxs-lookup"><span data-stu-id="b3203-759">No</span></span>|  
|<span data-ttu-id="b3203-760">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-760">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-761">是</span><span class="sxs-lookup"><span data-stu-id="b3203-761">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-762">下面的代码示例显示消息队列属性的值 <xref:System.Messaging.MessageQueue.CanWrite%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-762">The following code example displays the value of a message queue's <xref:System.Messaging.MessageQueue.CanWrite%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberSignature Language="VB.NET" Value="Public Property Category As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Category { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.Category : Guid with get, set" Usage="System.Messaging.MessageQueue.Category" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_Category")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_Category")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-763">获取或设置队列类别。</span><span class="sxs-lookup"><span data-stu-id="b3203-763">Gets or sets the queue category.</span></span></summary>
        <value><span data-ttu-id="b3203-764"><see cref="T:System.Guid" />，表示队列类别（“消息队列”类型标识符），它允许应用程序将其队列分类。</span><span class="sxs-lookup"><span data-stu-id="b3203-764">A <see cref="T:System.Guid" /> that represents the queue category (Message Queuing type identifier), which allows an application to categorize its queues.</span></span> <span data-ttu-id="b3203-765">默认值为 <see langword="Guid.empty" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-765">The default is <see langword="Guid.empty" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-766">队列类别允许应用程序将其队列分类。</span><span class="sxs-lookup"><span data-stu-id="b3203-766">The queue category allows an application to categorize its queues.</span></span> <span data-ttu-id="b3203-767">例如，您可以将所有计费队列放在一个类别中，将所有订单队列放在另一个类别中。</span><span class="sxs-lookup"><span data-stu-id="b3203-767">For example, you can place all Billing queues in one category and all Order queues in another.</span></span>  
  
 <span data-ttu-id="b3203-768"><xref:System.Messaging.MessageQueue.Category%2A>属性提供对 "消息队列类型 ID" 属性的访问， (这是读/写) ，可通过 "计算机管理" 控制台中的 "**队列属性**" 对话框进行访问。</span><span class="sxs-lookup"><span data-stu-id="b3203-768">The <xref:System.Messaging.MessageQueue.Category%2A> property provides access to the Message Queuing Type ID property (which is read/write), accessible through the **Queue Properties** dialog box in the Computer Management Console.</span></span> <span data-ttu-id="b3203-769">您可以定义一个新类别。</span><span class="sxs-lookup"><span data-stu-id="b3203-769">You can define a new category.</span></span> <span data-ttu-id="b3203-770">尽管可以使用 <xref:System.Guid.NewGuid%2A> 来创建在所有值中都是唯一的类别值，但不 <xref:System.Guid> 需要执行此类操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-770">Although you can use <xref:System.Guid.NewGuid%2A> to create a category value that is unique across all <xref:System.Guid> values, such an action is unnecessary.</span></span> <span data-ttu-id="b3203-771">类别值仅需与其他类别（而不是所有其他值）不同 <xref:System.Guid> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-771">The category value needs to be distinct only from other categories, not from all other <xref:System.Guid> values.</span></span> <span data-ttu-id="b3203-772">例如，可以将分配为 {00000000-0000-0000-0000-000000000001} <xref:System.Messaging.MessageQueue.Category%2A> 一组队列，并将指定为另一组队列 {00000000-0000-0000-0000-000000000002} 的 <xref:System.Messaging.MessageQueue.Category%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-772">For example, you can assign {00000000-0000-0000-0000-000000000001} as the <xref:System.Messaging.MessageQueue.Category%2A> for one set of queues and {00000000-0000-0000-0000-000000000002} as the <xref:System.Messaging.MessageQueue.Category%2A> for another set.</span></span>  
  
 <span data-ttu-id="b3203-773">不需要设置 <xref:System.Messaging.MessageQueue.Category%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-773">It is not necessary to set the <xref:System.Messaging.MessageQueue.Category%2A>.</span></span> <span data-ttu-id="b3203-774">该值可以为 `null`。</span><span class="sxs-lookup"><span data-stu-id="b3203-774">The value can be `null`.</span></span>  
  
 <span data-ttu-id="b3203-775">设置此属性将修改 "消息队列" 队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-775">Setting this property modifies the Message Queuing queue.</span></span> <span data-ttu-id="b3203-776">因此， <xref:System.Messaging.MessageQueue> 此更改会影响任何其他实例。</span><span class="sxs-lookup"><span data-stu-id="b3203-776">Therefore, any other <xref:System.Messaging.MessageQueue> instances are affected by the change.</span></span>  
  
 <span data-ttu-id="b3203-777">下表显示了此属性在各种工作组模式下是否可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-777">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-778">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-778">Workgroup mode</span></span>|<span data-ttu-id="b3203-779">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-779">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-780">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-780">Local computer</span></span>|<span data-ttu-id="b3203-781">是</span><span class="sxs-lookup"><span data-stu-id="b3203-781">Yes</span></span>|  
|<span data-ttu-id="b3203-782">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-782">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-783">是</span><span class="sxs-lookup"><span data-stu-id="b3203-783">Yes</span></span>|  
|<span data-ttu-id="b3203-784">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-784">Remote computer</span></span>|<span data-ttu-id="b3203-785">否</span><span class="sxs-lookup"><span data-stu-id="b3203-785">No</span></span>|  
|<span data-ttu-id="b3203-786">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-786">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-787">否</span><span class="sxs-lookup"><span data-stu-id="b3203-787">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-788">下面的代码示例获取并设置消息队列属性的值 <xref:System.Messaging.MessageQueue.Category%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-788">The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.Category%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-789">队列类别被设置为无效值。</span><span class="sxs-lookup"><span data-stu-id="b3203-789">The queue category was set to an invalid value.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-790">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-790">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.Id" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearConnectionCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearConnectionCache();" />
      <MemberSignature Language="F#" Value="static member ClearConnectionCache : unit -&gt; unit" Usage="System.Messaging.MessageQueue.ClearConnectionCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b3203-791">清除连接缓存。</span><span class="sxs-lookup"><span data-stu-id="b3203-791">Clears the connection cache.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-792">调用时 <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A> ，将删除存储在缓存中的格式名称，并关闭缓存中打开和存储的句柄。</span><span class="sxs-lookup"><span data-stu-id="b3203-792">When you call <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, the format names stored in the cache are removed and handles opened and stored in the cache are closed.</span></span>  
  
 <span data-ttu-id="b3203-793">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-793">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-794">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-794">Workgroup mode</span></span>|<span data-ttu-id="b3203-795">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-795">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-796">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-796">Local computer</span></span>|<span data-ttu-id="b3203-797">是</span><span class="sxs-lookup"><span data-stu-id="b3203-797">Yes</span></span>|  
|<span data-ttu-id="b3203-798">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-798">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-799">是</span><span class="sxs-lookup"><span data-stu-id="b3203-799">Yes</span></span>|  
|<span data-ttu-id="b3203-800">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-800">Remote computer</span></span>|<span data-ttu-id="b3203-801">是</span><span class="sxs-lookup"><span data-stu-id="b3203-801">Yes</span></span>|  
|<span data-ttu-id="b3203-802">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-802">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-803">是</span><span class="sxs-lookup"><span data-stu-id="b3203-803">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-804">下面的代码示例调用 <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>。</span><span class="sxs-lookup"><span data-stu-id="b3203-804">The following code example calls <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>.</span></span>  
  
 [!code-csharp[MessageQueue#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageQueue.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b3203-805">释放 <see cref="T:System.Messaging.MessageQueue" /> 分配的所有资源。</span><span class="sxs-lookup"><span data-stu-id="b3203-805">Frees all resources allocated by the <see cref="T:System.Messaging.MessageQueue" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-806"><xref:System.Messaging.MessageQueue.Close%2A> 释放与关联的所有资源 <xref:System.Messaging.MessageQueue> ，包括共享资源（如果适用）。</span><span class="sxs-lookup"><span data-stu-id="b3203-806"><xref:System.Messaging.MessageQueue.Close%2A> frees all resources associated with a <xref:System.Messaging.MessageQueue>, including shared resources if appropriate.</span></span> <span data-ttu-id="b3203-807">如果这些资源仍可用，则系统会自动重新获取这些资源，例如，当你调用 <xref:System.Messaging.MessageQueue.Send%28System.Object%29> 方法时，如以下 c # 代码中所示。</span><span class="sxs-lookup"><span data-stu-id="b3203-807">The system re-acquires these resources automatically if they are still available, for example when you call the <xref:System.Messaging.MessageQueue.Send%28System.Object%29> method, as in the following C# code.</span></span>  
  
```csharp  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 <span data-ttu-id="b3203-808">调用时 <xref:System.Messaging.MessageQueue.Close%2A> ， <xref:System.Messaging.MessageQueue> 将清除直接访问 "消息队列" 队列的所有属性。 <xref:System.Messaging.MessageQueue.Path%2A>、、 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> <xref:System.Messaging.MessageQueue.Formatter%2A> 和 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> 都保留原样。</span><span class="sxs-lookup"><span data-stu-id="b3203-808">When you call <xref:System.Messaging.MessageQueue.Close%2A>, all <xref:System.Messaging.MessageQueue> properties that directly access the Message Queuing queue are cleared out. The <xref:System.Messaging.MessageQueue.Path%2A>, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, <xref:System.Messaging.MessageQueue.Formatter%2A>, and <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> all remain as they were.</span></span>  
  
 <span data-ttu-id="b3203-809"><xref:System.Messaging.MessageQueue.Close%2A> 不要始终释放队列的读取和写入句柄，因为它们可能已共享。</span><span class="sxs-lookup"><span data-stu-id="b3203-809"><xref:System.Messaging.MessageQueue.Close%2A> does not always free the read and write handles to a queue, because they might be shared.</span></span> <span data-ttu-id="b3203-810">可以执行以下任何步骤，以确保 <xref:System.Messaging.MessageQueue.Close%2A> 释放队列的读取和写入句柄：</span><span class="sxs-lookup"><span data-stu-id="b3203-810">You can take any of the following steps to ensure that <xref:System.Messaging.MessageQueue.Close%2A> frees the read and write handles to a queue:</span></span>  
  
-   <span data-ttu-id="b3203-811">创建 <xref:System.Messaging.MessageQueue> 具有独占访问权限的。</span><span class="sxs-lookup"><span data-stu-id="b3203-811">Create the <xref:System.Messaging.MessageQueue> with exclusive access.</span></span> <span data-ttu-id="b3203-812">为此，请调用 <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29> 或 <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> 构造函数，并将 `sharedModeDenyReceive` 参数设置为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-812">To do so, call the <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29> or <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> constructor, and set the `sharedModeDenyReceive` parameter to `true`.</span></span>  
  
-   <span data-ttu-id="b3203-813">在 <xref:System.Messaging.MessageQueue> 禁用连接缓存的情况创建。</span><span class="sxs-lookup"><span data-stu-id="b3203-813">Create the <xref:System.Messaging.MessageQueue> with connection caching disabled.</span></span> <span data-ttu-id="b3203-814">为此，请调用 <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> 构造函数并将 `enableConnectionCache` 参数设置为 `false` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-814">To do so, call the <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> constructor and set the `enableConnectionCache` parameter to `false`.</span></span>  
  
-   <span data-ttu-id="b3203-815">禁用连接缓存。</span><span class="sxs-lookup"><span data-stu-id="b3203-815">Disable connection caching.</span></span> <span data-ttu-id="b3203-816">为此，请将 <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> 属性设置为 `false` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-816">To do so, set the <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> property to `false`.</span></span>  
  
 <span data-ttu-id="b3203-817">在 <xref:System.Messaging.MessageQueue.Close%2A> 删除消息队列服务器上的队列之前，应调用队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-817">You should call <xref:System.Messaging.MessageQueue.Close%2A> for a queue before you delete the queue on the Message Queuing server.</span></span> <span data-ttu-id="b3203-818">否则，发送到队列的消息可能会引发异常或出现在死信队列中。</span><span class="sxs-lookup"><span data-stu-id="b3203-818">Otherwise, messages sent to the queue could throw exceptions or appear in the dead-letter queue.</span></span>  
  
 <span data-ttu-id="b3203-819">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-819">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-820">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-820">Workgroup mode</span></span>|<span data-ttu-id="b3203-821">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-821">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-822">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-822">Local computer</span></span>|<span data-ttu-id="b3203-823">是</span><span class="sxs-lookup"><span data-stu-id="b3203-823">Yes</span></span>|  
|<span data-ttu-id="b3203-824">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-824">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-825">是</span><span class="sxs-lookup"><span data-stu-id="b3203-825">Yes</span></span>|  
|<span data-ttu-id="b3203-826">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-826">Remote computer</span></span>|<span data-ttu-id="b3203-827">是</span><span class="sxs-lookup"><span data-stu-id="b3203-827">Yes</span></span>|  
|<span data-ttu-id="b3203-828">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-828">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-829">是</span><span class="sxs-lookup"><span data-stu-id="b3203-829">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-830">下面的代码示例关闭 "消息队列" 队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-830">The following code example closes a Message Queuing queue.</span></span>  
  
 [!code-cpp[MessageQueue.Close#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b3203-831">在“消息队列”服务器上的指定路径中创建新队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-831">Creates a new queue at the specified path on a Message Queuing server.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b3203-832">要创建的队列的路径。</span><span class="sxs-lookup"><span data-stu-id="b3203-832">The path of the queue to create.</span></span></param>
        <summary><span data-ttu-id="b3203-833">在指定的路径中创建非事务性“消息队列”队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-833">Creates a non-transactional Message Queuing queue at the specified path.</span></span></summary>
        <returns><span data-ttu-id="b3203-834">表示新队列的 <see cref="T:System.Messaging.MessageQueue" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-834">A <see cref="T:System.Messaging.MessageQueue" /> that represents the new queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-835">使用此重载创建非事务性 "消息队列" 队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-835">Use this overload to create a non-transactional Message Queuing queue.</span></span>  
  
 <span data-ttu-id="b3203-836">若要 <xref:System.Messaging.MessageQueue> 在应用程序中创建类的新实例并将其绑定到现有队列，请使用 <xref:System.Messaging.MessageQueue.%23ctor%2A> 构造函数。</span><span class="sxs-lookup"><span data-stu-id="b3203-836">To create a new instance of the <xref:System.Messaging.MessageQueue> class in your application and bind it to an existing queue, use the <xref:System.Messaging.MessageQueue.%23ctor%2A> constructor.</span></span> <span data-ttu-id="b3203-837">若要在消息队列中创建新队列，请调用 <xref:System.Messaging.MessageQueue.Create%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-837">To create a new queue in Message Queuing, call <xref:System.Messaging.MessageQueue.Create%28System.String%29>.</span></span>  
  
 <span data-ttu-id="b3203-838">参数的语法 `path` 取决于它所引用的队列的类型，如下表所示。</span><span class="sxs-lookup"><span data-stu-id="b3203-838">The syntax for the `path` parameter depends on the type of queue it references, as shown in the following table.</span></span>  
  
|<span data-ttu-id="b3203-839">队列类型</span><span class="sxs-lookup"><span data-stu-id="b3203-839">Queue type</span></span>|<span data-ttu-id="b3203-840">语法</span><span class="sxs-lookup"><span data-stu-id="b3203-840">Syntax</span></span>|  
|----------------|------------|  
|<span data-ttu-id="b3203-841">公用队列</span><span class="sxs-lookup"><span data-stu-id="b3203-841">Public queue</span></span>|`MachineName`\\`QueueName`|  
|<span data-ttu-id="b3203-842">专用队列</span><span class="sxs-lookup"><span data-stu-id="b3203-842">Private queue</span></span>|`MachineName`\\`Private$`\\`QueueName`|  
  
 <span data-ttu-id="b3203-843">使用 "." 表示本地计算机。</span><span class="sxs-lookup"><span data-stu-id="b3203-843">Use "." for the local computer.</span></span> <span data-ttu-id="b3203-844">有关更多语法，请参见 <xref:System.Messaging.MessageQueue.Path%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="b3203-844">For more syntax, see the <xref:System.Messaging.MessageQueue.Path%2A> property.</span></span>  
  
 <span data-ttu-id="b3203-845">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-845">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-846">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-846">Workgroup mode</span></span>|<span data-ttu-id="b3203-847">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-847">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-848">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-848">Local computer</span></span>|<span data-ttu-id="b3203-849">是</span><span class="sxs-lookup"><span data-stu-id="b3203-849">Yes</span></span>|  
|<span data-ttu-id="b3203-850">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-850">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-851">是</span><span class="sxs-lookup"><span data-stu-id="b3203-851">Yes</span></span>|  
|<span data-ttu-id="b3203-852">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-852">Remote computer</span></span>|<span data-ttu-id="b3203-853">否</span><span class="sxs-lookup"><span data-stu-id="b3203-853">No</span></span>|  
|<span data-ttu-id="b3203-854">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-854">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-855">否</span><span class="sxs-lookup"><span data-stu-id="b3203-855">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-856">下面的代码示例创建公用和专用队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-856">The following code example creates public and private queues.</span></span> <span data-ttu-id="b3203-857">它将消息发送到所选队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-857">It sends a message to selected queues.</span></span>  
  
 [!code-cpp[MessageQueue.Create_path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create_path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create_path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-858"><paramref name="path" /> 参数为 <see langword="null" /> 或者是空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="b3203-858">The <paramref name="path" /> parameter is <see langword="null" /> or is an empty string ("").</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-859">队列已存在于指定的路径中。</span><span class="sxs-lookup"><span data-stu-id="b3203-859">A queue already exists at the specified path.</span></span>  
  
 <span data-ttu-id="b3203-860">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-860">-or-</span></span>  
  
 <span data-ttu-id="b3203-861">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-861">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, transactional As Boolean) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path, bool transactional);" />
      <MemberSignature Language="F#" Value="static member Create : string * bool -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create (path, transactional)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b3203-862">要创建的队列的路径。</span><span class="sxs-lookup"><span data-stu-id="b3203-862">The path of the queue to create.</span></span></param>
        <param name="transactional"><span data-ttu-id="b3203-863">如果创建事务性队列，为 <see langword="true" />；如果创建非事务性队列，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-863"><see langword="true" /> to create a transactional queue; <see langword="false" /> to create a non-transactional queue.</span></span></param>
        <summary><span data-ttu-id="b3203-864">在指定的路径中创建事务性或非事务性“消息队列”队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-864">Creates a transactional or non-transactional Message Queuing queue at the specified path.</span></span></summary>
        <returns><span data-ttu-id="b3203-865">表示新队列的 <see cref="T:System.Messaging.MessageQueue" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-865">A <see cref="T:System.Messaging.MessageQueue" /> that represents the new queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-866">您可以使用此重载在消息队列中创建事务性队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-866">You can use this overload to create a transactional queue in Message Queuing.</span></span> <span data-ttu-id="b3203-867">可以通过将 `transactional` 参数设置为 `false` 或，通过调用的其他重载，来创建非事务性队列 <xref:System.Messaging.MessageQueue.Create%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-867">You can create a non-transactional queue, by setting the `transactional` parameter to `false` or by calling the other overload of <xref:System.Messaging.MessageQueue.Create%28System.String%29>.</span></span>  
  
 <span data-ttu-id="b3203-868">若要 <xref:System.Messaging.MessageQueue> 在应用程序中创建类的新实例并将其绑定到现有队列，请使用 <xref:System.Messaging.MessageQueue.%23ctor%2A> 构造函数。</span><span class="sxs-lookup"><span data-stu-id="b3203-868">To create a new instance of the <xref:System.Messaging.MessageQueue> class in your application and bind it to an existing queue, use the <xref:System.Messaging.MessageQueue.%23ctor%2A> constructor.</span></span> <span data-ttu-id="b3203-869">若要在消息队列中创建新队列，请调用 <xref:System.Messaging.MessageQueue.Create%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-869">To create a new queue in Message Queuing, call <xref:System.Messaging.MessageQueue.Create%28System.String%29>.</span></span>  
  
 <span data-ttu-id="b3203-870">参数的语法 `path` 取决于它所引用的队列的类型，如下表所示。</span><span class="sxs-lookup"><span data-stu-id="b3203-870">The syntax for the `path` parameter depends on the type of queue it references, as shown in the following table.</span></span>  
  
|<span data-ttu-id="b3203-871">队列类型</span><span class="sxs-lookup"><span data-stu-id="b3203-871">Queue type</span></span>|<span data-ttu-id="b3203-872">语法</span><span class="sxs-lookup"><span data-stu-id="b3203-872">Syntax</span></span>|  
|----------------|------------|  
|<span data-ttu-id="b3203-873">公用队列</span><span class="sxs-lookup"><span data-stu-id="b3203-873">Public queue</span></span>|`MachineName`\\`QueueName`|  
|<span data-ttu-id="b3203-874">专用队列</span><span class="sxs-lookup"><span data-stu-id="b3203-874">Private queue</span></span>|`MachineName`\\`Private$`\\`QueueName`|  
  
 <span data-ttu-id="b3203-875">使用 "." 表示本地计算机。</span><span class="sxs-lookup"><span data-stu-id="b3203-875">Use "." for the local computer.</span></span> <span data-ttu-id="b3203-876">有关更多语法，请参见 <xref:System.Messaging.MessageQueue.Path%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="b3203-876">For more syntax, see the <xref:System.Messaging.MessageQueue.Path%2A> property.</span></span>  
  
 <span data-ttu-id="b3203-877">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-877">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-878">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-878">Workgroup mode</span></span>|<span data-ttu-id="b3203-879">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-879">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-880">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-880">Local computer</span></span>|<span data-ttu-id="b3203-881">是</span><span class="sxs-lookup"><span data-stu-id="b3203-881">Yes</span></span>|  
|<span data-ttu-id="b3203-882">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-882">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-883">是</span><span class="sxs-lookup"><span data-stu-id="b3203-883">Yes</span></span>|  
|<span data-ttu-id="b3203-884">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-884">Remote computer</span></span>|<span data-ttu-id="b3203-885">否</span><span class="sxs-lookup"><span data-stu-id="b3203-885">No</span></span>|  
|<span data-ttu-id="b3203-886">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-886">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-887">否</span><span class="sxs-lookup"><span data-stu-id="b3203-887">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-888">下面的代码示例创建公共和专用事务性队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-888">The following code example creates public and private transactional queues.</span></span> <span data-ttu-id="b3203-889">它将消息发送到所选队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-889">It sends a message to selected queues.</span></span>  
  
 [!code-cpp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create_PathTransactional#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-890"><paramref name="path" /> 参数为 <see langword="null" /> 或者是空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="b3203-890">The <paramref name="path" /> parameter is <see langword="null" /> or is an empty string ("").</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-891">队列已存在于指定的路径中。</span><span class="sxs-lookup"><span data-stu-id="b3203-891">A queue already exists at the specified path.</span></span>  
  
 <span data-ttu-id="b3203-892">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-892">-or-</span></span>  
  
 <span data-ttu-id="b3203-893">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-893">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCursor () As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Cursor ^ CreateCursor();" />
      <MemberSignature Language="F#" Value="member this.CreateCursor : unit -&gt; System.Messaging.Cursor" Usage="messageQueue.CreateCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b3203-894">为当前消息队列创建新的 <see cref="T:System.Messaging.Cursor" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-894">Creates a new <see cref="T:System.Messaging.Cursor" /> for the current message queue.</span></span></summary>
        <returns><span data-ttu-id="b3203-895">当前消息队列的新 <see cref="T:System.Messaging.Cursor" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-895">A new <see cref="T:System.Messaging.Cursor" /> for the current message queue.</span></span> <span data-ttu-id="b3203-896">此游标用于在读取队列的消息时保持队列中的特定位置。</span><span class="sxs-lookup"><span data-stu-id="b3203-896">This cursor is used to maintain a specific location in the queue when reading the queue's messages.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Messaging.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreateTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime CreateTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateTime : DateTime" Usage="System.Messaging.MessageQueue.CreateTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_CreateTime")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_CreateTime")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-897">获取在“消息队列”中创建队列的时间和日期。</span><span class="sxs-lookup"><span data-stu-id="b3203-897">Gets the time and date that the queue was created in Message Queuing.</span></span></summary>
        <value><span data-ttu-id="b3203-898">表示队列创建日期和时间的 <see cref="T:System.DateTime" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-898">A <see cref="T:System.DateTime" /> that represents the date and time at which the queue was created.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-899"><xref:System.Messaging.MessageQueue.CreateTime%2A> 指的是消息队列服务器上的队列，而不是 <xref:System.Messaging.MessageQueue> 实例。</span><span class="sxs-lookup"><span data-stu-id="b3203-899"><xref:System.Messaging.MessageQueue.CreateTime%2A> refers to the queue on the Message Queuing server, not the <xref:System.Messaging.MessageQueue> instance.</span></span>  
  
 <span data-ttu-id="b3203-900">如果该队列存在，则此属性表示创建该队列的时间，并调整为该队列所在服务器的本地时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-900">If the queue exists, this property represents the time the queue was created, adjusted to the local time of the server on which the queue exists.</span></span>  
  
 <span data-ttu-id="b3203-901">下表显示了此属性在各种工作组模式下是否可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-901">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-902">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-902">Workgroup mode</span></span>|<span data-ttu-id="b3203-903">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-903">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-904">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-904">Local computer</span></span>|<span data-ttu-id="b3203-905">是</span><span class="sxs-lookup"><span data-stu-id="b3203-905">Yes</span></span>|  
|<span data-ttu-id="b3203-906">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-906">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-907">是</span><span class="sxs-lookup"><span data-stu-id="b3203-907">Yes</span></span>|  
|<span data-ttu-id="b3203-908">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-908">Remote computer</span></span>|<span data-ttu-id="b3203-909">否</span><span class="sxs-lookup"><span data-stu-id="b3203-909">No</span></span>|  
|<span data-ttu-id="b3203-910">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-910">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-911">否</span><span class="sxs-lookup"><span data-stu-id="b3203-911">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-912">下面的代码示例显示消息队列属性的值 <xref:System.Messaging.MessageQueue.CreateTime%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-912">The following code example displays the value of a message queue's <xref:System.Messaging.MessageQueue.CreateTime%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-913">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-913">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.LastModifyTime" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultPropertiesToSend As DefaultPropertiesToSend" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::DefaultPropertiesToSend ^ DefaultPropertiesToSend { System::Messaging::DefaultPropertiesToSend ^ get(); void set(System::Messaging::DefaultPropertiesToSend ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPropertiesToSend : System.Messaging.DefaultPropertiesToSend with get, set" Usage="System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-914">获取或设置(当应用程序向队列发送消息时)默认情况下使用的消息属性值。</span><span class="sxs-lookup"><span data-stu-id="b3203-914">Gets or sets the message property values to be used by default when the application sends messages to the queue.</span></span></summary>
        <value><span data-ttu-id="b3203-915"><see cref="T:System.Messaging.DefaultPropertiesToSend" />，它包含当应用程序向队列发送 <see cref="T:System.Messaging.Message" /> 实例以外的对象时使用的默认“消息队列”消息属性值。</span><span class="sxs-lookup"><span data-stu-id="b3203-915">A <see cref="T:System.Messaging.DefaultPropertiesToSend" /> that contains the default Message Queuing message property values used when the application sends objects other than <see cref="T:System.Messaging.Message" /> instances to the queue.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-916">向队列发送任何不属于类型的对象时 <xref:System.Messaging.Message> ，会将 <xref:System.Messaging.MessageQueue> 对象插入消息队列消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-916">When you send any object that is not of type <xref:System.Messaging.Message> to the queue, the <xref:System.Messaging.MessageQueue> inserts the object into a Message Queuing message.</span></span> <span data-ttu-id="b3203-917">此时，应用于在 <xref:System.Messaging.MessageQueue> 属性中指定的属性值的消息 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-917">At that time, the <xref:System.Messaging.MessageQueue> applies to the message the property values you specify in the <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> property.</span></span> <span data-ttu-id="b3203-918">相反，如果将发送 <xref:System.Messaging.Message> 到队列，则已为实例本身指定了这些属性，因此 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 将忽略 <xref:System.Messaging.Message> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-918">Conversely, if you send a <xref:System.Messaging.Message> to the queue, these properties are already specified for the instance itself, so <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> is ignored for the <xref:System.Messaging.Message>.</span></span>  
  
 <span data-ttu-id="b3203-919">尽管通过对象设置属性，但 <xref:System.Messaging.MessageQueue> <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 引用发送到队列的消息的属性，而不是队列本身。</span><span class="sxs-lookup"><span data-stu-id="b3203-919">Although you set the properties through the <xref:System.Messaging.MessageQueue> object, the <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> refers to the properties of the messages that are sent to the queue, not the queue itself.</span></span>  
  
 <span data-ttu-id="b3203-920">下表显示了这些属性的默认值。</span><span class="sxs-lookup"><span data-stu-id="b3203-920">The default values for the properties are shown in the following table.</span></span>  
  
|<span data-ttu-id="b3203-921">Property</span><span class="sxs-lookup"><span data-stu-id="b3203-921">Property</span></span>|<span data-ttu-id="b3203-922">默认值</span><span class="sxs-lookup"><span data-stu-id="b3203-922">Default value</span></span>|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|<span data-ttu-id="b3203-923">零</span><span class="sxs-lookup"><span data-stu-id="b3203-923">Zero (0)</span></span>|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|<span data-ttu-id="b3203-924">长度为零的字节数组</span><span class="sxs-lookup"><span data-stu-id="b3203-924">A zero-length array of bytes</span></span>|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|<span data-ttu-id="b3203-925">空字符串 ( "" ) </span><span class="sxs-lookup"><span data-stu-id="b3203-925">Empty string ("")</span></span>|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 <span data-ttu-id="b3203-926">下表显示了此属性在各种工作组模式下是否可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-926">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-927">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-927">Workgroup mode</span></span>|<span data-ttu-id="b3203-928">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-928">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-929">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-929">Local computer</span></span>|<span data-ttu-id="b3203-930">是</span><span class="sxs-lookup"><span data-stu-id="b3203-930">Yes</span></span>|  
|<span data-ttu-id="b3203-931">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-931">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-932">是</span><span class="sxs-lookup"><span data-stu-id="b3203-932">Yes</span></span>|  
|<span data-ttu-id="b3203-933">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-933">Remote computer</span></span>|<span data-ttu-id="b3203-934">是</span><span class="sxs-lookup"><span data-stu-id="b3203-934">Yes</span></span>|  
|<span data-ttu-id="b3203-935">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-935">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-936">是</span><span class="sxs-lookup"><span data-stu-id="b3203-936">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-937">下面的代码示例使用消息的优先级来确定要为消息发送的默认属性。</span><span class="sxs-lookup"><span data-stu-id="b3203-937">The following code example uses the priority of a message to determine default properties to send for the message.</span></span>  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-938">未能设置队列的默认属性，可能因为这些属性之一无效。</span><span class="sxs-lookup"><span data-stu-id="b3203-938">The default properties could not be set for the queue, possibly because one of the properties is not valid.</span></span></exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="T:System.Messaging.EncryptionAlgorithm" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Messaging.MessageQueue.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b3203-939">要删除的队列的位置。</span><span class="sxs-lookup"><span data-stu-id="b3203-939">The location of the queue to be deleted.</span></span></param>
        <summary><span data-ttu-id="b3203-940">删除“消息队列”服务器上的队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-940">Deletes a queue on a Message Queuing server.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-941">参数的语法 `path` 取决于队列的类型。</span><span class="sxs-lookup"><span data-stu-id="b3203-941">The syntax for the `path` parameter depends on the type of queue.</span></span>  
  
|<span data-ttu-id="b3203-942">队列类型</span><span class="sxs-lookup"><span data-stu-id="b3203-942">Queue type</span></span>|<span data-ttu-id="b3203-943">语法</span><span class="sxs-lookup"><span data-stu-id="b3203-943">Syntax</span></span>|  
|----------------|------------|  
|<span data-ttu-id="b3203-944">公用队列</span><span class="sxs-lookup"><span data-stu-id="b3203-944">Public queue</span></span>|`MachineName`\\`QueueName`|  
|<span data-ttu-id="b3203-945">专用队列</span><span class="sxs-lookup"><span data-stu-id="b3203-945">Private queue</span></span>|`MachineName`\\`Private$`\\`QueueName`|  
  
 <span data-ttu-id="b3203-946">有关更多语法，请参见 <xref:System.Messaging.MessageQueue.Path%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="b3203-946">For more syntax, see the <xref:System.Messaging.MessageQueue.Path%2A> property.</span></span>  
  
 <span data-ttu-id="b3203-947">或者，可以使用 <xref:System.Messaging.MessageQueue.FormatName%2A> 或 <xref:System.Messaging.MessageQueue.Label%2A> 来描述队列路径。</span><span class="sxs-lookup"><span data-stu-id="b3203-947">Alternatively, you can use the <xref:System.Messaging.MessageQueue.FormatName%2A> or <xref:System.Messaging.MessageQueue.Label%2A> to describe the queue path.</span></span>  
  
|<span data-ttu-id="b3203-948">参考</span><span class="sxs-lookup"><span data-stu-id="b3203-948">Reference</span></span>|<span data-ttu-id="b3203-949">语法</span><span class="sxs-lookup"><span data-stu-id="b3203-949">Syntax</span></span>|  
|---------------|------------|  
|<span data-ttu-id="b3203-950">格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-950">Format name</span></span>|<span data-ttu-id="b3203-951">Msmq.formatname： [ *格式名* ]</span><span class="sxs-lookup"><span data-stu-id="b3203-951">FormatName:[ *format name* ]</span></span>|  
|<span data-ttu-id="b3203-952">Label</span><span class="sxs-lookup"><span data-stu-id="b3203-952">Label</span></span>|<span data-ttu-id="b3203-953">标签： [ *标签* ]</span><span class="sxs-lookup"><span data-stu-id="b3203-953">Label:[ *label* ]</span></span>|  
  
 <span data-ttu-id="b3203-954">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-954">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-955">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-955">Workgroup mode</span></span>|<span data-ttu-id="b3203-956">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-956">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-957">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-957">Local computer</span></span>|<span data-ttu-id="b3203-958">是</span><span class="sxs-lookup"><span data-stu-id="b3203-958">Yes</span></span>|  
|<span data-ttu-id="b3203-959">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-959">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-960">是</span><span class="sxs-lookup"><span data-stu-id="b3203-960">Yes</span></span>|  
|<span data-ttu-id="b3203-961">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-961">Remote computer</span></span>|<span data-ttu-id="b3203-962">否</span><span class="sxs-lookup"><span data-stu-id="b3203-962">No</span></span>|  
|<span data-ttu-id="b3203-963">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-963">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-964">否</span><span class="sxs-lookup"><span data-stu-id="b3203-964">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-965">下面的代码示例将删除 "消息队列" 队列（如果存在）。</span><span class="sxs-lookup"><span data-stu-id="b3203-965">The following code example deletes a Message Queuing queue, if it exists.</span></span>  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-966"><paramref name="path" /> 参数为 <see langword="null" /> 或者是空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="b3203-966">The <paramref name="path" /> parameter is <see langword="null" /> or is an empty string ("").</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-967">该 <paramref name="path" /> 参数的语法无效。</span><span class="sxs-lookup"><span data-stu-id="b3203-967">The syntax for the <paramref name="path" /> parameter is not valid.</span></span>  
  
<span data-ttu-id="b3203-968">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-968">-or-</span></span> 
<span data-ttu-id="b3203-969">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-969">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberSignature Language="VB.NET" Value="Public Property DenySharedReceive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DenySharedReceive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DenySharedReceive : bool with get, set" Usage="System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_DenySharedReceive")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_DenySharedReceive")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-970">获取或设置一个值，该值指示此 <see cref="T:System.Messaging.MessageQueue" /> 对来自“消息队列”队列的消息是否有独占接收访问权。</span><span class="sxs-lookup"><span data-stu-id="b3203-970">Gets or sets a value that indicates whether this <see cref="T:System.Messaging.MessageQueue" /> has exclusive access to receive messages from the Message Queuing queue.</span></span></summary>
        <value><span data-ttu-id="b3203-971">如果此 <see cref="T:System.Messaging.MessageQueue" /> 对来自队列的消息有独占接收权，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-971"><see langword="true" /> if this <see cref="T:System.Messaging.MessageQueue" /> has exclusive rights to receive messages from the queue; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="b3203-972">默认值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-972">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-973"><xref:System.Messaging.MessageQueue.DenySharedReceive%2A> 指定由此引用的队列的共享模式 <xref:System.Messaging.MessageQueue> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-973"><xref:System.Messaging.MessageQueue.DenySharedReceive%2A> specifies the shared mode of the queue referenced by this <xref:System.Messaging.MessageQueue>.</span></span> <span data-ttu-id="b3203-974">如果设置为，则 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> `true` 指示只有这样才 <xref:System.Messaging.MessageQueue> 有权从具有指定的队列扫视或接收消息 <xref:System.Messaging.MessageQueue.Path%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-974">Set <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> to `true` to indicate that only this <xref:System.Messaging.MessageQueue> should have access to peek or receive messages from the queue with the specified <xref:System.Messaging.MessageQueue.Path%2A>.</span></span> <span data-ttu-id="b3203-975">如果另一个 <xref:System.Messaging.MessageQueue> 应用程序或另一个应用程序与同一队列资源关联，则该实例或应用程序将无法查看或接收消息，但仍可发送消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-975">If another <xref:System.Messaging.MessageQueue> or another application is associated with the same queue resource, that instance or application will not be able to peek or receive messages, but it can still send them.</span></span>  
  
 <span data-ttu-id="b3203-976">如果 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> 为 `false` ，则队列可用于多个应用程序，用于发送、查看或接收消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-976">If <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> is `false`, the queue is available to multiple applications for sending, peeking, or receiving messages.</span></span>  
  
 <span data-ttu-id="b3203-977">下表显示了此属性在各种工作组模式下是否可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-977">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-978">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-978">Workgroup mode</span></span>|<span data-ttu-id="b3203-979">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-979">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-980">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-980">Local computer</span></span>|<span data-ttu-id="b3203-981">是</span><span class="sxs-lookup"><span data-stu-id="b3203-981">Yes</span></span>|  
|<span data-ttu-id="b3203-982">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-982">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-983">是</span><span class="sxs-lookup"><span data-stu-id="b3203-983">Yes</span></span>|  
|<span data-ttu-id="b3203-984">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-984">Remote computer</span></span>|<span data-ttu-id="b3203-985">是</span><span class="sxs-lookup"><span data-stu-id="b3203-985">Yes</span></span>|  
|<span data-ttu-id="b3203-986">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-986">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-987">是</span><span class="sxs-lookup"><span data-stu-id="b3203-987">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-988">下面的代码示例获取并设置消息队列属性的值 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-988">The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="messageQueue.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="b3203-989">若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-989"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="b3203-990">处置由 <see cref="T:System.Messaging.MessageQueue" /> 占用的资源（内存除外）。</span><span class="sxs-lookup"><span data-stu-id="b3203-990">Disposes of the resources (other than memory) used by the <see cref="T:System.Messaging.MessageQueue" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-991">在完成使用 <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> 后，应调用 <xref:System.Messaging.MessageQueue>。</span><span class="sxs-lookup"><span data-stu-id="b3203-991">Call <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> when you are finished using the <xref:System.Messaging.MessageQueue>.</span></span> <span data-ttu-id="b3203-992"><xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> 方法使 <xref:System.Messaging.MessageQueue> 处于不可用状态。</span><span class="sxs-lookup"><span data-stu-id="b3203-992">The <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> method leaves the <xref:System.Messaging.MessageQueue> in an unusable state.</span></span> <span data-ttu-id="b3203-993">调用后 <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> ，必须释放对的所有引用， <xref:System.Messaging.MessageQueue> 以使其占用的内存可通过垃圾回收进行回收。</span><span class="sxs-lookup"><span data-stu-id="b3203-993">After calling <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>, you must release all references to the <xref:System.Messaging.MessageQueue> so the memory it was occupying can be reclaimed by garbage collection.</span></span>  
  
 <span data-ttu-id="b3203-994">在 <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> 释放对的最后一个引用之前，应调用 <xref:System.Messaging.MessageQueue> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-994">You should call <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> before you release your last reference to the <xref:System.Messaging.MessageQueue>.</span></span> <span data-ttu-id="b3203-995">否则，在垃圾回收 <xref:System.Messaging.MessageQueue> 调用 <xref:System.Messaging.MessageQueue> 对象的析构函数之前，将不会释放正在使用的资源。</span><span class="sxs-lookup"><span data-stu-id="b3203-995">Otherwise, the resources the <xref:System.Messaging.MessageQueue> is using will not be freed until garbage collection calls the <xref:System.Messaging.MessageQueue> object's destructor.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableConnectionCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableConnectionCache { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableConnectionCache : bool with get, set" Usage="System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-996">获取或设置一个值，该值指示应用程序是否维护连接缓存。</span><span class="sxs-lookup"><span data-stu-id="b3203-996">Gets or sets a value that indicates whether a cache of connections will be maintained by the application.</span></span></summary>
        <value><span data-ttu-id="b3203-997">如果创建和使用连接缓存，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-997"><see langword="true" /> to create and use a connection cache; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-998">连接缓存是对包含队列读取或写入句柄的结构的引用的列表。</span><span class="sxs-lookup"><span data-stu-id="b3203-998">A connection cache is a list of references to structures that contain read or write handles to queues.</span></span> <span data-ttu-id="b3203-999">当 <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> 为时 `true` ， <xref:System.Messaging.MessageQueue> 每次调用、或时，都将从缓存中借用， <xref:System.Messaging.MessageQueue.Send%28System.Object%29> <xref:System.Messaging.MessageQueue.Peek%2A> <xref:System.Messaging.MessageQueue.Receive%2A> 而不是打开新句柄。</span><span class="sxs-lookup"><span data-stu-id="b3203-999">When <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> is `true`, the <xref:System.Messaging.MessageQueue> borrows handles from the cache each time you call <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, or <xref:System.Messaging.MessageQueue.Receive%2A>, rather than open new handles.</span></span> <span data-ttu-id="b3203-1000">这可以提高性能。</span><span class="sxs-lookup"><span data-stu-id="b3203-1000">This can improve performance.</span></span> <span data-ttu-id="b3203-1001">使用连接缓存还会 <xref:System.Messaging.MessageQueue> 阻止网络拓扑中的更改。</span><span class="sxs-lookup"><span data-stu-id="b3203-1001">Using a connection cache also insulates the <xref:System.Messaging.MessageQueue> from changes in the network topology.</span></span>  
  
 <span data-ttu-id="b3203-1002">如果在连接缓存已满时创建与队列的新连接，则会 <xref:System.Messaging.MessageQueue> 使用新连接覆盖最近访问最少的结构。</span><span class="sxs-lookup"><span data-stu-id="b3203-1002">If you create a new connection to a queue when the connection cache is full, the <xref:System.Messaging.MessageQueue> overwrites the least recently accessed structure with the new connection.</span></span> <span data-ttu-id="b3203-1003">你可以通过调用来完全清除缓存 <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A> ，例如，如果你所使用的队列的格式名称已更改，使前面的读取和写入句柄不再有效。</span><span class="sxs-lookup"><span data-stu-id="b3203-1003">You can clear the cache entirely by calling <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, for example, if the format names of the queues you are working with have changed so that the previous read and write handles are no longer valid.</span></span>  
  
 <span data-ttu-id="b3203-1004">下表显示了此属性在各种工作组模式下是否可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1004">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1005">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1005">Workgroup mode</span></span>|<span data-ttu-id="b3203-1006">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1006">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1007">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1007">Local computer</span></span>|<span data-ttu-id="b3203-1008">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1008">Yes</span></span>|  
|<span data-ttu-id="b3203-1009">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1009">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1010">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1010">Yes</span></span>|  
|<span data-ttu-id="b3203-1011">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1011">Remote computer</span></span>|<span data-ttu-id="b3203-1012">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1012">Yes</span></span>|  
|<span data-ttu-id="b3203-1013">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1013">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1014">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1014">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1015">下面的代码示例获取并设置消息队列属性的值 <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1015">The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionRequired As EncryptionRequired" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionRequired EncryptionRequired { System::Messaging::EncryptionRequired get(); void set(System::Messaging::EncryptionRequired value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionRequired : System.Messaging.EncryptionRequired with get, set" Usage="System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_EncryptionRequired")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_EncryptionRequired")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-1016">获取或设置一个指示队列是否只接受非私有（非加密）消息的值。</span><span class="sxs-lookup"><span data-stu-id="b3203-1016">Gets or sets a value that indicates whether the queue accepts only non-private (non-encrypted) messages.</span></span></summary>
        <value><span data-ttu-id="b3203-1017"><see cref="T:System.Messaging.EncryptionRequired" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="b3203-1017">One of the <see cref="T:System.Messaging.EncryptionRequired" /> values.</span></span> <span data-ttu-id="b3203-1018">默认值为 <see langword="None" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1018">The default is <see langword="None" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1019">当你指定发送到队列的消息需要加密时，只会加密消息正文。</span><span class="sxs-lookup"><span data-stu-id="b3203-1019">When you specify that encryption is required for the messages sent to a queue, only the message bodies are encrypted.</span></span> <span data-ttu-id="b3203-1020">例如， (的其他成员 <xref:System.Messaging.Message.Label%2A> <xref:System.Messaging.Message.SenderId%2A> 不能加密和属性) 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1020">The other members (for example, the <xref:System.Messaging.Message.Label%2A> and <xref:System.Messaging.Message.SenderId%2A> properties) cannot be encrypted.</span></span>  
  
 <span data-ttu-id="b3203-1021">设置此属性将修改 "消息队列" 队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1021">Setting this property modifies the Message Queuing queue.</span></span> <span data-ttu-id="b3203-1022">因此， <xref:System.Messaging.MessageQueue> 此更改会影响任何其他实例。</span><span class="sxs-lookup"><span data-stu-id="b3203-1022">Therefore, any other <xref:System.Messaging.MessageQueue> instances are affected by the change.</span></span>  
  
 <span data-ttu-id="b3203-1023">加密消息会使消息成为私有消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1023">Encrypting a message makes the message private.</span></span> <span data-ttu-id="b3203-1024">您可以 `None` `Body` `Optional` 通过 <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> 适当地设置属性，将队列的加密要求指定为、或。</span><span class="sxs-lookup"><span data-stu-id="b3203-1024">You can specify the queue's encryption requirement to be `None`, `Body`, or `Optional` by setting the <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> property appropriately.</span></span> <span data-ttu-id="b3203-1025"><xref:System.Messaging.Message.UseEncryption%2A>消息的设置必须与队列的加密要求相对应。</span><span class="sxs-lookup"><span data-stu-id="b3203-1025">The <xref:System.Messaging.Message.UseEncryption%2A> setting of the message must correspond to the encryption requirement of the queue.</span></span> <span data-ttu-id="b3203-1026">如果未对消息进行加密，但队列指定了 `Body` ，或者如果消息已加密但队列指定了该消息 `None` ，则队列将拒绝该消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1026">If the message is not encrypted but the queue specifies `Body`, or if the message is encrypted but the queue specifies `None`, the message is rejected by the queue.</span></span> <span data-ttu-id="b3203-1027">如果发送应用程序在此事件中请求否定确认消息，则消息队列将指示消息对发送应用程序的拒绝。</span><span class="sxs-lookup"><span data-stu-id="b3203-1027">If the sending application requests a negative acknowledgment message in this event, Message Queuing indicates the message's rejection to the sending application.</span></span> <span data-ttu-id="b3203-1028">如果 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 属性为，则会将 `true` 加密失败的消息发送到死信队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1028">If the <xref:System.Messaging.Message.UseDeadLetterQueue%2A> property is `true`, a message that fails encryption is sent to the dead-letter queue.</span></span> <span data-ttu-id="b3203-1029">否则，消息将丢失。</span><span class="sxs-lookup"><span data-stu-id="b3203-1029">Otherwise, the message is lost.</span></span>  
  
 <span data-ttu-id="b3203-1030">下表显示了此属性在各种工作组模式下是否可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1030">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1031">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1031">Workgroup mode</span></span>|<span data-ttu-id="b3203-1032">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1032">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1033">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1033">Local computer</span></span>|<span data-ttu-id="b3203-1034">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1034">Yes</span></span>|  
|<span data-ttu-id="b3203-1035">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1035">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1036">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1036">Yes</span></span>|  
|<span data-ttu-id="b3203-1037">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1037">Remote computer</span></span>|<span data-ttu-id="b3203-1038">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1038">No</span></span>|  
|<span data-ttu-id="b3203-1039">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1039">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1040">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1040">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1041">下面的代码示例获取并设置消息队列属性的值 <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1041">The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-1042">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-1042">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="T:System.Messaging.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndPeek (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndPeek(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndPeek : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndPeek asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="b3203-1043">该 <see cref="T:System.IAsyncResult" /> 标识要完成的异步查看操作，并且从它检索最终结果。</span><span class="sxs-lookup"><span data-stu-id="b3203-1043">The <see cref="T:System.IAsyncResult" /> that identifies the asynchronous peek operation to finish and from which to retrieve an end result.</span></span></param>
        <summary><span data-ttu-id="b3203-1044">完成指定的异步查看操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-1044">Completes the specified asynchronous peek operation.</span></span></summary>
        <returns><span data-ttu-id="b3203-1045">该 <see cref="T:System.Messaging.Message" /> 与已完成的异步操作关联。</span><span class="sxs-lookup"><span data-stu-id="b3203-1045">The <see cref="T:System.Messaging.Message" /> associated with the completed asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1046"><xref:System.Messaging.MessageQueue.PeekCompleted>引发事件时，将 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 完成通过调用启动的操作 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1046">When the <xref:System.Messaging.MessageQueue.PeekCompleted> event is raised, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> completes the operation that was initiated by the <xref:System.Messaging.MessageQueue.BeginPeek%2A> call.</span></span> <span data-ttu-id="b3203-1047">为此，请 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 查看消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1047">To do so, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> peeks the message.</span></span>  
  
 <span data-ttu-id="b3203-1048"><xref:System.Messaging.MessageQueue.BeginPeek%2A> 可以指定超时，这会导致在 <xref:System.Messaging.MessageQueue.PeekCompleted> 消息在队列中出现之前发生超时的情况下引发事件。</span><span class="sxs-lookup"><span data-stu-id="b3203-1048"><xref:System.Messaging.MessageQueue.BeginPeek%2A> can specify a time-out, which causes the <xref:System.Messaging.MessageQueue.PeekCompleted> event to be raised if the time-out occurs before a message appears in the queue.</span></span> <span data-ttu-id="b3203-1049">如果在没有消息到达队列的情况下出现超时，则对的后续调用将 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-1049">When a time-out occurs without a message arriving in the queue, a subsequent call to <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> throws an exception.</span></span>  
  
 <span data-ttu-id="b3203-1050"><xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 用于读取导致 <xref:System.Messaging.MessageQueue.PeekCompleted> 引发事件的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1050"><xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> is used to read the message that caused the <xref:System.Messaging.MessageQueue.PeekCompleted> event to be raised.</span></span>  
  
 <span data-ttu-id="b3203-1051">如果要继续异步查看消息，则可以 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 在调用后再次调用 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1051">If you want to continue to asynchronously peek messages, you can again call <xref:System.Messaging.MessageQueue.BeginPeek%2A> after calling <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.</span></span>  
  
 <span data-ttu-id="b3203-1052">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1052">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1053">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1053">Workgroup mode</span></span>|<span data-ttu-id="b3203-1054">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1054">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1055">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1055">Local computer</span></span>|<span data-ttu-id="b3203-1056">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1056">Yes</span></span>|  
|<span data-ttu-id="b3203-1057">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1057">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1058">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1058">Yes</span></span>|  
|<span data-ttu-id="b3203-1059">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1059">Remote computer</span></span>|<span data-ttu-id="b3203-1060">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1060">No</span></span>|  
|<span data-ttu-id="b3203-1061">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1061">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1062">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1062">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1063">下面的代码示例创建一个名为的事件处理程序 `MyPeekCompleted` ，将其附加到 <xref:System.Messaging.MessageQueue.PeekCompleted> 事件处理程序委托，并调用 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 以对位于路径 ".\myQueue" 的队列启动异步查看操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-1063">The following code example creates an event handler named `MyPeekCompleted`, attaches it to the <xref:System.Messaging.MessageQueue.PeekCompleted> event handler delegate, and calls <xref:System.Messaging.MessageQueue.BeginPeek%2A> to initiate an asynchronous peek operation on the queue that is located at the path ".\myQueue".</span></span> <span data-ttu-id="b3203-1064"><xref:System.Messaging.MessageQueue.PeekCompleted>引发事件时，该示例将扫视消息，并将其正文写入屏幕。</span><span class="sxs-lookup"><span data-stu-id="b3203-1064">When a <xref:System.Messaging.MessageQueue.PeekCompleted> event is raised, the example peeks the message and writes its body to the screen.</span></span> <span data-ttu-id="b3203-1065">然后，该示例 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 再次调用以启动新的异步查看操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-1065">The example then calls <xref:System.Messaging.MessageQueue.BeginPeek%2A> again to initiate a new asynchronous peek operation.</span></span>  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3203-1066"><paramref name="asyncResult" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1066">The <paramref name="asyncResult" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-1067">该 <paramref name="asyncResult" /> 参数的语法无效。</span><span class="sxs-lookup"><span data-stu-id="b3203-1067">The syntax of the <paramref name="asyncResult" /> parameter is not valid.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-1068">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-1068">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndReceive(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndReceive asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="b3203-1069">该 <see cref="T:System.IAsyncResult" /> 标识要完成的异步接收操作，并且从它检索最终结果。</span><span class="sxs-lookup"><span data-stu-id="b3203-1069">The <see cref="T:System.IAsyncResult" /> that identifies the asynchronous receive operation to finish and from which to retrieve an end result.</span></span></param>
        <summary><span data-ttu-id="b3203-1070">完成指定的异步接收操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-1070">Completes the specified asynchronous receive operation.</span></span></summary>
        <returns><span data-ttu-id="b3203-1071">该 <see cref="T:System.Messaging.Message" /> 与已完成的异步操作关联。</span><span class="sxs-lookup"><span data-stu-id="b3203-1071">The <see cref="T:System.Messaging.Message" /> associated with the completed asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1072"><xref:System.Messaging.MessageQueue.ReceiveCompleted>引发事件时，将 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 完成通过调用启动的操作 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1072">When the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event is raised, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> completes the operation that was initiated by the <xref:System.Messaging.MessageQueue.BeginReceive%2A> call.</span></span> <span data-ttu-id="b3203-1073">为此，会 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 接收消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1073">To do so, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> receives the message.</span></span>  
  
 <span data-ttu-id="b3203-1074"><xref:System.Messaging.MessageQueue.BeginReceive%2A> 可以指定超时，这会导致在 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 消息在队列中出现之前发生超时的情况下引发事件。</span><span class="sxs-lookup"><span data-stu-id="b3203-1074"><xref:System.Messaging.MessageQueue.BeginReceive%2A> can specify a time-out, which causes the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event to be raised if the time-out occurs before a message appears in the queue.</span></span> <span data-ttu-id="b3203-1075">如果在没有消息到达队列的情况下出现超时，则对的后续调用将 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-1075">When a time-out occurs without a message arriving in the queue, a subsequent call to <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> throws an exception.</span></span>  
  
 <span data-ttu-id="b3203-1076"><xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 用于读取 (从队列中移除) 导致 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 引发事件的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1076"><xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> is used to read (removing from the queue) the message that caused the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event to be raised.</span></span>  
  
 <span data-ttu-id="b3203-1077">如果要继续异步接收消息，可以在 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 调用后再次调用 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1077">If you want to continue to asynchronously receive messages, you can again call <xref:System.Messaging.MessageQueue.BeginReceive%2A> after calling <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.</span></span>  
  
 <span data-ttu-id="b3203-1078">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1078">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1079">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1079">Workgroup mode</span></span>|<span data-ttu-id="b3203-1080">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1080">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1081">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1081">Local computer</span></span>|<span data-ttu-id="b3203-1082">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1082">Yes</span></span>|  
|<span data-ttu-id="b3203-1083">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1083">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1084">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1084">Yes</span></span>|  
|<span data-ttu-id="b3203-1085">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1085">Remote computer</span></span>|<span data-ttu-id="b3203-1086">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1086">No</span></span>|  
|<span data-ttu-id="b3203-1087">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1087">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1088">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1088">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1089">下面的代码示例将异步请求链接在一起。</span><span class="sxs-lookup"><span data-stu-id="b3203-1089">The following code example chains asynchronous requests.</span></span> <span data-ttu-id="b3203-1090">它假设本地计算机上有一个名为 "myQueue" 的队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1090">It assumes there is a queue on the local computer called "myQueue".</span></span> <span data-ttu-id="b3203-1091">`Main`函数开始由例程处理的异步操作 `MyReceiveCompleted` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1091">The `Main` function begins the asynchronous operation that is handled by the `MyReceiveCompleted` routine.</span></span> <span data-ttu-id="b3203-1092">`MyReceiveCompleted` 处理当前消息并开始新的异步接收操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-1092">`MyReceiveCompleted` processes the current message and begins a new asynchronous receive operation.</span></span>  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3203-1093"><paramref name="asyncResult" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1093">The <paramref name="asyncResult" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-1094">该 <paramref name="asyncResult" /> 参数的语法无效。</span><span class="sxs-lookup"><span data-stu-id="b3203-1094">The syntax of the <paramref name="asyncResult" /> parameter is not valid.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-1095">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-1095">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Messaging.MessageQueue.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b3203-1096">要查找的队列的位置。</span><span class="sxs-lookup"><span data-stu-id="b3203-1096">The location of the queue to find.</span></span></param>
        <summary><span data-ttu-id="b3203-1097">确定指定的路径中是否存在“消息队列”队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1097">Determines whether a Message Queuing queue exists at the specified path.</span></span></summary>
        <returns><span data-ttu-id="b3203-1098">如果指定的路径中存在队列，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1098"><see langword="true" /> if a queue with the specified path exists; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1099"><xref:System.Messaging.MessageQueue.Exists%28System.String%29>方法确定消息队列队列是否存在于指定的路径。</span><span class="sxs-lookup"><span data-stu-id="b3203-1099">The <xref:System.Messaging.MessageQueue.Exists%28System.String%29> method determines whether a Message Queuing queue exists at a specified path.</span></span> <span data-ttu-id="b3203-1100">不存在任何方法来确定具有指定格式名的队列是否存在。</span><span class="sxs-lookup"><span data-stu-id="b3203-1100">No method exists to determine whether a queue with a specified format name exists.</span></span> <span data-ttu-id="b3203-1101">有关格式名称语法和其他路径语法形式的详细信息，请参阅 <xref:System.Messaging.MessageQueue.Path%2A> 属性。 ) </span><span class="sxs-lookup"><span data-stu-id="b3203-1101">For more information about the format name syntax and other path syntax forms, see the <xref:System.Messaging.MessageQueue.Path%2A> property.)</span></span>  
  
 <span data-ttu-id="b3203-1102"><xref:System.Messaging.MessageQueue.Exists%28System.String%29> 是代价高昂的操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-1102"><xref:System.Messaging.MessageQueue.Exists%28System.String%29> is an expensive operation.</span></span> <span data-ttu-id="b3203-1103">仅当在应用程序中有必要时才使用它。</span><span class="sxs-lookup"><span data-stu-id="b3203-1103">Use it only when it is necessary within the application.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b3203-1104">此 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> 方法不支持 <xref:System.Messaging.MessageQueue.FormatName%2A> 前缀。</span><span class="sxs-lookup"><span data-stu-id="b3203-1104">The <xref:System.Messaging.MessageQueue.Exists%28System.String%29> method does not support the <xref:System.Messaging.MessageQueue.FormatName%2A> prefix.</span></span>  
  
 <span data-ttu-id="b3203-1105">参数的语法 `path` 取决于队列的类型，如下表所示。</span><span class="sxs-lookup"><span data-stu-id="b3203-1105">The syntax for the `path` parameter depends on the type of queue, as shown in the following table.</span></span>  
  
|<span data-ttu-id="b3203-1106">队列类型</span><span class="sxs-lookup"><span data-stu-id="b3203-1106">Queue type</span></span>|<span data-ttu-id="b3203-1107">语法</span><span class="sxs-lookup"><span data-stu-id="b3203-1107">Syntax</span></span>|  
|----------------|------------|  
|<span data-ttu-id="b3203-1108">公用队列</span><span class="sxs-lookup"><span data-stu-id="b3203-1108">Public queue</span></span>|`MachineName`\\`QueueName`|  
  
 <span data-ttu-id="b3203-1109"><xref:System.Messaging.MessageQueue.Exists%28System.String%29> 无法调用来验证远程专用队列是否存在。</span><span class="sxs-lookup"><span data-stu-id="b3203-1109"><xref:System.Messaging.MessageQueue.Exists%28System.String%29> cannot be called to verify the existence of a remote private queue.</span></span>  
  
 <span data-ttu-id="b3203-1110">有关更多语法，请参见 <xref:System.Messaging.MessageQueue.Path%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="b3203-1110">For more syntax, see the <xref:System.Messaging.MessageQueue.Path%2A> property.</span></span>  
  
 <span data-ttu-id="b3203-1111">或者，您可以使用 <xref:System.Messaging.MessageQueue.Label%2A> 来描述队列路径。</span><span class="sxs-lookup"><span data-stu-id="b3203-1111">Alternatively, you can use the <xref:System.Messaging.MessageQueue.Label%2A> to describe the queue path.</span></span>  
  
|<span data-ttu-id="b3203-1112">参考</span><span class="sxs-lookup"><span data-stu-id="b3203-1112">Reference</span></span>|<span data-ttu-id="b3203-1113">语法</span><span class="sxs-lookup"><span data-stu-id="b3203-1113">Syntax</span></span>|  
|---------------|------------|  
|<span data-ttu-id="b3203-1114">Label</span><span class="sxs-lookup"><span data-stu-id="b3203-1114">Label</span></span>|<span data-ttu-id="b3203-1115">标签： [ `label` ]</span><span class="sxs-lookup"><span data-stu-id="b3203-1115">Label:[ `label` ]</span></span>|  
  
 <span data-ttu-id="b3203-1116">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1116">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1117">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1117">Workgroup mode</span></span>|<span data-ttu-id="b3203-1118">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1118">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1119">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1119">Local computer</span></span>|<span data-ttu-id="b3203-1120">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1120">Yes</span></span>|  
|<span data-ttu-id="b3203-1121">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1121">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1122">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1122">No</span></span>|  
|<span data-ttu-id="b3203-1123">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1123">Remote computer</span></span>|<span data-ttu-id="b3203-1124">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1124">No</span></span>|  
|<span data-ttu-id="b3203-1125">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1125">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1126">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1126">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1127">下面的代码示例验证 "消息队列" 队列是否存在，然后将其删除。</span><span class="sxs-lookup"><span data-stu-id="b3203-1127">The following code example verifies whether a Message Queuing queue exists, and then deletes it.</span></span>  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-1128">该 <paramref name="path" /> 语法无效。</span><span class="sxs-lookup"><span data-stu-id="b3203-1128">The <paramref name="path" /> syntax is not valid.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-1129">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-1129">An error occurred when accessing a Message Queuing method.</span></span>  
  
<span data-ttu-id="b3203-1130">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-1130">-or-</span></span> 
<span data-ttu-id="b3203-1131"><see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /> 方法正被远程专用队列调用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1131">The <see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /> method is being called on a remote private queue</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b3203-1132">应用程序在验证队列是否存在时使用的格式名语法。</span><span class="sxs-lookup"><span data-stu-id="b3203-1132">The application used format name syntax when verifying queue existence.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FormatName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FormatName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FormatName : string" Usage="System.Messaging.MessageQueue.FormatName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_FormatName")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_FormatName")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-1133">获取“消息队列”在创建队列时生成的唯一队列名。</span><span class="sxs-lookup"><span data-stu-id="b3203-1133">Gets the unique queue name that Message Queuing generated at the time of the queue's creation.</span></span></summary>
        <value><span data-ttu-id="b3203-1134">队列的名称，该名称在网络上是唯一的。</span><span class="sxs-lookup"><span data-stu-id="b3203-1134">The name for the queue, which is unique on the network.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1135"><xref:System.Messaging.MessageQueue.FormatName%2A>属性包含队列的格式名。</span><span class="sxs-lookup"><span data-stu-id="b3203-1135">The <xref:System.Messaging.MessageQueue.FormatName%2A> property contains the format name of the queue.</span></span> <span data-ttu-id="b3203-1136">消息队列使用格式名来标识要打开的队列以及如何访问它。</span><span class="sxs-lookup"><span data-stu-id="b3203-1136">Message Queuing uses the format name to identify which queue to open and how to access it.</span></span> <span data-ttu-id="b3203-1137">与队列的大多数特征不同，格式名不是 "消息队列应用程序队列" 属性，因此无法通过 "消息队列" 管理工具进行访问。</span><span class="sxs-lookup"><span data-stu-id="b3203-1137">Unlike most of a queue's characteristics, the format name is not a Message Queuing application queue property, so you cannot access it through the Message Queuing management tool.</span></span> <span data-ttu-id="b3203-1138">格式名称只是队列的唯一名称，消息队列在创建队列时生成，或者应用程序稍后生成。</span><span class="sxs-lookup"><span data-stu-id="b3203-1138">The format name is simply a unique name for the queue, which Message Queuing generates when it creates the queue or which the application generates later.</span></span>  
  
 <span data-ttu-id="b3203-1139">如果使用路径名语法指定路径 (例如 `myComputer\myQueue`) ，而不是在读取或写入队列时使用格式名语法，则使用) Active Directory 的主域控制器 (将在 <xref:System.Messaging.MessageQueue.Path%2A> 访问队列之前将转换为关联的 <xref:System.Messaging.MessageQueue.FormatName%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1139">If you specify a path using the path name syntax (such as `myComputer\myQueue`) rather than using the format name syntax when you read or write to the queue, the primary domain controller (which uses Active Directory) translates the <xref:System.Messaging.MessageQueue.Path%2A> into the associated <xref:System.Messaging.MessageQueue.FormatName%2A> before accessing the queue.</span></span> <span data-ttu-id="b3203-1140">如果你的应用程序脱机工作，则必须使用 format name 语法;否则，主域控制器将不可用于执行路径转换。</span><span class="sxs-lookup"><span data-stu-id="b3203-1140">If your application is working offline, you must use the format name syntax; otherwise, the primary domain controller will not be available to perform the path translation.</span></span>  
  
 <span data-ttu-id="b3203-1141">下表显示了此属性在各种工作组模式下是否可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1141">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1142">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1142">Workgroup mode</span></span>|<span data-ttu-id="b3203-1143">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1143">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1144">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1144">Local computer</span></span>|<span data-ttu-id="b3203-1145">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1145">Yes</span></span>|  
|<span data-ttu-id="b3203-1146">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1146">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1147">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1147">Yes</span></span>|  
|<span data-ttu-id="b3203-1148">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1148">Remote computer</span></span>|<span data-ttu-id="b3203-1149">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1149">Yes</span></span>|  
|<span data-ttu-id="b3203-1150">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1150">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1151">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1151">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1152">下面的代码示例显示消息队列属性的值 <xref:System.Messaging.MessageQueue.FormatName%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1152">The following code example displays the value of a message queue's <xref:System.Messaging.MessageQueue.FormatName%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-1153">未设置 <see cref="P:System.Messaging.MessageQueue.Path" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1153">The <see cref="P:System.Messaging.MessageQueue.Path" /> is not set.</span></span>  
  
<span data-ttu-id="b3203-1154">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-1154">-or-</span></span> 
<span data-ttu-id="b3203-1155">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-1155">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="T:System.Messaging.MessageQueue" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.MessageQueue.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(null)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(null)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_Formatter")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_Formatter")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-1156">获取或设置格式化程序，该格式化程序用于将对象序列化为从队列读取或写入队列的消息体，或者用于将从队列读取或写入队列的消息体反序列化为对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-1156">Gets or sets the formatter used to serialize an object into or deserialize an object from the body of a message read from or written to the queue.</span></span></summary>
        <value><span data-ttu-id="b3203-1157">该 <see cref="T:System.Messaging.IMessageFormatter" /> 产生要写入消息体或要从消息体中读取的流。</span><span class="sxs-lookup"><span data-stu-id="b3203-1157">The <see cref="T:System.Messaging.IMessageFormatter" /> that produces a stream to be written to or read from the message body.</span></span> <span data-ttu-id="b3203-1158">默认值为 <see cref="T:System.Messaging.XmlMessageFormatter" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1158">The default is <see cref="T:System.Messaging.XmlMessageFormatter" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1159"><xref:System.Messaging.MessageQueue.Formatter%2A>属性包含格式化程序对象的实例，该实例在应用程序读取或写入队列时转换消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1159">The <xref:System.Messaging.MessageQueue.Formatter%2A> property contains an instance of a formatter object, which transforms messages when your application reads or writes to the queue.</span></span>  
  
 <span data-ttu-id="b3203-1160">当应用程序将消息发送到队列时，格式化程序将对象序列化为流，并将其插入消息正文。</span><span class="sxs-lookup"><span data-stu-id="b3203-1160">When the application sends message to the queue, the formatter serializes the object into a stream and inserts it into the message body.</span></span> <span data-ttu-id="b3203-1161">从队列中读取时，格式化程序将消息数据反序列化到的 <xref:System.Messaging.Message.Body%2A> 属性中 <xref:System.Messaging.Message> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1161">When reading from a queue, the formatter deserializes the message data into the <xref:System.Messaging.Message.Body%2A> property of a <xref:System.Messaging.Message>.</span></span>  
  
 <span data-ttu-id="b3203-1162"><xref:System.Messaging.XmlMessageFormatter>是松散耦合的，因此在使用此格式时，不需要在发送方和接收方上具有相同的对象类型。</span><span class="sxs-lookup"><span data-stu-id="b3203-1162">The <xref:System.Messaging.XmlMessageFormatter> is loosely coupled, so it is not necessary to have the same object type on the sender and receiver when using this format.</span></span> <span data-ttu-id="b3203-1163">将 <xref:System.Messaging.ActiveXMessageFormatter> <xref:System.Messaging.BinaryMessageFormatter> 数据序列化为二进制表示形式。</span><span class="sxs-lookup"><span data-stu-id="b3203-1163">The <xref:System.Messaging.ActiveXMessageFormatter> and <xref:System.Messaging.BinaryMessageFormatter> serialize the data into binary representation.</span></span> <span data-ttu-id="b3203-1164">在 <xref:System.Messaging.ActiveXMessageFormatter> 发送或接收 COM 组件时使用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1164">The <xref:System.Messaging.ActiveXMessageFormatter> is used when sending or receiving COM components.</span></span>  
  
 <span data-ttu-id="b3203-1165"><xref:System.Messaging.BinaryMessageFormatter> 与 <xref:System.Messaging.ActiveXMessageFormatter> 相比，提供更快的吞吐量 <xref:System.Messaging.XmlMessageFormatter> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1165"><xref:System.Messaging.BinaryMessageFormatter> and <xref:System.Messaging.ActiveXMessageFormatter> provide faster throughput than the <xref:System.Messaging.XmlMessageFormatter>.</span></span> <span data-ttu-id="b3203-1166"><xref:System.Messaging.ActiveXMessageFormatter>允许与 Visual Basic 6.0 消息队列应用程序的互操作性。</span><span class="sxs-lookup"><span data-stu-id="b3203-1166">The <xref:System.Messaging.ActiveXMessageFormatter> allows interoperability with Visual Basic 6.0 Message Queuing applications.</span></span>  
  
 <span data-ttu-id="b3203-1167">当应用程序将消息发送到队列时， <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 仅适用于那些使用默认消息属性的消息 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1167">When your application sends messages to the queue, the <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> applies only to those messages that use the default message properties, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>.</span></span> <span data-ttu-id="b3203-1168">如果将发送 <xref:System.Messaging.Message> 到队列，则消息队列将使用属性中定义的格式化程序 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 来序列化正文。</span><span class="sxs-lookup"><span data-stu-id="b3203-1168">If you send a <xref:System.Messaging.Message> to the queue, Message Queuing uses the formatter defined in the <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> property to serialize the body instead.</span></span>  
  
 <span data-ttu-id="b3203-1169"><xref:System.Messaging.MessageQueue>类将始终使用 <xref:System.Messaging.Message> 来接收或查看队列中的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1169">The <xref:System.Messaging.MessageQueue> class will always use a <xref:System.Messaging.Message> to receive or peek a message from the queue.</span></span> <span data-ttu-id="b3203-1170">使用属性对消息进行反序列化 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1170">The message is deserialized using the <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="b3203-1171">下表显示了此属性在各种工作组模式下是否可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1171">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1172">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1172">Workgroup mode</span></span>|<span data-ttu-id="b3203-1173">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1173">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1174">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1174">Local computer</span></span>|<span data-ttu-id="b3203-1175">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1175">Yes</span></span>|  
|<span data-ttu-id="b3203-1176">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1176">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1177">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1177">Yes</span></span>|  
|<span data-ttu-id="b3203-1178">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1178">Remote computer</span></span>|<span data-ttu-id="b3203-1179">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1179">No</span></span>|  
|<span data-ttu-id="b3203-1180">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1180">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1181">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1181">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1182">下面的代码示例演示如何使用格式化消息正文 <xref:System.Messaging.BinaryMessageFormatter> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1182">The following code example demonstrates formatting a message body using <xref:System.Messaging.BinaryMessageFormatter>.</span></span>  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 <span data-ttu-id="b3203-1183">下面的代码示例演示如何使用格式化消息正文 <xref:System.Messaging.XmlMessageFormatter> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1183">The following code example demonstrates formatting a message body using <xref:System.Messaging.XmlMessageFormatter>.</span></span>  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMessages () As Message()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Messaging::Message ^&gt; ^ GetAllMessages();" />
      <MemberSignature Language="F#" Value="member this.GetAllMessages : unit -&gt; System.Messaging.Message[]" Usage="messageQueue.GetAllMessages " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b3203-1184">返回位于队列中的所有消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1184">Returns all the messages that are in the queue.</span></span></summary>
        <returns><span data-ttu-id="b3203-1185">类型 <see cref="T:System.Messaging.Message" /> 的数组，表示队列中所有消息，其顺序与这些消息在“消息队列”队列中的出现顺序相同。</span><span class="sxs-lookup"><span data-stu-id="b3203-1185">An array of type <see cref="T:System.Messaging.Message" /> that represents all the messages in the queue, in the same order as they appear in the Message Queuing queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1186"><xref:System.Messaging.MessageQueue.GetAllMessages%2A> 返回队列中消息的静态快照，而不是指向这些消息的动态链接。</span><span class="sxs-lookup"><span data-stu-id="b3203-1186"><xref:System.Messaging.MessageQueue.GetAllMessages%2A> returns a static snapshot of the messages in the queue, not dynamic links to those messages.</span></span> <span data-ttu-id="b3203-1187">因此，不能使用数组来修改队列中的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1187">Therefore, you cannot use the array to modify the messages in the queue.</span></span> <span data-ttu-id="b3203-1188">如果要与队列进行实时、动态的交互 (例如) 删除消息的能力），请调用 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> 方法，这将返回队列中消息的动态列表。</span><span class="sxs-lookup"><span data-stu-id="b3203-1188">If you want real-time, dynamic interaction with the queue (such as the ability to delete messages), call the <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> method, which returns a dynamic list of the messages in the queue.</span></span>  
  
 <span data-ttu-id="b3203-1189">由于 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> 在调用方法时返回队列中的消息的副本，因此数组不反映到达队列中的新消息或从队列中移除的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1189">Because <xref:System.Messaging.MessageQueue.GetAllMessages%2A> returns a copy of the messages in the queue at the time the method was called, the array does not reflect new messages that arrive in the queue or messages that are removed from the queue.</span></span>  
  
 <span data-ttu-id="b3203-1190"><xref:System.Messaging.MessageQueue.GetAllMessages%2A> 仅检索未按属性筛选掉的那些属性 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1190"><xref:System.Messaging.MessageQueue.GetAllMessages%2A> retrieves only those properties not filtered out by the <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> property.</span></span>  
  
 <span data-ttu-id="b3203-1191">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1191">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1192">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1192">Workgroup mode</span></span>|<span data-ttu-id="b3203-1193">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1193">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1194">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1194">Local computer</span></span>|<span data-ttu-id="b3203-1195">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1195">Yes</span></span>|  
|<span data-ttu-id="b3203-1196">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1196">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1197">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1197">Yes</span></span>|  
|<span data-ttu-id="b3203-1198">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1198">Remote computer</span></span>|<span data-ttu-id="b3203-1199">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1199">No</span></span>|  
|<span data-ttu-id="b3203-1200">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1200">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1201">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1201">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1202">以下代码示例演示了 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> 的用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-1202">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.GetAllMessages%2A>.</span></span>  
  
 [!code-cpp[MessageQueue2#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-1203">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-1203">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="messageQueue.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName Language="C#">[System.Obsolete]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b3203-1204">枚举队列中的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1204">Enumerates the messages in a queue.</span></span> <span data-ttu-id="b3203-1205"><see cref="M:System.Messaging.MessageQueue.GetEnumerator" /> 已弃用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1205"><see cref="M:System.Messaging.MessageQueue.GetEnumerator" /> is deprecated.</span></span> <span data-ttu-id="b3203-1206">应改用 <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1206"><see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> should be used instead.</span></span></summary>
        <returns><span data-ttu-id="b3203-1207"><see cref="T:System.Collections.IEnumerator" />，它提供与队列消息的动态连接。</span><span class="sxs-lookup"><span data-stu-id="b3203-1207">A <see cref="T:System.Collections.IEnumerator" /> that provides a dynamic connection to the messages in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1208">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1208">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1209">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1209">Workgroup mode</span></span>|<span data-ttu-id="b3203-1210">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1210">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1211">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1211">Local computer</span></span>|<span data-ttu-id="b3203-1212">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1212">Yes</span></span>|  
|<span data-ttu-id="b3203-1213">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1213">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1214">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1214">Yes</span></span>|  
|<span data-ttu-id="b3203-1215">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1215">Remote computer</span></span>|<span data-ttu-id="b3203-1216">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1216">No</span></span>|  
|<span data-ttu-id="b3203-1217">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1217">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1218">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1218">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1219">以下代码示例演示了 <xref:System.Messaging.MessageQueue.GetEnumerator%2A> 的用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-1219">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.GetEnumerator%2A>.</span></span>  
  
 [!code-cpp[MessageQueue2#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineId (machineName As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetMachineId(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetMachineId : string -&gt; Guid" Usage="System.Messaging.MessageQueue.GetMachineId machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName"><span data-ttu-id="b3203-1220">包含队列的计算机的名称，名称前不含两个反斜杠 (\\\\)。</span><span class="sxs-lookup"><span data-stu-id="b3203-1220">The name of the computer that contains the queue, without the two preceding backslashes (\\\\).</span></span></param>
        <summary><span data-ttu-id="b3203-1221">获取计算机的标识符，此 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列位于该计算机上。</span><span class="sxs-lookup"><span data-stu-id="b3203-1221">Gets the identifier of the computer on which the queue referenced by this <see cref="T:System.Messaging.MessageQueue" /> is located.</span></span></summary>
        <returns><span data-ttu-id="b3203-1222"><see cref="T:System.Guid" />，表示队列所在的计算机的唯一标识符。</span><span class="sxs-lookup"><span data-stu-id="b3203-1222">A <see cref="T:System.Guid" /> that represents a unique identifier for the computer on which the queue is located.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1223">您可以使用计算机的标识符来实现两个目的：读取计算机日志并设置安全证书。</span><span class="sxs-lookup"><span data-stu-id="b3203-1223">You can use a computer's identifier for two purposes, among others: to read the computer journal and to set security certificates.</span></span> <span data-ttu-id="b3203-1224">但是， <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> 当脱机工作时，无法为远程计算机调用，因为该应用程序必须有权访问域控制器上的目录服务。</span><span class="sxs-lookup"><span data-stu-id="b3203-1224">However, you cannot call <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> for a remote computer when you are working offline because the application must have access to the directory service on the domain controller.</span></span>  
  
 <span data-ttu-id="b3203-1225">计算机标识符 (或计算机标识符) 是在将 <xref:System.Guid> 计算机添加到企业时消息队列创建的。</span><span class="sxs-lookup"><span data-stu-id="b3203-1225">The computer identifier (or machine identifier) is a <xref:System.Guid> that Message Queuing creates when a computer is added to the enterprise.</span></span> <span data-ttu-id="b3203-1226">消息队列将计算机标识符与 `Machine` 和关键字结合起来 `Journal` ，以创建计算机日志的格式名，该名称具有语法 `Machine=<computeridentifier>;Journal` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1226">Message Queuing combines the computer identifier with the `Machine` and `Journal` keywords to create the machine journal's format name, which has the syntax `Machine=<computeridentifier>;Journal`.</span></span> <span data-ttu-id="b3203-1227">计算机日志（也称为日志队列）是在属性为时存储应用程序生成的消息的副本的系统队列 <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> `true` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1227">The machine journal, which is also known as the journal queue, is a system queue that stores copies of application-generated messages when the <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> property is `true`.</span></span>  
  
 <span data-ttu-id="b3203-1228">此日志语法仅在构造队列的格式名时有效。</span><span class="sxs-lookup"><span data-stu-id="b3203-1228">This syntax for the journal is only valid when constructing the format name for the queue.</span></span> <span data-ttu-id="b3203-1229">路径名称语法为 `MachineName` \\ `Journal$` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1229">The path name syntax is `MachineName`\\`Journal$`.</span></span>  
  
 <span data-ttu-id="b3203-1230">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1230">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1231">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1231">Workgroup mode</span></span>|<span data-ttu-id="b3203-1232">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1232">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1233">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1233">Local computer</span></span>|<span data-ttu-id="b3203-1234">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1234">No</span></span>|  
|<span data-ttu-id="b3203-1235">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1235">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1236">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1236">No</span></span>|  
|<span data-ttu-id="b3203-1237">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1237">Remote computer</span></span>|<span data-ttu-id="b3203-1238">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1238">No</span></span>|  
|<span data-ttu-id="b3203-1239">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1239">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1240">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1240">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1241">下面的代码示例调用 <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29>。</span><span class="sxs-lookup"><span data-stu-id="b3203-1241">The following code example calls <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29>.</span></span>  
  
 [!code-csharp[MessageQueue#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-1242">未能检索到计算机标识符，可能是因为目录服务不可用，例如当正在脱机工作时。</span><span class="sxs-lookup"><span data-stu-id="b3203-1242">The computer identifier could not be retrieved, possibly because the directory service is not available; for example, if you are working offline.</span></span>  
  
 <span data-ttu-id="b3203-1243">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-1243">-or-</span></span>  
  
 <span data-ttu-id="b3203-1244">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-1244">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName Language="C#">[System.Obsolete]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b3203-1245">为队列中的所有消息创建枚举数对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-1245">Creates an enumerator object for all the messages in the queue.</span></span> <span data-ttu-id="b3203-1246"><see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /> 已弃用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1246"><see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /> is deprecated.</span></span> <span data-ttu-id="b3203-1247">应改用 <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1247"><see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> should be used instead.</span></span></summary>
        <returns><span data-ttu-id="b3203-1248">该 <see cref="T:System.Messaging.MessageEnumerator" /> 包括队列中所包含的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1248">The <see cref="T:System.Messaging.MessageEnumerator" /> holding the messages that are contained in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1249"><xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> 创建队列中所有消息的动态列表。</span><span class="sxs-lookup"><span data-stu-id="b3203-1249"><xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> creates a dynamic list of all the messages in a queue.</span></span> <span data-ttu-id="b3203-1250">你可以通过调用返回的来从队列中删除消息，该消息位于枚举数的当前位置 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> <xref:System.Messaging.MessageEnumerator> <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1250">You can remove from the queue the message at the enumerator's current position by calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> for the <xref:System.Messaging.MessageEnumerator> that <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> returns.</span></span>  
  
 <span data-ttu-id="b3203-1251">由于游标与队列中的消息动态列表相关联，因此，如果消息在当前游标位置之外，则枚举将反映对队列中的消息所做的任何修改。</span><span class="sxs-lookup"><span data-stu-id="b3203-1251">Because the cursor is associated with the dynamic list of messages in the queue, the enumeration reflects any modification you make to the messages in the queue, if the message is beyond the current cursor position.</span></span> <span data-ttu-id="b3203-1252">例如，枚举器可以自动访问放置在游标当前位置之外的低优先级的消息，但不能访问在该位置之前插入的优先级较高的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1252">For example, the enumerator can automatically access a lower-priority message placed beyond the cursor's current position, but not a higher-priority message inserted before that position.</span></span> <span data-ttu-id="b3203-1253">但是，你可以通过调用来重置枚举，从而将游标移回列表的开头 <xref:System.Messaging.MessageEnumerator.Reset%2A> <xref:System.Messaging.MessageEnumerator> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1253">However, you can reset the enumeration, thereby moving the cursor back to the beginning of the list, by calling <xref:System.Messaging.MessageEnumerator.Reset%2A> for the <xref:System.Messaging.MessageEnumerator>.</span></span>  
  
 <span data-ttu-id="b3203-1254">枚举中的消息顺序反映了它们在队列中的顺序，因此优先级较高的消息会出现在优先级较低的消息之前。</span><span class="sxs-lookup"><span data-stu-id="b3203-1254">The order of the messages in the enumeration reflects their order in the queue, so higher-priority messages will appear before lower-priority ones.</span></span>  
  
 <span data-ttu-id="b3203-1255">如果希望队列中消息的静态快照而不是动态连接到它们，请调用 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1255">If you want a static snapshot of the messages in the queue rather than a dynamic connection to them, call <xref:System.Messaging.MessageQueue.GetAllMessages%2A>.</span></span> <span data-ttu-id="b3203-1256">此方法返回对象的数组 <xref:System.Messaging.Message> ，这些对象表示调用方法时的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1256">This method returns an array of <xref:System.Messaging.Message> objects, which represent the messages at the time the method was called.</span></span>  
  
 <span data-ttu-id="b3203-1257">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1257">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1258">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1258">Workgroup mode</span></span>|<span data-ttu-id="b3203-1259">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1259">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1260">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1260">Local computer</span></span>|<span data-ttu-id="b3203-1261">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1261">Yes</span></span>|  
|<span data-ttu-id="b3203-1262">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1262">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1263">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1263">Yes</span></span>|  
|<span data-ttu-id="b3203-1264">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1264">Remote computer</span></span>|<span data-ttu-id="b3203-1265">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1265">Yes</span></span>|  
|<span data-ttu-id="b3203-1266">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1266">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1267">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1267">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1268">下面的代码示例获取队列中消息的动态列表，并对属性设置为的所有消息进行计数 <xref:System.Messaging.Message.Priority%2A> <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1268">The following code example gets a dynamic list of messages in a queue and counts all messages with the <xref:System.Messaging.Message.Priority%2A> property set to <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.</span></span>  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator2 () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator2();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator2 : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator2 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b3203-1269">为队列中的所有消息创建枚举数对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-1269">Creates an enumerator object for all the messages in the queue.</span></span></summary>
        <returns><span data-ttu-id="b3203-1270">该 <see cref="T:System.Messaging.MessageEnumerator" /> 包括队列中所包含的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1270">The <see cref="T:System.Messaging.MessageEnumerator" /> holding the messages that are contained in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1271"><xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> 创建队列中所有消息的动态列表。</span><span class="sxs-lookup"><span data-stu-id="b3203-1271"><xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> creates a dynamic list of all the messages in a queue.</span></span> <span data-ttu-id="b3203-1272">你可以通过调用返回的来从队列中删除消息，该消息位于枚举数的当前位置 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> <xref:System.Messaging.MessageEnumerator> <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1272">You can remove from the queue the message at the enumerator's current position by calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> for the <xref:System.Messaging.MessageEnumerator> that <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> returns.</span></span>  
  
 <span data-ttu-id="b3203-1273">由于游标与队列中的消息动态列表相关联，因此，如果消息在当前游标位置之外，则枚举将反映对队列中的消息所做的任何修改。</span><span class="sxs-lookup"><span data-stu-id="b3203-1273">Because the cursor is associated with the dynamic list of messages in the queue, the enumeration reflects any modification you make to the messages in the queue, if the message is beyond the current cursor position.</span></span> <span data-ttu-id="b3203-1274">例如，枚举器可以自动访问放置在游标当前位置之外的低优先级的消息，但不能访问在该位置之前插入的优先级较高的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1274">For example, the enumerator can automatically access a lower-priority message placed beyond the cursor's current position, but not a higher-priority message inserted before that position.</span></span> <span data-ttu-id="b3203-1275">但是，你可以通过调用来重置枚举，从而将游标移回列表的开头 <xref:System.Messaging.MessageEnumerator.Reset%2A> <xref:System.Messaging.MessageEnumerator> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1275">However, you can reset the enumeration, thereby moving the cursor back to the beginning of the list, by calling <xref:System.Messaging.MessageEnumerator.Reset%2A> for the <xref:System.Messaging.MessageEnumerator>.</span></span>  
  
 <span data-ttu-id="b3203-1276">枚举中的消息顺序反映了它们在队列中的顺序，因此优先级较高的消息会出现在优先级较低的消息之前。</span><span class="sxs-lookup"><span data-stu-id="b3203-1276">The order of the messages in the enumeration reflects their order in the queue, so higher-priority messages will appear before lower-priority ones.</span></span>  
  
 <span data-ttu-id="b3203-1277">如果希望队列中消息的静态快照而不是动态连接到它们，请调用 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1277">If you want a static snapshot of the messages in the queue rather than a dynamic connection to them, call <xref:System.Messaging.MessageQueue.GetAllMessages%2A>.</span></span> <span data-ttu-id="b3203-1278">此方法返回对象的数组 <xref:System.Messaging.Message> ，这些对象表示调用方法时的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1278">This method returns an array of <xref:System.Messaging.Message> objects, which represent the messages at the time the method was called.</span></span>  
  
 <span data-ttu-id="b3203-1279">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1279">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1280">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1280">Workgroup mode</span></span>|<span data-ttu-id="b3203-1281">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1281">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1282">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1282">Local computer</span></span>|<span data-ttu-id="b3203-1283">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1283">Yes</span></span>|  
|<span data-ttu-id="b3203-1284">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1284">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1285">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1285">Yes</span></span>|  
|<span data-ttu-id="b3203-1286">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1286">Remote computer</span></span>|<span data-ttu-id="b3203-1287">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1287">Yes</span></span>|  
|<span data-ttu-id="b3203-1288">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1288">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1289">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1289">Yes</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMessageQueueEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b3203-1290">为网络上公共队列的动态列表创建枚举数对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-1290">Creates an enumerator object for a dynamic listing of the public queues on the network.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator () As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator();" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : unit -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b3203-1291">提供只进游标语义，以枚举网络上的所有公共队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1291">Provides forward-only cursor semantics to enumerate through all public queues on the network.</span></span></summary>
        <returns><span data-ttu-id="b3203-1292"><see cref="T:System.Messaging.MessageQueueEnumerator" />，提供网络上所有公共消息队列的动态列表。</span><span class="sxs-lookup"><span data-stu-id="b3203-1292">A <see cref="T:System.Messaging.MessageQueueEnumerator" /> that provides a dynamic listing of all the public message queues on the network.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1293">此重载 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> 返回网络上所有公共队列的枚举。</span><span class="sxs-lookup"><span data-stu-id="b3203-1293">This overload of <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> returns an enumeration of all the public queues that are on the network.</span></span>  
  
 <span data-ttu-id="b3203-1294">由于游标与动态列表相关联，因此，枚举反映对删除或添加到游标当前位置之外的队列所做的任何修改。</span><span class="sxs-lookup"><span data-stu-id="b3203-1294">Because the cursor is associated with a dynamic listing, the enumeration reflects any modification you make to a queue list for queues deleted or added beyond the cursor's current position.</span></span> <span data-ttu-id="b3203-1295">不会反映在游标当前位置之前添加或删除队列的操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-1295">Additions or deletion of queues located before the cursor's current position are not reflected.</span></span> <span data-ttu-id="b3203-1296">例如，枚举器可以自动访问追加到光标位置之外的队列，而不是在该位置之前插入的队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1296">For example, the enumerator can automatically access a queue appended beyond the cursor position but not one inserted before that position.</span></span> <span data-ttu-id="b3203-1297">但是，你可以通过调用来重置枚举，从而将游标移回列表的开头 <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> <xref:System.Messaging.MessageQueueEnumerator> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1297">However, you can reset the enumeration, thereby moving the cursor back to the beginning of the list, by calling <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> for the <xref:System.Messaging.MessageQueueEnumerator>.</span></span>  
  
 <span data-ttu-id="b3203-1298">网络中未定义队列的顺序。</span><span class="sxs-lookup"><span data-stu-id="b3203-1298">There is no defined ordering of queues in a network.</span></span> <span data-ttu-id="b3203-1299">枚举器不按计算机、标签、公共或私有状态或任何其他可访问的条件对它们进行排序。</span><span class="sxs-lookup"><span data-stu-id="b3203-1299">An enumerator does not order them, for example, by computer, label, public or private status, or any other accessible criteria.</span></span>  
  
 <span data-ttu-id="b3203-1300">如果希望网络上的队列（而不是动态连接）的静态快照，请调用 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 或 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1300">If you want a static snapshot of the queues on the network rather than a dynamic connection to them, call <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> or <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>.</span></span> <span data-ttu-id="b3203-1301">这两个方法都返回对象的数组 <xref:System.Messaging.MessageQueue> ，这些对象表示调用方法时的队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1301">Each of these two methods returns an array of <xref:System.Messaging.MessageQueue> objects, which represent the queues at the time the method was called.</span></span>  
  
 <span data-ttu-id="b3203-1302">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1302">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1303">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1303">Workgroup mode</span></span>|<span data-ttu-id="b3203-1304">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1304">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1305">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1305">Local computer</span></span>|<span data-ttu-id="b3203-1306">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1306">No</span></span>|  
|<span data-ttu-id="b3203-1307">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1307">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1308">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1308">No</span></span>|  
|<span data-ttu-id="b3203-1309">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1309">Remote computer</span></span>|<span data-ttu-id="b3203-1310">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1310">No</span></span>|  
|<span data-ttu-id="b3203-1311">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1311">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1312">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1312">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1313">下面的代码示例将循环访问网络中的所有消息队列，并检查每个队列的路径。</span><span class="sxs-lookup"><span data-stu-id="b3203-1313">The following code example iterates through all the message queues in the network, and examines the path for each queue.</span></span> <span data-ttu-id="b3203-1314">最后，它显示网络上公用队列的数量。</span><span class="sxs-lookup"><span data-stu-id="b3203-1314">Finally, it displays the number of public queues on the network.</span></span>  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator (criteria As MessageQueueCriteria) As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria"><span data-ttu-id="b3203-1315"><see cref="T:System.Messaging.MessageQueueCriteria" />，包含用于筛选可用消息队列的判据。</span><span class="sxs-lookup"><span data-stu-id="b3203-1315">A <see cref="T:System.Messaging.MessageQueueCriteria" /> that contains the criteria used to filter the available message queues.</span></span></param>
        <summary><span data-ttu-id="b3203-1316">提供只进游标语义，以枚举网络上满足指定判据的所有公共队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1316">Provides forward-only cursor semantics to enumerate through all public queues on the network that meet the specified criteria.</span></span></summary>
        <returns><span data-ttu-id="b3203-1317"><see cref="T:System.Messaging.MessageQueueEnumerator" />，提供网络上公共消息队列的动态列表，这些消息队列满足 <paramref name="criteria" /> 参数指定的限制。</span><span class="sxs-lookup"><span data-stu-id="b3203-1317">A <see cref="T:System.Messaging.MessageQueueEnumerator" /> that provides a dynamic listing of the public message queues on the network that satisfy the restrictions specified by the <paramref name="criteria" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1318">的此重载 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> 返回网络上满足应用程序条件中定义的条件的所有公用队列的列表。</span><span class="sxs-lookup"><span data-stu-id="b3203-1318">This overload of <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> returns a listing of all the public queues on the network that satisfy criteria defined in the application criteria.</span></span> <span data-ttu-id="b3203-1319">可以指定要包括的条件，例如，队列创建或修改时间、计算机名称、标签、类别或这些条件的任意组合。</span><span class="sxs-lookup"><span data-stu-id="b3203-1319">You can specify the criteria to include, for example, queue creation or modification time, computer name, label, category, or any combination of these.</span></span>  
  
 <span data-ttu-id="b3203-1320">由于游标与动态列表相关联，因此，枚举反映了对出现在游标当前位置之外的队列所做的任何修改。</span><span class="sxs-lookup"><span data-stu-id="b3203-1320">Because the cursor is associated with a dynamic listing, the enumeration reflects any modification you make to a queue that occurs beyond the cursor's current position.</span></span> <span data-ttu-id="b3203-1321">不会反映对光标当前位置之前的队列所做的更改。</span><span class="sxs-lookup"><span data-stu-id="b3203-1321">Changes to queues located before the cursor's current position are not reflected.</span></span> <span data-ttu-id="b3203-1322">例如，枚举器可以自动访问追加到光标位置之外的队列，而不是在该位置之前插入的队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1322">For example, the enumerator can automatically access a queue appended beyond the cursor position but not one inserted before that position.</span></span> <span data-ttu-id="b3203-1323">但是，你可以通过调用来重置枚举，从而将游标移回列表的开头 <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> <xref:System.Messaging.MessageQueueEnumerator> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1323">However, you can reset the enumeration, thereby moving the cursor back to the beginning of the list, by calling <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> for the <xref:System.Messaging.MessageQueueEnumerator>.</span></span>  
  
 <span data-ttu-id="b3203-1324">网络中未定义队列的顺序。</span><span class="sxs-lookup"><span data-stu-id="b3203-1324">There is no defined ordering of queues in a network.</span></span> <span data-ttu-id="b3203-1325">枚举器不按计算机、标签、公共或私有状态或任何其他可访问的条件对它们进行排序。</span><span class="sxs-lookup"><span data-stu-id="b3203-1325">An enumerator does not order them, for example, by computer, label, public or private status, or any other accessible criteria.</span></span>  
  
 <span data-ttu-id="b3203-1326">如果希望网络上的队列（而不是动态连接到它们）的静态快照，请指定 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 或调用的条件 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1326">If you want a static snapshot of the queues on the network rather than a dynamic connection to them, specify criteria for <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> or call <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>.</span></span> <span data-ttu-id="b3203-1327">这两个方法都返回对象的数组 <xref:System.Messaging.MessageQueue> ，这些对象表示调用方法时的队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1327">Each of these two methods returns an array of <xref:System.Messaging.MessageQueue> objects, which represent the queues at the time the method was called.</span></span> <span data-ttu-id="b3203-1328">调用 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> 、 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> 或 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> 可提供与 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 通过、和的筛选条件调用相同的 <xref:System.Messaging.MessageQueue.Category%2A> 结果 <xref:System.Messaging.MessageQueue.Label%2A> <xref:System.Messaging.MessageQueue.MachineName%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1328">Calling <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, or <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> provides the same results as calling <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> with the filtering criteria of <xref:System.Messaging.MessageQueue.Category%2A>, <xref:System.Messaging.MessageQueue.Label%2A>, and <xref:System.Messaging.MessageQueue.MachineName%2A>, respectively.</span></span>  
  
 <span data-ttu-id="b3203-1329">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1329">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1330">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1330">Workgroup mode</span></span>|<span data-ttu-id="b3203-1331">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1331">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1332">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1332">Local computer</span></span>|<span data-ttu-id="b3203-1333">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1333">No</span></span>|  
|<span data-ttu-id="b3203-1334">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1334">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1335">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1335">No</span></span>|  
|<span data-ttu-id="b3203-1336">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1336">Remote computer</span></span>|<span data-ttu-id="b3203-1337">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1337">No</span></span>|  
|<span data-ttu-id="b3203-1338">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1338">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1339">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1339">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1340">下面的代码示例将循环访问消息队列，并显示在最后一天中创建并且存在于计算机 "MyComputer" 上的每个队列的路径。</span><span class="sxs-lookup"><span data-stu-id="b3203-1340">The following code example iterates through message queues and displays the path of each queue that was created in the last day and that exists on the computer "MyComputer".</span></span>  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPrivateQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPrivateQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPrivateQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPrivateQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName"><span data-ttu-id="b3203-1341">计算机，从其中检索专用队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1341">The computer from which to retrieve the private queues.</span></span></param>
        <summary><span data-ttu-id="b3203-1342">检索指定计算机上的所有专用队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1342">Retrieves all the private queues on the specified computer.</span></span></summary>
        <returns><span data-ttu-id="b3203-1343">引用检索的专用队列的 <see cref="T:System.Messaging.MessageQueue" /> 对象数组。</span><span class="sxs-lookup"><span data-stu-id="b3203-1343">An array of <see cref="T:System.Messaging.MessageQueue" /> objects that reference the retrieved private queues.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1344"><xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> 检索指定计算机上队列的静态快照。</span><span class="sxs-lookup"><span data-stu-id="b3203-1344"><xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> retrieves a static snapshot of the queues on a specified computer.</span></span>  
  
 <span data-ttu-id="b3203-1345">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1345">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1346">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1346">Workgroup mode</span></span>|<span data-ttu-id="b3203-1347">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1347">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1348">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1348">Local computer</span></span>|<span data-ttu-id="b3203-1349">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1349">Yes</span></span>|  
|<span data-ttu-id="b3203-1350">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1350">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1351">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1351">Yes</span></span>|  
|<span data-ttu-id="b3203-1352">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1352">Remote computer</span></span>|<span data-ttu-id="b3203-1353">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1353">Yes</span></span>|  
|<span data-ttu-id="b3203-1354">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1354">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1355">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1355">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1356">下面的代码示例检索队列的列表。</span><span class="sxs-lookup"><span data-stu-id="b3203-1356">The following code example retrieves lists of queues.</span></span>  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-1357"><paramref name="machineName" /> 参数为 <see langword="null" /> 或是空字符串（“”）。</span><span class="sxs-lookup"><span data-stu-id="b3203-1357">The <paramref name="machineName" /> parameter is <see langword="null" /> or an empty string ("").</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-1358">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-1358">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPublicQueues">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b3203-1359">检索网络上的所有公共队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1359">Retrieves all the public queues on the network.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues () As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues();" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : unit -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b3203-1360">检索网络上的所有公共队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1360">Retrieves all the public queues on the network.</span></span></summary>
        <returns><span data-ttu-id="b3203-1361">引用检索的公共队列的 <see cref="T:System.Messaging.MessageQueue" /> 对象数组。</span><span class="sxs-lookup"><span data-stu-id="b3203-1361">An array of <see cref="T:System.Messaging.MessageQueue" /> objects that reference the retrieved public queues.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1362">如果要完整列出网络上的所有公共队列，请使用此重载。</span><span class="sxs-lookup"><span data-stu-id="b3203-1362">Use this overload if you want a complete list of all the public queues on the network.</span></span> <span data-ttu-id="b3203-1363">如果要按某些条件（如 <xref:System.Messaging.MessageQueue.MachineName%2A> 、或上次修改时间）限制列表，请 <xref:System.Messaging.MessageQueue.Category%2A> 使用此方法的另一个重载。</span><span class="sxs-lookup"><span data-stu-id="b3203-1363">If you want to restrict the list by certain criteria, such as <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, or last modified time use another overload of this method.</span></span> <span data-ttu-id="b3203-1364"> (或者，你可以使用 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> 、 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> 或 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> 。 ) </span><span class="sxs-lookup"><span data-stu-id="b3203-1364">(Alternatively, you can use <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, or <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>.)</span></span>  
  
 <span data-ttu-id="b3203-1365"><xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 检索队列的静态快照。</span><span class="sxs-lookup"><span data-stu-id="b3203-1365"><xref:System.Messaging.MessageQueue.GetPublicQueues%2A> retrieves a static snapshot of the queues.</span></span> <span data-ttu-id="b3203-1366">若要与队列动态列表交互，请使用 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1366">To interact with a dynamic list of the queues, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.</span></span>  
  
 <span data-ttu-id="b3203-1367">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1367">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1368">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1368">Workgroup mode</span></span>|<span data-ttu-id="b3203-1369">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1369">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1370">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1370">Local computer</span></span>|<span data-ttu-id="b3203-1371">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1371">No</span></span>|  
|<span data-ttu-id="b3203-1372">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1372">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1373">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1373">No</span></span>|  
|<span data-ttu-id="b3203-1374">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1374">Remote computer</span></span>|<span data-ttu-id="b3203-1375">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1375">No</span></span>|  
|<span data-ttu-id="b3203-1376">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1376">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1377">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1377">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1378">下面的代码示例检索队列的列表。</span><span class="sxs-lookup"><span data-stu-id="b3203-1378">The following code example retrieves lists of queues.</span></span>  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-1379">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-1379">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues (criteria As MessageQueueCriteria) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria"><span data-ttu-id="b3203-1380"><see cref="T:System.Messaging.MessageQueueCriteria" />，包含用于筛选队列的判据。</span><span class="sxs-lookup"><span data-stu-id="b3203-1380">A <see cref="T:System.Messaging.MessageQueueCriteria" /> that contains the criteria used to filter the queues.</span></span></param>
        <summary><span data-ttu-id="b3203-1381">检索网络上满足指定判据的所有公共队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1381">Retrieves all the public queues on the network that meet the specified criteria.</span></span></summary>
        <returns><span data-ttu-id="b3203-1382">引用检索的公共队列的 <see cref="T:System.Messaging.MessageQueue" /> 对象数组。</span><span class="sxs-lookup"><span data-stu-id="b3203-1382">An array of <see cref="T:System.Messaging.MessageQueue" /> objects that reference the retrieved public queues.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1383">如果要按标签、类别或计算机名称筛选网络上的所有公共队列， <xref:System.Messaging.MessageQueue> 类将包含 (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> 、 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> 和分别) 提供该功能的特定方法 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1383">If you want to filter all the public queues on the network by label, category, or computer name, the <xref:System.Messaging.MessageQueue> class contains specific methods that provide that functionality (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, and <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, respectively).</span></span> <span data-ttu-id="b3203-1384">使用此重载获取网络上满足多个条件的所有公用队列的列表 (例如，如果要同时指定标签和类别) 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1384">Use this overload to get a list of all the public queues on the network that meet more than one of these criteria (for example, if you want to specify both a label and a category).</span></span> <span data-ttu-id="b3203-1385">还可以通过、和以外的消息条件进行筛选 <xref:System.Messaging.MessageQueue.Label%2A> <xref:System.Messaging.MessageQueue.Category%2A> <xref:System.Messaging.MessageQueue.MachineName%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1385">You can also filter by message criteria other than <xref:System.Messaging.MessageQueue.Label%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, and <xref:System.Messaging.MessageQueue.MachineName%2A>.</span></span> <span data-ttu-id="b3203-1386">例如，使用此重载按队列的上次修改时间进行筛选。</span><span class="sxs-lookup"><span data-stu-id="b3203-1386">For example, you use this overload to filter by a queue's last-modified time.</span></span> <span data-ttu-id="b3203-1387">只需创建类的新实例 <xref:System.Messaging.MessageQueueCriteria> ，在该实例中设置相应的属性，然后将该实例作为 `criteria` 参数传递。</span><span class="sxs-lookup"><span data-stu-id="b3203-1387">Simply create a new instance of the <xref:System.Messaging.MessageQueueCriteria> class, set the appropriate properties in the instance, and pass the instance as the `criteria` parameter.</span></span>  
  
 <span data-ttu-id="b3203-1388"><xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 检索队列的静态快照。</span><span class="sxs-lookup"><span data-stu-id="b3203-1388"><xref:System.Messaging.MessageQueue.GetPublicQueues%2A> retrieves a static snapshot of the queues.</span></span> <span data-ttu-id="b3203-1389">若要与队列动态列表交互，请使用 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1389">To interact with a dynamic list of the queues, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.</span></span>  
  
 <span data-ttu-id="b3203-1390">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1390">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1391">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1391">Workgroup mode</span></span>|<span data-ttu-id="b3203-1392">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1392">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1393">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1393">Local computer</span></span>|<span data-ttu-id="b3203-1394">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1394">No</span></span>|  
|<span data-ttu-id="b3203-1395">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1395">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1396">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1396">No</span></span>|  
|<span data-ttu-id="b3203-1397">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1397">Remote computer</span></span>|<span data-ttu-id="b3203-1398">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1398">No</span></span>|  
|<span data-ttu-id="b3203-1399">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1399">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1400">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1400">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1401">下面的代码示例检索队列的列表。</span><span class="sxs-lookup"><span data-stu-id="b3203-1401">The following code example retrieves lists of queues.</span></span>  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-1402">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-1402">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="T:System.Messaging.MessageQueueCriteria" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByCategory (category As Guid) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByCategory(Guid category);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByCategory : Guid -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByCategory category" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category"><span data-ttu-id="b3203-1403">一个 <see cref="T:System.Guid" />，它将要检索的队列集分组。</span><span class="sxs-lookup"><span data-stu-id="b3203-1403">A <see cref="T:System.Guid" /> that groups the set of queues to be retrieved.</span></span></param>
        <summary><span data-ttu-id="b3203-1404">检索网络上所有属于指定类别的公共队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1404">Retrieves all the public queues on the network that belong to the specified category.</span></span></summary>
        <returns><span data-ttu-id="b3203-1405">引用检索的公共队列的 <see cref="T:System.Messaging.MessageQueue" /> 对象数组。</span><span class="sxs-lookup"><span data-stu-id="b3203-1405">An array of <see cref="T:System.Messaging.MessageQueue" /> objects that reference the retrieved public queues.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1406">使用此方法可以按类别筛选公共队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1406">Use this method to filter the public queues by category.</span></span> <span data-ttu-id="b3203-1407"><xref:System.Messaging.MessageQueue.Category%2A>属性提供对消息队列类型 ID 属性的访问， (这是特定队列的读/写) 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1407">The <xref:System.Messaging.MessageQueue.Category%2A> property provides access to the Message Queuing type ID property (which is read/write) of a particular queue.</span></span> <span data-ttu-id="b3203-1408">尽管可以使用 <xref:System.Guid.NewGuid%2A> 来创建在所有值中都是唯一的类别值 <xref:System.Guid> ，但这并不是必需的。</span><span class="sxs-lookup"><span data-stu-id="b3203-1408">Although you can use <xref:System.Guid.NewGuid%2A> to create a category value that is unique across all <xref:System.Guid> values, it is not necessary.</span></span> <span data-ttu-id="b3203-1409">类别值仅需与其他类别（而不是所有其他值）不同 <xref:System.Guid> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1409">The category value needs to be distinct only from other categories, not from all other <xref:System.Guid> values.</span></span> <span data-ttu-id="b3203-1410">例如，可以将分配为 {00000000-0000-0000-0000-000000000001} <xref:System.Messaging.MessageQueue.Category%2A> 一组队列，并将指定为另一组队列 {00000000-0000-0000-0000-000000000002} 的 <xref:System.Messaging.MessageQueue.Category%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1410">For example, you can assign {00000000-0000-0000-0000-000000000001} as the <xref:System.Messaging.MessageQueue.Category%2A> for one set of queues and {00000000-0000-0000-0000-000000000002} as the <xref:System.Messaging.MessageQueue.Category%2A> for another set.</span></span>  
  
 <span data-ttu-id="b3203-1411"><xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> 检索队列的静态快照。</span><span class="sxs-lookup"><span data-stu-id="b3203-1411"><xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> retrieves a static snapshot of the queues.</span></span> <span data-ttu-id="b3203-1412">若要与队列动态列表交互，请使用 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1412">To interact with a dynamic list of the queues, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.</span></span> <span data-ttu-id="b3203-1413">你可以将类别指定为 <xref:System.Messaging.MessageQueueCriteria> 传入方法的。</span><span class="sxs-lookup"><span data-stu-id="b3203-1413">You can specify the category as part of the <xref:System.Messaging.MessageQueueCriteria> you pass into the method.</span></span>  
  
 <span data-ttu-id="b3203-1414">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1414">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1415">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1415">Workgroup mode</span></span>|<span data-ttu-id="b3203-1416">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1416">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1417">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1417">Local computer</span></span>|<span data-ttu-id="b3203-1418">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1418">No</span></span>|  
|<span data-ttu-id="b3203-1419">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1419">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1420">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1420">No</span></span>|  
|<span data-ttu-id="b3203-1421">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1421">Remote computer</span></span>|<span data-ttu-id="b3203-1422">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1422">No</span></span>|  
|<span data-ttu-id="b3203-1423">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1423">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1424">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1424">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1425">下面的代码示例检索队列的列表。</span><span class="sxs-lookup"><span data-stu-id="b3203-1425">The following code example retrieves lists of queues.</span></span>  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-1426">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-1426">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByLabel (label As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByLabel(System::String ^ label);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByLabel : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByLabel label" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label"><span data-ttu-id="b3203-1427">一个标签，它将要检索的队列集分组。</span><span class="sxs-lookup"><span data-stu-id="b3203-1427">A label that groups the set of queues to be retrieved.</span></span></param>
        <summary><span data-ttu-id="b3203-1428">检索网络上带有指定标签的所有公共队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1428">Retrieves all the public queues on the network that carry the specified label.</span></span></summary>
        <returns><span data-ttu-id="b3203-1429">引用检索的公共队列的 <see cref="T:System.Messaging.MessageQueue" /> 对象数组。</span><span class="sxs-lookup"><span data-stu-id="b3203-1429">An array of <see cref="T:System.Messaging.MessageQueue" /> objects that reference the retrieved public queues.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1430">使用此方法可以按标签筛选公共队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1430">Use this method to filter the public queues by label.</span></span>  
  
 <span data-ttu-id="b3203-1431"><xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> 检索队列的静态快照。</span><span class="sxs-lookup"><span data-stu-id="b3203-1431"><xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> retrieves a static snapshot of the queues.</span></span> <span data-ttu-id="b3203-1432">若要与队列动态列表交互，请使用 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1432">To interact with a dynamic list of the queues, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.</span></span> <span data-ttu-id="b3203-1433">您可以将标签指定为传入方法的中的一部分 <xref:System.Messaging.MessageQueueCriteria> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1433">You can specify the label as part of the <xref:System.Messaging.MessageQueueCriteria> you pass into the method.</span></span>  
  
 <span data-ttu-id="b3203-1434">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1434">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1435">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1435">Workgroup mode</span></span>|<span data-ttu-id="b3203-1436">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1436">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1437">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1437">Local computer</span></span>|<span data-ttu-id="b3203-1438">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1438">No</span></span>|  
|<span data-ttu-id="b3203-1439">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1439">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1440">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1440">No</span></span>|  
|<span data-ttu-id="b3203-1441">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1441">Remote computer</span></span>|<span data-ttu-id="b3203-1442">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1442">No</span></span>|  
|<span data-ttu-id="b3203-1443">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1443">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1444">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1444">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1445">下面的代码示例检索队列的列表。</span><span class="sxs-lookup"><span data-stu-id="b3203-1445">The following code example retrieves lists of queues.</span></span>  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-1446">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-1446">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3203-1447"><paramref name="label" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1447">The <paramref name="label" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName"><span data-ttu-id="b3203-1448">计算机的名称，该计算机包含要检索的公共队列集。</span><span class="sxs-lookup"><span data-stu-id="b3203-1448">The name of the computer that contains the set of public queues to be retrieved.</span></span></param>
        <summary><span data-ttu-id="b3203-1449">检索驻留在指定计算机上的所有公共队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1449">Retrieves all the public queues that reside on the specified computer.</span></span></summary>
        <returns><span data-ttu-id="b3203-1450"><see cref="T:System.Messaging.MessageQueue" /> 对象数组，这些对象引用该计算机上的公共队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1450">An array of <see cref="T:System.Messaging.MessageQueue" /> objects that reference the public queues on the computer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1451">使用此方法可以按计算机筛选公共队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1451">Use this method to filter the public queues by computer.</span></span>  
  
 <span data-ttu-id="b3203-1452"><xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> 检索队列的静态快照。</span><span class="sxs-lookup"><span data-stu-id="b3203-1452"><xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> retrieves a static snapshot of the queues.</span></span> <span data-ttu-id="b3203-1453">若要与队列动态列表交互，请使用 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1453">To interact with a dynamic list of the queues, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.</span></span> <span data-ttu-id="b3203-1454">你可以将计算机名称指定为 <xref:System.Messaging.MessageQueueCriteria> 传入方法的。</span><span class="sxs-lookup"><span data-stu-id="b3203-1454">You can specify the computer name as part of the <xref:System.Messaging.MessageQueueCriteria> you pass into the method.</span></span>  
  
 <span data-ttu-id="b3203-1455">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1455">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1456">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1456">Workgroup mode</span></span>|<span data-ttu-id="b3203-1457">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1457">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1458">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1458">Local computer</span></span>|<span data-ttu-id="b3203-1459">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1459">No</span></span>|  
|<span data-ttu-id="b3203-1460">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1460">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1461">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1461">No</span></span>|  
|<span data-ttu-id="b3203-1462">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1462">Remote computer</span></span>|<span data-ttu-id="b3203-1463">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1463">No</span></span>|  
|<span data-ttu-id="b3203-1464">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1464">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1465">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1465">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1466">下面的代码示例检索队列的列表。</span><span class="sxs-lookup"><span data-stu-id="b3203-1466">The following code example retrieves lists of queues.</span></span>  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-1467"><paramref name="machineName" /> 参数的语法不正确。</span><span class="sxs-lookup"><span data-stu-id="b3203-1467">The <paramref name="machineName" /> parameter has incorrect syntax.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-1468">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-1468">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSecurityContext () As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::SecurityContext ^ GetSecurityContext();" />
      <MemberSignature Language="F#" Value="static member GetSecurityContext : unit -&gt; System.Messaging.SecurityContext" Usage="System.Messaging.MessageQueue.GetSecurityContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b3203-1469">检索进行此调用时 MSMQ 将当前用户（线程标识）关联到的安全上下文。</span><span class="sxs-lookup"><span data-stu-id="b3203-1469">Retrieves the security context that MSMQ associates with the current user (thread identity) at the time of this call.</span></span></summary>
        <returns><span data-ttu-id="b3203-1470">包含安全上下文的 <see cref="T:System.Messaging.SecurityContext" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-1470">A <see cref="T:System.Messaging.SecurityContext" /> object that contains the security context.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Messaging.Message.SecurityContext" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Id { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : Guid" Usage="System.Messaging.MessageQueue.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_GuidId")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_GuidId")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-1471">获取队列的唯一“消息队列”标识符。</span><span class="sxs-lookup"><span data-stu-id="b3203-1471">Gets the unique Message Queuing identifier of the queue.</span></span></summary>
        <value><span data-ttu-id="b3203-1472"><see cref="P:System.Messaging.MessageQueue.Id" />，表示由“消息队列”应用程序生成的消息标识符。</span><span class="sxs-lookup"><span data-stu-id="b3203-1472">A <see cref="P:System.Messaging.MessageQueue.Id" /> that represents the message identifier generated by the Message Queuing application.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1473">消息队列 <xref:System.Messaging.MessageQueue.Id%2A> 在创建队列时设置属性。</span><span class="sxs-lookup"><span data-stu-id="b3203-1473">Message Queuing sets the <xref:System.Messaging.MessageQueue.Id%2A> property when it creates the queue.</span></span> <span data-ttu-id="b3203-1474">此属性仅适用于公用队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1474">This property is only available for public queues.</span></span>  
  
 <span data-ttu-id="b3203-1475">下表显示了此属性在各种工作组模式下是否可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1475">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1476">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1476">Workgroup mode</span></span>|<span data-ttu-id="b3203-1477">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1477">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1478">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1478">Local computer</span></span>|<span data-ttu-id="b3203-1479">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1479">Yes</span></span>|  
|<span data-ttu-id="b3203-1480">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1480">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1481">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1481">Yes</span></span>|  
|<span data-ttu-id="b3203-1482">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1482">Remote computer</span></span>|<span data-ttu-id="b3203-1483">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1483">No</span></span>|  
|<span data-ttu-id="b3203-1484">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1484">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1485">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1485">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1486">下面的代码示例显示消息队列属性的值 <xref:System.Messaging.MessageQueue.Id%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1486">The following code example displays the value of a message queue's <xref:System.Messaging.MessageQueue.Id%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-1487">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-1487">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteQueueSize As Long " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly long InfiniteQueueSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteQueueSize : int64" Usage="System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-1488">指定对某队列不存在大小限制。</span><span class="sxs-lookup"><span data-stu-id="b3203-1488">Specifies that no size restriction exists for a queue.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1489">此成员在设置或时经常 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> 使用 <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1489">This member is frequently used when setting <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> or <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1490">下面的代码示例演示如何使用 <xref:System.Messaging.MessageQueue.InfiniteQueueSize> 成员。</span><span class="sxs-lookup"><span data-stu-id="b3203-1490">The following code example demonstrates the use of the <xref:System.Messaging.MessageQueue.InfiniteQueueSize> member.</span></span>  
  
 [!code-csharp[MessageQueue#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-1491">指定对查看或接收消息的方法不存在超时设定。</span><span class="sxs-lookup"><span data-stu-id="b3203-1491">Specifies that no time-out exists for methods that peek or receive messages.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1492"><xref:System.Messaging.MessageQueue> 支持两种类型的消息检索：同步和异步。</span><span class="sxs-lookup"><span data-stu-id="b3203-1492"><xref:System.Messaging.MessageQueue> supports two types of message retrieval: synchronous and asynchronous.</span></span> <span data-ttu-id="b3203-1493">同步方法和将 <xref:System.Messaging.MessageQueue.Peek%2A> <xref:System.Messaging.MessageQueue.Receive%2A> 导致进程线程等待指定的时间间隔，以使新消息到达队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1493">The synchronous methods, <xref:System.Messaging.MessageQueue.Peek%2A> and <xref:System.Messaging.MessageQueue.Receive%2A>, cause the process thread to wait a specified time interval for a new message to arrive in the queue.</span></span> <span data-ttu-id="b3203-1494">如果指定的时间间隔为 <xref:System.Messaging.MessageQueue.InfiniteTimeout> ，则进程线程将保持阻止状态，直到新消息可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1494">If the specified time interval is <xref:System.Messaging.MessageQueue.InfiniteTimeout>, the process thread remains blocked until a new message is available.</span></span> <span data-ttu-id="b3203-1495">另一方面，如果 <xref:System.Messaging.MessageQueue.BeginPeek%2A> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 异步方法)  (，则允许主应用程序任务在单独的线程中继续，直到消息到达队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1495">On the other hand, <xref:System.Messaging.MessageQueue.BeginPeek%2A> and <xref:System.Messaging.MessageQueue.BeginReceive%2A> (the asynchronous methods), allow the main application tasks to continue in a separate thread until a message arrives in the queue.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1496">下面的代码示例演示如何使用 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 成员。</span><span class="sxs-lookup"><span data-stu-id="b3203-1496">The following code example demonstrates the use of the <xref:System.Messaging.MessageQueue.InfiniteTimeout> member.</span></span>  
  
 [!code-csharp[MessageQueue#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.MessageQueue.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_Label")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_Label")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-1497">获取或设置队列说明。</span><span class="sxs-lookup"><span data-stu-id="b3203-1497">Gets or sets the queue description.</span></span></summary>
        <value><span data-ttu-id="b3203-1498">消息队列的标签。</span><span class="sxs-lookup"><span data-stu-id="b3203-1498">The label for the message queue.</span></span> <span data-ttu-id="b3203-1499">默认值为空字符串("")。</span><span class="sxs-lookup"><span data-stu-id="b3203-1499">The default is an empty string ("").</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1500">消息队列标签的最大长度为124个字符。</span><span class="sxs-lookup"><span data-stu-id="b3203-1500">The maximum length of a message queue label is 124 characters.</span></span>  
  
 <span data-ttu-id="b3203-1501"><xref:System.Messaging.MessageQueue.Label%2A>属性不需要在所有队列中都是唯一的。</span><span class="sxs-lookup"><span data-stu-id="b3203-1501">The <xref:System.Messaging.MessageQueue.Label%2A> property does not need to be unique across all queues.</span></span> <span data-ttu-id="b3203-1502">但是，如果多个队列共享同一项 <xref:System.Messaging.MessageQueue.Label%2A> ，则不能使用 <xref:System.Messaging.MessageQueue.Send%28System.Object%29> 方法将消息广播到所有队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1502">However, if multiple queues share the same <xref:System.Messaging.MessageQueue.Label%2A>, you cannot use the <xref:System.Messaging.MessageQueue.Send%28System.Object%29> method to broadcast a message to all of them.</span></span> <span data-ttu-id="b3203-1503">如果在 <xref:System.Messaging.MessageQueue.Path%2A> 发送消息时使用属性的标签语法，则如果不唯一，则会引发异常 <xref:System.Messaging.MessageQueue.Label%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1503">If you use the label syntax for the <xref:System.Messaging.MessageQueue.Path%2A> property when you send the message, an exception will be thrown if the <xref:System.Messaging.MessageQueue.Label%2A> is not unique.</span></span>  
  
 <span data-ttu-id="b3203-1504">下表显示了此属性在各种工作组模式下是否可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1504">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1505">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1505">Workgroup mode</span></span>|<span data-ttu-id="b3203-1506">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1506">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1507">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1507">Local computer</span></span>|<span data-ttu-id="b3203-1508">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1508">Yes</span></span>|  
|<span data-ttu-id="b3203-1509">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1509">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1510">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1510">Yes</span></span>|  
|<span data-ttu-id="b3203-1511">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1511">Remote computer</span></span>|<span data-ttu-id="b3203-1512">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1512">No</span></span>|  
|<span data-ttu-id="b3203-1513">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1513">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1514">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1514">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1515">下面的代码示例获取并设置消息队列属性的值 <xref:System.Messaging.MessageQueue.Label%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1515">The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.Label%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-1516">标签被设置为无效值。</span><span class="sxs-lookup"><span data-stu-id="b3203-1516">The label was set to an invalid value.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-1517">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-1517">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastModifyTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime LastModifyTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.LastModifyTime : DateTime" Usage="System.Messaging.MessageQueue.LastModifyTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_LastModifyTime")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_LastModifyTime")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-1518">获取队列属性的最近修改时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-1518">Gets the last time the properties of a queue were modified.</span></span></summary>
        <value><span data-ttu-id="b3203-1519">指示队列属性最近修改时间的 <see cref="T:System.DateTime" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1519">A <see cref="T:System.DateTime" /> that indicates when the queue properties were last modified.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1520">上次修改时间包括创建队列的时间和 <xref:System.Messaging.MessageQueue> 修改 "消息队列" 队列的任何属性（如） <xref:System.Messaging.MessageQueue.BasePriority%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1520">The last modification time includes when the queue was created and any <xref:System.Messaging.MessageQueue> property that modifies the Message Queuing queue, such as <xref:System.Messaging.MessageQueue.BasePriority%2A>.</span></span> <span data-ttu-id="b3203-1521">属性的值 <xref:System.Messaging.MessageQueue.LastModifyTime%2A> 表示本地计算机的系统时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-1521">The value of the <xref:System.Messaging.MessageQueue.LastModifyTime%2A> property represents the system time of the local computer.</span></span>  
  
 <span data-ttu-id="b3203-1522"><xref:System.Messaging.MessageQueue.Refresh%2A>获取属性之前必须调用 <xref:System.Messaging.MessageQueue.LastModifyTime%2A> ; 否则，与此关联的修改时间 <xref:System.Messaging.MessageQueue> 可能不是最新的。</span><span class="sxs-lookup"><span data-stu-id="b3203-1522">You must call <xref:System.Messaging.MessageQueue.Refresh%2A> before getting the <xref:System.Messaging.MessageQueue.LastModifyTime%2A> property; otherwise, the modification time associated with this <xref:System.Messaging.MessageQueue> might not be current.</span></span>  
  
 <span data-ttu-id="b3203-1523">下表显示了此属性在各种工作组模式下是否可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1523">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1524">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1524">Workgroup mode</span></span>|<span data-ttu-id="b3203-1525">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1525">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1526">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1526">Local computer</span></span>|<span data-ttu-id="b3203-1527">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1527">Yes</span></span>|  
|<span data-ttu-id="b3203-1528">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1528">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1529">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1529">Yes</span></span>|  
|<span data-ttu-id="b3203-1530">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1530">Remote computer</span></span>|<span data-ttu-id="b3203-1531">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1531">No</span></span>|  
|<span data-ttu-id="b3203-1532">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1532">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1533">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1533">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1534">下面的代码示例显示消息队列属性的值 <xref:System.Messaging.MessageQueue.LastModifyTime%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1534">The following code example displays the value of a message queue's <xref:System.Messaging.MessageQueue.LastModifyTime%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-1535">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-1535">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.CreateTime" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Messaging.MessageQueue.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_MachineName")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_MachineName")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-1536">获取或设置“消息队列”队列所在的计算机的名称。</span><span class="sxs-lookup"><span data-stu-id="b3203-1536">Gets or sets the name of the computer where the Message Queuing queue is located.</span></span></summary>
        <value><span data-ttu-id="b3203-1537">队列所在的计算机的名称。</span><span class="sxs-lookup"><span data-stu-id="b3203-1537">The name of the computer where the queue is located.</span></span> <span data-ttu-id="b3203-1538">“消息队列”默认值为“.”，即本地计算机。</span><span class="sxs-lookup"><span data-stu-id="b3203-1538">The Message Queuing default is ".", the local computer.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1539"><xref:System.Messaging.MessageQueue.MachineName%2A>是队列友好名称语法的组成部分 <xref:System.Messaging.MessageQueue.Path%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1539">The <xref:System.Messaging.MessageQueue.MachineName%2A> is an integral component of the friendly name syntax of the queue <xref:System.Messaging.MessageQueue.Path%2A>.</span></span> <span data-ttu-id="b3203-1540">下表显示了在要使用其友好名称标识队列路径时，应用于指定类型的队列的语法。</span><span class="sxs-lookup"><span data-stu-id="b3203-1540">The following table shows the syntax you should use for a queue of a specified type when you want to identify the queue path using its friendly name.</span></span>  
  
|<span data-ttu-id="b3203-1541">队列类型</span><span class="sxs-lookup"><span data-stu-id="b3203-1541">Queue type</span></span>|<span data-ttu-id="b3203-1542">语法</span><span class="sxs-lookup"><span data-stu-id="b3203-1542">Syntax</span></span>|  
|----------------|------------|  
|<span data-ttu-id="b3203-1543">公用队列</span><span class="sxs-lookup"><span data-stu-id="b3203-1543">Public queue</span></span>|`MachineName`\\`QueueName`|  
|<span data-ttu-id="b3203-1544">专用队列</span><span class="sxs-lookup"><span data-stu-id="b3203-1544">Private queue</span></span>|`MachineName`\\`Private$`\\`QueueName`|  
|<span data-ttu-id="b3203-1545">日志队列</span><span class="sxs-lookup"><span data-stu-id="b3203-1545">Journal queue</span></span>|`MachineName`\\`QueueName`\\`Journal$`|  
|<span data-ttu-id="b3203-1546">计算机日志队列</span><span class="sxs-lookup"><span data-stu-id="b3203-1546">Machine journal queue</span></span>|`MachineName`\\`Journal$`|  
|<span data-ttu-id="b3203-1547">计算机死信队列</span><span class="sxs-lookup"><span data-stu-id="b3203-1547">Machine dead-letter queue</span></span>|`MachineName`\\`Deadletter$`|  
|<span data-ttu-id="b3203-1548">计算机事务性死信队列</span><span class="sxs-lookup"><span data-stu-id="b3203-1548">Machine transactional dead-letter queue</span></span>|`MachineName`\\`XactDeadletter$`|  
  
 <span data-ttu-id="b3203-1549">指定时，使用本地计算机的 "." <xref:System.Messaging.MessageQueue.MachineName%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1549">Use "." for the local computer when specifying the <xref:System.Messaging.MessageQueue.MachineName%2A>.</span></span> <span data-ttu-id="b3203-1550">此属性仅识别计算机名称，例如， `Server0` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1550">Only the computer name is recognized for this property, for example, `Server0`.</span></span> <span data-ttu-id="b3203-1551"><xref:System.Messaging.MessageQueue.MachineName%2A>属性不支持 IP 地址格式。</span><span class="sxs-lookup"><span data-stu-id="b3203-1551">The <xref:System.Messaging.MessageQueue.MachineName%2A> property does not support the IP address format.</span></span>  
  
 <span data-ttu-id="b3203-1552">如果 <xref:System.Messaging.MessageQueue.Path%2A> 在中定义 <xref:System.Messaging.MessageQueue.MachineName%2A> ，则当脱机工作时，应用程序将引发异常，因为路径转换需要域控制器。</span><span class="sxs-lookup"><span data-stu-id="b3203-1552">If you define the <xref:System.Messaging.MessageQueue.Path%2A> in terms of the <xref:System.Messaging.MessageQueue.MachineName%2A>, the application throws an exception when working offline because the domain controller is required for path translation.</span></span> <span data-ttu-id="b3203-1553">因此， <xref:System.Messaging.MessageQueue.FormatName%2A> <xref:System.Messaging.MessageQueue.Path%2A> 当脱机工作时，必须使用语法。</span><span class="sxs-lookup"><span data-stu-id="b3203-1553">Therefore, you must use the <xref:System.Messaging.MessageQueue.FormatName%2A> for the <xref:System.Messaging.MessageQueue.Path%2A> syntax when working offline.</span></span>  
  
 <span data-ttu-id="b3203-1554"><xref:System.Messaging.MessageQueue.MachineName%2A>、 <xref:System.Messaging.MessageQueue.Path%2A> 和 <xref:System.Messaging.MessageQueue.QueueName%2A> 属性是相关的。</span><span class="sxs-lookup"><span data-stu-id="b3203-1554">The <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, and <xref:System.Messaging.MessageQueue.QueueName%2A> properties are related.</span></span> <span data-ttu-id="b3203-1555">更改 <xref:System.Messaging.MessageQueue.MachineName%2A> 属性将导致 <xref:System.Messaging.MessageQueue.Path%2A> 属性发生更改。</span><span class="sxs-lookup"><span data-stu-id="b3203-1555">Changing the <xref:System.Messaging.MessageQueue.MachineName%2A> property causes the <xref:System.Messaging.MessageQueue.Path%2A> property to change.</span></span> <span data-ttu-id="b3203-1556">它从新的和生成 <xref:System.Messaging.MessageQueue.MachineName%2A> <xref:System.Messaging.MessageQueue.QueueName%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1556">It is built from the new <xref:System.Messaging.MessageQueue.MachineName%2A> and the <xref:System.Messaging.MessageQueue.QueueName%2A>.</span></span> <span data-ttu-id="b3203-1557">更改 <xref:System.Messaging.MessageQueue.Path%2A> (例如，若要使用格式名语法) 重置 <xref:System.Messaging.MessageQueue.MachineName%2A> 和 <xref:System.Messaging.MessageQueue.QueueName%2A> 属性以引用新队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1557">Changing the <xref:System.Messaging.MessageQueue.Path%2A> (for example, to use the format name syntax) resets the <xref:System.Messaging.MessageQueue.MachineName%2A> and <xref:System.Messaging.MessageQueue.QueueName%2A> properties to refer to the new queue.</span></span> <span data-ttu-id="b3203-1558">如果该 <xref:System.Messaging.MessageQueue.QueueName%2A> 属性为空，则将 <xref:System.Messaging.MessageQueue.Path%2A> 设置为指定的计算机的日记队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1558">If the <xref:System.Messaging.MessageQueue.QueueName%2A> property is empty, the <xref:System.Messaging.MessageQueue.Path%2A> is set to the Journal queue of the computer you specify.</span></span>  
  
 <span data-ttu-id="b3203-1559">下表显示了此属性在各种工作组模式下是否可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1559">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1560">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1560">Workgroup mode</span></span>|<span data-ttu-id="b3203-1561">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1561">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1562">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1562">Local computer</span></span>|<span data-ttu-id="b3203-1563">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1563">Yes</span></span>|  
|<span data-ttu-id="b3203-1564">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1564">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1565">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1565">Yes</span></span>|  
|<span data-ttu-id="b3203-1566">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1566">Remote computer</span></span>|<span data-ttu-id="b3203-1567">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1567">Yes</span></span>|  
|<span data-ttu-id="b3203-1568">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1568">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1569">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1569">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1570">下面的代码示例获取并设置消息队列属性的值 <xref:System.Messaging.MessageQueue.MachineName%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1570">The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.MachineName%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-1571"><see cref="P:System.Messaging.MessageQueue.MachineName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1571">The <see cref="P:System.Messaging.MessageQueue.MachineName" /> is <see langword="null" />.</span></span>        
<span data-ttu-id="b3203-1572">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-1572">-or-</span></span>

<span data-ttu-id="b3203-1573">计算机名称无效，可能是因为语法不正确。</span><span class="sxs-lookup"><span data-stu-id="b3203-1573">The name of the computer is not valid, possibly because the syntax is incorrect.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-1574">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-1574">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumJournalSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumJournalSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumJournalSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_MaximumJournalSize")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_MaximumJournalSize")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-1575">获取或设置日记队列的最大大小。</span><span class="sxs-lookup"><span data-stu-id="b3203-1575">Gets or sets the maximum size of the journal queue.</span></span></summary>
        <value><span data-ttu-id="b3203-1576">日记队列的最大大小，以千字节为单位。</span><span class="sxs-lookup"><span data-stu-id="b3203-1576">The maximum size, in kilobytes, of the journal queue.</span></span> <span data-ttu-id="b3203-1577">“消息队列”默认设置指定：不存在任何限制。</span><span class="sxs-lookup"><span data-stu-id="b3203-1577">The Message Queuing default specifies that no limit exists.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1578"><xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> 提供对消息队列日志存储限制的访问。</span><span class="sxs-lookup"><span data-stu-id="b3203-1578"><xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> provides access to the Message Queuing journal storage limit.</span></span> <span data-ttu-id="b3203-1579">仅当为时，它才适用 <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> `true` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1579">It is relevant only when <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> is `true`.</span></span> <span data-ttu-id="b3203-1580">设置此属性将修改 "消息队列" 队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1580">Setting this property modifies the Message Queuing queue.</span></span> <span data-ttu-id="b3203-1581">因此， <xref:System.Messaging.MessageQueue> 此更改会影响任何其他实例</span><span class="sxs-lookup"><span data-stu-id="b3203-1581">Therefore, any other <xref:System.Messaging.MessageQueue> instances are affected by the change</span></span>  
  
 <span data-ttu-id="b3203-1582">如果将消息存储在日志或死信队列中，则应定期清除队列，以删除不再需要的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1582">If you store messages in a journal or dead-letter queue, you should periodically clear the queue to remove messages that are no longer needed.</span></span> <span data-ttu-id="b3203-1583">此类队列中的消息将计入队列所在的计算机的消息配额。</span><span class="sxs-lookup"><span data-stu-id="b3203-1583">Messages in such a queue count toward the message quota for the computer where the queue resides.</span></span> <span data-ttu-id="b3203-1584"> (管理员设置计算机配额。 ) </span><span class="sxs-lookup"><span data-stu-id="b3203-1584">(The administrator sets the computer quota.)</span></span>  
  
 <span data-ttu-id="b3203-1585">下表显示了此属性在各种工作组模式下是否可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1585">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1586">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1586">Workgroup mode</span></span>|<span data-ttu-id="b3203-1587">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1587">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1588">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1588">Local computer</span></span>|<span data-ttu-id="b3203-1589">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1589">Yes</span></span>|  
|<span data-ttu-id="b3203-1590">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1590">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1591">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1591">Yes</span></span>|  
|<span data-ttu-id="b3203-1592">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1592">Remote computer</span></span>|<span data-ttu-id="b3203-1593">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1593">No</span></span>|  
|<span data-ttu-id="b3203-1594">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1594">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1595">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1595">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1596">下面的代码示例获取并设置消息队列属性的值 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1596">The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-1597">日记队列的最大大小被设置为无效值。</span><span class="sxs-lookup"><span data-stu-id="b3203-1597">The maximum journal queue size was set to an invalid value.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-1598">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-1598">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumQueueSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumQueueSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumQueueSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_MaximumQueueSize")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_MaximumQueueSize")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-1599">获取或设置队列的最大大小。</span><span class="sxs-lookup"><span data-stu-id="b3203-1599">Gets or sets the maximum size of the queue.</span></span></summary>
        <value><span data-ttu-id="b3203-1600">队列的最大大小，以千字节为单位。</span><span class="sxs-lookup"><span data-stu-id="b3203-1600">The maximum size, in kilobytes, of the queue.</span></span> <span data-ttu-id="b3203-1601">“消息队列”默认设置指定：不存在任何限制。</span><span class="sxs-lookup"><span data-stu-id="b3203-1601">The Message Queuing default specifies that no limit exists.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1602"><xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>提供对消息队列消息存储限制的访问，此限制与管理员定义的计算机的消息配额不同。</span><span class="sxs-lookup"><span data-stu-id="b3203-1602">The <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> provides access to the Message Queuing message storage limit, which is separate from the computer's message quota that the administrator defines.</span></span> <span data-ttu-id="b3203-1603">有关消息配额的详细信息，请参阅 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1603">For more information about the message quota, see <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>.</span></span>  
  
 <span data-ttu-id="b3203-1604">设置此属性将修改 "消息队列" 队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1604">Setting this property modifies the Message Queuing queue.</span></span> <span data-ttu-id="b3203-1605">因此， <xref:System.Messaging.MessageQueue> 此更改会影响任何其他实例</span><span class="sxs-lookup"><span data-stu-id="b3203-1605">Therefore, any other <xref:System.Messaging.MessageQueue> instances are affected by the change</span></span>  
  
 <span data-ttu-id="b3203-1606">如果尝试超过最大队列大小或计算机消息配额，则消息可能会丢失。</span><span class="sxs-lookup"><span data-stu-id="b3203-1606">If an attempt is made to exceed either the maximum queue size or the computer message quota, messages might be lost.</span></span> <span data-ttu-id="b3203-1607">当达到队列配额时，消息队列会通过返回否定确认消息，通知发送应用程序的管理队列是否已满。</span><span class="sxs-lookup"><span data-stu-id="b3203-1607">When the queue quota is reached, Message Queuing notifies the administration queue of the sending application to indicate that the queue is full, by returning a negative acknowledgment message.</span></span> <span data-ttu-id="b3203-1608">在队列中的消息的总大小降至限制以下之前，消息队列将继续发送否定确认。</span><span class="sxs-lookup"><span data-stu-id="b3203-1608">Message Queuing continues to send negative acknowledgments until the total size of the messages in the queue drops below the limit.</span></span>  
  
 <span data-ttu-id="b3203-1609">下表显示了此属性在各种工作组模式下是否可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1609">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1610">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1610">Workgroup mode</span></span>|<span data-ttu-id="b3203-1611">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1611">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1612">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1612">Local computer</span></span>|<span data-ttu-id="b3203-1613">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1613">Yes</span></span>|  
|<span data-ttu-id="b3203-1614">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1614">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1615">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1615">Yes</span></span>|  
|<span data-ttu-id="b3203-1616">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1616">Remote computer</span></span>|<span data-ttu-id="b3203-1617">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1617">No</span></span>|  
|<span data-ttu-id="b3203-1618">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1618">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1619">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1619">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1620">下面的代码示例获取并设置消息队列属性的值 <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1620">The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-1621">队列最大大小包含负值。</span><span class="sxs-lookup"><span data-stu-id="b3203-1621">The maximum queue size contains a negative value.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-1622">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-1622">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageReadPropertyFilter As MessagePropertyFilter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePropertyFilter ^ MessageReadPropertyFilter { System::Messaging::MessagePropertyFilter ^ get(); void set(System::Messaging::MessagePropertyFilter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MessageReadPropertyFilter : System.Messaging.MessagePropertyFilter with get, set" Usage="System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-1623">获取或设置接收或查看消息的属性筛选器。</span><span class="sxs-lookup"><span data-stu-id="b3203-1623">Gets or sets the property filter for receiving or peeking messages.</span></span></summary>
        <value><span data-ttu-id="b3203-1624">由队列使用的 <see cref="T:System.Messaging.MessagePropertyFilter" />，用来筛选队列所接收或查看的每个消息的属性集。</span><span class="sxs-lookup"><span data-stu-id="b3203-1624">The <see cref="T:System.Messaging.MessagePropertyFilter" /> used by the queue to filter the set of properties it receives or peeks for each message.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1625">此筛选器是一组用来限制接收或查看的消息属性的布尔值 <xref:System.Messaging.MessageQueue> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1625">This filter is a set of Boolean values restricting the message properties that the <xref:System.Messaging.MessageQueue> receives or peeks.</span></span> <span data-ttu-id="b3203-1626">当 <xref:System.Messaging.MessageQueue> 从服务器队列接收或查看消息时，它只检索值为的那些属性 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> `true` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1626">When the <xref:System.Messaging.MessageQueue> receives or peeks a message from the server queue, it retrieves only those properties for which the <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> value is `true`.</span></span>  
  
 <span data-ttu-id="b3203-1627">下图显示了属性的初始属性值 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1627">The following shows initial property values for the <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> property.</span></span> <span data-ttu-id="b3203-1628">这些设置与 <xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A> 在上调用时相同 <xref:System.Messaging.MessagePropertyFilter> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1628">These settings are identical to calling <xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A> on a <xref:System.Messaging.MessagePropertyFilter>.</span></span>  
  
|<span data-ttu-id="b3203-1629">Property</span><span class="sxs-lookup"><span data-stu-id="b3203-1629">Property</span></span>|<span data-ttu-id="b3203-1630">默认值</span><span class="sxs-lookup"><span data-stu-id="b3203-1630">Default value</span></span>|  
|--------------|-------------------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|<span data-ttu-id="b3203-1631">1024 字节</span><span class="sxs-lookup"><span data-stu-id="b3203-1631">1024 bytes</span></span>|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|<span data-ttu-id="b3203-1632">255字节</span><span class="sxs-lookup"><span data-stu-id="b3203-1632">255 bytes</span></span>|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|<span data-ttu-id="b3203-1633">255字节</span><span class="sxs-lookup"><span data-stu-id="b3203-1633">255 bytes</span></span>|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 <span data-ttu-id="b3203-1634">下表显示了此属性在各种工作组模式下是否可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1634">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1635">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1635">Workgroup mode</span></span>|<span data-ttu-id="b3203-1636">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1636">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1637">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1637">Local computer</span></span>|<span data-ttu-id="b3203-1638">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1638">Yes</span></span>|  
|<span data-ttu-id="b3203-1639">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1639">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1640">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1640">Yes</span></span>|  
|<span data-ttu-id="b3203-1641">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1641">Remote computer</span></span>|<span data-ttu-id="b3203-1642">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1642">Yes</span></span>|  
|<span data-ttu-id="b3203-1643">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1643">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1644">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1644">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1645">下面的代码示例使用 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> 来限制接收的消息属性。</span><span class="sxs-lookup"><span data-stu-id="b3203-1645">The following code example uses the <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> to restrict the message properties received.</span></span>  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-1646">筛选器为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1646">The filter is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MulticastAddress { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastAddress : string with get, set" Usage="System.Messaging.MessageQueue.MulticastAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue("")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue("")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_MulticastAddress")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_MulticastAddress")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-1647">在 MSMQ 3.0 中引入。</span><span class="sxs-lookup"><span data-stu-id="b3203-1647">Introduced in MSMQ 3.0.</span></span> <span data-ttu-id="b3203-1648">获取或设置与队列关联的多路广播地址。</span><span class="sxs-lookup"><span data-stu-id="b3203-1648">Gets or sets the multicast address associated with the queue.</span></span></summary>
        <value><span data-ttu-id="b3203-1649">包含有效的多路广播地址（格式如下）的 <see cref="T:System.String" />，或者为 <see langword="null" />，这表示队列与多路广播地址不关联。</span><span class="sxs-lookup"><span data-stu-id="b3203-1649">A <see cref="T:System.String" /> that contains a valid multicast address (in the form shown below) or <see langword="null" />, which indicates that the queue is not associated with a multicast address.</span></span>  
  
```  
&lt;address&gt;:&lt;port&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1650"><xref:System.Messaging.MessageQueue.MulticastAddress%2A>属性用于将非事务性队列与发送消息时可以使用的多播地址相关联。</span><span class="sxs-lookup"><span data-stu-id="b3203-1650">The <xref:System.Messaging.MessageQueue.MulticastAddress%2A> property is used to associate a non-transactional queue with a multicast address that can be used when sending messages.</span></span> <span data-ttu-id="b3203-1651">不能将事务性队列与多路广播地址相关联。</span><span class="sxs-lookup"><span data-stu-id="b3203-1651">You cannot associate a transactional queue with a multicast address.</span></span> <span data-ttu-id="b3203-1652">当发送应用程序向多播地址发送消息时，消息队列会将该消息的副本发送到与该地址关联的每个队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1652">When the sending application sends messages to a multicast address, Message Queuing sends a copy of the message to every queue associated with that address.</span></span>  
  
 <span data-ttu-id="b3203-1653">IP 多播地址必须在从224.0.0.0 到239.255.255.255 的 D 类范围内，这相当于设置前四个高序位等于1110。</span><span class="sxs-lookup"><span data-stu-id="b3203-1653">IP multicast addresses must be in the class D range from 224.0.0.0 to 239.255.255.255, which corresponds to setting the first four high-order bits equal to 1110.</span></span> <span data-ttu-id="b3203-1654">不过，只有此范围内的某些地址不会被保留，并且可用于发送多播消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1654">However, only certain ranges of addresses in this range are unreserved and available for sending multicast messages.</span></span> <span data-ttu-id="b3203-1655">有关保留的多播地址的最新列表，请参阅 [Internet 分配的编号机构 (IANA) Internet 多播地址](https://go.microsoft.com/fwlink/?linkid=3859) "网页。</span><span class="sxs-lookup"><span data-stu-id="b3203-1655">For the latest list of reserved multicast addresses, see the [Internet Assigned Number Authority (IANA) Internet Multicast Addresses](https://go.microsoft.com/fwlink/?linkid=3859) Web page.</span></span> <span data-ttu-id="b3203-1656">端口号没有限制。</span><span class="sxs-lookup"><span data-stu-id="b3203-1656">There are no restrictions on the port number.</span></span>  
  
 <span data-ttu-id="b3203-1657">如果多台源计算机发送多播消息，并且你希望特定队列仅接收来自一台源计算机的消息，则每个源计算机必须将消息发送到不同的 IP 地址和端口号组合。</span><span class="sxs-lookup"><span data-stu-id="b3203-1657">If several source computers are sending multicast messages and you want a specific queue to receive messages from only one source computer, each source computer must send messages to a different combination of IP address and port number.</span></span>  
  
 <span data-ttu-id="b3203-1658">若要将队列与多播地址取消关联，请将 <xref:System.Messaging.MessageQueue.MulticastAddress%2A> 属性设置为长度为零的字符串。</span><span class="sxs-lookup"><span data-stu-id="b3203-1658">To dissociate a queue from a multicast address, set the <xref:System.Messaging.MessageQueue.MulticastAddress%2A> property to a zero-length string.</span></span> <span data-ttu-id="b3203-1659">不要将其设置为 `null` ，因为这会导致 <xref:System.ArgumentNullException> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1659">Do not set it to `null`, as this will result in a <xref:System.ArgumentNullException>.</span></span>  
  
 <span data-ttu-id="b3203-1660">下表显示了此属性在各种工作组模式下是否可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1660">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1661">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1661">Workgroup mode</span></span>|<span data-ttu-id="b3203-1662">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1662">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1663">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1663">Local computer</span></span>|<span data-ttu-id="b3203-1664">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1664">Yes</span></span>|  
|<span data-ttu-id="b3203-1665">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1665">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1666">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1666">Yes</span></span>|  
|<span data-ttu-id="b3203-1667">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1667">Remote computer</span></span>|<span data-ttu-id="b3203-1668">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1668">No</span></span>|  
|<span data-ttu-id="b3203-1669">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1669">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1670">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1670">No</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="b3203-1671">未安装 MSMQ 3.0。</span><span class="sxs-lookup"><span data-stu-id="b3203-1671">MSMQ 3.0 is not installed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.Messaging.MessageQueue.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue("")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue("")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.ComponentModel.RecommendedAsConfigurable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.RecommendedAsConfigurable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_Path")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_Path")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName Language="C#">[System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.SettingsBindable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.SettingsBindable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-1672">获取或设置队列的路径。</span><span class="sxs-lookup"><span data-stu-id="b3203-1672">Gets or sets the queue's path.</span></span> <span data-ttu-id="b3203-1673">设置 <see cref="P:System.Messaging.MessageQueue.Path" /> 会导致 <see cref="T:System.Messaging.MessageQueue" /> 指向新队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1673">Setting the <see cref="P:System.Messaging.MessageQueue.Path" /> causes the <see cref="T:System.Messaging.MessageQueue" /> to point to a new queue.</span></span></summary>
        <value><span data-ttu-id="b3203-1674">由 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1674">The queue that is referenced by the <see cref="T:System.Messaging.MessageQueue" />.</span></span> <span data-ttu-id="b3203-1675">默认值取决于所使用的 <see cref="M:System.Messaging.MessageQueue.#ctor" /> 构造函数；它或者是 <see langword="null" />，或者是由构造函数的 <paramref name="path" /> 参数指定的。</span><span class="sxs-lookup"><span data-stu-id="b3203-1675">The default depends on which <see cref="M:System.Messaging.MessageQueue.#ctor" /> constructor you use; it is either <see langword="null" /> or is specified by the constructor's <paramref name="path" /> parameter.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1676">属性的语法 <xref:System.Messaging.MessageQueue.Path%2A> 取决于它所指向的队列的类型，如下表所示。</span><span class="sxs-lookup"><span data-stu-id="b3203-1676">The syntax for the <xref:System.Messaging.MessageQueue.Path%2A> property depends on the type of queue it points to, as shown in the following table.</span></span>  
  
|<span data-ttu-id="b3203-1677">队列类型</span><span class="sxs-lookup"><span data-stu-id="b3203-1677">Queue type</span></span>|<span data-ttu-id="b3203-1678">语法</span><span class="sxs-lookup"><span data-stu-id="b3203-1678">Syntax</span></span>|  
|----------------|------------|  
|<span data-ttu-id="b3203-1679">公用队列</span><span class="sxs-lookup"><span data-stu-id="b3203-1679">Public queue</span></span>|`MachineName`\\`QueueName`|  
|<span data-ttu-id="b3203-1680">专用队列</span><span class="sxs-lookup"><span data-stu-id="b3203-1680">Private queue</span></span>|`MachineName`\\`Private$`\\`QueueName`|  
|<span data-ttu-id="b3203-1681">日志队列</span><span class="sxs-lookup"><span data-stu-id="b3203-1681">Journal queue</span></span>|`MachineName`\\`QueueName`\\`Journal$`|  
|<span data-ttu-id="b3203-1682">计算机日志队列</span><span class="sxs-lookup"><span data-stu-id="b3203-1682">Machine journal queue</span></span>|`MachineName`\\`Journal$`|  
|<span data-ttu-id="b3203-1683">计算机死信队列</span><span class="sxs-lookup"><span data-stu-id="b3203-1683">Machine dead-letter queue</span></span>|`MachineName`\\`Deadletter$`|  
|<span data-ttu-id="b3203-1684">计算机事务性死信队列</span><span class="sxs-lookup"><span data-stu-id="b3203-1684">Machine transactional dead-letter queue</span></span>|`MachineName`\\`XactDeadletter$`|  
  
 <span data-ttu-id="b3203-1685">使用 "." 表示本地计算机。</span><span class="sxs-lookup"><span data-stu-id="b3203-1685">Use "." to represent the local computer.</span></span>  
  
 <span data-ttu-id="b3203-1686"><xref:System.Messaging.MessageQueue.MachineName%2A>、 <xref:System.Messaging.MessageQueue.Path%2A> 和 <xref:System.Messaging.MessageQueue.QueueName%2A> 属性是相关的。</span><span class="sxs-lookup"><span data-stu-id="b3203-1686">The <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, and <xref:System.Messaging.MessageQueue.QueueName%2A> properties are related.</span></span> <span data-ttu-id="b3203-1687">更改 <xref:System.Messaging.MessageQueue.MachineName%2A> 属性将导致 <xref:System.Messaging.MessageQueue.Path%2A> 属性发生更改。</span><span class="sxs-lookup"><span data-stu-id="b3203-1687">Changing the <xref:System.Messaging.MessageQueue.MachineName%2A> property causes the <xref:System.Messaging.MessageQueue.Path%2A> property to change.</span></span> <span data-ttu-id="b3203-1688">它从新的和生成 <xref:System.Messaging.MessageQueue.MachineName%2A> <xref:System.Messaging.MessageQueue.QueueName%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1688">It is built from the new <xref:System.Messaging.MessageQueue.MachineName%2A> and the <xref:System.Messaging.MessageQueue.QueueName%2A>.</span></span> <span data-ttu-id="b3203-1689">更改 <xref:System.Messaging.MessageQueue.Path%2A> (例如，若要使用格式名语法) 重置 <xref:System.Messaging.MessageQueue.MachineName%2A> 和 <xref:System.Messaging.MessageQueue.QueueName%2A> 属性以引用新队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1689">Changing the <xref:System.Messaging.MessageQueue.Path%2A> (for example, to use the format name syntax) resets the <xref:System.Messaging.MessageQueue.MachineName%2A> and <xref:System.Messaging.MessageQueue.QueueName%2A> properties to refer to the new queue.</span></span>  
  
 <span data-ttu-id="b3203-1690">或者，可以使用 <xref:System.Messaging.MessageQueue.FormatName%2A> 或 <xref:System.Messaging.MessageQueue.Label%2A> 来描述队列路径，如下表所示。</span><span class="sxs-lookup"><span data-stu-id="b3203-1690">Alternatively, you can use the <xref:System.Messaging.MessageQueue.FormatName%2A> or <xref:System.Messaging.MessageQueue.Label%2A> to describe the queue path, as shown in the following table.</span></span>  
  
|<span data-ttu-id="b3203-1691">参考</span><span class="sxs-lookup"><span data-stu-id="b3203-1691">Reference</span></span>|<span data-ttu-id="b3203-1692">语法</span><span class="sxs-lookup"><span data-stu-id="b3203-1692">Syntax</span></span>|<span data-ttu-id="b3203-1693">示例</span><span class="sxs-lookup"><span data-stu-id="b3203-1693">Example</span></span>|  
|---------------|------------|-------------|  
|<span data-ttu-id="b3203-1694">格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1694">Format name</span></span>|<span data-ttu-id="b3203-1695">`FormatName:` [ *格式名* ]</span><span class="sxs-lookup"><span data-stu-id="b3203-1695">`FormatName:` [ *format name* ]</span></span>|<span data-ttu-id="b3203-1696">`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112</span><span class="sxs-lookup"><span data-stu-id="b3203-1696">`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112</span></span>|  
|<span data-ttu-id="b3203-1697">Label</span><span class="sxs-lookup"><span data-stu-id="b3203-1697">Label</span></span>|<span data-ttu-id="b3203-1698">`Label:` [ *标签* ]</span><span class="sxs-lookup"><span data-stu-id="b3203-1698">`Label:` [ *label* ]</span></span>|<span data-ttu-id="b3203-1699">`Label:` TheLabel</span><span class="sxs-lookup"><span data-stu-id="b3203-1699">`Label:` TheLabel</span></span>|  
  
 <span data-ttu-id="b3203-1700">如果在 <xref:System.Messaging.MessageQueue.Path%2A> 发送消息时使用属性的标签语法，则如果不唯一，则会引发异常 <xref:System.Messaging.MessageQueue.Label%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1700">If you use the label syntax for the <xref:System.Messaging.MessageQueue.Path%2A> property when you send the message, an exception will be thrown if the <xref:System.Messaging.MessageQueue.Label%2A> is not unique.</span></span>  
  
 <span data-ttu-id="b3203-1701">若要脱机工作，必须使用格式名语法，而不是第一个表中的友好名称语法。</span><span class="sxs-lookup"><span data-stu-id="b3203-1701">To work offline, you must use the format name syntax, rather than the friendly name syntax in the first table.</span></span> <span data-ttu-id="b3203-1702">否则，会引发异常，因为 Active Directory 所在的主域控制器 () 不可用于解析格式名称的路径。</span><span class="sxs-lookup"><span data-stu-id="b3203-1702">Otherwise, an exception is thrown because the primary domain controller (on which Active Directory resides) is not available to resolve the path to the format name.</span></span>  
  
 <span data-ttu-id="b3203-1703">设置新路径将关闭消息队列并释放所有句柄。</span><span class="sxs-lookup"><span data-stu-id="b3203-1703">Setting a new path closes the message queue and releases all handles.</span></span>  
  
 <span data-ttu-id="b3203-1704">下表显示了此属性在各种工作组模式下是否可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1704">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1705">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1705">Workgroup mode</span></span>|<span data-ttu-id="b3203-1706">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1706">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1707">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1707">Local computer</span></span>|<span data-ttu-id="b3203-1708">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1708">Yes</span></span>|  
|<span data-ttu-id="b3203-1709">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1709">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1710">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1710">Yes</span></span>|  
|<span data-ttu-id="b3203-1711">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1711">Remote computer</span></span>|<span data-ttu-id="b3203-1712">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1712">Yes</span></span>|  
|<span data-ttu-id="b3203-1713">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1713">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1714">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1714">Yes</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="b3203-1715">在工作组模式下，只能使用专用队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1715">In workgroup mode you can only use private queues.</span></span> <span data-ttu-id="b3203-1716">使用专用队列语法指定该路径 `MachineName` \\ `Private$` \\ `QueueName` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1716">You specify the path using the private queue syntax `MachineName`\\`Private$`\\`QueueName`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1717">下面的代码示例 <xref:System.Messaging.MessageQueue> 使用各种路径名称语法类型创建新的对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-1717">The following code example creates new <xref:System.Messaging.MessageQueue> objects using various path name syntax types.</span></span> <span data-ttu-id="b3203-1718">在每种情况下，它会将消息发送到其路径在构造函数中定义的队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1718">In each case, it sends a message to the queue whose path is defined in the constructor.</span></span>  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-1719">路径无效，可能是因为语法无效。</span><span class="sxs-lookup"><span data-stu-id="b3203-1719">The path is not valid, possibly because the syntax is not valid.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Peek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe><span data-ttu-id="b3203-1720">方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="b3203-1720">The method is not thread safe.</span></span></threadsafe>
        <summary><span data-ttu-id="b3203-1721">返回队列中第一条消息的副本，而不从队列中移除该消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1721">Returns a copy of the first message in the queue without removing the message from the queue.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek();" />
      <MemberSignature Language="F#" Value="member this.Peek : unit -&gt; System.Messaging.Message" Usage="messageQueue.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b3203-1722">返回但不移除（查看）此 <see cref="T:System.Messaging.MessageQueue" /> 所引用的队列中的第一条消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1722">Returns without removing (peeks) the first message in the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />.</span></span> <span data-ttu-id="b3203-1723"><see cref="M:System.Messaging.MessageQueue.Peek" /> 方法是同步的，所以在有可用消息前，该方法阻塞当前线程。</span><span class="sxs-lookup"><span data-stu-id="b3203-1723">The <see cref="M:System.Messaging.MessageQueue.Peek" /> method is synchronous, so it blocks the current thread until a message becomes available.</span></span></summary>
        <returns><span data-ttu-id="b3203-1724">该 <see cref="T:System.Messaging.Message" /> 表示队列中第一条消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1724">The <see cref="T:System.Messaging.Message" /> that represents the first message in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1725">使用此重载可查看队列，或等待队列中存在消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1725">Use this overload to peek a queue, or to wait until a message exists in the queue.</span></span>  
  
 <span data-ttu-id="b3203-1726">此 <xref:System.Messaging.MessageQueue.Peek%2A> 方法从队列中读取并不删除第一条消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1726">The <xref:System.Messaging.MessageQueue.Peek%2A> method reads, but does not remove, the first message from the queue.</span></span> <span data-ttu-id="b3203-1727">因此，重复调用将 <xref:System.Messaging.MessageQueue.Peek%2A> 返回相同的消息，除非队列中有较高优先级的消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-1727">Therefore, repeated calls to <xref:System.Messaging.MessageQueue.Peek%2A> return the same message, unless a higher priority message arrives in the queue.</span></span> <span data-ttu-id="b3203-1728"><xref:System.Messaging.MessageQueue.Receive%2A>另一方面，方法会读取和删除队列中的第一条消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1728">The <xref:System.Messaging.MessageQueue.Receive%2A> method, on the other hand, both reads and removes the first message from the queue.</span></span> <span data-ttu-id="b3203-1729">因此，对的重复调用将 <xref:System.Messaging.MessageQueue.Receive%2A> 返回不同的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1729">Repeated calls to <xref:System.Messaging.MessageQueue.Receive%2A>, therefore, return different messages.</span></span>  
  
 <span data-ttu-id="b3203-1730">消息队列根据优先级和到达时间对队列中的消息进行排序。</span><span class="sxs-lookup"><span data-stu-id="b3203-1730">Message Queuing orders messages in the queue according to priority and arrival time.</span></span> <span data-ttu-id="b3203-1731">仅当较高优先级的消息超过较高优先级时，才会将其放在旧消息之前。</span><span class="sxs-lookup"><span data-stu-id="b3203-1731">A newer message is placed before an older one only if it is of a higher priority.</span></span>  
  
 <span data-ttu-id="b3203-1732">如果当前线程在等待消息到达队列时可以被阻塞，则使用 <xref:System.Messaging.MessageQueue.Peek%2A>。</span><span class="sxs-lookup"><span data-stu-id="b3203-1732">Use <xref:System.Messaging.MessageQueue.Peek%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</span></span> <span data-ttu-id="b3203-1733">由于此重载未指定超时，因此应用程序可能会无限期等待。</span><span class="sxs-lookup"><span data-stu-id="b3203-1733">Because this overload does not specify a time-out, the application might wait indefinitely.</span></span> <span data-ttu-id="b3203-1734">如果需要应用程序处理继续进行而不等待，则使用异步 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-1734">If you need the application processing to continue without waiting, use the asynchronous <xref:System.Messaging.MessageQueue.BeginPeek%2A> method.</span></span> <span data-ttu-id="b3203-1735">或者，您可以通过使用指定超时的的重载来指定消息到达队列的超时时间 <xref:System.Messaging.MessageQueue.Peek%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1735">Alternatively, you can specify a time-out for a message to arrive in the queue by using the overload of <xref:System.Messaging.MessageQueue.Peek%2A> that specifies a time-out.</span></span>  
  
 <span data-ttu-id="b3203-1736">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1736">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1737">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1737">Workgroup mode</span></span>|<span data-ttu-id="b3203-1738">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1738">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1739">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1739">Local computer</span></span>|<span data-ttu-id="b3203-1740">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1740">Yes</span></span>|  
|<span data-ttu-id="b3203-1741">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1741">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1742">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1742">Yes</span></span>|  
|<span data-ttu-id="b3203-1743">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1743">Remote computer</span></span>|<span data-ttu-id="b3203-1744">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1744">No</span></span>|  
|<span data-ttu-id="b3203-1745">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1745">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1746">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1746">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1747">下面的示例在队列中使用 <xref:System.Messaging.MessageQueue.Peek%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-1747">The following examples use the <xref:System.Messaging.MessageQueue.Peek%2A> method on a queue.</span></span>  
  
 <span data-ttu-id="b3203-1748">在第一个示例中，应用程序会等待，直到队列中有可用的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1748">In the first example, the application waits until a message becomes available in the queue.</span></span> <span data-ttu-id="b3203-1749">请注意，第一个示例不会访问到达的消息;它只是暂停处理直到消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-1749">Note that the first example does not access the message that arrives; it merely pauses processing until a message arrives.</span></span> <span data-ttu-id="b3203-1750">如果消息已在队列中存在，它将立即返回。</span><span class="sxs-lookup"><span data-stu-id="b3203-1750">If a message already exists in the queue, it will return immediately.</span></span>  
  
 <span data-ttu-id="b3203-1751">在第二个示例中，包含应用程序定义的类的消息将 `Order` 发送到队列，然后从队列中扫视。</span><span class="sxs-lookup"><span data-stu-id="b3203-1751">In the second example, a message that contains an application-defined `Order` class is sent to the queue, and then peeked from the queue.</span></span>  
  
 [!code-cpp[MessageQueue.Peek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-1752">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-1752">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="b3203-1753">方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="b3203-1753">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Peek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="b3203-1754">一个 <see cref="T:System.TimeSpan" /> 指示等待队列包含消息所用的最长时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-1754">A <see cref="T:System.TimeSpan" /> that indicates the maximum time to wait for the queue to contain a message.</span></span></param>
        <summary><span data-ttu-id="b3203-1755">返回但不移除（查看）此 <see cref="T:System.Messaging.MessageQueue" /> 所引用的队列中的第一条消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1755">Returns without removing (peeks) the first message in the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />.</span></span> <span data-ttu-id="b3203-1756"><see cref="M:System.Messaging.MessageQueue.Peek" /> 方法是同步的，因此在有可用消息或发生指定的超时之前，它一直阻止当前线程。</span><span class="sxs-lookup"><span data-stu-id="b3203-1756">The <see cref="M:System.Messaging.MessageQueue.Peek" /> method is synchronous, so it blocks the current thread until a message becomes available or the specified time-out occurs.</span></span></summary>
        <returns><span data-ttu-id="b3203-1757">该 <see cref="T:System.Messaging.Message" /> 表示队列中第一条消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1757">The <see cref="T:System.Messaging.Message" /> that represents the first message in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1758">使用此重载可查看队列，或在队列中存在消息之前等待指定的时间段。</span><span class="sxs-lookup"><span data-stu-id="b3203-1758">Use this overload to peek a queue, or to wait a specified period of time until a message exists in the queue.</span></span> <span data-ttu-id="b3203-1759">如果队列中已经存在消息，则该方法立即返回。</span><span class="sxs-lookup"><span data-stu-id="b3203-1759">The method returns immediately if a message already exists in the queue.</span></span>  
  
 <span data-ttu-id="b3203-1760">此 <xref:System.Messaging.MessageQueue.Peek%2A> 方法从队列中读取并不删除第一条消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1760">The <xref:System.Messaging.MessageQueue.Peek%2A> method reads, but does not remove, the first message from the queue.</span></span> <span data-ttu-id="b3203-1761">因此，重复调用将 <xref:System.Messaging.MessageQueue.Peek%2A> 返回相同的消息，除非队列中有较高优先级的消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-1761">Therefore, repeated calls to <xref:System.Messaging.MessageQueue.Peek%2A> return the same message, unless a higher priority message arrives in the queue.</span></span> <span data-ttu-id="b3203-1762"><xref:System.Messaging.MessageQueue.Receive%2A>另一方面，方法会读取和删除队列中的第一条消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1762">The <xref:System.Messaging.MessageQueue.Receive%2A> method, on the other hand, both reads and removes the first message from the queue.</span></span> <span data-ttu-id="b3203-1763">因此，对的重复调用将 <xref:System.Messaging.MessageQueue.Receive%2A> 返回不同的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1763">Repeated calls to <xref:System.Messaging.MessageQueue.Receive%2A>, therefore, return different messages.</span></span>  
  
 <span data-ttu-id="b3203-1764">消息队列根据优先级和到达时间对队列中的消息进行排序。</span><span class="sxs-lookup"><span data-stu-id="b3203-1764">Message Queuing orders messages in the queue according to priority and arrival time.</span></span> <span data-ttu-id="b3203-1765">仅当较高优先级的消息超过较高优先级时，才会将其放在旧消息之前。</span><span class="sxs-lookup"><span data-stu-id="b3203-1765">A newer message is placed before an older one only if it is of a higher priority.</span></span>  
  
 <span data-ttu-id="b3203-1766">如果当前线程在等待消息到达队列时可以被阻塞，则使用 <xref:System.Messaging.MessageQueue.Peek%2A>。</span><span class="sxs-lookup"><span data-stu-id="b3203-1766">Use <xref:System.Messaging.MessageQueue.Peek%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</span></span> <span data-ttu-id="b3203-1767">线程将被阻塞一段指定的时间，或在你指示的情况下无限期阻塞 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1767">The thread will be blocked up to the specified period of time, or indefinitely if you indicated <xref:System.Messaging.MessageQueue.InfiniteTimeout>.</span></span> <span data-ttu-id="b3203-1768">如果需要应用程序处理继续进行而不等待，则使用异步 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-1768">If you need the application processing to continue without waiting, use the asynchronous <xref:System.Messaging.MessageQueue.BeginPeek%2A> method.</span></span>  
  
 <span data-ttu-id="b3203-1769">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1769">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1770">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1770">Workgroup mode</span></span>|<span data-ttu-id="b3203-1771">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1771">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1772">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1772">Local computer</span></span>|<span data-ttu-id="b3203-1773">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1773">Yes</span></span>|  
|<span data-ttu-id="b3203-1774">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1774">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1775">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1775">Yes</span></span>|  
|<span data-ttu-id="b3203-1776">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1776">Remote computer</span></span>|<span data-ttu-id="b3203-1777">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1777">No</span></span>|  
|<span data-ttu-id="b3203-1778">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1778">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1779">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1779">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1780">下面的代码示例使用超时 <xref:System.Messaging.MessageQueue.Peek%2A> 值为零的方法来检查队列是否为空。</span><span class="sxs-lookup"><span data-stu-id="b3203-1780">The following code example uses the <xref:System.Messaging.MessageQueue.Peek%2A> method with a time-out of zero to check whether the queue is empty.</span></span>  
  
 [!code-cpp[MessageQueue.Peek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-1781">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1781">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-1782">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-1782">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="b3203-1783">方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="b3203-1783">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan, cursor As Cursor, action As PeekAction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction -&gt; System.Messaging.Message" Usage="messageQueue.Peek (timeout, cursor, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="b3203-1784">一个 <see cref="T:System.TimeSpan" /> 指示等待队列包含消息所用的最长时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-1784">A <see cref="T:System.TimeSpan" /> that indicates the maximum time to wait for the queue to contain a message.</span></span></param>
        <param name="cursor"><span data-ttu-id="b3203-1785">维持消息队列中特定位置的 <see cref="T:System.Messaging.Cursor" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1785">A <see cref="T:System.Messaging.Cursor" /> that maintains a specific position in the message queue.</span></span></param>
        <param name="action"><span data-ttu-id="b3203-1786"><see cref="T:System.Messaging.PeekAction" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="b3203-1786">One of the <see cref="T:System.Messaging.PeekAction" /> values.</span></span> <span data-ttu-id="b3203-1787">指示是查看队列中的当前消息还是下一条消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1787">Indicates whether to peek at the current message in the queue, or the next message.</span></span></param>
        <summary><span data-ttu-id="b3203-1788">使用指定的游标返回但不移除（查看）队列中的当前消息或下一条消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1788">Returns without removing (peeks) the current or next message in the queue, using the specified cursor.</span></span> <span data-ttu-id="b3203-1789"><see cref="M:System.Messaging.MessageQueue.Peek" /> 方法是同步的，因此在有可用消息或发生指定的超时之前，它一直阻止当前线程。</span><span class="sxs-lookup"><span data-stu-id="b3203-1789">The <see cref="M:System.Messaging.MessageQueue.Peek" /> method is synchronous, so it blocks the current thread until a message becomes available or the specified time-out occurs.</span></span></summary>
        <returns><span data-ttu-id="b3203-1790">一个 <see cref="T:System.Messaging.Message" />，表示队列中的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1790">A <see cref="T:System.Messaging.Message" /> that represents a message in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1791">使用此重载可查看队列，或在队列中存在消息之前等待指定的时间段。</span><span class="sxs-lookup"><span data-stu-id="b3203-1791">Use this overload to peek a queue, or to wait a specified period of time until a message exists in the queue.</span></span> <span data-ttu-id="b3203-1792">如果队列中已经存在消息，则该方法立即返回。</span><span class="sxs-lookup"><span data-stu-id="b3203-1792">The method returns immediately if a message already exists in the queue.</span></span>  
  
 <span data-ttu-id="b3203-1793">此 <xref:System.Messaging.MessageQueue.Peek%2A> 方法从队列中读取消息，但不从队列中移除消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1793">The <xref:System.Messaging.MessageQueue.Peek%2A> method reads, but does not remove, a message from the queue.</span></span> <span data-ttu-id="b3203-1794"><xref:System.Messaging.MessageQueue.Receive%2A>另一方面，方法会读取和删除队列中的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1794">The <xref:System.Messaging.MessageQueue.Receive%2A> method, on the other hand, both reads and removes a message from the queue.</span></span>  
  
 <span data-ttu-id="b3203-1795">如果当前线程在等待消息到达队列时可以被阻塞，则使用 <xref:System.Messaging.MessageQueue.Peek%2A>。</span><span class="sxs-lookup"><span data-stu-id="b3203-1795">Use <xref:System.Messaging.MessageQueue.Peek%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</span></span> <span data-ttu-id="b3203-1796">在指定的时间段内阻塞线程，或在指示的情况下无限期阻塞 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1796">The thread is blocked up to the specified period of time, or indefinitely if you indicated <xref:System.Messaging.MessageQueue.InfiniteTimeout>.</span></span> <span data-ttu-id="b3203-1797">如果需要应用程序处理继续进行而不等待，则使用异步 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-1797">If you need the application processing to continue without waiting, use the asynchronous <xref:System.Messaging.MessageQueue.BeginPeek%2A> method.</span></span>  
  
 <span data-ttu-id="b3203-1798">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1798">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1799">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1799">Workgroup mode</span></span>|<span data-ttu-id="b3203-1800">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1800">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1801">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1801">Local computer</span></span>|<span data-ttu-id="b3203-1802">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1802">Yes</span></span>|  
|<span data-ttu-id="b3203-1803">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1803">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1804">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1804">Yes</span></span>|  
|<span data-ttu-id="b3203-1805">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1805">Remote computer</span></span>|<span data-ttu-id="b3203-1806">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1806">No</span></span>|  
|<span data-ttu-id="b3203-1807">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1807">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1808">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1808">Yes</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b3203-1809">为 <paramref name="action" /> 参数指定的值不是 <see langword="PeekAction.Current" /> 和 <see langword="PeekAction.Next" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1809">A value other than <see langword="PeekAction.Current" /> or <see langword="PeekAction.Next" /> was specified for the <paramref name="action" /> parameter.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3203-1810"><paramref name="cursor" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1810">The <paramref name="cursor" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-1811">为 <paramref name="timeout" /> 参数指定的值无效。</span><span class="sxs-lookup"><span data-stu-id="b3203-1811">The value specified for the <paramref name="timeout" /> parameter is not valid.</span></span> <span data-ttu-id="b3203-1812"><paramref name="timeout" /> 可能小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1812">Possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-1813">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-1813">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="b3203-1814">方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="b3203-1814">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.PeekAction" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b3203-1815">查看匹配给定相关标识符的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1815">Peeks a message that matches a given correlation identifier.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId"><span data-ttu-id="b3203-1816">要查看的消息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1816">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to peek.</span></span></param>
        <summary><span data-ttu-id="b3203-1817">查看匹配给定相关标识符的消息，而且在队列中当前不存在具有指定相关标识符的消息时，立即引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-1817">Peeks the message that matches the given correlation identifier and immediately raises an exception if no message with the specified correlation identifier currently exists in the queue.</span></span></summary>
        <returns><span data-ttu-id="b3203-1818">其 <see cref="T:System.Messaging.Message" /> 匹配传入的 <paramref name="correlationId" /> 参数的 <see cref="P:System.Messaging.Message.CorrelationId" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1818">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1819">此方法在引用的队列中查找 <xref:System.Messaging.MessageQueue> <xref:System.Messaging.Message.CorrelationId%2A> 与指定参数匹配的消息 `correlationId` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1819">This method looks in the queue referenced by the <xref:System.Messaging.MessageQueue> for a message whose <xref:System.Messaging.Message.CorrelationId%2A> matches the specified `correlationId` parameter.</span></span> <span data-ttu-id="b3203-1820">如果未找到与参数匹配的消息 `correlationID` ，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-1820">If no message is found that matches the `correlationID` parameter, an exception is thrown.</span></span>  
  
 <span data-ttu-id="b3203-1821"><xref:System.Messaging.Message.CorrelationId%2A>属性用于将发送到队列的消息绑定到关联的响应、报告或确认消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1821">The <xref:System.Messaging.Message.CorrelationId%2A> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.</span></span>  
  
 <span data-ttu-id="b3203-1822">另外两种方法允许您查看队列中的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1822">Two other methods allow you to peek messages in a queue.</span></span> <span data-ttu-id="b3203-1823"><xref:System.Messaging.MessageQueue.Peek%2A>方法返回队列中的第一条消息，该 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 方法用于通过指定消息的唯一标识符来检索消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1823">The <xref:System.Messaging.MessageQueue.Peek%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method is used to retrieve a message by specifying its unique identifier.</span></span>  
  
 <span data-ttu-id="b3203-1824">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1824">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1825">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1825">Workgroup mode</span></span>|<span data-ttu-id="b3203-1826">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1826">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1827">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1827">Local computer</span></span>|<span data-ttu-id="b3203-1828">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1828">Yes</span></span>|  
|<span data-ttu-id="b3203-1829">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1829">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1830">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1830">Yes</span></span>|  
|<span data-ttu-id="b3203-1831">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1831">Remote computer</span></span>|<span data-ttu-id="b3203-1832">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1832">No</span></span>|  
|<span data-ttu-id="b3203-1833">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1833">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1834">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1834">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1835">下面的代码示例在队列中发送和接收包含订单的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1835">The following code example sends and receives a message that contains an order to and from a queue.</span></span> <span data-ttu-id="b3203-1836">当原始消息到达或从队列中检索时，它专门请求肯定确认。</span><span class="sxs-lookup"><span data-stu-id="b3203-1836">It specifically requests a positive acknowledgment when the original message reaches or is retrieved from the queue.</span></span>  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3203-1837"><paramref name="correlationId" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1837">The <paramref name="correlationId" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b3203-1838">未能找到具有指定 <paramref name="correlationId" /> 的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1838">The message with the specified <paramref name="correlationId" /> could not be found.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-1839">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-1839">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId"><span data-ttu-id="b3203-1840">要查看的消息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1840">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to peek.</span></span></param>
        <param name="timeout"><span data-ttu-id="b3203-1841">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-1841">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</span></span></param>
        <summary><span data-ttu-id="b3203-1842">查看匹配给定相关标识符的消息，并且一直等到队列中出现具有指定相关标识符的消息或超时过期时。</span><span class="sxs-lookup"><span data-stu-id="b3203-1842">Peeks the message that matches the given correlation identifier and waits until either a message with the specified correlation identifier is available in the queue, or the time-out expires.</span></span></summary>
        <returns><span data-ttu-id="b3203-1843">其 <see cref="T:System.Messaging.Message" /> 匹配传入的 <paramref name="correlationId" /> 参数的 <see cref="P:System.Messaging.Message.CorrelationId" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1843">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1844">此方法在引用的队列中查找 <xref:System.Messaging.MessageQueue> <xref:System.Messaging.Message.CorrelationId%2A> 与指定参数匹配的消息 `correlationId` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1844">This method looks in the queue referenced by the <xref:System.Messaging.MessageQueue> for a message whose <xref:System.Messaging.Message.CorrelationId%2A> matches the specified `correlationId` parameter.</span></span> <span data-ttu-id="b3203-1845">如果未找到与参数匹配的消息 `correlationID` ，并且在参数指定的时间段内，队列中没有新消息到达 `timeout` ，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-1845">If no message is found that matches the `correlationID` parameter, and no new message arrives in the queue within the period specified by the `timeout` parameter, an exception is thrown.</span></span>  
  
 <span data-ttu-id="b3203-1846">`timeout`参数未指定此方法的总运行时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-1846">The `timeout` parameter does not specify the total running time for this method.</span></span> <span data-ttu-id="b3203-1847">相反，它指定等待新消息到达队列的时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-1847">Rather, it specifies the time to wait for a new message to arrive in the queue.</span></span> <span data-ttu-id="b3203-1848">每当新消息到达时，此方法将检查 <xref:System.Messaging.Message.CorrelationId%2A> 新消息的，以查看它是否与参数匹配 `correlationId` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1848">Each time a new message arrives, this method examines the <xref:System.Messaging.Message.CorrelationId%2A> of the new message to see if it matches the `correlationId` parameter.</span></span> <span data-ttu-id="b3203-1849">否则，此方法将启动超时期限并等待另一个新消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-1849">If not, this method starts the time-out period over and waits for another new message to arrive.</span></span> <span data-ttu-id="b3203-1850">因此，如果新消息在超时期限内继续到达，则此方法可能会无限期地继续运行，直到超时期限过期，无需收到任何新消息，或直到到达其 <xref:System.Messaging.Message.CorrelationId%2A> 与参数匹配的消息 `correlationId` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1850">Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <xref:System.Messaging.Message.CorrelationId%2A> matches the `correlationId` parameter.</span></span>  
  
 <span data-ttu-id="b3203-1851"><xref:System.Messaging.Message.CorrelationId%2A>属性用于将发送到队列的消息绑定到关联的响应、报告或确认消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1851">The <xref:System.Messaging.Message.CorrelationId%2A> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.</span></span>  
  
 <span data-ttu-id="b3203-1852">另外两种方法允许您查看队列中的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1852">Two other methods allow you to peek messages in a queue.</span></span> <span data-ttu-id="b3203-1853"><xref:System.Messaging.MessageQueue.Peek%2A>方法返回队列中的第一条消息，该 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 方法用于通过指定消息的唯一标识符来检索消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1853">The <xref:System.Messaging.MessageQueue.Peek%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method is used to retrieve a message by specifying its unique identifier.</span></span>  
  
 <span data-ttu-id="b3203-1854">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1854">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1855">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1855">Workgroup mode</span></span>|<span data-ttu-id="b3203-1856">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1856">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1857">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1857">Local computer</span></span>|<span data-ttu-id="b3203-1858">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1858">Yes</span></span>|  
|<span data-ttu-id="b3203-1859">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1859">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1860">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1860">Yes</span></span>|  
|<span data-ttu-id="b3203-1861">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1861">Remote computer</span></span>|<span data-ttu-id="b3203-1862">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1862">No</span></span>|  
|<span data-ttu-id="b3203-1863">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1863">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1864">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1864">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1865">以下代码示例演示了 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29> 的用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-1865">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3203-1866"><paramref name="correlationId" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1866">The <paramref name="correlationId" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-1867">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1867">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b3203-1868">具有指定 <paramref name="correlationId" /> 的消息不在队列中，而且在超时过期之前没有到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-1868">The message with the specified <paramref name="correlationId" /> does not exist in the queue and did not arrive before the time-out expired.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-1869">消息在超时过期前没有到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-1869">A message did not arrive before the time-out expired.</span></span>  
  
 <span data-ttu-id="b3203-1870">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-1870">-or-</span></span>  
  
 <span data-ttu-id="b3203-1871">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-1871">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b3203-1872">返回具有指定消息标识符的消息的副本，但不从队列中移除消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1872">Returns a copy of the message that has the specified message identifier without removing the message from the queue.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id"><span data-ttu-id="b3203-1873">要查看的消息的 <see cref="P:System.Messaging.Message.Id" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1873">The <see cref="P:System.Messaging.Message.Id" /> of the message to peek.</span></span></param>
        <summary><span data-ttu-id="b3203-1874">查看其消息标识符匹配 <paramref name="id" /> 参数的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1874">Peeks the message whose message identifier matches the <paramref name="id" /> parameter.</span></span></summary>
        <returns><span data-ttu-id="b3203-1875"><see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.Id" /> 属性匹配 <paramref name="id" /> 参数。</span><span class="sxs-lookup"><span data-stu-id="b3203-1875">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1876">使用 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 读取，而不从队列中移除，即具有已知消息标识符的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1876">Use <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> to read, without removing from the queue, a message that has a known message identifier.</span></span> <span data-ttu-id="b3203-1877">消息标识符在消息队列企业中是唯一的，因此队列中最多只能有一条消息与给定 `id` 参数匹配。</span><span class="sxs-lookup"><span data-stu-id="b3203-1877">The identifier of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given `id` parameter.</span></span> <span data-ttu-id="b3203-1878">如果队列当前不包含消息，此重载将引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-1878">This overload throws an exception if the queue does not currently contain the message.</span></span>  
  
 <span data-ttu-id="b3203-1879">另外两种方法允许您查看队列中的消息： <xref:System.Messaging.MessageQueue.Peek%2A> 和 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1879">Two additional methods allow you to peek messages in a queue: <xref:System.Messaging.MessageQueue.Peek%2A> and <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>.</span></span> <span data-ttu-id="b3203-1880"><xref:System.Messaging.MessageQueue.Peek%2A>方法返回队列中的第一条消息; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 返回作为消息发送到队列的结果而创建的确认、报告或由应用程序生成的响应消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1880">The <xref:System.Messaging.MessageQueue.Peek%2A> method returns the first message in the queue; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> returns an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.</span></span>  
  
 <span data-ttu-id="b3203-1881">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1881">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1882">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1882">Workgroup mode</span></span>|<span data-ttu-id="b3203-1883">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1883">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1884">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1884">Local computer</span></span>|<span data-ttu-id="b3203-1885">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1885">Yes</span></span>|  
|<span data-ttu-id="b3203-1886">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1886">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1887">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1887">Yes</span></span>|  
|<span data-ttu-id="b3203-1888">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1888">Remote computer</span></span>|<span data-ttu-id="b3203-1889">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1889">No</span></span>|  
|<span data-ttu-id="b3203-1890">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1890">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1891">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1891">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1892">以下代码示例演示了 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 的用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-1892">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3203-1893"><paramref name="id" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1893">The <paramref name="id" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b3203-1894">不存在具有指定 <paramref name="id" /> 的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1894">No message with the specified <paramref name="id" /> exists.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-1895">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-1895">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id"><span data-ttu-id="b3203-1896">要查看的消息的 <see cref="P:System.Messaging.Message.Id" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1896">The <see cref="P:System.Messaging.Message.Id" /> of the message to peek.</span></span></param>
        <param name="timeout"><span data-ttu-id="b3203-1897">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-1897">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</span></span></param>
        <summary><span data-ttu-id="b3203-1898">查看其消息标识符匹配 <paramref name="id" /> 参数的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1898">Peeks the message whose message identifier matches the <paramref name="id" /> parameter.</span></span> <span data-ttu-id="b3203-1899">一直等到队列中出现该消息或发生超时。</span><span class="sxs-lookup"><span data-stu-id="b3203-1899">Waits until the message appears in the queue or a time-out occurs.</span></span></summary>
        <returns><span data-ttu-id="b3203-1900"><see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.Id" /> 属性匹配 <paramref name="id" /> 参数。</span><span class="sxs-lookup"><span data-stu-id="b3203-1900">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1901">使用 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 读取，而不从队列中移除，即具有已知消息标识符的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1901">Use <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> to read, without removing from the queue, a message that has a known message identifier.</span></span> <span data-ttu-id="b3203-1902">消息标识符在消息队列企业中是唯一的，因此队列中最多只能有一条消息与给定 `id` 参数匹配。</span><span class="sxs-lookup"><span data-stu-id="b3203-1902">The identifier of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given `id` parameter.</span></span> <span data-ttu-id="b3203-1903">如果队列当前不包含该消息，并且在发生超时之前没有新消息到达，此重载将引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-1903">This overload throws an exception if the queue does not currently contain the message and a new message does not arrive before the time-out occurs.</span></span>  
  
 <span data-ttu-id="b3203-1904">`timeout`参数未指定此方法的总运行时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-1904">The `timeout` parameter does not specify the total running time for this method.</span></span> <span data-ttu-id="b3203-1905">相反，它指定等待新消息到达队列的时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-1905">Rather, it specifies the time to wait for a new message to arrive in the queue.</span></span> <span data-ttu-id="b3203-1906">每当新消息到达时，此方法将检查 <xref:System.Messaging.Message.Id%2A> 新消息的，以查看它是否与参数匹配 `id` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1906">Each time a new message arrives, this method examines the <xref:System.Messaging.Message.Id%2A> of the new message to see if it matches the `id` parameter.</span></span> <span data-ttu-id="b3203-1907">否则，此方法将启动超时期限并等待另一个新消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-1907">If not, this method starts the time-out period over and waits for another new message to arrive.</span></span> <span data-ttu-id="b3203-1908">因此，如果新消息在超时期限内继续到达，则此方法可能会无限期地继续运行，直到超时期限过期，无需收到任何新消息，或直到到达其 <xref:System.Messaging.Message.Id%2A> 与参数匹配的消息 `id` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1908">Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <xref:System.Messaging.Message.Id%2A> matches the `id` parameter.</span></span>  
  
 <span data-ttu-id="b3203-1909">另外两种方法允许您查看队列中的消息： <xref:System.Messaging.MessageQueue.Peek%2A> 和 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1909">Two additional methods allow you to peek messages in a queue: <xref:System.Messaging.MessageQueue.Peek%2A> and <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>.</span></span> <span data-ttu-id="b3203-1910"><xref:System.Messaging.MessageQueue.Peek%2A>方法返回队列中的第一条消息; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 返回作为消息发送到队列的结果而创建的确认、报告或由应用程序生成的响应消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1910">The <xref:System.Messaging.MessageQueue.Peek%2A> method returns the first message in the queue; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> returns an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.</span></span>  
  
 <span data-ttu-id="b3203-1911">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1911">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1912">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1912">Workgroup mode</span></span>|<span data-ttu-id="b3203-1913">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1913">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1914">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1914">Local computer</span></span>|<span data-ttu-id="b3203-1915">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1915">Yes</span></span>|  
|<span data-ttu-id="b3203-1916">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1916">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1917">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1917">Yes</span></span>|  
|<span data-ttu-id="b3203-1918">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1918">Remote computer</span></span>|<span data-ttu-id="b3203-1919">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1919">No</span></span>|  
|<span data-ttu-id="b3203-1920">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1920">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1921">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1921">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1922">以下代码示例演示了 <xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29> 的用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-1922">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3203-1923"><paramref name="id" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1923">The <paramref name="id" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-1924">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1924">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b3203-1925">队列中不存在具有指定 <paramref name="id" /> 的消息，并且在 <paramref name="timeout" /> 参数指定的时间段过期之前该消息仍未到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-1925">The message with the specified <paramref name="id" /> does not exist in the queue and did not arrive before the period specified by the <paramref name="timeout" /> parameter expired.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-1926">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-1926">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b3203-1927">在 MSMQ 3.0 中引入。</span><span class="sxs-lookup"><span data-stu-id="b3203-1927">Introduced in MSMQ 3.0.</span></span> <span data-ttu-id="b3203-1928">查看队列中特定的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1928">Peeks at a specific message from the queue.</span></span> <span data-ttu-id="b3203-1929">消息可通过查询标识符来指定，也可以通过其相对于队首或队尾的位置来指定。</span><span class="sxs-lookup"><span data-stu-id="b3203-1929">The message can be specified by a lookup identifier or by its position at the front or end of the queue.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="lookupId"><span data-ttu-id="b3203-1930">要查看的消息的 <see cref="P:System.Messaging.Message.LookupId" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1930">The <see cref="P:System.Messaging.Message.LookupId" /> of the message to peek at.</span></span></param>
        <summary><span data-ttu-id="b3203-1931">在 MSMQ 3.0 中引入。</span><span class="sxs-lookup"><span data-stu-id="b3203-1931">Introduced in MSMQ 3.0.</span></span> <span data-ttu-id="b3203-1932">从非事务性队列中查看与给定查找标识符匹配的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1932">Peeks at the message that matches the given lookup identifier from a non-transactional queue.</span></span></summary>
        <returns><span data-ttu-id="b3203-1933"><see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.LookupId" /> 属性匹配传入的 <paramref name="lookupId" /> 参数。</span><span class="sxs-lookup"><span data-stu-id="b3203-1933">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.LookupId" /> property matches the <paramref name="lookupId" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1934">使用此方法可以读取具有已知查找标识符的消息，而无需将其从队列中删除。</span><span class="sxs-lookup"><span data-stu-id="b3203-1934">Use this method to read a message with a known lookup identifier without removing it from the queue.</span></span> <span data-ttu-id="b3203-1935">如果消息不在队列中，此方法会立即引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-1935">This method throws an exception immediately if the message is not in the queue.</span></span>  
  
 <span data-ttu-id="b3203-1936"><xref:System.Messaging.Message.LookupId%2A>消息的属性在消息所在的队列中是唯一的，因此队列中最多存在一个与给定参数匹配的消息 `lookupId` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1936">The <xref:System.Messaging.Message.LookupId%2A> property of a message is unique to the queue where the message resides, so there will be at most one message in the queue that matches the given `lookupId` parameter.</span></span>  
  
 <span data-ttu-id="b3203-1937">若要读取具有指定查找标识符的消息并将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-1937">To read a message with a specified lookup identifier and remove it from the queue, use the <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> method.</span></span>  
  
 <span data-ttu-id="b3203-1938">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1938">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1939">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1939">Workgroup mode</span></span>|<span data-ttu-id="b3203-1940">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1940">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1941">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1941">Local computer</span></span>|<span data-ttu-id="b3203-1942">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1942">Yes</span></span>|  
|<span data-ttu-id="b3203-1943">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1943">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1944">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1944">Yes</span></span>|  
|<span data-ttu-id="b3203-1945">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1945">Remote computer</span></span>|<span data-ttu-id="b3203-1946">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1946">No</span></span>|  
|<span data-ttu-id="b3203-1947">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1947">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1948">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1948">Yes</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="b3203-1949">未安装 MSMQ 3.0。</span><span class="sxs-lookup"><span data-stu-id="b3203-1949">MSMQ 3.0 is not installed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b3203-1950">未能找到具有指定 <paramref name="lookupId" /> 的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1950">The message with the specified <paramref name="lookupId" /> could not be found.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-1951">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-1951">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (action As MessageLookupAction, lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(System::Messaging::MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : System.Messaging.MessageLookupAction * int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId (action, lookupId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="lookupId" Type="System.Int64" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="b3203-1952">一个 <see cref="T:System.Messaging.MessageLookupAction" /> 值，指定读取队列中消息的方式。</span><span class="sxs-lookup"><span data-stu-id="b3203-1952">One of the <see cref="T:System.Messaging.MessageLookupAction" /> values, specifying how the message is read in the queue.</span></span> <span data-ttu-id="b3203-1953">指定以下值之一：</span><span class="sxs-lookup"><span data-stu-id="b3203-1953">Specify one of the following:</span></span> 
 <span data-ttu-id="b3203-1954"><see langword="MessageLookupAction.Current" />：查看由 <paramref name="lookupId" /> 指定的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1954"><see langword="MessageLookupAction.Current" />: Peeks at the message specified by <paramref name="lookupId" />.</span></span>  
  
 <span data-ttu-id="b3203-1955"><see langword="MessageLookupAction.Next" />：查看由 <paramref name="lookupId" /> 指定的消息的下一条消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1955"><see langword="MessageLookupAction.Next" />: Peeks at the message following the message specified by <paramref name="lookupId" />.</span></span>  
  
 <span data-ttu-id="b3203-1956"><see langword="MessageLookupAction.Previous" />：查看由 <paramref name="lookupId" /> 指定的消息的前一条消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1956"><see langword="MessageLookupAction.Previous" />: Peeks at the message preceding the message specified by <paramref name="lookupId" />.</span></span>  
  
 <span data-ttu-id="b3203-1957"><see langword="MessageLookupAction.First" />：查看队列中的第一条消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1957"><see langword="MessageLookupAction.First" />: Peeks at the first message in the queue.</span></span> <span data-ttu-id="b3203-1958"><paramref name="lookupId" /> 参数必须设置为 0。</span><span class="sxs-lookup"><span data-stu-id="b3203-1958">The <paramref name="lookupId" /> parameter must be set to 0.</span></span>  
  
 <span data-ttu-id="b3203-1959"><see langword="MessageLookupAction.Last" />：查看队列中的最后一条消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1959"><see langword="MessageLookupAction.Last" />: Peeks at the last message in the queue.</span></span> <span data-ttu-id="b3203-1960"><paramref name="lookupId" /> 参数必须设置为 0。</span><span class="sxs-lookup"><span data-stu-id="b3203-1960">The <paramref name="lookupId" /> parameter must be set to 0.</span></span></param>
        <param name="lookupId"><span data-ttu-id="b3203-1961">要查看的消息的 <see cref="P:System.Messaging.Message.LookupId" /> 或者为 0。</span><span class="sxs-lookup"><span data-stu-id="b3203-1961">The <see cref="P:System.Messaging.Message.LookupId" /> of the message to peek at, or 0.</span></span> <span data-ttu-id="b3203-1962">访问队列中的第一条和最后一条消息时使用 0。</span><span class="sxs-lookup"><span data-stu-id="b3203-1962">0 is used when accessing the first or last message in the queue.</span></span></param>
        <summary><span data-ttu-id="b3203-1963">在 MSMQ 3.0 中引入。</span><span class="sxs-lookup"><span data-stu-id="b3203-1963">Introduced in MSMQ 3.0.</span></span> <span data-ttu-id="b3203-1964">查看队列中特定的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1964">Peeks at a specific message from the queue.</span></span> <span data-ttu-id="b3203-1965">消息可通过查询标识符来指定，也可以通过其相对于队首或队尾的位置来指定。</span><span class="sxs-lookup"><span data-stu-id="b3203-1965">The message can be specified by a lookup identifier or by its position at the front or end of the queue.</span></span></summary>
        <returns><span data-ttu-id="b3203-1966">由传入的 <paramref name="action" /> 和 <paramref name="lookupId" /> 参数指定的 <see cref="T:System.Messaging.Message" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-1966">The <see cref="T:System.Messaging.Message" /> specified by the <paramref name="action" /> and <paramref name="lookupId" /> parameters passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1967">使用此方法可以读取具有已知查找标识符的消息，而无需将其从队列中删除。</span><span class="sxs-lookup"><span data-stu-id="b3203-1967">Use this method to read a message with a known lookup identifier without removing it from the queue.</span></span> <span data-ttu-id="b3203-1968">如果消息不在队列中，此方法会立即引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-1968">This method throws an exception immediately if the message is not in the queue.</span></span>  
  
 <span data-ttu-id="b3203-1969"><xref:System.Messaging.Message.LookupId%2A>消息的属性在消息所在的队列中是唯一的，因此队列中最多存在一个与给定参数匹配的消息 `lookupId` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1969">The <xref:System.Messaging.Message.LookupId%2A> property of a message is unique to the queue where the message resides, so there will be at most one message in the queue that matches the given `lookupId` parameter.</span></span>  
  
 <span data-ttu-id="b3203-1970">若要读取具有指定标识符的消息并将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-1970">To read a message with a specified identifier and remove it from the queue, use the <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> method.</span></span>  
  
 <span data-ttu-id="b3203-1971">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-1971">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-1972">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-1972">Workgroup mode</span></span>|<span data-ttu-id="b3203-1973">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-1973">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-1974">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1974">Local computer</span></span>|<span data-ttu-id="b3203-1975">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1975">Yes</span></span>|  
|<span data-ttu-id="b3203-1976">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1976">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-1977">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1977">Yes</span></span>|  
|<span data-ttu-id="b3203-1978">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-1978">Remote computer</span></span>|<span data-ttu-id="b3203-1979">否</span><span class="sxs-lookup"><span data-stu-id="b3203-1979">No</span></span>|  
|<span data-ttu-id="b3203-1980">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-1980">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-1981">是</span><span class="sxs-lookup"><span data-stu-id="b3203-1981">Yes</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="b3203-1982">未安装 MSMQ 3.0。</span><span class="sxs-lookup"><span data-stu-id="b3203-1982">MSMQ 3.0 is not installed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b3203-1983">未能找到具有指定 <paramref name="lookupId" /> 的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1983">The message with the specified <paramref name="lookupId" /> could not be found.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-1984">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-1984">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="b3203-1985"><paramref name="action" /> 参数不是 <see cref="T:System.Messaging.MessageLookupAction" /> 成员之一。</span><span class="sxs-lookup"><span data-stu-id="b3203-1985">The <paramref name="action" /> parameter is not one of the <see cref="T:System.Messaging.MessageLookupAction" /> members.</span></span></exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PeekCompleted As PeekCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::PeekCompletedEventHandler ^ PeekCompleted;" />
      <MemberSignature Language="F#" Value="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " Usage="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_PeekCompleted")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_PeekCompleted")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-1986">在消息未从队列移除的情况下读取该消息时发生。</span><span class="sxs-lookup"><span data-stu-id="b3203-1986">Occurs when a message is read without being removed from the queue.</span></span> <span data-ttu-id="b3203-1987">这是异步操作 <see cref="M:System.Messaging.MessageQueue.BeginPeek" /> 的结果。</span><span class="sxs-lookup"><span data-stu-id="b3203-1987">This is a result of the asynchronous operation, <see cref="M:System.Messaging.MessageQueue.BeginPeek" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1988"><xref:System.Messaging.MessageQueue.BeginPeek%2A> 当队列中有消息时，将在异步处理过程中用于引发 <xref:System.Messaging.MessageQueue.PeekCompleted> 事件。</span><span class="sxs-lookup"><span data-stu-id="b3203-1988"><xref:System.Messaging.MessageQueue.BeginPeek%2A> is used in asynchronous processing to raise the <xref:System.Messaging.MessageQueue.PeekCompleted> event when a message is available in the queue.</span></span>  
  
 <span data-ttu-id="b3203-1989"><xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 用于完成通过调用启动的操作 <xref:System.Messaging.MessageQueue.BeginPeek%2A> ，并在引发事件时查看消息 <xref:System.Messaging.MessageQueue.PeekCompleted> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-1989"><xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> is used to complete the operation initiated by a call to <xref:System.Messaging.MessageQueue.BeginPeek%2A> and peek the message when the <xref:System.Messaging.MessageQueue.PeekCompleted> event is raised.</span></span>  
  
 <span data-ttu-id="b3203-1990">创建 <xref:System.Messaging.PeekCompletedEventHandler> 委托时，需要标识将处理该事件的方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-1990">When you create a <xref:System.Messaging.PeekCompletedEventHandler> delegate, you identify the method that will handle the event.</span></span> <span data-ttu-id="b3203-1991">若要将事件与事件处理程序关联，请将该委托的一个实例添加到事件中。</span><span class="sxs-lookup"><span data-stu-id="b3203-1991">To associate the event with your event handler, add an instance of the delegate to the event.</span></span> <span data-ttu-id="b3203-1992">除非移除了该委托，否则每当发生该事件时就会调用事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="b3203-1992">The event handler is called whenever the event occurs, unless you remove the delegate.</span></span> <span data-ttu-id="b3203-1993">有关事件处理程序委托的详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。</span><span class="sxs-lookup"><span data-stu-id="b3203-1993">For more information about event handler delegates, see [Handling and Raising Events](/dotnet/standard/events/).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3203-1994">下面的代码示例创建一个名为的事件处理程序 `MyPeekCompleted` ，将其附加到 <xref:System.Messaging.MessageQueue.PeekCompleted> 事件处理程序委托，并调用 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 以对位于路径 ".\myQueue" 的队列启动异步查看操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-1994">The following code example creates an event handler named `MyPeekCompleted`, attaches it to the <xref:System.Messaging.MessageQueue.PeekCompleted> event handler delegate, and calls <xref:System.Messaging.MessageQueue.BeginPeek%2A> to initiate an asynchronous peek operation on the queue that is located at the path ".\myQueue".</span></span> <span data-ttu-id="b3203-1995"><xref:System.Messaging.MessageQueue.PeekCompleted>引发事件时，该示例将扫视消息，并将其正文写入屏幕。</span><span class="sxs-lookup"><span data-stu-id="b3203-1995">When a <xref:System.Messaging.MessageQueue.PeekCompleted> event is raised, the example peeks the message and writes its body to the screen.</span></span> <span data-ttu-id="b3203-1996">然后，该示例 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 再次调用以启动新的异步查看操作</span><span class="sxs-lookup"><span data-stu-id="b3203-1996">The example then calls <xref:System.Messaging.MessageQueue.BeginPeek%2A> again to initiate a new asynchronous peek operation</span></span>  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberSignature Language="VB.NET" Value="Public Sub Purge ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Purge();" />
      <MemberSignature Language="F#" Value="member this.Purge : unit -&gt; unit" Usage="messageQueue.Purge " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b3203-1997">删除队列中包含的所有消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-1997">Deletes all the messages contained in the queue.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-1998">清除队列会导致消息队列设置队列修改标志，这将影响 <xref:System.Messaging.MessageQueue.LastModifyTime%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="b3203-1998">Purging the queue causes Message Queuing to set the queue modification flag, which affects the <xref:System.Messaging.MessageQueue.LastModifyTime%2A> property.</span></span> <span data-ttu-id="b3203-1999">从队列中清除的消息丢失;它们不会发送到死信队列或日记队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-1999">Messages that are purged from the queue are lost; they are not sent to the dead-letter queue or the journal queue.</span></span>  
  
 <span data-ttu-id="b3203-2000">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2000">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2001">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2001">Workgroup mode</span></span>|<span data-ttu-id="b3203-2002">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2002">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2003">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2003">Local computer</span></span>|<span data-ttu-id="b3203-2004">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2004">Yes</span></span>|  
|<span data-ttu-id="b3203-2005">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2005">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2006">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2006">Yes</span></span>|  
|<span data-ttu-id="b3203-2007">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2007">Remote computer</span></span>|<span data-ttu-id="b3203-2008">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2008">No</span></span>|  
|<span data-ttu-id="b3203-2009">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2009">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2010">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2010">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-2011">以下代码示例演示了 <xref:System.Messaging.MessageQueue.Purge%2A> 的用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2011">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.Purge%2A>.</span></span>  
  
 [!code-cpp[MessageQueue2#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-2012">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-2012">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="M:System.Messaging.MessageQueue.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberSignature Language="VB.NET" Value="Public Property QueueName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ QueueName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.QueueName : string with get, set" Usage="System.Messaging.MessageQueue.QueueName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_QueueName")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_QueueName")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-2013">获取或设置标识队列的友好名称。</span><span class="sxs-lookup"><span data-stu-id="b3203-2013">Gets or sets the friendly name that identifies the queue.</span></span></summary>
        <value><span data-ttu-id="b3203-2014">名称，该名称标识由此 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2014">The name that identifies the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />.</span></span> <span data-ttu-id="b3203-2015">该值不能为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2015">The value cannot be <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2016">可以将与结合 <xref:System.Messaging.MessageQueue.QueueName%2A> 使用 <xref:System.Messaging.MessageQueue.MachineName%2A> 来创建队列的友好 <xref:System.Messaging.MessageQueue.Path%2A> 名称。</span><span class="sxs-lookup"><span data-stu-id="b3203-2016">You can combine the <xref:System.Messaging.MessageQueue.QueueName%2A> with the <xref:System.Messaging.MessageQueue.MachineName%2A> to create a friendly <xref:System.Messaging.MessageQueue.Path%2A> name for the queue.</span></span> <span data-ttu-id="b3203-2017">属性的友好名称变体的语法 <xref:System.Messaging.MessageQueue.Path%2A> 取决于队列的类型，如下表所示。</span><span class="sxs-lookup"><span data-stu-id="b3203-2017">The syntax for the friendly name variation of the <xref:System.Messaging.MessageQueue.Path%2A> property depends on the type of queue, as shown in the following table.</span></span>  
  
|<span data-ttu-id="b3203-2018">队列类型</span><span class="sxs-lookup"><span data-stu-id="b3203-2018">Queue type</span></span>|<span data-ttu-id="b3203-2019">语法</span><span class="sxs-lookup"><span data-stu-id="b3203-2019">Syntax</span></span>|  
|----------------|------------|  
|<span data-ttu-id="b3203-2020">公用队列</span><span class="sxs-lookup"><span data-stu-id="b3203-2020">Public queue</span></span>|`MachineName`\\`QueueName`|  
|<span data-ttu-id="b3203-2021">专用队列</span><span class="sxs-lookup"><span data-stu-id="b3203-2021">Private queue</span></span>|`MachineName`\\`Private$`\\`QueueName`|  
|<span data-ttu-id="b3203-2022">日志队列</span><span class="sxs-lookup"><span data-stu-id="b3203-2022">Journal queue</span></span>|`MachineName`\\`QueueName`\\`Journal$`|  
  
 <span data-ttu-id="b3203-2023">使用 "." 表示本地计算机。</span><span class="sxs-lookup"><span data-stu-id="b3203-2023">Use "." to represent the local computer.</span></span>  
  
 <span data-ttu-id="b3203-2024">更改 <xref:System.Messaging.MessageQueue.QueueName%2A> 属性将影响 <xref:System.Messaging.MessageQueue.Path%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="b3203-2024">Changing the <xref:System.Messaging.MessageQueue.QueueName%2A> property affects the <xref:System.Messaging.MessageQueue.Path%2A> property.</span></span> <span data-ttu-id="b3203-2025">如果在 <xref:System.Messaging.MessageQueue.QueueName%2A> 未设置属性的情况下设置 <xref:System.Messaging.MessageQueue.MachineName%2A> ， <xref:System.Messaging.MessageQueue.Path%2A> 属性将变为。 \\ `QueueName`</span><span class="sxs-lookup"><span data-stu-id="b3203-2025">If you set the <xref:System.Messaging.MessageQueue.QueueName%2A> without setting the <xref:System.Messaging.MessageQueue.MachineName%2A> property, the <xref:System.Messaging.MessageQueue.Path%2A> property becomes .\\`QueueName`.</span></span> <span data-ttu-id="b3203-2026">否则，将 <xref:System.Messaging.MessageQueue.Path%2A> 变为 `MachineName` \\ `QueueName` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2026">Otherwise, the <xref:System.Messaging.MessageQueue.Path%2A> becomes `MachineName`\\`QueueName`.</span></span>  
  
 <span data-ttu-id="b3203-2027">下表显示了此属性在各种工作组模式下是否可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2027">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2028">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2028">Workgroup mode</span></span>|<span data-ttu-id="b3203-2029">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2029">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2030">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2030">Local computer</span></span>|<span data-ttu-id="b3203-2031">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2031">Yes</span></span>|  
|<span data-ttu-id="b3203-2032">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2032">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2033">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2033">Yes</span></span>|  
|<span data-ttu-id="b3203-2034">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2034">Remote computer</span></span>|<span data-ttu-id="b3203-2035">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2035">Yes</span></span>|  
|<span data-ttu-id="b3203-2036">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2036">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2037">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2037">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-2038">下面的代码示例获取并设置消息队列属性的值 <xref:System.Messaging.MessageQueue.QueueName%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2038">The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.QueueName%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-2039">队列名称为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2039">The queue name is <see langword="null" />.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ReadHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadHandle : nativeint" Usage="System.Messaging.MessageQueue.ReadHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_ReadHandle")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_ReadHandle")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-2040">获取用于从消息队列读取消息的本机句柄。</span><span class="sxs-lookup"><span data-stu-id="b3203-2040">Gets the native handle used to read messages from the message queue.</span></span></summary>
        <value><span data-ttu-id="b3203-2041">用于查看和接收来自队列的消息的本机队列对象的句柄。</span><span class="sxs-lookup"><span data-stu-id="b3203-2041">A handle to the native queue object that you use for peeking and receiving messages from the queue.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2042">为 <xref:System.Messaging.MessageQueue.ReadHandle%2A> 消息队列对象提供本机 Windows 句柄，该句柄用于扫视和接收来自队列的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2042">The <xref:System.Messaging.MessageQueue.ReadHandle%2A> provides a native Windows handle to the message queue object that is used for peeking and receiving messages from the queue.</span></span> <span data-ttu-id="b3203-2043">如果更改队列的路径，将关闭句柄，并使用新值重新打开。</span><span class="sxs-lookup"><span data-stu-id="b3203-2043">If you change the path of the queue, the handle is closed and reopened with a new value.</span></span>  
  
 <span data-ttu-id="b3203-2044">下表显示了此属性在各种工作组模式下是否可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2044">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2045">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2045">Workgroup mode</span></span>|<span data-ttu-id="b3203-2046">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2046">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2047">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2047">Local computer</span></span>|<span data-ttu-id="b3203-2048">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2048">Yes</span></span>|  
|<span data-ttu-id="b3203-2049">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2049">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2050">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2050">Yes</span></span>|  
|<span data-ttu-id="b3203-2051">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2051">Remote computer</span></span>|<span data-ttu-id="b3203-2052">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2052">No</span></span>|  
|<span data-ttu-id="b3203-2053">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2053">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2054">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2054">Yes</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-2055">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-2055">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe><span data-ttu-id="b3203-2056">方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="b3203-2056">The method is not thread safe.</span></span></threadsafe>
        <summary><span data-ttu-id="b3203-2057">接收队列中的第一条消息，但不将它从队列中移除。</span><span class="sxs-lookup"><span data-stu-id="b3203-2057">Receives the first message in the queue, removing it from the queue.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive();" />
      <MemberSignature Language="F#" Value="member this.Receive : unit -&gt; System.Messaging.Message" Usage="messageQueue.Receive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b3203-2058">接收 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列中可用的第一条消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2058">Receives the first message available in the queue referenced by the <see cref="T:System.Messaging.MessageQueue" />.</span></span> <span data-ttu-id="b3203-2059">此调用是同步的，在有可用消息前，它将一直阻止当前线程的执行。</span><span class="sxs-lookup"><span data-stu-id="b3203-2059">This call is synchronous, and blocks the current thread of execution until a message is available.</span></span></summary>
        <returns><span data-ttu-id="b3203-2060"><see cref="T:System.Messaging.Message" />，它引用队列中可用的第一条消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2060">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2061">使用此重载接收队列中的消息，或等待队列中有消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2061">Use this overload to receive a message from a queue, or wait until there are messages in the queue.</span></span>  
  
 <span data-ttu-id="b3203-2062"><xref:System.Messaging.MessageQueue.Receive%2A>方法允许同步读取消息，从而将其从队列中删除。</span><span class="sxs-lookup"><span data-stu-id="b3203-2062">The <xref:System.Messaging.MessageQueue.Receive%2A> method allows for the synchronous reading of a message, thereby removing it from the queue.</span></span> <span data-ttu-id="b3203-2063">对的后续调用 <xref:System.Messaging.MessageQueue.Receive%2A> 将返回队列中后面的消息或新的优先级较高的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2063">Subsequent calls to <xref:System.Messaging.MessageQueue.Receive%2A> will return the messages that follow in the queue, or new, higher priority messages.</span></span>  
  
 <span data-ttu-id="b3203-2064">若要读取队列中的第一条消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.Peek%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2064">To read the first message in a queue without removing it from the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.</span></span> <span data-ttu-id="b3203-2065"><xref:System.Messaging.MessageQueue.Peek%2A>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2065">The <xref:System.Messaging.MessageQueue.Peek%2A> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span>  
  
 <span data-ttu-id="b3203-2066"><xref:System.Messaging.MessageQueue.Receive%2A>如果当前线程在等待消息到达队列时可以被阻塞，则使用对的调用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2066">Use a call to <xref:System.Messaging.MessageQueue.Receive%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</span></span> <span data-ttu-id="b3203-2067">由于此方法的重载 <xref:System.Messaging.MessageQueue.Receive%2A> 指定一个无限超时，因此应用程序可能会无限期等待。</span><span class="sxs-lookup"><span data-stu-id="b3203-2067">Because this overload of the <xref:System.Messaging.MessageQueue.Receive%2A> method specifies an infinite time-out, the application might wait indefinitely.</span></span> <span data-ttu-id="b3203-2068">如果应用程序处理应继续而不等待消息，请考虑使用异步方法 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2068">If the application processing should continue without waiting for the message, consider using the asynchronous method, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.</span></span>  
  
 <span data-ttu-id="b3203-2069">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2069">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2070">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2070">Workgroup mode</span></span>|<span data-ttu-id="b3203-2071">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2071">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2072">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2072">Local computer</span></span>|<span data-ttu-id="b3203-2073">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2073">Yes</span></span>|  
|<span data-ttu-id="b3203-2074">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2074">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2075">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2075">Yes</span></span>|  
|<span data-ttu-id="b3203-2076">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2076">Remote computer</span></span>|<span data-ttu-id="b3203-2077">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2077">No</span></span>|  
|<span data-ttu-id="b3203-2078">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2078">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2079">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2079">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-2080">下面的代码示例接收队列中的消息，并将有关该消息的信息输出到屏幕。</span><span class="sxs-lookup"><span data-stu-id="b3203-2080">The following code example receives a message from a queue and outputs information about that message to the screen.</span></span>  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-2081">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-2081">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction"><span data-ttu-id="b3203-2082"><see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-2082">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</span></span></param>
        <summary><span data-ttu-id="b3203-2083">接收 <see cref="T:System.Messaging.MessageQueue" /> 引用的事务性队列中可用的第一条消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2083">Receives the first message available in the transactional queue referenced by the <see cref="T:System.Messaging.MessageQueue" />.</span></span> <span data-ttu-id="b3203-2084">此调用是同步的，在有可用消息前，它将一直阻止当前线程的执行。</span><span class="sxs-lookup"><span data-stu-id="b3203-2084">This call is synchronous, and blocks the current thread of execution until a message is available.</span></span></summary>
        <returns><span data-ttu-id="b3203-2085"><see cref="T:System.Messaging.Message" />，它引用队列中可用的第一条消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2085">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2086">使用此重载可以通过由参数定义的内部事务上下文接收来自事务性队列的消息 `transaction` ，或等待队列中有消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2086">Use this overload to receive a message from a transactional queue using the internal transaction context defined by the `transaction` parameter, or wait until there are messages in the queue.</span></span>  
  
 <span data-ttu-id="b3203-2087"><xref:System.Messaging.MessageQueue.Receive%2A>方法允许同步读取消息，从而将其从队列中删除。</span><span class="sxs-lookup"><span data-stu-id="b3203-2087">The <xref:System.Messaging.MessageQueue.Receive%2A> method allows for the synchronous reading of a message, thereby removing it from the queue.</span></span> <span data-ttu-id="b3203-2088">对的后续调用 <xref:System.Messaging.MessageQueue.Receive%2A> 将返回队列中后面的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2088">Subsequent calls to <xref:System.Messaging.MessageQueue.Receive%2A> will return the messages that follow in the queue.</span></span>  
  
 <span data-ttu-id="b3203-2089">由于此方法是在事务队列中调用的，因此，如果事务中止，接收到的消息将返回到队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2089">Because this method is called on a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="b3203-2090">在提交事务之前，不会从队列中永久删除该消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2090">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="b3203-2091">若要读取队列中的第一条消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.Peek%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2091">To read the first message in a queue without removing it from the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.</span></span> <span data-ttu-id="b3203-2092"><xref:System.Messaging.MessageQueue.Peek%2A>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2092">The <xref:System.Messaging.MessageQueue.Peek%2A> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span> <span data-ttu-id="b3203-2093">没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.Peek%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2093">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.Peek%2A>.</span></span> <span data-ttu-id="b3203-2094">由于不会 <xref:System.Messaging.MessageQueue.Peek%2A> 删除队列中的任何消息，因此不会通过调用来回滚任何内容 <xref:System.Messaging.MessageQueueTransaction.Abort%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2094">Because <xref:System.Messaging.MessageQueue.Peek%2A> does not remove any messages in the queue, there would be nothing to roll back by a call to <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.</span></span>  
  
 <span data-ttu-id="b3203-2095"><xref:System.Messaging.MessageQueue.Receive%2A>如果当前线程在等待消息到达队列时可以被阻塞，则使用对的调用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2095">Use a call to <xref:System.Messaging.MessageQueue.Receive%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</span></span> <span data-ttu-id="b3203-2096">由于此方法的重载 <xref:System.Messaging.MessageQueue.Receive%2A> 指定一个无限超时，因此应用程序可能会无限期等待。</span><span class="sxs-lookup"><span data-stu-id="b3203-2096">Because this overload of the <xref:System.Messaging.MessageQueue.Receive%2A> method specifies an infinite time-out, the application might wait indefinitely.</span></span> <span data-ttu-id="b3203-2097">如果应用程序处理应继续而不等待消息，请考虑使用异步方法 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2097">If the application processing should continue without waiting for the message, consider using the asynchronous method, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.</span></span>  
  
 <span data-ttu-id="b3203-2098">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2098">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2099">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2099">Workgroup mode</span></span>|<span data-ttu-id="b3203-2100">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2100">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2101">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2101">Local computer</span></span>|<span data-ttu-id="b3203-2102">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2102">Yes</span></span>|  
|<span data-ttu-id="b3203-2103">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2103">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2104">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2104">Yes</span></span>|  
|<span data-ttu-id="b3203-2105">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2105">Remote computer</span></span>|<span data-ttu-id="b3203-2106">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2106">No</span></span>|  
|<span data-ttu-id="b3203-2107">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2107">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2108">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2108">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-2109">下面的代码示例连接到本地计算机上的事务队列，并将消息发送到队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2109">The following code example connects to a transactional queue on the local computer and sends a message to the queue.</span></span> <span data-ttu-id="b3203-2110">然后，它将接收包含订单的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2110">It then receives the message that contains an order.</span></span> <span data-ttu-id="b3203-2111">如果遇到非事务性队列，它将引发并引发异常并回滚事务。</span><span class="sxs-lookup"><span data-stu-id="b3203-2111">If it encounters a non-transactional queue, it will throw and exception and rollback the transaction.</span></span>  
  
 [!code-cpp[MessageQueue.Receive_transaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_transaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive_transaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-2112">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-2112">An error occurred when accessing a Message Queuing method.</span></span>  
  
 <span data-ttu-id="b3203-2113">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-2113">-or-</span></span>  
  
 <span data-ttu-id="b3203-2114">该队列为非事务性队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2114">The queue is non-transactional.</span></span></exception>
        <threadsafe><span data-ttu-id="b3203-2115">方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="b3203-2115">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType"><span data-ttu-id="b3203-2116"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文的类型。</span><span class="sxs-lookup"><span data-stu-id="b3203-2116">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span></span></param>
        <summary><span data-ttu-id="b3203-2117">接收 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列中可用的第一条消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2117">Receives the first message available in the queue referenced by the <see cref="T:System.Messaging.MessageQueue" />.</span></span> <span data-ttu-id="b3203-2118">此调用是同步的，在有可用消息前，它将一直阻止当前线程的执行。</span><span class="sxs-lookup"><span data-stu-id="b3203-2118">This call is synchronous, and blocks the current thread of execution until a message is available.</span></span></summary>
        <returns><span data-ttu-id="b3203-2119"><see cref="T:System.Messaging.Message" />，它引用队列中可用的第一条消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2119">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2120">使用此重载通过由参数定义的事务上下文从队列中接收消息 `transactionType` ，或等待队列中有消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2120">Use this overload to receive a message from a queue using a transaction context defined by the `transactionType` parameter, or wait until there are messages in the queue.</span></span>  
  
 <span data-ttu-id="b3203-2121">`Automatic` `transactionType` 如果已存在附加到要用于接收消息的线程的外部事务上下文，请为参数指定。</span><span class="sxs-lookup"><span data-stu-id="b3203-2121">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</span></span> <span data-ttu-id="b3203-2122">指定 `Single` 是否要以单个内部事务的形式接收消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2122">Specify `Single` if you want to receive the message as a single internal transaction.</span></span> <span data-ttu-id="b3203-2123">您可以指定 `None` 是否要在事务上下文之外接收来自事务性队列的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2123">You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.</span></span>  
  
 <span data-ttu-id="b3203-2124"><xref:System.Messaging.MessageQueue.Receive%2A>方法允许同步读取消息，从而将其从队列中删除。</span><span class="sxs-lookup"><span data-stu-id="b3203-2124">The <xref:System.Messaging.MessageQueue.Receive%2A> method allows for the synchronous reading of a message, thereby removing it from the queue.</span></span> <span data-ttu-id="b3203-2125">对的后续调用 <xref:System.Messaging.MessageQueue.Receive%2A> 将返回队列中后面的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2125">Subsequent calls to <xref:System.Messaging.MessageQueue.Receive%2A> will return the messages that follow in the queue.</span></span>  
  
 <span data-ttu-id="b3203-2126">如果调用此方法来接收来自事务性队列的消息，则在事务中止时，收到的消息将返回到队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2126">If this method is called to receive a message from a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="b3203-2127">在提交事务之前，不会从队列中永久删除该消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2127">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="b3203-2128">若要读取队列中的第一条消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.Peek%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2128">To read the first message in a queue without removing it from the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.</span></span> <span data-ttu-id="b3203-2129"><xref:System.Messaging.MessageQueue.Peek%2A>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2129">The <xref:System.Messaging.MessageQueue.Peek%2A> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span> <span data-ttu-id="b3203-2130">没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.Peek%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2130">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.Peek%2A>.</span></span> <span data-ttu-id="b3203-2131">由于不会 <xref:System.Messaging.MessageQueue.Peek%2A> 删除队列中的任何消息，因此不会通过调用来回滚任何内容 <xref:System.Messaging.MessageQueueTransaction.Abort%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2131">Because <xref:System.Messaging.MessageQueue.Peek%2A> does not remove any messages in the queue, there would be nothing to roll back by a call to <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.</span></span>  
  
 <span data-ttu-id="b3203-2132"><xref:System.Messaging.MessageQueue.Receive%2A>如果当前线程在等待消息到达队列时可以被阻塞，则使用对的调用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2132">Use a call to <xref:System.Messaging.MessageQueue.Receive%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</span></span> <span data-ttu-id="b3203-2133">由于此方法的重载 <xref:System.Messaging.MessageQueue.Receive%2A> 指定一个无限超时，因此应用程序可能会无限期等待。</span><span class="sxs-lookup"><span data-stu-id="b3203-2133">Because this overload of the <xref:System.Messaging.MessageQueue.Receive%2A> method specifies an infinite time-out, the application might wait indefinitely.</span></span> <span data-ttu-id="b3203-2134">如果应用程序处理应继续而不等待消息，请考虑使用异步方法 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2134">If the application processing should continue without waiting for the message, consider using the asynchronous method, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.</span></span>  
  
 <span data-ttu-id="b3203-2135">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2135">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2136">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2136">Workgroup mode</span></span>|<span data-ttu-id="b3203-2137">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2137">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2138">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2138">Local computer</span></span>|<span data-ttu-id="b3203-2139">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2139">Yes</span></span>|  
|<span data-ttu-id="b3203-2140">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2140">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2141">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2141">Yes</span></span>|  
|<span data-ttu-id="b3203-2142">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2142">Remote computer</span></span>|<span data-ttu-id="b3203-2143">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2143">No</span></span>|  
|<span data-ttu-id="b3203-2144">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2144">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2145">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2145">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-2146">以下代码示例演示了 <xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29> 的用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2146">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-2147">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-2147">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="b3203-2148"><paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</span><span class="sxs-lookup"><span data-stu-id="b3203-2148">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span></span></exception>
        <threadsafe><span data-ttu-id="b3203-2149">方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="b3203-2149">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Receive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="b3203-2150">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-2150">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</span></span></param>
        <summary><span data-ttu-id="b3203-2151">接收由 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列中的第一条可用消息，并且一直等到队列中有可用消息或超时过期。</span><span class="sxs-lookup"><span data-stu-id="b3203-2151">Receives the first message available in the queue referenced by the <see cref="T:System.Messaging.MessageQueue" /> and waits until either a message is available in the queue, or the time-out expires.</span></span></summary>
        <returns><span data-ttu-id="b3203-2152"><see cref="T:System.Messaging.Message" />，它引用队列中可用的第一条消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2152">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2153">使用此重载接收消息并在队列中没有消息时在指定的时间段内返回。</span><span class="sxs-lookup"><span data-stu-id="b3203-2153">Use this overload to receive a message and return in a specified period of time if there are no messages in the queue.</span></span>  
  
 <span data-ttu-id="b3203-2154"><xref:System.Messaging.MessageQueue.Receive%2A>方法允许同步读取消息，并将其从队列中删除。</span><span class="sxs-lookup"><span data-stu-id="b3203-2154">The <xref:System.Messaging.MessageQueue.Receive%2A> method allows for the synchronous reading of a message, removing it from the queue.</span></span> <span data-ttu-id="b3203-2155">对的后续调用 <xref:System.Messaging.MessageQueue.Receive%2A> 将返回队列中后面的消息或新的优先级较高的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2155">Subsequent calls to <xref:System.Messaging.MessageQueue.Receive%2A> will return the messages that follow in the queue, or new, higher priority messages.</span></span>  
  
 <span data-ttu-id="b3203-2156">若要读取队列中的第一条消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.Peek%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2156">To read the first message in a queue without removing it from the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.</span></span> <span data-ttu-id="b3203-2157"><xref:System.Messaging.MessageQueue.Peek%2A>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2157">The <xref:System.Messaging.MessageQueue.Peek%2A> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span>  
  
 <span data-ttu-id="b3203-2158"><xref:System.Messaging.MessageQueue.Receive%2A>如果当前线程在等待消息到达队列时可以被阻塞，则使用对的调用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2158">Use a call to <xref:System.Messaging.MessageQueue.Receive%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</span></span> <span data-ttu-id="b3203-2159">如果为参数指定了值，则线程将在给定的时间段内被阻止，或无限期地阻止 <xref:System.Messaging.MessageQueue.InfiniteTimeout> `timeout` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2159">The thread will be blocked for the given period of time, or indefinitely if you specified the value <xref:System.Messaging.MessageQueue.InfiniteTimeout> for the `timeout` parameter.</span></span> <span data-ttu-id="b3203-2160">如果应用程序处理应在不等待消息的情况下继续运行，请考虑使用异步方法 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2160">If the application processing should continue without waiting for a message, consider using the asynchronous method, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.</span></span>  
  
 <span data-ttu-id="b3203-2161">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2161">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2162">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2162">Workgroup mode</span></span>|<span data-ttu-id="b3203-2163">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2163">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2164">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2164">Local computer</span></span>|<span data-ttu-id="b3203-2165">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2165">Yes</span></span>|  
|<span data-ttu-id="b3203-2166">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2166">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2167">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2167">Yes</span></span>|  
|<span data-ttu-id="b3203-2168">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2168">Remote computer</span></span>|<span data-ttu-id="b3203-2169">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2169">No</span></span>|  
|<span data-ttu-id="b3203-2170">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2170">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2171">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2171">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-2172">下面的代码示例接收队列中的消息，并将有关该消息的信息输出到屏幕。</span><span class="sxs-lookup"><span data-stu-id="b3203-2172">The following code example receives a message from a queue and outputs information about that message to the screen.</span></span> <span data-ttu-id="b3203-2173">该示例在等待消息到达队列时，暂停执行最多5秒。</span><span class="sxs-lookup"><span data-stu-id="b3203-2173">The example pauses execution for up to five seconds while waiting for a message to arrive in the queue.</span></span>  
  
 [!code-cpp[MessageQueue.Receive_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-2174">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2174">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-2175">在超时过期之前消息没有到达队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2175">A message did not arrive in the queue before the time-out expired.</span></span>  
  
 <span data-ttu-id="b3203-2176">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-2176">-or-</span></span>  
  
 <span data-ttu-id="b3203-2177">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-2177">An error occurred when accessing a Message Queuing method</span></span></exception>
        <threadsafe><span data-ttu-id="b3203-2178">方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="b3203-2178">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, cursor As Cursor) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="b3203-2179">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-2179">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</span></span></param>
        <param name="cursor"><span data-ttu-id="b3203-2180">维持消息队列中特定位置的 <see cref="T:System.Messaging.Cursor" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2180">A <see cref="T:System.Messaging.Cursor" /> that maintains a specific position in the message queue.</span></span></param>
        <summary><span data-ttu-id="b3203-2181">使用指定的游标接收队列中的当前消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2181">Receives the current message in the queue, using a specified cursor.</span></span> <span data-ttu-id="b3203-2182">如果没有可用的消息，此方法将等待，直到有可用的消息或超时到期为止。</span><span class="sxs-lookup"><span data-stu-id="b3203-2182">If no message is available, this method waits until either a message is available, or the time-out expires.</span></span></summary>
        <returns><span data-ttu-id="b3203-2183"><see cref="T:System.Messaging.Message" />，它引用队列中可用的第一条消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2183">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-2184">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2184">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-2185">在超时过期之前消息没有到达队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2185">A message did not arrive in the queue before the time-out expired.</span></span>  
  
 <span data-ttu-id="b3203-2186">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-2186">-or-</span></span>  
  
 <span data-ttu-id="b3203-2187">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-2187">An error occurred when accessing a Message Queuing method</span></span>  
  
 <span data-ttu-id="b3203-2188">使用此重载接收消息并在队列中没有消息时在指定的时间段内返回。</span><span class="sxs-lookup"><span data-stu-id="b3203-2188">Use this overload to receive a message and return in a specified period of time if there are no messages in the queue.</span></span></exception>
        <threadsafe><span data-ttu-id="b3203-2189">方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="b3203-2189">The method is not thread safe.</span></span></threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="b3203-2190">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-2190">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</span></span></param>
        <param name="transaction"><span data-ttu-id="b3203-2191"><see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-2191">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</span></span></param>
        <summary><span data-ttu-id="b3203-2192">接收由 <see cref="T:System.Messaging.MessageQueue" /> 引用的事务性队列中的第一条可用消息，并且一直等到队列中有可用消息或超时过期。</span><span class="sxs-lookup"><span data-stu-id="b3203-2192">Receives the first message available in the transactional queue referenced by the <see cref="T:System.Messaging.MessageQueue" /> and waits until either a message is available in the queue, or the time-out expires.</span></span></summary>
        <returns><span data-ttu-id="b3203-2193"><see cref="T:System.Messaging.Message" />，它引用队列中可用的第一条消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2193">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2194">使用此重载，通过由参数定义的内部事务上下文接收来自事务性队列的消息 `transaction` ，并在队列中没有消息时在指定时间段内返回。</span><span class="sxs-lookup"><span data-stu-id="b3203-2194">Use this overload to receive a message from a transactional queue using the internal transaction context defined by the `transaction` parameter, and return within a specified period of time if there are no messages in the queue.</span></span>  
  
 <span data-ttu-id="b3203-2195"><xref:System.Messaging.MessageQueue.Receive%2A>方法允许同步读取消息，从而将其从队列中删除。</span><span class="sxs-lookup"><span data-stu-id="b3203-2195">The <xref:System.Messaging.MessageQueue.Receive%2A> method allows for the synchronous reading of a message, thereby removing it from the queue.</span></span> <span data-ttu-id="b3203-2196">对的后续调用 <xref:System.Messaging.MessageQueue.Receive%2A> 将返回队列中后面的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2196">Subsequent calls to <xref:System.Messaging.MessageQueue.Receive%2A> will return the messages that follow in the queue.</span></span>  
  
 <span data-ttu-id="b3203-2197">由于此方法是在事务队列中调用的，因此，如果事务中止，接收到的消息将返回到队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2197">Because this method is called on a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="b3203-2198">在提交事务之前，不会从队列中永久删除该消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2198">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="b3203-2199">若要读取队列中的第一条消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.Peek%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2199">To read the first message in a queue without removing it from the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.</span></span> <span data-ttu-id="b3203-2200"><xref:System.Messaging.MessageQueue.Peek%2A>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2200">The <xref:System.Messaging.MessageQueue.Peek%2A> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span> <span data-ttu-id="b3203-2201">没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.Peek%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2201">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.Peek%2A>.</span></span> <span data-ttu-id="b3203-2202">由于不会 <xref:System.Messaging.MessageQueue.Peek%2A> 删除队列中的任何消息，因此不会通过调用来回滚任何内容 <xref:System.Messaging.MessageQueueTransaction.Abort%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2202">Because <xref:System.Messaging.MessageQueue.Peek%2A> does not remove any messages in the queue, there would be nothing to roll back by a call to <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.</span></span>  
  
 <span data-ttu-id="b3203-2203"><xref:System.Messaging.MessageQueue.Receive%2A>如果当前线程在等待消息到达队列时可以被阻塞，则使用对的调用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2203">Use a call to <xref:System.Messaging.MessageQueue.Receive%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</span></span> <span data-ttu-id="b3203-2204">如果为参数指定了值，则线程将在给定的时间段内被阻止，或无限期地阻止 <xref:System.Messaging.MessageQueue.InfiniteTimeout> `timeout` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2204">The thread will be blocked for the given period of time, or indefinitely if you specified the value <xref:System.Messaging.MessageQueue.InfiniteTimeout> for the `timeout` parameter.</span></span> <span data-ttu-id="b3203-2205">如果应用程序处理应在不等待消息的情况下继续运行，请考虑使用异步方法 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2205">If the application processing should continue without waiting for a message, consider using the asynchronous method, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.</span></span>  
  
 <span data-ttu-id="b3203-2206">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2206">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2207">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2207">Workgroup mode</span></span>|<span data-ttu-id="b3203-2208">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2208">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2209">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2209">Local computer</span></span>|<span data-ttu-id="b3203-2210">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2210">Yes</span></span>|  
|<span data-ttu-id="b3203-2211">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2211">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2212">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2212">Yes</span></span>|  
|<span data-ttu-id="b3203-2213">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2213">Remote computer</span></span>|<span data-ttu-id="b3203-2214">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2214">No</span></span>|  
|<span data-ttu-id="b3203-2215">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2215">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2216">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2216">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-2217">下面的代码示例演示如何使用此方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2217">The following code example demonstrates the use of this method.</span></span>  
  
 [!code-cpp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-2218">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2218">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-2219">在超时过期之前消息没有到达队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2219">A message did not arrive in the queue before the time-out expired.</span></span>  
  
 <span data-ttu-id="b3203-2220">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-2220">-or-</span></span>  
  
 <span data-ttu-id="b3203-2221">该队列为非事务性队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2221">The queue is non-transactional.</span></span>  
  
 <span data-ttu-id="b3203-2222">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-2222">-or-</span></span>  
  
 <span data-ttu-id="b3203-2223">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-2223">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="b3203-2224">方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="b3203-2224">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="b3203-2225">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-2225">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</span></span></param>
        <param name="transactionType"><span data-ttu-id="b3203-2226"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文的类型。</span><span class="sxs-lookup"><span data-stu-id="b3203-2226">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span></span></param>
        <summary><span data-ttu-id="b3203-2227">接收 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列中可用的第一条消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2227">Receives the first message available in the queue referenced by the <see cref="T:System.Messaging.MessageQueue" />.</span></span> <span data-ttu-id="b3203-2228">此调用是同步的，并且一直等到队列中有可用的消息或超时到期。</span><span class="sxs-lookup"><span data-stu-id="b3203-2228">This call is synchronous, and waits until either a message is available in the queue, or the time-out expires.</span></span></summary>
        <returns><span data-ttu-id="b3203-2229"><see cref="T:System.Messaging.Message" />，它引用队列中可用的第一条消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2229">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2230">使用此重载通过由参数定义的事务上下文从队列中接收消息 `transactionType` ，并在队列中没有消息时返回指定时间段。</span><span class="sxs-lookup"><span data-stu-id="b3203-2230">Use this overload to receive a message from a queue using a transaction context defined by the `transactionType` parameter, and return in a specified period of time if there are no messages in the queue.</span></span>  
  
 <span data-ttu-id="b3203-2231">`Automatic` `transactionType` 如果已存在附加到要用于接收消息的线程的外部事务上下文，请为参数指定。</span><span class="sxs-lookup"><span data-stu-id="b3203-2231">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</span></span> <span data-ttu-id="b3203-2232">指定 `Single` 是否要以单个内部事务的形式接收消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2232">Specify `Single` if you want to receive the message as a single internal transaction.</span></span> <span data-ttu-id="b3203-2233">您可以指定 `None` 是否要在事务上下文之外接收来自事务性队列的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2233">You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.</span></span>  
  
 <span data-ttu-id="b3203-2234"><xref:System.Messaging.MessageQueue.Receive%2A>方法允许同步读取消息，从而将其从队列中删除。</span><span class="sxs-lookup"><span data-stu-id="b3203-2234">The <xref:System.Messaging.MessageQueue.Receive%2A> method allows for the synchronous reading of a message, thereby removing it from the queue.</span></span> <span data-ttu-id="b3203-2235">对的后续调用 <xref:System.Messaging.MessageQueue.Receive%2A> 将返回队列中后面的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2235">Subsequent calls to <xref:System.Messaging.MessageQueue.Receive%2A> will return the messages that follow in the queue.</span></span>  
  
 <span data-ttu-id="b3203-2236">如果调用此方法来接收来自事务性队列的消息，则在事务中止时，收到的消息将返回到队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2236">If this method is called to receive a message from a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="b3203-2237">在提交事务之前，不会从队列中永久删除该消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2237">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="b3203-2238">若要读取队列中的第一条消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.Peek%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2238">To read the first message in a queue without removing it from the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.</span></span> <span data-ttu-id="b3203-2239"><xref:System.Messaging.MessageQueue.Peek%2A>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2239">The <xref:System.Messaging.MessageQueue.Peek%2A> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span> <span data-ttu-id="b3203-2240">没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.Peek%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2240">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.Peek%2A>.</span></span> <span data-ttu-id="b3203-2241">由于不会 <xref:System.Messaging.MessageQueue.Peek%2A> 删除队列中的任何消息，因此不会通过调用来回滚任何内容 <xref:System.Messaging.MessageQueueTransaction.Abort%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2241">Because <xref:System.Messaging.MessageQueue.Peek%2A> does not remove any messages in the queue, there would be nothing to roll back by a call to <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.</span></span>  
  
 <span data-ttu-id="b3203-2242"><xref:System.Messaging.MessageQueue.Receive%2A>如果当前线程在等待消息到达队列时可以被阻塞，则使用对的调用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2242">Use a call to <xref:System.Messaging.MessageQueue.Receive%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</span></span> <span data-ttu-id="b3203-2243">如果为参数指定了值，则线程将在给定的时间段内被阻止，或无限期地阻止 <xref:System.Messaging.MessageQueue.InfiniteTimeout> `timeout` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2243">The thread will be blocked for the given period of time, or indefinitely if you specified the value <xref:System.Messaging.MessageQueue.InfiniteTimeout> for the `timeout` parameter.</span></span> <span data-ttu-id="b3203-2244">如果应用程序处理应在不等待消息的情况下继续运行，请考虑使用异步方法 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2244">If the application processing should continue without waiting for a message, consider using the asynchronous method, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.</span></span>  
  
 <span data-ttu-id="b3203-2245">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2245">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2246">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2246">Workgroup mode</span></span>|<span data-ttu-id="b3203-2247">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2247">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2248">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2248">Local computer</span></span>|<span data-ttu-id="b3203-2249">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2249">Yes</span></span>|  
|<span data-ttu-id="b3203-2250">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2250">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2251">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2251">Yes</span></span>|  
|<span data-ttu-id="b3203-2252">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2252">Remote computer</span></span>|<span data-ttu-id="b3203-2253">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2253">No</span></span>|  
|<span data-ttu-id="b3203-2254">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2254">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2255">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2255">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-2256">下面的代码示例演示如何使用此方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2256">The following code example demonstrates the use of this method.</span></span>  
  
 [!code-cpp[MessageQueue2#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-2257">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2257">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="b3203-2258"><paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</span><span class="sxs-lookup"><span data-stu-id="b3203-2258">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-2259">在超时过期之前消息没有到达队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2259">A message did not arrive in the queue before the time-out expired.</span></span>  
  
 <span data-ttu-id="b3203-2260">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-2260">-or-</span></span>  
  
 <span data-ttu-id="b3203-2261">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-2261">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="b3203-2262">方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="b3203-2262">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, cursor As Cursor, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="b3203-2263">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-2263">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</span></span></param>
        <param name="cursor"><span data-ttu-id="b3203-2264">维持消息队列中特定位置的 <see cref="T:System.Messaging.Cursor" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2264">A <see cref="T:System.Messaging.Cursor" /> that maintains a specific position in the message queue.</span></span></param>
        <param name="transaction"><span data-ttu-id="b3203-2265"><see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-2265">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</span></span></param>
        <summary><span data-ttu-id="b3203-2266">使用指定的游标接收队列中的当前消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2266">Receives the current message in the queue, using a specified cursor.</span></span> <span data-ttu-id="b3203-2267">如果没有可用的消息，此方法将等待，直到有可用的消息或超时到期为止。</span><span class="sxs-lookup"><span data-stu-id="b3203-2267">If no message is available, this method waits until either a message is available, or the time-out expires.</span></span></summary>
        <returns><span data-ttu-id="b3203-2268">一个 <see cref="T:System.Messaging.Message" />，它引用队列中的一条消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2268">A <see cref="T:System.Messaging.Message" /> that references a message in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2269">使用此重载，通过由参数定义的内部事务上下文接收来自事务性队列的消息 `transaction` ，并在队列中没有消息时在指定时间段内返回。</span><span class="sxs-lookup"><span data-stu-id="b3203-2269">Use this overload to receive a message from a transactional queue using the internal transaction context defined by the `transaction` parameter, and return within a specified period of time if there are no messages in the queue.</span></span>  
  
 <span data-ttu-id="b3203-2270"><xref:System.Messaging.MessageQueue.Receive%2A>方法允许同步读取消息，从而将其从队列中删除。</span><span class="sxs-lookup"><span data-stu-id="b3203-2270">The <xref:System.Messaging.MessageQueue.Receive%2A> method allows for the synchronous reading of a message, thereby removing it from the queue.</span></span> <span data-ttu-id="b3203-2271">后续调用 <xref:System.Messaging.MessageQueue.Receive%2A> 会返回队列中后面的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2271">Subsequent calls to <xref:System.Messaging.MessageQueue.Receive%2A> return the messages that follow in the queue.</span></span>  
  
 <span data-ttu-id="b3203-2272">由于此方法是在事务队列中调用的，因此，如果事务中止，接收到的消息将返回到队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2272">Because this method is called on a transactional queue, the message that is received is returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="b3203-2273">在提交事务之前，不会从队列中永久删除该消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2273">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="b3203-2274">若要在队列中读取消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.Peek%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2274">To read a message in a queue without removing it from the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.</span></span> <span data-ttu-id="b3203-2275">没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.Peek%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2275">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.Peek%2A>.</span></span> <span data-ttu-id="b3203-2276">由于不 <xref:System.Messaging.MessageQueue.Peek%2A> 会删除队列中的任何消息，因此没有任何内容可以通过调用回滚 <xref:System.Messaging.MessageQueueTransaction.Abort%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2276">Because <xref:System.Messaging.MessageQueue.Peek%2A> does not remove any messages in the queue, there is nothing to roll back by a call to <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.</span></span>  
  
 <span data-ttu-id="b3203-2277"><xref:System.Messaging.MessageQueue.Receive%2A>如果当前线程在等待消息到达队列时可以被阻塞，则使用对的调用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2277">Use a call to <xref:System.Messaging.MessageQueue.Receive%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</span></span> <span data-ttu-id="b3203-2278">线程在给定的时间段内被阻止，或在指定了参数的值的情况下无限期阻止 <xref:System.Messaging.MessageQueue.InfiniteTimeout> `timeout` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2278">The thread is blocked for the given period of time, or indefinitely if you specified the value <xref:System.Messaging.MessageQueue.InfiniteTimeout> for the `timeout` parameter.</span></span> <span data-ttu-id="b3203-2279">如果应用程序处理应在不等待消息的情况下继续运行，请考虑使用异步方法 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2279">If the application processing should continue without waiting for a message, consider using the asynchronous method, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.</span></span>  
  
 <span data-ttu-id="b3203-2280">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2280">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2281">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2281">Workgroup mode</span></span>|<span data-ttu-id="b3203-2282">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2282">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2283">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2283">Local computer</span></span>|<span data-ttu-id="b3203-2284">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2284">Yes</span></span>|  
|<span data-ttu-id="b3203-2285">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2285">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2286">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2286">Yes</span></span>|  
|<span data-ttu-id="b3203-2287">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2287">Remote computer</span></span>|<span data-ttu-id="b3203-2288">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2288">No</span></span>|  
|<span data-ttu-id="b3203-2289">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2289">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2290">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2290">Yes</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3203-2291"><paramref name="cursor" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2291">The <paramref name="cursor" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="b3203-2292">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-2292">-or-</span></span> 
<span data-ttu-id="b3203-2293"><paramref name="transaction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2293">The <paramref name="transaction" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-2294">为 <paramref name="timeout" /> 参数指定的值无效。</span><span class="sxs-lookup"><span data-stu-id="b3203-2294">The value specified for the <paramref name="timeout" /> parameter is not valid.</span></span> <span data-ttu-id="b3203-2295"><paramref name="timeout" /> 可能小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2295">Possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-2296">在超时过期之前消息没有到达队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2296">A message did not arrive in the queue before the time-out expired.</span></span>  
  
 <span data-ttu-id="b3203-2297">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-2297">-or-</span></span>  
  
 <span data-ttu-id="b3203-2298">该队列为非事务性队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2298">The queue is non-transactional.</span></span>  
  
 <span data-ttu-id="b3203-2299">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-2299">-or-</span></span>  
  
 <span data-ttu-id="b3203-2300">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-2300">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="b3203-2301">方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="b3203-2301">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, cursor As Cursor, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="b3203-2302">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-2302">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</span></span></param>
        <param name="cursor"><span data-ttu-id="b3203-2303">维持消息队列中特定位置的 <see cref="T:System.Messaging.Cursor" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2303">A <see cref="T:System.Messaging.Cursor" /> that maintains a specific position in the message queue.</span></span></param>
        <param name="transactionType"><span data-ttu-id="b3203-2304"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文类型。</span><span class="sxs-lookup"><span data-stu-id="b3203-2304">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values that describes the type of transaction context to associate with the message.</span></span></param>
        <summary><span data-ttu-id="b3203-2305">使用指定的游标接收队列中的当前消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2305">Receives the current message in the queue, using a specified cursor.</span></span> <span data-ttu-id="b3203-2306">如果没有可用的消息，此方法将等待，直到有可用的消息或超时到期为止。</span><span class="sxs-lookup"><span data-stu-id="b3203-2306">If no message is available, this method waits until either a message is available, or the time-out expires.</span></span></summary>
        <returns><span data-ttu-id="b3203-2307">一个 <see cref="T:System.Messaging.Message" />，它引用队列中的一条消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2307">A <see cref="T:System.Messaging.Message" /> that references a message in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2308">使用此重载通过由参数定义的事务上下文从队列中接收消息 `transactionType` ，并在队列中没有消息时返回指定时间段。</span><span class="sxs-lookup"><span data-stu-id="b3203-2308">Use this overload to receive a message from a queue using a transaction context defined by the `transactionType` parameter, and return in a specified period of time if there are no messages in the queue.</span></span>  
  
 <span data-ttu-id="b3203-2309">`Automatic` `transactionType` 如果已存在附加到要用于接收消息的线程的外部事务上下文，请为参数指定。</span><span class="sxs-lookup"><span data-stu-id="b3203-2309">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</span></span> <span data-ttu-id="b3203-2310">指定 `Single` 是否要以单个内部事务的形式接收消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2310">Specify `Single` if you want to receive the message as a single internal transaction.</span></span> <span data-ttu-id="b3203-2311">您可以指定 `None` 是否要在事务上下文之外接收来自事务性队列的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2311">You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.</span></span>  
  
 <span data-ttu-id="b3203-2312"><xref:System.Messaging.MessageQueue.Receive%2A>方法允许同步读取消息，从而将其从队列中删除。</span><span class="sxs-lookup"><span data-stu-id="b3203-2312">The <xref:System.Messaging.MessageQueue.Receive%2A> method allows for the synchronous reading of a message, thereby removing it from the queue.</span></span> <span data-ttu-id="b3203-2313">后续调用 <xref:System.Messaging.MessageQueue.Receive%2A> 会返回队列中后面的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2313">Subsequent calls to <xref:System.Messaging.MessageQueue.Receive%2A> return the messages that follow in the queue.</span></span>  
  
 <span data-ttu-id="b3203-2314">如果调用此方法来接收来自事务性队列的消息，则在事务中止的情况下，接收到的消息将返回到队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2314">If this method is called to receive a message from a transactional queue, the message that is received is returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="b3203-2315">在提交事务之前，不会从队列中永久删除该消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2315">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="b3203-2316">若要在队列中读取消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.Peek%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2316">To read a message in a queue without removing it from the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.</span></span> <span data-ttu-id="b3203-2317">没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.Peek%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2317">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.Peek%2A>.</span></span> <span data-ttu-id="b3203-2318">由于不 <xref:System.Messaging.MessageQueue.Peek%2A> 会删除队列中的任何消息，因此没有任何内容可以通过调用回滚 <xref:System.Messaging.MessageQueueTransaction.Abort%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2318">Because <xref:System.Messaging.MessageQueue.Peek%2A> does not remove any messages in the queue, there is nothing to roll back by a call to <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.</span></span>  
  
 <span data-ttu-id="b3203-2319"><xref:System.Messaging.MessageQueue.Receive%2A>如果当前线程在等待消息到达队列时可以被阻塞，则使用对的调用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2319">Use a call to <xref:System.Messaging.MessageQueue.Receive%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</span></span> <span data-ttu-id="b3203-2320">线程在给定的时间段内被阻止，或在指定了参数的值的情况下无限期阻止 <xref:System.Messaging.MessageQueue.InfiniteTimeout> `timeout` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2320">The thread is blocked for the given period of time, or indefinitely if you specified the value <xref:System.Messaging.MessageQueue.InfiniteTimeout> for the `timeout` parameter.</span></span> <span data-ttu-id="b3203-2321">如果应用程序处理应在不等待消息的情况下继续运行，请考虑使用异步方法 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2321">If the application processing should continue without waiting for a message, consider using the asynchronous method, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.</span></span>  
  
 <span data-ttu-id="b3203-2322">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2322">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2323">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2323">Workgroup mode</span></span>|<span data-ttu-id="b3203-2324">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2324">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2325">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2325">Local computer</span></span>|<span data-ttu-id="b3203-2326">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2326">Yes</span></span>|  
|<span data-ttu-id="b3203-2327">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2327">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2328">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2328">Yes</span></span>|  
|<span data-ttu-id="b3203-2329">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2329">Remote computer</span></span>|<span data-ttu-id="b3203-2330">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2330">No</span></span>|  
|<span data-ttu-id="b3203-2331">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2331">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2332">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2332">Yes</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3203-2333"><paramref name="cursor" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2333">The <paramref name="cursor" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-2334">为 <paramref name="timeout" /> 参数指定的值无效。</span><span class="sxs-lookup"><span data-stu-id="b3203-2334">The value specified for the <paramref name="timeout" /> parameter is not valid.</span></span> <span data-ttu-id="b3203-2335"><paramref name="timeout" /> 可能小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2335">Possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="b3203-2336"><paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</span><span class="sxs-lookup"><span data-stu-id="b3203-2336">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-2337">在超时过期之前消息没有到达队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2337">A message did not arrive in the queue before the time-out expired.</span></span>  
  
 <span data-ttu-id="b3203-2338">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-2338">-or-</span></span>  
  
 <span data-ttu-id="b3203-2339">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-2339">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="b3203-2340">方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="b3203-2340">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b3203-2341">接收匹配给定相关标识符的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2341">Receives a message that matches a given correlation identifier.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId"><span data-ttu-id="b3203-2342">要接收的消息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2342">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to receive.</span></span></param>
        <summary><span data-ttu-id="b3203-2343">从非事务性队列中接收与给定的相关标识符匹配的消息，而且在队列中当前不存在具有指定相关标识符的消息时立即引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-2343">Receives the message that matches the given correlation identifier (from a non-transactional queue) and immediately raises an exception if no message with the specified correlation identifier currently exists in the queue.</span></span></summary>
        <returns><span data-ttu-id="b3203-2344">其 <see cref="T:System.Messaging.Message" /> 匹配传入的 <paramref name="correlationId" /> 参数的 <see cref="P:System.Messaging.Message.CorrelationId" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2344">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2345">此方法在引用的非事务性队列中查找 <xref:System.Messaging.MessageQueue> <xref:System.Messaging.Message.CorrelationId%2A> 与指定参数匹配的消息 `correlationId` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2345">This method looks in the non-transactional queue referenced by the <xref:System.Messaging.MessageQueue> for a message whose <xref:System.Messaging.Message.CorrelationId%2A> matches the specified `correlationId` parameter.</span></span> <span data-ttu-id="b3203-2346">如果未找到与参数匹配的消息 `correlationID` ，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-2346">If no message is found that matches the `correlationID` parameter, an exception is thrown.</span></span> <span data-ttu-id="b3203-2347">否则，将从队列中删除该消息并将其返回给应用程序。</span><span class="sxs-lookup"><span data-stu-id="b3203-2347">Otherwise, the message is removed from the queue and returned to the application.</span></span>  
  
 <span data-ttu-id="b3203-2348"><xref:System.Messaging.Message.CorrelationId%2A>属性用于将发送到队列的消息绑定到关联的响应、报告或确认消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2348">The <xref:System.Messaging.Message.CorrelationId%2A> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.</span></span>  
  
 <span data-ttu-id="b3203-2349">另外两种方法可用于从队列接收消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2349">Two other methods allow you to receive messages from a queue.</span></span> <span data-ttu-id="b3203-2350"><xref:System.Messaging.MessageQueue.Receive%2A>方法返回队列中的第一条消息， <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 方法通过指定消息的唯一标识符来检索消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2350">The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> method retrieves a message by specifying its unique identifier.</span></span>  
  
 <span data-ttu-id="b3203-2351">若要读取具有指定相关标识符的消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2351">To read a message with a specified correlation identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method.</span></span> <span data-ttu-id="b3203-2352"><xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2352">The <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span>  
  
 <span data-ttu-id="b3203-2353">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2353">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2354">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2354">Workgroup mode</span></span>|<span data-ttu-id="b3203-2355">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2355">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2356">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2356">Local computer</span></span>|<span data-ttu-id="b3203-2357">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2357">Yes</span></span>|  
|<span data-ttu-id="b3203-2358">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2358">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2359">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2359">Yes</span></span>|  
|<span data-ttu-id="b3203-2360">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2360">Remote computer</span></span>|<span data-ttu-id="b3203-2361">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2361">No</span></span>|  
|<span data-ttu-id="b3203-2362">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2362">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2363">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2363">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-2364">下面的代码示例在队列中发送和接收包含订单的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2364">The following code example sends and receives a message that contains an order to and from a queue.</span></span> <span data-ttu-id="b3203-2365">当原始消息到达或从队列中检索时，它专门请求肯定确认。</span><span class="sxs-lookup"><span data-stu-id="b3203-2365">It specifically requests a positive acknowledgment when the original message reaches or is retrieved from the queue.</span></span>  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3203-2366"><paramref name="correlationId" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2366">The <paramref name="correlationId" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b3203-2367">未能找到具有指定 <paramref name="correlationId" /> 的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2367">The message with the specified <paramref name="correlationId" /> could not be found.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-2368">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-2368">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId"><span data-ttu-id="b3203-2369">要接收的消息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2369">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to receive.</span></span></param>
        <param name="transaction"><span data-ttu-id="b3203-2370"><see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-2370">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</span></span></param>
        <summary><span data-ttu-id="b3203-2371">从事务性队列中接收与给定的相关标识符匹配的消息，而且在队列中当前不存在具有指定相关标识符的消息时立即引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-2371">Receives the message that matches the given correlation identifier (from a transactional queue) and immediately raises an exception if no message with the specified correlation identifier currently exists in the queue.</span></span></summary>
        <returns><span data-ttu-id="b3203-2372">其 <see cref="T:System.Messaging.Message" /> 匹配传入的 <paramref name="correlationId" /> 参数的 <see cref="P:System.Messaging.Message.CorrelationId" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2372">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2373">此方法在引用的事务性队列中查找 <xref:System.Messaging.MessageQueue> <xref:System.Messaging.Message.CorrelationId%2A> 与指定参数匹配的消息 `correlationId` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2373">This method looks in the transactional queue referenced by the <xref:System.Messaging.MessageQueue> for a message whose <xref:System.Messaging.Message.CorrelationId%2A> matches the specified `correlationId` parameter.</span></span> <span data-ttu-id="b3203-2374">如果未找到与参数匹配的消息 `correlationID` ，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-2374">If no message is found that matches the `correlationID` parameter, an exception is thrown.</span></span> <span data-ttu-id="b3203-2375">否则，将从队列中删除该消息，并使用由参数定义的内部事务上下文将该消息返回到应用程序 `transaction` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2375">Otherwise, the message is removed from the queue and returned to the application using the internal transaction context defined by the `transaction` parameter.</span></span>  
  
 <span data-ttu-id="b3203-2376">由于此方法是在事务队列中调用的，因此，如果事务中止，接收到的消息将返回到队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2376">Because this method is called on a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="b3203-2377">在提交事务之前，不会从队列中永久删除该消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2377">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="b3203-2378"><xref:System.Messaging.Message.CorrelationId%2A>属性用于将发送到队列的消息绑定到关联的响应、报告或确认消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2378">The <xref:System.Messaging.Message.CorrelationId%2A> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.</span></span>  
  
 <span data-ttu-id="b3203-2379">另外两种方法可用于从队列接收消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2379">Two other methods allow you to receive messages from a queue.</span></span> <span data-ttu-id="b3203-2380"><xref:System.Messaging.MessageQueue.Receive%2A>方法返回队列中的第一条消息，该 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 方法用于通过指定消息的唯一标识符来检索消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2380">The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> method is used to retrieve a message by specifying its unique identifier.</span></span>  
  
 <span data-ttu-id="b3203-2381">若要读取具有指定相关标识符的消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2381">To read a message with a specified correlation identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method.</span></span> <span data-ttu-id="b3203-2382"><xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2382">The <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span> <span data-ttu-id="b3203-2383">没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2383">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>.</span></span> <span data-ttu-id="b3203-2384">因为不 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 会删除队列中的任何消息，所以如果事务中止，则不会回滚任何内容。</span><span class="sxs-lookup"><span data-stu-id="b3203-2384">Because <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.</span></span>  
  
 <span data-ttu-id="b3203-2385">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2385">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2386">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2386">Workgroup mode</span></span>|<span data-ttu-id="b3203-2387">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2387">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2388">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2388">Local computer</span></span>|<span data-ttu-id="b3203-2389">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2389">Yes</span></span>|  
|<span data-ttu-id="b3203-2390">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2390">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2391">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2391">Yes</span></span>|  
|<span data-ttu-id="b3203-2392">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2392">Remote computer</span></span>|<span data-ttu-id="b3203-2393">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2393">No</span></span>|  
|<span data-ttu-id="b3203-2394">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2394">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2395">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2395">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-2396">以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29> 的用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2396">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3203-2397"><paramref name="correlationId" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2397">The <paramref name="correlationId" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="b3203-2398">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-2398">-or-</span></span> 
<span data-ttu-id="b3203-2399"><paramref name="transaction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2399">The <paramref name="transaction" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b3203-2400">未能找到具有指定 <paramref name="correlationId" /> 的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2400">The message with the specified <paramref name="correlationId" /> could not be found.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-2401">该队列为非事务性队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2401">The queue is non-transactional.</span></span>  
  
 <span data-ttu-id="b3203-2402">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-2402">-or-</span></span>  
  
 <span data-ttu-id="b3203-2403">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-2403">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId"><span data-ttu-id="b3203-2404">要接收的消息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2404">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to receive.</span></span></param>
        <param name="transactionType"><span data-ttu-id="b3203-2405"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文的类型。</span><span class="sxs-lookup"><span data-stu-id="b3203-2405">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span></span></param>
        <summary><span data-ttu-id="b3203-2406">接收匹配给定相关标识符的消息，而且在队列中当前不存在具有指定相关标识符的消息时立即引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-2406">Receives the message that matches the given correlation identifier and immediately raises an exception if no message with the specified correlation identifier currently exists in the queue.</span></span></summary>
        <returns><span data-ttu-id="b3203-2407">其 <see cref="T:System.Messaging.Message" /> 匹配传入的 <paramref name="correlationId" /> 参数的 <see cref="P:System.Messaging.Message.CorrelationId" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2407">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2408">此方法在引用的队列中查找 <xref:System.Messaging.MessageQueue> <xref:System.Messaging.Message.CorrelationId%2A> 与指定参数匹配的消息 `correlationId` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2408">This method looks in the queue referenced by the <xref:System.Messaging.MessageQueue> for a message whose <xref:System.Messaging.Message.CorrelationId%2A> matches the specified `correlationId` parameter.</span></span> <span data-ttu-id="b3203-2409">如果未找到与参数匹配的消息 `correlationID` ，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-2409">If no message is found that matches the `correlationID` parameter, an exception is thrown.</span></span> <span data-ttu-id="b3203-2410">否则，将从队列中删除该消息，并使用由参数定义的事务上下文将该消息返回到应用程序 `transactionType` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2410">Otherwise, the message is removed from the queue and returned to the application using a transaction context defined by the `transactionType` parameter.</span></span>  
  
 <span data-ttu-id="b3203-2411">`Automatic` `transactionType` 如果已存在附加到要用于接收消息的线程的外部事务上下文，请为参数指定。</span><span class="sxs-lookup"><span data-stu-id="b3203-2411">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</span></span> <span data-ttu-id="b3203-2412">指定 `Single` 是否要以单个内部事务的形式接收消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2412">Specify `Single` if you want to receive the message as a single internal transaction.</span></span> <span data-ttu-id="b3203-2413">您可以指定 `None` 是否要在事务上下文之外接收来自事务性队列的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2413">You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.</span></span>  
  
 <span data-ttu-id="b3203-2414">如果调用此方法来接收来自事务性队列的消息，则在事务中止时，收到的消息将返回到队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2414">If this method is called to receive a message from a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="b3203-2415">在提交事务之前，不会从队列中永久删除该消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2415">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="b3203-2416"><xref:System.Messaging.Message.CorrelationId%2A>属性用于将发送到队列的消息绑定到关联的响应、报告或确认消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2416">The <xref:System.Messaging.Message.CorrelationId%2A> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.</span></span>  
  
 <span data-ttu-id="b3203-2417">另外两种方法可用于从队列接收消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2417">Two other methods allow you to receive messages from a queue.</span></span> <span data-ttu-id="b3203-2418"><xref:System.Messaging.MessageQueue.Receive%2A>方法返回队列中的第一条消息，该 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 方法用于通过指定消息的唯一标识符来检索消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2418">The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> method is used to retrieve a message by specifying its unique identifier.</span></span>  
  
 <span data-ttu-id="b3203-2419">若要读取具有指定相关标识符的消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2419">To read a message with a specified correlation identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method.</span></span> <span data-ttu-id="b3203-2420"><xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2420">The <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span> <span data-ttu-id="b3203-2421">没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2421">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>.</span></span> <span data-ttu-id="b3203-2422">因为不 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 会删除队列中的任何消息，所以如果事务中止，则不会回滚任何内容。</span><span class="sxs-lookup"><span data-stu-id="b3203-2422">Because <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.</span></span>  
  
 <span data-ttu-id="b3203-2423">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2423">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2424">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2424">Workgroup mode</span></span>|<span data-ttu-id="b3203-2425">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2425">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2426">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2426">Local computer</span></span>|<span data-ttu-id="b3203-2427">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2427">Yes</span></span>|  
|<span data-ttu-id="b3203-2428">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2428">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2429">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2429">Yes</span></span>|  
|<span data-ttu-id="b3203-2430">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2430">Remote computer</span></span>|<span data-ttu-id="b3203-2431">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2431">No</span></span>|  
|<span data-ttu-id="b3203-2432">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2432">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2433">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2433">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-2434">以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2434">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3203-2435"><paramref name="correlationId" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2435">The <paramref name="correlationId" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b3203-2436">未能找到具有指定 <paramref name="correlationId" /> 的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2436">The message with the specified <paramref name="correlationId" /> could not be found.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="b3203-2437"><paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</span><span class="sxs-lookup"><span data-stu-id="b3203-2437">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-2438">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-2438">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId"><span data-ttu-id="b3203-2439">要接收的消息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2439">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to receive.</span></span></param>
        <param name="timeout"><span data-ttu-id="b3203-2440">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-2440">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</span></span></param>
        <summary><span data-ttu-id="b3203-2441">从非事务性队列中接收与给定的相关标识符匹配的消息，并且一直等到队列中出现具有指定相关标识符的消息或者超时过期。</span><span class="sxs-lookup"><span data-stu-id="b3203-2441">Receives the message that matches the given correlation identifier (from a non-transactional queue) and waits until either a message with the specified correlation identifier is available in the queue, or the time-out expires.</span></span></summary>
        <returns><span data-ttu-id="b3203-2442">其 <see cref="T:System.Messaging.Message" /> 匹配传入的 <paramref name="correlationId" /> 参数的 <see cref="P:System.Messaging.Message.CorrelationId" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2442">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2443">此方法在引用的非事务性队列中查找 <xref:System.Messaging.MessageQueue> <xref:System.Messaging.Message.CorrelationId%2A> 与指定参数匹配的消息 `correlationId` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2443">This method looks in the non-transactional queue referenced by the <xref:System.Messaging.MessageQueue> for a message whose <xref:System.Messaging.Message.CorrelationId%2A> matches the specified `correlationId` parameter.</span></span> <span data-ttu-id="b3203-2444">如果具有参数指定的相关标识符的消息 `correlationId` 在队列中，则此方法立即返回。</span><span class="sxs-lookup"><span data-stu-id="b3203-2444">This method returns immediately if the message with the correlation identifier specified by the `correlationId` parameter is in the queue.</span></span> <span data-ttu-id="b3203-2445">否则，该方法将在给定的时间段内等待新消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2445">Otherwise, the method waits the given period of time for a new message to arrive.</span></span> <span data-ttu-id="b3203-2446">如果新消息在超时过期之前未到达，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-2446">If a new message does not arrive before the time-out expires, an exception is thrown.</span></span>  
  
 <span data-ttu-id="b3203-2447">`timeout`参数未指定此方法的总运行时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-2447">The `timeout` parameter does not specify the total running time for this method.</span></span> <span data-ttu-id="b3203-2448">相反，它指定等待新消息到达队列的时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-2448">Rather, it specifies the time to wait for a new message to arrive in the queue.</span></span> <span data-ttu-id="b3203-2449">每当新消息到达时，此方法将检查 <xref:System.Messaging.Message.CorrelationId%2A> 新消息的，以查看它是否与参数匹配 `correlationId` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2449">Each time a new message arrives, this method examines the <xref:System.Messaging.Message.CorrelationId%2A> of the new message to see if it matches the `correlationId` parameter.</span></span> <span data-ttu-id="b3203-2450">否则，此方法将启动超时期限并等待另一个新消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2450">If not, this method starts the time-out period over and waits for another new message to arrive.</span></span> <span data-ttu-id="b3203-2451">因此，如果新消息在超时期限内继续到达，则此方法可能会无限期地继续运行，直到超时期限过期，无需收到任何新消息，或直到到达其 <xref:System.Messaging.Message.CorrelationId%2A> 与参数匹配的消息 `correlationId` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2451">Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <xref:System.Messaging.Message.CorrelationId%2A> matches the `correlationId` parameter.</span></span>  
  
 <span data-ttu-id="b3203-2452"><xref:System.Messaging.Message.CorrelationId%2A>属性用于将发送到队列的消息绑定到关联的响应、报告或确认消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2452">The <xref:System.Messaging.Message.CorrelationId%2A> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.</span></span>  
  
 <span data-ttu-id="b3203-2453">另外两种方法可用于从队列接收消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2453">Two other methods allow you to receive messages from a queue.</span></span> <span data-ttu-id="b3203-2454"><xref:System.Messaging.MessageQueue.Receive%2A>方法返回队列中的第一条消息，该 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 方法用于通过指定消息的唯一标识符来检索消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2454">The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> method is used to retrieve a message by specifying its unique identifier.</span></span>  
  
 <span data-ttu-id="b3203-2455">若要读取具有指定相关标识符的消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2455">To read a message with a specified correlation identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method.</span></span> <span data-ttu-id="b3203-2456"><xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2456">The <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span>  
  
 <span data-ttu-id="b3203-2457">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2457">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2458">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2458">Workgroup mode</span></span>|<span data-ttu-id="b3203-2459">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2459">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2460">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2460">Local computer</span></span>|<span data-ttu-id="b3203-2461">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2461">Yes</span></span>|  
|<span data-ttu-id="b3203-2462">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2462">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2463">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2463">Yes</span></span>|  
|<span data-ttu-id="b3203-2464">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2464">Remote computer</span></span>|<span data-ttu-id="b3203-2465">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2465">No</span></span>|  
|<span data-ttu-id="b3203-2466">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2466">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2467">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2467">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-2468">以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29> 的用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2468">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3203-2469"><paramref name="correlationId" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2469">The <paramref name="correlationId" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-2470">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2470">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-2471">具有指定 <paramref name="correlationId" /> 的消息不在队列中，而且在超时过期之前没有到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2471">The message with the specified <paramref name="correlationId" /> does not exist in the queue and did not arrive before the time-out expired.</span></span>  
  
<span data-ttu-id="b3203-2472">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-2472">-or-</span></span> 
<span data-ttu-id="b3203-2473">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-2473">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId"><span data-ttu-id="b3203-2474">要接收的消息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2474">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to receive.</span></span></param>
        <param name="timeout"><span data-ttu-id="b3203-2475">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-2475">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</span></span></param>
        <param name="transaction"><span data-ttu-id="b3203-2476"><see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-2476">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</span></span></param>
        <summary><span data-ttu-id="b3203-2477">从事务性队列中接收与给定的相关标识符匹配的消息，并且一直等到队列中出现具有指定相关标识符的消息或者超时过期。</span><span class="sxs-lookup"><span data-stu-id="b3203-2477">Receives the message that matches the given correlation identifier (from a transactional queue) and waits until either a message with the specified correlation identifier is available in the queue, or the time-out expires.</span></span></summary>
        <returns><span data-ttu-id="b3203-2478">其 <see cref="T:System.Messaging.Message" /> 匹配传入的 <paramref name="correlationId" /> 参数的 <see cref="P:System.Messaging.Message.CorrelationId" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2478">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2479">此方法在引用的事务性队列中查找 <xref:System.Messaging.MessageQueue> <xref:System.Messaging.Message.CorrelationId%2A> 与指定参数匹配的消息 `correlationId` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2479">This method looks in the transactional queue referenced by the <xref:System.Messaging.MessageQueue> for a message whose <xref:System.Messaging.Message.CorrelationId%2A> matches the specified `correlationId` parameter.</span></span> <span data-ttu-id="b3203-2480">如果使用参数定义的相关标识符的消息 `correlationId` 在队列中，则此方法将立即返回 `transaction` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2480">This method returns immediately if the message with the correlation identifier specified by the `correlationId` parameter is in the queue, using the internal transaction context defined by the `transaction` parameter.</span></span> <span data-ttu-id="b3203-2481">否则，该方法将在给定的时间段内等待新消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2481">Otherwise, the method waits the given period of time for a new message to arrive.</span></span> <span data-ttu-id="b3203-2482">如果新消息在超时过期之前未到达，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-2482">If a new message does not arrive before the time-out expires, an exception is thrown.</span></span>  
  
 <span data-ttu-id="b3203-2483">`timeout`参数未指定此方法的总运行时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-2483">The `timeout` parameter does not specify the total running time for this method.</span></span> <span data-ttu-id="b3203-2484">相反，它指定等待新消息到达队列的时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-2484">Rather, it specifies the time to wait for a new message to arrive in the queue.</span></span> <span data-ttu-id="b3203-2485">每当新消息到达时，此方法将检查 <xref:System.Messaging.Message.CorrelationId%2A> 新消息的，以查看它是否与参数匹配 `correlationId` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2485">Each time a new message arrives, this method examines the <xref:System.Messaging.Message.CorrelationId%2A> of the new message to see if it matches the `correlationId` parameter.</span></span> <span data-ttu-id="b3203-2486">否则，此方法将启动超时期限并等待另一个新消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2486">If not, this method starts the time-out period over and waits for another new message to arrive.</span></span> <span data-ttu-id="b3203-2487">因此，如果新消息在超时期限内继续到达，则此方法可能会无限期地继续运行，直到超时期限过期，无需收到任何新消息，或直到到达其 <xref:System.Messaging.Message.CorrelationId%2A> 与参数匹配的消息 `correlationId` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2487">Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <xref:System.Messaging.Message.CorrelationId%2A> matches the `correlationId` parameter.</span></span>  
  
 <span data-ttu-id="b3203-2488">由于此方法是在事务队列中调用的，因此，如果事务中止，接收到的消息将返回到队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2488">Because this method is called on a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="b3203-2489">在提交事务之前，不会从队列中永久删除该消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2489">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="b3203-2490"><xref:System.Messaging.Message.CorrelationId%2A>属性用于将发送到队列的消息绑定到关联的响应、报告或确认消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2490">The <xref:System.Messaging.Message.CorrelationId%2A> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.</span></span>  
  
 <span data-ttu-id="b3203-2491">另外两种方法可用于从队列接收消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2491">Two other methods allow you to receive messages from a queue.</span></span> <span data-ttu-id="b3203-2492"><xref:System.Messaging.MessageQueue.Receive%2A>方法返回队列中的第一条消息，该 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 方法用于通过指定消息的唯一标识符来检索消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2492">The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> method is used to retrieve a message by specifying its unique identifier.</span></span>  
  
 <span data-ttu-id="b3203-2493">若要读取具有指定相关标识符的消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2493">To read a message with a specified correlation identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method.</span></span> <span data-ttu-id="b3203-2494"><xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2494">The <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span> <span data-ttu-id="b3203-2495">没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2495">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>.</span></span> <span data-ttu-id="b3203-2496">因为不 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 会删除队列中的任何消息，所以如果事务中止，则不会回滚任何内容。</span><span class="sxs-lookup"><span data-stu-id="b3203-2496">Because <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.</span></span>  
  
 <span data-ttu-id="b3203-2497">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2497">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2498">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2498">Workgroup mode</span></span>|<span data-ttu-id="b3203-2499">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2499">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2500">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2500">Local computer</span></span>|<span data-ttu-id="b3203-2501">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2501">Yes</span></span>|  
|<span data-ttu-id="b3203-2502">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2502">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2503">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2503">Yes</span></span>|  
|<span data-ttu-id="b3203-2504">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2504">Remote computer</span></span>|<span data-ttu-id="b3203-2505">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2505">No</span></span>|  
|<span data-ttu-id="b3203-2506">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2506">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2507">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2507">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-2508">以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29> 的用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2508">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3203-2509"><paramref name="correlationId" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2509">The <paramref name="correlationId" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="b3203-2510">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-2510">-or-</span></span> 
<span data-ttu-id="b3203-2511"><paramref name="transaction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2511">The <paramref name="transaction" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-2512">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2512">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-2513">具有指定 <paramref name="correlationId" /> 的消息不在队列中，而且在超时过期之前没有到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2513">The message with the specified <paramref name="correlationId" /> does not exist in the queue and did not arrive before the time-out expired.</span></span>  
  
<span data-ttu-id="b3203-2514">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-2514">-or-</span></span> 
<span data-ttu-id="b3203-2515">该队列为非事务性队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2515">The queue is non-transactional.</span></span>  
  
<span data-ttu-id="b3203-2516">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-2516">-or-</span></span> 
<span data-ttu-id="b3203-2517">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-2517">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId"><span data-ttu-id="b3203-2518">要接收的消息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2518">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to receive.</span></span></param>
        <param name="timeout"><span data-ttu-id="b3203-2519">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-2519">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</span></span></param>
        <param name="transactionType"><span data-ttu-id="b3203-2520"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文的类型。</span><span class="sxs-lookup"><span data-stu-id="b3203-2520">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span></span></param>
        <summary><span data-ttu-id="b3203-2521">接收与给定的相关标识符匹配的消息，并且一直等到队列中出现具有指定相关标识符的消息或超时过期。</span><span class="sxs-lookup"><span data-stu-id="b3203-2521">Receives the message that matches the given correlation identifier and waits until either a message with the specified correlation identifier is available in the queue, or the time-out expires.</span></span></summary>
        <returns><span data-ttu-id="b3203-2522">其 <see cref="T:System.Messaging.Message" /> 匹配传入的 <paramref name="correlationId" /> 参数的 <see cref="P:System.Messaging.Message.CorrelationId" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2522">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2523">此方法在引用的队列中查找 <xref:System.Messaging.MessageQueue> <xref:System.Messaging.Message.CorrelationId%2A> 与指定参数匹配的消息 `correlationId` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2523">This method looks in the queue referenced by the <xref:System.Messaging.MessageQueue> for a message whose <xref:System.Messaging.Message.CorrelationId%2A> matches the specified `correlationId` parameter.</span></span> <span data-ttu-id="b3203-2524">如果使用参数定义的相关标识符的消息 `correlationId` 在队列中，则此方法立即返回 `transactionType` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2524">This method returns immediately if the message with the correlation identifier specified by the `correlationId` parameter is in the queue, using a transaction context defined by the `transactionType` parameter.</span></span> <span data-ttu-id="b3203-2525">否则，该方法将在给定的时间段内等待新消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2525">Otherwise, the method waits the given period of time for a new message to arrive.</span></span> <span data-ttu-id="b3203-2526">如果新消息在超时过期之前未到达，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-2526">If a new message does not arrive before the time-out expires, an exception is thrown.</span></span>  
  
 <span data-ttu-id="b3203-2527">`timeout`参数未指定此方法的总运行时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-2527">The `timeout` parameter does not specify the total running time for this method.</span></span> <span data-ttu-id="b3203-2528">相反，它指定等待新消息到达队列的时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-2528">Rather, it specifies the time to wait for a new message to arrive in the queue.</span></span> <span data-ttu-id="b3203-2529">每当新消息到达时，此方法将检查 <xref:System.Messaging.Message.CorrelationId%2A> 新消息的，以查看它是否与参数匹配 `correlationId` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2529">Each time a new message arrives, this method examines the <xref:System.Messaging.Message.CorrelationId%2A> of the new message to see if it matches the `correlationId` parameter.</span></span> <span data-ttu-id="b3203-2530">否则，此方法将启动超时期限并等待另一个新消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2530">If not, this method starts the time-out period over and waits for another new message to arrive.</span></span> <span data-ttu-id="b3203-2531">因此，如果新消息在超时期限内继续到达，则此方法可能会无限期地继续运行，直到超时期限过期，无需收到任何新消息，或直到到达其 <xref:System.Messaging.Message.CorrelationId%2A> 与参数匹配的消息 `correlationId` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2531">Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <xref:System.Messaging.Message.CorrelationId%2A> matches the `correlationId` parameter.</span></span> <span data-ttu-id="b3203-2532">`Automatic` `transactionType` 如果已存在附加到要用于接收消息的线程的外部事务上下文，请为参数指定。</span><span class="sxs-lookup"><span data-stu-id="b3203-2532">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</span></span> <span data-ttu-id="b3203-2533">指定 `Single` 是否要以单个内部事务的形式接收消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2533">Specify `Single` if you want to receive the message as a single internal transaction.</span></span> <span data-ttu-id="b3203-2534">您可以指定 `None` 是否要在事务上下文之外接收来自事务性队列的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2534">You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.</span></span>  
  
 <span data-ttu-id="b3203-2535">如果调用此方法来接收来自事务性队列的消息，则在事务中止时，收到的消息将返回到队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2535">If this method is called to receive a message from a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="b3203-2536">在提交事务之前，不会从队列中永久删除该消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2536">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="b3203-2537"><xref:System.Messaging.Message.CorrelationId%2A>属性用于将发送到队列的消息绑定到关联的响应、报告或确认消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2537">The <xref:System.Messaging.Message.CorrelationId%2A> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.</span></span>  
  
 <span data-ttu-id="b3203-2538">另外两种方法可用于从队列接收消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2538">Two other methods allow you to receive messages from a queue.</span></span> <span data-ttu-id="b3203-2539"><xref:System.Messaging.MessageQueue.Receive%2A>方法返回队列中的第一条消息，该 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 方法用于通过指定消息的唯一标识符来检索消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2539">The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> method is used to retrieve a message by specifying its unique identifier.</span></span>  
  
 <span data-ttu-id="b3203-2540">若要读取具有指定相关标识符的消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2540">To read a message with a specified correlation identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method.</span></span> <span data-ttu-id="b3203-2541"><xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2541">The <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span> <span data-ttu-id="b3203-2542">没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2542">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>.</span></span> <span data-ttu-id="b3203-2543">因为不 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 会删除队列中的任何消息，所以如果事务中止，则不会回滚任何内容。</span><span class="sxs-lookup"><span data-stu-id="b3203-2543">Because <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.</span></span>  
  
 <span data-ttu-id="b3203-2544">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2544">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2545">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2545">Workgroup mode</span></span>|<span data-ttu-id="b3203-2546">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2546">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2547">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2547">Local computer</span></span>|<span data-ttu-id="b3203-2548">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2548">Yes</span></span>|  
|<span data-ttu-id="b3203-2549">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2549">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2550">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2550">Yes</span></span>|  
|<span data-ttu-id="b3203-2551">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2551">Remote computer</span></span>|<span data-ttu-id="b3203-2552">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2552">No</span></span>|  
|<span data-ttu-id="b3203-2553">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2553">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2554">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2554">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-2555">以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2555">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3203-2556"><paramref name="correlationId" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2556">The <paramref name="correlationId" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b3203-2557">未能找到具有指定 <paramref name="correlationId" /> 的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2557">The message with the specified <paramref name="correlationId" /> could not be found.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-2558">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2558">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="b3203-2559"><paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</span><span class="sxs-lookup"><span data-stu-id="b3203-2559">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-2560">具有指定 <paramref name="correlationId" /> 的消息不在队列中，而且在超时过期之前没有到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2560">The message with the specified <paramref name="correlationId" /> does not exist in the queue and did not arrive before the time-out expired.</span></span>  
  
<span data-ttu-id="b3203-2561">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-2561">-or-</span></span> 
<span data-ttu-id="b3203-2562">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-2562">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b3203-2563">接收匹配给定标识符的消息，并将其从队列中移除。</span><span class="sxs-lookup"><span data-stu-id="b3203-2563">Receives the message that matches the given identifier, removing it from the queue.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id"><span data-ttu-id="b3203-2564">要接收的消息的 <see cref="P:System.Messaging.Message.Id" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2564">The <see cref="P:System.Messaging.Message.Id" /> of the message to receive.</span></span></param>
        <summary><span data-ttu-id="b3203-2565">从非事务性队列中接收与给定的标识符匹配的消息，而且在队列中当前不存在具有指定标识符的消息时立即引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-2565">Receives the message that matches the given identifier from a non-transactional queue and immediately raises an exception if no message with the specified identifier currently exists in the queue.</span></span></summary>
        <returns><span data-ttu-id="b3203-2566"><see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.Id" /> 属性匹配传入的 <paramref name="id" /> 参数。</span><span class="sxs-lookup"><span data-stu-id="b3203-2566">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2567">使用此方法可以读取具有已知标识符的消息，并将其从队列中删除。</span><span class="sxs-lookup"><span data-stu-id="b3203-2567">Use this method to read a message with a known identifier and remove it from the queue.</span></span> <span data-ttu-id="b3203-2568">如果消息不在队列中，此方法会立即引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-2568">This method throws an exception immediately if the message is not in the queue.</span></span>  
  
 <span data-ttu-id="b3203-2569"><xref:System.Messaging.Message.Id%2A>消息的属性在消息队列企业中是唯一的，因此队列中最多只有一个与给定参数匹配的消息 `id` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2569">The <xref:System.Messaging.Message.Id%2A> property of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given `id` parameter.</span></span>  
  
 <span data-ttu-id="b3203-2570">另外两种方法可用于从队列接收消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2570">Two other methods allow you to receive messages from a queue.</span></span> <span data-ttu-id="b3203-2571"><xref:System.Messaging.MessageQueue.Receive%2A>方法返回队列中的第一条消息， <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 方法用于检索确认、报告或由应用程序生成的响应消息，该消息是作为发送到队列的消息的结果创建的。</span><span class="sxs-lookup"><span data-stu-id="b3203-2571">The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> method is used to retrieve an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.</span></span>  
  
 <span data-ttu-id="b3203-2572">若要读取具有指定标识符的消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2572">To read a message with a specified identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method.</span></span> <span data-ttu-id="b3203-2573"><xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2573">The <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span>  
  
 <span data-ttu-id="b3203-2574">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2574">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2575">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2575">Workgroup mode</span></span>|<span data-ttu-id="b3203-2576">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2576">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2577">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2577">Local computer</span></span>|<span data-ttu-id="b3203-2578">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2578">Yes</span></span>|  
|<span data-ttu-id="b3203-2579">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2579">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2580">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2580">Yes</span></span>|  
|<span data-ttu-id="b3203-2581">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2581">Remote computer</span></span>|<span data-ttu-id="b3203-2582">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2582">No</span></span>|  
|<span data-ttu-id="b3203-2583">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2583">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2584">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2584">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-2585">以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 的用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2585">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3203-2586"><paramref name="id" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2586">The <paramref name="id" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b3203-2587">未能找到具有指定 <paramref name="id" /> 的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2587">The message with the specified <paramref name="id" /> could not be found.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-2588">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-2588">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id"><span data-ttu-id="b3203-2589">要接收的消息的 <see cref="P:System.Messaging.Message.Id" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2589">The <see cref="P:System.Messaging.Message.Id" /> of the message to receive.</span></span></param>
        <param name="transaction"><span data-ttu-id="b3203-2590"><see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-2590">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</span></span></param>
        <summary><span data-ttu-id="b3203-2591">从事务性队列中接收与给定的标识符匹配的消息，而且在队列中当前不存在具有指定标识符的消息时立即引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-2591">Receives the message that matches the given identifier (from a transactional queue) and immediately raises an exception if no message with the specified identifier currently exists in the queue.</span></span></summary>
        <returns><span data-ttu-id="b3203-2592"><see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.Id" /> 属性匹配传入的 <paramref name="id" /> 参数。</span><span class="sxs-lookup"><span data-stu-id="b3203-2592">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2593">使用此方法可以读取具有已知标识符的消息，并使用由参数定义的内部事务上下文从队列中删除该消息 `transaction` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2593">Use this method to read a message with a known identifier and remove it from the queue, using the internal transaction context defined by the `transaction` parameter.</span></span> <span data-ttu-id="b3203-2594">如果消息不在队列中，此方法会立即引发异常</span><span class="sxs-lookup"><span data-stu-id="b3203-2594">This method throws an exception immediately if the message is not in the queue</span></span>  
  
 <span data-ttu-id="b3203-2595"><xref:System.Messaging.Message.Id%2A>消息的属性在消息队列企业中是唯一的，因此队列中最多只有一个与给定参数匹配的消息 `id` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2595">The <xref:System.Messaging.Message.Id%2A> property of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given `id` parameter.</span></span>  
  
 <span data-ttu-id="b3203-2596">由于此方法是在事务队列中调用的，因此，如果事务中止，接收到的消息将返回到队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2596">Because this method is called on a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="b3203-2597">在提交事务之前，不会从队列中永久删除该消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2597">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="b3203-2598">另外两种方法可用于从队列接收消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2598">Two other methods allow you to receive messages from a queue.</span></span> <span data-ttu-id="b3203-2599"><xref:System.Messaging.MessageQueue.Receive%2A>方法返回队列中的第一条消息， <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 方法用于检索确认、报告或由应用程序生成的响应消息，该消息是作为发送到队列的消息的结果创建的。</span><span class="sxs-lookup"><span data-stu-id="b3203-2599">The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> method is used to retrieve an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.</span></span>  
  
 <span data-ttu-id="b3203-2600">若要读取具有指定标识符的消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2600">To read a message with a specified identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method.</span></span> <span data-ttu-id="b3203-2601"><xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2601">The <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span> <span data-ttu-id="b3203-2602">没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2602">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>.</span></span> <span data-ttu-id="b3203-2603">因为不 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 会删除队列中的任何消息，所以如果事务中止，则不会回滚任何内容。</span><span class="sxs-lookup"><span data-stu-id="b3203-2603">Because <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.</span></span>  
  
 <span data-ttu-id="b3203-2604">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2604">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2605">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2605">Workgroup mode</span></span>|<span data-ttu-id="b3203-2606">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2606">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2607">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2607">Local computer</span></span>|<span data-ttu-id="b3203-2608">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2608">Yes</span></span>|  
|<span data-ttu-id="b3203-2609">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2609">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2610">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2610">Yes</span></span>|  
|<span data-ttu-id="b3203-2611">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2611">Remote computer</span></span>|<span data-ttu-id="b3203-2612">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2612">No</span></span>|  
|<span data-ttu-id="b3203-2613">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2613">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2614">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2614">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-2615">以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29> 的用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2615">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3203-2616"><paramref name="id" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2616">The <paramref name="id" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="b3203-2617">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-2617">-or-</span></span> 
<span data-ttu-id="b3203-2618"><paramref name="transaction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2618">The <paramref name="transaction" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b3203-2619">未能找到具有指定 <paramref name="id" /> 的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2619">The message with the specified <paramref name="id" /> could not be found.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-2620">该队列为非事务性队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2620">The queue is non-transactional.</span></span>  
  
 <span data-ttu-id="b3203-2621">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-2621">-or-</span></span>  
  
 <span data-ttu-id="b3203-2622">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-2622">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id"><span data-ttu-id="b3203-2623">要接收的消息的 <see cref="P:System.Messaging.Message.Id" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2623">The <see cref="P:System.Messaging.Message.Id" /> of the message to receive.</span></span></param>
        <param name="transactionType"><span data-ttu-id="b3203-2624"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文的类型。</span><span class="sxs-lookup"><span data-stu-id="b3203-2624">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span></span></param>
        <summary><span data-ttu-id="b3203-2625">接收与给定的标识符匹配的消息，而且在队列中当前不存在具有指定标识符的消息时立即引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-2625">Receives the message that matches the given identifier and immediately raises an exception if no message with the specified identifier currently exists in the queue.</span></span></summary>
        <returns><span data-ttu-id="b3203-2626"><see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.Id" /> 属性匹配传入的 <paramref name="id" /> 参数。</span><span class="sxs-lookup"><span data-stu-id="b3203-2626">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2627">使用此方法可以读取具有已知标识符的消息，并将其从队列中删除。</span><span class="sxs-lookup"><span data-stu-id="b3203-2627">Use this method to read a message with a known identifier and remove it from the queue.</span></span> <span data-ttu-id="b3203-2628">如果消息不在队列中，此方法会立即引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-2628">This method throws an exception immediately if the message is not in the queue.</span></span> <span data-ttu-id="b3203-2629">否则，将从队列中删除该消息，并使用由参数定义的事务上下文将该消息返回到应用程序 `transactionType` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2629">Otherwise, the message is removed from the queue and returned to the application using a transaction context defined by the `transactionType` parameter.</span></span>  
  
 <span data-ttu-id="b3203-2630">`Automatic` `transactionType` 如果已存在附加到要用于接收消息的线程的外部事务上下文，请为参数指定。</span><span class="sxs-lookup"><span data-stu-id="b3203-2630">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</span></span> <span data-ttu-id="b3203-2631">指定 `Single` 是否要以单个内部事务的形式接收消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2631">Specify `Single` if you want to receive the message as a single internal transaction.</span></span> <span data-ttu-id="b3203-2632">您可以指定 `None` 是否要在事务上下文之外接收来自事务性队列的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2632">You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.</span></span>  
  
 <span data-ttu-id="b3203-2633"><xref:System.Messaging.Message.Id%2A>消息的属性在消息队列企业中是唯一的，因此队列中最多只有一个与给定参数匹配的消息 `id` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2633">The <xref:System.Messaging.Message.Id%2A> property of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given `id` parameter.</span></span> <span data-ttu-id="b3203-2634">如果具有指定标识符的消息位于与此实例关联的队列中 <xref:System.Messaging.MessageQueue> ，则将找不到该消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2634">If the message with the specified identifier is in a queue other than the one associated with this <xref:System.Messaging.MessageQueue> instance, the message will not be found.</span></span>  
  
 <span data-ttu-id="b3203-2635">如果调用此方法来接收来自事务性队列的消息，则在事务中止时，收到的消息将返回到队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2635">If this method is called to receive a message from a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="b3203-2636">在提交事务之前，不会从队列中永久删除该消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2636">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="b3203-2637">另外两种方法可用于从队列接收消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2637">Two other methods allow you to receive messages from a queue.</span></span> <span data-ttu-id="b3203-2638"><xref:System.Messaging.MessageQueue.Receive%2A>方法返回队列中的第一条消息， <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 方法用于检索确认、报告或由应用程序生成的响应消息，该消息是作为发送到队列的消息的结果创建的。</span><span class="sxs-lookup"><span data-stu-id="b3203-2638">The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> method is used to retrieve an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.</span></span>  
  
 <span data-ttu-id="b3203-2639">若要读取具有指定标识符的消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2639">To read a message with a specified identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method.</span></span> <span data-ttu-id="b3203-2640"><xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2640">The <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span> <span data-ttu-id="b3203-2641">没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2641">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>.</span></span> <span data-ttu-id="b3203-2642">因为不 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 会删除队列中的任何消息，所以如果事务中止，则不会回滚任何内容。</span><span class="sxs-lookup"><span data-stu-id="b3203-2642">Because <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.</span></span>  
  
 <span data-ttu-id="b3203-2643">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2643">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2644">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2644">Workgroup mode</span></span>|<span data-ttu-id="b3203-2645">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2645">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2646">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2646">Local computer</span></span>|<span data-ttu-id="b3203-2647">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2647">Yes</span></span>|  
|<span data-ttu-id="b3203-2648">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2648">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2649">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2649">Yes</span></span>|  
|<span data-ttu-id="b3203-2650">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2650">Remote computer</span></span>|<span data-ttu-id="b3203-2651">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2651">No</span></span>|  
|<span data-ttu-id="b3203-2652">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2652">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2653">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2653">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-2654">以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2654">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3203-2655"><paramref name="id" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2655">The <paramref name="id" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b3203-2656">未能找到具有指定 <paramref name="id" /> 的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2656">The message with the specified <paramref name="id" /> could not be found.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="b3203-2657"><paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</span><span class="sxs-lookup"><span data-stu-id="b3203-2657">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-2658">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-2658">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id"><span data-ttu-id="b3203-2659">要接收的消息的 <see cref="P:System.Messaging.Message.Id" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2659">The <see cref="P:System.Messaging.Message.Id" /> of the message to receive.</span></span></param>
        <param name="timeout"><span data-ttu-id="b3203-2660">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-2660">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</span></span></param>
        <summary><span data-ttu-id="b3203-2661">从非事务性队列接收与给定的标识符匹配的消息，并且一直等到队列中出现具有指定标识符的消息或超时过期。</span><span class="sxs-lookup"><span data-stu-id="b3203-2661">Receives the message that matches the given identifier (from a non-transactional queue) and waits until either a message with the specified identifier is available in the queue or the time-out expires.</span></span></summary>
        <returns><span data-ttu-id="b3203-2662"><see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.Id" /> 属性匹配传入的 <paramref name="id" /> 参数。</span><span class="sxs-lookup"><span data-stu-id="b3203-2662">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2663">使用此方法可以读取具有已知标识符的消息，并将其从队列中删除。</span><span class="sxs-lookup"><span data-stu-id="b3203-2663">Use this method to read a message with a known identifier and remove it from the queue.</span></span> <span data-ttu-id="b3203-2664">如果具有参数指定的标识符的消息在队列中，则此方法立即返回 `id` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2664">This method returns immediately if the message with the identifier specified by the `id` parameter is in the queue.</span></span> <span data-ttu-id="b3203-2665">否则，该方法将在给定的时间段内等待新消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2665">Otherwise, the method waits the given period of time for a new message to arrive.</span></span> <span data-ttu-id="b3203-2666">如果新消息在超时过期之前未到达，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-2666">If a new message does not arrive before the time-out expires, an exception is thrown.</span></span>  
  
 <span data-ttu-id="b3203-2667">`timeout`参数未指定此方法的总运行时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-2667">The `timeout` parameter does not specify the total running time for this method.</span></span> <span data-ttu-id="b3203-2668">相反，它指定等待新消息到达队列的时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-2668">Rather, it specifies the time to wait for a new message to arrive in the queue.</span></span> <span data-ttu-id="b3203-2669">每当新消息到达时，此方法将检查 <xref:System.Messaging.Message.Id%2A> 新消息的，以查看它是否与参数匹配 `id` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2669">Each time a new message arrives, this method examines the <xref:System.Messaging.Message.Id%2A> of the new message to see if it matches the `id` parameter.</span></span> <span data-ttu-id="b3203-2670">否则，此方法将启动超时期限并等待另一个新消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2670">If not, this method starts the time-out period over and waits for another new message to arrive.</span></span> <span data-ttu-id="b3203-2671">因此，如果新消息在超时期限内继续到达，则此方法可能会无限期地继续运行，直到超时期限过期，无需收到任何新消息，或直到到达其 <xref:System.Messaging.Message.Id%2A> 与参数匹配的消息 `id` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2671">Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <xref:System.Messaging.Message.Id%2A> matches the `id` parameter.</span></span>  
  
 <span data-ttu-id="b3203-2672"><xref:System.Messaging.Message.Id%2A>消息的属性在消息队列企业中是唯一的，因此队列中最多只有一个与给定参数匹配的消息 `id` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2672">The <xref:System.Messaging.Message.Id%2A> property of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given `id` parameter.</span></span>  
  
 <span data-ttu-id="b3203-2673">当当前线程被阻止时，可以使用的此重载，只要 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 新消息在参数指定的超时期限内继续到达队列中即可 `timeout` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2673">Use this overload of <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> when it is acceptable for the current thread to be blocked as long as new messages continue to arrive in the queue within the time-out period specified by the `timeout` parameter.</span></span> <span data-ttu-id="b3203-2674">如果为参数指定了值 <xref:System.Messaging.MessageQueue.InfiniteTimeout> `timeout` ，或者在参数指定的超时期限内新消息仍到达队列，则线程将在至少给定的时间段内被阻止，或无限期地阻止。 `timeout`</span><span class="sxs-lookup"><span data-stu-id="b3203-2674">The thread will be blocked for at least the given period of time, or indefinitely if you specified the value <xref:System.Messaging.MessageQueue.InfiniteTimeout> for the `timeout` parameter, or if new messages continue to arrive in the queue within the time-out period specified by the `timeout` parameter.</span></span>  
  
 <span data-ttu-id="b3203-2675">另外两种方法可用于从队列接收消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2675">Two other methods allow you to receive messages from a queue.</span></span> <span data-ttu-id="b3203-2676"><xref:System.Messaging.MessageQueue.Receive%2A>方法返回队列中的第一条消息， <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 方法用于检索确认、报告或由应用程序生成的响应消息，该消息是作为发送到队列的消息的结果创建的。</span><span class="sxs-lookup"><span data-stu-id="b3203-2676">The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> method is used to retrieve an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.</span></span>  
  
 <span data-ttu-id="b3203-2677">若要读取具有指定标识符的消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2677">To read a message with a specified identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method.</span></span> <span data-ttu-id="b3203-2678"><xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2678">The <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span>  
  
 <span data-ttu-id="b3203-2679">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2679">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2680">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2680">Workgroup mode</span></span>|<span data-ttu-id="b3203-2681">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2681">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2682">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2682">Local computer</span></span>|<span data-ttu-id="b3203-2683">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2683">Yes</span></span>|  
|<span data-ttu-id="b3203-2684">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2684">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2685">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2685">Yes</span></span>|  
|<span data-ttu-id="b3203-2686">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2686">Remote computer</span></span>|<span data-ttu-id="b3203-2687">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2687">No</span></span>|  
|<span data-ttu-id="b3203-2688">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2688">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2689">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2689">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-2690">以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29> 的用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2690">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3203-2691"><paramref name="id" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2691">The <paramref name="id" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-2692">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2692">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-2693">在时间超时之前，带有指定 <paramref name="id" /> 的消息没有到达队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2693">A message with the specified <paramref name="id" /> did not arrive in the queue before the time-out expired.</span></span>  
  
<span data-ttu-id="b3203-2694">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-2694">-or-</span></span> 
<span data-ttu-id="b3203-2695">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-2695">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id"><span data-ttu-id="b3203-2696">要接收的消息的 <see cref="P:System.Messaging.Message.Id" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2696">The <see cref="P:System.Messaging.Message.Id" /> of the message to receive.</span></span></param>
        <param name="timeout"><span data-ttu-id="b3203-2697">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-2697">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</span></span></param>
        <param name="transaction"><span data-ttu-id="b3203-2698"><see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-2698">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</span></span></param>
        <summary><span data-ttu-id="b3203-2699">从事务性队列接收与给定的标识符匹配的消息，并且一直等到队列中出现具有指定标识符的消息或超时过期。</span><span class="sxs-lookup"><span data-stu-id="b3203-2699">Receives the message that matches the given identifier (from a transactional queue) and waits until either a message with the specified identifier is available in the queue or the time-out expires.</span></span></summary>
        <returns><span data-ttu-id="b3203-2700"><see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.Id" /> 属性匹配传入的 <paramref name="id" /> 参数。</span><span class="sxs-lookup"><span data-stu-id="b3203-2700">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2701">使用此方法可以读取具有已知标识符的消息，并使用由参数定义的内部事务上下文从队列中删除该消息 `transaction` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2701">Use this method to read a message with a known identifier and remove it from the queue, using the internal transaction context defined by the `transaction` parameter.</span></span> <span data-ttu-id="b3203-2702">如果具有参数指定的标识符的消息在队列中，则此方法立即返回 `id` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2702">This method returns immediately if the message with the identifier specified by the `id` parameter is in the queue.</span></span> <span data-ttu-id="b3203-2703">否则，该方法将在给定的时间段内等待新消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2703">Otherwise, the method waits the given period of time for a new message to arrive.</span></span> <span data-ttu-id="b3203-2704">如果新消息在超时过期之前未到达，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-2704">If a new message does not arrive before the time-out expires, an exception is thrown.</span></span>  
  
 <span data-ttu-id="b3203-2705">`timeout`参数未指定此方法的总运行时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-2705">The `timeout` parameter does not specify the total running time for this method.</span></span> <span data-ttu-id="b3203-2706">相反，它指定等待新消息到达队列的时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-2706">Rather, it specifies the time to wait for a new message to arrive in the queue.</span></span> <span data-ttu-id="b3203-2707">每当新消息到达时，此方法将检查 <xref:System.Messaging.Message.Id%2A> 新消息的，以查看它是否与参数匹配 `id` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2707">Each time a new message arrives, this method examines the <xref:System.Messaging.Message.Id%2A> of the new message to see if it matches the `id` parameter.</span></span> <span data-ttu-id="b3203-2708">否则，此方法将启动超时期限并等待另一个新消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2708">If not, this method starts the time-out period over and waits for another new message to arrive.</span></span> <span data-ttu-id="b3203-2709">因此，如果新消息在超时期限内继续到达，则此方法可能会无限期地继续运行，直到超时期限过期，无需收到任何新消息，或直到到达其 <xref:System.Messaging.Message.Id%2A> 与参数匹配的消息 `id` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2709">Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <xref:System.Messaging.Message.Id%2A> matches the `id` parameter.</span></span>  
  
 <span data-ttu-id="b3203-2710"><xref:System.Messaging.Message.Id%2A>消息的属性在消息队列企业中是唯一的，因此队列中最多只有一个与给定参数匹配的消息 `id` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2710">The <xref:System.Messaging.Message.Id%2A> property of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given `id` parameter.</span></span>  
  
 <span data-ttu-id="b3203-2711">当当前线程被阻止时，可以使用的此重载，只要 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 新消息在参数指定的超时期限内继续到达队列中即可 `timeout` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2711">Use this overload of <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> when it is acceptable for the current thread to be blocked as long as new messages continue to arrive in the queue within the time-out period specified by the `timeout` parameter.</span></span> <span data-ttu-id="b3203-2712">如果为参数指定了值 <xref:System.Messaging.MessageQueue.InfiniteTimeout> `timeout` ，或者在参数指定的超时期限内新消息继续到达队列，则线程将在至少给定的时间段内被阻止。 `timeout`</span><span class="sxs-lookup"><span data-stu-id="b3203-2712">The thread will be blocked for at least the given period of time, or indefinitely if you specified the value <xref:System.Messaging.MessageQueue.InfiniteTimeout> for the `timeout` parameter, or if new messages continue to arrive in the queue within the timeout period specified by the `timeout` parameter.</span></span>  
  
 <span data-ttu-id="b3203-2713">由于此方法是在事务队列中调用的，因此，如果事务中止，接收到的消息将返回到队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2713">Because this method is called on a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="b3203-2714">在提交事务之前，不会从队列中永久删除该消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2714">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="b3203-2715">另外两种方法可用于从队列接收消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2715">Two other methods allow you to receive messages from a queue.</span></span> <span data-ttu-id="b3203-2716"><xref:System.Messaging.MessageQueue.Receive%2A>方法返回队列中的第一条消息， <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 方法用于检索确认、报告或由应用程序生成的响应消息，该消息是作为发送到队列的消息的结果创建的。</span><span class="sxs-lookup"><span data-stu-id="b3203-2716">The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> method is used to retrieve an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.</span></span>  
  
 <span data-ttu-id="b3203-2717">若要读取具有指定标识符的消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2717">To read a message with a specified identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method.</span></span> <span data-ttu-id="b3203-2718"><xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非在队列中有较高优先级的消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2718">The <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message, unless a higher priority message arrives in the queue.</span></span> <span data-ttu-id="b3203-2719">没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2719">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>.</span></span> <span data-ttu-id="b3203-2720">因为不 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 会删除队列中的任何消息，所以如果事务中止，则不会回滚任何内容。</span><span class="sxs-lookup"><span data-stu-id="b3203-2720">Because <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.</span></span>  
  
 <span data-ttu-id="b3203-2721">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2721">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2722">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2722">Workgroup mode</span></span>|<span data-ttu-id="b3203-2723">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2723">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2724">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2724">Local computer</span></span>|<span data-ttu-id="b3203-2725">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2725">Yes</span></span>|  
|<span data-ttu-id="b3203-2726">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2726">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2727">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2727">Yes</span></span>|  
|<span data-ttu-id="b3203-2728">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2728">Remote computer</span></span>|<span data-ttu-id="b3203-2729">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2729">No</span></span>|  
|<span data-ttu-id="b3203-2730">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2730">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2731">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2731">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-2732">以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29> 的用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2732">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3203-2733"><paramref name="id" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2733">The <paramref name="id" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="b3203-2734">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-2734">-or-</span></span> 
<span data-ttu-id="b3203-2735"><paramref name="transaction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2735">The <paramref name="transaction" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-2736">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2736">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-2737">在时间超时之前，带有指定 <paramref name="id" /> 的消息没有到达队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2737">A message with the specified <paramref name="id" /> did not arrive in the queue before the time-out expired.</span></span>  
  
<span data-ttu-id="b3203-2738">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-2738">-or-</span></span> 
<span data-ttu-id="b3203-2739">该队列为非事务性队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2739">The queue is non-transactional.</span></span>  
  
<span data-ttu-id="b3203-2740">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-2740">-or-</span></span> 
<span data-ttu-id="b3203-2741">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-2741">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id"><span data-ttu-id="b3203-2742">要接收的消息的 <see cref="P:System.Messaging.Message.Id" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2742">The <see cref="P:System.Messaging.Message.Id" /> of the message to receive.</span></span></param>
        <param name="timeout"><span data-ttu-id="b3203-2743">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-2743">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</span></span></param>
        <param name="transactionType"><span data-ttu-id="b3203-2744"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文的类型。</span><span class="sxs-lookup"><span data-stu-id="b3203-2744">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span></span></param>
        <summary><span data-ttu-id="b3203-2745">接收与给定的标识符匹配的消息，并且一直等到队列中出现具有指定标识符的消息或超时过期。</span><span class="sxs-lookup"><span data-stu-id="b3203-2745">Receives the message that matches the given identifier and waits until either a message with the specified identifier is available in the queue or the time-out expires.</span></span></summary>
        <returns><span data-ttu-id="b3203-2746"><see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.Id" /> 属性匹配传入的 <paramref name="id" /> 参数。</span><span class="sxs-lookup"><span data-stu-id="b3203-2746">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2747">使用此方法可以读取具有已知标识符的消息，并将其从队列中删除。</span><span class="sxs-lookup"><span data-stu-id="b3203-2747">Use this method to read a message with a known identifier and remove it from the queue.</span></span> <span data-ttu-id="b3203-2748">如果使用参数指定的标识符的消息 `id` 在队列中，则此方法将立即返回 `transactionType` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2748">This method returns immediately if the message with the identifier specified by the `id` parameter is in the queue, using a transaction context defined by the `transactionType` parameter.</span></span> <span data-ttu-id="b3203-2749">否则，该方法将在给定的时间段内等待新消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2749">Otherwise, the method waits the given period of time for a new message to arrive.</span></span> <span data-ttu-id="b3203-2750">如果新消息在超时过期之前未到达，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-2750">If a new message does not arrive before the time-out expires, an exception is thrown.</span></span>  
  
 <span data-ttu-id="b3203-2751">`timeout`参数未指定此方法的总运行时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-2751">The `timeout` parameter does not specify the total running time for this method.</span></span> <span data-ttu-id="b3203-2752">相反，它指定等待新消息到达队列的时间。</span><span class="sxs-lookup"><span data-stu-id="b3203-2752">Rather, it specifies the time to wait for a new message to arrive in the queue.</span></span> <span data-ttu-id="b3203-2753">每当新消息到达时，此方法将检查 <xref:System.Messaging.Message.Id%2A> 新消息的，以查看它是否与参数匹配 `id` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2753">Each time a new message arrives, this method examines the <xref:System.Messaging.Message.Id%2A> of the new message to see if it matches the `id` parameter.</span></span> <span data-ttu-id="b3203-2754">否则，此方法将启动超时期限并等待另一个新消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2754">If not, this method starts the time-out period over and waits for another new message to arrive.</span></span> <span data-ttu-id="b3203-2755">因此，如果新消息在超时期限内继续到达，则此方法可能会无限期地继续运行，直到超时期限过期，无需收到任何新消息，或直到到达其 <xref:System.Messaging.Message.Id%2A> 与参数匹配的消息 `id` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2755">Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <xref:System.Messaging.Message.Id%2A> matches the `id` parameter.</span></span>  
  
 <span data-ttu-id="b3203-2756">`Automatic` `transactionType` 如果已存在附加到要用于接收消息的线程的外部事务上下文，请为参数指定。</span><span class="sxs-lookup"><span data-stu-id="b3203-2756">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</span></span> <span data-ttu-id="b3203-2757">指定 `Single` 是否要以单个内部事务的形式接收消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2757">Specify `Single` if you want to receive the message as a single internal transaction.</span></span> <span data-ttu-id="b3203-2758">您可以指定 `None` 是否要在事务上下文之外接收来自事务性队列的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2758">You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.</span></span>  
  
 <span data-ttu-id="b3203-2759"><xref:System.Messaging.Message.Id%2A>消息的属性在消息队列企业中是唯一的，因此队列中最多只有一个与给定参数匹配的消息 `id` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2759">The <xref:System.Messaging.Message.Id%2A> property of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given `id` parameter.</span></span> <span data-ttu-id="b3203-2760">如果具有指定标识符的消息位于与此实例关联的队列中 <xref:System.Messaging.MessageQueue> ，则将找不到该消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2760">If the message with the specified identifier is in a queue other than the one associated with this <xref:System.Messaging.MessageQueue> instance, the message will not be found.</span></span>  
  
 <span data-ttu-id="b3203-2761">当当前线程被阻止时，可以使用的此重载，只要 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 新消息在参数指定的超时期限内继续到达队列中即可 `timeout` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2761">Use this overload of <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> when it is acceptable for the current thread to be blocked as long as new messages continue to arrive in the queue within the time-out period specified by the `timeout` parameter.</span></span> <span data-ttu-id="b3203-2762">如果为参数指定了值 <xref:System.Messaging.MessageQueue.InfiniteTimeout> `timeout` ，或者在参数指定的超时期限内新消息仍到达队列，则线程将在至少给定的时间段内被阻止，或无限期地阻止。 `timeout`</span><span class="sxs-lookup"><span data-stu-id="b3203-2762">The thread will be blocked for at least the given period of time, or indefinitely if you specified the value <xref:System.Messaging.MessageQueue.InfiniteTimeout> for the `timeout` parameter, or if new messages continue to arrive in the queue within the time-out period specified by the `timeout` parameter.</span></span>  
  
 <span data-ttu-id="b3203-2763">如果调用此方法来接收来自事务性队列的消息，则在事务中止时，收到的消息将返回到队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2763">If this method is called to receive a message from a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="b3203-2764">在提交事务之前，不会从队列中永久删除该消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2764">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="b3203-2765">另外两种方法可用于从队列接收消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2765">Two other methods allow you to receive messages from a queue.</span></span> <span data-ttu-id="b3203-2766"><xref:System.Messaging.MessageQueue.Receive%2A>方法返回队列中的第一条消息， <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 方法用于检索确认、报告或由应用程序生成的响应消息，该消息是作为发送到队列的消息的结果创建的。</span><span class="sxs-lookup"><span data-stu-id="b3203-2766">The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> method is used to retrieve an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.</span></span>  
  
 <span data-ttu-id="b3203-2767">若要读取具有指定标识符的消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2767">To read a message with a specified identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method.</span></span> <span data-ttu-id="b3203-2768"><xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。</span><span class="sxs-lookup"><span data-stu-id="b3203-2768">The <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span> <span data-ttu-id="b3203-2769">没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2769">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>.</span></span> <span data-ttu-id="b3203-2770">因为不 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 会删除队列中的任何消息，所以如果事务中止，则不会回滚任何内容。</span><span class="sxs-lookup"><span data-stu-id="b3203-2770">Because <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.</span></span>  
  
 <span data-ttu-id="b3203-2771">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2771">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2772">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2772">Workgroup mode</span></span>|<span data-ttu-id="b3203-2773">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2773">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2774">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2774">Local computer</span></span>|<span data-ttu-id="b3203-2775">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2775">Yes</span></span>|  
|<span data-ttu-id="b3203-2776">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2776">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2777">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2777">Yes</span></span>|  
|<span data-ttu-id="b3203-2778">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2778">Remote computer</span></span>|<span data-ttu-id="b3203-2779">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2779">No</span></span>|  
|<span data-ttu-id="b3203-2780">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2780">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2781">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2781">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-2782">以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2782">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3203-2783"><paramref name="id" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2783">The <paramref name="id" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-2784">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2784">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-2785">在时间超时之前，带有指定 <paramref name="id" /> 的消息没有到达队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2785">A message with the specified <paramref name="id" /> did not arrive in the queue before the time-out expired.</span></span>  
  
<span data-ttu-id="b3203-2786">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-2786">-or-</span></span> 
<span data-ttu-id="b3203-2787">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-2787">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="b3203-2788"><paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</span><span class="sxs-lookup"><span data-stu-id="b3203-2788">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span></span></exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b3203-2789">在 MSMQ 3.0 中引入。</span><span class="sxs-lookup"><span data-stu-id="b3203-2789">Introduced in MSMQ 3.0.</span></span> <span data-ttu-id="b3203-2790">接收队列中特定的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2790">Receives a specific message from the queue.</span></span> <span data-ttu-id="b3203-2791">消息可通过查询标识符来指定，也可以通过其相对于队首或队尾的位置来指定。</span><span class="sxs-lookup"><span data-stu-id="b3203-2791">The message can be specified by a lookup identifier or by its position at the front or end of the queue.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="lookupId"><span data-ttu-id="b3203-2792">要接收的消息的 <see cref="P:System.Messaging.Message.LookupId" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2792">The <see cref="P:System.Messaging.Message.LookupId" /> of the message to receive.</span></span></param>
        <summary><span data-ttu-id="b3203-2793">在 MSMQ 3.0 中引入。</span><span class="sxs-lookup"><span data-stu-id="b3203-2793">Introduced in MSMQ 3.0.</span></span> <span data-ttu-id="b3203-2794">从非事务性队列中接收与给定的查找标识符匹配的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2794">Receives the message that matches the given lookup identifier from a non-transactional queue.</span></span></summary>
        <returns><span data-ttu-id="b3203-2795"><see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.LookupId" /> 属性匹配传入的 <paramref name="lookupId" /> 参数。</span><span class="sxs-lookup"><span data-stu-id="b3203-2795">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.LookupId" /> property matches the <paramref name="lookupId" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2796">使用此方法可以读取具有已知查找标识符的消息并将其从队列中删除。</span><span class="sxs-lookup"><span data-stu-id="b3203-2796">Use this method to read a message with a known lookup identifier and remove it from the queue.</span></span> <span data-ttu-id="b3203-2797">如果消息不在队列中，此方法会立即引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-2797">This method throws an exception immediately if the message is not in the queue.</span></span>  
  
 <span data-ttu-id="b3203-2798"><xref:System.Messaging.Message.LookupId%2A>消息的属性在消息所在的队列中是唯一的，因此队列中最多存在一个与给定参数匹配的消息 `lookupId` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2798">The <xref:System.Messaging.Message.LookupId%2A> property of a message is unique to the queue where the message resides, so there will be at most one message in the queue that matches the given `lookupId` parameter.</span></span>  
  
 <span data-ttu-id="b3203-2799">若要使用指定的查找标识符读取消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2799">To read a message with a specified lookup identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> method.</span></span>  
  
 <span data-ttu-id="b3203-2800">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2800">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2801">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2801">Workgroup mode</span></span>|<span data-ttu-id="b3203-2802">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2802">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2803">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2803">Local computer</span></span>|<span data-ttu-id="b3203-2804">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2804">Yes</span></span>|  
|<span data-ttu-id="b3203-2805">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2805">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2806">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2806">Yes</span></span>|  
|<span data-ttu-id="b3203-2807">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2807">Remote computer</span></span>|<span data-ttu-id="b3203-2808">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2808">No</span></span>|  
|<span data-ttu-id="b3203-2809">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2809">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2810">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2810">Yes</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="b3203-2811">未安装 MSMQ 3.0。</span><span class="sxs-lookup"><span data-stu-id="b3203-2811">MSMQ 3.0 is not installed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b3203-2812">未能找到具有指定 <paramref name="lookupId" /> 的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2812">The message with the specified <paramref name="lookupId" /> could not be found.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-2813">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-2813">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="lookupId" Type="System.Int64" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="b3203-2814">一个 <see cref="T:System.Messaging.MessageLookupAction" /> 值，指定读取队列中消息的方式。</span><span class="sxs-lookup"><span data-stu-id="b3203-2814">One of the <see cref="T:System.Messaging.MessageLookupAction" /> values, specifying how the message is read in the queue.</span></span> <span data-ttu-id="b3203-2815">指定以下值之一：</span><span class="sxs-lookup"><span data-stu-id="b3203-2815">Specify one of the following:</span></span> 
 <span data-ttu-id="b3203-2816"><see langword="MessageLookupAction.Current" />：接收由 <paramref name="lookupId" /> 指定的消息，然后将其从队列中移除。</span><span class="sxs-lookup"><span data-stu-id="b3203-2816"><see langword="MessageLookupAction.Current" />: Receives the message specified by <paramref name="lookupId" /> and removes it from the queue.</span></span>  
  
 <span data-ttu-id="b3203-2817"><see langword="MessageLookupAction.Next" />：接收 <paramref name="lookupId" /> 所指定消息的后一条消息，然后将其从队列中移除。</span><span class="sxs-lookup"><span data-stu-id="b3203-2817"><see langword="MessageLookupAction.Next" />: Receives the message following the message specified by <paramref name="lookupId" /> and removes it from the queue.</span></span>  
  
 <span data-ttu-id="b3203-2818"><see langword="MessageLookupAction.Previous" />：接收 <paramref name="lookupId" /> 所指定消息的前一条消息，然后将其从队列中移除。</span><span class="sxs-lookup"><span data-stu-id="b3203-2818"><see langword="MessageLookupAction.Previous" />: Receives the message preceding the message specified by <paramref name="lookupId" /> and removes it from the queue.</span></span>  
  
 <span data-ttu-id="b3203-2819"><see langword="MessageLookupAction.First" />：接收队列中的第一条消息并将它从队列中移除。</span><span class="sxs-lookup"><span data-stu-id="b3203-2819"><see langword="MessageLookupAction.First" />: Receives the first message in the queue and removes it from the queue.</span></span> <span data-ttu-id="b3203-2820"><paramref name="lookupId" /> 参数必须设置为 0。</span><span class="sxs-lookup"><span data-stu-id="b3203-2820">The <paramref name="lookupId" /> parameter must be set to 0.</span></span>  
  
 <span data-ttu-id="b3203-2821"><see langword="MessageLookupAction.Last" />：接收队列中的最后一条消息并将它从队列中移除。</span><span class="sxs-lookup"><span data-stu-id="b3203-2821"><see langword="MessageLookupAction.Last" />: Receives the last message in the queue and removes it from the queue.</span></span> <span data-ttu-id="b3203-2822"><paramref name="lookupId" /> 参数必须设置为 0。</span><span class="sxs-lookup"><span data-stu-id="b3203-2822">The <paramref name="lookupId" /> parameter must be set to 0.</span></span></param>
        <param name="lookupId"><span data-ttu-id="b3203-2823">要接收的消息的 <see cref="P:System.Messaging.Message.LookupId" />，或者为 0。</span><span class="sxs-lookup"><span data-stu-id="b3203-2823">The <see cref="P:System.Messaging.Message.LookupId" /> of the message to receive, or 0.</span></span> <span data-ttu-id="b3203-2824">访问队列中的第一条和最后一条消息时使用 0。</span><span class="sxs-lookup"><span data-stu-id="b3203-2824">0 is used when accessing the first or last message in the queue.</span></span></param>
        <param name="transaction"><span data-ttu-id="b3203-2825"><see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-2825">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</span></span></param>
        <summary><span data-ttu-id="b3203-2826">在 MSMQ 3.0 中引入。</span><span class="sxs-lookup"><span data-stu-id="b3203-2826">Introduced in MSMQ 3.0.</span></span> <span data-ttu-id="b3203-2827">从事务性队列中接收特定的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2827">Receives a specific message from a transactional queue.</span></span> <span data-ttu-id="b3203-2828">消息可通过查询标识符来指定，也可以通过其相对于队首或队尾的位置来指定。</span><span class="sxs-lookup"><span data-stu-id="b3203-2828">The message can be specified by a lookup identifier or by its position at the front or end of the queue.</span></span></summary>
        <returns><span data-ttu-id="b3203-2829">由传入的 <paramref name="lookupId" /> 和 <paramref name="action" /> 参数指定的 <see cref="T:System.Messaging.Message" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2829">The <see cref="T:System.Messaging.Message" /> specified by the <paramref name="lookupId" /> and <paramref name="action" /> parameters passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2830">使用此方法可以读取具有已知查找标识符的消息，并使用由参数定义的事务上下文从队列中删除该消息 `transaction` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2830">Use this method to read a message with a known lookup identifier and remove it from the queue, using a transaction context defined by the `transaction` parameter.</span></span> <span data-ttu-id="b3203-2831">如果消息不在队列中，此方法会立即引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-2831">This method throws an exception immediately if the message is not in the queue.</span></span>  
  
 <span data-ttu-id="b3203-2832"><xref:System.Messaging.Message.LookupId%2A>消息的属性在消息所在的队列中是唯一的，因此队列中最多存在一个与给定参数匹配的消息 `lookupId` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2832">The <xref:System.Messaging.Message.LookupId%2A> property of a message is unique to the queue where the message resides, so there will be at most one message in the queue that matches the given `lookupId` parameter.</span></span>  
  
 <span data-ttu-id="b3203-2833">由于此方法是在事务队列中调用的，因此，如果事务中止，接收到的消息将返回到队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2833">Because this method is called on a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="b3203-2834">在提交事务之前，不会从队列中永久删除该消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2834">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="b3203-2835">若要读取具有指定标识符的消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2835">To read a message with a specified identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> method.</span></span> <span data-ttu-id="b3203-2836">没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2836">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>.</span></span> <span data-ttu-id="b3203-2837">因为不 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 会从队列中删除任何消息，所以如果事务中止，则不会回滚任何内容。</span><span class="sxs-lookup"><span data-stu-id="b3203-2837">Because <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> does not remove any messages from the queue, there would be nothing to roll back if the transaction were aborted.</span></span>  
  
 <span data-ttu-id="b3203-2838">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2838">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2839">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2839">Workgroup mode</span></span>|<span data-ttu-id="b3203-2840">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2840">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2841">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2841">Local computer</span></span>|<span data-ttu-id="b3203-2842">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2842">Yes</span></span>|  
|<span data-ttu-id="b3203-2843">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2843">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2844">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2844">Yes</span></span>|  
|<span data-ttu-id="b3203-2845">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2845">Remote computer</span></span>|<span data-ttu-id="b3203-2846">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2846">No</span></span>|  
|<span data-ttu-id="b3203-2847">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2847">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2848">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2848">Yes</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="b3203-2849">未安装 MSMQ 3.0。</span><span class="sxs-lookup"><span data-stu-id="b3203-2849">MSMQ 3.0 is not installed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b3203-2850">未能找到具有指定 <paramref name="lookupId" /> 的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2850">The message with the specified <paramref name="lookupId" /> could not be found.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-2851">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-2851">An error occurred when accessing a Message Queuing method.</span></span>  
  
 <span data-ttu-id="b3203-2852">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-2852">-or-</span></span>  
  
 <span data-ttu-id="b3203-2853">该队列为非事务性队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2853">The queue is non-transactional.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="b3203-2854"><paramref name="action" /> 参数不是 <see cref="T:System.Messaging.MessageLookupAction" /> 成员之一。</span><span class="sxs-lookup"><span data-stu-id="b3203-2854">The <paramref name="action" /> parameter is not one of the <see cref="T:System.Messaging.MessageLookupAction" /> members.</span></span></exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="lookupId" Type="System.Int64" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="b3203-2855">一个 <see cref="T:System.Messaging.MessageLookupAction" /> 值，指定读取队列中消息的方式。</span><span class="sxs-lookup"><span data-stu-id="b3203-2855">One of the <see cref="T:System.Messaging.MessageLookupAction" /> values, specifying how the message is read in the queue.</span></span> <span data-ttu-id="b3203-2856">指定以下值之一：</span><span class="sxs-lookup"><span data-stu-id="b3203-2856">Specify one of the following:</span></span> 
 <span data-ttu-id="b3203-2857"><see langword="MessageLookupAction.Current" />：接收由 <paramref name="lookupId" /> 指定的消息，然后将其从队列中移除。</span><span class="sxs-lookup"><span data-stu-id="b3203-2857"><see langword="MessageLookupAction.Current" />: Receives the message specified by <paramref name="lookupId" /> and removes it from the queue.</span></span>  
  
 <span data-ttu-id="b3203-2858"><see langword="MessageLookupAction.Next" />：接收 <paramref name="lookupId" /> 所指定消息的后一条消息，然后将其从队列中移除。</span><span class="sxs-lookup"><span data-stu-id="b3203-2858"><see langword="MessageLookupAction.Next" />: Receives the message following the message specified by <paramref name="lookupId" /> and removes it from the queue.</span></span>  
  
 <span data-ttu-id="b3203-2859"><see langword="MessageLookupAction.Previous" />：接收 <paramref name="lookupId" /> 所指定消息的前一条消息，然后将其从队列中移除。</span><span class="sxs-lookup"><span data-stu-id="b3203-2859"><see langword="MessageLookupAction.Previous" />: Receives the message preceding the message specified by <paramref name="lookupId" /> and removes it from the queue.</span></span>  
  
 <span data-ttu-id="b3203-2860"><see langword="MessageLookupAction.First" />：接收队列中的第一条消息并将它从队列中移除。</span><span class="sxs-lookup"><span data-stu-id="b3203-2860"><see langword="MessageLookupAction.First" />: Receives the first message in the queue and removes it from the queue.</span></span> <span data-ttu-id="b3203-2861"><paramref name="lookupId" /> 参数必须设置为 0。</span><span class="sxs-lookup"><span data-stu-id="b3203-2861">The <paramref name="lookupId" /> parameter must be set to 0.</span></span>  
  
 <span data-ttu-id="b3203-2862"><see langword="MessageLookupAction.Last" />：接收队列中的最后一条消息并将它从队列中移除。</span><span class="sxs-lookup"><span data-stu-id="b3203-2862"><see langword="MessageLookupAction.Last" />: Receives the last message in the queue and removes it from the queue.</span></span> <span data-ttu-id="b3203-2863"><paramref name="lookupId" /> 参数必须设置为 0。</span><span class="sxs-lookup"><span data-stu-id="b3203-2863">The <paramref name="lookupId" /> parameter must be set to 0.</span></span></param>
        <param name="lookupId"><span data-ttu-id="b3203-2864">要接收的消息的 <see cref="P:System.Messaging.Message.LookupId" />，或者为 0。</span><span class="sxs-lookup"><span data-stu-id="b3203-2864">The <see cref="P:System.Messaging.Message.LookupId" /> of the message to receive, or 0.</span></span> <span data-ttu-id="b3203-2865">访问队列中的第一条和最后一条消息时使用 0。</span><span class="sxs-lookup"><span data-stu-id="b3203-2865">0 is used when accessing the first or last message in the queue.</span></span></param>
        <param name="transactionType"><span data-ttu-id="b3203-2866"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文的类型。</span><span class="sxs-lookup"><span data-stu-id="b3203-2866">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span></span></param>
        <summary><span data-ttu-id="b3203-2867">在 MSMQ 3.0 中引入。</span><span class="sxs-lookup"><span data-stu-id="b3203-2867">Introduced in MSMQ 3.0.</span></span> <span data-ttu-id="b3203-2868">使用指定的事务上下文从队列中接收特定的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2868">Receives a specific message from the queue, using the specified transaction context.</span></span> <span data-ttu-id="b3203-2869">消息可通过查询标识符来指定，也可以通过其相对于队首或队尾的位置来指定。</span><span class="sxs-lookup"><span data-stu-id="b3203-2869">The message can be specified by a lookup identifier or by its position at the front or end of the queue.</span></span></summary>
        <returns><span data-ttu-id="b3203-2870">由传入的 <paramref name="action" /> 和 <paramref name="lookupId" /> 参数指定的 <see cref="T:System.Messaging.Message" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-2870">The <see cref="T:System.Messaging.Message" /> specified by the <paramref name="action" /> and <paramref name="lookupId" /> parameters passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2871">使用此方法可以读取具有已知查找标识符的消息，并使用由参数定义的事务上下文从队列中删除该消息 `transactionType` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2871">Use this method to read a message with a known lookup identifier and remove it from the queue, using a transaction context defined by the `transactionType` parameter.</span></span> <span data-ttu-id="b3203-2872">如果消息不在队列中，此方法会立即引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-2872">This method throws an exception immediately if the message is not in the queue.</span></span>  
  
 <span data-ttu-id="b3203-2873"><xref:System.Messaging.Message.LookupId%2A>消息的属性在消息所在的队列中是唯一的，因此队列中最多存在一个与给定参数匹配的消息 `lookupId` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2873">The <xref:System.Messaging.Message.LookupId%2A> property of a message is unique to the queue where the message resides, so there will be at most one message in the queue that matches the given `lookupId` parameter.</span></span>  
  
 <span data-ttu-id="b3203-2874">若要读取具有指定标识符的消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2874">To read a message with a specified identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> method.</span></span> <span data-ttu-id="b3203-2875">没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2875">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>.</span></span> <span data-ttu-id="b3203-2876">因为不 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 会从队列中删除任何消息，所以如果事务中止，则不会回滚任何内容。</span><span class="sxs-lookup"><span data-stu-id="b3203-2876">Because <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> does not remove any messages from the queue, there would be nothing to roll back if the transaction were aborted.</span></span>  
  
 <span data-ttu-id="b3203-2877">`Automatic` `transactionType` 如果已存在附加到要用于接收消息的线程的外部事务上下文，请为参数指定。</span><span class="sxs-lookup"><span data-stu-id="b3203-2877">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</span></span> <span data-ttu-id="b3203-2878">指定 `Single` 是否要以单个内部事务的形式接收消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2878">Specify `Single` if you want to receive the message as a single internal transaction.</span></span> <span data-ttu-id="b3203-2879">您可以指定 `None` 是否要在事务上下文之外接收来自事务性队列的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2879">You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.</span></span>  
  
 <span data-ttu-id="b3203-2880">如果调用此方法来接收来自事务性队列的消息，则在事务中止时，收到的消息将返回到队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2880">If this method is called to receive a message from a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="b3203-2881">在提交事务之前，不会从队列中永久删除该消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2881">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="b3203-2882">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2882">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2883">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2883">Workgroup mode</span></span>|<span data-ttu-id="b3203-2884">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2884">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2885">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2885">Local computer</span></span>|<span data-ttu-id="b3203-2886">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2886">Yes</span></span>|  
|<span data-ttu-id="b3203-2887">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2887">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2888">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2888">Yes</span></span>|  
|<span data-ttu-id="b3203-2889">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2889">Remote computer</span></span>|<span data-ttu-id="b3203-2890">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2890">No</span></span>|  
|<span data-ttu-id="b3203-2891">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2891">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2892">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2892">Yes</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="b3203-2893">未安装 MSMQ 3.0。</span><span class="sxs-lookup"><span data-stu-id="b3203-2893">MSMQ 3.0 is not installed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b3203-2894">未能找到具有指定 <paramref name="lookupId" /> 的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2894">The message with the specified <paramref name="lookupId" /> could not be found.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-2895">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-2895">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="b3203-2896"><paramref name="action" /> 参数不是 <see cref="T:System.Messaging.MessageLookupAction" /> 成员之一。</span><span class="sxs-lookup"><span data-stu-id="b3203-2896">The <paramref name="action" /> parameter is not one of the <see cref="T:System.Messaging.MessageLookupAction" /> members.</span></span>  
  
<span data-ttu-id="b3203-2897">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-2897">-or-</span></span> 
<span data-ttu-id="b3203-2898"><paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</span><span class="sxs-lookup"><span data-stu-id="b3203-2898">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span></span></exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReceiveCompleted As ReceiveCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::ReceiveCompletedEventHandler ^ ReceiveCompleted;" />
      <MemberSignature Language="F#" Value="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " Usage="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_ReceiveCompleted")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_ReceiveCompleted")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-2899">在从队列移除某条消息后发生。</span><span class="sxs-lookup"><span data-stu-id="b3203-2899">Occurs when a message has been removed from the queue.</span></span> <span data-ttu-id="b3203-2900">此事件由异步操作 <see cref="M:System.Messaging.MessageQueue.BeginReceive" /> 引发。</span><span class="sxs-lookup"><span data-stu-id="b3203-2900">This event is raised by the asynchronous operation, <see cref="M:System.Messaging.MessageQueue.BeginReceive" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2901"><xref:System.Messaging.MessageQueue.BeginReceive%2A> 当队列中有消息时，将在异步处理过程中用于引发 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 事件。</span><span class="sxs-lookup"><span data-stu-id="b3203-2901"><xref:System.Messaging.MessageQueue.BeginReceive%2A> is used in asynchronous processing to raise the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event when a message is available in the queue.</span></span>  
  
 <span data-ttu-id="b3203-2902"><xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 用于完成通过调用启动的操作 <xref:System.Messaging.MessageQueue.BeginReceive%2A> ，并在引发事件时查看消息 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2902"><xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> is used to complete the operation initiated by a call to <xref:System.Messaging.MessageQueue.BeginReceive%2A> and peek the message when the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event is raised.</span></span>  
  
 <span data-ttu-id="b3203-2903">创建 <xref:System.Messaging.ReceiveCompletedEventHandler> 委托时，需要标识将处理该事件的方法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2903">When you create a <xref:System.Messaging.ReceiveCompletedEventHandler> delegate, you identify the method that will handle the event.</span></span> <span data-ttu-id="b3203-2904">若要将事件与事件处理程序关联，请将该委托的一个实例添加到事件中。</span><span class="sxs-lookup"><span data-stu-id="b3203-2904">To associate the event with your event handler, add an instance of the delegate to the event.</span></span> <span data-ttu-id="b3203-2905">除非移除了该委托，否则每当发生该事件时就会调用事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="b3203-2905">The event handler is called whenever the event occurs, unless you remove the delegate.</span></span> <span data-ttu-id="b3203-2906">有关事件处理程序委托的详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。</span><span class="sxs-lookup"><span data-stu-id="b3203-2906">For more information about event handler delegates, see [Handling and Raising Events](/dotnet/standard/events/).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3203-2907">下面的代码示例创建一个名为的事件处理程序 `MyReceiveCompleted` ，将其附加到 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 事件处理程序委托，并调用 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 以在位于路径 ".\myQueue" 的队列上启动异步接收操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-2907">The following code example creates an event handler named `MyReceiveCompleted`, attaches it to the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event handler delegate, and calls <xref:System.Messaging.MessageQueue.BeginReceive%2A> to initiate an asynchronous receive operation on the queue that is located at the path ".\myQueue".</span></span> <span data-ttu-id="b3203-2908"><xref:System.Messaging.MessageQueue.ReceiveCompleted>引发事件时，该示例接收消息，并将其正文写入屏幕。</span><span class="sxs-lookup"><span data-stu-id="b3203-2908">When a <xref:System.Messaging.MessageQueue.ReceiveCompleted> event is raised, the example receives the message and writes its body to the screen.</span></span> <span data-ttu-id="b3203-2909">然后，该示例 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 再次调用以启动新的异步接收操作。</span><span class="sxs-lookup"><span data-stu-id="b3203-2909">The example then calls <xref:System.Messaging.MessageQueue.BeginReceive%2A> again to initiate a new asynchronous receive operation.</span></span>  
  
 [!code-cpp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="messageQueue.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b3203-2910">刷新 <see cref="T:System.Messaging.MessageQueue" /> 所显示的属性以反映资源的当前状态。</span><span class="sxs-lookup"><span data-stu-id="b3203-2910">Refreshes the properties presented by the <see cref="T:System.Messaging.MessageQueue" /> to reflect the current state of the resource.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2911"><xref:System.Messaging.MessageQueue.Refresh%2A> 将的属性与其 <xref:System.Messaging.MessageQueue> 关联的消息队列服务器资源同步。</span><span class="sxs-lookup"><span data-stu-id="b3203-2911"><xref:System.Messaging.MessageQueue.Refresh%2A> synchronizes the properties of a <xref:System.Messaging.MessageQueue> with its associated Message Queuing server resource.</span></span> <span data-ttu-id="b3203-2912">如果 <xref:System.Messaging.MessageQueue.Label%2A> 自创建之后在服务器上更改了任何属性（如或 <xref:System.Messaging.MessageQueue.Category%2A> ），则会 <xref:System.Messaging.MessageQueue> <xref:System.Messaging.MessageQueue.Refresh%2A> <xref:System.Messaging.MessageQueue> 用新信息更新。</span><span class="sxs-lookup"><span data-stu-id="b3203-2912">If any property, such as <xref:System.Messaging.MessageQueue.Label%2A> or <xref:System.Messaging.MessageQueue.Category%2A>, has changed on the server since the time the <xref:System.Messaging.MessageQueue> was created, <xref:System.Messaging.MessageQueue.Refresh%2A> updates the <xref:System.Messaging.MessageQueue> with the new information.</span></span>  
  
 <span data-ttu-id="b3203-2913">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2913">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2914">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2914">Workgroup mode</span></span>|<span data-ttu-id="b3203-2915">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2915">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2916">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2916">Local computer</span></span>|<span data-ttu-id="b3203-2917">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2917">Yes</span></span>|  
|<span data-ttu-id="b3203-2918">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2918">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2919">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2919">Yes</span></span>|  
|<span data-ttu-id="b3203-2920">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2920">Remote computer</span></span>|<span data-ttu-id="b3203-2921">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2921">No</span></span>|  
|<span data-ttu-id="b3203-2922">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2922">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2923">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2923">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-2924">以下代码示例演示了 <xref:System.Messaging.MessageQueue.Refresh%2A> 的用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2924">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.Refresh%2A>.</span></span>  
  
 [!code-cpp[MessageQueue2#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetPermissions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetPermissions();" />
      <MemberSignature Language="F#" Value="member this.ResetPermissions : unit -&gt; unit" Usage="messageQueue.ResetPermissions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b3203-2925">将权限列表重置为操作系统的默认值。</span><span class="sxs-lookup"><span data-stu-id="b3203-2925">Resets the permission list to the operating system's default values.</span></span> <span data-ttu-id="b3203-2926">移除已追加到默认列表中的所有队列权限。</span><span class="sxs-lookup"><span data-stu-id="b3203-2926">Removes any queue permissions you have appended to the default list.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2927">调用时 <xref:System.Messaging.MessageQueue.ResetPermissions%2A> ，会将权限列表返回到其默认值。</span><span class="sxs-lookup"><span data-stu-id="b3203-2927">When you call <xref:System.Messaging.MessageQueue.ResetPermissions%2A>, you return the permission list to its default values.</span></span> <span data-ttu-id="b3203-2928">通常，这会授予队列创建者所有权限，并为每个人提供以下权限：</span><span class="sxs-lookup"><span data-stu-id="b3203-2928">Generally, this grants the queue creator all permissions, and gives the group Everyone the following rights:</span></span>  
  
-   <span data-ttu-id="b3203-2929">获取队列属性。</span><span class="sxs-lookup"><span data-stu-id="b3203-2929">Get the properties of the queue.</span></span>  
  
-   <span data-ttu-id="b3203-2930">获取队列权限。</span><span class="sxs-lookup"><span data-stu-id="b3203-2930">Get queue permissions.</span></span>  
  
-   <span data-ttu-id="b3203-2931">写入队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2931">Write to the queue.</span></span>  
  
 <span data-ttu-id="b3203-2932">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2932">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2933">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2933">Workgroup mode</span></span>|<span data-ttu-id="b3203-2934">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2934">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2935">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2935">Local computer</span></span>|<span data-ttu-id="b3203-2936">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2936">Yes</span></span>|  
|<span data-ttu-id="b3203-2937">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2937">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2938">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2938">Yes</span></span>|  
|<span data-ttu-id="b3203-2939">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2939">Remote computer</span></span>|<span data-ttu-id="b3203-2940">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2940">No</span></span>|  
|<span data-ttu-id="b3203-2941">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2941">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2942">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2942">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-2943">以下代码示例演示了 <xref:System.Messaging.MessageQueue.ResetPermissions%2A> 的用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-2943">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ResetPermissions%2A>.</span></span>  
  
 [!code-cpp[MessageQueue2#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-2944">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-2944">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b3203-2945">向队列发送对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-2945">Sends an object to a queue.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Send : obj -&gt; unit" Usage="messageQueue.Send obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="b3203-2946">要发送到队列的对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-2946">The object to send to the queue.</span></span></param>
        <summary><span data-ttu-id="b3203-2947">将对象发送到此 <see cref="T:System.Messaging.MessageQueue" /> 引用的非事务性队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2947">Sends an object to non-transactional queue referenced by this <see cref="T:System.Messaging.MessageQueue" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2948">使用此重载将包含参数的消息发送 `obj` 到由引用的队列 <xref:System.Messaging.MessageQueue> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2948">Use this overload to send a message that contains the `obj` parameter to the queue referenced by the <xref:System.Messaging.MessageQueue>.</span></span> <span data-ttu-id="b3203-2949">发送到队列的对象可以为 <xref:System.Messaging.Message> 或任何托管对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-2949">The object you send to the queue can be a <xref:System.Messaging.Message> or any managed object.</span></span> <span data-ttu-id="b3203-2950">如果发送除之外的任何对象 <xref:System.Messaging.Message> ，则会序列化对象并将其插入消息的正文中。</span><span class="sxs-lookup"><span data-stu-id="b3203-2950">If you send any object other than a <xref:System.Messaging.Message>, the object is serialized and inserted into the body of the message.</span></span>  
  
 <span data-ttu-id="b3203-2951">如果使用此重载将消息发送到事务性队列，则会将该消息发送到死信队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2951">If you use this overload to send a message to a transactional queue, the message will be sent to the dead-letter queue.</span></span> <span data-ttu-id="b3203-2952">如果希望消息成为包含其他消息的事务的一部分，请使用采用 <xref:System.Messaging.MessageQueueTransaction> 或 <xref:System.Messaging.MessageQueueTransactionType> 作为参数的重载。</span><span class="sxs-lookup"><span data-stu-id="b3203-2952">If you want the message to be part of a transaction that contains other messages, use an overload that takes a <xref:System.Messaging.MessageQueueTransaction> or <xref:System.Messaging.MessageQueueTransactionType> as a parameter.</span></span>  
  
 <span data-ttu-id="b3203-2953">如果在调用之前未设置 <xref:System.Messaging.MessageQueue.Formatter%2A> 属性 <xref:System.Messaging.MessageQueue.Send%28System.Object%29> ，则格式化程序默认为 <xref:System.Messaging.XmlMessageFormatter> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2953">If you do not set the <xref:System.Messaging.MessageQueue.Formatter%2A> property before calling <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, the formatter defaults to the <xref:System.Messaging.XmlMessageFormatter>.</span></span>  
  
 <span data-ttu-id="b3203-2954"><xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>属性应用于以外的任何对象 <xref:System.Messaging.Message> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2954">The <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> property applies to any object other than a <xref:System.Messaging.Message>.</span></span> <span data-ttu-id="b3203-2955">例如，如果使用成员指定标签或优先级 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> ，则 <xref:System.Messaging.Message> 在应用程序将其发送到队列时，这些值将应用于包含不属于类型的对象的任何消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2955">If you specify, for example, a label or a priority using the <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> member, these values apply to any message that contains an object that is not of type <xref:System.Messaging.Message> when your application sends it to the queue.</span></span> <span data-ttu-id="b3203-2956">在发送时 <xref:System.Messaging.Message> ，为设置的属性值 <xref:System.Messaging.Message> 优先于， <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 并且消息的 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 属性优先于队列的 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="b3203-2956">When sending a <xref:System.Messaging.Message>, the property values set for the <xref:System.Messaging.Message> take precedence over <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> and the message's <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> property takes precedence over the queue's <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="b3203-2957">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2957">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2958">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2958">Workgroup mode</span></span>|<span data-ttu-id="b3203-2959">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2959">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2960">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2960">Local computer</span></span>|<span data-ttu-id="b3203-2961">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2961">Yes</span></span>|  
|<span data-ttu-id="b3203-2962">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2962">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2963">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2963">Yes</span></span>|  
|<span data-ttu-id="b3203-2964">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2964">Remote computer</span></span>|<span data-ttu-id="b3203-2965">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2965">No</span></span>|  
|<span data-ttu-id="b3203-2966">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2966">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2967">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2967">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-2968">下面的代码示例连接到消息队列并将消息发送到队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2968">The following code example connects to a message queue and sends a message to the queue.</span></span>  
  
 [!code-cpp[MessageQueue.Send_obj#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send_obj#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send_obj#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 <span data-ttu-id="b3203-2969">下面的代码示例将应用程序定义的 `Order` 类发送到队列，然后从该队列接收消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2969">The following code example sends an application-defined `Order` class to a queue and then receives a message from that queue.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-2970">尚未设置 <see cref="P:System.Messaging.MessageQueue.Path" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="b3203-2970">The <see cref="P:System.Messaging.MessageQueue.Path" /> property has not been set.</span></span>  
  
<span data-ttu-id="b3203-2971">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-2971">-or-</span></span> 
<span data-ttu-id="b3203-2972">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-2972">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="b3203-2973">要发送到队列的对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-2973">The object to send to the queue.</span></span></param>
        <param name="transaction"><span data-ttu-id="b3203-2974"><see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-2974">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</span></span></param>
        <summary><span data-ttu-id="b3203-2975">将对象发送到此 <see cref="T:System.Messaging.MessageQueue" /> 所引用的事务性队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-2975">Sends an object to the transactional queue referenced by this <see cref="T:System.Messaging.MessageQueue" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-2976">使用此重载 `obj` <xref:System.Messaging.MessageQueue> ，使用由参数定义的内部事务上下文将包含参数的消息发送到引用的事务性队列 `transaction` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2976">Use this overload to send a message that contains the `obj` parameter to the transactional queue referenced by the <xref:System.Messaging.MessageQueue>, using an internal transaction context defined by the `transaction` parameter.</span></span> <span data-ttu-id="b3203-2977">发送到队列的对象可以为 <xref:System.Messaging.Message> 或任何托管对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-2977">The object you send to the queue can be a <xref:System.Messaging.Message> or any managed object.</span></span> <span data-ttu-id="b3203-2978">如果发送除之外的任何对象 <xref:System.Messaging.Message> ，则会序列化对象并将其插入消息的正文中。</span><span class="sxs-lookup"><span data-stu-id="b3203-2978">If you send any object other than a <xref:System.Messaging.Message>, the object is serialized and inserted into the body of the message.</span></span>  
  
 <span data-ttu-id="b3203-2979">如果使用此重载将消息发送到非事务性队列，则可能会将该消息发送到死信队列，而不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-2979">If you use this overload to send a message to a non-transactional queue, the message might be sent to the dead-letter queue without throwing an exception.</span></span>  
  
 <span data-ttu-id="b3203-2980">如果在调用之前未设置 <xref:System.Messaging.MessageQueue.Formatter%2A> 属性 <xref:System.Messaging.MessageQueue.Send%28System.Object%29> ，则格式化程序默认为 <xref:System.Messaging.XmlMessageFormatter> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2980">If you do not set the <xref:System.Messaging.MessageQueue.Formatter%2A> property before calling <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, the formatter defaults to the <xref:System.Messaging.XmlMessageFormatter>.</span></span>  
  
 <span data-ttu-id="b3203-2981"><xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>属性应用于以外的任何对象 <xref:System.Messaging.Message> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2981">The <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> property applies to any object other than a <xref:System.Messaging.Message>.</span></span> <span data-ttu-id="b3203-2982">例如，如果使用成员指定标签或优先级 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> ，则 <xref:System.Messaging.Message> 在应用程序将其发送到队列时，这些值将应用于包含不属于类型的对象的任何消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2982">If you specify, for example, a label or a priority using the <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> member, these values apply to any message that contains an object that is not of type <xref:System.Messaging.Message> when your application sends it to the queue.</span></span> <span data-ttu-id="b3203-2983">在发送时 <xref:System.Messaging.Message> ，为设置的属性值 <xref:System.Messaging.Message> 优先于， <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 并且消息的 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 属性优先于队列的 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="b3203-2983">When sending a <xref:System.Messaging.Message>, the property values set for the <xref:System.Messaging.Message> take precedence over <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> and the message's <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> property takes precedence over the queue's <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="b3203-2984"><xref:System.Messaging.MessageQueueTransaction> 线程单元感知，因此，如果单元状态为 `STA` ，则不能在多个线程中使用事务。</span><span class="sxs-lookup"><span data-stu-id="b3203-2984"><xref:System.Messaging.MessageQueueTransaction> is threading apartment aware, so if your apartment state is `STA`, you cannot use the transaction in multiple threads.</span></span> <span data-ttu-id="b3203-2985">Visual Basic 将主线程的状态设置为 `STA` ，因此你必须 <xref:System.MTAThreadAttribute> 在子例程中应用 `Main` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-2985">Visual Basic sets the state of the main thread to `STA`, so you must apply the <xref:System.MTAThreadAttribute> in the `Main` subroutine.</span></span> <span data-ttu-id="b3203-2986">否则，利用另一个线程发送事务性消息将引发 <xref:System.Messaging.MessageQueueException> 异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-2986">Otherwise, sending a transactional message using another thread throws a <xref:System.Messaging.MessageQueueException> exception.</span></span> <span data-ttu-id="b3203-2987"><xref:System.MTAThreadAttribute>使用以下片段应用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2987">You apply the <xref:System.MTAThreadAttribute> by using the following fragment.</span></span>  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 <span data-ttu-id="b3203-2988">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-2988">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-2989">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-2989">Workgroup mode</span></span>|<span data-ttu-id="b3203-2990">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-2990">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-2991">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2991">Local computer</span></span>|<span data-ttu-id="b3203-2992">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2992">Yes</span></span>|  
|<span data-ttu-id="b3203-2993">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2993">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-2994">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2994">Yes</span></span>|  
|<span data-ttu-id="b3203-2995">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-2995">Remote computer</span></span>|<span data-ttu-id="b3203-2996">否</span><span class="sxs-lookup"><span data-stu-id="b3203-2996">No</span></span>|  
|<span data-ttu-id="b3203-2997">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-2997">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-2998">是</span><span class="sxs-lookup"><span data-stu-id="b3203-2998">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-2999">下面的代码示例将字符串发送到事务性队列，然后从该队列接收消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-2999">The following code example sends a string to a transactional queue and then receives a message from that queue.</span></span>  
  
 [!code-cpp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3203-3000"><paramref name="transaction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-3000">The <paramref name="transaction" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-3001">尚未设置 <see cref="P:System.Messaging.MessageQueue.Path" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="b3203-3001">The <see cref="P:System.Messaging.MessageQueue.Path" /> property has not been set.</span></span>  
  
<span data-ttu-id="b3203-3002">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-3002">-or-</span></span> 
<span data-ttu-id="b3203-3003">“消息队列”应用程序指示事务用法不正确。</span><span class="sxs-lookup"><span data-stu-id="b3203-3003">The Message Queuing application indicated an incorrect transaction use.</span></span>  
  
<span data-ttu-id="b3203-3004">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-3004">-or-</span></span> 
<span data-ttu-id="b3203-3005">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-3005">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="b3203-3006">要发送到队列的对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-3006">The object to send to the queue.</span></span></param>
        <param name="transactionType"><span data-ttu-id="b3203-3007"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文的类型。</span><span class="sxs-lookup"><span data-stu-id="b3203-3007">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span></span></param>
        <summary><span data-ttu-id="b3203-3008">将对象发送到此 <see cref="T:System.Messaging.MessageQueue" /> 所引用的队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-3008">Sends an object to the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-3009">使用此重载将包含参数的消息发送 `obj` 到由引用的队列 <xref:System.Messaging.MessageQueue> ，使用由参数定义的事务上下文 `transactionType` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-3009">Use this overload to send a message that contains the `obj` parameter to the queue referenced by the <xref:System.Messaging.MessageQueue>, using a transaction context defined by the `transactionType` parameter.</span></span> <span data-ttu-id="b3203-3010">`Automatic` `transactionType` 如果已存在附加到要用于发送消息的线程的外部事务上下文，请为参数指定。</span><span class="sxs-lookup"><span data-stu-id="b3203-3010">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to send the message.</span></span> <span data-ttu-id="b3203-3011">指定 `Single` 是否要将消息作为单个内部事务发送。</span><span class="sxs-lookup"><span data-stu-id="b3203-3011">Specify `Single` if you want to send the message as a single internal transaction.</span></span> <span data-ttu-id="b3203-3012">您可以指定 `None` 是否要将事务性消息发送到非事务性线程。</span><span class="sxs-lookup"><span data-stu-id="b3203-3012">You can specify `None` if you want to send a transactional message to a non-transactional thread.</span></span>  
  
 <span data-ttu-id="b3203-3013">发送到队列的对象可以为 <xref:System.Messaging.Message> 或任何托管对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-3013">The object you send to the queue can be a <xref:System.Messaging.Message> or any managed object.</span></span> <span data-ttu-id="b3203-3014">如果发送除之外的任何对象 <xref:System.Messaging.Message> ，则会序列化对象并将其插入消息的正文中。</span><span class="sxs-lookup"><span data-stu-id="b3203-3014">If you send any object other than a <xref:System.Messaging.Message>, the object is serialized and inserted into the body of the message.</span></span>  
  
 <span data-ttu-id="b3203-3015">如果在调用之前未设置 <xref:System.Messaging.MessageQueue.Formatter%2A> 属性 <xref:System.Messaging.MessageQueue.Send%28System.Object%29> ，则格式化程序默认为 <xref:System.Messaging.XmlMessageFormatter> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-3015">If you do not set the <xref:System.Messaging.MessageQueue.Formatter%2A> property before calling <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, the formatter defaults to the <xref:System.Messaging.XmlMessageFormatter>.</span></span>  
  
 <span data-ttu-id="b3203-3016"><xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>属性应用于以外的任何对象 <xref:System.Messaging.Message> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-3016">The <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> property applies to any object other than a <xref:System.Messaging.Message>.</span></span> <span data-ttu-id="b3203-3017">例如，如果使用成员指定标签或优先级 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> ，则 <xref:System.Messaging.Message> 在应用程序将其发送到队列时，这些值将应用于包含不属于类型的对象的任何消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-3017">If you specify, for example, a label or a priority using the <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> member, these values apply to any message that contains an object that is not of type <xref:System.Messaging.Message> when your application sends it to the queue.</span></span> <span data-ttu-id="b3203-3018">在发送时 <xref:System.Messaging.Message> ，为设置的属性值 <xref:System.Messaging.Message> 优先于， <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 并且消息的 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 属性优先于队列的 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="b3203-3018">When sending a <xref:System.Messaging.Message>, the property values set for the <xref:System.Messaging.Message> take precedence over <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> and the message's <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> property takes precedence over the queue's <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="b3203-3019">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-3019">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-3020">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-3020">Workgroup mode</span></span>|<span data-ttu-id="b3203-3021">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-3021">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-3022">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-3022">Local computer</span></span>|<span data-ttu-id="b3203-3023">是</span><span class="sxs-lookup"><span data-stu-id="b3203-3023">Yes</span></span>|  
|<span data-ttu-id="b3203-3024">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-3024">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-3025">是</span><span class="sxs-lookup"><span data-stu-id="b3203-3025">Yes</span></span>|  
|<span data-ttu-id="b3203-3026">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-3026">Remote computer</span></span>|<span data-ttu-id="b3203-3027">否</span><span class="sxs-lookup"><span data-stu-id="b3203-3027">No</span></span>|  
|<span data-ttu-id="b3203-3028">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-3028">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-3029">是</span><span class="sxs-lookup"><span data-stu-id="b3203-3029">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-3030">以下代码示例演示了 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-3030">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="b3203-3031"><paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</span><span class="sxs-lookup"><span data-stu-id="b3203-3031">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-3032">尚未设置 <see cref="P:System.Messaging.MessageQueue.Path" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="b3203-3032">The <see cref="P:System.Messaging.MessageQueue.Path" /> property has not been set.</span></span>  
  
<span data-ttu-id="b3203-3033">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-3033">-or-</span></span> 
<span data-ttu-id="b3203-3034">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-3034">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string -&gt; unit" Usage="messageQueue.Send (obj, label)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="b3203-3035">要发送到队列的对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-3035">The object to send to the queue.</span></span></param>
        <param name="label"><span data-ttu-id="b3203-3036">消息的标签。</span><span class="sxs-lookup"><span data-stu-id="b3203-3036">The label of the message.</span></span></param>
        <summary><span data-ttu-id="b3203-3037">将对象发送到此 <see cref="T:System.Messaging.MessageQueue" /> 引用的非事务性队列，并指定消息的标签。</span><span class="sxs-lookup"><span data-stu-id="b3203-3037">Sends an object to the non-transactional queue referenced by this <see cref="T:System.Messaging.MessageQueue" /> and specifies a label for the message.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-3038">使用此重载将包含参数的消息发送 `obj` 到由引用的队列 <xref:System.Messaging.MessageQueue> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-3038">Use this overload to send a message that contains the `obj` parameter to the queue referenced by the <xref:System.Messaging.MessageQueue>.</span></span> <span data-ttu-id="b3203-3039">利用此重载，可以指定标识消息的字符串标签。</span><span class="sxs-lookup"><span data-stu-id="b3203-3039">With this overload, you can specify the string label that identifies the message.</span></span> <span data-ttu-id="b3203-3040">发送到队列的对象可以是 <xref:System.Messaging.Message> 、结构、数据对象或任何托管对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-3040">The object you send to the queue can be a <xref:System.Messaging.Message>, a structure, a data object, or any managed object.</span></span> <span data-ttu-id="b3203-3041">如果发送除之外的任何对象 <xref:System.Messaging.Message> ，则会序列化对象并将其插入消息的正文中。</span><span class="sxs-lookup"><span data-stu-id="b3203-3041">If you send any object other than a <xref:System.Messaging.Message>, the object is serialized and inserted into the body of the message.</span></span>  
  
 <span data-ttu-id="b3203-3042">消息标签不同于消息队列标签，但两者都依赖于应用程序，并且对消息队列没有继承意义。</span><span class="sxs-lookup"><span data-stu-id="b3203-3042">The message label is distinct from the message queue label, but both are application-dependent and have no inherit meaning to Message Queuing.</span></span>  
  
 <span data-ttu-id="b3203-3043">如果使用此重载将消息发送到事务性队列，则会将该消息发送到死信队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-3043">If you use this overload to send a message to a transactional queue, the message will be sent to the dead-letter queue.</span></span> <span data-ttu-id="b3203-3044">如果希望消息成为包含其他消息的事务的一部分，请使用采用 <xref:System.Messaging.MessageQueueTransaction> 或 <xref:System.Messaging.MessageQueueTransactionType> 作为参数的重载。</span><span class="sxs-lookup"><span data-stu-id="b3203-3044">If you want the message to be part of a transaction that contains other messages, use an overload that takes a <xref:System.Messaging.MessageQueueTransaction> or <xref:System.Messaging.MessageQueueTransactionType> as a parameter.</span></span>  
  
 <span data-ttu-id="b3203-3045"><xref:System.Messaging.MessageQueue.Path%2A> <xref:System.Messaging.MessageQueue> 必须先指定此实例的属性，然后才能发送消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-3045">The <xref:System.Messaging.MessageQueue.Path%2A> property for this <xref:System.Messaging.MessageQueue> instance must be specified before you send the message.</span></span> <span data-ttu-id="b3203-3046">如果在调用之前未设置 <xref:System.Messaging.MessageQueue.Formatter%2A> 属性 <xref:System.Messaging.MessageQueue.Send%28System.Object%29> ，则格式化程序默认为 <xref:System.Messaging.XmlMessageFormatter> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-3046">If you do not set the <xref:System.Messaging.MessageQueue.Formatter%2A> property before calling <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, the formatter defaults to the <xref:System.Messaging.XmlMessageFormatter>.</span></span>  
  
 <span data-ttu-id="b3203-3047"><xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>属性应用于以外的任何对象 <xref:System.Messaging.Message> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-3047">The <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> property applies to any object other than a <xref:System.Messaging.Message>.</span></span> <span data-ttu-id="b3203-3048">例如，如果使用成员指定标签或优先级 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> ，则 <xref:System.Messaging.Message> 在应用程序将其发送到队列时，这些值将应用于包含不属于类型的对象的任何消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-3048">If you specify, for example, a label or a priority using the <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> member, these values apply to any message that contains an object that is not of type <xref:System.Messaging.Message> when your application sends it to the queue.</span></span> <span data-ttu-id="b3203-3049">在发送时 <xref:System.Messaging.Message> ，为设置的属性值 <xref:System.Messaging.Message> 优先于， <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 并且消息的 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 属性优先于队列的 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="b3203-3049">When sending a <xref:System.Messaging.Message>, the property values set for the <xref:System.Messaging.Message> take precedence over <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> and the message's <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> property takes precedence over the queue's <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="b3203-3050">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-3050">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-3051">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-3051">Workgroup mode</span></span>|<span data-ttu-id="b3203-3052">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-3052">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-3053">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-3053">Local computer</span></span>|<span data-ttu-id="b3203-3054">是</span><span class="sxs-lookup"><span data-stu-id="b3203-3054">Yes</span></span>|  
|<span data-ttu-id="b3203-3055">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-3055">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-3056">是</span><span class="sxs-lookup"><span data-stu-id="b3203-3056">Yes</span></span>|  
|<span data-ttu-id="b3203-3057">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-3057">Remote computer</span></span>|<span data-ttu-id="b3203-3058">否</span><span class="sxs-lookup"><span data-stu-id="b3203-3058">No</span></span>|  
|<span data-ttu-id="b3203-3059">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-3059">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-3060">是</span><span class="sxs-lookup"><span data-stu-id="b3203-3060">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-3061">以下代码示例演示了 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29> 的用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-3061">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3203-3062"><paramref name="label" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-3062">The <paramref name="label" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-3063">尚未设置 <see cref="P:System.Messaging.MessageQueue.Path" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="b3203-3063">The <see cref="P:System.Messaging.MessageQueue.Path" /> property has not been set.</span></span>  
  
<span data-ttu-id="b3203-3064">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-3064">-or-</span></span> 
<span data-ttu-id="b3203-3065">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-3065">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, label, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="b3203-3066">要发送到队列的对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-3066">The object to send to the queue.</span></span></param>
        <param name="label"><span data-ttu-id="b3203-3067">消息的标签。</span><span class="sxs-lookup"><span data-stu-id="b3203-3067">The label of the message.</span></span></param>
        <param name="transaction"><span data-ttu-id="b3203-3068"><see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-3068">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</span></span></param>
        <summary><span data-ttu-id="b3203-3069">将对象发送到此 <see cref="T:System.Messaging.MessageQueue" /> 引用的事务性队列中，并指定该消息的标签。</span><span class="sxs-lookup"><span data-stu-id="b3203-3069">Sends an object to the transactional queue referenced by this <see cref="T:System.Messaging.MessageQueue" /> and specifies a label for the message.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-3070">使用此重载 `obj` <xref:System.Messaging.MessageQueue> ，使用由参数定义的内部事务上下文将包含参数的消息发送到引用的事务性队列 `transaction` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-3070">Use this overload to send a message that contains the `obj` parameter to the transactional queue referenced by the <xref:System.Messaging.MessageQueue>, using an internal transaction context defined by the `transaction` parameter.</span></span> <span data-ttu-id="b3203-3071">利用此重载，可以指定标识消息的字符串标签。</span><span class="sxs-lookup"><span data-stu-id="b3203-3071">With this overload, you can specify the string label that identifies the message.</span></span> <span data-ttu-id="b3203-3072">发送到队列的对象可以是 <xref:System.Messaging.Message> 、结构、数据对象或任何托管对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-3072">The object you send to the queue can be a <xref:System.Messaging.Message>, a structure, a data object, or any managed object.</span></span> <span data-ttu-id="b3203-3073">如果发送除之外的任何对象 <xref:System.Messaging.Message> ，则会序列化对象并将其插入消息的正文中。</span><span class="sxs-lookup"><span data-stu-id="b3203-3073">If you send any object other than a <xref:System.Messaging.Message>, the object is serialized and inserted into the body of the message.</span></span>  
  
 <span data-ttu-id="b3203-3074">消息标签不同于消息队列标签，但两者都依赖于应用程序，并且对消息队列没有继承意义。</span><span class="sxs-lookup"><span data-stu-id="b3203-3074">The message label is distinct from the message queue label, but both are application-dependent and have no inherit meaning to Message Queuing.</span></span>  
  
 <span data-ttu-id="b3203-3075">如果使用此重载将消息发送到非事务性队列，则可能会将该消息发送到死信队列，而不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-3075">If you use this overload to send a message to a non-transactional queue, the message might be sent to the dead-letter queue without throwing an exception.</span></span>  
  
 <span data-ttu-id="b3203-3076">如果在调用之前未设置 <xref:System.Messaging.MessageQueue.Formatter%2A> 属性 <xref:System.Messaging.MessageQueue.Send%28System.Object%29> ，则格式化程序默认为 <xref:System.Messaging.XmlMessageFormatter> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-3076">If you do not set the <xref:System.Messaging.MessageQueue.Formatter%2A> property before calling <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, the formatter defaults to the <xref:System.Messaging.XmlMessageFormatter>.</span></span>  
  
 <span data-ttu-id="b3203-3077"><xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>属性应用于以外的任何对象 <xref:System.Messaging.Message> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-3077">The <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> property applies to any object other than a <xref:System.Messaging.Message>.</span></span> <span data-ttu-id="b3203-3078">例如，如果使用成员指定标签或优先级 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> ，则 <xref:System.Messaging.Message> 在应用程序将其发送到队列时，这些值将应用于包含不属于类型的对象的任何消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-3078">If you specify, for example, a label or a priority using the <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> member, these values apply to any message that contains an object that is not of type <xref:System.Messaging.Message> when your application sends it to the queue.</span></span> <span data-ttu-id="b3203-3079">在发送时 <xref:System.Messaging.Message> ，为设置的属性值 <xref:System.Messaging.Message> 优先于， <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 并且消息的 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 属性优先于队列的 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 属性</span><span class="sxs-lookup"><span data-stu-id="b3203-3079">When sending a <xref:System.Messaging.Message>, the property values set for the <xref:System.Messaging.Message> take precedence over <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> and the message's <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> property takes precedence over the queue's <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> property</span></span>  
  
 <span data-ttu-id="b3203-3080"><xref:System.Messaging.MessageQueueTransaction> 线程单元感知，因此，如果单元状态为 `STA` ，则不能在多个线程中使用事务。</span><span class="sxs-lookup"><span data-stu-id="b3203-3080"><xref:System.Messaging.MessageQueueTransaction> is threading apartment aware, so if your apartment state is `STA`, you cannot use the transaction in multiple threads.</span></span> <span data-ttu-id="b3203-3081">Visual Basic 将主线程的状态设置为 `STA` ，因此你必须 <xref:System.MTAThreadAttribute> 在子例程中应用 `Main` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-3081">Visual Basic sets the state of the main thread to `STA`, so you must apply the <xref:System.MTAThreadAttribute> in the `Main` subroutine.</span></span> <span data-ttu-id="b3203-3082">否则，利用另一个线程发送事务性消息将引发 <xref:System.Messaging.MessageQueueException> 异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-3082">Otherwise, sending a transactional message using another thread throws a <xref:System.Messaging.MessageQueueException> exception.</span></span> <span data-ttu-id="b3203-3083"><xref:System.MTAThreadAttribute>使用以下片段应用。</span><span class="sxs-lookup"><span data-stu-id="b3203-3083">You apply the <xref:System.MTAThreadAttribute> by using the following fragment.</span></span>  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 <span data-ttu-id="b3203-3084">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-3084">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-3085">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-3085">Workgroup mode</span></span>|<span data-ttu-id="b3203-3086">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-3086">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-3087">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-3087">Local computer</span></span>|<span data-ttu-id="b3203-3088">是</span><span class="sxs-lookup"><span data-stu-id="b3203-3088">Yes</span></span>|  
|<span data-ttu-id="b3203-3089">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-3089">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-3090">是</span><span class="sxs-lookup"><span data-stu-id="b3203-3090">Yes</span></span>|  
|<span data-ttu-id="b3203-3091">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-3091">Remote computer</span></span>|<span data-ttu-id="b3203-3092">否</span><span class="sxs-lookup"><span data-stu-id="b3203-3092">No</span></span>|  
|<span data-ttu-id="b3203-3093">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-3093">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-3094">是</span><span class="sxs-lookup"><span data-stu-id="b3203-3094">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-3095">以下代码示例演示了 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29> 的用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-3095">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3203-3096"><paramref name="label" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-3096">The <paramref name="label" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="b3203-3097">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-3097">-or-</span></span> 
<span data-ttu-id="b3203-3098"><paramref name="transaction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-3098">The <paramref name="transaction" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-3099">尚未设置 <see cref="P:System.Messaging.MessageQueue.Path" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="b3203-3099">The <see cref="P:System.Messaging.MessageQueue.Path" /> property has not been set.</span></span>  
  
<span data-ttu-id="b3203-3100">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-3100">-or-</span></span> 
<span data-ttu-id="b3203-3101">“消息队列”应用程序指示了不正确的事务用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-3101">The Message Queuing application indicated an incorrect transaction usage.</span></span>  
  
<span data-ttu-id="b3203-3102">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-3102">-or-</span></span> 
<span data-ttu-id="b3203-3103">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-3103">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, label, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="b3203-3104">要发送到队列的对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-3104">The object to send to the queue.</span></span></param>
        <param name="label"><span data-ttu-id="b3203-3105">消息的标签。</span><span class="sxs-lookup"><span data-stu-id="b3203-3105">The label of the message.</span></span></param>
        <param name="transactionType"><span data-ttu-id="b3203-3106"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文的类型。</span><span class="sxs-lookup"><span data-stu-id="b3203-3106">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span></span></param>
        <summary><span data-ttu-id="b3203-3107">将对象发送到此 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列中，并指定该消息的标签。</span><span class="sxs-lookup"><span data-stu-id="b3203-3107">Sends an object to the queue referenced by this <see cref="T:System.Messaging.MessageQueue" /> and specifies a label for the message.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-3108">使用此重载将包含参数的消息发送 `obj` 到由引用的队列 <xref:System.Messaging.MessageQueue> ，使用由参数定义的事务上下文 `transactionType` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-3108">Use this overload to send a message that contains the `obj` parameter to the queue referenced by the <xref:System.Messaging.MessageQueue>, using a transaction context defined by the `transactionType` parameter.</span></span> <span data-ttu-id="b3203-3109">`Automatic` `transactionType` 如果已存在附加到要用于发送消息的线程的外部事务上下文，请为参数指定。</span><span class="sxs-lookup"><span data-stu-id="b3203-3109">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to send the message.</span></span> <span data-ttu-id="b3203-3110">指定 `Single` 是否要将消息作为单个内部事务发送。</span><span class="sxs-lookup"><span data-stu-id="b3203-3110">Specify `Single` if you want to send the message as a single internal transaction.</span></span> <span data-ttu-id="b3203-3111">您可以指定 `None` 是否要将事务性消息发送到非事务性线程。</span><span class="sxs-lookup"><span data-stu-id="b3203-3111">You can specify `None` if you want to send a transactional message to a non-transactional thread.</span></span>  
  
 <span data-ttu-id="b3203-3112">发送到队列的对象可以为 <xref:System.Messaging.Message> 或任何托管对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-3112">The object you send to the queue can be a <xref:System.Messaging.Message> or any managed object.</span></span> <span data-ttu-id="b3203-3113">如果发送除之外的任何对象 <xref:System.Messaging.Message> ，则会序列化对象并将其插入消息的正文中。</span><span class="sxs-lookup"><span data-stu-id="b3203-3113">If you send any object other than a <xref:System.Messaging.Message>, the object is serialized and inserted into the body of the message.</span></span> <span data-ttu-id="b3203-3114">利用此重载，可以指定标识消息的字符串标签。</span><span class="sxs-lookup"><span data-stu-id="b3203-3114">With this overload, you can specify the string label that identifies the message.</span></span>  
  
 <span data-ttu-id="b3203-3115">消息标签不同于消息队列标签，但两者都依赖于应用程序，并且对消息队列没有继承意义。</span><span class="sxs-lookup"><span data-stu-id="b3203-3115">The message label is distinct from the message queue label, but both are application-dependent and have no inherit meaning to Message Queuing.</span></span>  
  
 <span data-ttu-id="b3203-3116">如果在调用之前未设置 <xref:System.Messaging.MessageQueue.Formatter%2A> 属性 <xref:System.Messaging.MessageQueue.Send%28System.Object%29> ，则格式化程序默认为 <xref:System.Messaging.XmlMessageFormatter> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-3116">If you do not set the <xref:System.Messaging.MessageQueue.Formatter%2A> property before calling <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, the formatter defaults to the <xref:System.Messaging.XmlMessageFormatter>.</span></span>  
  
 <span data-ttu-id="b3203-3117"><xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>属性应用于以外的任何对象 <xref:System.Messaging.Message> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-3117">The <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> property applies to any object other than a <xref:System.Messaging.Message>.</span></span> <span data-ttu-id="b3203-3118">例如，如果使用成员指定标签或优先级 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> ，则 <xref:System.Messaging.Message> 在应用程序将其发送到队列时，这些值将应用于包含不属于类型的对象的任何消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-3118">If you specify, for example, a label or a priority using the <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> member, these values apply to any message that contains an object that is not of type <xref:System.Messaging.Message> when your application sends it to the queue.</span></span> <span data-ttu-id="b3203-3119">在发送时 <xref:System.Messaging.Message> ，为设置的属性值 <xref:System.Messaging.Message> 优先于 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> ，并且消息的 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 属性优先于队列的 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="b3203-3119">When sending a <xref:System.Messaging.Message>, the property values set for the <xref:System.Messaging.Message> take precedence over <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, and the message's <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> property takes precedence over the queue's <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="b3203-3120">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-3120">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-3121">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-3121">Workgroup mode</span></span>|<span data-ttu-id="b3203-3122">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-3122">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-3123">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-3123">Local computer</span></span>|<span data-ttu-id="b3203-3124">是</span><span class="sxs-lookup"><span data-stu-id="b3203-3124">Yes</span></span>|  
|<span data-ttu-id="b3203-3125">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-3125">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-3126">是</span><span class="sxs-lookup"><span data-stu-id="b3203-3126">Yes</span></span>|  
|<span data-ttu-id="b3203-3127">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-3127">Remote computer</span></span>|<span data-ttu-id="b3203-3128">否</span><span class="sxs-lookup"><span data-stu-id="b3203-3128">No</span></span>|  
|<span data-ttu-id="b3203-3129">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-3129">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-3130">是</span><span class="sxs-lookup"><span data-stu-id="b3203-3130">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-3131">以下代码示例演示了 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-3131">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3203-3132"><paramref name="label" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-3132">The <paramref name="label" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction"><span data-ttu-id="b3203-3133">“消息队列”应用程序指示了不正确的事务用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-3133">The Message Queuing application indicated an incorrect transaction usage.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="b3203-3134"><paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</span><span class="sxs-lookup"><span data-stu-id="b3203-3134">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-3135">尚未设置 <see cref="P:System.Messaging.MessageQueue.Path" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="b3203-3135">The <see cref="P:System.Messaging.MessageQueue.Path" /> property has not been set.</span></span>  
  
<span data-ttu-id="b3203-3136">- 或 -</span><span class="sxs-lookup"><span data-stu-id="b3203-3136">-or-</span></span> 
<span data-ttu-id="b3203-3137">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-3137">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetPermissions">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b3203-3138">将权限添加到当前集合中。</span><span class="sxs-lookup"><span data-stu-id="b3203-3138">Adds permissions to the current set.</span></span> <span data-ttu-id="b3203-3139">这样可控制谁对队列中的队列属性和消息具有访问权限。</span><span class="sxs-lookup"><span data-stu-id="b3203-3139">This controls who has access rights to queue properties and messages in the queue.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (dacl As AccessControlList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::AccessControlList ^ dacl);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.AccessControlList -&gt; unit" Usage="messageQueue.SetPermissions dacl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl"><span data-ttu-id="b3203-3140"><see cref="T:System.Messaging.AccessControlList" />，包含一个或多个指定受信者和要授予的权限的访问控制项。</span><span class="sxs-lookup"><span data-stu-id="b3203-3140">A <see cref="T:System.Messaging.AccessControlList" /> that contains one or more access control entries that specify the trustees and the permissions to grant.</span></span></param>
        <summary><span data-ttu-id="b3203-3141">基于访问控制列表的内容将访问权限分配给队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-3141">Assigns access rights to the queue based on the contents of an access control list.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-3142">使用此重载可通过使用访问控制项的集合指定受信者和权限信息来授予、拒绝或撤消权限。</span><span class="sxs-lookup"><span data-stu-id="b3203-3142">Use this overload to grant, deny, or revoke rights by using a collection of access control entries to specify trustee and permissions information.</span></span> <span data-ttu-id="b3203-3143">例如，使用此项可以同时向多个用户授予权限。</span><span class="sxs-lookup"><span data-stu-id="b3203-3143">This is used, for example, to grant permissions to multiple users at the same time.</span></span>  
  
 <span data-ttu-id="b3203-3144">构造参数时指定的受信者 `ace` 可以是单个用户、用户组或计算机。</span><span class="sxs-lookup"><span data-stu-id="b3203-3144">The trustee you specify when you construct the `ace` parameter can be an individual user, a group of users, or a computer.</span></span> <span data-ttu-id="b3203-3145">如果受信者是个人，请使用格式 `DOMAIN` \\ `user` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-3145">If the trustee is an individual, use the format `DOMAIN`\\`user`.</span></span> <span data-ttu-id="b3203-3146">您可以为受信者指定 "."，以指示本地计算机。</span><span class="sxs-lookup"><span data-stu-id="b3203-3146">You can specify "." for the trustee to indicate the local computer.</span></span>  
  
 <span data-ttu-id="b3203-3147">通过 <xref:System.Messaging.MessageQueue.SetPermissions%2A> 向现有列表添加权限指定的权限。</span><span class="sxs-lookup"><span data-stu-id="b3203-3147">The permissions you assign through <xref:System.Messaging.MessageQueue.SetPermissions%2A> add rights to the existing list.</span></span> <span data-ttu-id="b3203-3148">默认情况下，公用或专用队列的创建者具有 "完全控制" 权限，而 "域组" 有权获取队列属性、获取权限和写入队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-3148">By default, the creator of a public or private queue has full control, and the domain group Everyone has permission to get queue properties, get permissions, and write to the queue.</span></span> <span data-ttu-id="b3203-3149">调用时 <xref:System.Messaging.MessageQueue.SetPermissions%2A> ，会将用户和权限信息追加到现有列表的底部。</span><span class="sxs-lookup"><span data-stu-id="b3203-3149">When you call <xref:System.Messaging.MessageQueue.SetPermissions%2A>, the user and permissions information is appended to the bottom of the existing list.</span></span>  
  
 <span data-ttu-id="b3203-3150">系统 <xref:System.Messaging.AccessControlEntry> 会按顺序检查每个事件，直到发生以下事件之一：</span><span class="sxs-lookup"><span data-stu-id="b3203-3150">The system examines each <xref:System.Messaging.AccessControlEntry> in sequence until one of the following events occurs:</span></span>  
  
-   <span data-ttu-id="b3203-3151">拒绝访问会 <xref:System.Messaging.AccessControlEntry> 显式拒绝对线程的访问令牌中列出的某个受信者所请求的任何访问权限。</span><span class="sxs-lookup"><span data-stu-id="b3203-3151">An access-denied <xref:System.Messaging.AccessControlEntry> explicitly denies any of the requested access rights to one of the trustees listed in the thread's access token.</span></span>  
  
-   <span data-ttu-id="b3203-3152">线程的访问令牌中列出的受信者的一个或多个允许访问的 <xref:System.Messaging.AccessControlEntry> 项显式授予所有请求的访问权限。</span><span class="sxs-lookup"><span data-stu-id="b3203-3152">One or more access-allowed <xref:System.Messaging.AccessControlEntry> items for trustees listed in the thread's access token explicitly grant all the requested access rights.</span></span>  
  
-   <span data-ttu-id="b3203-3153">已 <xref:System.Messaging.AccessControlEntry> 检查所有项，但至少有一个请求的访问权限尚未显式允许，在这种情况下，访问将被隐式拒绝。</span><span class="sxs-lookup"><span data-stu-id="b3203-3153">All <xref:System.Messaging.AccessControlEntry> items have been checked and there is still at least one requested access right that has not been explicitly allowed, in which case, access is implicitly denied.</span></span>  
  
 <span data-ttu-id="b3203-3154">构造 `dacl` 参数时，请将实例添加 <xref:System.Messaging.AccessControlEntry> 到集合中 <xref:System.Messaging.AccessControlList> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-3154">When you construct the `dacl` parameter, you add <xref:System.Messaging.AccessControlEntry> instances to your <xref:System.Messaging.AccessControlList> collection.</span></span> <span data-ttu-id="b3203-3155">构造每个访问控制项时，可以指定常规或标准访问权限。</span><span class="sxs-lookup"><span data-stu-id="b3203-3155">When you construct each access control entry, you can specify generic or standard access rights.</span></span> <span data-ttu-id="b3203-3156">队列的权限可以是以下各项的任意组合：</span><span class="sxs-lookup"><span data-stu-id="b3203-3156">The rights to a queue can be any combination of the following:</span></span>  
  
-   <span data-ttu-id="b3203-3157">删除</span><span class="sxs-lookup"><span data-stu-id="b3203-3157">Delete</span></span>  
  
-   <span data-ttu-id="b3203-3158">读取安全</span><span class="sxs-lookup"><span data-stu-id="b3203-3158">Read Security</span></span>  
  
-   <span data-ttu-id="b3203-3159">写入安全性</span><span class="sxs-lookup"><span data-stu-id="b3203-3159">Write Security</span></span>  
  
-   <span data-ttu-id="b3203-3160">同步</span><span class="sxs-lookup"><span data-stu-id="b3203-3160">Synchronize</span></span>  
  
-   <span data-ttu-id="b3203-3161">修改所有者</span><span class="sxs-lookup"><span data-stu-id="b3203-3161">Modify Owner</span></span>  
  
-   <span data-ttu-id="b3203-3162">读取</span><span class="sxs-lookup"><span data-stu-id="b3203-3162">Read</span></span>  
  
-   <span data-ttu-id="b3203-3163">Write</span><span class="sxs-lookup"><span data-stu-id="b3203-3163">Write</span></span>  
  
-   <span data-ttu-id="b3203-3164">执行</span><span class="sxs-lookup"><span data-stu-id="b3203-3164">Execute</span></span>  
  
-   <span data-ttu-id="b3203-3165">必需</span><span class="sxs-lookup"><span data-stu-id="b3203-3165">Required</span></span>  
  
-   <span data-ttu-id="b3203-3166">全部</span><span class="sxs-lookup"><span data-stu-id="b3203-3166">All</span></span>  
  
-   <span data-ttu-id="b3203-3167">None</span><span class="sxs-lookup"><span data-stu-id="b3203-3167">None</span></span>  
  
 <span data-ttu-id="b3203-3168">这些权限是可使用或按位运算符组合的一组位标志。</span><span class="sxs-lookup"><span data-stu-id="b3203-3168">These rights are a set of bit flags that you can combine using the OR bitwise operator.</span></span>  
  
-   <span data-ttu-id="b3203-3169">完全控制</span><span class="sxs-lookup"><span data-stu-id="b3203-3169">Full Control</span></span>  
  
-   <span data-ttu-id="b3203-3170">删除消息</span><span class="sxs-lookup"><span data-stu-id="b3203-3170">Delete Message</span></span>  
  
-   <span data-ttu-id="b3203-3171">接收消息</span><span class="sxs-lookup"><span data-stu-id="b3203-3171">Receive Message</span></span>  
  
-   <span data-ttu-id="b3203-3172">扫视消息</span><span class="sxs-lookup"><span data-stu-id="b3203-3172">Peek Message</span></span>  
  
-   <span data-ttu-id="b3203-3173">接收日志消息</span><span class="sxs-lookup"><span data-stu-id="b3203-3173">Receive Journal Message</span></span>  
  
-   <span data-ttu-id="b3203-3174">获取队列属性</span><span class="sxs-lookup"><span data-stu-id="b3203-3174">Get Queue Properties</span></span>  
  
-   <span data-ttu-id="b3203-3175">设置队列属性</span><span class="sxs-lookup"><span data-stu-id="b3203-3175">Set Queue Properties</span></span>  
  
-   <span data-ttu-id="b3203-3176">获取权限</span><span class="sxs-lookup"><span data-stu-id="b3203-3176">Get Permissions</span></span>  
  
-   <span data-ttu-id="b3203-3177">设置权限</span><span class="sxs-lookup"><span data-stu-id="b3203-3177">Set Permissions</span></span>  
  
-   <span data-ttu-id="b3203-3178">获取队列所有权</span><span class="sxs-lookup"><span data-stu-id="b3203-3178">Take Queue Ownership</span></span>  
  
-   <span data-ttu-id="b3203-3179"> 编写消息</span><span class="sxs-lookup"><span data-stu-id="b3203-3179">Write Message</span></span>  
  
 <span data-ttu-id="b3203-3180">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-3180">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-3181">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-3181">Workgroup mode</span></span>|<span data-ttu-id="b3203-3182">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-3182">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-3183">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-3183">Local computer</span></span>|<span data-ttu-id="b3203-3184">是</span><span class="sxs-lookup"><span data-stu-id="b3203-3184">Yes</span></span>|  
|<span data-ttu-id="b3203-3185">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-3185">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-3186">是</span><span class="sxs-lookup"><span data-stu-id="b3203-3186">Yes</span></span>|  
|<span data-ttu-id="b3203-3187">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-3187">Remote computer</span></span>|<span data-ttu-id="b3203-3188">否</span><span class="sxs-lookup"><span data-stu-id="b3203-3188">No</span></span>|  
|<span data-ttu-id="b3203-3189">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-3189">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-3190">否</span><span class="sxs-lookup"><span data-stu-id="b3203-3190">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-3191">以下代码示例演示了 <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29> 的用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-3191">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29>.</span></span>      
  
 [!code-cpp[MessageQueue2#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-3192">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-3192">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.AccessControlList" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (ace As MessageQueueAccessControlEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::MessageQueueAccessControlEntry ^ ace);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.MessageQueueAccessControlEntry -&gt; unit" Usage="messageQueue.SetPermissions ace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace"><span data-ttu-id="b3203-3193">指定用户、访问类型和权限类型的 <see cref="T:System.Messaging.MessageQueueAccessControlEntry" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-3193">A <see cref="T:System.Messaging.MessageQueueAccessControlEntry" /> that specifies a user, an access type, and a permission type.</span></span></param>
        <summary><span data-ttu-id="b3203-3194">基于访问控制项的内容将访问权限分配给队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-3194">Assigns access rights to the queue based on the contents of an access control entry.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-3195">使用此重载通过访问控制项指定受信者和权限信息来授予、拒绝或撤消权限。</span><span class="sxs-lookup"><span data-stu-id="b3203-3195">Use this overload to grant, deny, or revoke rights by using an access control entry to specify trustee and rights information.</span></span>  
  
 <span data-ttu-id="b3203-3196">构造参数时指定的受信者 `ace` 可以是单个用户、用户组或计算机。</span><span class="sxs-lookup"><span data-stu-id="b3203-3196">The trustee you specify when you construct the `ace` parameter can be an individual user, a group of users, or a computer.</span></span> <span data-ttu-id="b3203-3197">如果受信者是个人，请使用格式 `DOMAIN` \\ `user` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-3197">If the trustee is an individual, use the format `DOMAIN`\\`user`.</span></span> <span data-ttu-id="b3203-3198">您可以为受信者指定 "."，以指示本地计算机。</span><span class="sxs-lookup"><span data-stu-id="b3203-3198">You can specify "." for the trustee to indicate the local computer.</span></span>  
  
 <span data-ttu-id="b3203-3199">通过 <xref:System.Messaging.MessageQueue.SetPermissions%2A> 向现有列表添加权限指定的权限。</span><span class="sxs-lookup"><span data-stu-id="b3203-3199">The permissions you assign through <xref:System.Messaging.MessageQueue.SetPermissions%2A> add rights to the existing list.</span></span> <span data-ttu-id="b3203-3200">默认情况下，公用或专用队列的创建者具有 "完全控制" 权限，而 "域组" 有权获取队列属性、获取权限和写入队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-3200">By default, the creator of a public or private queue has full control, and the domain group Everyone has permission to get queue properties, get permissions, and write to the queue.</span></span> <span data-ttu-id="b3203-3201">调用时 <xref:System.Messaging.MessageQueue.SetPermissions%2A> ，会将用户和权限信息追加到现有列表的底部。</span><span class="sxs-lookup"><span data-stu-id="b3203-3201">When you call <xref:System.Messaging.MessageQueue.SetPermissions%2A>, the user and permissions information is appended to the bottom of the existing list.</span></span>  
  
 <span data-ttu-id="b3203-3202">系统 <xref:System.Messaging.AccessControlEntry> 会按顺序检查每个事件，直到发生以下事件之一：</span><span class="sxs-lookup"><span data-stu-id="b3203-3202">The system examines each <xref:System.Messaging.AccessControlEntry> in sequence until one of the following events occurs:</span></span>  
  
-   <span data-ttu-id="b3203-3203">拒绝访问会 <xref:System.Messaging.AccessControlEntry> 显式拒绝对线程的访问令牌中列出的某个受信者所请求的任何访问权限。</span><span class="sxs-lookup"><span data-stu-id="b3203-3203">An access-denied <xref:System.Messaging.AccessControlEntry> explicitly denies any of the requested access rights to one of the trustees listed in the thread's access token.</span></span>  
  
-   <span data-ttu-id="b3203-3204">线程的访问令牌中列出的受信者的一个或多个允许访问的 <xref:System.Messaging.AccessControlEntry> 项显式授予所有请求的访问权限。</span><span class="sxs-lookup"><span data-stu-id="b3203-3204">One or more access-allowed <xref:System.Messaging.AccessControlEntry> items for trustees listed in the thread's access token explicitly grant all the requested access rights.</span></span>  
  
-   <span data-ttu-id="b3203-3205">已 <xref:System.Messaging.AccessControlEntry> 检查所有项，但至少有一个请求的访问权限尚未显式允许，在这种情况下，访问将被隐式拒绝。</span><span class="sxs-lookup"><span data-stu-id="b3203-3205">All <xref:System.Messaging.AccessControlEntry> items have been checked and there is still at least one requested access right that has not been explicitly allowed, in which case, access is implicitly denied.</span></span>  
  
 <span data-ttu-id="b3203-3206">在构造时在参数中指定的对队列的权限 `rights` <xref:System.Messaging.MessageQueueAccessControlEntry> ，可以是以下任意组合：</span><span class="sxs-lookup"><span data-stu-id="b3203-3206">The rights to a queue, which you specify in the `rights` parameter when you construct your <xref:System.Messaging.MessageQueueAccessControlEntry>, can be any combination of the following:</span></span>  
  
-   <span data-ttu-id="b3203-3207">完全控制</span><span class="sxs-lookup"><span data-stu-id="b3203-3207">Full Control</span></span>  
  
-   <span data-ttu-id="b3203-3208">删除消息</span><span class="sxs-lookup"><span data-stu-id="b3203-3208">Delete Message</span></span>  
  
-   <span data-ttu-id="b3203-3209">接收消息</span><span class="sxs-lookup"><span data-stu-id="b3203-3209">Receive Message</span></span>  
  
-   <span data-ttu-id="b3203-3210">扫视消息</span><span class="sxs-lookup"><span data-stu-id="b3203-3210">Peek Message</span></span>  
  
-   <span data-ttu-id="b3203-3211">接收日志消息</span><span class="sxs-lookup"><span data-stu-id="b3203-3211">Receive Journal Message</span></span>  
  
-   <span data-ttu-id="b3203-3212">获取队列属性</span><span class="sxs-lookup"><span data-stu-id="b3203-3212">Get Queue Properties</span></span>  
  
-   <span data-ttu-id="b3203-3213">设置队列属性</span><span class="sxs-lookup"><span data-stu-id="b3203-3213">Set Queue Properties</span></span>  
  
-   <span data-ttu-id="b3203-3214">获取权限</span><span class="sxs-lookup"><span data-stu-id="b3203-3214">Get Permissions</span></span>  
  
-   <span data-ttu-id="b3203-3215">设置权限</span><span class="sxs-lookup"><span data-stu-id="b3203-3215">Set Permissions</span></span>  
  
-   <span data-ttu-id="b3203-3216">获取队列所有权</span><span class="sxs-lookup"><span data-stu-id="b3203-3216">Take Queue Ownership</span></span>  
  
-   <span data-ttu-id="b3203-3217"> 编写消息</span><span class="sxs-lookup"><span data-stu-id="b3203-3217">Write Message</span></span>  
  
 <span data-ttu-id="b3203-3218">`rights`在参数的构造函数中指定的参数 `ace` 是枚举的标志 <xref:System.Messaging.MessageQueueAccessRights> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-3218">The `rights` parameter you specify in the constructor for the `ace` parameter is a flag of the <xref:System.Messaging.MessageQueueAccessRights> enumeration.</span></span> <span data-ttu-id="b3203-3219">它表示一组可以使用按位运算符或在生成参数时进行组合的位标志 `rights` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-3219">It represents a set of bit flags that you can combine using the bitwise operator OR when you build the `rights` parameter.</span></span>  
  
 <span data-ttu-id="b3203-3220">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-3220">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-3221">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-3221">Workgroup mode</span></span>|<span data-ttu-id="b3203-3222">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-3222">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-3223">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-3223">Local computer</span></span>|<span data-ttu-id="b3203-3224">是</span><span class="sxs-lookup"><span data-stu-id="b3203-3224">Yes</span></span>|  
|<span data-ttu-id="b3203-3225">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-3225">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-3226">是</span><span class="sxs-lookup"><span data-stu-id="b3203-3226">Yes</span></span>|  
|<span data-ttu-id="b3203-3227">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-3227">Remote computer</span></span>|<span data-ttu-id="b3203-3228">否</span><span class="sxs-lookup"><span data-stu-id="b3203-3228">No</span></span>|  
|<span data-ttu-id="b3203-3229">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-3229">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-3230">否</span><span class="sxs-lookup"><span data-stu-id="b3203-3230">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-3231">以下代码示例演示了 <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29> 的用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-3231">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-3232">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-3232">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.MessageQueueAccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights -&gt; unit" Usage="messageQueue.SetPermissions (user, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user"><span data-ttu-id="b3203-3233">获取对队列的附加权限的个人、组或计算机。</span><span class="sxs-lookup"><span data-stu-id="b3203-3233">The individual, group, or computer that gets additional rights to the queue.</span></span></param>
        <param name="rights"><span data-ttu-id="b3203-3234"><see cref="T:System.Messaging.MessageQueueAccessRights" />，指示对“消息队列”分配给传入的 <paramref name="user" /> 的队列权限集。</span><span class="sxs-lookup"><span data-stu-id="b3203-3234">A <see cref="T:System.Messaging.MessageQueueAccessRights" /> that indicates the set of rights to the queue that Message Queuing assigns to the <paramref name="user" /> passed in.</span></span></param>
        <summary><span data-ttu-id="b3203-3235">给予计算机、组或用户指定的访问权限。</span><span class="sxs-lookup"><span data-stu-id="b3203-3235">Gives a computer, group, or user the specified access rights.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-3236">使用此重载将指定的权限授予单个用户。</span><span class="sxs-lookup"><span data-stu-id="b3203-3236">Use this overload to grant specified rights to an individual user.</span></span> <span data-ttu-id="b3203-3237">用户可以是任何有效的受信者，其中包括个人用户、用户组或计算机。</span><span class="sxs-lookup"><span data-stu-id="b3203-3237">The user can be any valid trustee, which includes individual users, groups of users, or a computer.</span></span> <span data-ttu-id="b3203-3238">如果用户是个人，请使用参数的格式 `DOMAIN` \\ `user` `user` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-3238">If the user is an individual, use the format `DOMAIN`\\`user` for the `user` parameter.</span></span> <span data-ttu-id="b3203-3239">可以为参数指定 "."， `user` 以指示本地计算机。</span><span class="sxs-lookup"><span data-stu-id="b3203-3239">You can specify "." for the `user` parameter to indicate the local computer.</span></span>  
  
 <span data-ttu-id="b3203-3240">通过 <xref:System.Messaging.MessageQueue.SetPermissions%2A> 向现有列表添加权限指定的权限。</span><span class="sxs-lookup"><span data-stu-id="b3203-3240">The permissions you assign through <xref:System.Messaging.MessageQueue.SetPermissions%2A> add rights to the existing list.</span></span> <span data-ttu-id="b3203-3241">默认情况下，公用或专用队列的创建者具有 "完全控制" 权限，而 "域组" 有权获取队列属性、获取权限和写入队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-3241">By default, the creator of a public or private queue has full control, and the domain group Everyone has permission to get queue properties, get permissions, and write to the queue.</span></span> <span data-ttu-id="b3203-3242">调用时 <xref:System.Messaging.MessageQueue.SetPermissions%2A> ，会将用户和权限信息追加到现有列表的底部。</span><span class="sxs-lookup"><span data-stu-id="b3203-3242">When you call <xref:System.Messaging.MessageQueue.SetPermissions%2A>, the user and permissions information is appended to the bottom of the existing list.</span></span>  
  
 <span data-ttu-id="b3203-3243">系统 <xref:System.Messaging.AccessControlEntry> 会按顺序检查每个事件，直到发生以下事件之一：</span><span class="sxs-lookup"><span data-stu-id="b3203-3243">The system examines each <xref:System.Messaging.AccessControlEntry> in sequence until one of the following events occurs:</span></span>  
  
-   <span data-ttu-id="b3203-3244">拒绝访问会 <xref:System.Messaging.AccessControlEntry> 显式拒绝对线程的访问令牌中列出的某个受信者所请求的任何访问权限。</span><span class="sxs-lookup"><span data-stu-id="b3203-3244">An access-denied <xref:System.Messaging.AccessControlEntry> explicitly denies any of the requested access rights to one of the trustees listed in the thread's access token.</span></span>  
  
-   <span data-ttu-id="b3203-3245">线程的访问令牌中列出的受信者的一个或多个允许访问的 <xref:System.Messaging.AccessControlEntry> 项显式授予所有请求的访问权限。</span><span class="sxs-lookup"><span data-stu-id="b3203-3245">One or more access-allowed <xref:System.Messaging.AccessControlEntry> items for trustees listed in the thread's access token explicitly grant all the requested access rights.</span></span>  
  
-   <span data-ttu-id="b3203-3246">已 <xref:System.Messaging.AccessControlEntry> 检查所有项，但至少有一个请求的访问权限尚未显式允许，在这种情况下，访问将被隐式拒绝。</span><span class="sxs-lookup"><span data-stu-id="b3203-3246">All <xref:System.Messaging.AccessControlEntry> items have been checked and there is still at least one requested access right that has not been explicitly allowed, in which case, access is implicitly denied.</span></span>  
  
 <span data-ttu-id="b3203-3247">在参数中指定的对队列的权限 `rights` 可以是以下任意组合：</span><span class="sxs-lookup"><span data-stu-id="b3203-3247">The rights to a queue, specified in the `rights` parameter, can be any combination of the following:</span></span>  
  
-   <span data-ttu-id="b3203-3248">完全控制</span><span class="sxs-lookup"><span data-stu-id="b3203-3248">Full Control</span></span>  
  
-   <span data-ttu-id="b3203-3249">删除消息</span><span class="sxs-lookup"><span data-stu-id="b3203-3249">Delete Message</span></span>  
  
-   <span data-ttu-id="b3203-3250">接收消息</span><span class="sxs-lookup"><span data-stu-id="b3203-3250">Receive Message</span></span>  
  
-   <span data-ttu-id="b3203-3251">扫视消息</span><span class="sxs-lookup"><span data-stu-id="b3203-3251">Peek Message</span></span>  
  
-   <span data-ttu-id="b3203-3252">接收日志消息</span><span class="sxs-lookup"><span data-stu-id="b3203-3252">Receive Journal Message</span></span>  
  
-   <span data-ttu-id="b3203-3253">获取队列属性</span><span class="sxs-lookup"><span data-stu-id="b3203-3253">Get Queue Properties</span></span>  
  
-   <span data-ttu-id="b3203-3254">设置队列属性</span><span class="sxs-lookup"><span data-stu-id="b3203-3254">Set Queue Properties</span></span>  
  
-   <span data-ttu-id="b3203-3255">获取权限</span><span class="sxs-lookup"><span data-stu-id="b3203-3255">Get Permissions</span></span>  
  
-   <span data-ttu-id="b3203-3256">设置权限</span><span class="sxs-lookup"><span data-stu-id="b3203-3256">Set Permissions</span></span>  
  
-   <span data-ttu-id="b3203-3257">获取队列所有权</span><span class="sxs-lookup"><span data-stu-id="b3203-3257">Take Queue Ownership</span></span>  
  
-   <span data-ttu-id="b3203-3258"> 编写消息</span><span class="sxs-lookup"><span data-stu-id="b3203-3258">Write Message</span></span>  
  
 <span data-ttu-id="b3203-3259"><xref:System.Messaging.MessageQueueAccessRights>枚举表示一组可以使用按位运算符组合或用于生成参数的位标志 `rights` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-3259">The <xref:System.Messaging.MessageQueueAccessRights> enumeration represents a set of bit flags that you can combine using the bitwise operator OR to build the `rights` parameter.</span></span>  
  
 <span data-ttu-id="b3203-3260">利用此重载，只能授予权限;不能撤消或拒绝它们。</span><span class="sxs-lookup"><span data-stu-id="b3203-3260">With this overload, you can only grant permissions; you cannot revoke or deny them.</span></span> <span data-ttu-id="b3203-3261">必须使用其他重载显式授予除以外的任何 <xref:System.Messaging.AccessControlEntryType> 其他重载 `Allow` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-3261">You must use a different overload to explicitly grant any <xref:System.Messaging.AccessControlEntryType> other than `Allow`.</span></span>  
  
 <span data-ttu-id="b3203-3262">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-3262">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-3263">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-3263">Workgroup mode</span></span>|<span data-ttu-id="b3203-3264">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-3264">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-3265">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-3265">Local computer</span></span>|<span data-ttu-id="b3203-3266">是</span><span class="sxs-lookup"><span data-stu-id="b3203-3266">Yes</span></span>|  
|<span data-ttu-id="b3203-3267">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-3267">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-3268">是</span><span class="sxs-lookup"><span data-stu-id="b3203-3268">Yes</span></span>|  
|<span data-ttu-id="b3203-3269">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-3269">Remote computer</span></span>|<span data-ttu-id="b3203-3270">否</span><span class="sxs-lookup"><span data-stu-id="b3203-3270">No</span></span>|  
|<span data-ttu-id="b3203-3271">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-3271">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-3272">否</span><span class="sxs-lookup"><span data-stu-id="b3203-3272">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-3273">以下代码示例演示了 <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29> 的用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-3273">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3203-3274"><paramref name="user" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-3274">The <paramref name="user" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-3275">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-3275">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights, entryType As AccessControlEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights, System::Messaging::AccessControlEntryType entryType);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights * System.Messaging.AccessControlEntryType -&gt; unit" Usage="messageQueue.SetPermissions (user, rights, entryType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user"><span data-ttu-id="b3203-3276">获取对队列的附加权限的个人、组或计算机。</span><span class="sxs-lookup"><span data-stu-id="b3203-3276">The individual, group, or computer that gets additional rights to the queue.</span></span></param>
        <param name="rights"><span data-ttu-id="b3203-3277"><see cref="T:System.Messaging.MessageQueueAccessRights" />，指示对“消息队列”分配给传入的 <paramref name="user" /> 的队列权限集。</span><span class="sxs-lookup"><span data-stu-id="b3203-3277">A <see cref="T:System.Messaging.MessageQueueAccessRights" /> that indicates the set of rights to the queue that Message Queuing assigns to the <paramref name="user" /> passed in.</span></span></param>
        <param name="entryType"><span data-ttu-id="b3203-3278"><see cref="T:System.Messaging.AccessControlEntryType" />，指定授予、拒绝还是撤消 <paramref name="rights" /> 参数指定的权限。</span><span class="sxs-lookup"><span data-stu-id="b3203-3278">A <see cref="T:System.Messaging.AccessControlEntryType" /> that specifies whether to grant, deny, or revoke the permissions specified by the <paramref name="rights" /> parameter.</span></span></param>
        <summary><span data-ttu-id="b3203-3279">利用指定的访问控制类型（允许、拒绝、撤消或设置），给予计算机、组或用户指定的访问权限。</span><span class="sxs-lookup"><span data-stu-id="b3203-3279">Gives a computer, group, or user the specified access rights, with the specified access control type (allow, deny, revoke, or set).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-3280">使用此重载可为单个用户授予、拒绝或撤消指定的权限。</span><span class="sxs-lookup"><span data-stu-id="b3203-3280">Use this overload to grant, deny, or revoke specified rights for an individual user.</span></span> <span data-ttu-id="b3203-3281">用户可以是任何有效的受信者，其中包括个人用户、用户组或计算机。</span><span class="sxs-lookup"><span data-stu-id="b3203-3281">The user can be any valid trustee, which includes individual users, groups of users, or a computer.</span></span> <span data-ttu-id="b3203-3282">如果用户是个人，请使用参数的格式 `DOMAIN` \\ `user` `user` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-3282">If the user is an individual, use the format `DOMAIN`\\`user` for the `user` parameter.</span></span> <span data-ttu-id="b3203-3283">可以为参数指定 "."， `user` 以指示本地计算机。</span><span class="sxs-lookup"><span data-stu-id="b3203-3283">You can specify "." for the `user` parameter to indicate the local computer.</span></span>  
  
 <span data-ttu-id="b3203-3284">通过 <xref:System.Messaging.MessageQueue.SetPermissions%2A> 向现有列表添加权限指定的权限。</span><span class="sxs-lookup"><span data-stu-id="b3203-3284">The permissions you assign through <xref:System.Messaging.MessageQueue.SetPermissions%2A> add rights to the existing list.</span></span> <span data-ttu-id="b3203-3285">默认情况下，公用或专用队列的创建者具有 "完全控制" 权限，而 "域组" 有权获取队列属性、获取权限和写入队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-3285">By default, the creator of a public or private queue has full control, and the domain group Everyone has permission to get queue properties, get permissions, and write to the queue.</span></span> <span data-ttu-id="b3203-3286">调用时 <xref:System.Messaging.MessageQueue.SetPermissions%2A> ，会将用户和权限信息追加到现有列表的底部。</span><span class="sxs-lookup"><span data-stu-id="b3203-3286">When you call <xref:System.Messaging.MessageQueue.SetPermissions%2A>, the user and permissions information is appended to the bottom of the existing list.</span></span>  
  
 <span data-ttu-id="b3203-3287">系统 <xref:System.Messaging.AccessControlEntry> 会按顺序检查每个事件，直到发生以下事件之一：</span><span class="sxs-lookup"><span data-stu-id="b3203-3287">The system examines each <xref:System.Messaging.AccessControlEntry> in sequence until one of the following events occurs:</span></span>  
  
-   <span data-ttu-id="b3203-3288">拒绝访问会 <xref:System.Messaging.AccessControlEntry> 显式拒绝对线程的访问令牌中列出的某个受信者所请求的任何访问权限。</span><span class="sxs-lookup"><span data-stu-id="b3203-3288">An access-denied <xref:System.Messaging.AccessControlEntry> explicitly denies any of the requested access rights to one of the trustees listed in the thread's access token.</span></span>  
  
-   <span data-ttu-id="b3203-3289">线程的访问令牌中列出的受信者的一个或多个允许访问的 <xref:System.Messaging.AccessControlEntry> 项显式授予所有请求的访问权限。</span><span class="sxs-lookup"><span data-stu-id="b3203-3289">One or more access-allowed <xref:System.Messaging.AccessControlEntry> items for trustees listed in the thread's access token explicitly grant all the requested access rights.</span></span>  
  
-   <span data-ttu-id="b3203-3290">已 <xref:System.Messaging.AccessControlEntry> 检查所有项，但至少有一个请求的访问权限尚未显式允许，在这种情况下，访问将被隐式拒绝。</span><span class="sxs-lookup"><span data-stu-id="b3203-3290">All <xref:System.Messaging.AccessControlEntry> items have been checked and there is still at least one requested access right that has not been explicitly allowed, in which case, access is implicitly denied.</span></span>  
  
 <span data-ttu-id="b3203-3291">在参数中指定的对队列的权限 `rights` 可以是以下任意组合：</span><span class="sxs-lookup"><span data-stu-id="b3203-3291">The rights to a queue, specified in the `rights` parameter, can be any combination of the following:</span></span>  
  
-   <span data-ttu-id="b3203-3292">完全控制</span><span class="sxs-lookup"><span data-stu-id="b3203-3292">Full Control</span></span>  
  
-   <span data-ttu-id="b3203-3293">删除消息</span><span class="sxs-lookup"><span data-stu-id="b3203-3293">Delete Message</span></span>  
  
-   <span data-ttu-id="b3203-3294">接收消息</span><span class="sxs-lookup"><span data-stu-id="b3203-3294">Receive Message</span></span>  
  
-   <span data-ttu-id="b3203-3295">扫视消息</span><span class="sxs-lookup"><span data-stu-id="b3203-3295">Peek Message</span></span>  
  
-   <span data-ttu-id="b3203-3296">接收日志消息</span><span class="sxs-lookup"><span data-stu-id="b3203-3296">Receive Journal Message</span></span>  
  
-   <span data-ttu-id="b3203-3297">获取队列属性</span><span class="sxs-lookup"><span data-stu-id="b3203-3297">Get Queue Properties</span></span>  
  
-   <span data-ttu-id="b3203-3298">设置队列属性</span><span class="sxs-lookup"><span data-stu-id="b3203-3298">Set Queue Properties</span></span>  
  
-   <span data-ttu-id="b3203-3299">获取权限</span><span class="sxs-lookup"><span data-stu-id="b3203-3299">Get Permissions</span></span>  
  
-   <span data-ttu-id="b3203-3300">设置权限</span><span class="sxs-lookup"><span data-stu-id="b3203-3300">Set Permissions</span></span>  
  
-   <span data-ttu-id="b3203-3301">获取队列所有权</span><span class="sxs-lookup"><span data-stu-id="b3203-3301">Take Queue Ownership</span></span>  
  
-   <span data-ttu-id="b3203-3302"> 编写消息</span><span class="sxs-lookup"><span data-stu-id="b3203-3302">Write Message</span></span>  
  
 <span data-ttu-id="b3203-3303"><xref:System.Messaging.MessageQueueAccessRights>枚举表示一组可以使用按位运算符组合或用于生成参数的位标志 `rights` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-3303">The <xref:System.Messaging.MessageQueueAccessRights> enumeration represents a set of bit flags that you can combine using the bitwise operator OR to build the `rights` parameter.</span></span>  
  
 <span data-ttu-id="b3203-3304">下表显示了此方法是否在各种工作组模式下可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-3304">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-3305">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-3305">Workgroup mode</span></span>|<span data-ttu-id="b3203-3306">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-3306">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-3307">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-3307">Local computer</span></span>|<span data-ttu-id="b3203-3308">是</span><span class="sxs-lookup"><span data-stu-id="b3203-3308">Yes</span></span>|  
|<span data-ttu-id="b3203-3309">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-3309">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-3310">是</span><span class="sxs-lookup"><span data-stu-id="b3203-3310">Yes</span></span>|  
|<span data-ttu-id="b3203-3311">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-3311">Remote computer</span></span>|<span data-ttu-id="b3203-3312">否</span><span class="sxs-lookup"><span data-stu-id="b3203-3312">No</span></span>|  
|<span data-ttu-id="b3203-3313">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-3313">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-3314">否</span><span class="sxs-lookup"><span data-stu-id="b3203-3314">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-3315">以下代码示例演示了 <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29> 的用法。</span><span class="sxs-lookup"><span data-stu-id="b3203-3315">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-3316">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-3316">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.AccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(null)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(null)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_SynchronizingObject")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_SynchronizingObject")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-3317">获取或设置由 <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> 或 <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> 事件产生封送事件处理程序调用的对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-3317">Gets or sets the object that marshals the event-handler call resulting from a <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> or <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> event.</span></span></summary>
        <value><span data-ttu-id="b3203-3318"><see cref="T:System.ComponentModel.ISynchronizeInvoke" />，表示封送由 <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> 或 <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> 事件产生的事件处理程序调用的对象。</span><span class="sxs-lookup"><span data-stu-id="b3203-3318">A <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, which represents the object that marshals the event-handler call resulting from a <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> or <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> event.</span></span> <span data-ttu-id="b3203-3319">默认值为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-3319">The default is <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-3320"><xref:System.Messaging.MessageQueue.ReceiveCompleted> <xref:System.Messaging.MessageQueue.PeekCompleted> 或请求中的或事件的结果， <xref:System.Messaging.MessageQueue.BeginReceive%2A> <xref:System.Messaging.MessageQueue.BeginPeek%2A> 分别为特定线程。</span><span class="sxs-lookup"><span data-stu-id="b3203-3320">A <xref:System.Messaging.MessageQueue.ReceiveCompleted> or <xref:System.Messaging.MessageQueue.PeekCompleted> event results from a <xref:System.Messaging.MessageQueue.BeginReceive%2A> or <xref:System.Messaging.MessageQueue.BeginPeek%2A> request, respectively, to a specific thread.</span></span> <span data-ttu-id="b3203-3321">通常，在将 <xref:System.Messaging.MessageQueue.SynchronizingObject%2A> 其相关组件置于控件或窗体内时设置，因为这些组件绑定到特定线程。</span><span class="sxs-lookup"><span data-stu-id="b3203-3321">Typically, the <xref:System.Messaging.MessageQueue.SynchronizingObject%2A> is set when its related component is placed inside a control or a form, because those components are bound to a specific thread.</span></span>  
  
 <span data-ttu-id="b3203-3322">通常，同步对象将方法调用封送到单个线程。</span><span class="sxs-lookup"><span data-stu-id="b3203-3322">Typically, the synchronizing object marshals a method call into a single thread.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transactional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Transactional { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Transactional : bool" Usage="System.Messaging.MessageQueue.Transactional" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_Transactional")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_Transactional")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-3323">获取一个值，该值指示队列是否只接受事务。</span><span class="sxs-lookup"><span data-stu-id="b3203-3323">Gets a value that indicates whether the queue accepts only transactions.</span></span></summary>
        <value><span data-ttu-id="b3203-3324">如果队列只接受作为事务的一部分发送的消息，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-3324"><see langword="true" /> if the queue accepts only messages sent as part of a transaction; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-3325">事务性消息处理是指将几个相关消息耦合到一个事务中。</span><span class="sxs-lookup"><span data-stu-id="b3203-3325">Transactional messaging refers to the coupling of several related messages into a single transaction.</span></span> <span data-ttu-id="b3203-3326">作为事务的一部分发送消息可确保消息按顺序传递、只传递一次，并从其目标队列成功检索。</span><span class="sxs-lookup"><span data-stu-id="b3203-3326">Sending messages as part of a transaction ensures that the messages are delivered in order, delivered only once, and successfully retrieved from their destination queue.</span></span>  
  
 <span data-ttu-id="b3203-3327">如果队列是事务性的，则它仅接受作为事务的一部分发送的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-3327">If a queue is transactional, it accepts only messages that are sent as part of a transaction.</span></span> <span data-ttu-id="b3203-3328">但是，可以在不显式使用事务性 <xref:System.Messaging.MessageQueueTransaction.Begin%2A> 、和语法的情况下，从本地事务队列发送或接收非事务性消息 <xref:System.Messaging.MessageQueueTransaction.Commit%2A> <xref:System.Messaging.MessageQueueTransaction.Abort%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-3328">However, a non-transactional message can be sent or received from a local transaction queue without explicitly using transactional <xref:System.Messaging.MessageQueueTransaction.Begin%2A>, <xref:System.Messaging.MessageQueueTransaction.Commit%2A>, and <xref:System.Messaging.MessageQueueTransaction.Abort%2A> syntax.</span></span> <span data-ttu-id="b3203-3329">如果将非事务性消息发送到事务性队列，此组件会为其创建单个消息事务，除非使用直接格式名称引用远程计算机上的队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-3329">If a non-transactional message is sent to a transactional queue, this component creates a single-message transaction for it, except in the case of referencing a queue on a remote computer using a direct format name.</span></span> <span data-ttu-id="b3203-3330">在这种情况下，如果在发送消息时未指定事务上下文，则不会为您创建一个，并将消息发送到死信队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-3330">In this situation, if you do not specify a transaction context when sending a message, one is not created for you and the message will be sent to the dead-letter queue.</span></span>  
  
 <span data-ttu-id="b3203-3331">如果将非事务性消息发送到事务性队列，则在发生异常的情况下将无法回滚消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-3331">If you send a non-transactional message to a transactional queue, you will not be able to roll back the message in the event of an exception.</span></span>  
  
 <span data-ttu-id="b3203-3332"><xref:System.Messaging.MessageQueueTransaction> 线程单元感知，因此，如果单元状态为 `STA` ，则不能在多个线程中使用事务。</span><span class="sxs-lookup"><span data-stu-id="b3203-3332"><xref:System.Messaging.MessageQueueTransaction> is threading apartment aware, so if your apartment state is `STA`, you cannot use the transaction in multiple threads.</span></span> <span data-ttu-id="b3203-3333">Visual Basic 将主线程的状态设置为 `STA` ，因此你必须 <xref:System.MTAThreadAttribute> 在子例程中应用 `Main` 。</span><span class="sxs-lookup"><span data-stu-id="b3203-3333">Visual Basic sets the state of the main thread to `STA`, so you must apply the <xref:System.MTAThreadAttribute> in the `Main` subroutine.</span></span> <span data-ttu-id="b3203-3334">否则，利用另一个线程发送事务性消息将引发 <xref:System.Messaging.MessageQueueException> 异常。</span><span class="sxs-lookup"><span data-stu-id="b3203-3334">Otherwise, sending a transactional message using another thread throws a <xref:System.Messaging.MessageQueueException> exception.</span></span> <span data-ttu-id="b3203-3335"><xref:System.MTAThreadAttribute>使用以下片段应用。</span><span class="sxs-lookup"><span data-stu-id="b3203-3335">You apply the <xref:System.MTAThreadAttribute> by using the following fragment.</span></span>  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 <span data-ttu-id="b3203-3336">下表显示了此属性在各种工作组模式下是否可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-3336">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-3337">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-3337">Workgroup mode</span></span>|<span data-ttu-id="b3203-3338">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-3338">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-3339">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-3339">Local computer</span></span>|<span data-ttu-id="b3203-3340">是</span><span class="sxs-lookup"><span data-stu-id="b3203-3340">Yes</span></span>|  
|<span data-ttu-id="b3203-3341">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-3341">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-3342">是</span><span class="sxs-lookup"><span data-stu-id="b3203-3342">Yes</span></span>|  
|<span data-ttu-id="b3203-3343">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-3343">Remote computer</span></span>|<span data-ttu-id="b3203-3344">否</span><span class="sxs-lookup"><span data-stu-id="b3203-3344">No</span></span>|  
|<span data-ttu-id="b3203-3345">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-3345">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-3346">否</span><span class="sxs-lookup"><span data-stu-id="b3203-3346">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-3347">下面的代码示例显示消息队列属性的值 <xref:System.Messaging.MessageQueue.Transactional%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-3347">The following code example displays the value of a message queue's <xref:System.Messaging.MessageQueue.Transactional%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-3348">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-3348">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Begin" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Commit" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Abort" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_UseJournalQueue")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_UseJournalQueue")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_WriteHandle")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_WriteHandle")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-3349">获取或设置一个值，该值指示接收的消息是否复制到日记队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-3349">Gets or sets a value that indicates whether received messages are copied to the journal queue.</span></span></summary>
        <value><span data-ttu-id="b3203-3350">如果从队列接收到的消息复制到其日记队列，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b3203-3350"><see langword="true" /> if messages received from the queue are copied to its journal queue; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-3351">当消息队列应用程序创建新的应用程序队列时，它会自动在同一位置创建关联的日记队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-3351">When the Message Queuing application creates a new application queue, it automatically creates an associated journal queue in the same location.</span></span> <span data-ttu-id="b3203-3352">日志队列用于跟踪从队列中删除的消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-3352">The journal queue is used to track the messages removed from a queue.</span></span> <span data-ttu-id="b3203-3353">设置此属性将修改 "消息队列" 队列。</span><span class="sxs-lookup"><span data-stu-id="b3203-3353">Setting this property modifies the Message Queuing queue.</span></span> <span data-ttu-id="b3203-3354">因此， <xref:System.Messaging.MessageQueue> 此更改会影响任何其他实例。</span><span class="sxs-lookup"><span data-stu-id="b3203-3354">Therefore, any other <xref:System.Messaging.MessageQueue> instances are affected by the change.</span></span>  
  
 <span data-ttu-id="b3203-3355">日志队列不跟踪从队列中删除的消息，因为它们的接收时间计时器过期，也不跟踪使用消息队列目录服务从队列中清除的消息 (的信息存储或 Active Directory) 。</span><span class="sxs-lookup"><span data-stu-id="b3203-3355">The journal queue does not track messages removed from the queue because their time-to-be-received timer expired, nor does it track messages purged from the queue by using a Message Queuing directory service (Information Store or Active Directory).</span></span>  
  
 <span data-ttu-id="b3203-3356">应用程序无法将消息发送到日记队列;它们仅限于对这些队列的只读访问。</span><span class="sxs-lookup"><span data-stu-id="b3203-3356">Applications cannot send messages to journal queues; they are limited to read-only access of these queues.</span></span> <span data-ttu-id="b3203-3357">而且，消息队列从不从日志队列中删除消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-3357">Furthermore, Message Queuing never removes messages from journal queues.</span></span> <span data-ttu-id="b3203-3358">使用队列的应用程序必须通过接收或清除队列来清除这些消息。</span><span class="sxs-lookup"><span data-stu-id="b3203-3358">The application using the queue must clear these messages either by receiving them or by purging the queue.</span></span>  
  
 <span data-ttu-id="b3203-3359">下表显示了此属性在各种工作组模式下是否可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-3359">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-3360">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-3360">Workgroup mode</span></span>|<span data-ttu-id="b3203-3361">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-3361">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-3362">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-3362">Local computer</span></span>|<span data-ttu-id="b3203-3363">是</span><span class="sxs-lookup"><span data-stu-id="b3203-3363">Yes</span></span>|  
|<span data-ttu-id="b3203-3364">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-3364">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-3365">是</span><span class="sxs-lookup"><span data-stu-id="b3203-3365">Yes</span></span>|  
|<span data-ttu-id="b3203-3366">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-3366">Remote computer</span></span>|<span data-ttu-id="b3203-3367">否</span><span class="sxs-lookup"><span data-stu-id="b3203-3367">No</span></span>|  
|<span data-ttu-id="b3203-3368">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-3368">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-3369">否</span><span class="sxs-lookup"><span data-stu-id="b3203-3369">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3203-3370">下面的代码示例获取并设置消息队列属性的值 <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b3203-3370">The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-3371">访问“消息队列”方法时出错。</span><span class="sxs-lookup"><span data-stu-id="b3203-3371">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriteHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr WriteHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteHandle : nativeint" Usage="System.Messaging.MessageQueue.WriteHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_WriteHandle")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_WriteHandle")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3203-3372">获取用于将消息发送到消息队列的本机句柄。</span><span class="sxs-lookup"><span data-stu-id="b3203-3372">Gets the native handle used to send messages to the message queue.</span></span></summary>
        <value><span data-ttu-id="b3203-3373">用于将消息发送到队列的本机队列对象的句柄。</span><span class="sxs-lookup"><span data-stu-id="b3203-3373">A handle to the native queue object that you use for sending messages to the queue.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3203-3374">提供用于将 <xref:System.Messaging.MessageQueue.WriteHandle%2A> 消息发送到队列的消息队列对象的本机 Windows 句柄。</span><span class="sxs-lookup"><span data-stu-id="b3203-3374">The <xref:System.Messaging.MessageQueue.WriteHandle%2A> provides a native Windows handle to the message queue object that is used for sending messages to the queue.</span></span> <span data-ttu-id="b3203-3375">如果更改队列的路径，将关闭句柄，并使用新值重新打开。</span><span class="sxs-lookup"><span data-stu-id="b3203-3375">If you change the path of the queue, the handle is closed and reopened with a new value.</span></span>  
  
 <span data-ttu-id="b3203-3376">下表显示了此属性在各种工作组模式下是否可用。</span><span class="sxs-lookup"><span data-stu-id="b3203-3376">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="b3203-3377">工作组模式</span><span class="sxs-lookup"><span data-stu-id="b3203-3377">Workgroup mode</span></span>|<span data-ttu-id="b3203-3378">可用</span><span class="sxs-lookup"><span data-stu-id="b3203-3378">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="b3203-3379">本地计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-3379">Local computer</span></span>|<span data-ttu-id="b3203-3380">是</span><span class="sxs-lookup"><span data-stu-id="b3203-3380">Yes</span></span>|  
|<span data-ttu-id="b3203-3381">本地计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-3381">Local computer and direct format name</span></span>|<span data-ttu-id="b3203-3382">是</span><span class="sxs-lookup"><span data-stu-id="b3203-3382">Yes</span></span>|  
|<span data-ttu-id="b3203-3383">远程计算机</span><span class="sxs-lookup"><span data-stu-id="b3203-3383">Remote computer</span></span>|<span data-ttu-id="b3203-3384">否</span><span class="sxs-lookup"><span data-stu-id="b3203-3384">No</span></span>|  
|<span data-ttu-id="b3203-3385">远程计算机和直接格式名称</span><span class="sxs-lookup"><span data-stu-id="b3203-3385">Remote computer and direct format name</span></span>|<span data-ttu-id="b3203-3386">是</span><span class="sxs-lookup"><span data-stu-id="b3203-3386">Yes</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="b3203-3387">消息队列无法用于写入。</span><span class="sxs-lookup"><span data-stu-id="b3203-3387">The message queue is not available for writing.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
  </Members>
</Type>
