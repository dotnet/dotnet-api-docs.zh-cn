<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7083e7582001df42ff506251c7763e0fae3c7151" /><Meta Name="ms.sourcegitcommit" Value="c982ad9e10a242d90f1e631b5981570f9e5d9f34" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/10/2020" /><Meta Name="ms.locfileid" Value="89874636" /></Metadata><TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;xamarinmac-3.0" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageQueue&#xA;Inherits Component&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageQueue : System::ComponentModel::Component, System::Collections::IEnumerable" />
  <TypeSignature Language="F#" Value="type MessageQueue = class&#xA;    inherit Component&#xA;    interface IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" FrameworkAlternate="netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.ComponentModel.DefaultEvent("ReceiveCompleted")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultEvent("ReceiveCompleted")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName Language="C#">[System.ComponentModel.Designer("Microsoft.VisualStudio.Install.MessageQueueInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.Designer("Microsoft.VisualStudio.Install.MessageQueueInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName Language="C#">[System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName Language="C#">[System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName Language="C#">[System.Messaging.MessagingDescription("MessageQueueDesc")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MessageQueueDesc")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供对“消息队列”服务器上的队列的访问。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 消息队列技术允许在不同时间运行的应用程序在异类网络和可能暂时脱机的系统之间进行通信。 应用程序发送、接收或查看 (读取，而不从队列中移除) 消息。 消息队列是 [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] 和 WINDOWS NT 的可选组件，并且必须单独安装。  
  
 <xref:System.Messaging.MessageQueue>类是消息队列周围的包装器。 有多个版本的消息队列，使用 <xref:System.Messaging.MessageQueue> 类可能会产生略微不同的行为，具体取决于所使用的操作系统。 有关每个版本的消息队列的特定功能的信息，请参阅 MSDN 中的平台 SDK 中的 "消息队列新增功能" 主题。  
  
 <xref:System.Messaging.MessageQueue>类提供对 "消息队列" 队列的引用。 你可以在构造函数中指定一个路径 <xref:System.Messaging.MessageQueue.%23ctor%2A> 以连接到现有资源，或者可以在服务器上创建一个新队列。 <xref:System.Messaging.MessageQueue.Send%28System.Object%29> <xref:System.Messaging.MessageQueue.Peek%2A> <xref:System.Messaging.MessageQueue.Receive%2A> 必须先将类的新实例 <xref:System.Messaging.MessageQueue> 与现有队列相关联，然后才能调用、或。 此时，你可以操作队列属性，例如 <xref:System.Messaging.MessageQueue.Category%2A> 和 <xref:System.Messaging.MessageQueue.Label%2A> 。  
  
 <xref:System.Messaging.MessageQueue> 支持两种类型的消息检索：同步和异步。 同步方法和将 <xref:System.Messaging.MessageQueue.Peek%2A> <xref:System.Messaging.MessageQueue.Receive%2A> 导致进程线程等待指定的时间间隔，以使新消息到达队列。 使用异步方法 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 和 <xref:System.Messaging.MessageQueue.BeginReceive%2A> ，可以在消息到达队列之前，在单独的线程中继续执行主应用程序任务。 这些方法的工作方式是使用回调对象和状态对象在线程之间传递信息。  
  
 创建类的新实例时 <xref:System.Messaging.MessageQueue> ，不会创建新的 "消息队列" 队列。 相反，您可以使用 <xref:System.Messaging.MessageQueue.Create%28System.String%29> 、 <xref:System.Messaging.MessageQueue.Delete%28System.String%29> 和 <xref:System.Messaging.MessageQueue.Purge%2A> 方法管理服务器上的队列。  
  
 与 <xref:System.Messaging.MessageQueue.Purge%2A> 、 <xref:System.Messaging.MessageQueue.Create%28System.String%29> 和 <xref:System.Messaging.MessageQueue.Delete%28System.String%29> 是 `static` 成员不同，因此你可以在不创建类的新实例的情况下调用它们 <xref:System.Messaging.MessageQueue> 。  
  
 可以将 <xref:System.Messaging.MessageQueue> 对象的属性设置 <xref:System.Messaging.MessageQueue.Path%2A> 为以下三个名称之一：友好名称、 <xref:System.Messaging.MessageQueue.FormatName%2A> 或 <xref:System.Messaging.MessageQueue.Label%2A> 。 友好名称由队列的 <xref:System.Messaging.MessageQueue.MachineName%2A> 和 <xref:System.Messaging.MessageQueue.QueueName%2A> 属性定义，适用 <xref:System.Messaging.MessageQueue.MachineName%2A> \\ <xref:System.Messaging.MessageQueue.QueueName%2A> 于公用队列和 <xref:System.Messaging.MessageQueue.MachineName%2A> \\ `Private$` \\ <xref:System.Messaging.MessageQueue.QueueName%2A> 专用队列。 <xref:System.Messaging.MessageQueue.FormatName%2A>属性允许脱机访问消息队列。 最后，可以使用队列的 <xref:System.Messaging.MessageQueue.Label%2A> 属性设置队列的 <xref:System.Messaging.MessageQueue.Path%2A> 。  
  
 有关实例的初始属性值的列表 <xref:System.Messaging.MessageQueue> ，请参见 <xref:System.Messaging.MessageQueue.%23ctor%2A> 构造函数。
  
## Examples  
 下面的代码示例 <xref:System.Messaging.MessageQueue> 使用各种路径名称语法类型创建新的对象。 在每种情况下，它会将消息发送到其路径在构造函数中定义的队列。  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 下面的代码示例使用名为的应用程序特定的类向队列发送消息，并从队列接收消息 `Order` 。  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>只有 <see cref="M:System.Messaging.MessageQueue.GetAllMessages" /> 方法是线程安全的。</threadsafe>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="T:System.Messaging.MessageQueueException" />
    <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
    <altmember cref="P:System.Messaging.MessageQueue.Path" />
    <altmember cref="P:System.Messaging.MessageQueue.Label" />
    <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
    <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
    <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Messaging.MessageQueue" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Messaging.MessageQueue" /> 类的新实例。 无参数构造函数初始化新实例后，必须设置该实例的 <see cref="P:System.Messaging.MessageQueue.Path" /> 属性才能使用该实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载创建 <xref:System.Messaging.MessageQueue> 类的新实例，该实例不会立即绑定到消息队列服务器上的队列。 使用此实例之前，必须通过设置属性将其连接到现有的 "消息队列" 队列 <xref:System.Messaging.MessageQueue.Path%2A> 。 另外，还可以设置对 <xref:System.Messaging.MessageQueue> 该方法的 <xref:System.Messaging.MessageQueue.Create%28System.String%29> 返回值的引用，从而创建新的 "消息队列" 队列。  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A>构造函数实例化类的新实例 <xref:System.Messaging.MessageQueue> ; 它不会创建新的 "消息队列" 队列。  
  
 下表显示了实例的初始属性值 <xref:System.Messaging.MessageQueue> 。  
  
|Property|初始值|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|由类的无参数构造函数设置的值 <xref:System.Messaging.DefaultPropertiesToSend> 。|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|由类的无参数构造函数设置的值 <xref:System.Messaging.MessagePropertyFilter> 。 所有筛选器值均设置为 `true` 。|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## Examples  
 下面的代码示例创建一个新的 <xref:System.Messaging.MessageQueue> 。  
  
 [!code-csharp[MessageQueue#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">此 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列的位置。</param>
        <summary>初始化 <see cref="T:System.Messaging.MessageQueue" /> 类的新实例，该实例引用指定路径处的“消息队列”队列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要将新的 <xref:System.Messaging.MessageQueue> 实例绑定到特定的 "消息队列" 队列，请使用此重载。 如果要授予对引用队列的第一个应用程序的独占访问权限，则必须将 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> 属性设置为 `true` 或使用传递读访问限制参数的构造函数。  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A>构造函数实例化类的新实例 <xref:System.Messaging.MessageQueue> ; 它不会创建新的 "消息队列" 队列。 若要在消息队列中创建新队列，请使用 <xref:System.Messaging.MessageQueue.Create%28System.String%29> 。  
  
 参数的语法 `path` 取决于它所引用的队列的类型，如下表所示。  
  
|队列类型|语法|  
|----------------|------------|  
|公用队列|`MachineName`\\`QueueName`|  
|专用队列|`MachineName`\\`Private$`\\`QueueName`|  
|日志队列|`MachineName`\\`QueueName`\\`Journal$`|  
|计算机日志队列|`MachineName`\\`Journal$`|  
|计算机死信队列|`MachineName`\\`Deadletter$`|  
|计算机事务性死信队列|`MachineName`\\`XactDeadletter$`|  
  
 或者，可以使用 <xref:System.Messaging.MessageQueue.FormatName%2A> 或 <xref:System.Messaging.MessageQueue.Label%2A> 来描述队列路径，如下表所示。  
  
|参考|语法|示例|  
|---------------|------------|-------------|  
|格式名|`FormatName:` [ *格式名* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Label|`Label:` [ *标签* ]|`Label:` TheLabel|  
  
 若要脱机工作，必须使用格式名语法，而不是构造函数的路径名称语法。 否则，会引发异常，因为主域控制器不可用于解析格式名称的路径。  
  
 下表显示了实例的初始属性值 <xref:System.Messaging.MessageQueue> 。 这些值基于具有参数指定的路径的 "消息队列" 队列的属性 `path` 。  
  
|Property|初始值|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|由类的无参数构造函数设置的值 <xref:System.Messaging.DefaultPropertiesToSend> 。|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`如果 "消息队列" 队列的隐私级别设置为 "正文"，则为否则为 `false` 。|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|"消息队列" 队列的 "计算机名" 属性的值。|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|由类的无参数构造函数设置的值 <xref:System.Messaging.MessagePropertyFilter> 。|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>如果构造函数未设置，则为。|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>如果构造函数未设置，则为。|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`如果启用了消息队列对象的日志设置，则为;否则为 `false` 。|  
  
   
  
## Examples  
 下面的代码示例 <xref:System.Messaging.MessageQueue> 使用各种路径名称语法类型创建新的对象。 在每种情况下，它会将消息发送到其路径在构造函数中定义的队列。  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.MessageQueue.Path" /> 属性无效，很可能因为尚未设置该属性。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">此 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列的位置，它对于本地计算机可以是“.”。</param>
        <param name="sharedModeDenyReceive"><see langword="true" />，授予访问该队列的第一个应用程序独占读访问权；否则为 <see langword="false" />。</param>
        <summary>初始化 <see cref="T:System.Messaging.MessageQueue" /> 类的新实例，该实例引用位于指定路径处而且具有指定读访问限制的“消息队列”队列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要将新的绑定 <xref:System.Messaging.MessageQueue> 到特定的 "消息队列" 队列，请使用此重载。 如果要授予对引用队列的第一个应用程序的独占访问权限，请将 `sharedModeDenyReceive` 参数设置为 `true` 。 否则，将设置 `sharedModeDenyReceive` 为 `false` 或使用只有一个参数的构造函数 `path` 。  
  
 设置 `sharedModeDenyReceive` 为 `true` 会影响访问 "消息队列" 队列的所有对象，包括其他应用程序。 此参数的效果并不限于此应用程序。  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A>构造函数创建类的新实例 <xref:System.Messaging.MessageQueue> ; 它不会创建新的 "消息队列" 队列。 若要在消息队列中创建新队列，请使用 <xref:System.Messaging.MessageQueue.Create%28System.String%29> 。  
  
 参数的语法 `path` 取决于队列的类型。  
  
|队列类型|语法|  
|----------------|------------|  
|公用队列|`MachineName`\\`QueueName`|  
|专用队列|`MachineName`\\`Private$`\\`QueueName`|  
|日志队列|`MachineName`\\`QueueName`\\`Journal$`|  
|计算机日志队列|`MachineName`\\`Journal$`|  
|计算机死信队列|`MachineName`\\`Deadletter$`|  
|计算机事务性死信队列|`MachineName`\\`XactDeadletter$`|  
  
 或者，您可以使用 "消息队列" 队列的格式名称或标签来描述队列路径。  
  
|参考|语法|示例|  
|---------------|------------|-------------|  
|格式名|`FormatName:` [ *格式名* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Label|`Label:` [ *标签* ]|`Label:` TheLabel|  
  
 若要脱机工作，必须使用格式名语法，而不是友好名称语法。 否则，会引发异常，因为 Active Directory 所在的主域控制器 () 不可用于解析格式名称的路径。  
  
 如果 <xref:System.Messaging.MessageQueue> 打开的队列的 `sharedModeDenyReceive` 参数设置为，则 `true` <xref:System.Messaging.MessageQueue> 随后尝试从队列中读取的任何都将生成， <xref:System.Messaging.MessageQueueException> 因为存在共享冲突。 <xref:System.Messaging.MessageQueueException>如果 <xref:System.Messaging.MessageQueue> 尝试以独占模式访问队列，而另一个 <xref:System.Messaging.MessageQueue> 已具有对队列的非独占访问权限，则也会引发。  
  
 下表显示了实例的初始属性值 <xref:System.Messaging.MessageQueue> 。 这些值基于 "消息队列" 队列的属性，具有参数指定的路径 `path` 。  
  
|Property|初始值|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`。|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0。|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>。|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|由类的无参数构造函数设置的值 <xref:System.Messaging.DefaultPropertiesToSend> 。|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`如果 "消息队列" 队列的隐私级别设置为 "正文"，则为否则为 `false` 。|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>。|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>。|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|"消息队列" 队列的 "计算机名" 属性的值。|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>。|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>。|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|由类的无参数构造函数设置的值 <xref:System.Messaging.MessagePropertyFilter> 。|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>如果构造函数未设置，则为。|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>如果构造函数未设置，则为。|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`sharedModeDenyReceive` 参数的值。|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`如果启用了消息队列对象的日志设置，则为;否则为 `false` 。|  
  
   
  
## Examples  
 下面的代码示例创建一个 <xref:System.Messaging.MessageQueue> 具有独占访问权限的新，设置其路径，并将消息发送到队列。  
  
 [!code-cpp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.MessageQueue.Path" /> 属性无效，很可能因为尚未设置该属性。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">此 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列的位置，它对于本地计算机可以是“.”。</param>
        <param name="accessMode"><see cref="T:System.Messaging.QueueAccessMode" /> 值之一。</param>
        <summary>初始化 <see cref="T:System.Messaging.MessageQueue" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="enableCache" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">此 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列的位置，它对于本地计算机可以是“.”。</param>
        <param name="sharedModeDenyReceive"><see langword="true" />，授予访问该队列的第一个应用程序独占读访问权；否则为 <see langword="false" />。</param>
        <param name="enableCache">如果创建和使用连接缓存，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>初始化 <see cref="T:System.Messaging.MessageQueue" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例创建一个 <xref:System.Messaging.MessageQueue> 具有独占读取访问权限且已启用连接缓存的新。  
  
 [!code-cpp[MessageQueue4#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="enableCache" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">此 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列的位置，它对于本地计算机可以是“.”。</param>
        <param name="sharedModeDenyReceive"><see langword="true" />，授予访问该队列的第一个应用程序独占读访问权；否则为 <see langword="false" />。</param>
        <param name="enableCache">如果创建和使用连接缓存，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <param name="accessMode"><see cref="T:System.Messaging.QueueAccessMode" /> 值之一。</param>
        <summary>初始化 <see cref="T:System.Messaging.MessageQueue" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessMode As QueueAccessMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::QueueAccessMode AccessMode { System::Messaging::QueueAccessMode get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessMode : System.Messaging.QueueAccessMode" Usage="System.Messaging.MessageQueue.AccessMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示队列的访问模式。</summary>
        <value><see cref="T:System.Messaging.QueueAccessMode" /> 值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 队列的默认访问模式为 `QueueAccessMode.SendAndReceive` ，除非在调用构造函数时另行指定。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberSignature Language="VB.NET" Value="Public Property Authenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Authenticate : bool with get, set" Usage="System.Messaging.MessageQueue.Authenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_Authenticate")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_Authenticate")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示队列是否仅接受经过身份验证的消息。</summary>
        <value>如果队列仅接受已经过身份验证的消息，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 消息身份验证提供了一种方法，可确保消息的完整性并验证发送消息的用户。 为了请求身份验证，发送应用程序会设置消息的身份验证级别。  
  
 当你将设置为时， <xref:System.Messaging.MessageQueue.Authenticate%2A> `true` 将限制对服务器上的队列的访问，而不仅限于此 <xref:System.Messaging.MessageQueue> 实例。 针对同一个 "消息队列" 队列的所有客户端都将受到影响。  
  
 仅接受经过身份验证的消息的队列将拒绝未经过身份验证的消息。 若要请求拒绝消息，发送应用程序可以设置消息的 <xref:System.Messaging.Message.AcknowledgeType%2A> 属性。 由于不存在消息拒绝的其他指示，因此发送应用程序可能会丢失消息，除非你请求将该消息发送到死信队列。  
  
 下表显示了此属性在各种工作组模式下是否可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 下面的代码示例获取并设置消息队列属性的值 <xref:System.Messaging.MessageQueue.Authenticate%2A> 。  
  
 [!code-csharp[MessageQueue#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public Property BasePriority As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short BasePriority { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int16 with get, set" Usage="System.Messaging.MessageQueue.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_BasePriority")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_BasePriority")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置基优先级，“消息队列”使用该基优先级在网络上传送公共队列的消息。</summary>
        <value>发送到（公共）队列的所有消息的单个基本优先级。 默认值为零 (0)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 消息队列的基本优先级指定消息发送到该队列的消息在通过网络传输时的处理方式。 您可以设置 <xref:System.Messaging.MessageQueue.BasePriority%2A> 属性，以对发送到指定队列的所有消息授予更高或较低的优先级。 设置此属性将修改 "消息队列" 队列。 因此， <xref:System.Messaging.MessageQueue> 此更改会影响任何其他实例。  
  
 消息队列 <xref:System.Messaging.MessageQueue.BasePriority%2A> 与 <xref:System.Messaging.Message.Priority%2A> 消息的属性无关，后者指定传入消息在队列中的排列顺序。  
  
 <xref:System.Messaging.MessageQueue.BasePriority%2A> 仅适用于其路径是使用格式名称指定的公用队列。 专用队列的基本优先级始终为零 (0) 。  
  
 下表显示了此属性在各种工作组模式下是否可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 下面的代码示例获取并设置消息队列属性的值 <xref:System.Messaging.MessageQueue.BasePriority%2A> 。  
  
 [!code-csharp[MessageQueue#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">基优先级被设置为无效值。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPeek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>方法不是线程安全的。</threadsafe>
        <summary>通过通知“消息队列”开始查看消息并在完成后通知事件处理程序，启动一个异步查看操作。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek();" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : unit -&gt; IAsyncResult" Usage="messageQueue.BeginPeek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>启动一个未设置超时的异步查看操作。直到队列中有可用消息时，操作才会完成。</summary>
        <returns>该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在异步处理过程中， <xref:System.Messaging.MessageQueue.BeginPeek%2A> <xref:System.Messaging.MessageQueue.PeekCompleted> 当消息在队列中可用时，使用来引发事件。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 如果队列中已经存在消息，也会引发。  
  
 若要使用 <xref:System.Messaging.MessageQueue.BeginPeek%2A> ，请创建一个事件处理程序，用于处理异步操作的结果，并将其与事件委托相关联。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 启动异步查看操作; <xref:System.Messaging.MessageQueue> <xref:System.Messaging.MessageQueue.PeekCompleted> 当消息到达队列时，会通过引发事件通知。 <xref:System.Messaging.MessageQueue>然后，可以通过调用 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 或通过使用检索结果来访问消息 <xref:System.Messaging.PeekCompletedEventArgs> 。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>方法会立即返回，但在调用事件处理程序之前，不会完成异步操作。  
  
 由于 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 是异步的，因此你可以调用它来查看队列，而不会阻止当前的执行线程。 若要同步查看队列，请使用 <xref:System.Messaging.MessageQueue.Peek%2A> 方法。  
  
 异步操作完成后，可以 <xref:System.Messaging.MessageQueue.BeginPeek%2A> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 在事件处理程序中调用或再次运行以继续接收通知。  
  
 返回的将 <xref:System.IAsyncResult> <xref:System.Messaging.MessageQueue.BeginPeek%2A> 标识该方法启动的异步操作。 可以在 <xref:System.IAsyncResult> 操作的整个生存期内使用此方法，不过，在调用之前，通常不使用此方法 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 。 但是，如果您启动多个异步操作，则可以将它们的 <xref:System.IAsyncResult> 值放在数组中，并指定是否等待所有操作或任何操作完成。 在这种情况下，可以使用 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 的属性 <xref:System.IAsyncResult> 来标识已完成的操作。  
  
 如果 <xref:System.Messaging.MessageQueue.CanRead%2A> 为 `false` ，则引发完成事件，但在调用时将引发异常 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例创建一个名为的事件处理程序 `MyPeekCompleted` ，将其附加到 <xref:System.Messaging.MessageQueue.PeekCompleted> 事件处理程序委托，并调用 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 以对位于路径 ".\myQueue" 的队列启动异步查看操作。 <xref:System.Messaging.MessageQueue.PeekCompleted>引发事件时，该示例将扫视消息，并将其正文写入屏幕。 然后，该示例 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 再次调用以启动新的异步查看操作。  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <threadsafe>方法不是线程安全的。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginPeek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示等待消息变为可用所用的时间间隔。</param>
        <summary>启动具有指定超时的异步查看操作。直到队列中有可用消息或发生超时，操作才会完成。</summary>
        <returns>该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在异步处理过程中， <xref:System.Messaging.MessageQueue.BeginPeek%2A> <xref:System.Messaging.MessageQueue.PeekCompleted> 当消息在队列中可用或指定的时间间隔到期时，使用来引发事件。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 如果队列中已经存在消息，也会引发。  
  
 若要使用 <xref:System.Messaging.MessageQueue.BeginPeek%2A> ，请创建一个事件处理程序，用于处理异步操作的结果，并将其与事件委托相关联。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 启动异步查看操作; <xref:System.Messaging.MessageQueue> <xref:System.Messaging.MessageQueue.PeekCompleted> 当消息到达队列时，会通过引发事件通知。 <xref:System.Messaging.MessageQueue>然后，可以通过调用 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 或通过使用检索结果来访问消息 <xref:System.Messaging.PeekCompletedEventArgs> 。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>方法会立即返回，但在调用事件处理程序之前，不会完成异步操作。  
  
 由于 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 是异步的，因此你可以调用它来查看队列，而不会阻止当前的执行线程。 若要同步查看队列，请使用 <xref:System.Messaging.MessageQueue.Peek%2A> 方法。  
  
 异步操作完成后，可以 <xref:System.Messaging.MessageQueue.BeginPeek%2A> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 在事件处理程序中调用或再次运行以继续接收通知。  
  
 返回的将 <xref:System.IAsyncResult> <xref:System.Messaging.MessageQueue.BeginPeek%2A> 标识该方法启动的异步操作。 可以在 <xref:System.IAsyncResult> 操作的整个生存期内使用此方法，不过，在调用之前，通常不使用此方法 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 。 但是，如果您启动多个异步操作，则可以将它们的 <xref:System.IAsyncResult> 值放在数组中，并指定是否等待所有操作或任何操作完成。 在这种情况下，可以使用 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 的属性 <xref:System.IAsyncResult> 来标识已完成的操作。  
  
 此重载指定超时。如果参数指定的间隔 `timeout` 过期，此组件将引发 <xref:System.Messaging.MessageQueue.PeekCompleted> 事件。 由于不存在任何消息，对的后续调用 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 将引发异常。  
  
 如果 <xref:System.Messaging.MessageQueue.CanRead%2A> 为 `false` ，则引发完成事件，但在调用时将引发异常 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例使用队列路径 ".\myQueue" 创建异步查看操作。 它创建事件处理程序， `MyPeekCompleted` 并将其附加到 <xref:System.Messaging.MessageQueue.PeekCompleted> 事件处理程序委托。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 在一分钟的超时时间内调用以启动异步查看操作。 当 <xref:System.Messaging.MessageQueue.PeekCompleted> 引发事件或超时过期时，将检索消息（如果存在），并将其正文写入屏幕。 然后 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 再次调用，以使用相同的超时启动新的异步查看操作。  
  
 [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <threadsafe>方法不是线程安全的。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示等待消息变为可用所用的时间间隔。</param>
        <param name="stateObject">应用程序指定的状态对象，包含与异步操作关联的信息。</param>
        <summary>启动具有指定超时设定和指定状态对象的异步查看操作，此状态对象在操作的整个生存期内提供相关信息。 直到队列中出现消息时或发生超时时才完成操作。</summary>
        <returns>该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在异步处理过程中， <xref:System.Messaging.MessageQueue.BeginPeek%2A> <xref:System.Messaging.MessageQueue.PeekCompleted> 当消息在队列中可用或指定的时间间隔到期时，使用来引发事件。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 如果队列中已经存在消息，也会引发。  
  
 使用此重载将信息与将在操作的整个生存期内保留的操作相关联。 事件处理程序可以通过查看 <xref:System.IAsyncResult.AsyncState%2A> 与操作关联的的属性来访问此信息 <xref:System.IAsyncResult> 。  
  
 若要使用 <xref:System.Messaging.MessageQueue.BeginPeek%2A> ，请创建一个事件处理程序，用于处理异步操作的结果，并将其与事件委托相关联。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 启动异步查看操作; <xref:System.Messaging.MessageQueue> <xref:System.Messaging.MessageQueue.PeekCompleted> 当消息到达队列时，会通过引发事件通知。 <xref:System.Messaging.MessageQueue>然后，可以通过调用 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 或通过使用检索结果来访问消息 <xref:System.Messaging.PeekCompletedEventArgs> 。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>方法会立即返回，但在调用事件处理程序之前，不会完成异步操作。  
  
 由于 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 是异步的，因此你可以调用它来查看队列，而不会阻止当前的执行线程。 若要同步查看队列，请使用 <xref:System.Messaging.MessageQueue.Peek%2A> 方法。  
  
 异步操作完成后，可以 <xref:System.Messaging.MessageQueue.BeginPeek%2A> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 在事件处理程序中调用或再次运行以继续接收通知。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 返回一个 <xref:System.IAsyncResult> ，它标识该方法启动的异步操作。 可以在 <xref:System.IAsyncResult> 操作的整个生存期内使用此方法，不过，在调用之前，通常不使用此方法 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 。 但是，如果您启动多个异步操作，则可以将它们的 <xref:System.IAsyncResult> 值放在数组中，并指定是否等待所有操作或任何操作完成。 在这种情况下，可以使用 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 的属性 <xref:System.IAsyncResult> 来标识已完成的操作。  
  
 此重载指定超时和状态对象。 如果参数指定的间隔 `timeout` 过期，此组件将引发 <xref:System.Messaging.MessageQueue.PeekCompleted> 事件。 由于不存在任何消息，对的后续调用 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 将引发异常。  
  
 状态对象将状态信息与操作相关联。 例如，如果 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 多次调用来启动多个操作，则可以通过定义的单独状态对象标识每个操作。 有关此方案的说明，请参阅 "示例" 部分。  
  
 你还可以使用状态对象跨进程线程传递信息。 如果线程已启动，但回调在异步方案中的其他线程上，则将对状态对象进行封送处理，并将其与事件中的信息一起传递回来。  
  
 如果 <xref:System.Messaging.MessageQueue.CanRead%2A> 为 `false` ，则引发完成事件，但在调用时将引发异常 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例使用队列路径 ".\myQueue" 创建异步查看操作。 它创建事件处理程序， `MyPeekCompleted` 并将其附加到 <xref:System.Messaging.MessageQueue.PeekCompleted> 事件处理程序委托。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 调用时，超时为一分钟。 对的每个调用 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 都具有唯一的关联整数，该整数标识特定操作。 当 <xref:System.Messaging.MessageQueue.PeekCompleted> 引发事件或超时过期时，将检索消息（如果存在），并在屏幕上写入消息体和特定于操作的整数标识符。 然后 <xref:System.Messaging.MessageQueue.BeginPeek%2A> ，再次调用来启动一个新的异步查看操作，该操作具有相同的超时和刚完成的操作的关联整数。  
  
 [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <threadsafe>方法不是线程安全的。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示等待消息变为可用所用的时间间隔。</param>
        <param name="stateObject">应用程序指定的状态对象，包含与异步操作关联的信息。</param>
        <param name="callback">该 <see cref="T:System.AsyncCallback" /> 将接收异步操作完成通知。</param>
        <summary>启动具有指定超时设定和指定状态对象的异步查看操作，此状态对象在操作的整个生存期内提供相关信息。 此重载通过回调接收操作的事件处理程序标识的通知。 直到队列中出现消息时或发生超时时才完成操作。</summary>
        <returns>该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载时，当消息在队列中可用或指定的时间间隔到期时，将直接调用在回调参数中指定的回调; <xref:System.Messaging.MessageQueue.PeekCompleted> 不引发该事件。 的其他重载 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 依赖于此组件来引发 <xref:System.Messaging.MessageQueue.PeekCompleted> 事件。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 如果队列中已经存在消息，也会引发。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>方法会立即返回，但在调用事件处理程序之前，不会完成异步操作。  
  
 由于 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 是异步的，因此你可以调用它来查看队列，而不会阻止当前的执行线程。 若要同步查看队列，请使用 <xref:System.Messaging.MessageQueue.Peek%2A> 方法。  
  
 异步操作完成后，可以 <xref:System.Messaging.MessageQueue.BeginPeek%2A> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 在事件处理程序中调用或再次运行以继续接收通知。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 返回一个 <xref:System.IAsyncResult> ，它标识该方法启动的异步操作。 可以在 <xref:System.IAsyncResult> 操作的整个生存期内使用此方法，不过，在调用之前，通常不使用此方法 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 。 但是，如果您启动多个异步操作，则可以将它们的 <xref:System.IAsyncResult> 值放在数组中，并指定是否等待所有操作或任何操作完成。 在这种情况下，可以使用 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 的属性 <xref:System.IAsyncResult> 来标识已完成的操作。  
  
 状态对象将状态信息与操作相关联。 例如，如果 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 多次调用来启动多个操作，则可以通过定义的单独状态对象标识每个操作。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例创建一个异步查看操作。 此代码示例将一条消息发送到本地消息队列，然后调用 <xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29> 并传入：超时值为10秒; 唯一的整数，用于标识该特定消息; 以及 <xref:System.AsyncCallback> 标识事件处理程序的的新实例 `MyPeekCompleted` 。 <xref:System.Messaging.MessageQueue.PeekCompleted>引发事件时，事件处理程序将查看该消息，并将消息正文和整数消息标识符写入屏幕。  
  
 [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <threadsafe>方法不是线程安全的。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, cursor As Cursor, action As PeekAction, state As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, cursor, action, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示等待消息变为可用所用的时间间隔。</param>
        <param name="cursor">维持消息队列中特定位置的 <see cref="T:System.Messaging.Cursor" />。</param>
        <param name="action"><see cref="T:System.Messaging.PeekAction" /> 值之一。 指示是查看队列中的当前消息还是下一条消息。</param>
        <param name="state">应用程序指定的状态对象，包含与异步操作关联的信息。</param>
        <param name="callback">该 <see cref="T:System.AsyncCallback" /> 将接收异步操作完成通知。</param>
        <summary>启动异步查看操作，此操作具有指定的超时并使用指定的游标、指定的查看操作和指定的状态对象。 状态对象在操作的整个生存期内提供相关的信息。 此重载通过回调接收操作的事件处理程序标识的通知。 直到队列中出现消息时或发生超时时才完成操作。</summary>
        <returns>该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载时，当消息在队列中可用或指定的时间间隔过期时，将直接调用在回调参数中指定的回调。 <xref:System.Messaging.MessageQueue.PeekCompleted>不引发该事件。 的其他重载 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 依赖于此组件来引发 <xref:System.Messaging.MessageQueue.PeekCompleted> 事件。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 如果队列中已经存在消息，也会引发。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>方法会立即返回，但在调用事件处理程序之前，不会完成异步操作。  
  
 由于 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 是异步的，因此你可以调用它来查看队列，而不会阻止当前的执行线程。 若要同步查看队列，请使用 <xref:System.Messaging.MessageQueue.Peek%2A> 方法。  
  
 异步操作完成后，可以 <xref:System.Messaging.MessageQueue.BeginPeek%2A> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 在事件处理程序中调用或再次运行以继续接收通知。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 返回一个 <xref:System.IAsyncResult> ，它标识由方法启动的异步操作。 可以在 <xref:System.IAsyncResult> 操作的整个生存期内使用此方法，不过，在调用之前，通常不使用此方法 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 。 但是，如果您启动多个异步操作，则可以将它们的 <xref:System.IAsyncResult> 值放在数组中，并指定是否等待所有操作或任何操作完成。 在这种情况下，请使用 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 的属性 <xref:System.IAsyncResult> 来标识已完成的操作。  
  
 状态对象将状态信息与操作相关联。 例如，如果 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 多次调用来启动多个操作，则可以通过定义的单独状态对象标识每个操作。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">为 <paramref name="action" /> 参数指定的值不是 <see langword="PeekAction.Current" /> 和 <see langword="PeekAction.Next" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="cursor" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <threadsafe>方法不是线程安全的。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>方法不是线程安全的。</threadsafe>
        <summary>通过通知“消息队列”开始接收消息并在完成后通知事件处理程序，启动一个异步接收操作。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive();" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : unit -&gt; IAsyncResult" Usage="messageQueue.BeginReceive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>启动一个未设置超时的异步接收操作。直到队列中有可用消息时，操作才会完成。</summary>
        <returns>该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在异步处理过程中， <xref:System.Messaging.MessageQueue.BeginReceive%2A> <xref:System.Messaging.MessageQueue.ReceiveCompleted> 当消息已从队列中移除时，使用引发事件。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 如果队列中已经存在消息，也会引发。  
  
 若要使用 <xref:System.Messaging.MessageQueue.BeginReceive%2A> ，请创建一个事件处理程序，用于处理异步操作的结果并将其与事件委托相关联。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 启动异步接收操作; <xref:System.Messaging.MessageQueue> <xref:System.Messaging.MessageQueue.ReceiveCompleted> 当消息到达队列时，会通过引发事件通知。 <xref:System.Messaging.MessageQueue>然后，可以通过调用来访问消息 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>方法会立即返回，但在调用事件处理程序之前，不会完成异步操作。  
  
 由于 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 是异步的，因此你可以调用它来接收队列中的消息，而不会阻止当前的执行线程。 若要以同步方式接收消息，请使用 <xref:System.Messaging.MessageQueue.Receive%2A> 方法。  
  
 异步操作完成后，可以 <xref:System.Messaging.MessageQueue.BeginPeek%2A> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 在事件处理程序中调用或再次运行以继续接收通知。  
  
 返回的将 <xref:System.IAsyncResult> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 标识该方法启动的异步操作。 可以在 <xref:System.IAsyncResult> 操作的整个生存期内使用此方法，不过，在调用之前，通常不使用此方法 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 。 但是，如果您启动多个异步操作，则可以将它们的 <xref:System.IAsyncResult> 值放在数组中，并指定是否等待所有操作或任何操作完成。 在这种情况下，可以使用 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 的属性 <xref:System.IAsyncResult> 来标识已完成的操作。  
  
 如果 <xref:System.Messaging.MessageQueue.CanRead%2A> 为 `false` ，则引发完成事件，但在调用时将引发异常 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 。  
  
 不要对事务使用异步调用 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 。 如果要执行事务异步操作，请调用 <xref:System.Messaging.MessageQueue.BeginPeek%2A> ，并在 <xref:System.Messaging.MessageQueue.Receive%2A> 为查看操作创建的事件处理程序中放置事务和 (同步) 方法。 你的事件处理程序可能包含以下 c # 代码中所示的功能。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例将异步请求链接在一起。 它假设本地计算机上有一个名为 "myQueue" 的队列。 `Main`函数开始由例程处理的异步操作 `MyReceiveCompleted` 。 `MyReceiveCompleted` 处理当前消息并开始新的异步接收操作。  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 下面的代码示例将异步请求排队。 对的调用将 <xref:System.Messaging.MessageQueue.BeginReceive%2A> <xref:System.IAsyncResult.AsyncWaitHandle%2A> 在其返回值中使用。 `Main`例程等待所有异步操作在退出前完成。  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <threadsafe>方法不是线程安全的。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginReceive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示等待消息变为可用所用的时间间隔。</param>
        <summary>启动具有指定超时的异步接收操作。直到队列中有可用消息时或发生超时，操作才会完成。</summary>
        <returns>该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在异步处理过程中， <xref:System.Messaging.MessageQueue.BeginReceive%2A> <xref:System.Messaging.MessageQueue.ReceiveCompleted> 当消息在队列中可用或指定的时间间隔到期时，使用来引发事件。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 如果队列中已经存在消息，也会引发。  
  
 若要使用 <xref:System.Messaging.MessageQueue.BeginReceive%2A> ，请创建一个事件处理程序，用于处理异步操作的结果并将其与事件委托相关联。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 启动异步接收操作; <xref:System.Messaging.MessageQueue> <xref:System.Messaging.MessageQueue.ReceiveCompleted> 当消息到达队列时，会通过引发事件通知。 <xref:System.Messaging.MessageQueue>然后，可以通过调用 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 或使用检索结果来访问消息 <xref:System.Messaging.ReceiveCompletedEventArgs> 。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>方法会立即返回，但在调用事件处理程序之前，不会完成异步操作。  
  
 由于 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 是异步的，因此你可以调用它来接收队列中的消息，而不会阻止当前的执行线程。 若要以同步方式接收消息，请使用 <xref:System.Messaging.MessageQueue.Receive%2A> 方法。  
  
 异步操作完成后，可以 <xref:System.Messaging.MessageQueue.BeginPeek%2A> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 在事件处理程序中调用或再次运行以继续接收通知。  
  
 如果 <xref:System.Messaging.MessageQueue.CanRead%2A> 为 `false` ，则引发完成事件，但在调用时将引发异常 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 。  
  
 返回的将 <xref:System.IAsyncResult> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 标识该方法启动的异步操作。 可以在 <xref:System.IAsyncResult> 操作的整个生存期内使用此方法，不过，在调用之前，通常不使用此方法 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 。 但是，如果您启动多个异步操作，则可以将它们的 <xref:System.IAsyncResult> 值放在数组中，并指定是否等待所有操作或任何操作完成。 在这种情况下，可以使用 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 的属性 <xref:System.IAsyncResult> 来标识已完成的操作。  
  
 此重载指定超时。如果参数指定的间隔 `timeout` 过期，此组件将引发 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 事件。 由于不存在任何消息，对的后续调用 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 将引发异常。  
  
 不要对事务使用异步调用 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 。 如果要执行事务异步操作，请调用 <xref:System.Messaging.MessageQueue.BeginPeek%2A> ，并在 <xref:System.Messaging.MessageQueue.Receive%2A> 为查看操作创建的事件处理程序中放置事务和 (同步) 方法。 你的事件处理程序可能包含以下 c # 代码中所示的功能。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例创建一个异步接收操作。 此代码示例创建一个事件处理程序， `MyReceiveCompleted` 并将其附加到 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 事件处理程序委托。 此代码示例将消息发送到本地消息队列，然后调用 <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29> ，并传入10秒的超时值。 <xref:System.Messaging.MessageQueue.ReceiveCompleted>引发事件时，事件处理程序会接收消息，并将消息正文写入屏幕。  
  
 [!code-cpp[MessageQueueBeginReceive1#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效，可能是因为它表示负数。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <threadsafe>方法不是线程安全的。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示等待消息变为可用所用的时间间隔。</param>
        <param name="stateObject">应用程序指定的状态对象，包含与异步操作关联的信息。</param>
        <summary>启动具有指定超时设定和指定状态对象的异步接收操作，此状态对象在操作的整个生存期内提供相关信息。 直到队列中出现消息时或发生超时时才完成操作。</summary>
        <returns>该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在异步处理过程中， <xref:System.Messaging.MessageQueue.BeginReceive%2A> <xref:System.Messaging.MessageQueue.ReceiveCompleted> 当消息在队列中可用或指定的时间间隔到期时，使用来引发事件。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 如果队列中已经存在消息，也会引发。  
  
 使用此重载将信息与将在操作的整个生存期内保留的操作相关联。 事件处理程序可以通过查看 <xref:System.IAsyncResult.AsyncState%2A> 与操作关联的的属性来检测此信息 <xref:System.IAsyncResult> 。  
  
 若要使用 <xref:System.Messaging.MessageQueue.BeginReceive%2A> ，请创建一个事件处理程序，用于处理异步操作的结果并将其与事件委托相关联。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 启动异步接收操作; <xref:System.Messaging.MessageQueue> <xref:System.Messaging.MessageQueue.ReceiveCompleted> 当消息到达队列时，会通过引发事件通知。 <xref:System.Messaging.MessageQueue>然后，可以通过调用 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 或使用检索结果来访问消息 <xref:System.Messaging.ReceiveCompletedEventArgs> 。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>方法会立即返回，但在调用事件处理程序之前，不会完成异步操作。  
  
 由于 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 是异步的，因此你可以调用它来接收队列中的消息，而不会阻止当前的执行线程。 若要以同步方式接收消息，请使用 <xref:System.Messaging.MessageQueue.Receive%2A> 方法。  
  
 异步操作完成后，可以 <xref:System.Messaging.MessageQueue.BeginPeek%2A> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 在事件处理程序中调用或再次运行以继续接收通知。  
  
 返回的将 <xref:System.IAsyncResult> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 标识该方法启动的异步操作。 可以在 <xref:System.IAsyncResult> 操作的整个生存期内使用此方法，不过，在调用之前，通常不使用此方法 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 。 但是，如果您启动多个异步操作，则可以将它们的 <xref:System.IAsyncResult> 值放在数组中，并指定是否等待所有操作或任何操作完成。 在这种情况下，可以使用 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 的属性 <xref:System.IAsyncResult> 来标识已完成的操作。  
  
 此重载指定超时和状态对象。 如果参数指定的间隔 `timeout` 过期，此组件将引发 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 事件。 由于不存在任何消息，对的后续调用 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 将引发异常。  
  
 状态对象将状态信息与操作相关联。 例如，如果 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 多次调用来启动多个操作，则可以通过定义的单独状态对象标识每个操作。  
  
 你还可以使用状态对象跨进程线程传递信息。 如果线程已启动，但回调在异步方案中的其他线程上，则将对状态对象进行封送处理，并将其与事件中的信息一起传递回来。  
  
 不要对事务使用异步调用 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 。 如果要执行事务异步操作，请调用 <xref:System.Messaging.MessageQueue.BeginPeek%2A> ，并在 <xref:System.Messaging.MessageQueue.Receive%2A> 为查看操作创建的事件处理程序中放置事务和 (同步) 方法。 你的事件处理程序可能包含以下 c # 代码中所示的功能。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例创建一个异步接收操作。 此代码示例创建一个事件处理程序， `MyReceiveCompleted` 并将其附加到 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 事件处理程序委托。 此代码示例将一条消息发送到本地消息队列，然后调用 <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29> ，传入10秒的超时值和一个标识该特定消息的唯一整数。 <xref:System.Messaging.MessageQueue.ReceiveCompleted>引发事件时，事件处理程序会接收消息，并将消息正文和整数消息标识符写入屏幕。  
  
 [!code-cpp[MessageQueueBeginReceive2#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <threadsafe>方法不是线程安全的。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示等待消息变为可用所用的时间间隔。</param>
        <param name="stateObject">应用程序指定的状态对象，包含与异步操作关联的信息。</param>
        <param name="callback">该 <see cref="T:System.AsyncCallback" /> 将接收异步操作完成通知。</param>
        <summary>启动具有指定超时设定和指定状态对象的异步接收操作，此状态对象在操作的整个生存期内提供相关信息。 此重载通过回调接收操作的事件处理程序标识的通知。 直到队列中出现消息时或发生超时时才完成操作。</summary>
        <returns>该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载时，当消息在队列中可用或指定的时间间隔到期时，将直接调用在回调参数中指定的回调; <xref:System.Messaging.MessageQueue.ReceiveCompleted> 不引发该事件。 的其他重载 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 依赖于此组件来引发 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 事件。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 如果队列中已经存在消息，也会引发。  
  
 若要使用 <xref:System.Messaging.MessageQueue.BeginReceive%2A> ，请创建一个事件处理程序，用于处理异步操作的结果并将其与事件委托相关联。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 启动异步接收操作; <xref:System.Messaging.MessageQueue> <xref:System.Messaging.MessageQueue.ReceiveCompleted> 当消息到达队列时，会通过引发事件通知。 <xref:System.Messaging.MessageQueue>然后，可以通过调用 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 或使用检索结果来访问消息 <xref:System.Messaging.ReceiveCompletedEventArgs> 。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>方法会立即返回，但在调用事件处理程序之前，不会完成异步操作。  
  
 由于 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 是异步的，因此你可以调用它来接收队列中的消息，而不会阻止当前的执行线程。 若要以同步方式接收消息，请使用 <xref:System.Messaging.MessageQueue.Receive%2A> 方法。  
  
 异步操作完成后，可以 <xref:System.Messaging.MessageQueue.BeginPeek%2A> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 在事件处理程序中调用或再次运行以继续接收通知。  
  
 返回的将 <xref:System.IAsyncResult> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 标识该方法启动的异步操作。 可以在 <xref:System.IAsyncResult> 操作的整个生存期内使用此方法，不过，在调用之前，通常不使用此方法 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 。 但是，如果您启动多个异步操作，则可以将它们的 <xref:System.IAsyncResult> 值放在数组中，并指定是否等待所有操作或任何操作完成。 在这种情况下，可以使用 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 的属性 <xref:System.IAsyncResult> 来标识已完成的操作。  
  
 状态对象将状态信息与操作相关联。 例如，如果 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 多次调用来启动多个操作，则可以通过定义的单独状态对象标识每个操作。  
  
 你还可以使用状态对象跨进程线程传递信息。 如果线程已启动，但回调在异步方案中的其他线程上，则将对状态对象进行封送处理，并将其与事件中的信息一起传递回来。  
  
 不要对事务使用异步调用 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 。 如果要执行事务异步操作，请调用 <xref:System.Messaging.MessageQueue.BeginPeek%2A> ，并在 <xref:System.Messaging.MessageQueue.Receive%2A> 为查看操作创建的事件处理程序中放置事务和 (同步) 方法。 你的事件处理程序可能包含以下 c # 代码中所示的功能。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例创建一个异步接收操作。 此代码示例将一条消息发送到本地消息队列，然后调用 <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29> 并传入：超时值为10秒; 唯一的整数，用于标识该特定消息; 以及 <xref:System.AsyncCallback> 标识事件处理程序的的新实例 `MyReceiveCompleted` 。 <xref:System.Messaging.MessageQueue.ReceiveCompleted>引发事件时，事件处理程序会接收消息，并将消息正文和整数消息标识符写入屏幕。  
  
 [!code-cpp[MessageQueueBeginReceive3#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <threadsafe>方法不是线程安全的。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, cursor As Cursor, state As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * System.Messaging.Cursor * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, cursor, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示等待消息变为可用所用的时间间隔。</param>
        <param name="cursor">维持消息队列中特定位置的 <see cref="T:System.Messaging.Cursor" />。</param>
        <param name="state">应用程序指定的状态对象，包含与异步操作关联的信息。</param>
        <param name="callback">该 <see cref="T:System.AsyncCallback" /> 将接收异步操作完成通知。</param>
        <summary>启动异步接收操作，此操作具有指定的超时并使用指定的游标和指定的状态对象。 状态对象在操作的整个生存期内提供相关的信息。 此重载通过回调接收操作的事件处理程序标识的通知。 直到队列中出现消息时或发生超时时才完成操作。</summary>
        <returns>该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载时，当消息在队列中可用或指定的时间间隔到期时，将直接调用在回调参数中指定的回调; <xref:System.Messaging.MessageQueue.ReceiveCompleted> 不引发该事件。 的其他重载 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 依赖于此组件来引发 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 事件。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 如果队列中已经存在消息，也会引发。  
  
 若要使用 <xref:System.Messaging.MessageQueue.BeginReceive%2A> ，请创建一个事件处理程序，用于处理异步操作的结果并将其与事件委托相关联。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 启动异步接收操作; <xref:System.Messaging.MessageQueue> <xref:System.Messaging.MessageQueue.ReceiveCompleted> 当消息到达队列时，会通过引发事件通知。 <xref:System.Messaging.MessageQueue>然后，可以通过调用 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 或使用检索结果来访问消息 <xref:System.Messaging.ReceiveCompletedEventArgs> 。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>方法会立即返回，但在调用事件处理程序之前，不会完成异步操作。  
  
 由于 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 是异步的，因此你可以调用它来接收队列中的消息，而不会阻止当前的执行线程。 若要以同步方式接收消息，请使用 <xref:System.Messaging.MessageQueue.Receive%2A> 方法。  
  
 异步操作完成后，可以 <xref:System.Messaging.MessageQueue.BeginPeek%2A> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 在事件处理程序中调用或再次运行以继续接收通知。  
  
 返回的将 <xref:System.IAsyncResult> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 标识该方法启动的异步操作。 可以在 <xref:System.IAsyncResult> 操作的整个生存期内使用此方法，不过，在调用之前，通常不使用此方法 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 。 但是，如果您启动多个异步操作，则可以将它们的 <xref:System.IAsyncResult> 值放在数组中，并指定是否等待所有操作或任何操作完成。 在这种情况下，请使用 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 的属性 <xref:System.IAsyncResult> 来标识已完成的操作。  
  
 状态对象将状态信息与操作相关联。 例如，如果 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 多次调用来启动多个操作，则可以通过定义的单独状态对象标识每个操作。  
  
 你还可以使用状态对象跨进程线程传递信息。 如果线程已启动，但回调在异步方案中的其他线程上，则将对状态对象进行封送处理，并将其与事件中的信息一起传递回来。  
  
 不要对事务使用异步调用 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 。 如果要执行事务异步操作，请调用 <xref:System.Messaging.MessageQueue.BeginPeek%2A> ，并在 <xref:System.Messaging.MessageQueue.Receive%2A> 为查看操作创建的事件处理程序中放置事务和 (同步) 方法。 你的事件处理程序可能包含以下 c # 代码中所示的功能。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="cursor" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <threadsafe>方法不是线程安全的。</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Messaging.MessageQueue.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_CanRead")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_CanRead")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Messaging.MessageQueue" /> 是否可读。</summary>
        <value>如果存在 <see cref="T:System.Messaging.MessageQueue" /> 而且应用程序可从其中读取，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanRead%2A> 指示应用程序是否能够查看或接收来自队列的消息。 如果 <xref:System.Messaging.MessageQueue.CanRead%2A> 为 `true` ，则 <xref:System.Messaging.MessageQueue> 可以接收或查看队列中的消息。 否则，不能。  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A>`false`如果队列已使用独占读取访问 (权限打开，或者它是使用非独占访问权限打开的，并且这 <xref:System.Messaging.MessageQueue> 请求) 独占访问权限，或者应用程序没有足够的权限访问它，则为。 如果你的应用程序在为时尝试从队列读取 <xref:System.Messaging.MessageQueue.CanRead%2A> `false` ，则拒绝访问。  
  
 下表显示了此属性在各种工作组模式下是否可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例显示消息队列属性的值 <xref:System.Messaging.MessageQueue.CanRead%2A> 。  
  
 [!code-csharp[MessageQueue#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Messaging.MessageQueue.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_CanWrite")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_CanWrite")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Messaging.MessageQueue" /> 是否可写。</summary>
        <value>如果存在 <see cref="T:System.Messaging.MessageQueue" /> 而且应用程序可向其中写入，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> 指示应用程序是否能够将消息发送到队列。 如果 <xref:System.Messaging.MessageQueue.CanWrite%2A> 为 `true` ，则 <xref:System.Messaging.MessageQueue> 可以将消息发送到队列。 否则，不能。  
  
 <xref:System.Messaging.MessageQueue.CanWrite%2A>`false`如果队列已使用独占写入访问 (权限打开，或者它是使用非独占访问权限打开的，并且这 <xref:System.Messaging.MessageQueue> 请求) 独占访问权限，或者应用程序没有足够的权限访问它，则为。 如果你的应用程序在为时尝试写入 <xref:System.Messaging.MessageQueue.CanWrite%2A> 队列 `false` ，则拒绝访问。  
  
 下表显示了此属性在各种工作组模式下是否可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例显示消息队列属性的值 <xref:System.Messaging.MessageQueue.CanWrite%2A> 。  
  
 [!code-csharp[MessageQueue#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberSignature Language="VB.NET" Value="Public Property Category As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Category { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.Category : Guid with get, set" Usage="System.Messaging.MessageQueue.Category" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_Category")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_Category")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置队列类别。</summary>
        <value><see cref="T:System.Guid" />，表示队列类别（“消息队列”类型标识符），它允许应用程序将其队列分类。 默认值为 <see langword="Guid.empty" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 队列类别允许应用程序将其队列分类。 例如，您可以将所有计费队列放在一个类别中，将所有订单队列放在另一个类别中。  
  
 <xref:System.Messaging.MessageQueue.Category%2A>属性提供对 "消息队列类型 ID" 属性的访问， (这是读/写) ，可通过 "计算机管理" 控制台中的 "**队列属性**" 对话框进行访问。 您可以定义一个新类别。 尽管可以使用 <xref:System.Guid.NewGuid%2A> 来创建在所有值中都是唯一的类别值，但不 <xref:System.Guid> 需要执行此类操作。 类别值仅需与其他类别（而不是所有其他值）不同 <xref:System.Guid> 。 例如，可以将分配为 {00000000-0000-0000-0000-000000000001} <xref:System.Messaging.MessageQueue.Category%2A> 一组队列，并将指定为另一组队列 {00000000-0000-0000-0000-000000000002} 的 <xref:System.Messaging.MessageQueue.Category%2A> 。  
  
 不需要设置 <xref:System.Messaging.MessageQueue.Category%2A> 。 该值可以为 `null`。  
  
 设置此属性将修改 "消息队列" 队列。 因此， <xref:System.Messaging.MessageQueue> 此更改会影响任何其他实例。  
  
 下表显示了此属性在各种工作组模式下是否可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 下面的代码示例获取并设置消息队列属性的值 <xref:System.Messaging.MessageQueue.Category%2A> 。  
  
 [!code-csharp[MessageQueue#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">队列类别被设置为无效值。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Id" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearConnectionCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearConnectionCache();" />
      <MemberSignature Language="F#" Value="static member ClearConnectionCache : unit -&gt; unit" Usage="System.Messaging.MessageQueue.ClearConnectionCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>清除连接缓存。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用时 <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A> ，将删除存储在缓存中的格式名称，并关闭缓存中打开和存储的句柄。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|是|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例调用 <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>。  
  
 [!code-csharp[MessageQueue#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageQueue.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放 <see cref="T:System.Messaging.MessageQueue" /> 分配的所有资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Close%2A> 释放与关联的所有资源 <xref:System.Messaging.MessageQueue> ，包括共享资源（如果适用）。 如果这些资源仍可用，则系统会自动重新获取这些资源，例如，当你调用 <xref:System.Messaging.MessageQueue.Send%28System.Object%29> 方法时，如以下 c # 代码中所示。  
  
```csharp  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 调用时 <xref:System.Messaging.MessageQueue.Close%2A> ， <xref:System.Messaging.MessageQueue> 将清除直接访问 "消息队列" 队列的所有属性。 <xref:System.Messaging.MessageQueue.Path%2A>、、 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> <xref:System.Messaging.MessageQueue.Formatter%2A> 和 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> 都保留原样。  
  
 <xref:System.Messaging.MessageQueue.Close%2A> 不要始终释放队列的读取和写入句柄，因为它们可能已共享。 可以执行以下任何步骤，以确保 <xref:System.Messaging.MessageQueue.Close%2A> 释放队列的读取和写入句柄：  
  
-   创建 <xref:System.Messaging.MessageQueue> 具有独占访问权限的。 为此，请调用 <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29> 或 <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> 构造函数，并将 `sharedModeDenyReceive` 参数设置为 `true` 。  
  
-   在 <xref:System.Messaging.MessageQueue> 禁用连接缓存的情况创建。 为此，请调用 <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> 构造函数并将 `enableConnectionCache` 参数设置为 `false` 。  
  
-   禁用连接缓存。 为此，请将 <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> 属性设置为 `false` 。  
  
 在 <xref:System.Messaging.MessageQueue.Close%2A> 删除消息队列服务器上的队列之前，应调用队列。 否则，发送到队列的消息可能会引发异常或出现在死信队列中。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|是|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例关闭 "消息队列" 队列。  
  
 [!code-cpp[MessageQueue.Close#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在“消息队列”服务器上的指定路径中创建新队列。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要创建的队列的路径。</param>
        <summary>在指定的路径中创建非事务性“消息队列”队列。</summary>
        <returns>表示新队列的 <see cref="T:System.Messaging.MessageQueue" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载创建非事务性 "消息队列" 队列。  
  
 若要 <xref:System.Messaging.MessageQueue> 在应用程序中创建类的新实例并将其绑定到现有队列，请使用 <xref:System.Messaging.MessageQueue.%23ctor%2A> 构造函数。 若要在消息队列中创建新队列，请调用 <xref:System.Messaging.MessageQueue.Create%28System.String%29> 。  
  
 参数的语法 `path` 取决于它所引用的队列的类型，如下表所示。  
  
|队列类型|语法|  
|----------------|------------|  
|公用队列|`MachineName`\\`QueueName`|  
|专用队列|`MachineName`\\`Private$`\\`QueueName`|  
  
 使用 "." 表示本地计算机。 有关更多语法，请参见 <xref:System.Messaging.MessageQueue.Path%2A> 属性。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 下面的代码示例创建公用和专用队列。 它将消息发送到所选队列。  
  
 [!code-cpp[MessageQueue.Create_path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create_path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create_path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 参数为 <see langword="null" /> 或者是空字符串 ("")。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">队列已存在于指定的路径中。  
  
 - 或 -  
  
 访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, transactional As Boolean) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path, bool transactional);" />
      <MemberSignature Language="F#" Value="static member Create : string * bool -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create (path, transactional)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">要创建的队列的路径。</param>
        <param name="transactional">如果创建事务性队列，为 <see langword="true" />；如果创建非事务性队列，则为 <see langword="false" />。</param>
        <summary>在指定的路径中创建事务性或非事务性“消息队列”队列。</summary>
        <returns>表示新队列的 <see cref="T:System.Messaging.MessageQueue" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用此重载在消息队列中创建事务性队列。 可以通过将 `transactional` 参数设置为 `false` 或，通过调用的其他重载，来创建非事务性队列 <xref:System.Messaging.MessageQueue.Create%28System.String%29> 。  
  
 若要 <xref:System.Messaging.MessageQueue> 在应用程序中创建类的新实例并将其绑定到现有队列，请使用 <xref:System.Messaging.MessageQueue.%23ctor%2A> 构造函数。 若要在消息队列中创建新队列，请调用 <xref:System.Messaging.MessageQueue.Create%28System.String%29> 。  
  
 参数的语法 `path` 取决于它所引用的队列的类型，如下表所示。  
  
|队列类型|语法|  
|----------------|------------|  
|公用队列|`MachineName`\\`QueueName`|  
|专用队列|`MachineName`\\`Private$`\\`QueueName`|  
  
 使用 "." 表示本地计算机。 有关更多语法，请参见 <xref:System.Messaging.MessageQueue.Path%2A> 属性。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 下面的代码示例创建公共和专用事务性队列。 它将消息发送到所选队列。  
  
 [!code-cpp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create_PathTransactional#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 参数为 <see langword="null" /> 或者是空字符串 ("")。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">队列已存在于指定的路径中。  
  
 - 或 -  
  
 访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCursor () As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Cursor ^ CreateCursor();" />
      <MemberSignature Language="F#" Value="member this.CreateCursor : unit -&gt; System.Messaging.Cursor" Usage="messageQueue.CreateCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为当前消息队列创建新的 <see cref="T:System.Messaging.Cursor" />。</summary>
        <returns>当前消息队列的新 <see cref="T:System.Messaging.Cursor" />。 此游标用于在读取队列的消息时保持队列中的特定位置。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Messaging.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreateTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime CreateTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateTime : DateTime" Usage="System.Messaging.MessageQueue.CreateTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_CreateTime")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_CreateTime")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在“消息队列”中创建队列的时间和日期。</summary>
        <value>表示队列创建日期和时间的 <see cref="T:System.DateTime" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CreateTime%2A> 指的是消息队列服务器上的队列，而不是 <xref:System.Messaging.MessageQueue> 实例。  
  
 如果该队列存在，则此属性表示创建该队列的时间，并调整为该队列所在服务器的本地时间。  
  
 下表显示了此属性在各种工作组模式下是否可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 下面的代码示例显示消息队列属性的值 <xref:System.Messaging.MessageQueue.CreateTime%2A> 。  
  
 [!code-csharp[MessageQueue#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.LastModifyTime" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultPropertiesToSend As DefaultPropertiesToSend" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::DefaultPropertiesToSend ^ DefaultPropertiesToSend { System::Messaging::DefaultPropertiesToSend ^ get(); void set(System::Messaging::DefaultPropertiesToSend ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPropertiesToSend : System.Messaging.DefaultPropertiesToSend with get, set" Usage="System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置(当应用程序向队列发送消息时)默认情况下使用的消息属性值。</summary>
        <value><see cref="T:System.Messaging.DefaultPropertiesToSend" />，它包含当应用程序向队列发送 <see cref="T:System.Messaging.Message" /> 实例以外的对象时使用的默认“消息队列”消息属性值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 向队列发送任何不属于类型的对象时 <xref:System.Messaging.Message> ，会将 <xref:System.Messaging.MessageQueue> 对象插入消息队列消息。 此时，应用于在 <xref:System.Messaging.MessageQueue> 属性中指定的属性值的消息 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 。 相反，如果将发送 <xref:System.Messaging.Message> 到队列，则已为实例本身指定了这些属性，因此 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 将忽略 <xref:System.Messaging.Message> 。  
  
 尽管通过对象设置属性，但 <xref:System.Messaging.MessageQueue> <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 引用发送到队列的消息的属性，而不是队列本身。  
  
 下表显示了这些属性的默认值。  
  
|Property|默认值|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|零|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|长度为零的字节数组|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|空字符串 ( "" ) |  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 下表显示了此属性在各种工作组模式下是否可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|是|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例使用消息的优先级来确定要为消息发送的默认属性。  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">未能设置队列的默认属性，可能因为这些属性之一无效。</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="T:System.Messaging.EncryptionAlgorithm" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Messaging.MessageQueue.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要删除的队列的位置。</param>
        <summary>删除“消息队列”服务器上的队列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参数的语法 `path` 取决于队列的类型。  
  
|队列类型|语法|  
|----------------|------------|  
|公用队列|`MachineName`\\`QueueName`|  
|专用队列|`MachineName`\\`Private$`\\`QueueName`|  
  
 有关更多语法，请参见 <xref:System.Messaging.MessageQueue.Path%2A> 属性。  
  
 或者，可以使用 <xref:System.Messaging.MessageQueue.FormatName%2A> 或 <xref:System.Messaging.MessageQueue.Label%2A> 来描述队列路径。  
  
|参考|语法|  
|---------------|------------|  
|格式名|Msmq.formatname： [ *格式名* ]|  
|Label|标签： [ *标签* ]|  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 下面的代码示例将删除 "消息队列" 队列（如果存在）。  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 参数为 <see langword="null" /> 或者是空字符串 ("")。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">该 <paramref name="path" /> 参数的语法无效。  
  
- 或 - 
访问“消息队列”方法时出错。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberSignature Language="VB.NET" Value="Public Property DenySharedReceive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DenySharedReceive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DenySharedReceive : bool with get, set" Usage="System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_DenySharedReceive")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_DenySharedReceive")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示此 <see cref="T:System.Messaging.MessageQueue" /> 对来自“消息队列”队列的消息是否有独占接收访问权。</summary>
        <value>如果此 <see cref="T:System.Messaging.MessageQueue" /> 对来自队列的消息有独占接收权，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> 指定由此引用的队列的共享模式 <xref:System.Messaging.MessageQueue> 。 如果设置为，则 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> `true` 指示只有这样才 <xref:System.Messaging.MessageQueue> 有权从具有指定的队列扫视或接收消息 <xref:System.Messaging.MessageQueue.Path%2A> 。 如果另一个 <xref:System.Messaging.MessageQueue> 应用程序或另一个应用程序与同一队列资源关联，则该实例或应用程序将无法查看或接收消息，但仍可发送消息。  
  
 如果 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> 为 `false` ，则队列可用于多个应用程序，用于发送、查看或接收消息。  
  
 下表显示了此属性在各种工作组模式下是否可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|是|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例获取并设置消息队列属性的值 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> 。  
  
 [!code-csharp[MessageQueue#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="messageQueue.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。</param>
        <summary>处置由 <see cref="T:System.Messaging.MessageQueue" /> 占用的资源（内存除外）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在完成使用 <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> 后，应调用 <xref:System.Messaging.MessageQueue>。 <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> 方法使 <xref:System.Messaging.MessageQueue> 处于不可用状态。 调用后 <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> ，必须释放对的所有引用， <xref:System.Messaging.MessageQueue> 以使其占用的内存可通过垃圾回收进行回收。  
  
 在 <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> 释放对的最后一个引用之前，应调用 <xref:System.Messaging.MessageQueue> 。 否则，在垃圾回收 <xref:System.Messaging.MessageQueue> 调用 <xref:System.Messaging.MessageQueue> 对象的析构函数之前，将不会释放正在使用的资源。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableConnectionCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableConnectionCache { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableConnectionCache : bool with get, set" Usage="System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示应用程序是否维护连接缓存。</summary>
        <value>如果创建和使用连接缓存，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 连接缓存是对包含队列读取或写入句柄的结构的引用的列表。 当 <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> 为时 `true` ， <xref:System.Messaging.MessageQueue> 每次调用、或时，都将从缓存中借用， <xref:System.Messaging.MessageQueue.Send%28System.Object%29> <xref:System.Messaging.MessageQueue.Peek%2A> <xref:System.Messaging.MessageQueue.Receive%2A> 而不是打开新句柄。 这可以提高性能。 使用连接缓存还会 <xref:System.Messaging.MessageQueue> 阻止网络拓扑中的更改。  
  
 如果在连接缓存已满时创建与队列的新连接，则会 <xref:System.Messaging.MessageQueue> 使用新连接覆盖最近访问最少的结构。 你可以通过调用来完全清除缓存 <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A> ，例如，如果你所使用的队列的格式名称已更改，使前面的读取和写入句柄不再有效。  
  
 下表显示了此属性在各种工作组模式下是否可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|是|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例获取并设置消息队列属性的值 <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> 。  
  
 [!code-csharp[MessageQueue#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionRequired As EncryptionRequired" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionRequired EncryptionRequired { System::Messaging::EncryptionRequired get(); void set(System::Messaging::EncryptionRequired value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionRequired : System.Messaging.EncryptionRequired with get, set" Usage="System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_EncryptionRequired")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_EncryptionRequired")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个指示队列是否只接受非私有（非加密）消息的值。</summary>
        <value><see cref="T:System.Messaging.EncryptionRequired" /> 值之一。 默认值为 <see langword="None" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你指定发送到队列的消息需要加密时，只会加密消息正文。 例如， (的其他成员 <xref:System.Messaging.Message.Label%2A> <xref:System.Messaging.Message.SenderId%2A> 不能加密和属性) 。  
  
 设置此属性将修改 "消息队列" 队列。 因此， <xref:System.Messaging.MessageQueue> 此更改会影响任何其他实例。  
  
 加密消息会使消息成为私有消息。 您可以 `None` `Body` `Optional` 通过 <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> 适当地设置属性，将队列的加密要求指定为、或。 <xref:System.Messaging.Message.UseEncryption%2A>消息的设置必须与队列的加密要求相对应。 如果未对消息进行加密，但队列指定了 `Body` ，或者如果消息已加密但队列指定了该消息 `None` ，则队列将拒绝该消息。 如果发送应用程序在此事件中请求否定确认消息，则消息队列将指示消息对发送应用程序的拒绝。 如果 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 属性为，则会将 `true` 加密失败的消息发送到死信队列。 否则，消息将丢失。  
  
 下表显示了此属性在各种工作组模式下是否可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 下面的代码示例获取并设置消息队列属性的值 <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> 。  
  
 [!code-csharp[MessageQueue#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="T:System.Messaging.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndPeek (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndPeek(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndPeek : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndPeek asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">该 <see cref="T:System.IAsyncResult" /> 标识要完成的异步查看操作，并且从它检索最终结果。</param>
        <summary>完成指定的异步查看操作。</summary>
        <returns>该 <see cref="T:System.Messaging.Message" /> 与已完成的异步操作关联。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.PeekCompleted>引发事件时，将 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 完成通过调用启动的操作 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 。 为此，请 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 查看消息。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 可以指定超时，这会导致在 <xref:System.Messaging.MessageQueue.PeekCompleted> 消息在队列中出现之前发生超时的情况下引发事件。 如果在没有消息到达队列的情况下出现超时，则对的后续调用将 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 引发异常。  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 用于读取导致 <xref:System.Messaging.MessageQueue.PeekCompleted> 引发事件的消息。  
  
 如果要继续异步查看消息，则可以 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 在调用后再次调用 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例创建一个名为的事件处理程序 `MyPeekCompleted` ，将其附加到 <xref:System.Messaging.MessageQueue.PeekCompleted> 事件处理程序委托，并调用 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 以对位于路径 ".\myQueue" 的队列启动异步查看操作。 <xref:System.Messaging.MessageQueue.PeekCompleted>引发事件时，该示例将扫视消息，并将其正文写入屏幕。 然后，该示例 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 再次调用以启动新的异步查看操作。  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">该 <paramref name="asyncResult" /> 参数的语法无效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndReceive(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndReceive asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">该 <see cref="T:System.IAsyncResult" /> 标识要完成的异步接收操作，并且从它检索最终结果。</param>
        <summary>完成指定的异步接收操作。</summary>
        <returns>该 <see cref="T:System.Messaging.Message" /> 与已完成的异步操作关联。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted>引发事件时，将 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 完成通过调用启动的操作 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 。 为此，会 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 接收消息。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 可以指定超时，这会导致在 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 消息在队列中出现之前发生超时的情况下引发事件。 如果在没有消息到达队列的情况下出现超时，则对的后续调用将 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 引发异常。  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 用于读取 (从队列中移除) 导致 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 引发事件的消息。  
  
 如果要继续异步接收消息，可以在 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 调用后再次调用 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例将异步请求链接在一起。 它假设本地计算机上有一个名为 "myQueue" 的队列。 `Main`函数开始由例程处理的异步操作 `MyReceiveCompleted` 。 `MyReceiveCompleted` 处理当前消息并开始新的异步接收操作。  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">该 <paramref name="asyncResult" /> 参数的语法无效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Messaging.MessageQueue.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要查找的队列的位置。</param>
        <summary>确定指定的路径中是否存在“消息队列”队列。</summary>
        <returns>如果指定的路径中存在队列，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29>方法确定消息队列队列是否存在于指定的路径。 不存在任何方法来确定具有指定格式名的队列是否存在。 有关格式名称语法和其他路径语法形式的详细信息，请参阅 <xref:System.Messaging.MessageQueue.Path%2A> 属性。 )   
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> 是代价高昂的操作。 仅当在应用程序中有必要时才使用它。  
  
> [!NOTE]
>  此 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> 方法不支持 <xref:System.Messaging.MessageQueue.FormatName%2A> 前缀。  
  
 参数的语法 `path` 取决于队列的类型，如下表所示。  
  
|队列类型|语法|  
|----------------|------------|  
|公用队列|`MachineName`\\`QueueName`|  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> 无法调用来验证远程专用队列是否存在。  
  
 有关更多语法，请参见 <xref:System.Messaging.MessageQueue.Path%2A> 属性。  
  
 或者，您可以使用 <xref:System.Messaging.MessageQueue.Label%2A> 来描述队列路径。  
  
|参考|语法|  
|---------------|------------|  
|Label|标签： [ `label` ]|  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|否|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 下面的代码示例验证 "消息队列" 队列是否存在，然后将其删除。  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">该 <paramref name="path" /> 语法无效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。  
  
- 或 - 
<see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /> 方法正被远程专用队列调用。</exception>
        <exception cref="T:System.InvalidOperationException">应用程序在验证队列是否存在时使用的格式名语法。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FormatName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FormatName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FormatName : string" Usage="System.Messaging.MessageQueue.FormatName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_FormatName")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_FormatName")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取“消息队列”在创建队列时生成的唯一队列名。</summary>
        <value>队列的名称，该名称在网络上是唯一的。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.FormatName%2A>属性包含队列的格式名。 消息队列使用格式名来标识要打开的队列以及如何访问它。 与队列的大多数特征不同，格式名不是 "消息队列应用程序队列" 属性，因此无法通过 "消息队列" 管理工具进行访问。 格式名称只是队列的唯一名称，消息队列在创建队列时生成，或者应用程序稍后生成。  
  
 如果使用路径名语法指定路径 (例如 `myComputer\myQueue`) ，而不是在读取或写入队列时使用格式名语法，则使用) Active Directory 的主域控制器 (将在 <xref:System.Messaging.MessageQueue.Path%2A> 访问队列之前将转换为关联的 <xref:System.Messaging.MessageQueue.FormatName%2A> 。 如果你的应用程序脱机工作，则必须使用 format name 语法;否则，主域控制器将不可用于执行路径转换。  
  
 下表显示了此属性在各种工作组模式下是否可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|是|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例显示消息队列属性的值 <xref:System.Messaging.MessageQueue.FormatName%2A> 。  
  
 [!code-csharp[MessageQueue#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">未设置 <see cref="P:System.Messaging.MessageQueue.Path" />。  
  
- 或 - 
访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="T:System.Messaging.MessageQueue" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.MessageQueue.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(null)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(null)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_Formatter")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_Formatter")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置格式化程序，该格式化程序用于将对象序列化为从队列读取或写入队列的消息体，或者用于将从队列读取或写入队列的消息体反序列化为对象。</summary>
        <value>该 <see cref="T:System.Messaging.IMessageFormatter" /> 产生要写入消息体或要从消息体中读取的流。 默认值为 <see cref="T:System.Messaging.XmlMessageFormatter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Formatter%2A>属性包含格式化程序对象的实例，该实例在应用程序读取或写入队列时转换消息。  
  
 当应用程序将消息发送到队列时，格式化程序将对象序列化为流，并将其插入消息正文。 从队列中读取时，格式化程序将消息数据反序列化到的 <xref:System.Messaging.Message.Body%2A> 属性中 <xref:System.Messaging.Message> 。  
  
 <xref:System.Messaging.XmlMessageFormatter>是松散耦合的，因此在使用此格式时，不需要在发送方和接收方上具有相同的对象类型。 将 <xref:System.Messaging.ActiveXMessageFormatter> <xref:System.Messaging.BinaryMessageFormatter> 数据序列化为二进制表示形式。 在 <xref:System.Messaging.ActiveXMessageFormatter> 发送或接收 COM 组件时使用。  
  
 <xref:System.Messaging.BinaryMessageFormatter> 与 <xref:System.Messaging.ActiveXMessageFormatter> 相比，提供更快的吞吐量 <xref:System.Messaging.XmlMessageFormatter> 。 <xref:System.Messaging.ActiveXMessageFormatter>允许与 Visual Basic 6.0 消息队列应用程序的互操作性。  
  
 当应用程序将消息发送到队列时， <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 仅适用于那些使用默认消息属性的消息 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 。 如果将发送 <xref:System.Messaging.Message> 到队列，则消息队列将使用属性中定义的格式化程序 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 来序列化正文。  
  
 <xref:System.Messaging.MessageQueue>类将始终使用 <xref:System.Messaging.Message> 来接收或查看队列中的消息。 使用属性对消息进行反序列化 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 。  
  
 下表显示了此属性在各种工作组模式下是否可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例演示如何使用格式化消息正文 <xref:System.Messaging.BinaryMessageFormatter> 。  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 下面的代码示例演示如何使用格式化消息正文 <xref:System.Messaging.XmlMessageFormatter> 。  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMessages () As Message()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Messaging::Message ^&gt; ^ GetAllMessages();" />
      <MemberSignature Language="F#" Value="member this.GetAllMessages : unit -&gt; System.Messaging.Message[]" Usage="messageQueue.GetAllMessages " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回位于队列中的所有消息。</summary>
        <returns>类型 <see cref="T:System.Messaging.Message" /> 的数组，表示队列中所有消息，其顺序与这些消息在“消息队列”队列中的出现顺序相同。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> 返回队列中消息的静态快照，而不是指向这些消息的动态链接。 因此，不能使用数组来修改队列中的消息。 如果要与队列进行实时、动态的交互 (例如) 删除消息的能力），请调用 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> 方法，这将返回队列中消息的动态列表。  
  
 由于 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> 在调用方法时返回队列中的消息的副本，因此数组不反映到达队列中的新消息或从队列中移除的消息。  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> 仅检索未按属性筛选掉的那些属性 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> 。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> 的用法。  
  
 [!code-cpp[MessageQueue2#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="messageQueue.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName Language="C#">[System.Obsolete]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>枚举队列中的消息。 <see cref="M:System.Messaging.MessageQueue.GetEnumerator" /> 已弃用。 应改用 <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />。</summary>
        <returns><see cref="T:System.Collections.IEnumerator" />，它提供与队列消息的动态连接。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.GetEnumerator%2A> 的用法。  
  
 [!code-cpp[MessageQueue2#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineId (machineName As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetMachineId(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetMachineId : string -&gt; Guid" Usage="System.Messaging.MessageQueue.GetMachineId machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">包含队列的计算机的名称，名称前不含两个反斜杠 (\\\\)。</param>
        <summary>获取计算机的标识符，此 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列位于该计算机上。</summary>
        <returns><see cref="T:System.Guid" />，表示队列所在的计算机的唯一标识符。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用计算机的标识符来实现两个目的：读取计算机日志并设置安全证书。 但是， <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> 当脱机工作时，无法为远程计算机调用，因为该应用程序必须有权访问域控制器上的目录服务。  
  
 计算机标识符 (或计算机标识符) 是在将 <xref:System.Guid> 计算机添加到企业时消息队列创建的。 消息队列将计算机标识符与 `Machine` 和关键字结合起来 `Journal` ，以创建计算机日志的格式名，该名称具有语法 `Machine=<computeridentifier>;Journal` 。 计算机日志（也称为日志队列）是在属性为时存储应用程序生成的消息的副本的系统队列 <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> `true` 。  
  
 此日志语法仅在构造队列的格式名时有效。 路径名称语法为 `MachineName` \\ `Journal$` 。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|否|  
|本地计算机和直接格式名称|否|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 下面的代码示例调用 <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29>。  
  
 [!code-csharp[MessageQueue#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">未能检索到计算机标识符，可能是因为目录服务不可用，例如当正在脱机工作时。  
  
 - 或 -  
  
 访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName Language="C#">[System.Obsolete]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为队列中的所有消息创建枚举数对象。 <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /> 已弃用。 应改用 <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />。</summary>
        <returns>该 <see cref="T:System.Messaging.MessageEnumerator" /> 包括队列中所包含的消息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> 创建队列中所有消息的动态列表。 你可以通过调用返回的来从队列中删除消息，该消息位于枚举数的当前位置 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> <xref:System.Messaging.MessageEnumerator> <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> 。  
  
 由于游标与队列中的消息动态列表相关联，因此，如果消息在当前游标位置之外，则枚举将反映对队列中的消息所做的任何修改。 例如，枚举器可以自动访问放置在游标当前位置之外的低优先级的消息，但不能访问在该位置之前插入的优先级较高的消息。 但是，你可以通过调用来重置枚举，从而将游标移回列表的开头 <xref:System.Messaging.MessageEnumerator.Reset%2A> <xref:System.Messaging.MessageEnumerator> 。  
  
 枚举中的消息顺序反映了它们在队列中的顺序，因此优先级较高的消息会出现在优先级较低的消息之前。  
  
 如果希望队列中消息的静态快照而不是动态连接到它们，请调用 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> 。 此方法返回对象的数组 <xref:System.Messaging.Message> ，这些对象表示调用方法时的消息。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|是|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例获取队列中消息的动态列表，并对属性设置为的所有消息进行计数 <xref:System.Messaging.Message.Priority%2A> <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType> 。  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator2 () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator2();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator2 : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator2 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为队列中的所有消息创建枚举数对象。</summary>
        <returns>该 <see cref="T:System.Messaging.MessageEnumerator" /> 包括队列中所包含的消息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> 创建队列中所有消息的动态列表。 你可以通过调用返回的来从队列中删除消息，该消息位于枚举数的当前位置 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> <xref:System.Messaging.MessageEnumerator> <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> 。  
  
 由于游标与队列中的消息动态列表相关联，因此，如果消息在当前游标位置之外，则枚举将反映对队列中的消息所做的任何修改。 例如，枚举器可以自动访问放置在游标当前位置之外的低优先级的消息，但不能访问在该位置之前插入的优先级较高的消息。 但是，你可以通过调用来重置枚举，从而将游标移回列表的开头 <xref:System.Messaging.MessageEnumerator.Reset%2A> <xref:System.Messaging.MessageEnumerator> 。  
  
 枚举中的消息顺序反映了它们在队列中的顺序，因此优先级较高的消息会出现在优先级较低的消息之前。  
  
 如果希望队列中消息的静态快照而不是动态连接到它们，请调用 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> 。 此方法返回对象的数组 <xref:System.Messaging.Message> ，这些对象表示调用方法时的消息。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|是|  
|远程计算机和直接格式名称|是|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMessageQueueEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>为网络上公共队列的动态列表创建枚举数对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator () As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator();" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : unit -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>提供只进游标语义，以枚举网络上的所有公共队列。</summary>
        <returns><see cref="T:System.Messaging.MessageQueueEnumerator" />，提供网络上所有公共消息队列的动态列表。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> 返回网络上所有公共队列的枚举。  
  
 由于游标与动态列表相关联，因此，枚举反映对删除或添加到游标当前位置之外的队列所做的任何修改。 不会反映在游标当前位置之前添加或删除队列的操作。 例如，枚举器可以自动访问追加到光标位置之外的队列，而不是在该位置之前插入的队列。 但是，你可以通过调用来重置枚举，从而将游标移回列表的开头 <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> <xref:System.Messaging.MessageQueueEnumerator> 。  
  
 网络中未定义队列的顺序。 枚举器不按计算机、标签、公共或私有状态或任何其他可访问的条件对它们进行排序。  
  
 如果希望网络上的队列（而不是动态连接）的静态快照，请调用 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 或 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> 。 这两个方法都返回对象的数组 <xref:System.Messaging.MessageQueue> ，这些对象表示调用方法时的队列。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|否|  
|本地计算机和直接格式名称|否|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 下面的代码示例将循环访问网络中的所有消息队列，并检查每个队列的路径。 最后，它显示网络上公用队列的数量。  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator (criteria As MessageQueueCriteria) As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria"><see cref="T:System.Messaging.MessageQueueCriteria" />，包含用于筛选可用消息队列的判据。</param>
        <summary>提供只进游标语义，以枚举网络上满足指定判据的所有公共队列。</summary>
        <returns><see cref="T:System.Messaging.MessageQueueEnumerator" />，提供网络上公共消息队列的动态列表，这些消息队列满足 <paramref name="criteria" /> 参数指定的限制。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的此重载 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> 返回网络上满足应用程序条件中定义的条件的所有公用队列的列表。 可以指定要包括的条件，例如，队列创建或修改时间、计算机名称、标签、类别或这些条件的任意组合。  
  
 由于游标与动态列表相关联，因此，枚举反映了对出现在游标当前位置之外的队列所做的任何修改。 不会反映对光标当前位置之前的队列所做的更改。 例如，枚举器可以自动访问追加到光标位置之外的队列，而不是在该位置之前插入的队列。 但是，你可以通过调用来重置枚举，从而将游标移回列表的开头 <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> <xref:System.Messaging.MessageQueueEnumerator> 。  
  
 网络中未定义队列的顺序。 枚举器不按计算机、标签、公共或私有状态或任何其他可访问的条件对它们进行排序。  
  
 如果希望网络上的队列（而不是动态连接到它们）的静态快照，请指定 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 或调用的条件 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> 。 这两个方法都返回对象的数组 <xref:System.Messaging.MessageQueue> ，这些对象表示调用方法时的队列。 调用 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> 、 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> 或 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> 可提供与 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 通过、和的筛选条件调用相同的 <xref:System.Messaging.MessageQueue.Category%2A> 结果 <xref:System.Messaging.MessageQueue.Label%2A> <xref:System.Messaging.MessageQueue.MachineName%2A> 。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|否|  
|本地计算机和直接格式名称|否|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 下面的代码示例将循环访问消息队列，并显示在最后一天中创建并且存在于计算机 "MyComputer" 上的每个队列的路径。  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPrivateQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPrivateQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPrivateQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPrivateQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">计算机，从其中检索专用队列。</param>
        <summary>检索指定计算机上的所有专用队列。</summary>
        <returns>引用检索的专用队列的 <see cref="T:System.Messaging.MessageQueue" /> 对象数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> 检索指定计算机上队列的静态快照。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|是|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例检索队列的列表。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> 参数为 <see langword="null" /> 或是空字符串（“”）。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPublicQueues">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>检索网络上的所有公共队列。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues () As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues();" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : unit -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索网络上的所有公共队列。</summary>
        <returns>引用检索的公共队列的 <see cref="T:System.Messaging.MessageQueue" /> 对象数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要完整列出网络上的所有公共队列，请使用此重载。 如果要按某些条件（如 <xref:System.Messaging.MessageQueue.MachineName%2A> 、或上次修改时间）限制列表，请 <xref:System.Messaging.MessageQueue.Category%2A> 使用此方法的另一个重载。  (或者，你可以使用 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> 、 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> 或 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> 。 )   
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 检索队列的静态快照。 若要与队列动态列表交互，请使用 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> 。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|否|  
|本地计算机和直接格式名称|否|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 下面的代码示例检索队列的列表。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues (criteria As MessageQueueCriteria) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria"><see cref="T:System.Messaging.MessageQueueCriteria" />，包含用于筛选队列的判据。</param>
        <summary>检索网络上满足指定判据的所有公共队列。</summary>
        <returns>引用检索的公共队列的 <see cref="T:System.Messaging.MessageQueue" /> 对象数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要按标签、类别或计算机名称筛选网络上的所有公共队列， <xref:System.Messaging.MessageQueue> 类将包含 (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> 、 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> 和分别) 提供该功能的特定方法 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> 。 使用此重载获取网络上满足多个条件的所有公用队列的列表 (例如，如果要同时指定标签和类别) 。 还可以通过、和以外的消息条件进行筛选 <xref:System.Messaging.MessageQueue.Label%2A> <xref:System.Messaging.MessageQueue.Category%2A> <xref:System.Messaging.MessageQueue.MachineName%2A> 。 例如，使用此重载按队列的上次修改时间进行筛选。 只需创建类的新实例 <xref:System.Messaging.MessageQueueCriteria> ，在该实例中设置相应的属性，然后将该实例作为 `criteria` 参数传递。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 检索队列的静态快照。 若要与队列动态列表交互，请使用 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> 。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|否|  
|本地计算机和直接格式名称|否|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 下面的代码示例检索队列的列表。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="T:System.Messaging.MessageQueueCriteria" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByCategory (category As Guid) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByCategory(Guid category);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByCategory : Guid -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByCategory category" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category">一个 <see cref="T:System.Guid" />，它将要检索的队列集分组。</param>
        <summary>检索网络上所有属于指定类别的公共队列。</summary>
        <returns>引用检索的公共队列的 <see cref="T:System.Messaging.MessageQueue" /> 对象数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可以按类别筛选公共队列。 <xref:System.Messaging.MessageQueue.Category%2A>属性提供对消息队列类型 ID 属性的访问， (这是特定队列的读/写) 。 尽管可以使用 <xref:System.Guid.NewGuid%2A> 来创建在所有值中都是唯一的类别值 <xref:System.Guid> ，但这并不是必需的。 类别值仅需与其他类别（而不是所有其他值）不同 <xref:System.Guid> 。 例如，可以将分配为 {00000000-0000-0000-0000-000000000001} <xref:System.Messaging.MessageQueue.Category%2A> 一组队列，并将指定为另一组队列 {00000000-0000-0000-0000-000000000002} 的 <xref:System.Messaging.MessageQueue.Category%2A> 。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> 检索队列的静态快照。 若要与队列动态列表交互，请使用 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> 。 你可以将类别指定为 <xref:System.Messaging.MessageQueueCriteria> 传入方法的。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|否|  
|本地计算机和直接格式名称|否|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 下面的代码示例检索队列的列表。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByLabel (label As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByLabel(System::String ^ label);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByLabel : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByLabel label" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label">一个标签，它将要检索的队列集分组。</param>
        <summary>检索网络上带有指定标签的所有公共队列。</summary>
        <returns>引用检索的公共队列的 <see cref="T:System.Messaging.MessageQueue" /> 对象数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可以按标签筛选公共队列。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> 检索队列的静态快照。 若要与队列动态列表交互，请使用 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> 。 您可以将标签指定为传入方法的中的一部分 <xref:System.Messaging.MessageQueueCriteria> 。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|否|  
|本地计算机和直接格式名称|否|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 下面的代码示例检索队列的列表。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="label" /> 参数为 <see langword="null" />。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">计算机的名称，该计算机包含要检索的公共队列集。</param>
        <summary>检索驻留在指定计算机上的所有公共队列。</summary>
        <returns><see cref="T:System.Messaging.MessageQueue" /> 对象数组，这些对象引用该计算机上的公共队列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可以按计算机筛选公共队列。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> 检索队列的静态快照。 若要与队列动态列表交互，请使用 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> 。 你可以将计算机名称指定为 <xref:System.Messaging.MessageQueueCriteria> 传入方法的。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|否|  
|本地计算机和直接格式名称|否|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 下面的代码示例检索队列的列表。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> 参数的语法不正确。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSecurityContext () As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::SecurityContext ^ GetSecurityContext();" />
      <MemberSignature Language="F#" Value="static member GetSecurityContext : unit -&gt; System.Messaging.SecurityContext" Usage="System.Messaging.MessageQueue.GetSecurityContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索进行此调用时 MSMQ 将当前用户（线程标识）关联到的安全上下文。</summary>
        <returns>包含安全上下文的 <see cref="T:System.Messaging.SecurityContext" /> 对象。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Messaging.Message.SecurityContext" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Id { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : Guid" Usage="System.Messaging.MessageQueue.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_GuidId")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_GuidId")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取队列的唯一“消息队列”标识符。</summary>
        <value><see cref="P:System.Messaging.MessageQueue.Id" />，表示由“消息队列”应用程序生成的消息标识符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 消息队列 <xref:System.Messaging.MessageQueue.Id%2A> 在创建队列时设置属性。 此属性仅适用于公用队列。  
  
 下表显示了此属性在各种工作组模式下是否可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 下面的代码示例显示消息队列属性的值 <xref:System.Messaging.MessageQueue.Id%2A> 。  
  
 [!code-csharp[MessageQueue#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteQueueSize As Long " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly long InfiniteQueueSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteQueueSize : int64" Usage="System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定对某队列不存在大小限制。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员在设置或时经常 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> 使用 <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> 。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Messaging.MessageQueue.InfiniteQueueSize> 成员。  
  
 [!code-csharp[MessageQueue#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定对查看或接收消息的方法不存在超时设定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue> 支持两种类型的消息检索：同步和异步。 同步方法和将 <xref:System.Messaging.MessageQueue.Peek%2A> <xref:System.Messaging.MessageQueue.Receive%2A> 导致进程线程等待指定的时间间隔，以使新消息到达队列。 如果指定的时间间隔为 <xref:System.Messaging.MessageQueue.InfiniteTimeout> ，则进程线程将保持阻止状态，直到新消息可用。 另一方面，如果 <xref:System.Messaging.MessageQueue.BeginPeek%2A> <xref:System.Messaging.MessageQueue.BeginReceive%2A> 异步方法)  (，则允许主应用程序任务在单独的线程中继续，直到消息到达队列。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 成员。  
  
 [!code-csharp[MessageQueue#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.MessageQueue.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_Label")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_Label")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置队列说明。</summary>
        <value>消息队列的标签。 默认值为空字符串("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 消息队列标签的最大长度为124个字符。  
  
 <xref:System.Messaging.MessageQueue.Label%2A>属性不需要在所有队列中都是唯一的。 但是，如果多个队列共享同一项 <xref:System.Messaging.MessageQueue.Label%2A> ，则不能使用 <xref:System.Messaging.MessageQueue.Send%28System.Object%29> 方法将消息广播到所有队列。 如果在 <xref:System.Messaging.MessageQueue.Path%2A> 发送消息时使用属性的标签语法，则如果不唯一，则会引发异常 <xref:System.Messaging.MessageQueue.Label%2A> 。  
  
 下表显示了此属性在各种工作组模式下是否可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 下面的代码示例获取并设置消息队列属性的值 <xref:System.Messaging.MessageQueue.Label%2A> 。  
  
 [!code-csharp[MessageQueue#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">标签被设置为无效值。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastModifyTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime LastModifyTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.LastModifyTime : DateTime" Usage="System.Messaging.MessageQueue.LastModifyTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_LastModifyTime")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_LastModifyTime")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取队列属性的最近修改时间。</summary>
        <value>指示队列属性最近修改时间的 <see cref="T:System.DateTime" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 上次修改时间包括创建队列的时间和 <xref:System.Messaging.MessageQueue> 修改 "消息队列" 队列的任何属性（如） <xref:System.Messaging.MessageQueue.BasePriority%2A> 。 属性的值 <xref:System.Messaging.MessageQueue.LastModifyTime%2A> 表示本地计算机的系统时间。  
  
 <xref:System.Messaging.MessageQueue.Refresh%2A>获取属性之前必须调用 <xref:System.Messaging.MessageQueue.LastModifyTime%2A> ; 否则，与此关联的修改时间 <xref:System.Messaging.MessageQueue> 可能不是最新的。  
  
 下表显示了此属性在各种工作组模式下是否可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 下面的代码示例显示消息队列属性的值 <xref:System.Messaging.MessageQueue.LastModifyTime%2A> 。  
  
 [!code-csharp[MessageQueue#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CreateTime" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Messaging.MessageQueue.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_MachineName")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_MachineName")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置“消息队列”队列所在的计算机的名称。</summary>
        <value>队列所在的计算机的名称。 “消息队列”默认值为“.”，即本地计算机。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MachineName%2A>是队列友好名称语法的组成部分 <xref:System.Messaging.MessageQueue.Path%2A> 。 下表显示了在要使用其友好名称标识队列路径时，应用于指定类型的队列的语法。  
  
|队列类型|语法|  
|----------------|------------|  
|公用队列|`MachineName`\\`QueueName`|  
|专用队列|`MachineName`\\`Private$`\\`QueueName`|  
|日志队列|`MachineName`\\`QueueName`\\`Journal$`|  
|计算机日志队列|`MachineName`\\`Journal$`|  
|计算机死信队列|`MachineName`\\`Deadletter$`|  
|计算机事务性死信队列|`MachineName`\\`XactDeadletter$`|  
  
 指定时，使用本地计算机的 "." <xref:System.Messaging.MessageQueue.MachineName%2A> 。 此属性仅识别计算机名称，例如， `Server0` 。 <xref:System.Messaging.MessageQueue.MachineName%2A>属性不支持 IP 地址格式。  
  
 如果 <xref:System.Messaging.MessageQueue.Path%2A> 在中定义 <xref:System.Messaging.MessageQueue.MachineName%2A> ，则当脱机工作时，应用程序将引发异常，因为路径转换需要域控制器。 因此， <xref:System.Messaging.MessageQueue.FormatName%2A> <xref:System.Messaging.MessageQueue.Path%2A> 当脱机工作时，必须使用语法。  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>、 <xref:System.Messaging.MessageQueue.Path%2A> 和 <xref:System.Messaging.MessageQueue.QueueName%2A> 属性是相关的。 更改 <xref:System.Messaging.MessageQueue.MachineName%2A> 属性将导致 <xref:System.Messaging.MessageQueue.Path%2A> 属性发生更改。 它从新的和生成 <xref:System.Messaging.MessageQueue.MachineName%2A> <xref:System.Messaging.MessageQueue.QueueName%2A> 。 更改 <xref:System.Messaging.MessageQueue.Path%2A> (例如，若要使用格式名语法) 重置 <xref:System.Messaging.MessageQueue.MachineName%2A> 和 <xref:System.Messaging.MessageQueue.QueueName%2A> 属性以引用新队列。 如果该 <xref:System.Messaging.MessageQueue.QueueName%2A> 属性为空，则将 <xref:System.Messaging.MessageQueue.Path%2A> 设置为指定的计算机的日记队列。  
  
 下表显示了此属性在各种工作组模式下是否可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|是|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 下面的代码示例获取并设置消息队列属性的值 <xref:System.Messaging.MessageQueue.MachineName%2A> 。  
  
 [!code-csharp[MessageQueue#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.MessageQueue.MachineName" /> 为 <see langword="null" />。        
- 或 -

计算机名称无效，可能是因为语法不正确。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumJournalSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumJournalSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumJournalSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_MaximumJournalSize")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_MaximumJournalSize")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置日记队列的最大大小。</summary>
        <value>日记队列的最大大小，以千字节为单位。 “消息队列”默认设置指定：不存在任何限制。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> 提供对消息队列日志存储限制的访问。 仅当为时，它才适用 <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> `true` 。 设置此属性将修改 "消息队列" 队列。 因此， <xref:System.Messaging.MessageQueue> 此更改会影响任何其他实例  
  
 如果将消息存储在日志或死信队列中，则应定期清除队列，以删除不再需要的消息。 此类队列中的消息将计入队列所在的计算机的消息配额。  (管理员设置计算机配额。 )   
  
 下表显示了此属性在各种工作组模式下是否可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 下面的代码示例获取并设置消息队列属性的值 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> 。  
  
 [!code-csharp[MessageQueue#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">日记队列的最大大小被设置为无效值。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumQueueSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumQueueSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumQueueSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_MaximumQueueSize")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_MaximumQueueSize")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置队列的最大大小。</summary>
        <value>队列的最大大小，以千字节为单位。 “消息队列”默认设置指定：不存在任何限制。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>提供对消息队列消息存储限制的访问，此限制与管理员定义的计算机的消息配额不同。 有关消息配额的详细信息，请参阅 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> 。  
  
 设置此属性将修改 "消息队列" 队列。 因此， <xref:System.Messaging.MessageQueue> 此更改会影响任何其他实例  
  
 如果尝试超过最大队列大小或计算机消息配额，则消息可能会丢失。 当达到队列配额时，消息队列会通过返回否定确认消息，通知发送应用程序的管理队列是否已满。 在队列中的消息的总大小降至限制以下之前，消息队列将继续发送否定确认。  
  
 下表显示了此属性在各种工作组模式下是否可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 下面的代码示例获取并设置消息队列属性的值 <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> 。  
  
 [!code-csharp[MessageQueue#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">队列最大大小包含负值。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageReadPropertyFilter As MessagePropertyFilter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePropertyFilter ^ MessageReadPropertyFilter { System::Messaging::MessagePropertyFilter ^ get(); void set(System::Messaging::MessagePropertyFilter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MessageReadPropertyFilter : System.Messaging.MessagePropertyFilter with get, set" Usage="System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置接收或查看消息的属性筛选器。</summary>
        <value>由队列使用的 <see cref="T:System.Messaging.MessagePropertyFilter" />，用来筛选队列所接收或查看的每个消息的属性集。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此筛选器是一组用来限制接收或查看的消息属性的布尔值 <xref:System.Messaging.MessageQueue> 。 当 <xref:System.Messaging.MessageQueue> 从服务器队列接收或查看消息时，它只检索值为的那些属性 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> `true` 。  
  
 下图显示了属性的初始属性值 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> 。 这些设置与 <xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A> 在上调用时相同 <xref:System.Messaging.MessagePropertyFilter> 。  
  
|Property|默认值|  
|--------------|-------------------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|1024 字节|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|255字节|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|255字节|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 下表显示了此属性在各种工作组模式下是否可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|是|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> 来限制接收的消息属性。  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">筛选器为 <see langword="null" />。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MulticastAddress { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastAddress : string with get, set" Usage="System.Messaging.MessageQueue.MulticastAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue("")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue("")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_MulticastAddress")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_MulticastAddress")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 MSMQ 3.0 中引入。 获取或设置与队列关联的多路广播地址。</summary>
        <value>包含有效的多路广播地址（格式如下）的 <see cref="T:System.String" />，或者为 <see langword="null" />，这表示队列与多路广播地址不关联。  
  
```  
&lt;address&gt;:&lt;port&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MulticastAddress%2A>属性用于将非事务性队列与发送消息时可以使用的多播地址相关联。 不能将事务性队列与多路广播地址相关联。 当发送应用程序向多播地址发送消息时，消息队列会将该消息的副本发送到与该地址关联的每个队列。  
  
 IP 多播地址必须在从224.0.0.0 到239.255.255.255 的 D 类范围内，这相当于设置前四个高序位等于1110。 不过，只有此范围内的某些地址不会被保留，并且可用于发送多播消息。 有关保留的多播地址的最新列表，请参阅 [Internet 分配的编号机构 (IANA) Internet 多播地址](https://go.microsoft.com/fwlink/?linkid=3859) "网页。 端口号没有限制。  
  
 如果多台源计算机发送多播消息，并且你希望特定队列仅接收来自一台源计算机的消息，则每个源计算机必须将消息发送到不同的 IP 地址和端口号组合。  
  
 若要将队列与多播地址取消关联，请将 <xref:System.Messaging.MessageQueue.MulticastAddress%2A> 属性设置为长度为零的字符串。 不要将其设置为 `null` ，因为这会导致 <xref:System.ArgumentNullException> 。  
  
 下表显示了此属性在各种工作组模式下是否可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">未安装 MSMQ 3.0。</exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.Messaging.MessageQueue.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue("")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue("")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.ComponentModel.RecommendedAsConfigurable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.RecommendedAsConfigurable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_Path")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_Path")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName Language="C#">[System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.SettingsBindable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.SettingsBindable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置队列的路径。 设置 <see cref="P:System.Messaging.MessageQueue.Path" /> 会导致 <see cref="T:System.Messaging.MessageQueue" /> 指向新队列。</summary>
        <value>由 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列。 默认值取决于所使用的 <see cref="M:System.Messaging.MessageQueue.#ctor" /> 构造函数；它或者是 <see langword="null" />，或者是由构造函数的 <paramref name="path" /> 参数指定的。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性的语法 <xref:System.Messaging.MessageQueue.Path%2A> 取决于它所指向的队列的类型，如下表所示。  
  
|队列类型|语法|  
|----------------|------------|  
|公用队列|`MachineName`\\`QueueName`|  
|专用队列|`MachineName`\\`Private$`\\`QueueName`|  
|日志队列|`MachineName`\\`QueueName`\\`Journal$`|  
|计算机日志队列|`MachineName`\\`Journal$`|  
|计算机死信队列|`MachineName`\\`Deadletter$`|  
|计算机事务性死信队列|`MachineName`\\`XactDeadletter$`|  
  
 使用 "." 表示本地计算机。  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>、 <xref:System.Messaging.MessageQueue.Path%2A> 和 <xref:System.Messaging.MessageQueue.QueueName%2A> 属性是相关的。 更改 <xref:System.Messaging.MessageQueue.MachineName%2A> 属性将导致 <xref:System.Messaging.MessageQueue.Path%2A> 属性发生更改。 它从新的和生成 <xref:System.Messaging.MessageQueue.MachineName%2A> <xref:System.Messaging.MessageQueue.QueueName%2A> 。 更改 <xref:System.Messaging.MessageQueue.Path%2A> (例如，若要使用格式名语法) 重置 <xref:System.Messaging.MessageQueue.MachineName%2A> 和 <xref:System.Messaging.MessageQueue.QueueName%2A> 属性以引用新队列。  
  
 或者，可以使用 <xref:System.Messaging.MessageQueue.FormatName%2A> 或 <xref:System.Messaging.MessageQueue.Label%2A> 来描述队列路径，如下表所示。  
  
|参考|语法|示例|  
|---------------|------------|-------------|  
|格式名|`FormatName:` [ *格式名* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112|  
|Label|`Label:` [ *标签* ]|`Label:` TheLabel|  
  
 如果在 <xref:System.Messaging.MessageQueue.Path%2A> 发送消息时使用属性的标签语法，则如果不唯一，则会引发异常 <xref:System.Messaging.MessageQueue.Label%2A> 。  
  
 若要脱机工作，必须使用格式名语法，而不是第一个表中的友好名称语法。 否则，会引发异常，因为 Active Directory 所在的主域控制器 () 不可用于解析格式名称的路径。  
  
 设置新路径将关闭消息队列并释放所有句柄。  
  
 下表显示了此属性在各种工作组模式下是否可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|是|  
|远程计算机和直接格式名称|是|  
  
> [!NOTE]
>  在工作组模式下，只能使用专用队列。 使用专用队列语法指定该路径 `MachineName` \\ `Private$` \\ `QueueName` 。  
  
   
  
## Examples  
 下面的代码示例 <xref:System.Messaging.MessageQueue> 使用各种路径名称语法类型创建新的对象。 在每种情况下，它会将消息发送到其路径在构造函数中定义的队列。  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">路径无效，可能是因为语法无效。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Peek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>方法不是线程安全的。</threadsafe>
        <summary>返回队列中第一条消息的副本，而不从队列中移除该消息。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek();" />
      <MemberSignature Language="F#" Value="member this.Peek : unit -&gt; System.Messaging.Message" Usage="messageQueue.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回但不移除（查看）此 <see cref="T:System.Messaging.MessageQueue" /> 所引用的队列中的第一条消息。 <see cref="M:System.Messaging.MessageQueue.Peek" /> 方法是同步的，所以在有可用消息前，该方法阻塞当前线程。</summary>
        <returns>该 <see cref="T:System.Messaging.Message" /> 表示队列中第一条消息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载可查看队列，或等待队列中存在消息。  
  
 此 <xref:System.Messaging.MessageQueue.Peek%2A> 方法从队列中读取并不删除第一条消息。 因此，重复调用将 <xref:System.Messaging.MessageQueue.Peek%2A> 返回相同的消息，除非队列中有较高优先级的消息到达。 <xref:System.Messaging.MessageQueue.Receive%2A>另一方面，方法会读取和删除队列中的第一条消息。 因此，对的重复调用将 <xref:System.Messaging.MessageQueue.Receive%2A> 返回不同的消息。  
  
 消息队列根据优先级和到达时间对队列中的消息进行排序。 仅当较高优先级的消息超过较高优先级时，才会将其放在旧消息之前。  
  
 如果当前线程在等待消息到达队列时可以被阻塞，则使用 <xref:System.Messaging.MessageQueue.Peek%2A>。 由于此重载未指定超时，因此应用程序可能会无限期等待。 如果需要应用程序处理继续进行而不等待，则使用异步 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 方法。 或者，您可以通过使用指定超时的的重载来指定消息到达队列的超时时间 <xref:System.Messaging.MessageQueue.Peek%2A> 。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的示例在队列中使用 <xref:System.Messaging.MessageQueue.Peek%2A> 方法。  
  
 在第一个示例中，应用程序会等待，直到队列中有可用的消息。 请注意，第一个示例不会访问到达的消息;它只是暂停处理直到消息到达。 如果消息已在队列中存在，它将立即返回。  
  
 在第二个示例中，包含应用程序定义的类的消息将 `Order` 发送到队列，然后从队列中扫视。  
  
 [!code-cpp[MessageQueue.Peek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <threadsafe>方法不是线程安全的。</threadsafe>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Peek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示等待队列包含消息所用的最长时间。</param>
        <summary>返回但不移除（查看）此 <see cref="T:System.Messaging.MessageQueue" /> 所引用的队列中的第一条消息。 <see cref="M:System.Messaging.MessageQueue.Peek" /> 方法是同步的，因此在有可用消息或发生指定的超时之前，它一直阻止当前线程。</summary>
        <returns>该 <see cref="T:System.Messaging.Message" /> 表示队列中第一条消息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载可查看队列，或在队列中存在消息之前等待指定的时间段。 如果队列中已经存在消息，则该方法立即返回。  
  
 此 <xref:System.Messaging.MessageQueue.Peek%2A> 方法从队列中读取并不删除第一条消息。 因此，重复调用将 <xref:System.Messaging.MessageQueue.Peek%2A> 返回相同的消息，除非队列中有较高优先级的消息到达。 <xref:System.Messaging.MessageQueue.Receive%2A>另一方面，方法会读取和删除队列中的第一条消息。 因此，对的重复调用将 <xref:System.Messaging.MessageQueue.Receive%2A> 返回不同的消息。  
  
 消息队列根据优先级和到达时间对队列中的消息进行排序。 仅当较高优先级的消息超过较高优先级时，才会将其放在旧消息之前。  
  
 如果当前线程在等待消息到达队列时可以被阻塞，则使用 <xref:System.Messaging.MessageQueue.Peek%2A>。 线程将被阻塞一段指定的时间，或在你指示的情况下无限期阻塞 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 。 如果需要应用程序处理继续进行而不等待，则使用异步 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 方法。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例使用超时 <xref:System.Messaging.MessageQueue.Peek%2A> 值为零的方法来检查队列是否为空。  
  
 [!code-cpp[MessageQueue.Peek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <threadsafe>方法不是线程安全的。</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan, cursor As Cursor, action As PeekAction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction -&gt; System.Messaging.Message" Usage="messageQueue.Peek (timeout, cursor, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示等待队列包含消息所用的最长时间。</param>
        <param name="cursor">维持消息队列中特定位置的 <see cref="T:System.Messaging.Cursor" />。</param>
        <param name="action"><see cref="T:System.Messaging.PeekAction" /> 值之一。 指示是查看队列中的当前消息还是下一条消息。</param>
        <summary>使用指定的游标返回但不移除（查看）队列中的当前消息或下一条消息。 <see cref="M:System.Messaging.MessageQueue.Peek" /> 方法是同步的，因此在有可用消息或发生指定的超时之前，它一直阻止当前线程。</summary>
        <returns>一个 <see cref="T:System.Messaging.Message" />，表示队列中的消息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载可查看队列，或在队列中存在消息之前等待指定的时间段。 如果队列中已经存在消息，则该方法立即返回。  
  
 此 <xref:System.Messaging.MessageQueue.Peek%2A> 方法从队列中读取消息，但不从队列中移除消息。 <xref:System.Messaging.MessageQueue.Receive%2A>另一方面，方法会读取和删除队列中的消息。  
  
 如果当前线程在等待消息到达队列时可以被阻塞，则使用 <xref:System.Messaging.MessageQueue.Peek%2A>。 在指定的时间段内阻塞线程，或在指示的情况下无限期阻塞 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 。 如果需要应用程序处理继续进行而不等待，则使用异步 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 方法。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">为 <paramref name="action" /> 参数指定的值不是 <see langword="PeekAction.Current" /> 和 <see langword="PeekAction.Next" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="cursor" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效。 <paramref name="timeout" /> 可能小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <threadsafe>方法不是线程安全的。</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.PeekAction" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>查看匹配给定相关标识符的消息。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">要查看的消息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <summary>查看匹配给定相关标识符的消息，而且在队列中当前不存在具有指定相关标识符的消息时，立即引发异常。</summary>
        <returns>其 <see cref="T:System.Messaging.Message" /> 匹配传入的 <paramref name="correlationId" /> 参数的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法在引用的队列中查找 <xref:System.Messaging.MessageQueue> <xref:System.Messaging.Message.CorrelationId%2A> 与指定参数匹配的消息 `correlationId` 。 如果未找到与参数匹配的消息 `correlationID` ，则会引发异常。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>属性用于将发送到队列的消息绑定到关联的响应、报告或确认消息。  
  
 另外两种方法允许您查看队列中的消息。 <xref:System.Messaging.MessageQueue.Peek%2A>方法返回队列中的第一条消息，该 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 方法用于通过指定消息的唯一标识符来检索消息。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例在队列中发送和接收包含订单的消息。 当原始消息到达或从队列中检索时，它专门请求肯定确认。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">未能找到具有指定 <paramref name="correlationId" /> 的消息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">要查看的消息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</param>
        <summary>查看匹配给定相关标识符的消息，并且一直等到队列中出现具有指定相关标识符的消息或超时过期时。</summary>
        <returns>其 <see cref="T:System.Messaging.Message" /> 匹配传入的 <paramref name="correlationId" /> 参数的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法在引用的队列中查找 <xref:System.Messaging.MessageQueue> <xref:System.Messaging.Message.CorrelationId%2A> 与指定参数匹配的消息 `correlationId` 。 如果未找到与参数匹配的消息 `correlationID` ，并且在参数指定的时间段内，队列中没有新消息到达 `timeout` ，则会引发异常。  
  
 `timeout`参数未指定此方法的总运行时间。 相反，它指定等待新消息到达队列的时间。 每当新消息到达时，此方法将检查 <xref:System.Messaging.Message.CorrelationId%2A> 新消息的，以查看它是否与参数匹配 `correlationId` 。 否则，此方法将启动超时期限并等待另一个新消息到达。 因此，如果新消息在超时期限内继续到达，则此方法可能会无限期地继续运行，直到超时期限过期，无需收到任何新消息，或直到到达其 <xref:System.Messaging.Message.CorrelationId%2A> 与参数匹配的消息 `correlationId` 。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>属性用于将发送到队列的消息绑定到关联的响应、报告或确认消息。  
  
 另外两种方法允许您查看队列中的消息。 <xref:System.Messaging.MessageQueue.Peek%2A>方法返回队列中的第一条消息，该 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 方法用于通过指定消息的唯一标识符来检索消息。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29> 的用法。  
  
 [!code-cpp[MessageQueue2#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.InvalidOperationException">具有指定 <paramref name="correlationId" /> 的消息不在队列中，而且在超时过期之前没有到达。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">消息在超时过期前没有到达。  
  
 - 或 -  
  
 访问“消息队列”方法时出错。</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回具有指定消息标识符的消息的副本，但不从队列中移除消息。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">要查看的消息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <summary>查看其消息标识符匹配 <paramref name="id" /> 参数的消息。</summary>
        <returns><see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.Id" /> 属性匹配 <paramref name="id" /> 参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 读取，而不从队列中移除，即具有已知消息标识符的消息。 消息标识符在消息队列企业中是唯一的，因此队列中最多只能有一条消息与给定 `id` 参数匹配。 如果队列当前不包含消息，此重载将引发异常。  
  
 另外两种方法允许您查看队列中的消息： <xref:System.Messaging.MessageQueue.Peek%2A> 和 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 。 <xref:System.Messaging.MessageQueue.Peek%2A>方法返回队列中的第一条消息; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 返回作为消息发送到队列的结果而创建的确认、报告或由应用程序生成的响应消息。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 的用法。  
  
 [!code-cpp[MessageQueue2#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">不存在具有指定 <paramref name="id" /> 的消息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">要查看的消息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</param>
        <summary>查看其消息标识符匹配 <paramref name="id" /> 参数的消息。 一直等到队列中出现该消息或发生超时。</summary>
        <returns><see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.Id" /> 属性匹配 <paramref name="id" /> 参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 读取，而不从队列中移除，即具有已知消息标识符的消息。 消息标识符在消息队列企业中是唯一的，因此队列中最多只能有一条消息与给定 `id` 参数匹配。 如果队列当前不包含该消息，并且在发生超时之前没有新消息到达，此重载将引发异常。  
  
 `timeout`参数未指定此方法的总运行时间。 相反，它指定等待新消息到达队列的时间。 每当新消息到达时，此方法将检查 <xref:System.Messaging.Message.Id%2A> 新消息的，以查看它是否与参数匹配 `id` 。 否则，此方法将启动超时期限并等待另一个新消息到达。 因此，如果新消息在超时期限内继续到达，则此方法可能会无限期地继续运行，直到超时期限过期，无需收到任何新消息，或直到到达其 <xref:System.Messaging.Message.Id%2A> 与参数匹配的消息 `id` 。  
  
 另外两种方法允许您查看队列中的消息： <xref:System.Messaging.MessageQueue.Peek%2A> 和 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 。 <xref:System.Messaging.MessageQueue.Peek%2A>方法返回队列中的第一条消息; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 返回作为消息发送到队列的结果而创建的确认、报告或由应用程序生成的响应消息。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29> 的用法。  
  
 [!code-cpp[MessageQueue2#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.InvalidOperationException">队列中不存在具有指定 <paramref name="id" /> 的消息，并且在 <paramref name="timeout" /> 参数指定的时间段过期之前该消息仍未到达。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在 MSMQ 3.0 中引入。 查看队列中特定的消息。 消息可通过查询标识符来指定，也可以通过其相对于队首或队尾的位置来指定。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="lookupId">要查看的消息的 <see cref="P:System.Messaging.Message.LookupId" />。</param>
        <summary>在 MSMQ 3.0 中引入。 从非事务性队列中查看与给定查找标识符匹配的消息。</summary>
        <returns><see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.LookupId" /> 属性匹配传入的 <paramref name="lookupId" /> 参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可以读取具有已知查找标识符的消息，而无需将其从队列中删除。 如果消息不在队列中，此方法会立即引发异常。  
  
 <xref:System.Messaging.Message.LookupId%2A>消息的属性在消息所在的队列中是唯一的，因此队列中最多存在一个与给定参数匹配的消息 `lookupId` 。  
  
 若要读取具有指定查找标识符的消息并将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> 方法。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">未安装 MSMQ 3.0。</exception>
        <exception cref="T:System.InvalidOperationException">未能找到具有指定 <paramref name="lookupId" /> 的消息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (action As MessageLookupAction, lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(System::Messaging::MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : System.Messaging.MessageLookupAction * int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId (action, lookupId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="lookupId" Type="System.Int64" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="action">一个 <see cref="T:System.Messaging.MessageLookupAction" /> 值，指定读取队列中消息的方式。 指定以下值之一： 
 <see langword="MessageLookupAction.Current" />：查看由 <paramref name="lookupId" /> 指定的消息。  
  
 <see langword="MessageLookupAction.Next" />：查看由 <paramref name="lookupId" /> 指定的消息的下一条消息。  
  
 <see langword="MessageLookupAction.Previous" />：查看由 <paramref name="lookupId" /> 指定的消息的前一条消息。  
  
 <see langword="MessageLookupAction.First" />：查看队列中的第一条消息。 <paramref name="lookupId" /> 参数必须设置为 0。  
  
 <see langword="MessageLookupAction.Last" />：查看队列中的最后一条消息。 <paramref name="lookupId" /> 参数必须设置为 0。</param>
        <param name="lookupId">要查看的消息的 <see cref="P:System.Messaging.Message.LookupId" /> 或者为 0。 访问队列中的第一条和最后一条消息时使用 0。</param>
        <summary>在 MSMQ 3.0 中引入。 查看队列中特定的消息。 消息可通过查询标识符来指定，也可以通过其相对于队首或队尾的位置来指定。</summary>
        <returns>由传入的 <paramref name="action" /> 和 <paramref name="lookupId" /> 参数指定的 <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可以读取具有已知查找标识符的消息，而无需将其从队列中删除。 如果消息不在队列中，此方法会立即引发异常。  
  
 <xref:System.Messaging.Message.LookupId%2A>消息的属性在消息所在的队列中是唯一的，因此队列中最多存在一个与给定参数匹配的消息 `lookupId` 。  
  
 若要读取具有指定标识符的消息并将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> 方法。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">未安装 MSMQ 3.0。</exception>
        <exception cref="T:System.InvalidOperationException">未能找到具有指定 <paramref name="lookupId" /> 的消息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="action" /> 参数不是 <see cref="T:System.Messaging.MessageLookupAction" /> 成员之一。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PeekCompleted As PeekCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::PeekCompletedEventHandler ^ PeekCompleted;" />
      <MemberSignature Language="F#" Value="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " Usage="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_PeekCompleted")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_PeekCompleted")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在消息未从队列移除的情况下读取该消息时发生。 这是异步操作 <see cref="M:System.Messaging.MessageQueue.BeginPeek" /> 的结果。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 当队列中有消息时，将在异步处理过程中用于引发 <xref:System.Messaging.MessageQueue.PeekCompleted> 事件。  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 用于完成通过调用启动的操作 <xref:System.Messaging.MessageQueue.BeginPeek%2A> ，并在引发事件时查看消息 <xref:System.Messaging.MessageQueue.PeekCompleted> 。  
  
 创建 <xref:System.Messaging.PeekCompletedEventHandler> 委托时，需要标识将处理该事件的方法。 若要将事件与事件处理程序关联，请将该委托的一个实例添加到事件中。 除非移除了该委托，否则每当发生该事件时就会调用事件处理程序。 有关事件处理程序委托的详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例创建一个名为的事件处理程序 `MyPeekCompleted` ，将其附加到 <xref:System.Messaging.MessageQueue.PeekCompleted> 事件处理程序委托，并调用 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 以对位于路径 ".\myQueue" 的队列启动异步查看操作。 <xref:System.Messaging.MessageQueue.PeekCompleted>引发事件时，该示例将扫视消息，并将其正文写入屏幕。 然后，该示例 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 再次调用以启动新的异步查看操作  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberSignature Language="VB.NET" Value="Public Sub Purge ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Purge();" />
      <MemberSignature Language="F#" Value="member this.Purge : unit -&gt; unit" Usage="messageQueue.Purge " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>删除队列中包含的所有消息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 清除队列会导致消息队列设置队列修改标志，这将影响 <xref:System.Messaging.MessageQueue.LastModifyTime%2A> 属性。 从队列中清除的消息丢失;它们不会发送到死信队列或日记队列。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.Purge%2A> 的用法。  
  
 [!code-cpp[MessageQueue2#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="M:System.Messaging.MessageQueue.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberSignature Language="VB.NET" Value="Public Property QueueName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ QueueName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.QueueName : string with get, set" Usage="System.Messaging.MessageQueue.QueueName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_QueueName")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_QueueName")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置标识队列的友好名称。</summary>
        <value>名称，该名称标识由此 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列。 该值不能为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以将与结合 <xref:System.Messaging.MessageQueue.QueueName%2A> 使用 <xref:System.Messaging.MessageQueue.MachineName%2A> 来创建队列的友好 <xref:System.Messaging.MessageQueue.Path%2A> 名称。 属性的友好名称变体的语法 <xref:System.Messaging.MessageQueue.Path%2A> 取决于队列的类型，如下表所示。  
  
|队列类型|语法|  
|----------------|------------|  
|公用队列|`MachineName`\\`QueueName`|  
|专用队列|`MachineName`\\`Private$`\\`QueueName`|  
|日志队列|`MachineName`\\`QueueName`\\`Journal$`|  
  
 使用 "." 表示本地计算机。  
  
 更改 <xref:System.Messaging.MessageQueue.QueueName%2A> 属性将影响 <xref:System.Messaging.MessageQueue.Path%2A> 属性。 如果在 <xref:System.Messaging.MessageQueue.QueueName%2A> 未设置属性的情况下设置 <xref:System.Messaging.MessageQueue.MachineName%2A> ， <xref:System.Messaging.MessageQueue.Path%2A> 属性将变为。 \\ `QueueName` 否则，将 <xref:System.Messaging.MessageQueue.Path%2A> 变为 `MachineName` \\ `QueueName` 。  
  
 下表显示了此属性在各种工作组模式下是否可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|是|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 下面的代码示例获取并设置消息队列属性的值 <xref:System.Messaging.MessageQueue.QueueName%2A> 。  
  
 [!code-csharp[MessageQueue#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">队列名称为 <see langword="null" />。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ReadHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadHandle : nativeint" Usage="System.Messaging.MessageQueue.ReadHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_ReadHandle")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_ReadHandle")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于从消息队列读取消息的本机句柄。</summary>
        <value>用于查看和接收来自队列的消息的本机队列对象的句柄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为 <xref:System.Messaging.MessageQueue.ReadHandle%2A> 消息队列对象提供本机 Windows 句柄，该句柄用于扫视和接收来自队列的消息。 如果更改队列的路径，将关闭句柄，并使用新值重新打开。  
  
 下表显示了此属性在各种工作组模式下是否可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>方法不是线程安全的。</threadsafe>
        <summary>接收队列中的第一条消息，但不将它从队列中移除。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive();" />
      <MemberSignature Language="F#" Value="member this.Receive : unit -&gt; System.Messaging.Message" Usage="messageQueue.Receive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>接收 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列中可用的第一条消息。 此调用是同步的，在有可用消息前，它将一直阻止当前线程的执行。</summary>
        <returns><see cref="T:System.Messaging.Message" />，它引用队列中可用的第一条消息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载接收队列中的消息，或等待队列中有消息。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法允许同步读取消息，从而将其从队列中删除。 对的后续调用 <xref:System.Messaging.MessageQueue.Receive%2A> 将返回队列中后面的消息或新的优先级较高的消息。  
  
 若要读取队列中的第一条消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.Peek%2A> 方法。 <xref:System.Messaging.MessageQueue.Peek%2A>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>如果当前线程在等待消息到达队列时可以被阻塞，则使用对的调用。 由于此方法的重载 <xref:System.Messaging.MessageQueue.Receive%2A> 指定一个无限超时，因此应用程序可能会无限期等待。 如果应用程序处理应继续而不等待消息，请考虑使用异步方法 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例接收队列中的消息，并将有关该消息的信息输出到屏幕。  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</param>
        <summary>接收 <see cref="T:System.Messaging.MessageQueue" /> 引用的事务性队列中可用的第一条消息。 此调用是同步的，在有可用消息前，它将一直阻止当前线程的执行。</summary>
        <returns><see cref="T:System.Messaging.Message" />，它引用队列中可用的第一条消息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载可以通过由参数定义的内部事务上下文接收来自事务性队列的消息 `transaction` ，或等待队列中有消息。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法允许同步读取消息，从而将其从队列中删除。 对的后续调用 <xref:System.Messaging.MessageQueue.Receive%2A> 将返回队列中后面的消息。  
  
 由于此方法是在事务队列中调用的，因此，如果事务中止，接收到的消息将返回到队列。 在提交事务之前，不会从队列中永久删除该消息。  
  
 若要读取队列中的第一条消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.Peek%2A> 方法。 <xref:System.Messaging.MessageQueue.Peek%2A>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。 没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.Peek%2A> 。 由于不会 <xref:System.Messaging.MessageQueue.Peek%2A> 删除队列中的任何消息，因此不会通过调用来回滚任何内容 <xref:System.Messaging.MessageQueueTransaction.Abort%2A> 。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>如果当前线程在等待消息到达队列时可以被阻塞，则使用对的调用。 由于此方法的重载 <xref:System.Messaging.MessageQueue.Receive%2A> 指定一个无限超时，因此应用程序可能会无限期等待。 如果应用程序处理应继续而不等待消息，请考虑使用异步方法 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例连接到本地计算机上的事务队列，并将消息发送到队列。 然后，它将接收包含订单的消息。 如果遇到非事务性队列，它将引发并引发异常并回滚事务。  
  
 [!code-cpp[MessageQueue.Receive_transaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_transaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive_transaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。  
  
 - 或 -  
  
 该队列为非事务性队列。</exception>
        <threadsafe>方法不是线程安全的。</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文的类型。</param>
        <summary>接收 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列中可用的第一条消息。 此调用是同步的，在有可用消息前，它将一直阻止当前线程的执行。</summary>
        <returns><see cref="T:System.Messaging.Message" />，它引用队列中可用的第一条消息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载通过由参数定义的事务上下文从队列中接收消息 `transactionType` ，或等待队列中有消息。  
  
 `Automatic` `transactionType` 如果已存在附加到要用于接收消息的线程的外部事务上下文，请为参数指定。 指定 `Single` 是否要以单个内部事务的形式接收消息。 您可以指定 `None` 是否要在事务上下文之外接收来自事务性队列的消息。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法允许同步读取消息，从而将其从队列中删除。 对的后续调用 <xref:System.Messaging.MessageQueue.Receive%2A> 将返回队列中后面的消息。  
  
 如果调用此方法来接收来自事务性队列的消息，则在事务中止时，收到的消息将返回到队列。 在提交事务之前，不会从队列中永久删除该消息。  
  
 若要读取队列中的第一条消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.Peek%2A> 方法。 <xref:System.Messaging.MessageQueue.Peek%2A>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。 没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.Peek%2A> 。 由于不会 <xref:System.Messaging.MessageQueue.Peek%2A> 删除队列中的任何消息，因此不会通过调用来回滚任何内容 <xref:System.Messaging.MessageQueueTransaction.Abort%2A> 。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>如果当前线程在等待消息到达队列时可以被阻塞，则使用对的调用。 由于此方法的重载 <xref:System.Messaging.MessageQueue.Receive%2A> 指定一个无限超时，因此应用程序可能会无限期等待。 如果应用程序处理应继续而不等待消息，请考虑使用异步方法 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</exception>
        <threadsafe>方法不是线程安全的。</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Receive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</param>
        <summary>接收由 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列中的第一条可用消息，并且一直等到队列中有可用消息或超时过期。</summary>
        <returns><see cref="T:System.Messaging.Message" />，它引用队列中可用的第一条消息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载接收消息并在队列中没有消息时在指定的时间段内返回。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法允许同步读取消息，并将其从队列中删除。 对的后续调用 <xref:System.Messaging.MessageQueue.Receive%2A> 将返回队列中后面的消息或新的优先级较高的消息。  
  
 若要读取队列中的第一条消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.Peek%2A> 方法。 <xref:System.Messaging.MessageQueue.Peek%2A>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>如果当前线程在等待消息到达队列时可以被阻塞，则使用对的调用。 如果为参数指定了值，则线程将在给定的时间段内被阻止，或无限期地阻止 <xref:System.Messaging.MessageQueue.InfiniteTimeout> `timeout` 。 如果应用程序处理应在不等待消息的情况下继续运行，请考虑使用异步方法 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例接收队列中的消息，并将有关该消息的信息输出到屏幕。 该示例在等待消息到达队列时，暂停执行最多5秒。  
  
 [!code-cpp[MessageQueue.Receive_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">在超时过期之前消息没有到达队列。  
  
 - 或 -  
  
 访问“消息队列”方法时出错。</exception>
        <threadsafe>方法不是线程安全的。</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, cursor As Cursor) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</param>
        <param name="cursor">维持消息队列中特定位置的 <see cref="T:System.Messaging.Cursor" />。</param>
        <summary>使用指定的游标接收队列中的当前消息。 如果没有可用的消息，此方法将等待，直到有可用的消息或超时到期为止。</summary>
        <returns><see cref="T:System.Messaging.Message" />，它引用队列中可用的第一条消息。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">在超时过期之前消息没有到达队列。  
  
 - 或 -  
  
 访问“消息队列”方法时出错。  
  
 使用此重载接收消息并在队列中没有消息时在指定的时间段内返回。</exception>
        <threadsafe>方法不是线程安全的。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</param>
        <summary>接收由 <see cref="T:System.Messaging.MessageQueue" /> 引用的事务性队列中的第一条可用消息，并且一直等到队列中有可用消息或超时过期。</summary>
        <returns><see cref="T:System.Messaging.Message" />，它引用队列中可用的第一条消息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载，通过由参数定义的内部事务上下文接收来自事务性队列的消息 `transaction` ，并在队列中没有消息时在指定时间段内返回。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法允许同步读取消息，从而将其从队列中删除。 对的后续调用 <xref:System.Messaging.MessageQueue.Receive%2A> 将返回队列中后面的消息。  
  
 由于此方法是在事务队列中调用的，因此，如果事务中止，接收到的消息将返回到队列。 在提交事务之前，不会从队列中永久删除该消息。  
  
 若要读取队列中的第一条消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.Peek%2A> 方法。 <xref:System.Messaging.MessageQueue.Peek%2A>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。 没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.Peek%2A> 。 由于不会 <xref:System.Messaging.MessageQueue.Peek%2A> 删除队列中的任何消息，因此不会通过调用来回滚任何内容 <xref:System.Messaging.MessageQueueTransaction.Abort%2A> 。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>如果当前线程在等待消息到达队列时可以被阻塞，则使用对的调用。 如果为参数指定了值，则线程将在给定的时间段内被阻止，或无限期地阻止 <xref:System.Messaging.MessageQueue.InfiniteTimeout> `timeout` 。 如果应用程序处理应在不等待消息的情况下继续运行，请考虑使用异步方法 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例演示如何使用此方法。  
  
 [!code-cpp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">在超时过期之前消息没有到达队列。  
  
 - 或 -  
  
 该队列为非事务性队列。  
  
 - 或 -  
  
 访问“消息队列”方法时出错。</exception>
        <threadsafe>方法不是线程安全的。</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</param>
        <param name="transactionType"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文的类型。</param>
        <summary>接收 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列中可用的第一条消息。 此调用是同步的，并且一直等到队列中有可用的消息或超时到期。</summary>
        <returns><see cref="T:System.Messaging.Message" />，它引用队列中可用的第一条消息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载通过由参数定义的事务上下文从队列中接收消息 `transactionType` ，并在队列中没有消息时返回指定时间段。  
  
 `Automatic` `transactionType` 如果已存在附加到要用于接收消息的线程的外部事务上下文，请为参数指定。 指定 `Single` 是否要以单个内部事务的形式接收消息。 您可以指定 `None` 是否要在事务上下文之外接收来自事务性队列的消息。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法允许同步读取消息，从而将其从队列中删除。 对的后续调用 <xref:System.Messaging.MessageQueue.Receive%2A> 将返回队列中后面的消息。  
  
 如果调用此方法来接收来自事务性队列的消息，则在事务中止时，收到的消息将返回到队列。 在提交事务之前，不会从队列中永久删除该消息。  
  
 若要读取队列中的第一条消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.Peek%2A> 方法。 <xref:System.Messaging.MessageQueue.Peek%2A>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。 没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.Peek%2A> 。 由于不会 <xref:System.Messaging.MessageQueue.Peek%2A> 删除队列中的任何消息，因此不会通过调用来回滚任何内容 <xref:System.Messaging.MessageQueueTransaction.Abort%2A> 。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>如果当前线程在等待消息到达队列时可以被阻塞，则使用对的调用。 如果为参数指定了值，则线程将在给定的时间段内被阻止，或无限期地阻止 <xref:System.Messaging.MessageQueue.InfiniteTimeout> `timeout` 。 如果应用程序处理应在不等待消息的情况下继续运行，请考虑使用异步方法 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例演示如何使用此方法。  
  
 [!code-cpp[MessageQueue2#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">在超时过期之前消息没有到达队列。  
  
 - 或 -  
  
 访问“消息队列”方法时出错。</exception>
        <threadsafe>方法不是线程安全的。</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, cursor As Cursor, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</param>
        <param name="cursor">维持消息队列中特定位置的 <see cref="T:System.Messaging.Cursor" />。</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</param>
        <summary>使用指定的游标接收队列中的当前消息。 如果没有可用的消息，此方法将等待，直到有可用的消息或超时到期为止。</summary>
        <returns>一个 <see cref="T:System.Messaging.Message" />，它引用队列中的一条消息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载，通过由参数定义的内部事务上下文接收来自事务性队列的消息 `transaction` ，并在队列中没有消息时在指定时间段内返回。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法允许同步读取消息，从而将其从队列中删除。 后续调用 <xref:System.Messaging.MessageQueue.Receive%2A> 会返回队列中后面的消息。  
  
 由于此方法是在事务队列中调用的，因此，如果事务中止，接收到的消息将返回到队列。 在提交事务之前，不会从队列中永久删除该消息。  
  
 若要在队列中读取消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.Peek%2A> 方法。 没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.Peek%2A> 。 由于不 <xref:System.Messaging.MessageQueue.Peek%2A> 会删除队列中的任何消息，因此没有任何内容可以通过调用回滚 <xref:System.Messaging.MessageQueueTransaction.Abort%2A> 。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>如果当前线程在等待消息到达队列时可以被阻塞，则使用对的调用。 线程在给定的时间段内被阻止，或在指定了参数的值的情况下无限期阻止 <xref:System.Messaging.MessageQueue.InfiniteTimeout> `timeout` 。 如果应用程序处理应在不等待消息的情况下继续运行，请考虑使用异步方法 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="cursor" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="transaction" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效。 <paramref name="timeout" /> 可能小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">在超时过期之前消息没有到达队列。  
  
 - 或 -  
  
 该队列为非事务性队列。  
  
 - 或 -  
  
 访问“消息队列”方法时出错。</exception>
        <threadsafe>方法不是线程安全的。</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, cursor As Cursor, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</param>
        <param name="cursor">维持消息队列中特定位置的 <see cref="T:System.Messaging.Cursor" />。</param>
        <param name="transactionType"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文类型。</param>
        <summary>使用指定的游标接收队列中的当前消息。 如果没有可用的消息，此方法将等待，直到有可用的消息或超时到期为止。</summary>
        <returns>一个 <see cref="T:System.Messaging.Message" />，它引用队列中的一条消息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载通过由参数定义的事务上下文从队列中接收消息 `transactionType` ，并在队列中没有消息时返回指定时间段。  
  
 `Automatic` `transactionType` 如果已存在附加到要用于接收消息的线程的外部事务上下文，请为参数指定。 指定 `Single` 是否要以单个内部事务的形式接收消息。 您可以指定 `None` 是否要在事务上下文之外接收来自事务性队列的消息。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法允许同步读取消息，从而将其从队列中删除。 后续调用 <xref:System.Messaging.MessageQueue.Receive%2A> 会返回队列中后面的消息。  
  
 如果调用此方法来接收来自事务性队列的消息，则在事务中止的情况下，接收到的消息将返回到队列。 在提交事务之前，不会从队列中永久删除该消息。  
  
 若要在队列中读取消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.Peek%2A> 方法。 没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.Peek%2A> 。 由于不 <xref:System.Messaging.MessageQueue.Peek%2A> 会删除队列中的任何消息，因此没有任何内容可以通过调用回滚 <xref:System.Messaging.MessageQueueTransaction.Abort%2A> 。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>如果当前线程在等待消息到达队列时可以被阻塞，则使用对的调用。 线程在给定的时间段内被阻止，或在指定了参数的值的情况下无限期阻止 <xref:System.Messaging.MessageQueue.InfiniteTimeout> `timeout` 。 如果应用程序处理应在不等待消息的情况下继续运行，请考虑使用异步方法 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="cursor" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效。 <paramref name="timeout" /> 可能小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">在超时过期之前消息没有到达队列。  
  
 - 或 -  
  
 访问“消息队列”方法时出错。</exception>
        <threadsafe>方法不是线程安全的。</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接收匹配给定相关标识符的消息。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">要接收的消息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <summary>从非事务性队列中接收与给定的相关标识符匹配的消息，而且在队列中当前不存在具有指定相关标识符的消息时立即引发异常。</summary>
        <returns>其 <see cref="T:System.Messaging.Message" /> 匹配传入的 <paramref name="correlationId" /> 参数的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法在引用的非事务性队列中查找 <xref:System.Messaging.MessageQueue> <xref:System.Messaging.Message.CorrelationId%2A> 与指定参数匹配的消息 `correlationId` 。 如果未找到与参数匹配的消息 `correlationID` ，则会引发异常。 否则，将从队列中删除该消息并将其返回给应用程序。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>属性用于将发送到队列的消息绑定到关联的响应、报告或确认消息。  
  
 另外两种方法可用于从队列接收消息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法返回队列中的第一条消息， <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 方法通过指定消息的唯一标识符来检索消息。  
  
 若要读取具有指定相关标识符的消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 方法。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例在队列中发送和接收包含订单的消息。 当原始消息到达或从队列中检索时，它专门请求肯定确认。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">未能找到具有指定 <paramref name="correlationId" /> 的消息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">要接收的消息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</param>
        <summary>从事务性队列中接收与给定的相关标识符匹配的消息，而且在队列中当前不存在具有指定相关标识符的消息时立即引发异常。</summary>
        <returns>其 <see cref="T:System.Messaging.Message" /> 匹配传入的 <paramref name="correlationId" /> 参数的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法在引用的事务性队列中查找 <xref:System.Messaging.MessageQueue> <xref:System.Messaging.Message.CorrelationId%2A> 与指定参数匹配的消息 `correlationId` 。 如果未找到与参数匹配的消息 `correlationID` ，则会引发异常。 否则，将从队列中删除该消息，并使用由参数定义的内部事务上下文将该消息返回到应用程序 `transaction` 。  
  
 由于此方法是在事务队列中调用的，因此，如果事务中止，接收到的消息将返回到队列。 在提交事务之前，不会从队列中永久删除该消息。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>属性用于将发送到队列的消息绑定到关联的响应、报告或确认消息。  
  
 另外两种方法可用于从队列接收消息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法返回队列中的第一条消息，该 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 方法用于通过指定消息的唯一标识符来检索消息。  
  
 若要读取具有指定相关标识符的消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 方法。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。 没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 。 因为不 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 会删除队列中的任何消息，所以如果事务中止，则不会回滚任何内容。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29> 的用法。  
  
 [!code-cpp[MessageQueue2#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="transaction" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">未能找到具有指定 <paramref name="correlationId" /> 的消息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">该队列为非事务性队列。  
  
 - 或 -  
  
 访问“消息队列”方法时出错。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">要接收的消息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="transactionType"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文的类型。</param>
        <summary>接收匹配给定相关标识符的消息，而且在队列中当前不存在具有指定相关标识符的消息时立即引发异常。</summary>
        <returns>其 <see cref="T:System.Messaging.Message" /> 匹配传入的 <paramref name="correlationId" /> 参数的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法在引用的队列中查找 <xref:System.Messaging.MessageQueue> <xref:System.Messaging.Message.CorrelationId%2A> 与指定参数匹配的消息 `correlationId` 。 如果未找到与参数匹配的消息 `correlationID` ，则会引发异常。 否则，将从队列中删除该消息，并使用由参数定义的事务上下文将该消息返回到应用程序 `transactionType` 。  
  
 `Automatic` `transactionType` 如果已存在附加到要用于接收消息的线程的外部事务上下文，请为参数指定。 指定 `Single` 是否要以单个内部事务的形式接收消息。 您可以指定 `None` 是否要在事务上下文之外接收来自事务性队列的消息。  
  
 如果调用此方法来接收来自事务性队列的消息，则在事务中止时，收到的消息将返回到队列。 在提交事务之前，不会从队列中永久删除该消息。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>属性用于将发送到队列的消息绑定到关联的响应、报告或确认消息。  
  
 另外两种方法可用于从队列接收消息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法返回队列中的第一条消息，该 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 方法用于通过指定消息的唯一标识符来检索消息。  
  
 若要读取具有指定相关标识符的消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 方法。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。 没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 。 因为不 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 会删除队列中的任何消息，所以如果事务中止，则不会回滚任何内容。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">未能找到具有指定 <paramref name="correlationId" /> 的消息。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">要接收的消息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</param>
        <summary>从非事务性队列中接收与给定的相关标识符匹配的消息，并且一直等到队列中出现具有指定相关标识符的消息或者超时过期。</summary>
        <returns>其 <see cref="T:System.Messaging.Message" /> 匹配传入的 <paramref name="correlationId" /> 参数的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法在引用的非事务性队列中查找 <xref:System.Messaging.MessageQueue> <xref:System.Messaging.Message.CorrelationId%2A> 与指定参数匹配的消息 `correlationId` 。 如果具有参数指定的相关标识符的消息 `correlationId` 在队列中，则此方法立即返回。 否则，该方法将在给定的时间段内等待新消息到达。 如果新消息在超时过期之前未到达，则会引发异常。  
  
 `timeout`参数未指定此方法的总运行时间。 相反，它指定等待新消息到达队列的时间。 每当新消息到达时，此方法将检查 <xref:System.Messaging.Message.CorrelationId%2A> 新消息的，以查看它是否与参数匹配 `correlationId` 。 否则，此方法将启动超时期限并等待另一个新消息到达。 因此，如果新消息在超时期限内继续到达，则此方法可能会无限期地继续运行，直到超时期限过期，无需收到任何新消息，或直到到达其 <xref:System.Messaging.Message.CorrelationId%2A> 与参数匹配的消息 `correlationId` 。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>属性用于将发送到队列的消息绑定到关联的响应、报告或确认消息。  
  
 另外两种方法可用于从队列接收消息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法返回队列中的第一条消息，该 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 方法用于通过指定消息的唯一标识符来检索消息。  
  
 若要读取具有指定相关标识符的消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 方法。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29> 的用法。  
  
 [!code-cpp[MessageQueue2#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">具有指定 <paramref name="correlationId" /> 的消息不在队列中，而且在超时过期之前没有到达。  
  
- 或 - 
访问“消息队列”方法时出错。</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">要接收的消息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</param>
        <summary>从事务性队列中接收与给定的相关标识符匹配的消息，并且一直等到队列中出现具有指定相关标识符的消息或者超时过期。</summary>
        <returns>其 <see cref="T:System.Messaging.Message" /> 匹配传入的 <paramref name="correlationId" /> 参数的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法在引用的事务性队列中查找 <xref:System.Messaging.MessageQueue> <xref:System.Messaging.Message.CorrelationId%2A> 与指定参数匹配的消息 `correlationId` 。 如果使用参数定义的相关标识符的消息 `correlationId` 在队列中，则此方法将立即返回 `transaction` 。 否则，该方法将在给定的时间段内等待新消息到达。 如果新消息在超时过期之前未到达，则会引发异常。  
  
 `timeout`参数未指定此方法的总运行时间。 相反，它指定等待新消息到达队列的时间。 每当新消息到达时，此方法将检查 <xref:System.Messaging.Message.CorrelationId%2A> 新消息的，以查看它是否与参数匹配 `correlationId` 。 否则，此方法将启动超时期限并等待另一个新消息到达。 因此，如果新消息在超时期限内继续到达，则此方法可能会无限期地继续运行，直到超时期限过期，无需收到任何新消息，或直到到达其 <xref:System.Messaging.Message.CorrelationId%2A> 与参数匹配的消息 `correlationId` 。  
  
 由于此方法是在事务队列中调用的，因此，如果事务中止，接收到的消息将返回到队列。 在提交事务之前，不会从队列中永久删除该消息。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>属性用于将发送到队列的消息绑定到关联的响应、报告或确认消息。  
  
 另外两种方法可用于从队列接收消息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法返回队列中的第一条消息，该 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 方法用于通过指定消息的唯一标识符来检索消息。  
  
 若要读取具有指定相关标识符的消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 方法。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。 没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 。 因为不 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 会删除队列中的任何消息，所以如果事务中止，则不会回滚任何内容。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29> 的用法。  
  
 [!code-cpp[MessageQueue2#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="transaction" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">具有指定 <paramref name="correlationId" /> 的消息不在队列中，而且在超时过期之前没有到达。  
  
- 或 - 
该队列为非事务性队列。  
  
- 或 - 
访问“消息队列”方法时出错。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">要接收的消息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</param>
        <param name="transactionType"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文的类型。</param>
        <summary>接收与给定的相关标识符匹配的消息，并且一直等到队列中出现具有指定相关标识符的消息或超时过期。</summary>
        <returns>其 <see cref="T:System.Messaging.Message" /> 匹配传入的 <paramref name="correlationId" /> 参数的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法在引用的队列中查找 <xref:System.Messaging.MessageQueue> <xref:System.Messaging.Message.CorrelationId%2A> 与指定参数匹配的消息 `correlationId` 。 如果使用参数定义的相关标识符的消息 `correlationId` 在队列中，则此方法立即返回 `transactionType` 。 否则，该方法将在给定的时间段内等待新消息到达。 如果新消息在超时过期之前未到达，则会引发异常。  
  
 `timeout`参数未指定此方法的总运行时间。 相反，它指定等待新消息到达队列的时间。 每当新消息到达时，此方法将检查 <xref:System.Messaging.Message.CorrelationId%2A> 新消息的，以查看它是否与参数匹配 `correlationId` 。 否则，此方法将启动超时期限并等待另一个新消息到达。 因此，如果新消息在超时期限内继续到达，则此方法可能会无限期地继续运行，直到超时期限过期，无需收到任何新消息，或直到到达其 <xref:System.Messaging.Message.CorrelationId%2A> 与参数匹配的消息 `correlationId` 。 `Automatic` `transactionType` 如果已存在附加到要用于接收消息的线程的外部事务上下文，请为参数指定。 指定 `Single` 是否要以单个内部事务的形式接收消息。 您可以指定 `None` 是否要在事务上下文之外接收来自事务性队列的消息。  
  
 如果调用此方法来接收来自事务性队列的消息，则在事务中止时，收到的消息将返回到队列。 在提交事务之前，不会从队列中永久删除该消息。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>属性用于将发送到队列的消息绑定到关联的响应、报告或确认消息。  
  
 另外两种方法可用于从队列接收消息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法返回队列中的第一条消息，该 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 方法用于通过指定消息的唯一标识符来检索消息。  
  
 若要读取具有指定相关标识符的消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 方法。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。 没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 。 因为不 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 会删除队列中的任何消息，所以如果事务中止，则不会回滚任何内容。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">未能找到具有指定 <paramref name="correlationId" /> 的消息。</exception>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">具有指定 <paramref name="correlationId" /> 的消息不在队列中，而且在超时过期之前没有到达。  
  
- 或 - 
访问“消息队列”方法时出错。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接收匹配给定标识符的消息，并将其从队列中移除。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">要接收的消息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <summary>从非事务性队列中接收与给定的标识符匹配的消息，而且在队列中当前不存在具有指定标识符的消息时立即引发异常。</summary>
        <returns><see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.Id" /> 属性匹配传入的 <paramref name="id" /> 参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可以读取具有已知标识符的消息，并将其从队列中删除。 如果消息不在队列中，此方法会立即引发异常。  
  
 <xref:System.Messaging.Message.Id%2A>消息的属性在消息队列企业中是唯一的，因此队列中最多只有一个与给定参数匹配的消息 `id` 。  
  
 另外两种方法可用于从队列接收消息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法返回队列中的第一条消息， <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 方法用于检索确认、报告或由应用程序生成的响应消息，该消息是作为发送到队列的消息的结果创建的。  
  
 若要读取具有指定标识符的消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 方法。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 的用法。  
  
 [!code-cpp[MessageQueue2#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">未能找到具有指定 <paramref name="id" /> 的消息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">要接收的消息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</param>
        <summary>从事务性队列中接收与给定的标识符匹配的消息，而且在队列中当前不存在具有指定标识符的消息时立即引发异常。</summary>
        <returns><see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.Id" /> 属性匹配传入的 <paramref name="id" /> 参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可以读取具有已知标识符的消息，并使用由参数定义的内部事务上下文从队列中删除该消息 `transaction` 。 如果消息不在队列中，此方法会立即引发异常  
  
 <xref:System.Messaging.Message.Id%2A>消息的属性在消息队列企业中是唯一的，因此队列中最多只有一个与给定参数匹配的消息 `id` 。  
  
 由于此方法是在事务队列中调用的，因此，如果事务中止，接收到的消息将返回到队列。 在提交事务之前，不会从队列中永久删除该消息。  
  
 另外两种方法可用于从队列接收消息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法返回队列中的第一条消息， <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 方法用于检索确认、报告或由应用程序生成的响应消息，该消息是作为发送到队列的消息的结果创建的。  
  
 若要读取具有指定标识符的消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 方法。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。 没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 。 因为不 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 会删除队列中的任何消息，所以如果事务中止，则不会回滚任何内容。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29> 的用法。  
  
 [!code-cpp[MessageQueue2#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="transaction" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">未能找到具有指定 <paramref name="id" /> 的消息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">该队列为非事务性队列。  
  
 - 或 -  
  
 访问“消息队列”方法时出错。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">要接收的消息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="transactionType"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文的类型。</param>
        <summary>接收与给定的标识符匹配的消息，而且在队列中当前不存在具有指定标识符的消息时立即引发异常。</summary>
        <returns><see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.Id" /> 属性匹配传入的 <paramref name="id" /> 参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可以读取具有已知标识符的消息，并将其从队列中删除。 如果消息不在队列中，此方法会立即引发异常。 否则，将从队列中删除该消息，并使用由参数定义的事务上下文将该消息返回到应用程序 `transactionType` 。  
  
 `Automatic` `transactionType` 如果已存在附加到要用于接收消息的线程的外部事务上下文，请为参数指定。 指定 `Single` 是否要以单个内部事务的形式接收消息。 您可以指定 `None` 是否要在事务上下文之外接收来自事务性队列的消息。  
  
 <xref:System.Messaging.Message.Id%2A>消息的属性在消息队列企业中是唯一的，因此队列中最多只有一个与给定参数匹配的消息 `id` 。 如果具有指定标识符的消息位于与此实例关联的队列中 <xref:System.Messaging.MessageQueue> ，则将找不到该消息。  
  
 如果调用此方法来接收来自事务性队列的消息，则在事务中止时，收到的消息将返回到队列。 在提交事务之前，不会从队列中永久删除该消息。  
  
 另外两种方法可用于从队列接收消息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法返回队列中的第一条消息， <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 方法用于检索确认、报告或由应用程序生成的响应消息，该消息是作为发送到队列的消息的结果创建的。  
  
 若要读取具有指定标识符的消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 方法。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。 没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 。 因为不 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 会删除队列中的任何消息，所以如果事务中止，则不会回滚任何内容。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">未能找到具有指定 <paramref name="id" /> 的消息。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">要接收的消息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</param>
        <summary>从非事务性队列接收与给定的标识符匹配的消息，并且一直等到队列中出现具有指定标识符的消息或超时过期。</summary>
        <returns><see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.Id" /> 属性匹配传入的 <paramref name="id" /> 参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可以读取具有已知标识符的消息，并将其从队列中删除。 如果具有参数指定的标识符的消息在队列中，则此方法立即返回 `id` 。 否则，该方法将在给定的时间段内等待新消息到达。 如果新消息在超时过期之前未到达，则会引发异常。  
  
 `timeout`参数未指定此方法的总运行时间。 相反，它指定等待新消息到达队列的时间。 每当新消息到达时，此方法将检查 <xref:System.Messaging.Message.Id%2A> 新消息的，以查看它是否与参数匹配 `id` 。 否则，此方法将启动超时期限并等待另一个新消息到达。 因此，如果新消息在超时期限内继续到达，则此方法可能会无限期地继续运行，直到超时期限过期，无需收到任何新消息，或直到到达其 <xref:System.Messaging.Message.Id%2A> 与参数匹配的消息 `id` 。  
  
 <xref:System.Messaging.Message.Id%2A>消息的属性在消息队列企业中是唯一的，因此队列中最多只有一个与给定参数匹配的消息 `id` 。  
  
 当当前线程被阻止时，可以使用的此重载，只要 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 新消息在参数指定的超时期限内继续到达队列中即可 `timeout` 。 如果为参数指定了值 <xref:System.Messaging.MessageQueue.InfiniteTimeout> `timeout` ，或者在参数指定的超时期限内新消息仍到达队列，则线程将在至少给定的时间段内被阻止，或无限期地阻止。 `timeout`  
  
 另外两种方法可用于从队列接收消息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法返回队列中的第一条消息， <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 方法用于检索确认、报告或由应用程序生成的响应消息，该消息是作为发送到队列的消息的结果创建的。  
  
 若要读取具有指定标识符的消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 方法。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29> 的用法。  
  
 [!code-cpp[MessageQueue2#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">在时间超时之前，带有指定 <paramref name="id" /> 的消息没有到达队列。  
  
- 或 - 
访问“消息队列”方法时出错。</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">要接收的消息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</param>
        <summary>从事务性队列接收与给定的标识符匹配的消息，并且一直等到队列中出现具有指定标识符的消息或超时过期。</summary>
        <returns><see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.Id" /> 属性匹配传入的 <paramref name="id" /> 参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可以读取具有已知标识符的消息，并使用由参数定义的内部事务上下文从队列中删除该消息 `transaction` 。 如果具有参数指定的标识符的消息在队列中，则此方法立即返回 `id` 。 否则，该方法将在给定的时间段内等待新消息到达。 如果新消息在超时过期之前未到达，则会引发异常。  
  
 `timeout`参数未指定此方法的总运行时间。 相反，它指定等待新消息到达队列的时间。 每当新消息到达时，此方法将检查 <xref:System.Messaging.Message.Id%2A> 新消息的，以查看它是否与参数匹配 `id` 。 否则，此方法将启动超时期限并等待另一个新消息到达。 因此，如果新消息在超时期限内继续到达，则此方法可能会无限期地继续运行，直到超时期限过期，无需收到任何新消息，或直到到达其 <xref:System.Messaging.Message.Id%2A> 与参数匹配的消息 `id` 。  
  
 <xref:System.Messaging.Message.Id%2A>消息的属性在消息队列企业中是唯一的，因此队列中最多只有一个与给定参数匹配的消息 `id` 。  
  
 当当前线程被阻止时，可以使用的此重载，只要 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 新消息在参数指定的超时期限内继续到达队列中即可 `timeout` 。 如果为参数指定了值 <xref:System.Messaging.MessageQueue.InfiniteTimeout> `timeout` ，或者在参数指定的超时期限内新消息继续到达队列，则线程将在至少给定的时间段内被阻止。 `timeout`  
  
 由于此方法是在事务队列中调用的，因此，如果事务中止，接收到的消息将返回到队列。 在提交事务之前，不会从队列中永久删除该消息。  
  
 另外两种方法可用于从队列接收消息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法返回队列中的第一条消息， <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 方法用于检索确认、报告或由应用程序生成的响应消息，该消息是作为发送到队列的消息的结果创建的。  
  
 若要读取具有指定标识符的消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 方法。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非在队列中有较高优先级的消息到达。 没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 。 因为不 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 会删除队列中的任何消息，所以如果事务中止，则不会回滚任何内容。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29> 的用法。  
  
 [!code-cpp[MessageQueue2#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="transaction" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">在时间超时之前，带有指定 <paramref name="id" /> 的消息没有到达队列。  
  
- 或 - 
该队列为非事务性队列。  
  
- 或 - 
访问“消息队列”方法时出错。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">要接收的消息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</param>
        <param name="transactionType"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文的类型。</param>
        <summary>接收与给定的标识符匹配的消息，并且一直等到队列中出现具有指定标识符的消息或超时过期。</summary>
        <returns><see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.Id" /> 属性匹配传入的 <paramref name="id" /> 参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可以读取具有已知标识符的消息，并将其从队列中删除。 如果使用参数指定的标识符的消息 `id` 在队列中，则此方法将立即返回 `transactionType` 。 否则，该方法将在给定的时间段内等待新消息到达。 如果新消息在超时过期之前未到达，则会引发异常。  
  
 `timeout`参数未指定此方法的总运行时间。 相反，它指定等待新消息到达队列的时间。 每当新消息到达时，此方法将检查 <xref:System.Messaging.Message.Id%2A> 新消息的，以查看它是否与参数匹配 `id` 。 否则，此方法将启动超时期限并等待另一个新消息到达。 因此，如果新消息在超时期限内继续到达，则此方法可能会无限期地继续运行，直到超时期限过期，无需收到任何新消息，或直到到达其 <xref:System.Messaging.Message.Id%2A> 与参数匹配的消息 `id` 。  
  
 `Automatic` `transactionType` 如果已存在附加到要用于接收消息的线程的外部事务上下文，请为参数指定。 指定 `Single` 是否要以单个内部事务的形式接收消息。 您可以指定 `None` 是否要在事务上下文之外接收来自事务性队列的消息。  
  
 <xref:System.Messaging.Message.Id%2A>消息的属性在消息队列企业中是唯一的，因此队列中最多只有一个与给定参数匹配的消息 `id` 。 如果具有指定标识符的消息位于与此实例关联的队列中 <xref:System.Messaging.MessageQueue> ，则将找不到该消息。  
  
 当当前线程被阻止时，可以使用的此重载，只要 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 新消息在参数指定的超时期限内继续到达队列中即可 `timeout` 。 如果为参数指定了值 <xref:System.Messaging.MessageQueue.InfiniteTimeout> `timeout` ，或者在参数指定的超时期限内新消息仍到达队列，则线程将在至少给定的时间段内被阻止，或无限期地阻止。 `timeout`  
  
 如果调用此方法来接收来自事务性队列的消息，则在事务中止时，收到的消息将返回到队列。 在提交事务之前，不会从队列中永久删除该消息。  
  
 另外两种方法可用于从队列接收消息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法返回队列中的第一条消息， <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 方法用于检索确认、报告或由应用程序生成的响应消息，该消息是作为发送到队列的消息的结果创建的。  
  
 若要读取具有指定标识符的消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 方法。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法始终返回队列中的第一条消息，因此，对方法的后续调用将返回相同的消息，除非队列中有较高优先级的消息到达。 没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 。 因为不 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 会删除队列中的任何消息，所以如果事务中止，则不会回滚任何内容。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">在时间超时之前，带有指定 <paramref name="id" /> 的消息没有到达队列。  
  
- 或 - 
访问“消息队列”方法时出错。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在 MSMQ 3.0 中引入。 接收队列中特定的消息。 消息可通过查询标识符来指定，也可以通过其相对于队首或队尾的位置来指定。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="lookupId">要接收的消息的 <see cref="P:System.Messaging.Message.LookupId" />。</param>
        <summary>在 MSMQ 3.0 中引入。 从非事务性队列中接收与给定的查找标识符匹配的消息。</summary>
        <returns><see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.LookupId" /> 属性匹配传入的 <paramref name="lookupId" /> 参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可以读取具有已知查找标识符的消息并将其从队列中删除。 如果消息不在队列中，此方法会立即引发异常。  
  
 <xref:System.Messaging.Message.LookupId%2A>消息的属性在消息所在的队列中是唯一的，因此队列中最多存在一个与给定参数匹配的消息 `lookupId` 。  
  
 若要使用指定的查找标识符读取消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 方法。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">未安装 MSMQ 3.0。</exception>
        <exception cref="T:System.InvalidOperationException">未能找到具有指定 <paramref name="lookupId" /> 的消息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="lookupId" Type="System.Int64" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="action">一个 <see cref="T:System.Messaging.MessageLookupAction" /> 值，指定读取队列中消息的方式。 指定以下值之一： 
 <see langword="MessageLookupAction.Current" />：接收由 <paramref name="lookupId" /> 指定的消息，然后将其从队列中移除。  
  
 <see langword="MessageLookupAction.Next" />：接收 <paramref name="lookupId" /> 所指定消息的后一条消息，然后将其从队列中移除。  
  
 <see langword="MessageLookupAction.Previous" />：接收 <paramref name="lookupId" /> 所指定消息的前一条消息，然后将其从队列中移除。  
  
 <see langword="MessageLookupAction.First" />：接收队列中的第一条消息并将它从队列中移除。 <paramref name="lookupId" /> 参数必须设置为 0。  
  
 <see langword="MessageLookupAction.Last" />：接收队列中的最后一条消息并将它从队列中移除。 <paramref name="lookupId" /> 参数必须设置为 0。</param>
        <param name="lookupId">要接收的消息的 <see cref="P:System.Messaging.Message.LookupId" />，或者为 0。 访问队列中的第一条和最后一条消息时使用 0。</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</param>
        <summary>在 MSMQ 3.0 中引入。 从事务性队列中接收特定的消息。 消息可通过查询标识符来指定，也可以通过其相对于队首或队尾的位置来指定。</summary>
        <returns>由传入的 <paramref name="lookupId" /> 和 <paramref name="action" /> 参数指定的 <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可以读取具有已知查找标识符的消息，并使用由参数定义的事务上下文从队列中删除该消息 `transaction` 。 如果消息不在队列中，此方法会立即引发异常。  
  
 <xref:System.Messaging.Message.LookupId%2A>消息的属性在消息所在的队列中是唯一的，因此队列中最多存在一个与给定参数匹配的消息 `lookupId` 。  
  
 由于此方法是在事务队列中调用的，因此，如果事务中止，接收到的消息将返回到队列。 在提交事务之前，不会从队列中永久删除该消息。  
  
 若要读取具有指定标识符的消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 方法。 没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 。 因为不 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 会从队列中删除任何消息，所以如果事务中止，则不会回滚任何内容。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">未安装 MSMQ 3.0。</exception>
        <exception cref="T:System.InvalidOperationException">未能找到具有指定 <paramref name="lookupId" /> 的消息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。  
  
 - 或 -  
  
 该队列为非事务性队列。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="action" /> 参数不是 <see cref="T:System.Messaging.MessageLookupAction" /> 成员之一。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="lookupId" Type="System.Int64" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="action">一个 <see cref="T:System.Messaging.MessageLookupAction" /> 值，指定读取队列中消息的方式。 指定以下值之一： 
 <see langword="MessageLookupAction.Current" />：接收由 <paramref name="lookupId" /> 指定的消息，然后将其从队列中移除。  
  
 <see langword="MessageLookupAction.Next" />：接收 <paramref name="lookupId" /> 所指定消息的后一条消息，然后将其从队列中移除。  
  
 <see langword="MessageLookupAction.Previous" />：接收 <paramref name="lookupId" /> 所指定消息的前一条消息，然后将其从队列中移除。  
  
 <see langword="MessageLookupAction.First" />：接收队列中的第一条消息并将它从队列中移除。 <paramref name="lookupId" /> 参数必须设置为 0。  
  
 <see langword="MessageLookupAction.Last" />：接收队列中的最后一条消息并将它从队列中移除。 <paramref name="lookupId" /> 参数必须设置为 0。</param>
        <param name="lookupId">要接收的消息的 <see cref="P:System.Messaging.Message.LookupId" />，或者为 0。 访问队列中的第一条和最后一条消息时使用 0。</param>
        <param name="transactionType"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文的类型。</param>
        <summary>在 MSMQ 3.0 中引入。 使用指定的事务上下文从队列中接收特定的消息。 消息可通过查询标识符来指定，也可以通过其相对于队首或队尾的位置来指定。</summary>
        <returns>由传入的 <paramref name="action" /> 和 <paramref name="lookupId" /> 参数指定的 <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可以读取具有已知查找标识符的消息，并使用由参数定义的事务上下文从队列中删除该消息 `transactionType` 。 如果消息不在队列中，此方法会立即引发异常。  
  
 <xref:System.Messaging.Message.LookupId%2A>消息的属性在消息所在的队列中是唯一的，因此队列中最多存在一个与给定参数匹配的消息 `lookupId` 。  
  
 若要读取具有指定标识符的消息而不将其从队列中删除，请使用 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 方法。 没有与调用返回的消息相关联的事务上下文 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 。 因为不 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 会从队列中删除任何消息，所以如果事务中止，则不会回滚任何内容。  
  
 `Automatic` `transactionType` 如果已存在附加到要用于接收消息的线程的外部事务上下文，请为参数指定。 指定 `Single` 是否要以单个内部事务的形式接收消息。 您可以指定 `None` 是否要在事务上下文之外接收来自事务性队列的消息。  
  
 如果调用此方法来接收来自事务性队列的消息，则在事务中止时，收到的消息将返回到队列。 在提交事务之前，不会从队列中永久删除该消息。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">未安装 MSMQ 3.0。</exception>
        <exception cref="T:System.InvalidOperationException">未能找到具有指定 <paramref name="lookupId" /> 的消息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="action" /> 参数不是 <see cref="T:System.Messaging.MessageLookupAction" /> 成员之一。  
  
- 或 - 
<paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReceiveCompleted As ReceiveCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::ReceiveCompletedEventHandler ^ ReceiveCompleted;" />
      <MemberSignature Language="F#" Value="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " Usage="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_ReceiveCompleted")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_ReceiveCompleted")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在从队列移除某条消息后发生。 此事件由异步操作 <see cref="M:System.Messaging.MessageQueue.BeginReceive" /> 引发。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 当队列中有消息时，将在异步处理过程中用于引发 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 事件。  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 用于完成通过调用启动的操作 <xref:System.Messaging.MessageQueue.BeginReceive%2A> ，并在引发事件时查看消息 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 。  
  
 创建 <xref:System.Messaging.ReceiveCompletedEventHandler> 委托时，需要标识将处理该事件的方法。 若要将事件与事件处理程序关联，请将该委托的一个实例添加到事件中。 除非移除了该委托，否则每当发生该事件时就会调用事件处理程序。 有关事件处理程序委托的详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例创建一个名为的事件处理程序 `MyReceiveCompleted` ，将其附加到 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 事件处理程序委托，并调用 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 以在位于路径 ".\myQueue" 的队列上启动异步接收操作。 <xref:System.Messaging.MessageQueue.ReceiveCompleted>引发事件时，该示例接收消息，并将其正文写入屏幕。 然后，该示例 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 再次调用以启动新的异步接收操作。  
  
 [!code-cpp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="messageQueue.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>刷新 <see cref="T:System.Messaging.MessageQueue" /> 所显示的属性以反映资源的当前状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Refresh%2A> 将的属性与其 <xref:System.Messaging.MessageQueue> 关联的消息队列服务器资源同步。 如果 <xref:System.Messaging.MessageQueue.Label%2A> 自创建之后在服务器上更改了任何属性（如或 <xref:System.Messaging.MessageQueue.Category%2A> ），则会 <xref:System.Messaging.MessageQueue> <xref:System.Messaging.MessageQueue.Refresh%2A> <xref:System.Messaging.MessageQueue> 用新信息更新。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.Refresh%2A> 的用法。  
  
 [!code-cpp[MessageQueue2#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetPermissions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetPermissions();" />
      <MemberSignature Language="F#" Value="member this.ResetPermissions : unit -&gt; unit" Usage="messageQueue.ResetPermissions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将权限列表重置为操作系统的默认值。 移除已追加到默认列表中的所有队列权限。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用时 <xref:System.Messaging.MessageQueue.ResetPermissions%2A> ，会将权限列表返回到其默认值。 通常，这会授予队列创建者所有权限，并为每个人提供以下权限：  
  
-   获取队列属性。  
  
-   获取队列权限。  
  
-   写入队列。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.ResetPermissions%2A> 的用法。  
  
 [!code-cpp[MessageQueue2#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向队列发送对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Send : obj -&gt; unit" Usage="messageQueue.Send obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要发送到队列的对象。</param>
        <summary>将对象发送到此 <see cref="T:System.Messaging.MessageQueue" /> 引用的非事务性队列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载将包含参数的消息发送 `obj` 到由引用的队列 <xref:System.Messaging.MessageQueue> 。 发送到队列的对象可以为 <xref:System.Messaging.Message> 或任何托管对象。 如果发送除之外的任何对象 <xref:System.Messaging.Message> ，则会序列化对象并将其插入消息的正文中。  
  
 如果使用此重载将消息发送到事务性队列，则会将该消息发送到死信队列。 如果希望消息成为包含其他消息的事务的一部分，请使用采用 <xref:System.Messaging.MessageQueueTransaction> 或 <xref:System.Messaging.MessageQueueTransactionType> 作为参数的重载。  
  
 如果在调用之前未设置 <xref:System.Messaging.MessageQueue.Formatter%2A> 属性 <xref:System.Messaging.MessageQueue.Send%28System.Object%29> ，则格式化程序默认为 <xref:System.Messaging.XmlMessageFormatter> 。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>属性应用于以外的任何对象 <xref:System.Messaging.Message> 。 例如，如果使用成员指定标签或优先级 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> ，则 <xref:System.Messaging.Message> 在应用程序将其发送到队列时，这些值将应用于包含不属于类型的对象的任何消息。 在发送时 <xref:System.Messaging.Message> ，为设置的属性值 <xref:System.Messaging.Message> 优先于， <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 并且消息的 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 属性优先于队列的 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 属性。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例连接到消息队列并将消息发送到队列。  
  
 [!code-cpp[MessageQueue.Send_obj#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send_obj#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send_obj#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 下面的代码示例将应用程序定义的 `Order` 类发送到队列，然后从该队列接收消息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">尚未设置 <see cref="P:System.Messaging.MessageQueue.Path" /> 属性。  
  
- 或 - 
访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">要发送到队列的对象。</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</param>
        <summary>将对象发送到此 <see cref="T:System.Messaging.MessageQueue" /> 所引用的事务性队列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载 `obj` <xref:System.Messaging.MessageQueue> ，使用由参数定义的内部事务上下文将包含参数的消息发送到引用的事务性队列 `transaction` 。 发送到队列的对象可以为 <xref:System.Messaging.Message> 或任何托管对象。 如果发送除之外的任何对象 <xref:System.Messaging.Message> ，则会序列化对象并将其插入消息的正文中。  
  
 如果使用此重载将消息发送到非事务性队列，则可能会将该消息发送到死信队列，而不会引发异常。  
  
 如果在调用之前未设置 <xref:System.Messaging.MessageQueue.Formatter%2A> 属性 <xref:System.Messaging.MessageQueue.Send%28System.Object%29> ，则格式化程序默认为 <xref:System.Messaging.XmlMessageFormatter> 。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>属性应用于以外的任何对象 <xref:System.Messaging.Message> 。 例如，如果使用成员指定标签或优先级 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> ，则 <xref:System.Messaging.Message> 在应用程序将其发送到队列时，这些值将应用于包含不属于类型的对象的任何消息。 在发送时 <xref:System.Messaging.Message> ，为设置的属性值 <xref:System.Messaging.Message> 优先于， <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 并且消息的 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 属性优先于队列的 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 属性。  
  
 <xref:System.Messaging.MessageQueueTransaction> 线程单元感知，因此，如果单元状态为 `STA` ，则不能在多个线程中使用事务。 Visual Basic 将主线程的状态设置为 `STA` ，因此你必须 <xref:System.MTAThreadAttribute> 在子例程中应用 `Main` 。 否则，利用另一个线程发送事务性消息将引发 <xref:System.Messaging.MessageQueueException> 异常。 <xref:System.MTAThreadAttribute>使用以下片段应用。  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 下面的代码示例将字符串发送到事务性队列，然后从该队列接收消息。  
  
 [!code-cpp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="transaction" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">尚未设置 <see cref="P:System.Messaging.MessageQueue.Path" /> 属性。  
  
- 或 - 
“消息队列”应用程序指示事务用法不正确。  
  
- 或 - 
访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">要发送到队列的对象。</param>
        <param name="transactionType"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文的类型。</param>
        <summary>将对象发送到此 <see cref="T:System.Messaging.MessageQueue" /> 所引用的队列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载将包含参数的消息发送 `obj` 到由引用的队列 <xref:System.Messaging.MessageQueue> ，使用由参数定义的事务上下文 `transactionType` 。 `Automatic` `transactionType` 如果已存在附加到要用于发送消息的线程的外部事务上下文，请为参数指定。 指定 `Single` 是否要将消息作为单个内部事务发送。 您可以指定 `None` 是否要将事务性消息发送到非事务性线程。  
  
 发送到队列的对象可以为 <xref:System.Messaging.Message> 或任何托管对象。 如果发送除之外的任何对象 <xref:System.Messaging.Message> ，则会序列化对象并将其插入消息的正文中。  
  
 如果在调用之前未设置 <xref:System.Messaging.MessageQueue.Formatter%2A> 属性 <xref:System.Messaging.MessageQueue.Send%28System.Object%29> ，则格式化程序默认为 <xref:System.Messaging.XmlMessageFormatter> 。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>属性应用于以外的任何对象 <xref:System.Messaging.Message> 。 例如，如果使用成员指定标签或优先级 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> ，则 <xref:System.Messaging.Message> 在应用程序将其发送到队列时，这些值将应用于包含不属于类型的对象的任何消息。 在发送时 <xref:System.Messaging.Message> ，为设置的属性值 <xref:System.Messaging.Message> 优先于， <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 并且消息的 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 属性优先于队列的 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 属性。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">尚未设置 <see cref="P:System.Messaging.MessageQueue.Path" /> 属性。  
  
- 或 - 
访问“消息队列”方法时出错。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string -&gt; unit" Usage="messageQueue.Send (obj, label)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">要发送到队列的对象。</param>
        <param name="label">消息的标签。</param>
        <summary>将对象发送到此 <see cref="T:System.Messaging.MessageQueue" /> 引用的非事务性队列，并指定消息的标签。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载将包含参数的消息发送 `obj` 到由引用的队列 <xref:System.Messaging.MessageQueue> 。 利用此重载，可以指定标识消息的字符串标签。 发送到队列的对象可以是 <xref:System.Messaging.Message> 、结构、数据对象或任何托管对象。 如果发送除之外的任何对象 <xref:System.Messaging.Message> ，则会序列化对象并将其插入消息的正文中。  
  
 消息标签不同于消息队列标签，但两者都依赖于应用程序，并且对消息队列没有继承意义。  
  
 如果使用此重载将消息发送到事务性队列，则会将该消息发送到死信队列。 如果希望消息成为包含其他消息的事务的一部分，请使用采用 <xref:System.Messaging.MessageQueueTransaction> 或 <xref:System.Messaging.MessageQueueTransactionType> 作为参数的重载。  
  
 <xref:System.Messaging.MessageQueue.Path%2A> <xref:System.Messaging.MessageQueue> 必须先指定此实例的属性，然后才能发送消息。 如果在调用之前未设置 <xref:System.Messaging.MessageQueue.Formatter%2A> 属性 <xref:System.Messaging.MessageQueue.Send%28System.Object%29> ，则格式化程序默认为 <xref:System.Messaging.XmlMessageFormatter> 。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>属性应用于以外的任何对象 <xref:System.Messaging.Message> 。 例如，如果使用成员指定标签或优先级 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> ，则 <xref:System.Messaging.Message> 在应用程序将其发送到队列时，这些值将应用于包含不属于类型的对象的任何消息。 在发送时 <xref:System.Messaging.Message> ，为设置的属性值 <xref:System.Messaging.Message> 优先于， <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 并且消息的 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 属性优先于队列的 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 属性。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29> 的用法。  
  
 [!code-cpp[MessageQueue2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="label" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">尚未设置 <see cref="P:System.Messaging.MessageQueue.Path" /> 属性。  
  
- 或 - 
访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, label, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">要发送到队列的对象。</param>
        <param name="label">消息的标签。</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</param>
        <summary>将对象发送到此 <see cref="T:System.Messaging.MessageQueue" /> 引用的事务性队列中，并指定该消息的标签。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载 `obj` <xref:System.Messaging.MessageQueue> ，使用由参数定义的内部事务上下文将包含参数的消息发送到引用的事务性队列 `transaction` 。 利用此重载，可以指定标识消息的字符串标签。 发送到队列的对象可以是 <xref:System.Messaging.Message> 、结构、数据对象或任何托管对象。 如果发送除之外的任何对象 <xref:System.Messaging.Message> ，则会序列化对象并将其插入消息的正文中。  
  
 消息标签不同于消息队列标签，但两者都依赖于应用程序，并且对消息队列没有继承意义。  
  
 如果使用此重载将消息发送到非事务性队列，则可能会将该消息发送到死信队列，而不会引发异常。  
  
 如果在调用之前未设置 <xref:System.Messaging.MessageQueue.Formatter%2A> 属性 <xref:System.Messaging.MessageQueue.Send%28System.Object%29> ，则格式化程序默认为 <xref:System.Messaging.XmlMessageFormatter> 。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>属性应用于以外的任何对象 <xref:System.Messaging.Message> 。 例如，如果使用成员指定标签或优先级 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> ，则 <xref:System.Messaging.Message> 在应用程序将其发送到队列时，这些值将应用于包含不属于类型的对象的任何消息。 在发送时 <xref:System.Messaging.Message> ，为设置的属性值 <xref:System.Messaging.Message> 优先于， <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 并且消息的 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 属性优先于队列的 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 属性  
  
 <xref:System.Messaging.MessageQueueTransaction> 线程单元感知，因此，如果单元状态为 `STA` ，则不能在多个线程中使用事务。 Visual Basic 将主线程的状态设置为 `STA` ，因此你必须 <xref:System.MTAThreadAttribute> 在子例程中应用 `Main` 。 否则，利用另一个线程发送事务性消息将引发 <xref:System.Messaging.MessageQueueException> 异常。 <xref:System.MTAThreadAttribute>使用以下片段应用。  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29> 的用法。  
  
 [!code-cpp[MessageQueue2#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="label" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="transaction" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">尚未设置 <see cref="P:System.Messaging.MessageQueue.Path" /> 属性。  
  
- 或 - 
“消息队列”应用程序指示了不正确的事务用法。  
  
- 或 - 
访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, label, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">要发送到队列的对象。</param>
        <param name="label">消息的标签。</param>
        <param name="transactionType"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文的类型。</param>
        <summary>将对象发送到此 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列中，并指定该消息的标签。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载将包含参数的消息发送 `obj` 到由引用的队列 <xref:System.Messaging.MessageQueue> ，使用由参数定义的事务上下文 `transactionType` 。 `Automatic` `transactionType` 如果已存在附加到要用于发送消息的线程的外部事务上下文，请为参数指定。 指定 `Single` 是否要将消息作为单个内部事务发送。 您可以指定 `None` 是否要将事务性消息发送到非事务性线程。  
  
 发送到队列的对象可以为 <xref:System.Messaging.Message> 或任何托管对象。 如果发送除之外的任何对象 <xref:System.Messaging.Message> ，则会序列化对象并将其插入消息的正文中。 利用此重载，可以指定标识消息的字符串标签。  
  
 消息标签不同于消息队列标签，但两者都依赖于应用程序，并且对消息队列没有继承意义。  
  
 如果在调用之前未设置 <xref:System.Messaging.MessageQueue.Formatter%2A> 属性 <xref:System.Messaging.MessageQueue.Send%28System.Object%29> ，则格式化程序默认为 <xref:System.Messaging.XmlMessageFormatter> 。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>属性应用于以外的任何对象 <xref:System.Messaging.Message> 。 例如，如果使用成员指定标签或优先级 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> ，则 <xref:System.Messaging.Message> 在应用程序将其发送到队列时，这些值将应用于包含不属于类型的对象的任何消息。 在发送时 <xref:System.Messaging.Message> ，为设置的属性值 <xref:System.Messaging.Message> 优先于 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> ，并且消息的 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 属性优先于队列的 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 属性。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="label" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction">“消息队列”应用程序指示了不正确的事务用法。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">尚未设置 <see cref="P:System.Messaging.MessageQueue.Path" /> 属性。  
  
- 或 - 
访问“消息队列”方法时出错。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetPermissions">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将权限添加到当前集合中。 这样可控制谁对队列中的队列属性和消息具有访问权限。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (dacl As AccessControlList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::AccessControlList ^ dacl);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.AccessControlList -&gt; unit" Usage="messageQueue.SetPermissions dacl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl"><see cref="T:System.Messaging.AccessControlList" />，包含一个或多个指定受信者和要授予的权限的访问控制项。</param>
        <summary>基于访问控制列表的内容将访问权限分配给队列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载可通过使用访问控制项的集合指定受信者和权限信息来授予、拒绝或撤消权限。 例如，使用此项可以同时向多个用户授予权限。  
  
 构造参数时指定的受信者 `ace` 可以是单个用户、用户组或计算机。 如果受信者是个人，请使用格式 `DOMAIN` \\ `user` 。 您可以为受信者指定 "."，以指示本地计算机。  
  
 通过 <xref:System.Messaging.MessageQueue.SetPermissions%2A> 向现有列表添加权限指定的权限。 默认情况下，公用或专用队列的创建者具有 "完全控制" 权限，而 "域组" 有权获取队列属性、获取权限和写入队列。 调用时 <xref:System.Messaging.MessageQueue.SetPermissions%2A> ，会将用户和权限信息追加到现有列表的底部。  
  
 系统 <xref:System.Messaging.AccessControlEntry> 会按顺序检查每个事件，直到发生以下事件之一：  
  
-   拒绝访问会 <xref:System.Messaging.AccessControlEntry> 显式拒绝对线程的访问令牌中列出的某个受信者所请求的任何访问权限。  
  
-   线程的访问令牌中列出的受信者的一个或多个允许访问的 <xref:System.Messaging.AccessControlEntry> 项显式授予所有请求的访问权限。  
  
-   已 <xref:System.Messaging.AccessControlEntry> 检查所有项，但至少有一个请求的访问权限尚未显式允许，在这种情况下，访问将被隐式拒绝。  
  
 构造 `dacl` 参数时，请将实例添加 <xref:System.Messaging.AccessControlEntry> 到集合中 <xref:System.Messaging.AccessControlList> 。 构造每个访问控制项时，可以指定常规或标准访问权限。 队列的权限可以是以下各项的任意组合：  
  
-   删除  
  
-   读取安全  
  
-   写入安全性  
  
-   同步  
  
-   修改所有者  
  
-   读取  
  
-   Write  
  
-   执行  
  
-   必需  
  
-   全部  
  
-   None  
  
 这些权限是可使用或按位运算符组合的一组位标志。  
  
-   完全控制  
  
-   删除消息  
  
-   接收消息  
  
-   速览消息  
  
-   接收日志消息  
  
-   获取队列属性  
  
-   设置队列属性  
  
-   获取权限  
  
-   设置权限  
  
-   获取队列所有权  
  
-    编写消息  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29> 的用法。      
  
 [!code-cpp[MessageQueue2#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.AccessControlList" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (ace As MessageQueueAccessControlEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::MessageQueueAccessControlEntry ^ ace);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.MessageQueueAccessControlEntry -&gt; unit" Usage="messageQueue.SetPermissions ace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace">指定用户、访问类型和权限类型的 <see cref="T:System.Messaging.MessageQueueAccessControlEntry" />。</param>
        <summary>基于访问控制项的内容将访问权限分配给队列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载通过访问控制项指定受信者和权限信息来授予、拒绝或撤消权限。  
  
 构造参数时指定的受信者 `ace` 可以是单个用户、用户组或计算机。 如果受信者是个人，请使用格式 `DOMAIN` \\ `user` 。 您可以为受信者指定 "."，以指示本地计算机。  
  
 通过 <xref:System.Messaging.MessageQueue.SetPermissions%2A> 向现有列表添加权限指定的权限。 默认情况下，公用或专用队列的创建者具有 "完全控制" 权限，而 "域组" 有权获取队列属性、获取权限和写入队列。 调用时 <xref:System.Messaging.MessageQueue.SetPermissions%2A> ，会将用户和权限信息追加到现有列表的底部。  
  
 系统 <xref:System.Messaging.AccessControlEntry> 会按顺序检查每个事件，直到发生以下事件之一：  
  
-   拒绝访问会 <xref:System.Messaging.AccessControlEntry> 显式拒绝对线程的访问令牌中列出的某个受信者所请求的任何访问权限。  
  
-   线程的访问令牌中列出的受信者的一个或多个允许访问的 <xref:System.Messaging.AccessControlEntry> 项显式授予所有请求的访问权限。  
  
-   已 <xref:System.Messaging.AccessControlEntry> 检查所有项，但至少有一个请求的访问权限尚未显式允许，在这种情况下，访问将被隐式拒绝。  
  
 在构造时在参数中指定的对队列的权限 `rights` <xref:System.Messaging.MessageQueueAccessControlEntry> ，可以是以下任意组合：  
  
-   完全控制  
  
-   删除消息  
  
-   接收消息  
  
-   速览消息  
  
-   接收日志消息  
  
-   获取队列属性  
  
-   设置队列属性  
  
-   获取权限  
  
-   设置权限  
  
-   获取队列所有权  
  
-    编写消息  
  
 `rights`在参数的构造函数中指定的参数 `ace` 是枚举的标志 <xref:System.Messaging.MessageQueueAccessRights> 。 它表示一组可以使用按位运算符或在生成参数时进行组合的位标志 `rights` 。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29> 的用法。  
  
 [!code-cpp[MessageQueue2#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.MessageQueueAccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights -&gt; unit" Usage="messageQueue.SetPermissions (user, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user">获取对队列的附加权限的个人、组或计算机。</param>
        <param name="rights"><see cref="T:System.Messaging.MessageQueueAccessRights" />，指示对“消息队列”分配给传入的 <paramref name="user" /> 的队列权限集。</param>
        <summary>给予计算机、组或用户指定的访问权限。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载将指定的权限授予单个用户。 用户可以是任何有效的受信者，其中包括个人用户、用户组或计算机。 如果用户是个人，请使用参数的格式 `DOMAIN` \\ `user` `user` 。 可以为参数指定 "."， `user` 以指示本地计算机。  
  
 通过 <xref:System.Messaging.MessageQueue.SetPermissions%2A> 向现有列表添加权限指定的权限。 默认情况下，公用或专用队列的创建者具有 "完全控制" 权限，而 "域组" 有权获取队列属性、获取权限和写入队列。 调用时 <xref:System.Messaging.MessageQueue.SetPermissions%2A> ，会将用户和权限信息追加到现有列表的底部。  
  
 系统 <xref:System.Messaging.AccessControlEntry> 会按顺序检查每个事件，直到发生以下事件之一：  
  
-   拒绝访问会 <xref:System.Messaging.AccessControlEntry> 显式拒绝对线程的访问令牌中列出的某个受信者所请求的任何访问权限。  
  
-   线程的访问令牌中列出的受信者的一个或多个允许访问的 <xref:System.Messaging.AccessControlEntry> 项显式授予所有请求的访问权限。  
  
-   已 <xref:System.Messaging.AccessControlEntry> 检查所有项，但至少有一个请求的访问权限尚未显式允许，在这种情况下，访问将被隐式拒绝。  
  
 在参数中指定的对队列的权限 `rights` 可以是以下任意组合：  
  
-   完全控制  
  
-   删除消息  
  
-   接收消息  
  
-   速览消息  
  
-   接收日志消息  
  
-   获取队列属性  
  
-   设置队列属性  
  
-   获取权限  
  
-   设置权限  
  
-   获取队列所有权  
  
-    编写消息  
  
 <xref:System.Messaging.MessageQueueAccessRights>枚举表示一组可以使用按位运算符组合或用于生成参数的位标志 `rights` 。  
  
 利用此重载，只能授予权限;不能撤消或拒绝它们。 必须使用其他重载显式授予除以外的任何 <xref:System.Messaging.AccessControlEntryType> 其他重载 `Allow` 。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29> 的用法。  
  
 [!code-cpp[MessageQueue2#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="user" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights, entryType As AccessControlEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights, System::Messaging::AccessControlEntryType entryType);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights * System.Messaging.AccessControlEntryType -&gt; unit" Usage="messageQueue.SetPermissions (user, rights, entryType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user">获取对队列的附加权限的个人、组或计算机。</param>
        <param name="rights"><see cref="T:System.Messaging.MessageQueueAccessRights" />，指示对“消息队列”分配给传入的 <paramref name="user" /> 的队列权限集。</param>
        <param name="entryType"><see cref="T:System.Messaging.AccessControlEntryType" />，指定授予、拒绝还是撤消 <paramref name="rights" /> 参数指定的权限。</param>
        <summary>利用指定的访问控制类型（允许、拒绝、撤消或设置），给予计算机、组或用户指定的访问权限。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载可为单个用户授予、拒绝或撤消指定的权限。 用户可以是任何有效的受信者，其中包括个人用户、用户组或计算机。 如果用户是个人，请使用参数的格式 `DOMAIN` \\ `user` `user` 。 可以为参数指定 "."， `user` 以指示本地计算机。  
  
 通过 <xref:System.Messaging.MessageQueue.SetPermissions%2A> 向现有列表添加权限指定的权限。 默认情况下，公用或专用队列的创建者具有 "完全控制" 权限，而 "域组" 有权获取队列属性、获取权限和写入队列。 调用时 <xref:System.Messaging.MessageQueue.SetPermissions%2A> ，会将用户和权限信息追加到现有列表的底部。  
  
 系统 <xref:System.Messaging.AccessControlEntry> 会按顺序检查每个事件，直到发生以下事件之一：  
  
-   拒绝访问会 <xref:System.Messaging.AccessControlEntry> 显式拒绝对线程的访问令牌中列出的某个受信者所请求的任何访问权限。  
  
-   线程的访问令牌中列出的受信者的一个或多个允许访问的 <xref:System.Messaging.AccessControlEntry> 项显式授予所有请求的访问权限。  
  
-   已 <xref:System.Messaging.AccessControlEntry> 检查所有项，但至少有一个请求的访问权限尚未显式允许，在这种情况下，访问将被隐式拒绝。  
  
 在参数中指定的对队列的权限 `rights` 可以是以下任意组合：  
  
-   完全控制  
  
-   删除消息  
  
-   接收消息  
  
-   速览消息  
  
-   接收日志消息  
  
-   获取队列属性  
  
-   设置队列属性  
  
-   获取权限  
  
-   设置权限  
  
-   获取队列所有权  
  
-    编写消息  
  
 <xref:System.Messaging.MessageQueueAccessRights>枚举表示一组可以使用按位运算符组合或用于生成参数的位标志 `rights` 。  
  
 下表显示了此方法是否在各种工作组模式下可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.AccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(null)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(null)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_SynchronizingObject")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_SynchronizingObject")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置由 <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> 或 <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> 事件产生封送事件处理程序调用的对象。</summary>
        <value><see cref="T:System.ComponentModel.ISynchronizeInvoke" />，表示封送由 <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> 或 <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> 事件产生的事件处理程序调用的对象。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> <xref:System.Messaging.MessageQueue.PeekCompleted> 或请求中的或事件的结果， <xref:System.Messaging.MessageQueue.BeginReceive%2A> <xref:System.Messaging.MessageQueue.BeginPeek%2A> 分别为特定线程。 通常，在将 <xref:System.Messaging.MessageQueue.SynchronizingObject%2A> 其相关组件置于控件或窗体内时设置，因为这些组件绑定到特定线程。  
  
 通常，同步对象将方法调用封送到单个线程。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transactional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Transactional { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Transactional : bool" Usage="System.Messaging.MessageQueue.Transactional" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_Transactional")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_Transactional")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示队列是否只接受事务。</summary>
        <value>如果队列只接受作为事务的一部分发送的消息，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事务性消息处理是指将几个相关消息耦合到一个事务中。 作为事务的一部分发送消息可确保消息按顺序传递、只传递一次，并从其目标队列成功检索。  
  
 如果队列是事务性的，则它仅接受作为事务的一部分发送的消息。 但是，可以在不显式使用事务性 <xref:System.Messaging.MessageQueueTransaction.Begin%2A> 、和语法的情况下，从本地事务队列发送或接收非事务性消息 <xref:System.Messaging.MessageQueueTransaction.Commit%2A> <xref:System.Messaging.MessageQueueTransaction.Abort%2A> 。 如果将非事务性消息发送到事务性队列，此组件会为其创建单个消息事务，除非使用直接格式名称引用远程计算机上的队列。 在这种情况下，如果在发送消息时未指定事务上下文，则不会为您创建一个，并将消息发送到死信队列。  
  
 如果将非事务性消息发送到事务性队列，则在发生异常的情况下将无法回滚消息。  
  
 <xref:System.Messaging.MessageQueueTransaction> 线程单元感知，因此，如果单元状态为 `STA` ，则不能在多个线程中使用事务。 Visual Basic 将主线程的状态设置为 `STA` ，因此你必须 <xref:System.MTAThreadAttribute> 在子例程中应用 `Main` 。 否则，利用另一个线程发送事务性消息将引发 <xref:System.Messaging.MessageQueueException> 异常。 <xref:System.MTAThreadAttribute>使用以下片段应用。  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 下表显示了此属性在各种工作组模式下是否可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 下面的代码示例显示消息队列属性的值 <xref:System.Messaging.MessageQueue.Transactional%2A> 。  
  
 [!code-csharp[MessageQueue#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Begin" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Commit" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Abort" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_UseJournalQueue")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_UseJournalQueue")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_WriteHandle")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_WriteHandle")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示接收的消息是否复制到日记队列。</summary>
        <value>如果从队列接收到的消息复制到其日记队列，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当消息队列应用程序创建新的应用程序队列时，它会自动在同一位置创建关联的日记队列。 日志队列用于跟踪从队列中删除的消息。 设置此属性将修改 "消息队列" 队列。 因此， <xref:System.Messaging.MessageQueue> 此更改会影响任何其他实例。  
  
 日志队列不跟踪从队列中删除的消息，因为它们的接收时间计时器过期，也不跟踪使用消息队列目录服务从队列中清除的消息 (的信息存储或 Active Directory) 。  
  
 应用程序无法将消息发送到日记队列;它们仅限于对这些队列的只读访问。 而且，消息队列从不从日志队列中删除消息。 使用队列的应用程序必须通过接收或清除队列来清除这些消息。  
  
 下表显示了此属性在各种工作组模式下是否可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|否|  
  
   
  
## Examples  
 下面的代码示例获取并设置消息队列属性的值 <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> 。  
  
 [!code-csharp[MessageQueue#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriteHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr WriteHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteHandle : nativeint" Usage="System.Messaging.MessageQueue.WriteHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MQ_WriteHandle")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MQ_WriteHandle")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于将消息发送到消息队列的本机句柄。</summary>
        <value>用于将消息发送到队列的本机队列对象的句柄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供用于将 <xref:System.Messaging.MessageQueue.WriteHandle%2A> 消息发送到队列的消息队列对象的本机 Windows 句柄。 如果更改队列的路径，将关闭句柄，并使用新值重新打开。  
  
 下表显示了此属性在各种工作组模式下是否可用。  
  
|工作组模式|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名称|是|  
|远程计算机|否|  
|远程计算机和直接格式名称|是|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">消息队列无法用于写入。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
  </Members>
</Type>
