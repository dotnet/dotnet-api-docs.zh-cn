<Type Name="Message" FullName="System.Messaging.Message">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7099b37d9e607c027df03615f1080672fb68c235" /><Meta Name="ms.sourcegitcommit" Value="c982ad9e10a242d90f1e631b5981570f9e5d9f34" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/10/2020" /><Meta Name="ms.locfileid" Value="90001088" /></Metadata><TypeSignature Language="C#" Value="public class Message : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Message extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.Message" />
  <TypeSignature Language="VB.NET" Value="Public Class Message&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Message : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Message = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName Language="C#">[System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName Language="C#">[System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供对定义消息队列消息所需的属性的访问。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Messaging.Message> 类查看或接收来自队列的消息，或在将消息发送到队列时对消息属性进行精细控制。  
  
 <xref:System.Messaging.MessageQueue> 使用 <xref:System.Messaging.Message> 类查看或接收来自队列的消息时，因为 <xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=nameWithType> 和 <xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=nameWithType> 方法都创建类的新实例 <xref:System.Messaging.Message> 并设置该实例的属性。 <xref:System.Messaging.Message>类的只读属性适用于从队列中检索消息，而读取/写入属性应用于发送和检索消息。 <xref:System.Messaging.MessageQueue>扫视或接收来自队列的消息时，其 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> 属性将确定检索消息的哪些属性。  
  
 使用 <xref:System.Messaging.MessageQueue> 类的 <xref:System.Messaging.MessageQueue.Send%2A> 方法可以为发送到该队列的消息指定任何对象类型。 您可以使用 <xref:System.Messaging.MessageQueue> 实例的 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 属性来指定发送到队列的一般消息的设置。 设置类型包括格式化程序、标签、加密和身份验证。 在 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 协调消息传递应用程序以响应确认和报告消息时，还可以指定相应成员的值。 使用 <xref:System.Messaging.Message> 实例将消息发送到队列，你可以灵活地访问和修改其中的许多属性-无论是单个消息还是按消息。 <xref:System.Messaging.Message> 属性优先于 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 。  
  
 消息数据存储在属性中 <xref:System.Messaging.Message.Body%2A> ，并在较小的范围内存储 <xref:System.Messaging.Message.AppSpecific%2A> 和 <xref:System.Messaging.Message.Extension%2A> 属性。 对消息数据进行加密、序列化或反序列化时，仅 <xref:System.Messaging.Message.Body%2A> 影响属性的内容。  
  
 <xref:System.Messaging.Message.Body%2A>发送消息时，将使用指定的属性对属性的内容进行序列化 <xref:System.Messaging.Message.Formatter%2A> 。 序列化的内容位于属性中 <xref:System.Messaging.Message.BodyStream%2A> 。 您还可以直接设置 <xref:System.Messaging.Message.BodyStream%2A> 属性，例如，将文件作为消息的数据内容发送。 你可以随时更改 <xref:System.Messaging.Message.Body%2A> 或 <xref:System.Messaging.Message.Formatter%2A> 属性，然后再发送消息，并且在调用时，将相应地序列化数据 <xref:System.Messaging.MessageQueue.Send%2A> 。  
  
 属性定义的属性 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=nameWithType> 仅适用于不属于类型的消息 <xref:System.Messaging.Message> 。 如果 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 为指定了属性，则 <xref:System.Messaging.MessageQueue> 发送到该队列的实例中的名称相同的属性将 <xref:System.Messaging.Message> 导致忽略这些默认属性。  
  
 有关实例的初始属性值的列表 <xref:System.Messaging.Message> ，请参见 <xref:System.Messaging.Message.%23ctor%2A> 构造函数。  
  
   
  
## Examples  
 下面的代码示例演示如何使用格式化消息正文 <xref:System.Messaging.BinaryMessageFormatter> 。  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 下面的代码示例演示如何使用格式化消息正文 <xref:System.Messaging.XmlMessageFormatter> 。  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Messaging.Message" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Messaging.Message" /> 类的新实例（主体为空）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载创建 <xref:System.Messaging.Message> 类的新实例，该实例的正文为空。  
  
 <xref:System.Messaging.Message.Body%2A>发送对象之前，请指定属性或 <xref:System.Messaging.Message.BodyStream%2A> 属性 <xref:System.Messaging.Message> 。 <xref:System.Messaging.Message.Body%2A>属性可以是可序列化的任何对象，例如文本字符串、结构对象、类实例或嵌入的对象。  
  
 除非将消息内容直接写入 <xref:System.Messaging.Message.BodyStream%2A> 属性，否则在 <xref:System.Messaging.Message.Formatter%2A> 发送消息之前，请设置属性。 在 <xref:System.Messaging.Message.Formatter%2A> <xref:System.Messaging.MessageQueue.Send%2A> 实例上调用方法时，将使用属性的值对正文进行序列化 <xref:System.Messaging.MessageQueue> 。  
  
 <xref:System.Messaging.XmlMessageFormatter>是松散耦合的，因此在使用此格式时，不需要在发送方和接收方上具有相同的对象类型。 将 <xref:System.Messaging.ActiveXMessageFormatter> <xref:System.Messaging.BinaryMessageFormatter> 数据序列化为二进制表示形式。 在 <xref:System.Messaging.ActiveXMessageFormatter> 发送或接收 COM 组件时使用。  
  
 下表显示了实例的初始属性值 <xref:System.Messaging.Message> 。  
  
|属性|初始值|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft 基本加密提供程序版本1。0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`null`|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|空字符串 ( "" ) |  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|长度为零的字节数组|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|长度为零的字节数组|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|长度为零的字节数组|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|空字符串 ( "" ) |  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|长度为零的字节数组|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 下面的代码示例将两个不同优先级的消息发送到队列，然后检索它们。  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj -&gt; System.Messaging.Message" Usage="new System.Messaging.Message body" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="body">要序列化到消息体中的对象。</param>
        <summary>通过用 <see cref="T:System.Messaging.Message" /> 将指定的对象序列化到消息体中，初始化 <see cref="T:System.Messaging.XmlMessageFormatter" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载创建 <xref:System.Messaging.Message> 类的新实例，该类包含 <xref:System.Messaging.Message.Body%2A> 由参数指定的 `body` 。 `body`参数可以是可序列化的任何对象，例如文本字符串、结构对象、类实例或嵌入的对象。 使用来序列化正文， <xref:System.Messaging.XmlMessageFormatter> 除非在 <xref:System.Messaging.Message.Formatter%2A> 发送之前更改属性 <xref:System.Messaging.Message> 。 如果 <xref:System.Messaging.Message.Body%2A> <xref:System.Messaging.Message.Formatter%2A> 在调用之前随时更改或属性 <xref:System.Messaging.MessageQueue.Send%2A> ，将根据新的属性值对消息进行序列化。  
  
 <xref:System.Messaging.XmlMessageFormatter>是松散耦合的，因此在使用此格式时，不需要在发送方和接收方上具有相同的对象类型。 将 <xref:System.Messaging.ActiveXMessageFormatter> <xref:System.Messaging.BinaryMessageFormatter> 数据序列化为二进制表示形式。 在 <xref:System.Messaging.ActiveXMessageFormatter> 发送或接收 COM 组件时使用。  
  
 下表显示了实例的初始属性值 <xref:System.Messaging.Message> 。  
  
|属性|初始值|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft 基本加密提供程序版本1。0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`body` 参数。|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|空字符串 ( "" ) |  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|长度为零的字节数组|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|长度为零的字节数组|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|长度为零的字节数组|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|空字符串 ( "" ) |  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|长度为零的字节数组|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 下面的代码示例创建一个新队列，将包含订单的消息发送到该队列，然后检索该队列。  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body, System.Messaging.IMessageFormatter formatter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body, class System.Messaging.IMessageFormatter formatter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object, formatter As IMessageFormatter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body, System::Messaging::IMessageFormatter ^ formatter);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj * System.Messaging.IMessageFormatter -&gt; System.Messaging.Message" Usage="new System.Messaging.Message (body, formatter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
        <Parameter Name="formatter" Type="System.Messaging.IMessageFormatter" />
      </Parameters>
      <Docs>
        <param name="body">要序列化到消息体中的对象。</param>
        <param name="formatter"><see cref="T:System.Messaging.IMessageFormatter" />，指定用于序列化消息体的格式化程序。</param>
        <summary>初始化 <see cref="T:System.Messaging.Message" /> 类的新实例，使用指定的格式化程序将指定的对象序列化到消息体中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载创建 <xref:System.Messaging.Message> 类的新实例，该类包含 <xref:System.Messaging.Message.Body%2A> 由参数指定的， `body` 并使用任何有效的格式化程序来序列化正文。 `body`参数是可序列化的任何对象，例如文本字符串、结构对象、类实例或嵌入的对象。 如果 <xref:System.Messaging.Message.Body%2A> <xref:System.Messaging.Message.Formatter%2A> 在调用之前随时更改或属性 <xref:System.Messaging.MessageQueue.Send%2A> ，将根据新的属性值对消息进行序列化。  
  
 <xref:System.Messaging.XmlMessageFormatter>是松散耦合的，因此在使用此格式时，不需要在发送方和接收方上具有相同的对象类型。 将 <xref:System.Messaging.ActiveXMessageFormatter> <xref:System.Messaging.BinaryMessageFormatter> 数据序列化为二进制表示形式。 在 <xref:System.Messaging.ActiveXMessageFormatter> 发送或接收 COM 组件时使用。  
  
 下表显示了实例的初始属性值 <xref:System.Messaging.Message> 。  
  
|属性|初始值|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft 基本加密提供程序版本1。0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`body` 参数。|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|空字符串 ( "" ) |  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|长度为零的字节数组|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|长度为零的字节数组|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|长度为零的字节数组|  
|<xref:System.Messaging.Message.Formatter%2A>|`formatter` 参数。|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|空字符串 ( "" ) |  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|长度为零的字节数组|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="AcknowledgeType">
      <MemberSignature Language="C#" Value="public System.Messaging.AcknowledgeTypes AcknowledgeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.AcknowledgeTypes AcknowledgeType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AcknowledgeType" />
      <MemberSignature Language="VB.NET" Value="Public Property AcknowledgeType As AcknowledgeTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::AcknowledgeTypes AcknowledgeType { System::Messaging::AcknowledgeTypes get(); void set(System::Messaging::AcknowledgeTypes value); };" />
      <MemberSignature Language="F#" Value="member this.AcknowledgeType : System.Messaging.AcknowledgeTypes with get, set" Usage="System.Messaging.Message.AcknowledgeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgAcknowledgeType")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgAcknowledgeType")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.AcknowledgeTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置返回给发送应用程序的确认消息的类型。</summary>
        <value><see cref="T:System.Messaging.AcknowledgeTypes" /> 值之一，该值表示系统在管理队列中传递的确认消息类型，以及在何种条件下将确认消息返回发送应用程序。 默认值为 <see langword="None" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.AcknowledgeType%2A>属性指定发送应用程序所请求的确认消息的类型。 <xref:System.Messaging.Message.AcknowledgeType%2A>在发送消息之前设置属性，以请求某些出现的通知（例如，到达其目标队列的消息、要检索的消息，或阻止消息到达目标队列或从目标队列中检索消息的超时）。  
  
 消息队列通过将确认消息发送到 <xref:System.Messaging.Message.AdministrationQueue%2A> 原始消息指定的属性来返回通知。 确认消息的 <xref:System.Messaging.Message.Acknowledgment%2A> 属性指示它所表示的确认类型。 例如，如果由于消息在间隔过期之前未到达目标而发送确认消息 <xref:System.Messaging.Message.TimeToReachQueue%2A> ， <xref:System.Messaging.Message.Acknowledgment%2A> 确认消息的属性将包含值 `ReachQueueTimeout` 。  
  
   
  
## Examples  
 下面的代码示例在队列中发送和接收包含订单的消息。 当原始消息到达或从队列中检索时，它专门请求肯定确认。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息经过筛选后忽略了 <see cref="P:System.Messaging.Message.AcknowledgeType" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="Acknowledgment">
      <MemberSignature Language="C#" Value="public System.Messaging.Acknowledgment Acknowledgment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.Acknowledgment Acknowledgment" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Acknowledgment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Acknowledgment As Acknowledgment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Acknowledgment Acknowledgment { System::Messaging::Acknowledgment get(); };" />
      <MemberSignature Language="F#" Value="member this.Acknowledgment : System.Messaging.Acknowledgment" Usage="System.Messaging.Message.Acknowledgment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgAcknowledgement")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgAcknowledgement")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.Acknowledgment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取该消息表示的确认分类。</summary>
        <value><see cref="T:System.Messaging.Acknowledgment" /> 枚举值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接收来自管理队列的消息时，请阅读 <xref:System.Messaging.Message.Acknowledgment%2A> 属性以验证原始消息的状态。  
  
 将消息发送到其目标队列时，可以请求消息队列发布确认消息。 例如，此类消息可以指示消息是在指定的超时内到达，还是在指定的超时内检索到，或者指示在传递失败的情况下出现了什么问题。 目标队列返回确认消息，并将其发送到原始消息的属性中指定的管理队列 <xref:System.Messaging.Message.AdministrationQueue%2A> 。 <xref:System.Messaging.Message.Id%2A>确认消息的属性标识确认消息，而不是原始消息。 可以在确认实例的属性中找到原始消息的标识符 <xref:System.Messaging.Message> <xref:System.Messaging.Message.CorrelationId%2A> 。  
  
 如果此 <xref:System.Messaging.Message> 实例表示确认消息，则该 <xref:System.Messaging.Message.Acknowledgment%2A> 属性指定确认类型。 否则， <xref:System.Messaging.Message.Acknowledgment%2A> 属性包含值 `Normal` 。  
  
 使用 <xref:System.Messaging.Message.AcknowledgeType%2A> 原始消息的属性来指定将在哪些情况下返回确认。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
- 或 - 
消息队列经过筛选后忽略了 <see cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="AdministrationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue AdministrationQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue AdministrationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AdministrationQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property AdministrationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ AdministrationQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AdministrationQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.AdministrationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgAdministrationQueue")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgAdministrationQueue")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置接收由消息队列生成的确认消息的队列。</summary>
        <value><see cref="T:System.Messaging.MessageQueue" />，指定用于系统生成的确认消息的管理队列。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性中指定的队列 <xref:System.Messaging.Message.AdministrationQueue%2A> 可以是任何非事务性队列。 发送到管理队列的确认消息可以指示原始消息是否到达了目标队列，以及是否被从该队列中移除。  
  
 当 <xref:System.Messaging.Message.AcknowledgeType%2A> 属性具有以外的任何值时 `None` ，发送应用程序必须指定要用作管理队列的队列。  
  
   
  
## Examples  
 下面的代码示例在队列中发送和接收包含订单的消息。 当原始消息到达或从队列中检索时，它专门请求肯定确认。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.AdministrationQueue" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="AppSpecific">
      <MemberSignature Language="C#" Value="public int AppSpecific { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AppSpecific" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AppSpecific" />
      <MemberSignature Language="VB.NET" Value="Public Property AppSpecific As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AppSpecific { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.AppSpecific : int with get, set" Usage="System.Messaging.Message.AppSpecific" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgAppSpecific")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgAppSpecific")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置应用程序特定的附加信息。</summary>
        <value>应用程序特定的信息。 默认值为零。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.AppSpecific%2A>属性包含特定于应用程序的信息，您可以使用这些信息来组织不同类型的消息。 例如，可使用应用程序特定的索引。 应用程序负责解释 <xref:System.Messaging.Message.AppSpecific%2A> 属性信息。  
  
 如果可能，应在消息正文中（而不是属性）中包含消息数据 <xref:System.Messaging.Message.AppSpecific%2A> 。  
  
 使用外部队列时，请使用 <xref:System.Messaging.Message.Extension%2A> 属性来指定消息队列中不存在的消息属性。 与属性一样 <xref:System.Messaging.Message.AppSpecific%2A> ，应用程序负责了解属性的内容 <xref:System.Messaging.Message.Extension%2A> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.AppSpecific" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="ArrivedTime">
      <MemberSignature Language="C#" Value="public DateTime ArrivedTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ArrivedTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ArrivedTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ArrivedTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ArrivedTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ArrivedTime : DateTime" Usage="System.Messaging.Message.ArrivedTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgArrivedTime")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgArrivedTime")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取消息到达目标队列的时间。</summary>
        <value><see cref="T:System.DateTime" />，表示消息到达目标队列的时间。 该时间被从 GMT 调整为目标队列驻留的计算机上的本地时间。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 消息的 <xref:System.Messaging.Message.TimeToBeReceived%2A> 属性指示必须从目标队列接收消息的速度。 <xref:System.Messaging.Message.TimeToBeReceived%2A>属性计时器在发送消息时启动，而不是在消息到达队列时启动。  
  
   
  
## Examples  
 下面的代码示例显示消息的属性的值 <xref:System.Messaging.Message.ArrivedTime%2A> 。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
- 或 - 
消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.ArrivedTime" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
      </Docs>
    </Member>
    <Member MemberName="AttachSenderId">
      <MemberSignature Language="C#" Value="public bool AttachSenderId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AttachSenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AttachSenderId" />
      <MemberSignature Language="VB.NET" Value="Public Property AttachSenderId As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AttachSenderId { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AttachSenderId : bool with get, set" Usage="System.Messaging.Message.AttachSenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgAttachSenderId")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgAttachSenderId")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示发送方 ID 是否应附在消息中。</summary>
        <value>如果 <see cref="P:System.Messaging.Message.SenderId" /> 应附在消息中，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SenderId%2A>属性是一个字节数组，表示发送用户的标识符。 发件人 ID 由消息队列设置，接收队列管理器使用该 ID 来验证发送方是否有权访问队列。  
  
 缺少发送方 ID 是由发送应用程序指示的，消息队列不应验证消息的发送方，也不验证发送方对接收队列的访问权限。 <xref:System.Messaging.Message.SenderId%2A>仅当消息到达目标队列时已通过身份验证，才可信任。 如果队列仅接受经过身份验证的消息并且 <xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A> 或属性为，则消息在到达目标队列时被拒绝 <xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A> `false` 。  
  
> [!CAUTION]
>  如果消息被拒绝，则会将消息发送到死信队列 (如果) ，则会将其 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> `true` 忽略。 如果消息无法到达队列，可以请求确认。 否则，如果 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 为，则 `false` 消息可能会丢失，并且不发出警告。  
  
   
  
## Examples  
 下面的代码示例获取并设置消息的属性的值 <xref:System.Messaging.Message.AttachSenderId%2A> 。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.AttachSenderId" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.SenderId" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="Authenticated">
      <MemberSignature Language="C#" Value="public bool Authenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticated" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Authenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Authenticated : bool" Usage="System.Messaging.Message.Authenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgAuthenticated")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgAuthenticated")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示消息是否已验证。</summary>
        <value>如果在消息进入队列时请求了验证，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Authenticated%2A>仅当应用程序与消息进行交互并尝试确定是否请求身份验证时，该属性才使用此属性。 如果消息在队列中，则会对消息进行身份验证。 相反，如果 <xref:System.Messaging.Message.Authenticated%2A> 属性为 `true` ，则接收队列管理器在收到消息时对消息进行了身份验证。  
  
 通过查看消息的属性，不能确定消息是否失败。 消息队列在将身份验证传递到队列之前，会丢弃这些消息。 但是，如果传递失败阻止消息到达队列，你可以请求发送确认消息。  
  
   
  
## Examples  
 下面的代码示例显示消息的属性的值 <xref:System.Messaging.Message.Authenticated%2A> 。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
- 或 - 
消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.Authenticated" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderName">
      <MemberSignature Language="C#" Value="public string AuthenticationProviderName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AuthenticationProviderName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderName" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AuthenticationProviderName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderName : string with get, set" Usage="System.Messaging.Message.AuthenticationProviderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgAuthenticationProviderName")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgAuthenticationProviderName")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于生成消息数字签名的加密提供程序的名称。</summary>
        <value>用于生成消息数字签名的加密提供程序的名称。 默认值为 Microsoft 基础加密提供程序版本 1.0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Messaging.Message.AuthenticationProviderName%2A> 外部队列时，通常使用。 消息队列需要身份验证提供程序的名称和身份验证提供程序类型 (身份验证提供程序) 验证发送到外部队列的消息的数字签名以及从外部队列传递到消息队列的消息。  
  
 发送消息时，请始终同时设置 <xref:System.Messaging.Message.AuthenticationProviderName%2A> 和 <xref:System.Messaging.Message.ConnectorType%2A> 属性。 发送消息时，如果未同时设置连接器类型，则消息队列将忽略身份验证提供程序名称。  
  
 <xref:System.Messaging.Message.AuthenticationProviderName%2A>属性不能为 `null` ，但它可以是空字符串 ( "" ) 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未能设置 <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> 属性。  
  
- 或 - 
消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> 属性。</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.AuthenticationProviderName" /> 被设置成了 <see langword="null" />。</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderType">
      <MemberSignature Language="C#" Value="public System.Messaging.CryptographicProviderType AuthenticationProviderType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.CryptographicProviderType AuthenticationProviderType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderType" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderType As CryptographicProviderType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::CryptographicProviderType AuthenticationProviderType { System::Messaging::CryptographicProviderType get(); void set(System::Messaging::CryptographicProviderType value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderType : System.Messaging.CryptographicProviderType with get, set" Usage="System.Messaging.Message.AuthenticationProviderType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgAuthenticationProviderType")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgAuthenticationProviderType")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.CryptographicProviderType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于生成消息数字签名的加密提供程序类型。</summary>
        <value><see cref="T:System.Messaging.CryptographicProviderType" /> 值之一。 默认值为 <see langword="RSA_FULL" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Messaging.Message.AuthenticationProviderType%2A> 外部队列时，通常使用属性来指定与消息关联的加密服务提供程序。 消息队列需要身份验证提供程序的名称和身份验证提供程序类型 (身份验证提供程序) 验证发送到外部队列的消息的数字签名以及从外部队列传递到消息队列的消息。  
  
 仅 `RsaFull` 适用于消息传送。  
  
 发送消息时，请始终同时设置 <xref:System.Messaging.Message.AuthenticationProviderType%2A> 和 <xref:System.Messaging.Message.ConnectorType%2A> 属性。 发送消息时，如果未同时设置连接器类型，则消息队列将忽略身份验证提供程序类型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未能设置 <see cref="P:System.Messaging.Message.AuthenticationProviderType" /> 属性。  
  
- 或 - 
消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.AuthenticationProviderType" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.CryptographicProviderType" />
      </Docs>
    </Member>
    <Member MemberName="Body">
      <MemberSignature Language="C#" Value="public object Body { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Body" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Body" />
      <MemberSignature Language="VB.NET" Value="Public Property Body As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Body { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Body : obj with get, set" Usage="System.Messaging.Message.Body" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置消息的内容。</summary>
        <value>指定消息内容的对象。 该对象可以是字符串、日期、货币、数字、字节数组或任何托管对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 消息的 <xref:System.Messaging.Message.Body%2A> 属性通常包含与消息关联的数据。 尽管你还可以在和属性中发送应用程序特定的数据 <xref:System.Messaging.Message.AppSpecific%2A> <xref:System.Messaging.Message.Extension%2A> ，但应尽可能在消息中包含消息数据 <xref:System.Messaging.Message.Body%2A> 。 仅对 <xref:System.Messaging.Message.Body%2A> 属性内容进行序列化或加密。  
  
 <xref:System.Messaging.Message.Body%2A>属性可包含任何大小不超过 4 MB 的对象。 如果你使用将 <xref:System.Messaging.MessageQueue.Send%2A?displayProperty=nameWithType> 不属于类型的任何对象发送 <xref:System.Messaging.Message> 到，则 <xref:System.Messaging.MessageQueue> 该对象将位于 <xref:System.Messaging.Message.Body%2A> <xref:System.Messaging.Message> 由或返回的实例的属性中 <xref:System.Messaging.MessageQueue.Peek%2A> <xref:System.Messaging.MessageQueue.Receive%2A> 。  
  
 中的字符串自变量 `MessageQueue.Send("hello.")` 是此类泛型对象的一个示例。  
  
 <xref:System.Messaging.Message.BodyType%2A>属性指示消息正文中存储的信息的类型。 消息队列使用此信息来标识属性内容的类型 <xref:System.Messaging.Message.Body%2A> 。  
  
 <xref:System.Messaging.Message.Body%2A>发送对象之前，请指定属性或 <xref:System.Messaging.Message.BodyStream%2A> 属性 <xref:System.Messaging.Message> 。 <xref:System.Messaging.Message.Body%2A>属性可以是任何可序列化对象，例如文本字符串、结构对象、类实例或嵌入的对象。  
  
 除非将消息内容直接写入 <xref:System.Messaging.Message.BodyStream%2A> 属性，否则在 <xref:System.Messaging.Message.Formatter%2A> 发送消息之前，请设置属性。 在 <xref:System.Messaging.MessageQueue.Send%2A> 实例上调用方法时 <xref:System.Messaging.MessageQueue> ，使用属性中包含的格式化程序对正文进行序列化 <xref:System.Messaging.Message.Formatter%2A> 。 如果在未指定属性值的情况下发送消息 <xref:System.Messaging.Message.Formatter%2A> ，则格式化程序默认为 <xref:System.Messaging.XmlMessageFormatter> 。  
  
> [!NOTE]
>  <xref:System.Decimal.MaxValue> <xref:System.OverflowException> 如果 `Send` <xref:System.Messaging.MessageQueue> 调用类的方法并 <xref:System.Messaging.ActiveXMessageFormatter> 使用，则尝试将消息的正文设置为将导致。  
  
   
  
## Examples  
 下面的代码示例将两个不同优先级的消息发送到队列，然后检索它们。  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Messaging.Message.Formatter" /> 属性为 <see langword="null" />。  
  
- 或 - 
消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.Body" /> 属性。</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BodyStream { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BodyStream" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyStream" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BodyStream { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BodyStream : System.IO.Stream with get, set" Usage="System.Messaging.Message.BodyStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgBodyStream")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgBodyStream")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName Language="C#">[System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置消息正文中的信息。</summary>
        <value><see cref="T:System.IO.Stream" />，包含消息的 <see cref="P:System.Messaging.Message.Body" /> 中包括的已序列化信息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 消息的正文可以包含任何类型的信息（例如，字符串、日期、货币、数字、字节数组或任何托管对象）。 此信息将序列化为 <xref:System.IO.Stream> 要传递到队列的。  
  
 <xref:System.Messaging.Message.Body%2A>发送对象之前，请指定属性或 <xref:System.Messaging.Message.BodyStream%2A> 属性 <xref:System.Messaging.Message> 。 如果设置了 <xref:System.Messaging.Message.Body%2A> 属性，则会将内容序列化到 <xref:System.Messaging.Message.BodyStream%2A> 属性中。 不过，您可以选择 <xref:System.Messaging.Message.BodyStream%2A> 直接编写属性。 这很有用，例如，当你想要打开到文件的连接并将其内容流式传输为消息正文时，这很有用。  
  
 除非将消息内容直接写入 <xref:System.Messaging.Message.BodyStream%2A> 属性，否则在 <xref:System.Messaging.Message.Formatter%2A> 发送消息之前，请设置属性。 在 <xref:System.Messaging.MessageQueue.Send%2A> 实例上调用方法时 <xref:System.Messaging.MessageQueue> ，使用属性中包含的格式化程序对正文进行序列化 <xref:System.Messaging.Message.Formatter%2A> 。 如果在未指定属性值的情况下发送消息 <xref:System.Messaging.Message.Formatter%2A> ，则格式化程序默认为 <xref:System.Messaging.XmlMessageFormatter> 。  
  
 如果将 <xref:System.Messaging.Message.UseEncryption%2A> 此消息正文的属性设置为，则在 `true` 发送消息时将加密该消息，而不是在设置属性时加密 <xref:System.Messaging.Message.Body%2A> 。 因此，永远不会 <xref:System.Messaging.Message.BodyStream%2A> 加密该属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.Body" /> 属性。</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyType">
      <MemberSignature Language="C#" Value="public int BodyType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BodyType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyType" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyType As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BodyType { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BodyType : int with get, set" Usage="System.Messaging.Message.BodyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgBodyType")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgBodyType")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置消息正文所包含数据的类型。</summary>
        <value>消息体的真实类型，如字符串、日期、货币或数字。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 消息队列将正文内容识别为对象或序列化流。 <xref:System.Messaging.Message.BodyType%2A>属性指示消息的属性中的对象的类型 <xref:System.Messaging.Message.Body%2A> 。  
  
 在 <xref:System.Messaging.XmlMessageFormatter> 本机类型与消息体中的对象之间执行绑定。 如果使用，则 <xref:System.Messaging.XmlMessageFormatter> 格式化程序将 <xref:System.Messaging.Message.BodyType%2A> 为您设置属性。  
  
 其他格式化程序还可以提供绑定功能，如下面的 c # 代码中所示。  
  
```  
message.Formatter = new ActiveXMessageFormatter();  
object myObject message.Body;  
if (myObject is string) {  
}  
if (myObject is int) {  
}  
if (myObject is float) {  
}  
```  
  
   
  
## Examples  
 下面的代码示例显示消息的属性的值 <xref:System.Messaging.Message.BodyType%2A> 。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.Body" /> 属性。</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ConnectorType">
      <MemberSignature Language="C#" Value="public Guid ConnectorType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ConnectorType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ConnectorType" />
      <MemberSignature Language="VB.NET" Value="Public Property ConnectorType As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid ConnectorType { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectorType : Guid with get, set" Usage="System.Messaging.Message.ConnectorType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgConnectorType")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgConnectorType")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示由发送应用程序设置通常由消息队列设置的某些消息属性。</summary>
        <value>由应用程序定义的 <see cref="T:System.Guid" />，与连接器应用程序或消息加密一起使用。 此 <see cref="T:System.Guid" /> 允许接收应用程序解释由发送应用程序设置、但通常由消息队列设置的消息属性。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.ConnectorType%2A>每当应用程序设置通常由消息队列设置的消息属性时，消息队列都需要设置属性。 在以下两种情况下，应用程序通常使用 <xref:System.Messaging.Message.ConnectorType%2A> ：  
  
-   每当连接器应用程序传递消息时。 <xref:System.Messaging.Message.ConnectorType%2A>通知发送和接收应用程序如何解释消息的安全和确认属性。  
  
-   只要发送应用程序（而不是消息队列），就会对消息进行加密。 <xref:System.Messaging.Message.ConnectorType%2A>指示消息队列使用 <xref:System.Messaging.Message.DestinationSymmetricKey%2A> 属性值对消息进行解密。  
  
 <xref:System.Messaging.Message.ConnectorType%2A>如果设置以下任何属性，则必须设置属性 (否则，在发送消息时，队列将忽略这些属性) ：  
  
-   <xref:System.Messaging.Message.AuthenticationProviderName%2A>  
  
-   <xref:System.Messaging.Message.AuthenticationProviderType%2A>  
  
-   <xref:System.Messaging.Message.DestinationSymmetricKey%2A>  
  
-   <xref:System.Messaging.Message.DigitalSignature%2A>  
  
-   <xref:System.Messaging.Message.MessageType%2A>  
  
-   <xref:System.Messaging.Message.SenderId%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.ConnectorType" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DestinationSymmetricKey" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.Message.SenderId" />
      </Docs>
    </Member>
    <Member MemberName="CorrelationId">
      <MemberSignature Language="C#" Value="public string CorrelationId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CorrelationId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.CorrelationId" />
      <MemberSignature Language="VB.NET" Value="Public Property CorrelationId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CorrelationId { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CorrelationId : string with get, set" Usage="System.Messaging.Message.CorrelationId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgCorrelationId")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgCorrelationId")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置确认、报告和响应消息用以引用原始消息的消息标识符。</summary>
        <value>原始消息的 <see cref="P:System.Messaging.Message.Id" /> 属性指定的消息标识符。 消息队列在生成确认或报告消息时使用相关标识符；而应用程序在生成响应消息时使用相关标识符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当消息队列生成确认或报告消息时，它使用相关标识符属性来指定原始消息的消息标识符。 这样，相关标识符就可将报告或确认消息与原始消息关联起来。  
  
 然后，发送应用程序可以通过使用 <xref:System.Messaging.Message.CorrelationId%2A> 属性标识原始消息的属性，将确认或报告与原始消息相匹配 <xref:System.Messaging.Message.Id%2A> 。  
  
 连接器应用程序还必须将 <xref:System.Messaging.Message.CorrelationId%2A> 确认和报告消息的属性设置为原始消息的消息标识符。  
  
 当应用程序将响应消息发送到发送应用程序时，可以将 <xref:System.Messaging.Message.CorrelationId%2A> 响应消息的属性设置为原始消息的消息标识符。 然后，发送应用程序可以将响应消息与发送的消息相匹配。  
  
   
  
## Examples  
 下面的代码示例在队列中发送和接收包含订单的消息。 当原始消息到达或从队列中检索时，它专门请求肯定确认。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.CorrelationId" /> 属性。</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.CorrelationId" /> 为 <see langword="null" />。</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DestinationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue DestinationQueue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue DestinationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationQueue" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DestinationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ DestinationQueue { System::Messaging::MessageQueue ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DestinationQueue : System.Messaging.MessageQueue" Usage="System.Messaging.Message.DestinationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgDestinationQueue")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgDestinationQueue")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取消息的预期目标队列。</summary>
        <value><see cref="T:System.Messaging.MessageQueue" />，指定消息的预期目标队列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.DestinationQueue%2A>属性最常用于确定到达日志或死信队列的消息的原始目标。 通常不需要检查此属性，因为通常从其目标队列检索消息。  
  
   
  
## Examples  
 下面的代码示例显示消息的属性的值 <xref:System.Messaging.Message.DestinationQueue%2A> 。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
- 或 - 
消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.DestinationQueue" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="DestinationSymmetricKey">
      <MemberSignature Language="C#" Value="public byte[] DestinationSymmetricKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DestinationSymmetricKey" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationSymmetricKey" />
      <MemberSignature Language="VB.NET" Value="Public Property DestinationSymmetricKey As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DestinationSymmetricKey { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DestinationSymmetricKey : byte[] with get, set" Usage="System.Messaging.Message.DestinationSymmetricKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgDestinationSymmetricKey")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgDestinationSymmetricKey")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于对应用程序加密的消息或发送到外部队列的消息进行加密的对称密钥。</summary>
        <value>字节值的数组，指定用于加密消息的目标对称密钥。 默认值为零长度的数组。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 两个方案要求使用 <xref:System.Messaging.Message.DestinationSymmetricKey%2A> 属性。 第一种情况是，应用程序（而不是消息队列）会对消息进行加密。 第二种情况是将加密消息发送到消息队列之外的队列系统。  
  
 在设置此属性之前，必须用接收队列管理器的公钥来加密对称密钥。 发送应用程序加密的消息时，接收队列管理器使用对称密钥对消息进行解密，然后将消息发送到目标队列。  
  
 如果将消息发送到外部队列，则相应的连接器应用程序将首先收到该消息，该应用程序会将加密的消息连同附加的对称密钥转发给接收应用程序。 然后，接收应用程序负责使用对称密钥对消息进行解密。  
  
 设置 <xref:System.Messaging.Message.DestinationSymmetricKey%2A> 属性时，还必须设置 <xref:System.Messaging.Message.ConnectorType%2A> 属性。 发送消息时， <xref:System.Messaging.Message.DestinationSymmetricKey%2A> 如果还未设置该属性，则消息队列将忽略该属性 <xref:System.Messaging.Message.ConnectorType%2A> 。  
  
 <xref:System.Messaging.Message.DestinationSymmetricKey%2A>属性的最大数组大小为256。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> 属性。</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> 为 <see langword="null" />。</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="DigitalSignature">
      <MemberSignature Language="C#" Value="public byte[] DigitalSignature { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DigitalSignature" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DigitalSignature" />
      <MemberSignature Language="VB.NET" Value="Public Property DigitalSignature As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DigitalSignature { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DigitalSignature : byte[] with get, set" Usage="System.Messaging.Message.DigitalSignature" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgDigitalSignature")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgDigitalSignature")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置消息队列用于验证消息的数字签名。</summary>
        <value>字节值的数组，指定用于对消息进行身份验证的消息队列 1.0 数字签名。 默认值为零长度的数组。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 消息队列在对消息队列版本1.0 发送的消息进行身份验证时使用数字签名。 在大多数情况下，消息队列在 <xref:System.Messaging.Message.DigitalSignature%2A> 发送应用程序请求身份验证时生成并设置属性。 接收应用程序使用此属性来检索附加到消息的数字签名。  
  
 在 <xref:System.Messaging.Message.DigitalSignature%2A> 运行消息队列版本2.0 时，只能使用属性。 在请求身份验证时，发送应用程序必须指定消息队列版本1.0 签名。 如果发送应用程序发送消息队列版本2.0 签名，则此属性包含四个字节（每个字节都包含零）的缓冲区。  
  
 <xref:System.Messaging.Message.DigitalSignature%2A> <xref:System.Messaging.Message.SenderCertificate%2A> 发送消息时，连接器应用程序也使用属性和属性。 在此方案中，连接器应用程序（而不是消息队列）生成数字签名，它基于发送消息的用户的证书。  
  
 <xref:System.Messaging.Message.DigitalSignature%2A>属性的最大数组大小为256。  
  
 设置 <xref:System.Messaging.Message.DigitalSignature%2A> 属性时，还必须设置 <xref:System.Messaging.Message.ConnectorType%2A> 属性。 发送消息时， <xref:System.Messaging.Message.DigitalSignature%2A> 如果还未设置该属性，则消息队列将忽略该属性 <xref:System.Messaging.Message.ConnectorType%2A> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.DigitalSignature" /> 属性。</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.DigitalSignature" /> 属性为 <see langword="null" />。</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionAlgorithm EncryptionAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionAlgorithm EncryptionAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.EncryptionAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionAlgorithm As EncryptionAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionAlgorithm EncryptionAlgorithm { System::Messaging::EncryptionAlgorithm get(); void set(System::Messaging::EncryptionAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionAlgorithm : System.Messaging.EncryptionAlgorithm with get, set" Usage="System.Messaging.Message.EncryptionAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgEncryptionAlgorithm")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgEncryptionAlgorithm")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于加密私有消息体的加密算法。</summary>
        <value><see cref="T:System.Messaging.EncryptionAlgorithm" /> 枚举值之一。 默认值为 <see langword="RC2" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 (加密的) 消息是私有的，则会在收到消息之前对其进行加密。 <xref:System.Messaging.Message.EncryptionAlgorithm%2A>属性指定用于对专用消息的消息正文进行加密的算法。  
  
 队列可能要求对传入消息进行加密。 如果应用程序将非加密 (非私有) 消息发送到只接受专用消息的队列，或将专用消息发送到只接受非私有消息的队列，则队列将拒绝该消息。 发送应用程序可以请求在这种情况下返回否定确认消息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.EncryptionAlgorithm" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="T:System.Messaging.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="Extension">
      <MemberSignature Language="C#" Value="public byte[] Extension { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Extension" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Extension" />
      <MemberSignature Language="VB.NET" Value="Public Property Extension As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Extension { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Extension : byte[] with get, set" Usage="System.Messaging.Message.Extension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgExtension")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgExtension")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置与消息关联的、应用程序定义的附加信息。</summary>
        <value>字节值的数组，提供与消息关联的、应用程序定义的信息。 默认值为零长度的数组。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Extension%2A>属性提供与消息关联的应用程序定义的信息（如大型二进制对象）。 接收应用程序负责解释属性的内容 <xref:System.Messaging.Message.Extension%2A> 。  
  
 如果可能，应在 <xref:System.Messaging.Message.Body%2A> 消息的属性中（而不是属性）中包含消息数据 <xref:System.Messaging.Message.Extension%2A> 。  
  
 使用外部队列时，请使用 <xref:System.Messaging.Message.Extension%2A> 属性来指定消息队列中不存在的消息属性。  
  
 在非 Microsoft 消息队列的队列系统中存在一个外部队列。 消息队列通过连接器应用程序与此类队列通信。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.Extension" /> 属性。</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.Extension" /> 属性为 <see langword="null" />。</exception>
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.Message.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于将对象序列化到消息体中，或从消息体中反序列化对象的格式化程序。</summary>
        <value>该 <see cref="T:System.Messaging.IMessageFormatter" /> 产生要写入消息体或要从消息体中读取的流。 默认值为 <see cref="T:System.Messaging.XmlMessageFormatter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Formatter%2A>在读取和写入消息时使用属性。 将消息发送到队列时，格式化程序会将属性序列化为 <xref:System.Messaging.Message.Body%2A> 可发送到消息队列的流。 从队列中进行读取时，格式化程序将消息数据反序列化为 <xref:System.Messaging.Message.Body%2A> 属性。  
  
 除非将消息内容直接写入 <xref:System.Messaging.Message.BodyStream%2A> 属性，否则在 <xref:System.Messaging.Message.Formatter%2A> 发送消息之前，请设置属性。 在 <xref:System.Messaging.MessageQueue.Send%2A> 实例上调用方法时 <xref:System.Messaging.MessageQueue> ，使用属性中包含的格式化程序对正文进行序列化 <xref:System.Messaging.Message.Formatter%2A> 。 如果在未指定属性值的情况下发送消息 <xref:System.Messaging.Message.Formatter%2A> ，则格式化程序默认为 <xref:System.Messaging.XmlMessageFormatter> 。  
  
 <xref:System.Messaging.XmlMessageFormatter>是松散耦合的，因此在使用此格式时，不需要在发送方和接收方上具有相同的对象类型。 将 <xref:System.Messaging.ActiveXMessageFormatter> <xref:System.Messaging.BinaryMessageFormatter> 数据序列化为二进制表示形式。 在 <xref:System.Messaging.ActiveXMessageFormatter> 发送或接收 COM 组件时使用。  
  
   
  
## Examples  
 下面的代码示例演示如何使用格式化消息正文 <xref:System.Messaging.BinaryMessageFormatter> 。  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 下面的代码示例演示如何使用格式化消息正文 <xref:System.Messaging.XmlMessageFormatter> 。  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.Formatter" /> 属性为 <see langword="null" />。</exception>
        <altmember cref="M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.MessageQueue.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.HashAlgorithm HashAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.HashAlgorithm HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property HashAlgorithm As HashAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::HashAlgorithm HashAlgorithm { System::Messaging::HashAlgorithm get(); void set(System::Messaging::HashAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.HashAlgorithm : System.Messaging.HashAlgorithm with get, set" Usage="System.Messaging.Message.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgHashAlgorithm")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgHashAlgorithm")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.HashAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置消息队列在验证消息或为消息创建数字签名时使用的哈希算法。</summary>
        <value><see cref="T:System.Messaging.HashAlgorithm" /> 枚举值之一。 对于 Windows XP，默认值为 <see langword="SHA" />。 否则默认值为 <see langword="MD5" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在源计算机上，消息队列在为消息创建数字签名时使用哈希算法。 然后，目标队列管理器使用相同的哈希算法在收到消息时对消息进行身份验证。  

 由于 MD5 和 SHA1 出现冲突，Microsoft 建议 SHA256。 
 
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.HashAlgorithm" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : string" Usage="System.Messaging.Message.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgId")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgId")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取消息的标识符。</summary>
        <value>消息的唯一标识符，由消息队列生成。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 发送消息时，消息队列会生成消息标识符。 标识符由20个字节组成，其中包含两个项： <xref:System.Guid> 发送计算机的计算机和计算机上消息的唯一标识符。 这两项组合在一起，就产生了一个在网络上唯一的消息标识符。  
  
 消息队列为所有消息（包括确认消息和报告消息）生成消息标识符。 确认消息通常由消息队列发送，以反映原始消息的到达或失败。 可以 <xref:System.Messaging.Message.Id%2A> 在确认消息的属性中找到原始消息的属性值 <xref:System.Messaging.Message.CorrelationId%2A> 。  
  
 将 <xref:System.Messaging.Message.Id%2A> 响应消息发送到响应队列时，还可以使用属性。 若要在响应消息中包含原始消息的标识符，请将 <xref:System.Messaging.Message.CorrelationId%2A> 响应消息的属性设置为 <xref:System.Messaging.Message.Id%2A> 原始消息的属性。 然后，读取响应消息的应用程序可以使用响应消息的相关标识符来标识原始消息。  
  
   
  
## Examples  
 下面的代码示例在队列中发送和接收包含订单的消息。 当原始消息到达或从队列中检索时，它专门请求肯定确认。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
- 或 - 
消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.Id" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.Message.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.Message.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定不存在超时。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A> 和 <xref:System.Messaging.Message.TimeToReachQueue%2A> 需要一个指定超时值的值。对于前一种情况，超时是指从队列中接收消息所允许的最长时间。 对于后一种情况，超时是指允许消息到达队列的时间。 在这两种情况下，可以指定超时值（以秒为单位），也可以使用 <xref:System.Messaging.Message.InfiniteTimeout> 指示不存在超时。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Messaging.Message.InfiniteTimeout> 字段。  
  
  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
      </Docs>
    </Member>
    <Member MemberName="IsFirstInTransaction">
      <MemberSignature Language="C#" Value="public bool IsFirstInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFirstInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsFirstInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFirstInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFirstInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFirstInTransaction : bool" Usage="System.Messaging.Message.IsFirstInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgIsFirstInTransaction")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgIsFirstInTransaction")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示消息是否是事务中发送的第一条消息。</summary>
        <value>如果消息是事务中发送的第一条消息，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接收应用程序使用 <xref:System.Messaging.Message.IsFirstInTransaction%2A> 属性来验证消息是否是在单个事务中发送到单个队列的第一条消息。  
  
 此属性仅适用于消息队列版本2.0 及更高版本。  
  
 若要验证事务边界，可以结合使用 <xref:System.Messaging.Message.IsFirstInTransaction%2A> 属性和两个其他属性： <xref:System.Messaging.Message.IsLastInTransaction%2A> 和 <xref:System.Messaging.Message.TransactionId%2A> 。 使用前者检查消息是否是事务中发送的最后一条消息，并使用后者来检索事务的标识符。  
  
 如果在事务中只发送一条消息，则 <xref:System.Messaging.Message.IsFirstInTransaction%2A> 和 <xref:System.Messaging.Message.IsLastInTransaction%2A> 属性都设置为 `true` 。  
  
   
  
## Examples  
 下面的代码示例显示消息的属性的值 <xref:System.Messaging.Message.IsFirstInTransaction%2A> 。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
- 或 - 
消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.IsFirstInTransaction" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="IsLastInTransaction">
      <MemberSignature Language="C#" Value="public bool IsLastInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLastInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsLastInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLastInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLastInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLastInTransaction : bool" Usage="System.Messaging.Message.IsLastInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgIsLastInTransaction")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgIsLastInTransaction")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示消息是否是事务中发送的最后一条消息。</summary>
        <value>如果消息是单个事务中发送的最后一条消息，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接收应用程序使用 <xref:System.Messaging.Message.IsLastInTransaction%2A> 属性来验证消息是否是在单个事务中发送到单个队列的最后一条消息。  
  
 此属性仅适用于消息队列版本2.0 及更高版本。  
  
 若要验证事务边界，可以结合使用 <xref:System.Messaging.Message.IsLastInTransaction%2A> 属性和两个其他属性： <xref:System.Messaging.Message.IsFirstInTransaction%2A> 和 <xref:System.Messaging.Message.TransactionId%2A> 。 使用前者检查消息是否是事务中发送的第一条消息，并使用后者来检索事务的标识符。  
  
 如果在事务中只发送一条消息，则 <xref:System.Messaging.Message.IsFirstInTransaction%2A> 和 <xref:System.Messaging.Message.IsLastInTransaction%2A> 属性都设置为 `true` 。  
  
   
  
## Examples  
 下面的代码示例显示消息的属性的值 <xref:System.Messaging.Message.IsLastInTransaction%2A> 。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
- 或 - 
消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.IsLastInTransaction" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.Message.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgLabel")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgLabel")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置描述消息的应用程序定义的 Unicode 字符串。</summary>
        <value>消息的标签。 默认值为空字符串("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 消息标签有多种用途。 例如，可用于显示消息，或根据标签值有选择地处理消息。 此标签在消息中不必是唯一的。  
  
 消息队列和消息标签表示一个应用程序定义的值，可利用该值将标识队列或消息用人可识别的词条标识出来。 应用程序负责解释标签内容，这对 "消息队列" 应用程序没有内部意义。  
  
   
  
## Examples  
 下面的代码示例获取并设置消息的属性的值 <xref:System.Messaging.Message.Label%2A> 。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.Label" /> 属性。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName="LookupId">
      <MemberSignature Language="C#" Value="public long LookupId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LookupId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.LookupId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LookupId As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LookupId { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LookupId : int64" Usage="System.Messaging.Message.LookupId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 MSMQ 3.0 中引入。 获取消息的查找标识符。</summary>
        <value>消息的查找标识符，由消息队列生成，对消息驻留的队列是唯一的。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.LookupId%2A>属性提供对消息查找标识符的只读访问。 MSMQ 3.0 中引入的查找标识符是一个64位标识符，由消息队列生成并在消息放入队列中时分配给每个消息。 查找标识符不同于发送消息时生成的消息标识符。  
  
 消息队列为放置在任何队列中的所有消息生成一个查找标识符，包括应用程序生成的目标、管理和报表队列，以及系统生成的日志、死信、连接器和传出队列。 换句话说，这包括通过发送应用程序和消息队列发送的消息。 查找标识符对于队列是唯一的，在队列外没有意义。  
  
 如果将一条消息发送到多个目标队列，或将消息的副本存储在计算机日志或队列日志中，则该消息的每个副本都将具有自己的查找标识符，同时将其放入各自的队列中。  
  
 <xref:System.Messaging.Message.LookupId%2A>仅可对从队列中检索到的消息读取属性。  
  
 查找标识符用于读取队列中的特定消息。 已知消息的查找标识符后，接收方应用程序可以调用 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 或 <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> 函数直接转到该消息，并从队列中查看或检索该消息，这不同于必须从队列的前面开始并导航到队列末尾的游标。  
  
 获取队列中消息的查找标识符是应用程序的责任。 获取查找标识符的一种可行方法是为目标队列创建一个触发器，以便在将每条消息放置到队列中时调用该组件来缓存每个消息的标识符。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">未安装 MSMQ 3.0。</exception>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
- 或 - 
消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.LookupId" /> 属性。</exception>
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="MessageType">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageType MessageType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessageType MessageType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.MessageType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MessageType As MessageType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageType MessageType { System::Messaging::MessageType get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageType : System.Messaging.MessageType" Usage="System.Messaging.Message.MessageType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgMessageType")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgMessageType")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取消息类型：<see langword="Normal" />、<see langword="Acknowledgment" /> 或 <see langword="Report" />。</summary>
        <value><see cref="P:System.Messaging.Message.MessageType" /> 值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 消息队列通常在发送消息时设置此属性。 消息队列消息可以是下列类型之一：  
  
-   `Normal`，它是从应用程序发送到队列的典型消息，或返回给发送应用程序的响应消息。  
  
-   `Acknowledgement`，在发送应用程序请求消息时，将生成消息队列。 例如，消息队列可生成肯定消息或否定消息，以指示原始消息已到达或已被读取。 消息队列会将相应的确认消息返回到发送应用程序所指定的管理队列。  
  
-   `Report`，只要在源队列管理器中定义了报表队列，消息队列就会生成。 如果启用了跟踪，则每当原始消息进入或离开消息队列服务器时，消息队列都会向消息队列报告队列发送报告消息。  
  
   
  
## Examples  
 下面的代码示例显示消息的属性的值 <xref:System.Messaging.Message.MessageType%2A> 。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
- 或 - 
消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.MessageType" /> 属性。</exception>
        <altmember cref="T:System.Messaging.MessageType" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessagePriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As MessagePriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePriority Priority { System::Messaging::MessagePriority get(); void set(System::Messaging::MessagePriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Messaging.MessagePriority with get, set" Usage="System.Messaging.Message.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgPriority")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgPriority")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置消息优先级，该优先级用于确定消息在队列中的位置。</summary>
        <value><see cref="T:System.Messaging.MessagePriority" /> 值之一，表示非事务性消息的优先级。 默认值为 <see langword="Normal" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Priority%2A>属性会影响消息队列在消息传送过程中以及到达其目标后如何处理消息。 在路由过程中，优先级高的消息具有优先权，将会插入到目标队列的队首。 而具有相同优先级的消息则会按照到达的先后时间插入到队列中。  
  
 只能为非事务性消息设置有意义的优先级。 消息队列会将事务性消息的优先级自动设置为 `Lowest` ，从而导致忽略事务性消息的优先级。  
  
   
  
## Examples  
 下面的代码示例将两个不同优先级的消息发送到队列，然后检索它们。  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.Priority" /> 属性。</exception>
        <altmember cref="T:System.Messaging.MessagePriority" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.MessageQueue.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="Recoverable">
      <MemberSignature Language="C#" Value="public bool Recoverable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Recoverable" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Recoverable" />
      <MemberSignature Language="VB.NET" Value="Public Property Recoverable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Recoverable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Recoverable : bool with get, set" Usage="System.Messaging.Message.Recoverable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgRecoverable")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgRecoverable")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示在出现计算机故障或网络问题时是否保证传递消息。</summary>
        <value>如果通过在消息传递过程中将消息保存到磁盘上来保证消息的传递，则为 <see langword="true" />；如果不能保证传递，则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Recoverable%2A>属性指示消息的传递是否得到保证，即使在消息发送到目标队列的过程中出现计算机崩溃。  
  
 如果保证消息的传递，则会在路由过程中的每个步骤本地存储消息，直到将消息成功转发到下一台计算机。 将 <xref:System.Messaging.Message.Recoverable%2A> 属性设置为 `true` 可能会影响吞吐量。  
  
 如果消息是事务性的，消息队列会自动将消息视为可恢复消息，而不考虑属性的值 <xref:System.Messaging.Message.Recoverable%2A> 。  
  
   
  
## Examples  
 下面的代码示例获取并设置消息的属性的值 <xref:System.Messaging.Message.Recoverable%2A> 。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.Recoverable" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="ResponseQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue ResponseQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue ResponseQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ResponseQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property ResponseQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ ResponseQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResponseQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.ResponseQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgResponseQueue")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgResponseQueue")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置接收应用程序生成的响应消息的队列。</summary>
        <value>应用程序生成的响应消息所返回到的 <see cref="T:System.Messaging.MessageQueue" />。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.ResponseQueue%2A>属性标识接收应用程序生成的响应消息的队列，接收方应用程序将该消息返回给发送应用程序。 当应用程序发送其消息时，发送应用程序会指定响应队列。 任何可用队列均可指定为响应队列。  
  
 返回到响应队列的消息是应用程序特定的。 应用程序必须定义消息的内容以及收到消息时采取的操作。  
  
   
  
## Examples  
 下面的代码示例获取并设置消息的属性的值 <xref:System.Messaging.Message.ResponseQueue%2A> 。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.ResponseQueue" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
      </Docs>
    </Member>
    <Member MemberName="SecurityContext">
      <MemberSignature Language="C#" Value="public System.Messaging.SecurityContext SecurityContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.SecurityContext SecurityContext" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Property SecurityContext As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::SecurityContext ^ SecurityContext { System::Messaging::SecurityContext ^ get(); void set(System::Messaging::SecurityContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityContext : System.Messaging.SecurityContext with get, set" Usage="System.Messaging.Message.SecurityContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置消息的安全上下文。</summary>
        <value>如果以前曾经设置该属性，则为 <see cref="T:System.Messaging.SecurityContext" /> 对象，其中包含用于消息的安全上下文；否则为 NULL。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SenderCertificate">
      <MemberSignature Language="C#" Value="public byte[] SenderCertificate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Property SenderCertificate As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderCertificate { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SenderCertificate : byte[] with get, set" Usage="System.Messaging.Message.SenderCertificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgSenderCertificate")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgSenderCertificate")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于验证消息的安全证书。</summary>
        <value>表示安全证书的字节值数组，消息队列用该数组验证消息的发送方。 默认值为零长度的数组。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SenderCertificate%2A>当消息包含外部安全证书时，接收应用程序将使用属性。  
  
 消息队列可以使用内部或外部安全证书对消息进行身份验证。 消息队列提供用于验证消息完整性的内部证书。 证书颁发机构提供外部证书，可通过消息的属性访问该证书 <xref:System.Messaging.Message.SenderCertificate%2A> 。 除了允许消息队列对消息进行身份验证外，外部证书还允许接收应用程序进一步验证发送方。 内部证书对于接收应用程序没有可用的值。  
  
 必须向消息队列系统的目录服务注册外部证书。 外部证书包含有关证书颁发机构、证书用户、证书有效期、证书用户公钥和证书颁发机构签名的信息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.SenderCertificate" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
      </Docs>
    </Member>
    <Member MemberName="SenderId">
      <MemberSignature Language="C#" Value="public byte[] SenderId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderId As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderId { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderId : byte[]" Usage="System.Messaging.Message.SenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgSenderId")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgSenderId")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取发送用户的标识符。</summary>
        <value>标识发送方的字节值数组。 接收队列管理器在对消息进行身份验证时使用标识符 — 以验证消息的发送方和发送方对队列的访问权限。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 <xref:System.Messaging.Message.AttachSenderId%2A> 属性为 `false` ，则在发送时，属性中指定的发送方标识符 <xref:System.Messaging.Message.SenderId%2A> 不会附加到消息中。 这会指示消息队列，指出发送方在向目标队列发送消息时不应验证发送方。 如果 <xref:System.Messaging.Message.AttachSenderId%2A> 属性为 `true` ，则只有在 <xref:System.Messaging.Message.SenderId%2A> 对消息进行身份验证时，属性值才是可信任的。 将 <xref:System.Messaging.Message.Authenticated%2A> 属性与属性结合使用 <xref:System.Messaging.Message.SenderId%2A> ，验证发件人的访问权限。  
  
 连接器应用程序是一种应用程序，它使用连接器服务器来提供消息队列与其他队列系统之间的通信。 消息队列需要连接器应用程序来提供发送程序标识。 <xref:System.Messaging.Message.ConnectorType%2A>通过连接器应用程序发送消息时，必须设置属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
- 或 - 
消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.SenderId" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
      </Docs>
    </Member>
    <Member MemberName="SenderVersion">
      <MemberSignature Language="C#" Value="public long SenderVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 SenderVersion" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderVersion As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long SenderVersion { long get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderVersion : int64" Usage="System.Messaging.Message.SenderVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgSenderVersion")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgSenderVersion")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于发送消息的消息队列版本。</summary>
        <value>用于发送消息的消息队列版本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SenderVersion%2A>属性对某些功能很重要。 例如，仅消息队列2.0 和更高版本支持事务处理，并使用数字签名对 MSMQ 1.0 发送的消息进行身份验证。  
  
 发送队列管理器在 <xref:System.Messaging.Message.SenderVersion%2A> 发送消息时设置属性。  
  
   
  
## Examples  
 下面的代码示例显示消息的属性的值 <xref:System.Messaging.Message.SenderVersion%2A> 。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
- 或 - 
消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.SenderVersion" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="SentTime">
      <MemberSignature Language="C#" Value="public DateTime SentTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime SentTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SentTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SentTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime SentTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.SentTime : DateTime" Usage="System.Messaging.Message.SentTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgSentTime")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgSentTime")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取发送计算机上的源队列管理器发送消息的日期和时间。</summary>
        <value>表示消息发送时间的 <see cref="T:System.DateTime" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将 <xref:System.Messaging.Message.SentTime%2A> 属性调整为在其上创建此类的实例的计算机的本地时间 <xref:System.Messaging.Message> 。 此时区可能与源和目标队列的时区不同。  
  
   
  
## Examples  
 下面的代码示例显示消息的属性的值 <xref:System.Messaging.Message.SentTime%2A> 。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
- 或 - 
消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.SentTime" /> 属性。</exception>
      </Docs>
    </Member>
    <Member MemberName="SourceMachine">
      <MemberSignature Language="C#" Value="public string SourceMachine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SourceMachine" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SourceMachine" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SourceMachine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SourceMachine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SourceMachine : string" Usage="System.Messaging.Message.SourceMachine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgSourceMachine")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgSourceMachine")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取发出消息的计算机。</summary>
        <value>发送消息的计算机的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性的格式 <xref:System.Messaging.Message.SourceMachine%2A> 不包括前面两个正斜杠 (\\ \\) 。 例如， `myServer` 是有效的 <xref:System.Messaging.Message.SourceMachine%2A> 。  
  
   
  
## Examples  
 下面的代码示例显示消息的属性的值 <xref:System.Messaging.Message.SourceMachine%2A> 。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
- 或 - 
消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.SourceMachine" /> 属性。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">未能访问计算机信息和目录服务。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="TimeToBeReceived">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToBeReceived { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToBeReceived" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToBeReceived" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToBeReceived As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToBeReceived { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToBeReceived : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToBeReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.TimeoutConverter))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.TimeoutConverter))&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgTimeToBeReceived")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgTimeToBeReceived")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置要从目标队列接收消息所需的最长时间。</summary>
        <value>从目标队列接收已发送消息所需的总时间。 默认值为 <see cref="F:System.Messaging.Message.InfiniteTimeout" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A>属性指定从目标队列接收发送消息所用的总时间。 时间限制包括获取目标队列所用的时间，以及在接收消息之前在队列中等待的时间。  
  
> [!CAUTION]
>  使用从属客户端计算机时，请确保客户端计算机上的时钟与运行消息队列的服务器上的时钟同步。 否则，如果发送的消息的属性不是，则可能导致不可预知的行为 <xref:System.Messaging.Message.TimeToBeReceived%2A> <xref:System.Messaging.Message.InfiniteTimeout> 。  
  
 如果 <xref:System.Messaging.Message.TimeToBeReceived%2A> 从队列中删除消息之前，由属性指定的间隔过期，则消息队列将以两种方式之一丢弃该消息。 如果消息的 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 属性为 `true`，则将该消息发送到死信队列。 如果 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 为 `false` ，则忽略该消息。  
  
 如果在计时器过期之前未检索到消息，则可以设置消息的 <xref:System.Messaging.Message.AcknowledgeType%2A> 属性以请求消息队列向发送应用程序发送否定确认消息。  
  
 如果由属性指定的值 <xref:System.Messaging.Message.TimeToBeReceived%2A> 小于属性指定的值 <xref:System.Messaging.Message.TimeToReachQueue%2A> ，则 <xref:System.Messaging.Message.TimeToBeReceived%2A> 优先使用。  
  
 在单个事务中发送多个消息时，消息队列将使用 <xref:System.Messaging.Message.TimeToBeReceived%2A> 第一条消息的属性。  
  
   
  
## Examples  
 下面的代码示例获取并设置消息的属性的值 <xref:System.Messaging.Message.TimeToBeReceived%2A> 。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.TimeToBeReceived" /> 属性。</exception>
        <exception cref="T:System.ArgumentException">为 <see cref="P:System.Messaging.Message.TimeToBeReceived" /> 指定的值无效。</exception>
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TimeToReachQueue">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToReachQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToReachQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToReachQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToReachQueue As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToReachQueue { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToReachQueue : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToReachQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.TimeoutConverter))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.TimeoutConverter))&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgTimeToReachQueue")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgTimeToReachQueue")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置消息到达队列所用的最长时间。</summary>
        <value>从发送消息的时间开始算起，消息到达目标队列的时间限制。 默认值为 <see cref="F:System.Messaging.Message.InfiniteTimeout" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果由属性指定的时间间隔在 <xref:System.Messaging.Message.TimeToReachQueue%2A> 消息到达其目标之前过期，则消息队列将通过以下两种方式之一丢弃消息。 如果消息的 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 属性为 `true`，则将该消息发送到死信队列。 如果 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 为 `false` ，则忽略消息  
  
 <xref:System.Messaging.Message.AcknowledgeType%2A>如果消息不会在计时器过期前到达，则可以设置该消息的属性，请求消息队列向发送应用程序发送否定确认消息。  
  
 如果该 <xref:System.Messaging.Message.TimeToReachQueue%2A> 属性设置为0秒，则消息队列将尝试将消息发送到其目标-如果队列正在等待消息。 如果队列是本地的，则消息始终到达该队列。  
  
 如果由属性指定的值 <xref:System.Messaging.Message.TimeToReachQueue%2A> 大于属性指定的值 <xref:System.Messaging.Message.TimeToBeReceived%2A> ，则 <xref:System.Messaging.Message.TimeToBeReceived%2A> 优先使用。  
  
 在单个事务中发送多个消息时，消息队列将使用 <xref:System.Messaging.Message.TimeToReachQueue%2A> 第一条消息的属性。  
  
   
  
## Examples  
 下面的代码示例获取并设置消息的属性的值 <xref:System.Messaging.Message.TimeToReachQueue%2A> 。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.TimeToReachQueue" /> 属性。</exception>
        <exception cref="T:System.ArgumentException">为 <see cref="P:System.Messaging.Message.TimeToReachQueue" /> 指定的值无效。 它可能表示负数。</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransactionId">
      <MemberSignature Language="C#" Value="public string TransactionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransactionId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TransactionId : string" Usage="System.Messaging.Message.TransactionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgTransactionId")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgTransactionId")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取曾包含消息的事务的标识符。</summary>
        <value>与消息关联的事务的标识符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接收应用程序使用 <xref:System.Messaging.Message.TransactionId%2A> 属性来验证消息是否是作为特定事务的一部分发送的。 事务标识符包含发送计算机的标识符 (前16位) 后跟4个字节的事务序列号。  
  
 此属性仅适用于消息队列版本2.0 及更高版本。  
  
 事务标识符不一定是唯一的，因为事务序列号不是持久的，它们会在 2 <sup>20</sup>重新开始。 消息队列仅保证后续事务具有不同的事务序列号。  
  
 可以结合使用 <xref:System.Messaging.Message.TransactionId%2A> 属性 <xref:System.Messaging.Message.IsFirstInTransaction%2A> 和和 <xref:System.Messaging.Message.IsLastInTransaction%2A> 属性来验证事务边界。  
  
   
  
## Examples  
 下面的代码示例显示消息的属性的值 <xref:System.Messaging.Message.TransactionId%2A> 。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
- 或 - 
消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.TransactionId" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="TransactionStatusQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue TransactionStatusQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue TransactionStatusQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionStatusQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionStatusQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ TransactionStatusQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionStatusQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.TransactionStatusQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgTransactionStatusQueue")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgTransactionStatusQueue")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取源计算机中的事务状态队列。</summary>
        <value>源计算机中的事务状态队列，用于将确认消息发回发送应用程序。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TransactionStatusQueue%2A>属性标识源计算机上的事务队列，该队列接收来自连接器应用程序的已读回执确认。 消息队列在检索发送到外部队列的事务性消息时，将设置属性和连接器应用程序使用属性。  
  
 在非 Microsoft 消息队列的队列系统中存在一个外部队列。 消息队列通过连接器应用程序与此类队列通信。  
  
 连接器应用程序可以使用事务状态队列向发送应用程序发送确认消息。 即使发送应用程序未请求其他确认，事务状态队列也应该接收这些确认。  
  
   
  
## Examples  
 下面的代码示例显示消息的属性的值 <xref:System.Messaging.Message.TransactionStatusQueue%2A> 。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
- 或 - 
消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.TransactionStatusQueue" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
      </Docs>
    </Member>
    <Member MemberName="UseAuthentication">
      <MemberSignature Language="C#" Value="public bool UseAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UseAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseAuthentication { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseAuthentication : bool with get, set" Usage="System.Messaging.Message.UseAuthentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgUseAuthentication")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgUseAuthentication")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示消息发送前是否验证了（或是否必须验证）。</summary>
        <value>如果发送应用程序请求对消息进行验证，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseAuthentication%2A>属性指定是否需要对消息进行身份验证。 如果发送应用程序请求身份验证，则消息队列会创建数字签名，并使用它在发送消息时对消息进行签名，并在收到消息时对消息进行身份验证。  
  
 如果 <xref:System.Messaging.Message.UseAuthentication%2A> 为 `false` 并且向只接受经过身份验证的消息的队列发送消息，则在消息到达队列时将拒绝该消息。  
  
 通过查看消息的属性，不能确定消息是否失败。 消息队列在传递到队列之前会丢弃此类消息。 但是，如果传递失败阻止消息到达队列，则可以请求发送确认消息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.UseAuthentication" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
      </Docs>
    </Member>
    <Member MemberName="UseDeadLetterQueue">
      <MemberSignature Language="C#" Value="public bool UseDeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseDeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseDeadLetterQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseDeadLetterQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDeadLetterQueue : bool with get, set" Usage="System.Messaging.Message.UseDeadLetterQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgUseDeadLetterQueue")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgUseDeadLetterQueue")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否将未能传递的消息的副本发送到死信队列。</summary>
        <value>如果消息传递失败应导致向死信队列发送消息的副本，则为 <see langword="true" />，否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseJournalQueue%2A>和 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 属性指定消息队列跟踪消息的方式。 如果 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 为 `true` ，则) 的非事务性消息 (传递失败将导致消息发送到无法传递消息的计算机上的非事务性死信队列。 例如，消息计时器过期可能会导致传递失败。  
  
 如果事务消息传递失败，则消息队列会在所有负面和有疑问的情况下将消息发送到源计算机上的事务性死信队列。  
  
 将消息存储在死信队列中时，应定期清除队列，以删除不再需要的消息。 死信队列中存储的消息会根据队列所在计算机的大小配额计数。 计算机配额由管理员设置，是指为在整个计算机上存储消息而不只是在单个队列中分配的大小。  
  
 不创建日志或死信队列。 这两个都是消息队列生成的系统队列。  
  
   
  
## Examples  
 下面的代码示例获取并设置消息的属性的值 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.UseDeadLetterQueue" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="UseEncryption">
      <MemberSignature Language="C#" Value="public bool UseEncryption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseEncryption" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseEncryption" />
      <MemberSignature Language="VB.NET" Value="Public Property UseEncryption As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseEncryption { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseEncryption : bool with get, set" Usage="System.Messaging.Message.UseEncryption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgUseEncryption")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgUseEncryption")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否使消息成为私有的。</summary>
        <value>要求消息队列加密消息时为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果消息是私有的，则在发送和解密消息时，消息的正文会被加密。 若要发送专用消息，发送应用程序必须指定使用加密，并根据需要指定加密算法。  
  
 发送专用消息时，应用程序不需要执行消息加密。 如果你的应用程序在 Microsoft Windows 2000 企业内发送消息，并且该企业有权访问目录服务，则消息队列可以为你加密消息正文。 接收专用消息时，接收队列管理器始终会解密消息正文。  
  
   
  
## Examples  
 下面的代码示例获取并设置消息的属性的值 <xref:System.Messaging.Message.UseEncryption%2A> 。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.UseEncryption" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.EncryptionAlgorithm" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.Message.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgUseJournalQueue")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgUseJournalQueue")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否在始发计算机的计算机日记中保留消息的副本。</summary>
        <value>在成功地将消息从始发计算机传输到下一个服务器后，要求在始发计算机的计算机日记中保留消息副本时为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseJournalQueue%2A>和 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 属性指定消息队列跟踪消息的方式。 如果 <xref:System.Messaging.Message.UseJournalQueue%2A> 为 `true` ，则在传输消息的每个步骤中，将副本保存在原始计算机上的计算机日志中。  
  
 如果目标队列位于远程计算机上，则仅将发送的消息复制到日记队列。 如果目标在本地计算机上，则该消息将直接发送到队列;无需执行日记操作的中间步骤。  
  
 在日志队列中存储消息时，请定期清除队列，以删除不再需要的消息。 日志队列中存储的消息会根据队列所在的计算机的配额计数。  (管理员设置计算机配额。 )   
  
 不创建日志或死信队列。 这两个都是消息队列生成的系统队列。  
  
   
  
## Examples  
 下面的代码示例获取并设置消息的属性的值 <xref:System.Messaging.Message.UseJournalQueue%2A> 。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.UseJournalQueue" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="UseTracing">
      <MemberSignature Language="C#" Value="public bool UseTracing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseTracing" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseTracing" />
      <MemberSignature Language="VB.NET" Value="Public Property UseTracing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseTracing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseTracing : bool with get, set" Usage="System.Messaging.Message.UseTracing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Messaging.MessagingDescription("MsgUseTracing")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Messaging.MessagingDescription("MsgUseTracing")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否在消息向目标队列移动的过程中跟踪消息。</summary>
        <value>如果在发往目标队列的过程中，由原始消息产生的每个中间步骤都生成发送给系统报告队列的报告，则为 <see langword="true" />，否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseTracing%2A>属性指定在消息到达目标队列时是否跟踪该消息的路由。 如果为，则每当消息通过 `true` 消息队列路由服务器时，消息队列) 生成的报表消息 (都将发送到报表队列。 报表队列由源队列管理器指定。 报表队列并不限于消息队列生成的报表消息;还可以将应用程序生成的消息发送到报表队列。  
  
 使用跟踪涉及到设置 Active Directory 和为消息队列企业指定报表队列。 管理员配置这些设置。  
  
   
  
## Examples  
 下面的代码示例获取并设置消息的属性的值 <xref:System.Messaging.Message.UseTracing%2A> 。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.UseTracing" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
      </Docs>
    </Member>
  </Members>
</Type>
