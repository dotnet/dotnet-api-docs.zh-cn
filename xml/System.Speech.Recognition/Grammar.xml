<Type Name="Grammar" FullName="System.Speech.Recognition.Grammar">
  <Metadata><Meta Name="ms.openlocfilehash" Value="25b8d731459d1656b619f2e3be089f4763758446" /><Meta Name="ms.sourcegitcommit" Value="c982ad9e10a242d90f1e631b5981570f9e5d9f34" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/10/2020" /><Meta Name="ms.locfileid" Value="89971738" /></Metadata><TypeSignature Language="C#" Value="public class Grammar" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Grammar extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Speech.Recognition.Grammar" />
  <TypeSignature Language="VB.NET" Value="Public Class Grammar" />
  <TypeSignature Language="C++ CLI" Value="public ref class Grammar" />
  <TypeSignature Language="F#" Value="type Grammar = class" />
  <AssemblyInfo>
    <AssemblyName>System.Speech</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Diagnostics.DebuggerDisplay("Grammar: {(_uri != null ? "uri=" + _uri.ToString () + " " : "") + "rule=" + _ruleName }")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerDisplay("Grammar: {(_uri != null ? "uri=" + _uri.ToString () + " " : "") + "rule=" + _ruleName }")&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>引用语音识别语法的运行时对象，应用程序可以用之来定义语音识别的约束。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 语音识别语法是一组规则或约束，用于定义语音识别引擎可识别为有意义的输入的内容。 有关创建和使用语音识别语法的详细信息，请参阅 [语音识别](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14))和 [使用 SrgsGrammar 创建语法](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361680(v%3doffice.14))。  
  
 创作语法之后，必须将其生成到 <xref:System.Speech.Recognition.Grammar> 语音识别引擎可以加载的对象中，且应用程序可以在运行时使用该对象管理语音识别。 可以使用 <xref:System.Speech.Recognition.Grammar.%23ctor%2A> 构造函数 <xref:System.Speech.Recognition.Grammar> 从 <xref:System.Speech.Recognition.GrammarBuilder> 或对象创建实例，也可以使用 <xref:System.Speech.Recognition.SrgsGrammar.SrgsDocument> <xref:System.IO.Stream> 包含受支持格式的语法说明的文件或来创建实例。 支持的格式包括：  
  
-   符合 W3C[语音识别语法规范 (SRGS) 版本 1.0](https://go.microsoft.com/fwlink/?LinkId=201761)的 XML 格式文件  
  
-   已编译为带有 cfg 文件扩展名的二进制文件的语法  
  
 在其参数中接受 XML 格式语法文件的语法构造函数将 XML 语法编译为二进制格式，以优化语音识别引擎的加载和使用。 您可以 <xref:System.Speech.Recognition.Grammar> 通过使用其中一种方法预先编译语法来减少从 XML 格式语法构造对象所需的时间 <xref:System.Speech.Recognition.SrgsGrammar.SrgsGrammarCompiler.Compile%2A> 。  
  
 由或对象管理的应用程序的语音识别引擎 <xref:System.Speech.Recognition.SpeechRecognizer> <xref:System.Speech.Recognition.SpeechRecognitionEngine> 可以加载多个语音识别语法。 应用程序可以通过设置属性独立地启用或禁用各个语法 <xref:System.Speech.Recognition.Grammar.Enabled%2A> ，并通过属性（如 <xref:System.Speech.Recognition.Grammar> 和属性）修改识别 <xref:System.Speech.Recognition.Grammar.Priority%2A> 行为 <xref:System.Speech.Recognition.Grammar.Weight%2A> 。  
  
 <xref:System.Speech.Recognition.Grammar.SpeechRecognized>当输入与语法中的路径相匹配时，将引发语法的事件。  
  
> [!NOTE]
>  最佳做法是验证用于生成对象的任何 URI 或 DLL 的安全性 <xref:System.Speech.Recognition.Grammar> 。  
>   
>  Windows 和语音平台为 <xref:System.Speech.Recognition.Grammar> 从 DLL 或支持脚本编写的语法中构造实例的应用程序提供安全性。  
>   
>  对象中的脚本 <xref:System.Speech.Recognition.Grammar> 始终按从中的网页下载的方式运行 `Internet Zone` 。 公共语言运行时 (CLR) 隔离加载的任何 DLL 以获取语法定义。  
  
   
  
## Examples  
 下面的示例 <xref:System.Speech.Recognition.Grammar> 从 XML 文件中定义的语音识别语法构造对象， ( # A0) 。 下面的 XML 示例中将显示 cities.xml 文件的内容。  
  
```csharp  
// Load a cities grammar from a local file and return the grammar object.   
private static Grammar CreateGrammarFromFile()  
{  
  Grammar citiesGrammar = new Grammar(@"c:\temp\cities.xml");  
  citiesGrammar.Name = "SRGS File Cities Grammar";  
  return citiesGrammar;  
}  
  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-8" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.xml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item> Seattle </item>  
      <item> Los Angeles </item>  
      <item> New York </item>  
      <item> Miami </item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" />
    <altmember cref="T:System.Speech.Recognition.GrammarBuilder" />
    <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
    <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=15143">语音识别语法规范</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Speech.Recognition.Grammar" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用 <xref:System.Speech.Recognition.Grammar.%23ctor%2A> 构造函数 <xref:System.Speech.Recognition.Grammar> 从 <xref:System.Speech.Recognition.GrammarBuilder> 或对象创建实例，也可以使用 <xref:System.Speech.Recognition.SrgsGrammar.SrgsDocument> <xref:System.IO.Stream> 包含受支持格式的语法说明的文件或来创建实例。 支持的格式包括：  
  
-   符合 W3C[语音识别语法规范 (SRGS) 版本 1.0](https://go.microsoft.com/fwlink/?LinkId=201761)的 XML 格式文件  
  
-   已编译为带有 cfg 文件扩展名的二进制文件的语法  
  
 在其参数中接受 XML 格式语法文件的语法构造函数将 XML 语法编译为二进制格式，以优化语音识别引擎的加载和使用。 您可以 <xref:System.Speech.Recognition.Grammar> 通过使用其中一种方法预先编译语法来减少从 XML 格式语法构造对象所需的时间 <xref:System.Speech.Recognition.SrgsGrammar.SrgsGrammarCompiler.Compile%2A> 。  
  
 语音识别语法可以定义根规则。 若要创建一个 <xref:System.Speech.Recognition.Grammar> 指定要用作其根规则的规则的对象，请使用接受参数的构造函数 `ruleName` 。  
  
 若要创建一个 <xref:System.Speech.Recognition.Grammar> 指定基 URI 以解析相对规则引用的对象，请使用采用参数的构造函数 `baseUri` 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Grammar ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Grammar();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Speech.Recognition.Grammar" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Grammar (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (stream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Grammar(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.Grammar : System.IO.Stream -&gt; System.Speech.Recognition.Grammar" Usage="new System.Speech.Recognition.Grammar stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">以受支持的格式描述语音识别语法的流。</param>
        <summary>从 <see cref="T:System.Speech.Recognition.Grammar" /> 初始化 <see cref="T:System.IO.Stream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数不会将任何参数传递给初始化处理程序，并且说明不应定义需要参数的初始化处理程序。  
  
 此构造函数可以创建 <xref:System.Speech.Recognition.Grammar> 以下格式的实例：  
  
-   符合 W3C[语音识别语法规范 (SRGS) 版本 1.0](https://go.microsoft.com/fwlink/?LinkId=201761)的 XML 格式文件  
  
-   已编译为带有 cfg 文件扩展名的二进制文件的语法  
  
 此构造函数将 XML 格式语法文件编译为二进制格式，以优化语音识别引擎的加载和使用。 您可以 <xref:System.Speech.Recognition.Grammar> 通过使用其中一种方法预先编译语法来减少从 XML 格式语法构造对象所需的时间 <xref:System.Speech.Recognition.SrgsGrammar.SrgsGrammarCompiler.Compile%2A> 。  
  
 SRGS 语法可以定义根规则。 若要 <xref:System.Speech.Recognition.Grammar> 从流创建对象并指定根规则，请使用 <xref:System.Speech.Recognition.Grammar.%23ctor%2A> 或 <xref:System.Speech.Recognition.Grammar.%23ctor%2A> 构造函数。  
  
 若要 <xref:System.Speech.Recognition.Grammar> 从流创建对象并指定要使用的基 URI 来解析相对规则引用，请使用 <xref:System.Speech.Recognition.Grammar.%23ctor%2A> 构造函数。  
  
   
  
## Examples  
 下面的示例通过使用文件流 ( # A0) 在本地 SRGS 文件中创建语音识别语法。 下面的 c # 示例将显示 cities.xml 文件的内容。  
  
```csharp  
  
// Load a cities grammar from an I/O stream and    
// return the new grammar.   
private static Grammar CreateGrammarFromStream()  
{  
  string fileName = @"c:\temp\cities.xml";  
  Grammar citiesGrammar =  
    new Grammar(new FileStream(fileName, FileMode.Open));  
  citiesGrammar.Name = "Stream Cities Grammar";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-8" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.xml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item>Seattle</item>  
      <item>Los Angeles</item>  
      <item>New York</item>  
      <item>Miami</item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="stream" /> 描述未包含根规则的语法。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">流不包含有效的语法说明,也不描述包含一个规则引用无法解析的语法。</exception>
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=15143">语音识别语法规范</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Grammar (System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor(System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (builder As GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Grammar(System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.Grammar : System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.Grammar" Usage="new System.Speech.Recognition.Grammar builder" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">包含语音识别语法的约束的 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 的实例。</param>
        <summary>从 <see cref="T:System.Speech.Recognition.Grammar" /> 对象初始化 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[    
  
## Examples  
 下面的示例使用和对象创建语音识别 <xref:System.Speech.Recognition.Choices> 语法 <xref:System.Speech.Recognition.GrammarBuilder> 。 <xref:System.Speech.Recognition.Grammar.%23ctor%2A>构造函数 <xref:System.Speech.Recognition.Grammar> 从对象中创建对象 <xref:System.Speech.Recognition.GrammarBuilder> 。  
  
```csharp
// Create a grammar using a GrammarBuilder and return the new grammar.   
private static Grammar CreateGrammarBuilderGrammar()  
{  
  GrammarBuilder builder = new GrammarBuilder();  
  
  Choices cityChoice = new Choices (new string[]   
  {"Seattle", "New York", "Miami", "Los Angeles"});  
  
  builder.Append("I would like to fly from");  
  builder.Append(cityChoice);  
  builder.Append("to");  
  builder.Append(cityChoice);  
  
  Grammar citiesGrammar = new Grammar(builder);  
  citiesGrammar.Name = "GrammarBuilder Cities Grammar";  
  
  return citiesGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Grammar (System.Speech.Recognition.SrgsGrammar.SrgsDocument srgsDocument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SrgsGrammar.SrgsDocument srgsDocument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor(System.Speech.Recognition.SrgsGrammar.SrgsDocument)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (srgsDocument As SrgsDocument)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Grammar(System::Speech::Recognition::SrgsGrammar::SrgsDocument ^ srgsDocument);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.Grammar : System.Speech.Recognition.SrgsGrammar.SrgsDocument -&gt; System.Speech.Recognition.Grammar" Usage="new System.Speech.Recognition.Grammar srgsDocument" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="srgsDocument" Type="System.Speech.Recognition.SrgsGrammar.SrgsDocument" />
      </Parameters>
      <Docs>
        <param name="srgsDocument">语音识别语法的约束。</param>
        <summary>从 <see cref="T:System.Speech.Recognition.Grammar" /> 对象初始化 <see cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数不会将任何参数传递给初始化处理程序，并且 <xref:System.Speech.Recognition.SrgsGrammar.SrgsDocument> 不应包含需要参数的初始化处理程序。  
  
 <xref:System.Speech.Recognition.SrgsGrammar.SrgsDocument>可以具有根规则。 若要创建 <xref:System.Speech.Recognition.Grammar> 指定根规则的对象，请使用 <xref:System.Speech.Recognition.Grammar.%23ctor%2A> 或 <xref:System.Speech.Recognition.Grammar.%23ctor%2A> 构造函数。  
  
 若要从创建语音识别 <xref:System.Speech.Recognition.Grammar> <xref:System.Speech.Recognition.SrgsGrammar.SrgsDocument> ，并指定要用于解析相对规则引用的基本 URI，请使用 <xref:System.Speech.Recognition.Grammar.%23ctor%2A> 构造函数。  
  
   
  
## Examples  
 下面的示例在实例中创建语音识别语法 <xref:System.Speech.Recognition.SrgsGrammar.SrgsDocument> ，然后使用该语法构造 <xref:System.Speech.Recognition.Grammar> 对象。  
  
```csharp  
private static Grammar CreateSrgsDocumentGrammar()  
{  
  // Create the SrgsDocument.  
  SrgsDocument document = new SrgsDocument();  
  
  // Create the Cities rule and add it to the document.  
  SrgsRule citiesRule = new SrgsRule("Cities");  
  
  SrgsOneOf cityChoice = new SrgsOneOf();  
  cityChoice.Add(new SrgsItem("Seattle"));  
  cityChoice.Add(new SrgsItem("Los Angeles"));  
  cityChoice.Add(new SrgsItem("New York"));  
  cityChoice.Add(new SrgsItem("Miami"));  
  
  citiesRule.Add(cityChoice);  
  document.Rules.Add(citiesRule);  
  
  // Create the Main rule and add it to the document.  
  SrgsRule mainRule = new SrgsRule("Main");  
  mainRule.Scope = SrgsRuleScope.Public;  
  
  SrgsItem item = new SrgsItem("I would like to fly from");  
  item.Add(new SrgsRuleRef(citiesRule));  
  item.Add(new SrgsText("to"));  
  item.Add(new SrgsRuleRef(citiesRule));  
  
  mainRule.Add(item);  
  document.Rules.Add(mainRule);  
  
  // Set the root rule.  
  document.Root = mainRule;  
  
  // Create the Grammar object.  
  Grammar citiesGrammar = new Grammar(document);  
  citiesGrammar.Name = "SrgsDocument Cities Grammar";  
  
  return citiesGrammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="srgsDocument" /> 不包含根规则。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="srgsDocument" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="srgsDocument" /> 包含无法解析的规则引用。</exception>
        <altmember cref="N:System.Speech.Recognition.SrgsGrammar" />
        <altmember cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=15143">语音识别语法规范</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Grammar (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Grammar(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.Grammar : string -&gt; System.Speech.Recognition.Grammar" Usage="new System.Speech.Recognition.Grammar path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">以受支持的格式描述语音识别语法的文件路径。</param>
        <summary>从文件中初始化 <see cref="T:System.Speech.Recognition.Grammar" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数不会将任何参数传递给初始化处理程序，并且说明不应定义需要参数的初始化处理程序。  
  
 此构造函数可以创建 <xref:System.Speech.Recognition.Grammar> 以下格式的实例：  
  
-   符合 W3C[语音识别语法规范 (SRGS) 版本 1.0](https://go.microsoft.com/fwlink/?LinkId=201761)的 XML 格式文件  
  
-   已编译为带有 cfg 文件扩展名的二进制文件的语法  
  
 此构造函数将 XML 格式语法文件编译为二进制格式，以优化语音识别引擎的加载和使用。 您可以 <xref:System.Speech.Recognition.Grammar> 通过使用其中一种方法预先编译语法来减少从 XML 格式语法构造对象所需的时间 <xref:System.Speech.Recognition.SrgsGrammar.SrgsGrammarCompiler.Compile%2A> 。  
  
 SRGS 语法可以定义根规则。 若要 <xref:System.Speech.Recognition.Grammar> 通过字符串创建对象并指定根规则，请使用 <xref:System.Speech.Recognition.Grammar.%23ctor%2A> 构造函数。  
  
 若要创建一个 <xref:System.Speech.Recognition.Grammar> 对象，该对象指定用于解析相对规则引用的基本 URI，请在文件流中打开该文件，并使用 <xref:System.Speech.Recognition.Grammar.%23ctor%2A?displayProperty=nameWithType> 构造函数。  
  
   
  
## Examples  
 下面的示例从本地 SRGS 文件加载语音识别语法，以生成 <xref:System.Speech.Recognition.Grammar> 对象。 cities.xml 文件的内容将显示在遵循 c # 示例的 XML 示例中。  
  
```csharp  
// Load a cities grammar from a local file and  
// return the new grammar.   
private static Grammar CreateGrammarFromFile()  
{  
  Grammar citiesGrammar = new Grammar(@"c:\temp\cities.xml");  
  citiesGrammar.Name = "SRGS File Cities Grammar";  
  return citiesGrammar;  
}  
  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-8" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.xml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item>Seattle</item>  
      <item>Los Angeles</item>  
      <item>New York</item>  
      <item>Miami</item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 包含了空字符串 ("")，或该文件对不包含根规则的语法进行了介绍。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">文件不包含有效的说明,也不描述包含一个规则引用无法解析的语法。</exception>
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=15143">语音识别语法规范</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Grammar (System.IO.Stream stream, string ruleName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, string ruleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor(System.IO.Stream,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (stream As Stream, ruleName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Grammar(System::IO::Stream ^ stream, System::String ^ ruleName);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.Grammar : System.IO.Stream * string -&gt; System.Speech.Recognition.Grammar" Usage="new System.Speech.Recognition.Grammar (stream, ruleName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="ruleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stream">以受支持的格式描述语音识别语法的流。</param>
        <param name="ruleName">用作语音识别语法的入口点的规则标识符，或以使用语法说明的默认根规则 <see langword="null" /> 。</param>
        <summary>从 <see cref="T:System.Speech.Recognition.Grammar" /> 和指定根规则中来初始化 <see cref="T:System.IO.Stream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数不会将任何参数传递给初始化处理程序，并且说明不应定义需要参数的初始化处理程序。  
  
 此构造函数可以创建  <xref:System.Speech.Recognition.Grammar> 以下格式的实例：  
  
-   符合 W3C[语音识别语法规范 (SRGS) 版本 1.0](https://go.microsoft.com/fwlink/?LinkId=201761)的 XML 格式文件  
  
-   已编译为带有 cfg 文件扩展名的二进制文件的语法  
  
 此构造函数将 XML 格式语法文件编译为二进制格式，以优化语音识别引擎的加载和使用。 您可以 <xref:System.Speech.Recognition.Grammar> 通过使用其中一种方法预先编译语法来减少从 XML 格式语法构造对象所需的时间 <xref:System.Speech.Recognition.SrgsGrammar.SrgsGrammarCompiler.Compile%2A> 。  
  
 若要 <xref:System.Speech.Recognition.Grammar> 从流创建，并指定要使用的基 URI 来解析相对规则引用，请使用 <xref:System.Speech.Recognition.Grammar.%23ctor%2A> 构造函数。  
  
   
  
## Examples  
 下面的示例从文件流加载本地 SRGS 文件 ( # A0) ，并指定要用作语法的根的规则。 cities.xml 文件的内容将显示在遵循 c # 示例的 XML 示例中。  
  
```csharp  
  
// Load a cities grammar from an I/O stream, use a specific  
// rule as the root of the grammar, and return the new grammar.   
private static Grammar CreateGrammarFromStream2()  
{  
  FileInfo file = new FileInfo(@"c:\temp\cities.xml");  
  Grammar citiesGrammar = new Grammar(file.OpenRead(), "Main");  
  citiesGrammar.Name = "Stream Cities Grammar 2";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-8" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.xml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item>Seattle</item>  
      <item>Los Angeles</item>  
      <item>New York</item>  
      <item>Miami</item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="ruleName" /> 无法解析或非公共，或者 <paramref name="ruleName" /> 为 <see langword="null" />，并且语法说明不定义根规则。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">流不包含有效的说明,也不描述包含一个规则引用无法解析的语法。</exception>
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=15143">语音识别语法规范</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Grammar (System.Speech.Recognition.SrgsGrammar.SrgsDocument srgsDocument, string ruleName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SrgsGrammar.SrgsDocument srgsDocument, string ruleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor(System.Speech.Recognition.SrgsGrammar.SrgsDocument,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (srgsDocument As SrgsDocument, ruleName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Grammar(System::Speech::Recognition::SrgsGrammar::SrgsDocument ^ srgsDocument, System::String ^ ruleName);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.Grammar : System.Speech.Recognition.SrgsGrammar.SrgsDocument * string -&gt; System.Speech.Recognition.Grammar" Usage="new System.Speech.Recognition.Grammar (srgsDocument, ruleName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="srgsDocument" Type="System.Speech.Recognition.SrgsGrammar.SrgsDocument" />
        <Parameter Name="ruleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="srgsDocument">语音识别语法的约束。</param>
        <param name="ruleName">规则标识符作为语音识别语法的入口点，按 <see cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" />默认根规则使用 <see langword="null" /> 。</param>
        <summary>初始化来自 <see cref="T:System.Speech.Recognition.Grammar" /> 对象的 <see cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" /> 类的新实例并指定一个根规则。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数不会将任何参数传递给初始化处理程序，并且 <xref:System.Speech.Recognition.SrgsGrammar.SrgsDocument> 不应包含需要参数的初始化处理程序。  
  
 若要 <xref:System.Speech.Recognition.Grammar> 从创建对象 <xref:System.Speech.Recognition.SrgsGrammar.SrgsDocument> 并指定要使用的基 URI 来解析相对规则引用，请使用 <xref:System.Speech.Recognition.Grammar.%23ctor%2A> 构造函数。  
  
   
  
## Examples  
 下面的示例在实例中创建语音识别语法 <xref:System.Speech.Recognition.SrgsGrammar.SrgsDocument> ，并指定要用作语法的根规则的规则。 该示例 <xref:System.Speech.Recognition.Grammar> 从实例构造对象 <xref:System.Speech.Recognition.SrgsGrammar.SrgsDocument> 并将其加载到语音识别引擎。  
  
```csharp  
using System;  
using System.Speech.Recognition;  
using System.Speech.Recognition.SrgsGrammar;  
  
namespace SampleRecognition  
{  
  class Program  
  {  
    static void Main(string[] args)  
  
    // Initialize an in-process speech recognition engine.  
    {  
      using (SpeechRecognitionEngine recognizer =  
         new SpeechRecognitionEngine())  
      {  
  
        // Create the SrgsDocument.  
        SrgsDocument document = new SrgsDocument();  
  
        // Create the Cities rule and add it to the document.  
        SrgsRule citiesRule = new SrgsRule("Cities");  
        citiesRule.Scope = SrgsRuleScope.Public;  
  
        SrgsOneOf cityChoice = new SrgsOneOf();  
        cityChoice.Add(new SrgsItem("Seattle"));  
        cityChoice.Add(new SrgsItem("Los Angeles"));  
        cityChoice.Add(new SrgsItem("New York"));  
        cityChoice.Add(new SrgsItem("Miami"));  
  
        citiesRule.Add(cityChoice);  
        document.Rules.Add(citiesRule);  
  
        // Create the Main rule and add it to the document.  
        SrgsRule mainRule = new SrgsRule("Main");  
        mainRule.Scope = SrgsRuleScope.Public;  
  
        mainRule.Add(new SrgsItem("I would like to fly from"));  
        mainRule.Add(new SrgsRuleRef(citiesRule));  
        mainRule.Add(new SrgsItem("to"));  
        mainRule.Add(new SrgsRuleRef(citiesRule));  
  
        document.Rules.Add(mainRule);  
  
        // Create the Grammar object and specify which rule to use as the root.  
        Grammar citiesGrammar = new Grammar(document,"Main");  
  
        // Load the grammar object to the recognizer.  
        recognizer.LoadGrammarAsync(citiesGrammar);  
  
        // Attach a handler for the SpeechRecognized event.  
        recognizer.SpeechRecognized +=  
          new EventHandler<SpeechRecognizedEventArgs>(recognizer_SpeechRecognized);  
  
        // Set the input to the recognizer.  
        recognizer.SetInputToDefaultAudioDevice();  
  
        // Start recognition.  
        recognizer.RecognizeAsync();  
        Console.WriteLine("Starting asynchronous recognition...");  
  
        // Keep the console window open.  
        Console.ReadLine();  
      }  
    }  
  
    // Handle the SpeechRecognized event.  
    static void recognizer_SpeechRecognized(object sender, SpeechRecognizedEventArgs e)  
    {  
      Console.WriteLine("  Speech recognized: " + e.Result.Text);  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="ruleName" /> 无法解析或非公共，或者 <paramref name="ruleName" /> 为 <see langword="null" />，并且 <paramref name="srgsDocument" /> 不包含根规则。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="srgsDocument" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="srgsDocument" /> 包含无法解析的规则引用。</exception>
        <altmember cref="N:System.Speech.Recognition.SrgsGrammar" />
        <altmember cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=15143">语音识别语法规范</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Grammar (string path, string ruleName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, string ruleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, ruleName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Grammar(System::String ^ path, System::String ^ ruleName);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.Grammar : string * string -&gt; System.Speech.Recognition.Grammar" Usage="new System.Speech.Recognition.Grammar (path, ruleName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="ruleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">以受支持的格式描述语音识别语法的文件路径。</param>
        <param name="ruleName">用作语音识别语法的入口点的规则标识符，或以使用语法说明的默认根规则 <see langword="null" /> 。</param>
        <summary>初始化 <see cref="T:System.Speech.Recognition.Grammar" /> 类的新实例并指定根规则。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数不会将任何参数传递给初始化处理程序，并且说明不应定义需要参数的初始化处理程序。  
  
 此构造函数可以创建 <xref:System.Speech.Recognition.Grammar> 以下格式的实例：  
  
-   符合 W3C[语音识别语法规范 (SRGS) 版本 1.0](https://go.microsoft.com/fwlink/?LinkId=201761)的 XML 格式文件  
  
-   已编译为带有 cfg 文件扩展名的二进制文件的语法  
  
 此构造函数将 XML 格式语法文件编译为二进制格式，以优化语音识别引擎的加载和使用。 您可以 <xref:System.Speech.Recognition.Grammar> 通过使用其中一种方法预先编译语法来减少从 XML 格式语法构造对象所需的时间 <xref:System.Speech.Recognition.SrgsGrammar.SrgsGrammarCompiler.Compile%2A> 。  
  
 若要创建一个 <xref:System.Speech.Recognition.Grammar> 指定要用于解析相对规则引用的基 URI 的，请打开该文件的文件流并使用 <xref:System.Speech.Recognition.Grammar.%23ctor%2A> 构造函数。  
  
   
  
## Examples  
 下面的示例从文件中加载本地 SRGS 文件 ( # A0) ，并指定要用作语法的根的规则。 cities.xml 文件的内容将显示在遵循 c # 示例的 XML 示例中。  
  
```csharp  
  
// Load a cities grammar from a local file, use a specific  
// rule as the root of the grammar, and return the new grammar.  
private static Grammar CreateGrammarFromFile2()  
{  
  Grammar citiesGrammar = new Grammar(@"c:\temp\cities.xml", "Main");  
  citiesGrammar.Name = "SRGS File Cities Grammar 2";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-8" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.xml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item>Seattle</item>  
      <item>Los Angeles</item>  
      <item>New York</item>  
      <item>Miami</item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="ruleName" /> 无法解析或非公共，<paramref name="path" /> 为空字符串 ("")，或者 <paramref name="ruleName" /> 为 <see langword="null" />，并且语法说明不定义根规则。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">文件不包含有效的说明,也不描述包含一个规则引用无法解析的语法。</exception>
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=15143">语音识别语法规范</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Grammar (System.IO.Stream stream, string ruleName, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, string ruleName, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor(System.IO.Stream,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (stream As Stream, ruleName As String, parameters As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Grammar(System::IO::Stream ^ stream, System::String ^ ruleName, cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.Grammar : System.IO.Stream * string * obj[] -&gt; System.Speech.Recognition.Grammar" Usage="new System.Speech.Recognition.Grammar (stream, ruleName, parameters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="ruleName" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="stream">连接到包含语法规范的输入 / 输出对象（包括文件、VisualStudio 资源和 DLL）的 <see cref="T:System.IO.Stream" />。</param>
        <param name="ruleName">用作语音识别语法的入口点的规则标识符，或以使用语法说明的默认根规则 <see langword="null" /> 。</param>
        <param name="parameters">通过入口点或创建的根规则的属性指定设置为指定的 <see cref="P:System.Speech.Recognition.SrgsGrammar.SrgsRule.OnInit" /> 参数要传递至的 <see cref="T:System.Speech.Recognition.Grammar" /> 初始化处理程序。 此参数可以为 null。</param>
        <summary>从 <see cref="T:System.Speech.Recognition.Grammar" /> 和指定根规则中来初始化 <see cref="T:System.IO.Stream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 还可以指定初始化处理程序的参数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="stream" /> 连接到该语法: 
-   不包含 <paramref name="ruleName" /> 中指定的规则  
  
-   需要与 <paramref name="parameters" /> 中指定的那些不同的初始化参数  
  
-   包含无法由语法的默认基 <see cref="T:System.Uri" /> 规则解决的相对规则引用</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Grammar (System.IO.Stream stream, string ruleName, Uri baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, string ruleName, class System.Uri baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor(System.IO.Stream,System.String,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (stream As Stream, ruleName As String, baseUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Grammar(System::IO::Stream ^ stream, System::String ^ ruleName, Uri ^ baseUri);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.Grammar : System.IO.Stream * string * Uri -&gt; System.Speech.Recognition.Grammar" Usage="new System.Speech.Recognition.Grammar (stream, ruleName, baseUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="ruleName" Type="System.String" />
        <Parameter Name="baseUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="stream">以受支持的格式描述语音识别语法的流。</param>
        <param name="ruleName">用作语音识别语法的入口点的规则标识符，或以使用语法说明的默认根规则 <see langword="null" /> 。</param>
        <param name="baseUri">使用的基 URI 解决所有在语法描述中的任何相关规则 <see langword="null" />引用，或</param>
        <summary>初始化来自流的 <see cref="T:System.Speech.Recognition.Grammar" /> 类的新实例，指定根规则并定义一个基统一资源字符识别（URI）来解析相对规则引用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数不会将任何参数传递给初始化处理程序，并且说明不应定义需要参数的初始化处理程序。  
  
 此构造函数可以创建 <xref:System.Speech.Recognition.Grammar> 以下格式的实例：  
  
-   符合 W3C[语音识别语法规范 (SRGS) 版本 1.0](https://go.microsoft.com/fwlink/?LinkId=201761)的 XML 格式文件  
  
-   已编译为带有 cfg 文件扩展名的二进制文件的语法  
  
 此构造函数将 XML 格式语法文件编译为二进制格式，以优化语音识别引擎的加载和使用。 您可以 <xref:System.Speech.Recognition.Grammar> 通过使用其中一种方法预先编译语法来减少从 XML 格式语法构造对象所需的时间 <xref:System.Speech.Recognition.SrgsGrammar.SrgsGrammarCompiler.Compile%2A> 。  
  
 此构造函数不会进行验证 `baseUri` 。 但是， `LoadGrammar` <xref:System.Speech.Recognition.SpeechRecognitionEngine> 如果或对象的方法 <xref:System.Speech.Recognition.SpeechRecognizer> 无法解析语法说明中的所有规则引用，则会引发异常。 如果不 `baseUri` 为 `null` ，则此 `LoadGrammar` 方法使用 URI 来解析不能以其他方式解析的规则引用。 如果 `baseUri` 表示文件，则在 `LoadGrammar` 尝试解析相对规则引用时，使用指定的文件和文件的目录。  
  
   
  
## Examples  
 下面的示例从文件流加载本地 SRGS 文件 ( # A0) 。 文件包含对 cities.xml 文件中规则的相对规则引用，并指定要用于解析规则引用的基 URI。 shuttle.xml 和 cities.xml 文件的内容将显示在遵循 c # 示例的 XML 示例中。  
  
```csharp  
  
private static Grammar CreateGrammarFromStream3()  
{  
  FileInfo file = new FileInfo(@".\shuttle.xml");  
  Uri baseUri = new Uri(@"file://c:\temp\");  
  Grammar citiesGrammar = new Grammar(file.OpenRead(), null, baseUri);  
  citiesGrammar.Name = "Stream Cities Grammar 3";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-8" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- shuttle.xml:   
    Defines an SRGS grammar for asking about a shuttle service. This grammar  
    references a Cities rule that is defined in the cities.xml grammar. -->  
  
  <rule id="Main">  
    <item>  
      Can I get a shuttle in  
      <ruleref uri="cities.xml#Cities"/>  
    </item>  
  </rule>  
</grammar>  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-8" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.xml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item>Seattle</item>  
      <item>Los Angeles</item>  
      <item>New York</item>  
      <item>Miami</item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="ruleName" /> 无法解析或非公共，或者 <paramref name="ruleName" /> 为 <see langword="null" />，并且语法说明不定义根规则。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">流不包含有效的说明,也不描述包含一个规则引用无法解析的语法。</exception>
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=15143">语音识别语法规范</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Grammar (System.Speech.Recognition.SrgsGrammar.SrgsDocument srgsDocument, string ruleName, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SrgsGrammar.SrgsDocument srgsDocument, string ruleName, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor(System.Speech.Recognition.SrgsGrammar.SrgsDocument,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (srgsDocument As SrgsDocument, ruleName As String, parameters As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Grammar(System::Speech::Recognition::SrgsGrammar::SrgsDocument ^ srgsDocument, System::String ^ ruleName, cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.Grammar : System.Speech.Recognition.SrgsGrammar.SrgsDocument * string * obj[] -&gt; System.Speech.Recognition.Grammar" Usage="new System.Speech.Recognition.Grammar (srgsDocument, ruleName, parameters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="srgsDocument" Type="System.Speech.Recognition.SrgsGrammar.SrgsDocument" />
        <Parameter Name="ruleName" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="srgsDocument">包含语音识别语法的约束的 <see cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" /> 的实例。</param>
        <param name="ruleName">用作语音识别语法的入口点的规则标识符，或以使用语法说明的默认根规则 <see langword="null" /> 。</param>
        <param name="parameters">通过入口点或创建的根规则的属性指定设置为指定的 <see cref="P:System.Speech.Recognition.SrgsGrammar.SrgsRule.OnInit" /> 参数要传递至的 <see cref="T:System.Speech.Recognition.Grammar" /> 初始化处理程序。 此参数可以为 null。</param>
        <summary>初始化来自 <see cref="T:System.Speech.Recognition.Grammar" /> 的实例的 <see cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" /> 类的新实例，并指定成为语法入口点的规则的名称。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 还可以指定初始化处理程序的参数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">-   包含无效值的任何参数。  
  
-   <paramref name="srgsDocument" /> 指定的 <see cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" /> 不包含 <paramref name="ruleName" /> 指定的规则。  
  
-   数组参数的内容与初始化处理程序的任何规则的参数不匹配。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Grammar (System.Speech.Recognition.SrgsGrammar.SrgsDocument srgsDocument, string ruleName, Uri baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SrgsGrammar.SrgsDocument srgsDocument, string ruleName, class System.Uri baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor(System.Speech.Recognition.SrgsGrammar.SrgsDocument,System.String,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (srgsDocument As SrgsDocument, ruleName As String, baseUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Grammar(System::Speech::Recognition::SrgsGrammar::SrgsDocument ^ srgsDocument, System::String ^ ruleName, Uri ^ baseUri);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.Grammar : System.Speech.Recognition.SrgsGrammar.SrgsDocument * string * Uri -&gt; System.Speech.Recognition.Grammar" Usage="new System.Speech.Recognition.Grammar (srgsDocument, ruleName, baseUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="srgsDocument" Type="System.Speech.Recognition.SrgsGrammar.SrgsDocument" />
        <Parameter Name="ruleName" Type="System.String" />
        <Parameter Name="baseUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="srgsDocument">语音识别语法的约束。</param>
        <param name="ruleName">规则标识符作为语音识别语法的入口点，按 <see cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" />默认根规则使用 <see langword="null" /> 。</param>
        <param name="baseUri"><see cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" />或者 <see langword="null" />中使用的基 URI 解决所有在语法描述中的任何相关规则引用，或</param>
        <summary>初始化来自 <see cref="T:System.Speech.Recognition.Grammar" /> 对象的 <see cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" /> 类的新实例，指定一个根规则，并定义一个基统一资源标识符（URI）来解析相对规则引用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数不会将任何参数传递给初始化处理程序，并且 <xref:System.Speech.Recognition.SrgsGrammar.SrgsDocument> 不应包含需要参数的初始化处理程序。  
  
 此构造函数不会进行验证 `baseUri` 。 但是， `LoadGrammar` <xref:System.Speech.Recognition.SpeechRecognitionEngine> 如果或对象的方法 <xref:System.Speech.Recognition.SpeechRecognizer> 无法解析语法说明中的所有规则引用，则会引发异常。 如果不 `baseUri` 为 `null` ，则此 `LoadGrammar` 方法使用 URI 来解析不能以其他方式解析的规则引用。 如果 `baseUri` 表示文件，则此 `LoadGrammar` 方法在尝试解析相对规则引用时使用指定的文件和文件的目录。  
  
   
  
## Examples  
 下面的示例在中创建一个语音识别语法， <xref:System.Speech.Recognition.SrgsGrammar.SrgsDocument> 其中包含对 cities.xml 文件的相对规则引用，并指定要用于解析规则引用的 URI。 cities.xml 文件的内容将显示在遵循 c # 示例的 XML 示例中。  
  
```csharp  
  
private static Grammar CreateSrgsDocumentGrammar3()  
{  
  // Create the SrgsDocument.  
  SrgsDocument document = new SrgsDocument();  
  
  // Create the Main rule and add it to the document.  
  SrgsRule mainRule = new SrgsRule("Main");  
  mainRule.Scope = SrgsRuleScope.Public;  
  
  SrgsItem item = new SrgsItem("Can I get a shuttle in");  
  
  // Create a relative URI for the cities rule.  
  Uri ruleUri = new Uri("cities.xml#Cities", UriKind.Relative);  
  
  item.Add(new SrgsRuleRef(ruleUri));  
  
  mainRule.Add(item);  
  document.Rules.Add(mainRule);  
  
  // Set the root rule.  
  document.Root = mainRule;  
  
  // Create the grammar.  
  Uri baseUri = new Uri(@"file://c:\temp\");  
  Grammar citiesGrammar = new Grammar(document, null, baseUri);  
  citiesGrammar.Name = "SrgsDocument Cities Grammar 3";  
  
  return citiesGrammar;  
}  
  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-8" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.xml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item>Seattle</item>  
      <item>Los Angeles</item>  
      <item>New York</item>  
      <item>Miami</item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="ruleName" /> 无法解析或非公共，或者 <paramref name="ruleName" /> 为 <see langword="null" />，并且 <paramref name="srgsDocument" /> 不包含根规则。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="srgsDocument" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="srgsDocument" /> 包含无法解析的规则引用。</exception>
        <altmember cref="N:System.Speech.Recognition.SrgsGrammar" />
        <altmember cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=15143">语音识别语法规范</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Grammar (string path, string ruleName, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, string ruleName, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, ruleName As String, parameters As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Grammar(System::String ^ path, System::String ^ ruleName, cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.Grammar : string * string * obj[] -&gt; System.Speech.Recognition.Grammar" Usage="new System.Speech.Recognition.Grammar (path, ruleName, parameters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="ruleName" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="path">一个文件的路径，包括 DLL，包含语法规范。</param>
        <param name="ruleName">用作语音识别语法的入口点的规则标识符，或以使用语法说明的默认根规则 <see langword="null" /> 。</param>
        <param name="parameters">通过入口点或创建的根规则的属性指定设置为指定的 <see cref="P:System.Speech.Recognition.SrgsGrammar.SrgsRule.OnInit" /> 参数要传递至的 <see cref="T:System.Speech.Recognition.Grammar" /> 初始化处理程序。 此参数可以为 null。</param>
        <summary>初始化来自包含语法定义的文件的 <see cref="T:System.Speech.Recognition.Grammar" /> 类的新实例并指定成为语法入口的规则的名称。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 还可以指定初始化处理程序的参数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">-   包含无效值的任何参数。  
  
-   <paramref name="path" /> 指定的文件不包含在 <paramref name="ruleName" /> 有效语法或规则指定的。  
  
-   数组参数的内容与初始化处理程序的任何规则的参数不匹配。  
  
-   语法具有无法由语法的默认基 <see cref="T:System.Uri" /> 规则解决的相对规则引用。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Grammar (System.IO.Stream stream, string ruleName, Uri baseUri, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, string ruleName, class System.Uri baseUri, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor(System.IO.Stream,System.String,System.Uri,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (stream As Stream, ruleName As String, baseUri As Uri, parameters As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Grammar(System::IO::Stream ^ stream, System::String ^ ruleName, Uri ^ baseUri, cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.Grammar : System.IO.Stream * string * Uri * obj[] -&gt; System.Speech.Recognition.Grammar" Usage="new System.Speech.Recognition.Grammar (stream, ruleName, baseUri, parameters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="ruleName" Type="System.String" />
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="stream">连接到包含语法规范的输入 / 输出对象（包括文件、VisualStudio 资源和 DLL）的 <see cref="T:System.IO.Stream" />。</param>
        <param name="ruleName">用作语音识别语法的入口点的规则标识符，或以使用语法说明的默认根规则 <see langword="null" /> 。</param>
        <param name="baseUri">使用的基 URI 解决所有在语法描述中的任何相关规则 <see langword="null" />引用，或</param>
        <param name="parameters">通过入口点或创建的根规则的属性指定设置为指定的 <see cref="P:System.Speech.Recognition.SrgsGrammar.SrgsRule.OnInit" /> 参数要传递至的 <see cref="T:System.Speech.Recognition.Grammar" /> 初始化处理程序。 此参数可以为 null。</param>
        <summary>初始化 <see cref="T:System.Speech.Recognition.Grammar" /> 类的新实例 <see cref="T:System.IO.Stream" /> 并指定根规则和基 URI 来解析相对引用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 还可以指定初始化处理程序的参数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">-   包含无效值的任何参数。  
  
-   <paramref name="stream" /> 连接到不包含 <paramref name="ruleName" /> 指定规则的语法。  
  
-   数组参数的内容与初始化处理程序的任何规则的参数不匹配。  
  
-   语法包含无法由语法的默认基或 <paramref name="baseUri" />提供的 URI <see cref="T:System.Uri" /> 解决的相对规则引用。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Grammar (System.Speech.Recognition.SrgsGrammar.SrgsDocument srgsDocument, string ruleName, Uri baseUri, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SrgsGrammar.SrgsDocument srgsDocument, string ruleName, class System.Uri baseUri, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.#ctor(System.Speech.Recognition.SrgsGrammar.SrgsDocument,System.String,System.Uri,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (srgsDocument As SrgsDocument, ruleName As String, baseUri As Uri, parameters As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Grammar(System::Speech::Recognition::SrgsGrammar::SrgsDocument ^ srgsDocument, System::String ^ ruleName, Uri ^ baseUri, cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.Grammar : System.Speech.Recognition.SrgsGrammar.SrgsDocument * string * Uri * obj[] -&gt; System.Speech.Recognition.Grammar" Usage="new System.Speech.Recognition.Grammar (srgsDocument, ruleName, baseUri, parameters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="srgsDocument" Type="System.Speech.Recognition.SrgsGrammar.SrgsDocument" />
        <Parameter Name="ruleName" Type="System.String" />
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="srgsDocument">包含语音识别语法的约束的 <see cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" /> 的实例。</param>
        <param name="ruleName">用作语音识别语法的入口点的规则标识符，或以使用语法说明的默认根规则 <see langword="null" /> 。</param>
        <param name="baseUri">使用的基 URI 解决所有在语法描述中的任何相关规则 <see langword="null" />引用，或</param>
        <param name="parameters">通过入口点或创建的根规则的属性指定设置为指定的 <see cref="P:System.Speech.Recognition.SrgsGrammar.SrgsRule.OnInit" /> 参数要传递至的 <see cref="T:System.Speech.Recognition.Grammar" /> 初始化处理程序。 此参数可以为 null。</param>
        <summary>初始化来自 <see cref="T:System.Speech.Recognition.Grammar" /> 的实例的 <see cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" /> 类的新实例，并指定成为语法入口的规则的名称及一个基 URI 来解析相对引用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 还可以指定初始化处理程序的参数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">-   包含无效值的任何参数。  
  
-   <paramref name="srgsDocument" /> 不包含 <see cref="T:System.Speech.Recognition.SrgsGrammar.SrgsDocument" /> 指定的规则 <paramref name="ruleName" /> 的指定中。  
  
-   数组参数的内容与初始化处理程序的任何规则的参数不匹配。  
  
-   语法具有无法由语法的默认基或<paramref name="baseUri" />提供的 URI <see cref="T:System.Uri" /> 解决的相对规则引用。</exception>
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.Grammar.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Speech.Recognition.Grammar.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，此值控制语音识别器是否可以使用 <see cref="T:System.Speech.Recognition.Grammar" /> 来进行识别。</summary>
        <value>如果引用的语音识别语法在语音识别器当前加载， <see langword="Enabled" /> 属性返回 <see langword="true" />；否则该属性返回 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.Grammar>可以单独启用或禁用的实例，而不是由语音识别引擎加载。  
  
   
  
## Examples  
 下面的示例将有关对象的信息写入 <xref:System.Speech.Recognition.Grammar> [控制台](https://go.microsoft.com/fwlink/?LinkId=159613)。  
  
```csharp  
  
private static void DumpGrammarStatus(Grammar item)  
{  
  Console.WriteLine("Grammar name is {0}:", item.Name);  
  Console.WriteLine("  The Grammar {0} loaded.",  
    item.Loaded ? "is" : "is not");  
  Console.WriteLine("  The Grammar {0} enabled.",  
    item.Enabled ? "is" : "is not");  
  if (item.RuleName != null)  
  {  
    Console.WriteLine("  The root rule is {0}.", item.RuleName);  
  }  
  else  
  {  
    Console.WriteLine("  The Grammar does not specify a root rule.");  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Speech.Recognition.Grammar.Loaded" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=15143">语音识别语法规范</related>
      </Docs>
    </Member>
    <Member MemberName="IsStg">
      <MemberSignature Language="C#" Value="protected internal virtual bool IsStg { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStg" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.Grammar.IsStg" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property IsStg As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool IsStg { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStg : bool" Usage="System.Speech.Recognition.Grammar.IsStg" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取语法是否是强类型的。</summary>
        <value>如果语法是强类型；<see langword="IsStg" /> 属性返回 <see langword="true" />，否则属性返回 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 强类型 <xref:System.Speech.Recognition.Grammar> 对象 (`IsStg` 等于 `true`) 可以 (对象返回强类型的结果，而不是将原始文本) 返回给客户端应用程序。 例如，强类型语法可能返回 <xref:System.DateTime> 对象，而不是原始识别的输入。  
  
 可以通过将代码附加到语法规则来实现强类型的语法。 当识别引擎处理任何给定的规则时，以输入当前部分结果作为输入，将执行关联的代码，并且文本信息成为丰富的类型对象。 这使客户端能够更轻松地使用增强的语义检查、对多个区域性的支持和内部语法逻辑。  
  
 强类型对象的实例 <xref:System.Speech.Recognition.Grammar> 通常作为 <xref:System.Type> 公共语言运行时 (CLR) 中的资源从程序集的资源中获取。 用于支持不同语言的本地化类型是此类对象的示例 <xref:System.Speech.Recognition.Grammar> 。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>从继承的强类型语法 <see cref="T:System.Speech.Recognition.Grammar" /> 需要重写的默认行为 <see langword="IsStg" /> ，这将返回 <see langword="false" /> 。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public bool Loaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Loaded" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.Grammar.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Loaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Loaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Loaded : bool" Usage="System.Speech.Recognition.Grammar.Loaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Speech.Recognition.Grammar" /> 是否已经由语音识别器加载。</summary>
        <value>如果引用的语音识别语法在语音识别器当前加载， <see langword="Loaded" /> 属性返回 <see langword="true" /> ;否则该属性返回 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 加载后 <xref:System.Speech.Recognition.Grammar> ，和的值将 <xref:System.Speech.Recognition.Grammar.Weight%2A> <xref:System.Speech.Recognition.Grammar.Priority%2A> 无法更改。  
  
   
  
## Examples  
 下面的示例将有关对象的信息写入 <xref:System.Speech.Recognition.Grammar> [控制台](https://go.microsoft.com/fwlink/?LinkId=159613)。  
  
```csharp  
  
private static void DumpGrammarStatus(Grammar item)  
{  
  Console.WriteLine("Grammar name is {0}:", item.Name);  
  Console.WriteLine("  The Grammar {0} loaded.",  
    item.Loaded ? "is" : "is not");  
  Console.WriteLine("  The Grammar {0} enabled.",  
    item.Enabled ? "is" : "is not");  
  if (item.RuleName != null)  
  {  
    Console.WriteLine("  The root rule is {0}.", item.RuleName);  
  }  
  else  
  {  
    Console.WriteLine("  The Grammar does not specify a root rule.");  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Speech.Recognition.Grammar.Enabled" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
      </Docs>
    </Member>
    <Member MemberName="LoadLocalizedGrammarFromType">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.Grammar LoadLocalizedGrammarFromType (Type type, params object[] onInitParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.Grammar LoadLocalizedGrammarFromType(class System.Type type, object[] onInitParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.LoadLocalizedGrammarFromType(System.Type,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadLocalizedGrammarFromType (type As Type, ParamArray onInitParameters As Object()) As Grammar" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::Grammar ^ LoadLocalizedGrammarFromType(Type ^ type, ... cli::array &lt;System::Object ^&gt; ^ onInitParameters);" />
      <MemberSignature Language="F#" Value="static member LoadLocalizedGrammarFromType : Type * obj[] -&gt; System.Speech.Recognition.Grammar" Usage="System.Speech.Recognition.Grammar.LoadLocalizedGrammarFromType (type, onInitParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.Grammar</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="onInitParameters" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">在程序集中，基于 <see cref="T:System.Type" /> 对象的 <see cref="T:System.Speech.Recognition.Grammar" />。</param>
        <param name="onInitParameters">要基于 <see cref="T:System.Speech.Recognition.Grammar" /> 传递给本地化对象的初始化方法的参数。 此参数可以为 null。</param>
        <summary><see langword="LoadLocalizedGrammarFromType" /> 方法返回从 <see cref="T:System.Speech.Recognition.Grammar" />派生的 <see cref="T:System.Type" /> 对象的本地化的实例。</summary>
        <returns>如果存在错误， <see langword="LoadLocalizedGrammarFromType" /> 方法返回 <see cref="T:System.Speech.Recognition.Grammar" />的有效对象基于 <see langword="null" /> 。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用获取的本地化语法 `LoadLocalizedGrammarFromType` 通常是强类型的 (有关 <xref:System.Speech.Recognition.Grammar.IsStg%2A> 强类型语法) 的详细信息，请参阅。 如果 `onInitParameters` 是 null 引用 (Visual Basic 中没有任何内容) 则本地化语法不应具有任何初始化方法或不带参数的方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.Grammar.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Speech.Recognition.Grammar.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Speech.Recognition.Grammar" /> 对象的名称。</summary>
        <value><see langword="Name" /> 属性返回 <see cref="T:System.Speech.Recognition.Grammar" /> 对象的名称。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例创建两个 <xref:System.Speech.Recognition.Grammar> 对象，一个用于数字，一个用于分数。 为语法对象分配名称、相对权重和优先级，并由进程内语音识别器加载。 `CreateDigitsGrammar` `CreateFractionsGrammar` `recognizer_SpeechRecognized` 此处未显示、和方法。  
  
```csharp  
  
// Create a Grammar for recognizing numeric digits.  
Grammar digitsGrammar = CreateDigitsGrammar();  
digitsGrammar.Name = "Digits Grammar";  
digitsGrammar.Priority = 2;  
digitsGrammar.Weight = 0.6f;  
  
// Create a Grammar for recognizing fractions.  
Grammar fractionsGrammar = CreateFractionsGrammar();  
fractionsGrammar.Name = "Fractions Grammar";  
fractionsGrammar.Priority = 1;  
fractionsGrammar.Weight = 1f;  
  
// Create an in-process speech recognizer.  
SpeechRecognitionEngine recognizer = new SpeechRecognitionEngine();  
  
recognizer.SpeechRecognized +=  
  new EventHandler<SpeechRecognizedEventArgs>(  
    recognizer_SpeechRecognized);  
  
// Load the digits and fractions Grammar objects.  
recognizer.LoadGrammar(digitsGrammar);  
recognizer.LoadGrammar(fractionsGrammar);  
  
// Start recognition.  
recognizer.SetInputToDefaultAudioDevice();  
recognizer.RecognizeAsync(RecognizeMode.Multiple);  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public int Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Priority" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.Grammar.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Priority { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : int with get, set" Usage="System.Speech.Recognition.Grammar.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Speech.Recognition.Grammar" /> 对象的优先级别值。</summary>
        <value><see langword="Priority" /> 属性返回表示特定 <see cref="T:System.Speech.Recognition.Grammar" />的相对优先级的整数值。 该范围包含从 -128 到 127。 默认值为 0。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Priority`当多个语法生成相同的识别结果时，属性用于选择语法。 如果语音识别器加载并启用了多个与输入匹配的语音识别语法，并且匹配项是识别器的最佳结果，则识别器使用最高的语法 `Priority` 。 如果生成相同识别结果的语法也具有相同的 `Priority` 值，则识别器使用的语法未定义。  
  
   
  
## Examples  
 下面的示例创建两个 <xref:System.Speech.Recognition.Grammar> 对象，一个用于数字，一个用于分数。 <xref:System.Speech.Recognition.Grammar>对象被分配名称、相对权重和优先级，并由进程内语音识别器加载。 `CreateDigitsGrammar` `CreateFractionsGrammar` `recognizer_SpeechRecognized` 此处未显示、和方法。  
  
```csharp  
  
// Create a Grammar for recognizing numeric digits.  
Grammar digitsGrammar = CreateDigitsGrammar();  
digitsGrammar.Name = "Digits Grammar";  
digitsGrammar.Priority = 2;  
digitsGrammar.Weight = 0.6f;  
  
// Create a Grammar for recognizing fractions.  
Grammar fractionsGrammar = CreateFractionsGrammar();  
fractionsGrammar.Name = "Fractions Grammar";  
fractionsGrammar.Priority = 1;  
fractionsGrammar.Weight = 1f;  
  
// Create an in-process speech recognizer.  
SpeechRecognitionEngine recognizer = new SpeechRecognitionEngine();  
  
recognizer.SpeechRecognized +=  
  new EventHandler<SpeechRecognizedEventArgs>(  
    recognizer_SpeechRecognized);  
  
// Load the digits and fractions Grammar objects.  
recognizer.LoadGrammar(digitsGrammar);  
recognizer.LoadGrammar(fractionsGrammar);  
  
// Start recognition.  
recognizer.SetInputToDefaultAudioDevice();  
recognizer.RecognizeAsync(RecognizeMode.Multiple);  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Speech.Recognition.Grammar.Loaded" />
        <altmember cref="P:System.Speech.Recognition.Grammar.Enabled" />
        <altmember cref="P:System.Speech.Recognition.Grammar.Weight" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
      </Docs>
    </Member>
    <Member MemberName="ResourceName">
      <MemberSignature Language="C#" Value="protected string ResourceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ResourceName" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.Grammar.ResourceName" />
      <MemberSignature Language="VB.NET" Value="Protected Property ResourceName As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::String ^ ResourceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResourceName : string with get, set" Usage="System.Speech.Recognition.Grammar.ResourceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>使用用于加载当前 <see cref="T:System.Speech.Recognition.Grammar" /> 的二进制资源名称获取或设置值。</summary>
        <value><see langword="ResourceName" /> 属性返回强类型的语法，使用该 <see cref="T:System.Speech.Recognition.Grammar" />，加载二进制资源的名称。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RuleName">
      <MemberSignature Language="C#" Value="public string RuleName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RuleName" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.Grammar.RuleName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RuleName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RuleName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RuleName : string" Usage="System.Speech.Recognition.Grammar.RuleName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取根规则或 <see cref="T:System.Speech.Recognition.Grammar" /> 对象入口点的名称。</summary>
        <value><see langword="RuleName" /> 属性返回识别引用的语音语法的根规则的标识符。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要构造 <xref:System.Speech.Recognition.Grammar> 对象并设置其根规则的名称，请使用 <xref:System.Speech.Recognition.Grammar.%23ctor%2A> 采用参数的构造函数之一 `ruleName` 。  
  
 如果的根规则 <xref:System.Speech.Recognition.Grammar> 没有名称，属性将返回 `null` 。  
  
 <xref:System.Speech.Recognition.Grammar>从对象构造的实例的根规则 <xref:System.Speech.Recognition.GrammarBuilder> 通常没有名称，因此 <xref:System.Speech.Recognition.Grammar.RuleName%2A> 返回 `null` 。  
  
   
  
## Examples  
 下面的示例将有关对象的信息写入 <xref:System.Speech.Recognition.Grammar> [控制台](https://go.microsoft.com/fwlink/?LinkId=159613)。  
  
```csharp  
  
private static void DumpGrammarStatus(Grammar item)  
{  
  Console.WriteLine("Grammar name is {0}:", item.Name);  
  Console.WriteLine("  The Grammar {0} loaded.",  
    item.Loaded ? "is" : "is not");  
  Console.WriteLine("  The Grammar {0} enabled.",  
    item.Enabled ? "is" : "is not");  
  if (item.RuleName != null)  
  {  
    Console.WriteLine("  The root rule is {0}.", item.RuleName);  
  }  
  else  
  {  
    Console.WriteLine("  The Grammar does not specify a root rule.");  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.Grammar.#ctor(System.IO.Stream)" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
      </Docs>
    </Member>
    <Member MemberName="SpeechRecognized">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Speech.Recognition.SpeechRecognizedEventArgs&gt; SpeechRecognized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Speech.Recognition.SpeechRecognizedEventArgs&gt; SpeechRecognized" />
      <MemberSignature Language="DocId" Value="E:System.Speech.Recognition.Grammar.SpeechRecognized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SpeechRecognized As EventHandler(Of SpeechRecognizedEventArgs) " FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Speech::Recognition::SpeechRecognizedEventArgs ^&gt; ^ SpeechRecognized;" />
      <MemberSignature Language="F#" Value="member this.SpeechRecognized : EventHandler&lt;System.Speech.Recognition.SpeechRecognizedEventArgs&gt; " Usage="member this.SpeechRecognized : System.EventHandler&lt;System.Speech.Recognition.SpeechRecognizedEventArgs&gt; " />
      <MemberSignature Language="VB.NET" Value="Public Event SpeechRecognized As EventHandler(Of SpeechRecognizedEventArgs) " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Speech.Recognition.SpeechRecognizedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当语音识别器执行使用 <see cref="T:System.Speech.Recognition.Grammar" /> 对象的标识时引发。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 语音识别器还 `SpeechRecognized`  会在识别输入时引发事件。 <xref:System.Speech.Recognition.Grammar>对象的 <xref:System.Speech.Recognition.Grammar.SpeechRecognized> 事件在语音识别器的事件发生前引发 `SpeechRecognized` 。 有关详细信息，请参阅 <xref:System.Speech.Recognition.SpeechRecognizer.SpeechRecognized?displayProperty=nameWithType> 、 <xref:System.Speech.Recognition.SpeechRecognitionEngine.SpeechRecognized?displayProperty=nameWithType> 和 <xref:System.Speech.Recognition.SpeechRecognitionEngine.RecognizeCompleted> 事件。  
  
 特定于特定语法的任何任务都应始终由该对象的事件的处理程序来处理 <xref:System.Speech.Recognition.Grammar> <xref:System.Speech.Recognition.Grammar.SpeechRecognized> 。  
  
   
  
## Examples  
 下面的示例演示如何对对象的事件使用事件处理程序 <xref:System.Speech.Recognition.Grammar> <xref:System.Speech.Recognition.Grammar.SpeechRecognized> 。 它会将识别结果输出到 [控制台](https://go.microsoft.com/fwlink/?LinkId=159613)。  
  
```csharp  
public partial class Form1 : Form  
{  
  SpeechRecognitionEngine sre;  
  
  public Form1()  
  {  
  InitializeComponent();  
  
  // Create an in-process speech recognizer.  
  sre = new SpeechRecognitionEngine();  
  
  // Configure input to the speech recognizer.  
  sre.SetInputToDefaultAudioDevice();  
  
  // Create a simple grammar and load it.  
  Grammar testGrammar = new Grammar(new GrammarBuilder("testing"));  
  sre.LoadGrammarAsync(testGrammar);  
  
  // Add a handler for the grammar's speech recognized event.  
  testGrammar.SpeechRecognized += new EventHandler<SpeechRecognizedEventArgs>(testGrammar_SpeechRecognized);  
  
  // Start asynchronous speech recognition.  
  sre.RecognizeAsync();  
  }  
  
  // Handle the grammar's SpeechRecognized event, output the recognized text.  
  void testGrammar_SpeechRecognized(object sender, SpeechRecognizedEventArgs e)  
  {  
    Console.WriteLine("Recognized text: " + e.Result.Text);  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
      </Docs>
    </Member>
    <Member MemberName="StgInit">
      <MemberSignature Language="C#" Value="protected void StgInit (object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void StgInit(object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.Grammar.StgInit(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Sub StgInit (parameters As Object())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void StgInit(cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.StgInit : obj[] -&gt; unit" Usage="grammar.StgInit parameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="parameters">要传递以初始化强类型语法的参数。 此参数可以为 null。</param>
        <summary><see langword="StgInit" /> 方法初始的强类型语法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 强类型 <xref:System.Speech.Recognition.Grammar> 对象 (`IsStg` 等于 `true`) 可以 (对象返回强类型的结果，而不是将原始文本) 返回给客户端应用程序。 例如，强类型语法可能返回 <xref:System.DateTime> 对象，而不是原始识别的输入。  
  
 可以通过将代码附加到语法规则来实现强类型的语法。 当识别引擎处理任何给定的规则时，以输入当前部分结果作为输入，将执行关联的代码，并且文本信息成为丰富的类型对象。 这使客户端能够更轻松地使用增强的语义检查、对多个区域性的支持和内部语法逻辑。  
  
 强类型对象的实例 <xref:System.Speech.Recognition.Grammar> 通常作为 <xref:System.Type> 公共语言运行时 (CLR) 中的资源从程序集的资源中获取。 用于支持不同语言的本地化类型是此类对象的示例 <xref:System.Speech.Recognition.Grammar> 。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>如果强类型语法需要初始化， <see langword="StgInit" /> 应在构造函数或初始化方法中调用。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Weight">
      <MemberSignature Language="C#" Value="public float Weight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 Weight" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.Grammar.Weight" />
      <MemberSignature Language="VB.NET" Value="Public Property Weight As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float Weight { float get(); void set(float value); };" />
      <MemberSignature Language="F#" Value="member this.Weight : single with get, set" Usage="System.Speech.Recognition.Grammar.Weight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Speech.Recognition.Grammar" /> 对象的宽度值。</summary>
        <value><see langword="Weight" /> 返回一个表明标识引擎实例当处理语音输入时应分配给语法的相对权重的浮点值的属性。 范围为0.0 到1.0 （含）。 默认值为1.0。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由于识别引擎使用 **权重**，其对特定语法性能的影响并不像这样直接预测 <xref:System.Speech.Recognition.Grammar.Priority%2A> 。  
  
 语音识别是加权系统。 它基于语法权重的组合、为语法中的替代项定义的权重以及语音模型定义的概率，计算所有可能的识别路径。 语音识别引擎使用这些权重和概率的组合来对可能的备用识别进行排名。 具有更高权重的语法将更多地提供识别替代方法（而不是具有较低权重的语法）的排名。  
  
 <xref:System.Speech.Recognition.Grammar.Weight%2A>语音识别器上属性的效果取决于识别器的实现。 尽管该 <xref:System.Speech.Recognition.Grammar.Weight%2A> 属性可用于调整应用程序的语音识别的准确性，但仅应在对特定识别环境进行了控制的诊断研究后使用该属性，并使用有关正在使用的识别引擎的完整信息。  
  
   
  
## Examples  
 下面的示例创建两个 <xref:System.Speech.Recognition.Grammar> 对象，一个用于数字，一个用于分数。 <xref:System.Speech.Recognition.Grammar>对象被分配名称、相对权重和优先级，并由进程内语音识别器加载。 `CreateDigitsGrammar` `CreateFractionsGrammar` `recognizer_SpeechRecognized` 此处未显示、和方法。  
  
```csharp  
  
// Create a Grammar for recognizing numeric digits.  
Grammar digitsGrammar = CreateDigitsGrammar();  
digitsGrammar.Name = "Digits Grammar";  
digitsGrammar.Priority = 2;  
digitsGrammar.Weight = 0.6f;  
  
// Create a Grammar for recognizing fractions.  
Grammar fractionsGrammar = CreateFractionsGrammar();  
fractionsGrammar.Name = "Fractions Grammar";  
fractionsGrammar.Priority = 1;  
fractionsGrammar.Weight = 1f;  
  
// Create an in-process speech recognizer.  
SpeechRecognitionEngine recognizer = new SpeechRecognitionEngine();  
  
recognizer.SpeechRecognized +=  
  new EventHandler<SpeechRecognizedEventArgs>(  
    recognizer_SpeechRecognized);  
  
// Load the digits and fractions Grammar objects.  
recognizer.LoadGrammar(digitsGrammar);  
recognizer.LoadGrammar(fractionsGrammar);  
  
// Start recognition.  
recognizer.SetInputToDefaultAudioDevice();  
recognizer.RecognizeAsync(RecognizeMode.Multiple);  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Speech.Recognition.Grammar.Loaded" />
        <altmember cref="P:System.Speech.Recognition.Grammar.Enabled" />
        <altmember cref="P:System.Speech.Recognition.Grammar.Priority" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
      </Docs>
    </Member>
  </Members>
</Type>
