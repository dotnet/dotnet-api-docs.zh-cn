<Type Name="Contract" FullName="System.Diagnostics.Contracts.Contract">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f4923a01d4d555f1d826d0523eb2997cae535595" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86670603" /></Metadata><TypeSignature Language="C#" Value="public static class Contract" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Contract extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Contracts.Contract" />
  <TypeSignature Language="VB.NET" Value="Public Class Contract" />
  <TypeSignature Language="C++ CLI" Value="public ref class Contract abstract sealed" />
  <TypeSignature Language="F#" Value="type Contract = class" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.0.4.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Diagnostics.Contracts" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Diagnostics.Contracts" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="f9b47-101">包含用于表示程序协定（如前置条件、后置条件和对象固定）的静态方法。</span><span class="sxs-lookup"><span data-stu-id="f9b47-101">Contains static methods for representing program contracts such as preconditions, postconditions, and object invariants.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9b47-102">代码协定类使你可以在代码中指定前置条件、后置条件和对象固定。</span><span class="sxs-lookup"><span data-stu-id="f9b47-102">Code contract classes let you specify preconditions, postconditions, and object invariants in your code.</span></span> <span data-ttu-id="f9b47-103">前置条件是输入方法或属性时必须满足的要求。</span><span class="sxs-lookup"><span data-stu-id="f9b47-103">Preconditions are requirements that must be met when entering a method or property.</span></span> <span data-ttu-id="f9b47-104">后置条件描述在方法或属性代码退出时的预期。</span><span class="sxs-lookup"><span data-stu-id="f9b47-104">Postconditions describe expectations at the time the method or property code exits.</span></span> <span data-ttu-id="f9b47-105">对象固定条件描述了不存在任何条件问题的类的预期状态。</span><span class="sxs-lookup"><span data-stu-id="f9b47-105">Object invariants describe the expected state for a class that has no condition problems.</span></span> <span data-ttu-id="f9b47-106">有关前置条件、后置条件和对象固定条件的详细信息，请参阅 [代码协定](/dotnet/framework/debug-trace-profile/code-contracts)。</span><span class="sxs-lookup"><span data-stu-id="f9b47-106">For more information about preconditions, postconditions, and object invariants, see [Code Contracts](/dotnet/framework/debug-trace-profile/code-contracts).</span></span>  
  
 <span data-ttu-id="f9b47-107">有关使用代码协定的工具和详细说明，请参阅 Visual Studio Marketplace 上的 [代码协定](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) 。</span><span class="sxs-lookup"><span data-stu-id="f9b47-107">For tools and detailed instructions for using code contracts, see [Code Contracts](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) on the Visual Studio Marketplace.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f9b47-108">必须使用二进制重写程序插入协定的运行时强制。</span><span class="sxs-lookup"><span data-stu-id="f9b47-108">You must use a binary rewriter to insert run-time enforcement of contracts.</span></span> <span data-ttu-id="f9b47-109">否则，只有在违反协定的情况下， <xref:System.Diagnostics.Contracts.Contract.Ensures%2A?displayProperty=nameWithType> 才可以静态测试方法的协定，并且在运行时不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="f9b47-109">Otherwise, contracts such as the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A?displayProperty=nameWithType> method can only be tested statically and will not throw exceptions during run time if a contract is violated.</span></span> <span data-ttu-id="f9b47-110">可以从 Visual Studio Marketplace 上的 [代码协定](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) 下载二进制重写 CCRewrite。</span><span class="sxs-lookup"><span data-stu-id="f9b47-110">You can download the binary rewriter CCRewrite from [Code Contracts](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) on the Visual Studio Marketplace.</span></span> <span data-ttu-id="f9b47-111">CCRewrite 附带了一个 Visual Studio 外接程序，使你能够从项目 **属性** 页激活运行时协定强制。</span><span class="sxs-lookup"><span data-stu-id="f9b47-111">CCRewrite comes with a Visual Studio add-in that enables you to activate run-time contract enforcement from the project **Properties** page.</span></span> <span data-ttu-id="f9b47-112">二进制重写程序和 Visual Studio 外接程序不随 [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] 或 Windows SDK 一起附带。</span><span class="sxs-lookup"><span data-stu-id="f9b47-112">The binary rewriter and the Visual Studio add-in do not ship with [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] or the Windows SDK.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Assert">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f9b47-113">在调试版本中，针对指定条件执行运行时测试。</span><span class="sxs-lookup"><span data-stu-id="f9b47-113">In debug builds, performs a run-time test for a specified condition.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition);" />
      <MemberSignature Language="F#" Value="static member Assert : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Assert condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Diagnostics.Conditional("CONTRACTS_FULL")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.Conditional("CONTRACTS_FULL")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Diagnostics.Conditional("DEBUG")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.Conditional("DEBUG")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="f9b47-114">要测试的条件表达式。</span><span class="sxs-lookup"><span data-stu-id="f9b47-114">The conditional expression to test.</span></span></param>
        <summary><span data-ttu-id="f9b47-115">检查条件；如果条件为 <see langword="false" />，则遵循为分析器设置的升级策略。</span><span class="sxs-lookup"><span data-stu-id="f9b47-115">Checks for a condition; if the condition is <see langword="false" />, follows the escalation policy set for the analyzer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9b47-116">默认升级策略是通知附加调试器有关协定失败的情况，或者如果未附加调试器，则显示 " **断言** " 对话框。</span><span class="sxs-lookup"><span data-stu-id="f9b47-116">The default escalation policy is to notify the attached debugger about a contract failure or to display an **Assert** dialog box if a debugger is not attached.</span></span> <span data-ttu-id="f9b47-117">或者，可以指示分析器引发异常。</span><span class="sxs-lookup"><span data-stu-id="f9b47-117">Optionally, the analyzer can be instructed to throw an exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Assert : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Assert (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Diagnostics.Conditional("CONTRACTS_FULL")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.Conditional("CONTRACTS_FULL")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Diagnostics.Conditional("DEBUG")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.Conditional("DEBUG")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="f9b47-118">要测试的条件表达式。</span><span class="sxs-lookup"><span data-stu-id="f9b47-118">The conditional expression to test.</span></span></param>
        <param name="userMessage"><span data-ttu-id="f9b47-119">在不满足条件时要显示的消息。</span><span class="sxs-lookup"><span data-stu-id="f9b47-119">A message to display if the condition is not met.</span></span></param>
        <summary><span data-ttu-id="f9b47-120">检查条件；如果条件为 <see langword="false" />，则遵循由分析器设置的升级策略，并显示指定的消息。</span><span class="sxs-lookup"><span data-stu-id="f9b47-120">Checks for a condition; if the condition is <see langword="false" />, follows the escalation policy set by the analyzer and displays the specified message.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9b47-121">默认升级策略是通知附加调试器有关协定失败的情况，或者如果未附加调试器，则显示 " **断言** " 对话框。</span><span class="sxs-lookup"><span data-stu-id="f9b47-121">The default escalation policy is to notify the attached debugger about a contract failure or to display an **Assert** dialog box if a debugger is not attached.</span></span> <span data-ttu-id="f9b47-122">或者，可以指示分析器引发异常。</span><span class="sxs-lookup"><span data-stu-id="f9b47-122">Optionally, the analyzer can be instructed to throw an exception.</span></span> <span data-ttu-id="f9b47-123">将 `userMessage` 参数传递给调试器输出。</span><span class="sxs-lookup"><span data-stu-id="f9b47-123">The `userMessage` parameter is passed to the debugger output.</span></span> <span data-ttu-id="f9b47-124">如果不是 `userMessage` 常量字符串，则工具可能无法读取它。</span><span class="sxs-lookup"><span data-stu-id="f9b47-124">If `userMessage` is not a constant string literal, tools may not be able to read it.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Assume">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f9b47-125">指示代码分析工具假设某个条件为 <see langword="true" />（即使无法静态地证明该条件始终为 <see langword="true" />）。</span><span class="sxs-lookup"><span data-stu-id="f9b47-125">Instructs code analysis tools to assume that a condition is <see langword="true" />, even if it cannot be statically proven to always be <see langword="true" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Assume">
      <MemberSignature Language="C#" Value="public static void Assume (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assume(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assume (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assume(bool condition);" />
      <MemberSignature Language="F#" Value="static member Assume : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Assume condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Diagnostics.Conditional("CONTRACTS_FULL")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.Conditional("CONTRACTS_FULL")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Diagnostics.Conditional("DEBUG")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.Conditional("DEBUG")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="f9b47-126">假设为 <see langword="true" /> 的条件表达式。</span><span class="sxs-lookup"><span data-stu-id="f9b47-126">The conditional expression to assume <see langword="true" />.</span></span></param>
        <summary><span data-ttu-id="f9b47-127">指示代码分析工具假设指定的条件为 <see langword="true" />（即使无法静态地证明该条件始终为 <see langword="true" />）。</span><span class="sxs-lookup"><span data-stu-id="f9b47-127">Instructs code analysis tools to assume that the specified condition is <see langword="true" />, even if it cannot be statically proven to always be <see langword="true" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9b47-128">在运行时，使用此方法等效于使用 <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="f9b47-128">At run time, using this method is equivalent to using the <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%29> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assume">
      <MemberSignature Language="C#" Value="public static void Assume (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assume(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assume (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assume(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Assume : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Assume (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Diagnostics.Conditional("CONTRACTS_FULL")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.Conditional("CONTRACTS_FULL")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Diagnostics.Conditional("DEBUG")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.Conditional("DEBUG")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="f9b47-129">假设为 <see langword="true" /> 的条件表达式。</span><span class="sxs-lookup"><span data-stu-id="f9b47-129">The conditional expression to assume <see langword="true" />.</span></span></param>
        <param name="userMessage"><span data-ttu-id="f9b47-130">假设失败时要发布的消息。</span><span class="sxs-lookup"><span data-stu-id="f9b47-130">The message to post if the assumption fails.</span></span></param>
        <summary><span data-ttu-id="f9b47-131">指示代码分析工具假设某个条件为 <see langword="true" />（即使无法静态地证明该条件始终为 <see langword="true" />），并在假设失败时显示一条消息。</span><span class="sxs-lookup"><span data-stu-id="f9b47-131">Instructs code analysis tools to assume that a condition is <see langword="true" />, even if it cannot be statically proven to always be <see langword="true" />, and displays a message if the assumption fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9b47-132">如果不是 `userMessage` 常量字符串，则工具可能无法理解该协定。</span><span class="sxs-lookup"><span data-stu-id="f9b47-132">If `userMessage` is not a constant string literal, the contract may not be understood by tools.</span></span>  
  
 <span data-ttu-id="f9b47-133">在运行时，使用此方法等效于使用 <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%2CSystem.String%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="f9b47-133">At run time, using this method is equivalent to using the <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%2CSystem.String%29> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContractFailed">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt; ContractFailed;" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Diagnostics.Contracts.ContractFailedEventArgs&gt; ContractFailed" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Contracts.Contract.ContractFailed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ContractFailed As EventHandler(Of ContractFailedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Diagnostics::Contracts::ContractFailedEventArgs ^&gt; ^ ContractFailed;" />
      <MemberSignature Language="F#" Value="member this.ContractFailed : EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt; " Usage="member this.ContractFailed : System.EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt; " />
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt;? ContractFailed;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[add: System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;add: System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[remove: System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;remove: System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f9b47-134">协定失败时发生。</span><span class="sxs-lookup"><span data-stu-id="f9b47-134">Occurs when a contract fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9b47-135">此事件的事件信息由传递给事件处理程序的 <xref:System.Diagnostics.Contracts.ContractFailedEventArgs?displayProperty=nameWithType> 对象提供。</span><span class="sxs-lookup"><span data-stu-id="f9b47-135">The event information for this event is supplied by the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs?displayProperty=nameWithType> object that is passed to the event handler.</span></span> <span data-ttu-id="f9b47-136">此事件通知托管应用程序环境，如交互式解释器或 Web 浏览器宿主，协定已失败。</span><span class="sxs-lookup"><span data-stu-id="f9b47-136">This event notifies a managed application environment such as an interactive interpreter or a Web browser host that a contract has failed.</span></span> <span data-ttu-id="f9b47-137">在执行此操作之前，它将引发一个事件，应用程序可以根据需要处理该事件。</span><span class="sxs-lookup"><span data-stu-id="f9b47-137">Before doing so, it will raise an event that an application can handle as it sees fit.</span></span> <span data-ttu-id="f9b47-138">例如，如果代码在测试框架中运行，则可以记录测试失败，然后结束测试。</span><span class="sxs-lookup"><span data-stu-id="f9b47-138">For example, if code is being run in a testing framework, you can log a test failure and then end the test.</span></span>  
  
 <span data-ttu-id="f9b47-139"><xref:System.Diagnostics.Contracts.Internal.ContractHelper.RaiseContractFailedEvent%2A>.NET Framework 类库中的方法的默认实现是调用向事件注册的每个处理程序 <xref:System.Diagnostics.Contracts.Contract.ContractFailed> 。</span><span class="sxs-lookup"><span data-stu-id="f9b47-139">The default implementation of the <xref:System.Diagnostics.Contracts.Internal.ContractHelper.RaiseContractFailedEvent%2A> method in the .NET Framework class library is to call each handler that is registered with the <xref:System.Diagnostics.Contracts.Contract.ContractFailed> event.</span></span> <span data-ttu-id="f9b47-140">处理程序引发的异常将被忽略，但每个处理程序都可以通过调用事件自变量的方法来指示是否处理了该失败 <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetHandled%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f9b47-140">Exceptions thrown by handlers are ignored, but each handler can indicate whether the failure is handled by calling the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetHandled%2A> method for the event arguments.</span></span> <span data-ttu-id="f9b47-141">如果任何处理程序将失败设置为 "已处理"，则该方法将返回 `null` ，并且不执行其他操作。</span><span class="sxs-lookup"><span data-stu-id="f9b47-141">If any handler sets the failure as handled, the method returns `null` and no further action is taken.</span></span> <span data-ttu-id="f9b47-142">或者，处理程序可以调用 <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetUnwind%2A> 方法来指示代码展开。</span><span class="sxs-lookup"><span data-stu-id="f9b47-142">Alternatively, handlers can call the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetUnwind%2A> method to instruct the code to unwind.</span></span> <span data-ttu-id="f9b47-143">在这种情况下，在执行所有处理程序后，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="f9b47-143">In that case, an exception is thrown after all handlers have executed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndContractBlock">
      <MemberSignature Language="C#" Value="public static void EndContractBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndContractBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EndContractBlock" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndContractBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndContractBlock();" />
      <MemberSignature Language="F#" Value="static member EndContractBlock : unit -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.EndContractBlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Diagnostics.Conditional("CONTRACTS_FULL")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.Conditional("CONTRACTS_FULL")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f9b47-144">当方法的协定仅包含 <see langword="if" />-<see langword="then" />-<see langword="throw" /> 形式的前置条件时，标记协定部分的结尾。</span><span class="sxs-lookup"><span data-stu-id="f9b47-144">Marks the end of the contract section when a method's contracts contain only preconditions in the <see langword="if" />-<see langword="then" />-<see langword="throw" /> form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9b47-145">大多数代码已包含代码形式的某些参数验证 `if` - `then` - `throw` 。</span><span class="sxs-lookup"><span data-stu-id="f9b47-145">Most code already contains some parameter validation in the form of `if`-`then`-`throw` code.</span></span> <span data-ttu-id="f9b47-146">`if` - `then` - `throw` 当语句首先出现在方法中时，协定工具会将语句识别为前置条件，并且整个此类语句后跟显式 <xref:System.Diagnostics.Contracts.Contract> 方法调用，如 <xref:System.Diagnostics.Contracts.Contract.Requires%2A> 、 <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> 、 <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A> 或 <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f9b47-146">The contract tools recognize `if`-`then`-`throw` statements as preconditions when the statements appear first inside a method, and the entire set of such statements is followed by an explicit <xref:System.Diagnostics.Contracts.Contract> method call, such as a <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, or <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>.</span></span>  
  
 <span data-ttu-id="f9b47-147">当 `if` - `then` - `throw` 语句出现在此窗体中时，协定工具会将它们识别为旧的需要语句。</span><span class="sxs-lookup"><span data-stu-id="f9b47-147">When `if`-`then`-`throw` statements appear in this form, the contract tools recognize them as legacy-require statements.</span></span> <span data-ttu-id="f9b47-148">此 <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> 窗体仅在以下情况下才使用：不遵循序列的其他协定 `if` - `then` - `throw` ，但仍应将其标记为 "旧式-需要"。</span><span class="sxs-lookup"><span data-stu-id="f9b47-148">The <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> form is used only if no other contracts follow the `if`-`then`-`throw` sequences, but they should still be tagged as legacy-requires.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Ensures">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f9b47-149">为封闭方法或属性指定一个后置条件协定。</span><span class="sxs-lookup"><span data-stu-id="f9b47-149">Specifies a postcondition contract for the enclosing method or property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ensures">
      <MemberSignature Language="C#" Value="public static void Ensures (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Ensures(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Ensures (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Ensures(bool condition);" />
      <MemberSignature Language="F#" Value="static member Ensures : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Ensures condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Diagnostics.Conditional("CONTRACTS_FULL")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.Conditional("CONTRACTS_FULL")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="f9b47-150">要测试的条件表达式。</span><span class="sxs-lookup"><span data-stu-id="f9b47-150">The conditional expression to test.</span></span> <span data-ttu-id="f9b47-151">该表达式可以包括 <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" />、<see cref="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" /> 和 <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> 值。</span><span class="sxs-lookup"><span data-stu-id="f9b47-151">The expression may include <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" />, <see cref="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" />, and <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> values.</span></span></param>
        <summary><span data-ttu-id="f9b47-152">为封闭方法或属性指定一个后置条件协定。</span><span class="sxs-lookup"><span data-stu-id="f9b47-152">Specifies a postcondition contract for the enclosing method or property.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9b47-153">`condition`参数指定 `true` 当封闭方法或属性正常返回时应为的后置条件。</span><span class="sxs-lookup"><span data-stu-id="f9b47-153">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property returns normally.</span></span>  
  
-   <span data-ttu-id="f9b47-154">此方法调用必须位于方法或属性的开头，位于任何其他代码之前。</span><span class="sxs-lookup"><span data-stu-id="f9b47-154">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="f9b47-155">必须使用二进制重写程序 (在 Visual Studio Marketplace) 上的 [代码协定](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) 中提供，以便执行此后置条件的运行时强制。</span><span class="sxs-lookup"><span data-stu-id="f9b47-155">You must use the binary rewriter (available at [Code Contracts](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) on the Visual Studio Marketplace) for run-time enforcement of this postcondition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f9b47-156">下面的示例演示如何使用 <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> 方法来确保返回预期值。</span><span class="sxs-lookup"><span data-stu-id="f9b47-156">The following example shows how to use the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> method to ensure that an expected value is returned.</span></span> <span data-ttu-id="f9b47-157">此代码示例是为类提供的更大示例的一部分 <xref:System.Diagnostics.Contracts.ContractClassAttribute> 。</span><span class="sxs-lookup"><span data-stu-id="f9b47-157">This code example is part of a larger example provided for the <xref:System.Diagnostics.Contracts.ContractClassAttribute> class.</span></span>  
  
 [!code-csharp[ContractExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#3)]
 [!code-vb[ContractExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ensures">
      <MemberSignature Language="C#" Value="public static void Ensures (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Ensures(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Ensures (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Ensures(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Ensures : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Ensures (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Diagnostics.Conditional("CONTRACTS_FULL")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.Conditional("CONTRACTS_FULL")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="f9b47-158">要测试的条件表达式。</span><span class="sxs-lookup"><span data-stu-id="f9b47-158">The conditional expression to test.</span></span> <span data-ttu-id="f9b47-159">该表达式可以包括 <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" /> 和 <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> 值。</span><span class="sxs-lookup"><span data-stu-id="f9b47-159">The expression may include <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" /> and <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> values.</span></span></param>
        <param name="userMessage"><span data-ttu-id="f9b47-160">表达式不为 <see langword="true" /> 时要显示的消息。</span><span class="sxs-lookup"><span data-stu-id="f9b47-160">The message to display if the expression is not <see langword="true" />.</span></span></param>
        <summary><span data-ttu-id="f9b47-161">为提供的退出条件指定后置条件协定，并指定条件为 <see langword="false" /> 时要显示的消息。</span><span class="sxs-lookup"><span data-stu-id="f9b47-161">Specifies a postcondition contract for a provided exit condition and a message to display if the condition is <see langword="false" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9b47-162">`condition`参数指定 `true` 当封闭方法或属性正常返回时应为的后置条件。</span><span class="sxs-lookup"><span data-stu-id="f9b47-162">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property returns normally.</span></span>  
  
-   <span data-ttu-id="f9b47-163">此方法调用必须位于方法或属性的开头，位于任何其他代码之前。</span><span class="sxs-lookup"><span data-stu-id="f9b47-163">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="f9b47-164">此合同向客户端公开;因此，它必须只引用至少与封闭方法相同的成员。</span><span class="sxs-lookup"><span data-stu-id="f9b47-164">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="f9b47-165">必须使用二进制重写程序 (在 Visual Studio Marketplace) 上的 [代码协定](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) 中提供，以便执行此后置条件的运行时强制。</span><span class="sxs-lookup"><span data-stu-id="f9b47-165">You must use the binary rewriter (available at [Code Contracts](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) on the Visual Studio Marketplace) for run-time enforcement of this postcondition.</span></span>  
  
-   <span data-ttu-id="f9b47-166">如果不是 `userMessage` 常量字符串，则工具可能无法理解该协定。</span><span class="sxs-lookup"><span data-stu-id="f9b47-166">If `userMessage` is not a constant string literal, the contract may not be understood by tools.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnsuresOnThrow&lt;TException&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f9b47-167">基于提供的异常和条件为封闭方法或属性指定一个后置条件协定。</span><span class="sxs-lookup"><span data-stu-id="f9b47-167">Specifies a postcondition contract for the enclosing method or property based on the provided exception and condition.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnsuresOnThrow&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void EnsuresOnThrow&lt;TException&gt; (bool condition) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsuresOnThrow&lt;(class System.Exception) TException&gt;(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnsuresOnThrow(Of TException As Exception) (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void EnsuresOnThrow(bool condition);" />
      <MemberSignature Language="F#" Value="static member EnsuresOnThrow : bool -&gt; unit (requires 'Exception :&gt; Exception)" Usage="System.Diagnostics.Contracts.Contract.EnsuresOnThrow condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Diagnostics.Conditional("CONTRACTS_FULL")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.Conditional("CONTRACTS_FULL")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TException"><span data-ttu-id="f9b47-168">引发后置条件检查的异常的类型。</span><span class="sxs-lookup"><span data-stu-id="f9b47-168">The type of exception that invokes the postcondition check.</span></span></typeparam>
        <param name="condition"><span data-ttu-id="f9b47-169">要测试的条件表达式。</span><span class="sxs-lookup"><span data-stu-id="f9b47-169">The conditional expression to test.</span></span></param>
        <summary><span data-ttu-id="f9b47-170">基于提供的异常和条件为封闭方法或属性指定一个后置条件协定。</span><span class="sxs-lookup"><span data-stu-id="f9b47-170">Specifies a postcondition contract for the enclosing method or property, based on the provided exception and condition.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9b47-171">`condition`参数指定一个后置条件， `true` 当封闭方法或属性异常终止并引发类型的异常时，应为 `TException` 。</span><span class="sxs-lookup"><span data-stu-id="f9b47-171">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property terminates abnormally and an exception of type `TException` is thrown.</span></span>  
  
-   <span data-ttu-id="f9b47-172">此方法调用必须位于方法或属性的开头，位于任何其他代码之前。</span><span class="sxs-lookup"><span data-stu-id="f9b47-172">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="f9b47-173">此合同向客户端公开;因此，它必须只引用至少与封闭方法相同的成员。</span><span class="sxs-lookup"><span data-stu-id="f9b47-173">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="f9b47-174">必须使用二进制重写程序来执行此后置条件的运行时强制。</span><span class="sxs-lookup"><span data-stu-id="f9b47-174">You must use the binary rewriter for run-time enforcement of this postcondition.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsuresOnThrow&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void EnsuresOnThrow&lt;TException&gt; (bool condition, string userMessage) where TException : Exception;" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsuresOnThrow&lt;(class System.Exception) TException&gt;(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnsuresOnThrow(Of TException As Exception) (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void EnsuresOnThrow(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member EnsuresOnThrow : bool * string -&gt; unit (requires 'Exception :&gt; Exception)" Usage="System.Diagnostics.Contracts.Contract.EnsuresOnThrow (condition, userMessage)" />
      <MemberSignature Language="C#" Value="public static void EnsuresOnThrow&lt;TException&gt; (bool condition, string? userMessage) where TException : Exception;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Diagnostics.Conditional("CONTRACTS_FULL")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.Conditional("CONTRACTS_FULL")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TException"><span data-ttu-id="f9b47-175">引发后置条件检查的异常的类型。</span><span class="sxs-lookup"><span data-stu-id="f9b47-175">The type of exception that invokes the postcondition check.</span></span></typeparam>
        <param name="condition"><span data-ttu-id="f9b47-176">要测试的条件表达式。</span><span class="sxs-lookup"><span data-stu-id="f9b47-176">The conditional expression to test.</span></span></param>
        <param name="userMessage"><span data-ttu-id="f9b47-177">表达式为 <see langword="false" /> 时要显示的消息。</span><span class="sxs-lookup"><span data-stu-id="f9b47-177">The message to display if the expression is <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f9b47-178">基于提供的异常和条件为封闭方法或属性指定后置条件协定，并指定条件为 <see langword="false" /> 时要显示的消息。</span><span class="sxs-lookup"><span data-stu-id="f9b47-178">Specifies a postcondition contract and a message to display if the condition is <see langword="false" /> for the enclosing method or property, based on the provided exception and condition.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9b47-179">`condition`参数指定一个后置条件， `true` 当封闭方法或属性异常终止并引发类型的异常时，应为 `TException` 。</span><span class="sxs-lookup"><span data-stu-id="f9b47-179">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property terminates abnormally and an exception of type `TException` is thrown.</span></span> <span data-ttu-id="f9b47-180">`message`如果条件为，则参数指定要显示的消息 `false` 。</span><span class="sxs-lookup"><span data-stu-id="f9b47-180">The `message` parameter specifies a message to display if the condition is `false`.</span></span>  
  
-   <span data-ttu-id="f9b47-181">此方法调用必须位于方法或属性的开头，位于任何其他代码之前。</span><span class="sxs-lookup"><span data-stu-id="f9b47-181">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="f9b47-182">此合同向客户端公开;因此，它必须只引用至少与封闭方法相同的成员。</span><span class="sxs-lookup"><span data-stu-id="f9b47-182">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="f9b47-183">必须使用二进制重写程序来执行此后置条件的运行时强制。</span><span class="sxs-lookup"><span data-stu-id="f9b47-183">You must use the binary rewriter for run-time enforcement of this postcondition.</span></span>  
  
-   <span data-ttu-id="f9b47-184">如果不是 `userMessage` 常量字符串，则工具可能无法理解该协定。</span><span class="sxs-lookup"><span data-stu-id="f9b47-184">If `userMessage` is not a constant string literal, the contract may not be understood by tools.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (int fromInclusive, int toExclusive, Predicate&lt;int&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(int32 fromInclusive, int32 toExclusive, class System.Predicate`1&lt;int32&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (fromInclusive As Integer, toExclusive As Integer, predicate As Predicate(Of Integer)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(int fromInclusive, int toExclusive, Predicate&lt;int&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Exists : int * int * Predicate&lt;int&gt; -&gt; bool" Usage="System.Diagnostics.Contracts.Contract.Exists (fromInclusive, toExclusive, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="predicate" Type="System.Predicate&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="f9b47-185">要传递给 <paramref name="predicate" /> 的第一个整数。</span><span class="sxs-lookup"><span data-stu-id="f9b47-185">The first integer to pass to <paramref name="predicate" />.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="f9b47-186">要传递给 <paramref name="predicate" /> 的最后一个整数加一。</span><span class="sxs-lookup"><span data-stu-id="f9b47-186">One more than the last integer to pass to <paramref name="predicate" />.</span></span></param>
        <param name="predicate"><span data-ttu-id="f9b47-187">用于计算指定范围内整数的任何值的函数。</span><span class="sxs-lookup"><span data-stu-id="f9b47-187">The function to evaluate for any value of the integer in the specified range.</span></span></param>
        <summary><span data-ttu-id="f9b47-188">确定指定的测试对某个整数范围中的任何整数是否都为 true。</span><span class="sxs-lookup"><span data-stu-id="f9b47-188">Determines whether a specified test is true for any integer within a range of integers.</span></span></summary>
        <returns><span data-ttu-id="f9b47-189">如果 <paramref name="predicate" /> 对于从 <paramref name="fromInclusive" /> 开始到 <paramref name="toExclusive" /> - 1 的范围内的任何整数都返回 <see langword="true" />，则为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="f9b47-189"><see langword="true" /> if <paramref name="predicate" /> returns <see langword="true" /> for any integer starting from <paramref name="fromInclusive" /> to <paramref name="toExclusive" /> - 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9b47-190">`toExclusive`参数比最后一个整数要方便使用从0开始的整数范围的长度。</span><span class="sxs-lookup"><span data-stu-id="f9b47-190">The `toExclusive` parameter is one more than the last integer to facilitate using the length of a range of integers starting at 0.</span></span> <span data-ttu-id="f9b47-191">例如，对于整数0到4，它将设置为5。</span><span class="sxs-lookup"><span data-stu-id="f9b47-191">For example, it would be set to 5 for integers 0 through 4.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f9b47-192"><paramref name="predicate" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f9b47-192"><paramref name="predicate" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f9b47-193"><paramref name="toExclusive" /> 小于 <paramref name="fromInclusive" />。</span><span class="sxs-lookup"><span data-stu-id="f9b47-193"><paramref name="toExclusive" /> is less than <paramref name="fromInclusive" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; collection, Predicate&lt;T&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; collection, class System.Predicate`1&lt;!!T&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (collection As IEnumerable(Of T), predicate As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, Predicate&lt;T&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Exists : seq&lt;'T&gt; * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Diagnostics.Contracts.Contract.Exists (collection, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="predicate" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="f9b47-194"><paramref name="collection" /> 中包含的类型。</span><span class="sxs-lookup"><span data-stu-id="f9b47-194">The type that is contained in <paramref name="collection" />.</span></span></typeparam>
        <param name="collection"><span data-ttu-id="f9b47-195">将从中提取 <c>T</c> 类型的元素以将其传递给 <paramref name="predicate" /> 的集合。</span><span class="sxs-lookup"><span data-stu-id="f9b47-195">The collection from which elements of type <c>T</c> will be drawn to pass to <paramref name="predicate" />.</span></span></param>
        <param name="predicate"><span data-ttu-id="f9b47-196">用于计算 <paramref name="collection" /> 中某个元素的函数。</span><span class="sxs-lookup"><span data-stu-id="f9b47-196">The function to evaluate for an element in <paramref name="collection" />.</span></span></param>
        <summary><span data-ttu-id="f9b47-197">确定函数中是否存在某个元素集合中的元素。</span><span class="sxs-lookup"><span data-stu-id="f9b47-197">Determines whether an element within a collection of elements exists within a function.</span></span></summary>
        <returns><span data-ttu-id="f9b47-198">当且仅当 <paramref name="predicate" /> 对于 <paramref name="T" /> 中的 <paramref name="collection" /> 类型的任何元素都返回 <see langword="true" /> 时，才为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="f9b47-198"><see langword="true" /> if and only if <paramref name="predicate" /> returns <see langword="true" /> for any element of type <paramref name="T" /> in <paramref name="collection" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f9b47-199"><paramref name="collection" /> 或 <paramref name="predicate" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f9b47-199"><paramref name="collection" /> or <paramref name="predicate" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      </Docs>
    </Member>
    <Member MemberName="ForAll">
      <MemberSignature Language="C#" Value="public static bool ForAll (int fromInclusive, int toExclusive, Predicate&lt;int&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ForAll(int32 fromInclusive, int32 toExclusive, class System.Predicate`1&lt;int32&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForAll (fromInclusive As Integer, toExclusive As Integer, predicate As Predicate(Of Integer)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ForAll(int fromInclusive, int toExclusive, Predicate&lt;int&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member ForAll : int * int * Predicate&lt;int&gt; -&gt; bool" Usage="System.Diagnostics.Contracts.Contract.ForAll (fromInclusive, toExclusive, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="predicate" Type="System.Predicate&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="f9b47-200">要传递给 <paramref name="predicate" /> 的第一个整数。</span><span class="sxs-lookup"><span data-stu-id="f9b47-200">The first integer to pass to <paramref name="predicate" />.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="f9b47-201">要传递给 <paramref name="predicate" /> 的最后一个整数加一。</span><span class="sxs-lookup"><span data-stu-id="f9b47-201">One more than the last integer to pass to <paramref name="predicate" />.</span></span></param>
        <param name="predicate"><span data-ttu-id="f9b47-202">要计算其中是否存在指定范围内的整数的函数。</span><span class="sxs-lookup"><span data-stu-id="f9b47-202">The function to evaluate for the existence of the integers in the specified range.</span></span></param>
        <summary><span data-ttu-id="f9b47-203">确定某个特定条件是否对指定范围内的所有整数都有效。</span><span class="sxs-lookup"><span data-stu-id="f9b47-203">Determines whether a particular condition is valid for all integers in a specified range.</span></span></summary>
        <returns><span data-ttu-id="f9b47-204">如果 <paramref name="predicate" /> 对于从 <paramref name="fromInclusive" /> 开始到 <paramref name="toExclusive" /> - 1 的范围内的所有整数都返回 <see langword="true" />，则为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="f9b47-204"><see langword="true" /> if <paramref name="predicate" /> returns <see langword="true" /> for all integers starting from <paramref name="fromInclusive" /> to <paramref name="toExclusive" /> - 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9b47-205">`toExclusive`参数比最后一个整数要方便使用从0开始的整数范围的长度。</span><span class="sxs-lookup"><span data-stu-id="f9b47-205">The `toExclusive` parameter is one more than the last integer to facilitate using the length of a range of integers starting at 0.</span></span> <span data-ttu-id="f9b47-206">例如，对于整数0到4，它将设置为5。</span><span class="sxs-lookup"><span data-stu-id="f9b47-206">For example, it would be set to 5 for integers 0 through 4.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f9b47-207">下面的示例演示如何使用 <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> 方法来确定数组是否具有 null 元素。</span><span class="sxs-lookup"><span data-stu-id="f9b47-207">The following example demonstrates how to use the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> method to determine whether an array has a null element.</span></span>  
  
 [!code-csharp[Contract.ForAllExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/contract.forallexample/cs/program.cs#1)]
 [!code-vb[Contract.ForAllExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/contract.forallexample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f9b47-208"><paramref name="predicate" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f9b47-208"><paramref name="predicate" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f9b47-209"><paramref name="toExclusive" /> 小于 <paramref name="fromInclusive" />。</span><span class="sxs-lookup"><span data-stu-id="f9b47-209"><paramref name="toExclusive" /> is less than <paramref name="fromInclusive" />.</span></span></exception>
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      </Docs>
    </Member>
    <Member MemberName="ForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool ForAll&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; collection, Predicate&lt;T&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ForAll&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; collection, class System.Predicate`1&lt;!!T&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForAll(Of T) (collection As IEnumerable(Of T), predicate As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool ForAll(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, Predicate&lt;T&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member ForAll : seq&lt;'T&gt; * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Diagnostics.Contracts.Contract.ForAll (collection, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="predicate" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="f9b47-210"><paramref name="collection" /> 中包含的类型。</span><span class="sxs-lookup"><span data-stu-id="f9b47-210">The type that is contained in <paramref name="collection" />.</span></span></typeparam>
        <param name="collection"><span data-ttu-id="f9b47-211">将从中提取 <c>T</c> 类型的元素以将其传递给 <paramref name="predicate" /> 的集合。</span><span class="sxs-lookup"><span data-stu-id="f9b47-211">The collection from which elements of type <c>T</c> will be drawn to pass to <paramref name="predicate" />.</span></span></param>
        <param name="predicate"><span data-ttu-id="f9b47-212">用于计算 <paramref name="collection" /> 中所有元素是否存在的函数。</span><span class="sxs-lookup"><span data-stu-id="f9b47-212">The function to evaluate for the existence of all the elements in <paramref name="collection" />.</span></span></param>
        <summary><span data-ttu-id="f9b47-213">确定函数中是否存在某个集合中的所有元素。</span><span class="sxs-lookup"><span data-stu-id="f9b47-213">Determines whether all the elements in a collection exist within a function.</span></span></summary>
        <returns><span data-ttu-id="f9b47-214">当且仅当 <paramref name="predicate" /> 对于 <paramref name="T" /> 中的 <paramref name="collection" /> 类型的所有元素都返回 <see langword="true" /> 时，才为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="f9b47-214"><see langword="true" /> if and only if <paramref name="predicate" /> returns <see langword="true" /> for all elements of type <paramref name="T" /> in <paramref name="collection" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f9b47-215">下面的示例演示如何使用 <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> 方法来确定集合是否具有 null 元素。</span><span class="sxs-lookup"><span data-stu-id="f9b47-215">The following example demonstrates how to use the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> method to determine whether a collection has a null element.</span></span>  
  
 [!code-csharp[Contract.ForAllExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/contract.forallexample/cs/program.cs#1)]
 [!code-vb[Contract.ForAllExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/contract.forallexample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f9b47-216"><paramref name="collection" /> 或 <paramref name="predicate" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f9b47-216"><paramref name="collection" /> or <paramref name="predicate" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invariant">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f9b47-217">为封闭方法或属性指定一个协定。</span><span class="sxs-lookup"><span data-stu-id="f9b47-217">Specifies a contract for an enclosing method or property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invariant">
      <MemberSignature Language="C#" Value="public static void Invariant (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invariant(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invariant (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invariant(bool condition);" />
      <MemberSignature Language="F#" Value="static member Invariant : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Invariant condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Diagnostics.Conditional("CONTRACTS_FULL")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.Conditional("CONTRACTS_FULL")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="f9b47-218">要测试的条件表达式。</span><span class="sxs-lookup"><span data-stu-id="f9b47-218">The conditional expression to test.</span></span></param>
        <summary><span data-ttu-id="f9b47-219">为封闭方法或属性指定一个固定的协定。</span><span class="sxs-lookup"><span data-stu-id="f9b47-219">Specifies an invariant contract for the enclosing method or property.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9b47-220"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> 协定包含在由特性标识的方法中 <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> ; 通常，方法名为 `ObjectInvariant` 。</span><span class="sxs-lookup"><span data-stu-id="f9b47-220"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> contracts are contained within a method that is identified by the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute; typically, the method is named `ObjectInvariant`.</span></span>  
  
-   <span data-ttu-id="f9b47-221">只能在类上声明的专用固定方法中指定该协定。</span><span class="sxs-lookup"><span data-stu-id="f9b47-221">This contract can be specified only in a dedicated invariant method that is declared on a class.</span></span> <span data-ttu-id="f9b47-222">如果该方法不是密封的，则它应只引用受保护的成员而不是私有成员，这样子类就可以确保保持固定不变。</span><span class="sxs-lookup"><span data-stu-id="f9b47-222">If the method is not sealed, it should refer only to protected members, not private members, so that subclasses can be sure to maintain the invariants.</span></span>  
  
-   <span data-ttu-id="f9b47-223">此协定未向客户端公开;因此，它可能引用与封闭方法不可见的成员。</span><span class="sxs-lookup"><span data-stu-id="f9b47-223">This contract is not exposed to clients; therefore, it may reference members that are less visible than the enclosing method.</span></span>  
  
-   <span data-ttu-id="f9b47-224">必须使用二进制重写程序来执行此固定的运行时强制。</span><span class="sxs-lookup"><span data-stu-id="f9b47-224">You must use the binary rewriter for run-time enforcement of this invariant.</span></span>  
  
-   <span data-ttu-id="f9b47-225">固定条件根据符号是否存在有条件地定义 `CONTRACTS FULL` 。</span><span class="sxs-lookup"><span data-stu-id="f9b47-225">Invariants are conditionally defined based on the presence of the `CONTRACTS FULL` symbol.</span></span> <span data-ttu-id="f9b47-226">在运行时检查期间，每次公共方法结束都要检查固定协定。</span><span class="sxs-lookup"><span data-stu-id="f9b47-226">During run-time checking, invariants are checked at the end of each public method.</span></span> <span data-ttu-id="f9b47-227">如果某个固定条件提到同一个类中的公共方法，则在该公共方法结束时通常会发生的固定检查将被禁用，并且仅在对该类的最外面的方法调用结束时检查。</span><span class="sxs-lookup"><span data-stu-id="f9b47-227">If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled and checked only at the end of the outermost method call to that class.</span></span> <span data-ttu-id="f9b47-228">如果因调用其他类上的方法而重新输入类，也会发生此类情况。</span><span class="sxs-lookup"><span data-stu-id="f9b47-228">This also happens if the class is re-entered because of a call to a method on another class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invariant">
      <MemberSignature Language="C#" Value="public static void Invariant (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invariant(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invariant (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invariant(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Invariant : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Invariant (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Diagnostics.Conditional("CONTRACTS_FULL")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.Conditional("CONTRACTS_FULL")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="f9b47-229">要测试的条件表达式。</span><span class="sxs-lookup"><span data-stu-id="f9b47-229">The conditional expression to test.</span></span></param>
        <param name="userMessage"><span data-ttu-id="f9b47-230">条件为 <see langword="false" /> 时要显示的消息。</span><span class="sxs-lookup"><span data-stu-id="f9b47-230">The message to display if the condition is <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f9b47-231">为封闭方法或属性指定一个固定协定，并在该协定的条件失败时显示一条消息。</span><span class="sxs-lookup"><span data-stu-id="f9b47-231">Specifies an invariant contract for the enclosing method or property, and displays a message if the condition for the contract fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9b47-232"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> 协定包含在由特性标识的方法中 <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> ; 通常，方法名为 `ObjectInvariant` 。</span><span class="sxs-lookup"><span data-stu-id="f9b47-232"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> contracts are contained within a method that is identified by the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute; typically, the method is named `ObjectInvariant`.</span></span>  
  
-   <span data-ttu-id="f9b47-233">只能在类上声明的专用固定方法中指定该协定。</span><span class="sxs-lookup"><span data-stu-id="f9b47-233">This contract can be specified only in a dedicated invariant method that is declared on a class.</span></span>  
  
-   <span data-ttu-id="f9b47-234">此协定未向客户端公开;因此，它可能引用与封闭方法不可见的成员。</span><span class="sxs-lookup"><span data-stu-id="f9b47-234">This contract is not exposed to clients; therefore, it may reference members that are less visible than the enclosing method.</span></span>  
  
-   <span data-ttu-id="f9b47-235">必须使用二进制重写程序来执行此固定的运行时强制。</span><span class="sxs-lookup"><span data-stu-id="f9b47-235">You must use the binary rewriter for run-time enforcement of this invariant.</span></span>  
  
-   <span data-ttu-id="f9b47-236">固定条件是在符号上定义的 `CONTRACTS FULL` 。</span><span class="sxs-lookup"><span data-stu-id="f9b47-236">Invariants are conditionally defined on the `CONTRACTS FULL` symbol.</span></span> <span data-ttu-id="f9b47-237">在运行时检查期间，每次公共方法结束都要检查固定协定。</span><span class="sxs-lookup"><span data-stu-id="f9b47-237">During run-time checking, invariants are checked at the end of each public method.</span></span> <span data-ttu-id="f9b47-238">如果某个固定条件提到同一个类中的公共方法，则在该公共方法结束时通常会发生的固定检查将被禁用，并且仅在对该类的最外面的方法调用结束时检查。</span><span class="sxs-lookup"><span data-stu-id="f9b47-238">If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled and checked only at the end of the outermost method call to that class.</span></span> <span data-ttu-id="f9b47-239">如果因调用其他类上的方法而重新输入类，也会发生此类情况。</span><span class="sxs-lookup"><span data-stu-id="f9b47-239">This also happens if the class is re-entered because of a call to a method on another class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OldValue&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T OldValue&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T OldValue&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OldValue(Of T) (value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T OldValue(T value);" />
      <MemberSignature Language="F#" Value="static member OldValue : 'T -&gt; 'T" Usage="System.Diagnostics.Contracts.Contract.OldValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="f9b47-240">值的类型。</span><span class="sxs-lookup"><span data-stu-id="f9b47-240">The type of value.</span></span></typeparam>
        <param name="value"><span data-ttu-id="f9b47-241">要表示的值（字段或参数）。</span><span class="sxs-lookup"><span data-stu-id="f9b47-241">The value to represent (field or parameter).</span></span></param>
        <summary><span data-ttu-id="f9b47-242">表示方法或属性开始时的值。</span><span class="sxs-lookup"><span data-stu-id="f9b47-242">Represents values as they were at the start of a method or property.</span></span></summary>
        <returns><span data-ttu-id="f9b47-243">一个方法或属性开始处的参数或字段的值。</span><span class="sxs-lookup"><span data-stu-id="f9b47-243">The value of the parameter or field at the start of a method or property.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9b47-244">此方法只能在协定的条件表达式中使用 <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f9b47-244">This method can be used only in the conditional expression for the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contract.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f9b47-245">下面的示例演示 <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> 如何使用方法确保已更新计数。</span><span class="sxs-lookup"><span data-stu-id="f9b47-245">The following example shows the use of the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method to ensure that a count has been updated.</span></span> <span data-ttu-id="f9b47-246">此代码示例是为类提供的更大示例的一部分 <xref:System.Diagnostics.Contracts.ContractClassAttribute> 。</span><span class="sxs-lookup"><span data-stu-id="f9b47-246">This code example is part of a larger example provided for the <xref:System.Diagnostics.Contracts.ContractClassAttribute> class.</span></span>  
  
 [!code-csharp[ContractExample#5](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#5)]
 [!code-vb[ContractExample#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Requires">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f9b47-247">为封闭方法或属性指定一个前置条件协定。</span><span class="sxs-lookup"><span data-stu-id="f9b47-247">Specifies a precondition contract for an enclosing method or property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Requires">
      <MemberSignature Language="C#" Value="public static void Requires (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Requires(bool condition);" />
      <MemberSignature Language="F#" Value="static member Requires : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Requires condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Diagnostics.Conditional("CONTRACTS_FULL")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.Conditional("CONTRACTS_FULL")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="f9b47-248">要测试的条件表达式。</span><span class="sxs-lookup"><span data-stu-id="f9b47-248">The conditional expression to test.</span></span></param>
        <summary><span data-ttu-id="f9b47-249">为封闭方法或属性指定一个前置条件协定。</span><span class="sxs-lookup"><span data-stu-id="f9b47-249">Specifies a precondition contract for the enclosing method or property.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   <span data-ttu-id="f9b47-250">此方法调用必须位于方法或属性的开头，位于任何其他代码之前。</span><span class="sxs-lookup"><span data-stu-id="f9b47-250">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="f9b47-251">此合同向客户端公开;因此，它必须只引用至少与封闭方法相同的成员。</span><span class="sxs-lookup"><span data-stu-id="f9b47-251">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="f9b47-252"><xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%29?displayProperty=nameWithType>当向后兼容性不强制引发特定异常时，请使用此方法而不是方法。</span><span class="sxs-lookup"><span data-stu-id="f9b47-252">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%29?displayProperty=nameWithType> method when backward compatibility does not force you to throw a particular exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires">
      <MemberSignature Language="C#" Value="public static void Requires (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Requires(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Requires : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Requires (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Diagnostics.Conditional("CONTRACTS_FULL")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.Conditional("CONTRACTS_FULL")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="f9b47-253">要测试的条件表达式。</span><span class="sxs-lookup"><span data-stu-id="f9b47-253">The conditional expression to test.</span></span></param>
        <param name="userMessage"><span data-ttu-id="f9b47-254">条件为 <see langword="false" /> 时要显示的消息。</span><span class="sxs-lookup"><span data-stu-id="f9b47-254">The message to display if the condition is <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f9b47-255">为封闭方法或属性指定一个前置条件协定，并在该协定的条件失败时显示一条消息。</span><span class="sxs-lookup"><span data-stu-id="f9b47-255">Specifies a precondition contract for the enclosing method or property, and displays a message if the condition for the contract fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   <span data-ttu-id="f9b47-256">此方法调用必须位于方法或属性的开头，位于任何其他代码之前。</span><span class="sxs-lookup"><span data-stu-id="f9b47-256">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="f9b47-257">此合同向客户端公开;因此，它必须只引用至少与封闭方法相同的成员。</span><span class="sxs-lookup"><span data-stu-id="f9b47-257">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="f9b47-258"><xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType>当向后兼容性不强制引发特定异常时，请使用此方法而不是方法。</span><span class="sxs-lookup"><span data-stu-id="f9b47-258">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> method when backward compatibility does not force you to throw a particular exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void Requires&lt;TException&gt; (bool condition) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires&lt;(class System.Exception) TException&gt;(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires(Of TException As Exception) (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void Requires(bool condition);" />
      <MemberSignature Language="F#" Value="static member Requires : bool -&gt; unit (requires 'Exception :&gt; Exception)" Usage="System.Diagnostics.Contracts.Contract.Requires condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TException"><span data-ttu-id="f9b47-259">条件为 <see langword="false" /> 时要引发的异常。</span><span class="sxs-lookup"><span data-stu-id="f9b47-259">The exception to throw if the condition is <see langword="false" />.</span></span></typeparam>
        <param name="condition"><span data-ttu-id="f9b47-260">要测试的条件表达式。</span><span class="sxs-lookup"><span data-stu-id="f9b47-260">The conditional expression to test.</span></span></param>
        <summary><span data-ttu-id="f9b47-261">为封闭方法或属性指定一个前置条件协定，并在该协定的条件失败时引发异常。</span><span class="sxs-lookup"><span data-stu-id="f9b47-261">Specifies a precondition contract for the enclosing method or property, and throws an exception if the condition for the contract fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="f9b47-262">若要使用方法，必须启用运行时检查 <xref:System.Diagnostics.Contracts.Contract.Requires%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f9b47-262">You must turn on run-time checking to use the <xref:System.Diagnostics.Contracts.Contract.Requires%2A> method.</span></span> <span data-ttu-id="f9b47-263">如果运行时检查处于关闭状态，则进程将被终止。</span><span class="sxs-lookup"><span data-stu-id="f9b47-263">If run-time checking is turned off, the process will be terminated.</span></span> <span data-ttu-id="f9b47-264">若要获取运行时检查的工具，请参阅 Visual Studio Marketplace 上的 [代码协定](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) 。</span><span class="sxs-lookup"><span data-stu-id="f9b47-264">To obtain the tools for runtime checking, see [Code Contracts](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) on the Visual Studio Marketplace.</span></span>  
  
-   <span data-ttu-id="f9b47-265">此方法调用必须位于方法或属性的开头，位于任何其他代码之前。</span><span class="sxs-lookup"><span data-stu-id="f9b47-265">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="f9b47-266">此合同向客户端公开;因此，它必须只引用至少与封闭方法相同的成员。</span><span class="sxs-lookup"><span data-stu-id="f9b47-266">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="f9b47-267"><xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%29?displayProperty=nameWithType>如果要在前置条件失败时引发异常，请使用此方法而不是方法。</span><span class="sxs-lookup"><span data-stu-id="f9b47-267">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%29?displayProperty=nameWithType> method when you want to throw an exception if the precondition fails.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void Requires&lt;TException&gt; (bool condition, string userMessage) where TException : Exception;" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires&lt;(class System.Exception) TException&gt;(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires(Of TException As Exception) (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void Requires(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Requires : bool * string -&gt; unit (requires 'Exception :&gt; Exception)" Usage="System.Diagnostics.Contracts.Contract.Requires (condition, userMessage)" />
      <MemberSignature Language="C#" Value="public static void Requires&lt;TException&gt; (bool condition, string? userMessage) where TException : Exception;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TException"><span data-ttu-id="f9b47-268">条件为 <see langword="false" /> 时要引发的异常。</span><span class="sxs-lookup"><span data-stu-id="f9b47-268">The exception to throw if the condition is <see langword="false" />.</span></span></typeparam>
        <param name="condition"><span data-ttu-id="f9b47-269">要测试的条件表达式。</span><span class="sxs-lookup"><span data-stu-id="f9b47-269">The conditional expression to test.</span></span></param>
        <param name="userMessage"><span data-ttu-id="f9b47-270">条件为 <see langword="false" /> 时要显示的消息。</span><span class="sxs-lookup"><span data-stu-id="f9b47-270">The message to display if the condition is <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f9b47-271">为封闭方法或属性指定一个前置条件协定，并在该协定的条件失败时引发包含提供的消息的异常。</span><span class="sxs-lookup"><span data-stu-id="f9b47-271">Specifies a precondition contract for the enclosing method or property, and throws an exception with the provided message if the condition for the contract fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   > [!IMPORTANT]
    >  <span data-ttu-id="f9b47-272">若要使用方法，必须启用运行时检查 <xref:System.Diagnostics.Contracts.Contract.Requires%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f9b47-272">You must turn on run-time checking to use the <xref:System.Diagnostics.Contracts.Contract.Requires%2A> method.</span></span> <span data-ttu-id="f9b47-273">如果运行时检查处于关闭状态，则进程将被终止。</span><span class="sxs-lookup"><span data-stu-id="f9b47-273">If run-time checking is turned off, the process will be terminated.</span></span> <span data-ttu-id="f9b47-274">若要获取运行时检查的工具，请参阅 Visual Studio Marketplace 上的 [代码协定](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) 。</span><span class="sxs-lookup"><span data-stu-id="f9b47-274">To obtain the tools for runtime checking, see [Code Contracts](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) on the Visual Studio Marketplace.</span></span>  
  
     <span data-ttu-id="f9b47-275">此方法调用必须位于方法或属性的开头，位于任何其他代码之前。</span><span class="sxs-lookup"><span data-stu-id="f9b47-275">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="f9b47-276">此合同向客户端公开;因此，它必须只引用至少与封闭方法相同的成员。</span><span class="sxs-lookup"><span data-stu-id="f9b47-276">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="f9b47-277"><xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType>如果要在前置条件失败时引发异常，请使用此方法而不是方法。</span><span class="sxs-lookup"><span data-stu-id="f9b47-277">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> method when you want to throw an exception if the precondition fails.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Result&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Result&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Result&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Result``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Result(Of T) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Result();" />
      <MemberSignature Language="F#" Value="static member Result : unit -&gt; 'T" Usage="System.Diagnostics.Contracts.Contract.Result " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T"><span data-ttu-id="f9b47-278">封闭方法或属性的返回值的类型。</span><span class="sxs-lookup"><span data-stu-id="f9b47-278">Type of return value of the enclosing method or property.</span></span></typeparam>
        <summary><span data-ttu-id="f9b47-279">表示一个方法或属性的返回值。</span><span class="sxs-lookup"><span data-stu-id="f9b47-279">Represents the return value of a method or property.</span></span></summary>
        <returns><span data-ttu-id="f9b47-280">封闭方法或属性的返回值。</span><span class="sxs-lookup"><span data-stu-id="f9b47-280">Return value of the enclosing method or property.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9b47-281">此方法只能在协定的条件表达式中使用 <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f9b47-281">This method can be used only in the conditional expression for the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contract.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f9b47-282">下面的示例演示如何使用 <xref:System.Diagnostics.Contracts.Contract.Result%2A> 方法来指定预期的返回值。</span><span class="sxs-lookup"><span data-stu-id="f9b47-282">The following example shows how to use the <xref:System.Diagnostics.Contracts.Contract.Result%2A> method to specify an expected return value.</span></span> <span data-ttu-id="f9b47-283">此代码示例是为类提供的更大示例的一部分 <xref:System.Diagnostics.Contracts.ContractClassAttribute> 。</span><span class="sxs-lookup"><span data-stu-id="f9b47-283">This code example is part of a larger example provided for the <xref:System.Diagnostics.Contracts.ContractClassAttribute> class.</span></span>  
  
 [!code-csharp[ContractExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#3)]
 [!code-vb[ContractExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueAtReturn&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T ValueAtReturn&lt;T&gt; (out T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T ValueAtReturn&lt;T&gt;([out] !!T&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ValueAtReturn(Of T) (ByRef value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T ValueAtReturn([Runtime::InteropServices::Out] T % value);" />
      <MemberSignature Language="F#" Value="static member ValueAtReturn : 'T -&gt; 'T" Usage="System.Diagnostics.Contracts.Contract.ValueAtReturn value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="f9b47-284"><see langword="out" /> 参数的类型。</span><span class="sxs-lookup"><span data-stu-id="f9b47-284">The type of the <see langword="out" /> parameter.</span></span></typeparam>
        <param name="value"><span data-ttu-id="f9b47-285"><see langword="out" /> 参数。</span><span class="sxs-lookup"><span data-stu-id="f9b47-285">The <see langword="out" /> parameter.</span></span></param>
        <summary><span data-ttu-id="f9b47-286">表示从一个方法返回时 <see langword="out" /> 参数的最终（输出）值。</span><span class="sxs-lookup"><span data-stu-id="f9b47-286">Represents the final (output) value of an <see langword="out" /> parameter when returning from a method.</span></span></summary>
        <returns><span data-ttu-id="f9b47-287"><see langword="out" /> 参数的输出值。</span><span class="sxs-lookup"><span data-stu-id="f9b47-287">The output value of the <see langword="out" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9b47-288">此方法只能在协定的条件表达式中使用 <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f9b47-288">This method can be used only in the conditional expression for the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contract.</span></span> <span data-ttu-id="f9b47-289">与 <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> 方法一样，每次编译器能推断出类型时都可发出泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="f9b47-289">As with the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method, you can omit the generic type parameter whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="f9b47-290">协定重写程序将方法调用替换为 `out` 参数的值。</span><span class="sxs-lookup"><span data-stu-id="f9b47-290">The contract rewriter replaces the method call with the value of the `out` parameter.</span></span> <span data-ttu-id="f9b47-291"><xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> 方法仅可在后置条件中出现。</span><span class="sxs-lookup"><span data-stu-id="f9b47-291">The <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method may appear only in postconditions.</span></span> <span data-ttu-id="f9b47-292">方法的自变量必须为 `out` 参数或结构 `out` 参数的字段。</span><span class="sxs-lookup"><span data-stu-id="f9b47-292">The argument to the method must be an `out` parameter or a field of a structure `out` parameter.</span></span> <span data-ttu-id="f9b47-293">在引用结构构造函数后置条件中的字段时，后者也非常有用。</span><span class="sxs-lookup"><span data-stu-id="f9b47-293">The latter is also useful when referring to fields in the postcondition of a structure constructor.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
