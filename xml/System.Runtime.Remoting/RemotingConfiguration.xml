<Type Name="RemotingConfiguration" FullName="System.Runtime.Remoting.RemotingConfiguration">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f92bff6d51bd93a82c26549722c4633383e1a8c0" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86756044" /></Metadata><TypeSignature Language="C#" Value="public class RemotingConfiguration" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RemotingConfiguration extends System.Object" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Remoting.RemotingConfiguration" />
  <TypeSignature Language="VB.NET" Value="Public Class RemotingConfiguration" />
  <TypeSignature Language="C++ CLI" Value="public ref class RemotingConfiguration" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="F#" Value="type RemotingConfiguration = class" />
  <TypeSignature Language="C#" Value="public static class RemotingConfiguration" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit RemotingConfiguration extends System.Object" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class RemotingConfiguration abstract sealed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="449d6-101">提供多种配置远程处理结构的静态方法。</span><span class="sxs-lookup"><span data-stu-id="449d6-101">Provides various static methods for configuring the remoting infrastructure.</span></span></summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="ApplicationId">
      <MemberSignature Language="C#" Value="public static string ApplicationId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ApplicationId" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.RemotingConfiguration.ApplicationId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ApplicationId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ApplicationId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationId : string" Usage="System.Runtime.Remoting.RemotingConfiguration.ApplicationId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="449d6-102">获取当前正在执行的应用程序的 ID。</span><span class="sxs-lookup"><span data-stu-id="449d6-102">Gets the ID of the currently executing application.</span></span></summary>
        <value><span data-ttu-id="449d6-103">一个 <see cref="T:System.String" />，包含当前正在执行的应用程序的 ID。</span><span class="sxs-lookup"><span data-stu-id="449d6-103">A <see cref="T:System.String" /> that contains the ID of the currently executing application.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="449d6-104">应用程序 ID 预置于当前正在执行的应用程序所创建的对象的 URI。</span><span class="sxs-lookup"><span data-stu-id="449d6-104">The application ID is prepended to the URI of the objects created by the currently executing application.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="449d6-105">直接调用方没有基础结构权限。</span><span class="sxs-lookup"><span data-stu-id="449d6-105">The immediate caller does not have infrastructure permission.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public static string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.RemotingConfiguration.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.Runtime.Remoting.RemotingConfiguration.ApplicationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[set: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="449d6-106">获取或设置远程处理应用程序的名称。</span><span class="sxs-lookup"><span data-stu-id="449d6-106">Gets or sets the name of a remoting application.</span></span></summary>
        <value><span data-ttu-id="449d6-107">远程处理应用程序的名称。</span><span class="sxs-lookup"><span data-stu-id="449d6-107">The name of a remoting application.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="449d6-108">仅可通过当前属性或通过配置文件设置应用程序名称一次。</span><span class="sxs-lookup"><span data-stu-id="449d6-108">An application name can be set only once, either through the current property or through a configuration file.</span></span> <span data-ttu-id="449d6-109">如果应用程序在宿主环境中运行（例如 Internet Information Services (IIS) ），则此值可能已 (通常设置为虚拟目录) 。</span><span class="sxs-lookup"><span data-stu-id="449d6-109">If an application is running inside a hosted environment, such as Internet Information Services (IIS), this value might have already been set (usually to the virtual directory).</span></span> <span data-ttu-id="449d6-110">`null`如果尚未设置应用程序名称，则当前属性将返回。</span><span class="sxs-lookup"><span data-stu-id="449d6-110">The current property will return `null` if the application name has not been set.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="449d6-111">下面的代码示例演示如何使用 <xref:System.Runtime.Remoting.RemotingConfiguration.ApplicationName%2A> 属性来指示远程处理应用程序的名称。</span><span class="sxs-lookup"><span data-stu-id="449d6-111">The following code example demonstrates the use of the <xref:System.Runtime.Remoting.RemotingConfiguration.ApplicationName%2A> property to indicate the name of the remoting application.</span></span> <span data-ttu-id="449d6-112">有关完整的示例代码，请参阅 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> 和方法的示例 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType%2A> 。</span><span class="sxs-lookup"><span data-stu-id="449d6-112">For the full example code, see examples for the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> and <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType%2A> methods.</span></span>  
  
 [!code-cpp[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/server.cpp#2)]
 [!code-csharp[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/server.cs#2)]
 [!code-vb[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/server.vb#2)]  
  
 <span data-ttu-id="449d6-113">下面的代码示例演示如何访问从命名应用程序进行远程处理的对象。</span><span class="sxs-lookup"><span data-stu-id="449d6-113">The following code example demonstrates how to access an object remoted from a named application.</span></span>  
  
 [!code-cpp[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/client.cpp#6)]
 [!code-csharp[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/client.cs#6)]
 [!code-vb[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/client.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="449d6-114">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span><span class="sxs-lookup"><span data-stu-id="449d6-114">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span></span> <span data-ttu-id="449d6-115">仅在设置该属性值时才会引发此异常。</span><span class="sxs-lookup"><span data-stu-id="449d6-115">This exception is thrown only when setting the property value.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Configure">
      <MemberSignature Language="C#" Value="public static void Configure (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Configure(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.Configure(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Configure (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Configure(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="static member Configure : string -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.Configure filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Obsolete("Use System.Runtime.Remoting.RemotingConfiguration.Configure(string fileName, bool ensureSecurity) instead.", false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use System.Runtime.Remoting.RemotingConfiguration.Configure(string fileName, bool ensureSecurity) instead.", false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Obsolete("Use Configure(String,Boolean)")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use Configure(String,Boolean)")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename"><span data-ttu-id="449d6-116">远程处理配置文件的名称。</span><span class="sxs-lookup"><span data-stu-id="449d6-116">The name of the remoting configuration file.</span></span> <span data-ttu-id="449d6-117">可以为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="449d6-117">Can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="449d6-118">读取配置文件并配置远程处理结构。</span><span class="sxs-lookup"><span data-stu-id="449d6-118">Reads the configuration file and configures the remoting infrastructure.</span></span> <span data-ttu-id="449d6-119"><see cref="M:System.Runtime.Remoting.RemotingConfiguration.Configure(System.String)" /> 已过时。</span><span class="sxs-lookup"><span data-stu-id="449d6-119"><see cref="M:System.Runtime.Remoting.RemotingConfiguration.Configure(System.String)" /> is obsolete.</span></span> <span data-ttu-id="449d6-120">请改用 <see cref="M:System.Runtime.Remoting.RemotingConfiguration.Configure(System.String,System.Boolean)" />。</span><span class="sxs-lookup"><span data-stu-id="449d6-120">Please use <see cref="M:System.Runtime.Remoting.RemotingConfiguration.Configure(System.String,System.Boolean)" /> instead.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="449d6-121"><xref:System.Runtime.Remoting.RemotingConfiguration.Configure%28System.String%29> 已过时。</span><span class="sxs-lookup"><span data-stu-id="449d6-121"><xref:System.Runtime.Remoting.RemotingConfiguration.Configure%28System.String%29> is obsolete.</span></span> <span data-ttu-id="449d6-122">请改用 <xref:System.Runtime.Remoting.RemotingConfiguration.Configure%28System.String%2CSystem.Boolean%29>。</span><span class="sxs-lookup"><span data-stu-id="449d6-122">Please use <xref:System.Runtime.Remoting.RemotingConfiguration.Configure%28System.String%2CSystem.Boolean%29> instead.</span></span>  
  
 <span data-ttu-id="449d6-123">`null`作为参数传递 `filename` 将导致默认远程处理初始化，而不需要配置文件存在。</span><span class="sxs-lookup"><span data-stu-id="449d6-123">Passing `null` as the `filename` parameter will cause default remoting initialization without requiring the existence of a configuration file.</span></span>  
  
 <span data-ttu-id="449d6-124">有关配置文件语法，请参阅 [远程处理设置架构](https://msdn.microsoft.com/library/dc2d1e62-9af7-4ca1-99fd-98b93bb4db9e)。</span><span class="sxs-lookup"><span data-stu-id="449d6-124">For configuration file syntax, see [Remoting Settings Schema](https://msdn.microsoft.com/library/dc2d1e62-9af7-4ca1-99fd-98b93bb4db9e).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="449d6-125"> (Mbr 的封送处理对象) 不会永久驻留在内存中。</span><span class="sxs-lookup"><span data-stu-id="449d6-125">Marshal-by-reference objects (MBRs) do not reside in memory forever.</span></span> <span data-ttu-id="449d6-126">相反，除非类型重写 <xref:System.MarshalByRefObject.InitializeLifetimeService%2A?displayProperty=nameWithType> 来控制其自身的生存期策略，否则，每个 MBR 在 .NET Framework 远程处理系统开始删除它并回收内存之前，将具有有限的生存期。</span><span class="sxs-lookup"><span data-stu-id="449d6-126">Instead, unless the type overrides <xref:System.MarshalByRefObject.InitializeLifetimeService%2A?displayProperty=nameWithType> to control its own lifetime policies, each MBR has a finite lifetime before the .NET Framework remoting system begins the process of deleting it and reclaiming the memory.</span></span> <span data-ttu-id="449d6-127">有关详细信息，请参阅 [生存期租约](https://msdn.microsoft.com/library/c72d561c-1266-4c8b-b258-2c168c08da9a)。</span><span class="sxs-lookup"><span data-stu-id="449d6-127">For more information, see [Lifetime Leases](https://msdn.microsoft.com/library/c72d561c-1266-4c8b-b258-2c168c08da9a).</span></span>  
  
   
  
## Examples  
 [!code-cpp[RemotingConfiguration_Configure_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/CPP/remotingconfiguration_configure_server.cpp#1)]
 [!code-csharp[RemotingConfiguration_Configure_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/CS/remotingconfiguration_configure_server.cs#1)]
 [!code-vb[RemotingConfiguration_Configure_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/VB/remotingconfiguration_configure_server.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="449d6-128">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span><span class="sxs-lookup"><span data-stu-id="449d6-128">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Configure">
      <MemberSignature Language="C#" Value="public static void Configure (string filename, bool ensureSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Configure(string filename, bool ensureSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.Configure(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Configure (filename As String, ensureSecurity As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Configure(System::String ^ filename, bool ensureSecurity);" />
      <MemberSignature Language="F#" Value="static member Configure : string * bool -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.Configure (filename, ensureSecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ensureSecurity" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="filename"><span data-ttu-id="449d6-129">远程处理配置文件的名称。</span><span class="sxs-lookup"><span data-stu-id="449d6-129">The name of the remoting configuration file.</span></span> <span data-ttu-id="449d6-130">可以为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="449d6-130">Can be <see langword="null" />.</span></span></param>
        <param name="ensureSecurity"><span data-ttu-id="449d6-131">如果设置为 <see langword="true" />，则安全是必选项。</span><span class="sxs-lookup"><span data-stu-id="449d6-131">If set to <see langword="true" /> security is required.</span></span> <span data-ttu-id="449d6-132">如果设置为 <see langword="false" />，则安全不是必选项，但仍可能会用到。</span><span class="sxs-lookup"><span data-stu-id="449d6-132">If set to <see langword="false" />, security is not required but still may be used.</span></span></param>
        <summary><span data-ttu-id="449d6-133">读取配置文件并配置远程处理结构。</span><span class="sxs-lookup"><span data-stu-id="449d6-133">Reads the configuration file and configures the remoting infrastructure.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="449d6-134">`null`作为参数传递 `filename` 将导致默认远程处理初始化，而不需要配置文件存在。</span><span class="sxs-lookup"><span data-stu-id="449d6-134">Passing `null` as the `filename` parameter will cause default remoting initialization without requiring the existence of a configuration file.</span></span> <span data-ttu-id="449d6-135">有关远程处理和安全性的详细信息，请参阅 [远程处理中的安全性。](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/9hwst9th(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="449d6-135">For more information about remoting and security see [Security in Remoting.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/9hwst9th(v=vs.100))</span></span>  
  
 <span data-ttu-id="449d6-136">有关配置文件语法，请参阅 [远程处理设置架构](https://msdn.microsoft.com/library/dc2d1e62-9af7-4ca1-99fd-98b93bb4db9e)。</span><span class="sxs-lookup"><span data-stu-id="449d6-136">For configuration file syntax, see [Remoting Settings Schema](https://msdn.microsoft.com/library/dc2d1e62-9af7-4ca1-99fd-98b93bb4db9e).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="449d6-137"> (Mbr 的封送处理对象) 不会永久驻留在内存中。</span><span class="sxs-lookup"><span data-stu-id="449d6-137">Marshal-by-reference objects (MBRs) do not reside in memory forever.</span></span> <span data-ttu-id="449d6-138">相反，除非类型重写 <xref:System.MarshalByRefObject.InitializeLifetimeService%2A?displayProperty=nameWithType> 来控制其自身的生存期策略，否则，每个 MBR 在 .NET Framework 远程处理系统开始删除它并回收内存之前，将具有有限的生存期。</span><span class="sxs-lookup"><span data-stu-id="449d6-138">Instead, unless the type overrides <xref:System.MarshalByRefObject.InitializeLifetimeService%2A?displayProperty=nameWithType> to control its own lifetime policies, each MBR has a finite lifetime before the .NET Framework remoting system begins the process of deleting it and reclaiming the memory.</span></span> <span data-ttu-id="449d6-139">有关详细信息，请参阅 [生存期租约](https://msdn.microsoft.com/library/c72d561c-1266-4c8b-b258-2c168c08da9a)。</span><span class="sxs-lookup"><span data-stu-id="449d6-139">For more information, see [Lifetime Leases](https://msdn.microsoft.com/library/c72d561c-1266-4c8b-b258-2c168c08da9a).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="449d6-140">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span><span class="sxs-lookup"><span data-stu-id="449d6-140">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CustomErrorsEnabled">
      <MemberSignature Language="C#" Value="public static bool CustomErrorsEnabled (bool isLocalRequest);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CustomErrorsEnabled(bool isLocalRequest) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.CustomErrorsEnabled(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CustomErrorsEnabled (isLocalRequest As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool CustomErrorsEnabled(bool isLocalRequest);" />
      <MemberSignature Language="F#" Value="static member CustomErrorsEnabled : bool -&gt; bool" Usage="System.Runtime.Remoting.RemotingConfiguration.CustomErrorsEnabled isLocalRequest" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isLocalRequest" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isLocalRequest"><span data-ttu-id="449d6-141"><see langword="true" /> 用于指定本地调用方，<see langword="false" /> 用于指定远程调用方。</span><span class="sxs-lookup"><span data-stu-id="449d6-141"><see langword="true" /> to specify local callers; <see langword="false" /> to specify remote callers.</span></span></param>
        <summary><span data-ttu-id="449d6-142">指示此应用程序域中的服务器信道是向本地或远程调用方返回经过筛选的异常信息，还是返回完整的异常信息。</span><span class="sxs-lookup"><span data-stu-id="449d6-142">Indicates whether the server channels in this application domain return filtered or complete exception information to local or remote callers.</span></span></summary>
        <returns><span data-ttu-id="449d6-143">如果只将筛选过的异常信息返回给本地调用方或远程调用方（具体返回给哪些调用方由 <paramref name="isLocalRequest" /> 参数指定），则为 <see langword="true" />；如果返回完整的异常信息，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="449d6-143"><see langword="true" /> if only filtered exception information is returned to local or remote callers, as specified by the <paramref name="isLocalRequest" /> parameter; <see langword="false" /> if complete exception information is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="449d6-144">完整的异常信息包括确切的服务器异常信息和服务器堆栈跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="449d6-144">Complete exception information includes the exact server exception and the server stack trace.</span></span> <span data-ttu-id="449d6-145">筛选后的信息包括标准的远程异常信息，但不包括服务器堆栈跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="449d6-145">Filtered information includes a standard remoting exception but no server stack trace.</span></span>  
  
 <span data-ttu-id="449d6-146">`CustomErrorsEnabled`方法反映在 `mode` `<customErrors>` 应用程序配置文件的元素的属性中指定的配置设置。</span><span class="sxs-lookup"><span data-stu-id="449d6-146">The `CustomErrorsEnabled` method reflects configuration settings that were specified in the `mode` attribute of the `<customErrors>` element of the application configuration file.</span></span> <span data-ttu-id="449d6-147">有关配置选项的详细信息，请参阅 [远程应用程序的配置](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/b8tysty8(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="449d6-147">For more information about configuration options, see [Configuration of Remote Applications](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/b8tysty8(v=vs.100)).</span></span>  
  
 <span data-ttu-id="449d6-148">下表显示了三个服务器通道属性值，这些值指定哪些调用方会收到异常信息以及接收到的信息类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-148">The following table shows the three server channel property values that specify which callers receive exception information and what type of information they receive.</span></span>  
  
|<span data-ttu-id="449d6-149">“值”</span><span class="sxs-lookup"><span data-stu-id="449d6-149">Value</span></span>|<span data-ttu-id="449d6-150">说明</span><span class="sxs-lookup"><span data-stu-id="449d6-150">Description</span></span>|  
|-----------|-----------------|  
|`off`|<span data-ttu-id="449d6-151">所有调用方均收到完整的异常信息。</span><span class="sxs-lookup"><span data-stu-id="449d6-151">All callers receive complete exception information.</span></span>|  
|`on`|<span data-ttu-id="449d6-152">所有调用方均收到筛选后的异常信息。</span><span class="sxs-lookup"><span data-stu-id="449d6-152">All callers receive filtered exception information.</span></span>|  
|`remoteOnly`|<span data-ttu-id="449d6-153">本地调用方收到完整的异常信息，远程调用方收到筛选后的异常信息。</span><span class="sxs-lookup"><span data-stu-id="449d6-153">Local callers receive complete exception information; remote callers receive filtered exception information.</span></span>|  
  
 <span data-ttu-id="449d6-154">下表显示了 `isLocalRequest` 参数和服务器信道属性的交互。</span><span class="sxs-lookup"><span data-stu-id="449d6-154">The following table shows the interaction of the `isLocalRequest` parameter and the server channel property.</span></span>  
  
|<span data-ttu-id="449d6-155">“值”</span><span class="sxs-lookup"><span data-stu-id="449d6-155">Value</span></span>|<span data-ttu-id="449d6-156">isLocalRequest</span><span class="sxs-lookup"><span data-stu-id="449d6-156">isLocalRequest</span></span>|<span data-ttu-id="449d6-157">返回值</span><span class="sxs-lookup"><span data-stu-id="449d6-157">Return value</span></span>|<span data-ttu-id="449d6-158">说明</span><span class="sxs-lookup"><span data-stu-id="449d6-158">Description</span></span>|  
|-----------|--------------------|------------------|-----------------|  
|`on`|`true`|`true`|<span data-ttu-id="449d6-159">本地调用方接收筛选的异常信息。</span><span class="sxs-lookup"><span data-stu-id="449d6-159">Local callers receive filtered exception information.</span></span>|  
|`on`|`false`|`true`|<span data-ttu-id="449d6-160">远程调用方接收筛选的异常信息。</span><span class="sxs-lookup"><span data-stu-id="449d6-160">Remote callers receive filtered exception information.</span></span>|  
|`off`|`true`|`false`|<span data-ttu-id="449d6-161">本地调用方接收完整的异常信息。</span><span class="sxs-lookup"><span data-stu-id="449d6-161">Local callers receive complete exception information.</span></span>|  
|`off`|`false`|`false`|<span data-ttu-id="449d6-162">远程调用方接收完整的异常信息。</span><span class="sxs-lookup"><span data-stu-id="449d6-162">Remote callers receive complete exception information.</span></span>|  
|`remoteOnly`|`true`|`false`|<span data-ttu-id="449d6-163">本地调用方接收完整的异常信息。</span><span class="sxs-lookup"><span data-stu-id="449d6-163">Local callers receive complete exception information.</span></span>|  
|`remoteOnly`|`false`|`true`|<span data-ttu-id="449d6-164">远程调用方接收筛选的异常信息。</span><span class="sxs-lookup"><span data-stu-id="449d6-164">Remote callers receive filtered exception information.</span></span>|  
  
 <span data-ttu-id="449d6-165">有关使用应用程序配置文件来控制将异常信息返回给调用方的信息，请参阅 `<customErrors>` 元素。</span><span class="sxs-lookup"><span data-stu-id="449d6-165">For information about using application configuration files to control the return of exception information to callers, see the `<customErrors>` element.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomErrorsMode">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.CustomErrorsModes CustomErrorsMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Runtime.Remoting.CustomErrorsModes CustomErrorsMode" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.RemotingConfiguration.CustomErrorsMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CustomErrorsMode As CustomErrorsModes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::CustomErrorsModes CustomErrorsMode { System::Runtime::Remoting::CustomErrorsModes get(); void set(System::Runtime::Remoting::CustomErrorsModes value); };" />
      <MemberSignature Language="F#" Value="member this.CustomErrorsMode : System.Runtime.Remoting.CustomErrorsModes with get, set" Usage="System.Runtime.Remoting.RemotingConfiguration.CustomErrorsMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[set: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.CustomErrorsModes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="449d6-166">获取或设置指示如何处理自定义错误的值。</span><span class="sxs-lookup"><span data-stu-id="449d6-166">Gets or sets value that indicates how custom errors are handled.</span></span></summary>
        <value><span data-ttu-id="449d6-167">一个 <see cref="T:System.Runtime.Remoting.CustomErrorsModes" /> 枚举的成员，指示如何处理自定义错误。</span><span class="sxs-lookup"><span data-stu-id="449d6-167">A member of the <see cref="T:System.Runtime.Remoting.CustomErrorsModes" /> enumeration that indicates how custom errors are handled.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredActivatedClientTypes">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ActivatedClientTypeEntry[] GetRegisteredActivatedClientTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ActivatedClientTypeEntry[] GetRegisteredActivatedClientTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedClientTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRegisteredActivatedClientTypes () As ActivatedClientTypeEntry()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Runtime::Remoting::ActivatedClientTypeEntry ^&gt; ^ GetRegisteredActivatedClientTypes();" />
      <MemberSignature Language="F#" Value="static member GetRegisteredActivatedClientTypes : unit -&gt; System.Runtime.Remoting.ActivatedClientTypeEntry[]" Usage="System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedClientTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ActivatedClientTypeEntry[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="449d6-168">检索对象类型的数组，这些对象类型在客户端上注册为将被远程激活的类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-168">Retrieves an array of object types registered on the client as types that will be activated remotely.</span></span></summary>
        <returns><span data-ttu-id="449d6-169">对象类型的数组，这些对象类型在客户端上注册为将被远程激活的类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-169">An array of object types registered on the client as types that will be activated remotely.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="449d6-170">有关客户端激活的对象的详细说明，请参阅 [客户端激活](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="449d6-170">For a detailed description of client-activated objects, see [Client Activation](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100)).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="449d6-171">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span><span class="sxs-lookup"><span data-stu-id="449d6-171">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span></span></exception>
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Type)" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Type,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredActivatedServiceTypes">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ActivatedServiceTypeEntry[] GetRegisteredActivatedServiceTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ActivatedServiceTypeEntry[] GetRegisteredActivatedServiceTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedServiceTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRegisteredActivatedServiceTypes () As ActivatedServiceTypeEntry()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Runtime::Remoting::ActivatedServiceTypeEntry ^&gt; ^ GetRegisteredActivatedServiceTypes();" />
      <MemberSignature Language="F#" Value="static member GetRegisteredActivatedServiceTypes : unit -&gt; System.Runtime.Remoting.ActivatedServiceTypeEntry[]" Usage="System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedServiceTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ActivatedServiceTypeEntry[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="449d6-172">检索在服务端上注册的对象类型的数组，可以从客户端根据请求激活这些对象类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-172">Retrieves an array of object types registered on the service end that can be activated on request from a client.</span></span></summary>
        <returns><span data-ttu-id="449d6-173">在服务端上注册的对象类型的数组，可以从客户端根据请求激活这些对象类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-173">An array of object types registered on the service end that can be activated on request from a client.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="449d6-174">有关客户端激活的对象的详细说明，请参阅 [客户端激活](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="449d6-174">For a detailed description of client-activated objects, see [Client Activation](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100)).</span></span>  
  
   
  
## Examples  
 [!code-cpp[RemotingConfiguration_GetRegisteredActivatedServer_Client#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/CPP/RemotingConfiguration_GetRegisteredActivatedService_server.cpp#2)]
 [!code-csharp[RemotingConfiguration_GetRegisteredActivatedServer_Client#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/CS/remotingconfiguration_getregisteredactivatedservice_server.cs#2)]
 [!code-vb[RemotingConfiguration_GetRegisteredActivatedServer_Client#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/VB/remotingconfiguration_getregisteredactivatedservice_server.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="449d6-175">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span><span class="sxs-lookup"><span data-stu-id="449d6-175">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span></span></exception>
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Type)" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Type,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredWellKnownClientTypes">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.WellKnownClientTypeEntry[] GetRegisteredWellKnownClientTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.WellKnownClientTypeEntry[] GetRegisteredWellKnownClientTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownClientTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRegisteredWellKnownClientTypes () As WellKnownClientTypeEntry()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Runtime::Remoting::WellKnownClientTypeEntry ^&gt; ^ GetRegisteredWellKnownClientTypes();" />
      <MemberSignature Language="F#" Value="static member GetRegisteredWellKnownClientTypes : unit -&gt; System.Runtime.Remoting.WellKnownClientTypeEntry[]" Usage="System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownClientTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.WellKnownClientTypeEntry[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="449d6-176">检索对象类型的数组，这些对象类型在客户端上注册为已知类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-176">Retrieves an array of object types registered on the client end as well-known types.</span></span></summary>
        <returns><span data-ttu-id="449d6-177">对象类型的数组，这些对象类型在客户端上注册为已知类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-177">An array of object types registered on the client end as well-known types.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="449d6-178">众所周知的对象类型可以是单一调用，也可以是 singleton。</span><span class="sxs-lookup"><span data-stu-id="449d6-178">Well-known object types can be either single call or singleton.</span></span> <span data-ttu-id="449d6-179">如果对象类型是单一调用，则每次传入来自客户端的调用时，都将创建该对象的新实例。</span><span class="sxs-lookup"><span data-stu-id="449d6-179">If an object type is single call, then a new instance of it is created each time a call from the client comes in.</span></span> <span data-ttu-id="449d6-180">对单一实例对象的所有调用都是由该对象的一个实例来处理的。</span><span class="sxs-lookup"><span data-stu-id="449d6-180">All calls to a singleton object are handled by one instance of that object.</span></span>  
  
 <span data-ttu-id="449d6-181">有关众所周知对象的更详细说明，请参阅 [服务器激活](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="449d6-181">For a more detailed description of well-known objects, see [Server Activation](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100)).</span></span>  
  
   
  
## Examples  
 [!code-cpp[RemotingConfiguration_GetRegisteredWellKnownClient_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredWellKnownClient_Client/CPP/remotingconfiguration_getregisteredwellknownclient_client.cpp#1)]
 [!code-csharp[RemotingConfiguration_GetRegisteredWellKnownClient_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredWellKnownClient_Client/CS/remotingconfiguration_getregisteredwellknownclient_client.cs#1)]
 [!code-vb[RemotingConfiguration_GetRegisteredWellKnownClient_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredWellKnownClient_Client/VB/remotingconfiguration_getregisteredwellknownclient_client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="449d6-182">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span><span class="sxs-lookup"><span data-stu-id="449d6-182">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span></span></exception>
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Type,System.String,System.Runtime.Remoting.WellKnownObjectMode)" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Type,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredWellKnownServiceTypes">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.WellKnownServiceTypeEntry[] GetRegisteredWellKnownServiceTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.WellKnownServiceTypeEntry[] GetRegisteredWellKnownServiceTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownServiceTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRegisteredWellKnownServiceTypes () As WellKnownServiceTypeEntry()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Runtime::Remoting::WellKnownServiceTypeEntry ^&gt; ^ GetRegisteredWellKnownServiceTypes();" />
      <MemberSignature Language="F#" Value="static member GetRegisteredWellKnownServiceTypes : unit -&gt; System.Runtime.Remoting.WellKnownServiceTypeEntry[]" Usage="System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownServiceTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.WellKnownServiceTypeEntry[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="449d6-183">检索对象类型的数组，这些对象类型在服务端上注册为已知类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-183">Retrieves an array of object types registered on the service end as well-known types.</span></span></summary>
        <returns><span data-ttu-id="449d6-184">对象类型的数组，这些对象类型在服务端上注册为已知类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-184">An array of object types registered on the service end as well-known types.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="449d6-185">众所周知的对象类型可以是单一调用，也可以是 singleton。</span><span class="sxs-lookup"><span data-stu-id="449d6-185">Well-known object types can be either single call or singleton.</span></span> <span data-ttu-id="449d6-186">如果对象类型是单一调用，则每次传入来自客户端的调用时，都将创建该对象的新实例。</span><span class="sxs-lookup"><span data-stu-id="449d6-186">If an object type is single call, then a new instance of it is created each time a call from the client comes in.</span></span> <span data-ttu-id="449d6-187">对单一实例对象的所有调用都是由该对象的一个实例来处理的。</span><span class="sxs-lookup"><span data-stu-id="449d6-187">All calls to a singleton object are handled by one instance of that object.</span></span>  
  
 <span data-ttu-id="449d6-188">有关众所周知对象的更详细说明，请参阅 [服务器激活](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="449d6-188">For a more detailed description of well-known objects, see [Server Activation](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100)).</span></span>  
  
   
  
## Examples  
 [!code-cpp[RemotingConfiguration_Configure_Client#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/CPP/remotingconfiguration_configure_server.cpp#2)]
 [!code-csharp[RemotingConfiguration_Configure_Client#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/CS/remotingconfiguration_configure_server.cs#2)]
 [!code-vb[RemotingConfiguration_Configure_Client#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/VB/remotingconfiguration_configure_server.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="449d6-189">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span><span class="sxs-lookup"><span data-stu-id="449d6-189">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span></span></exception>
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Type,System.String,System.Runtime.Remoting.WellKnownObjectMode)" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Type,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsActivationAllowed">
      <MemberSignature Language="C#" Value="public static bool IsActivationAllowed (Type svrType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsActivationAllowed(class System.Type svrType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.IsActivationAllowed(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsActivationAllowed (svrType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsActivationAllowed(Type ^ svrType);" />
      <MemberSignature Language="F#" Value="static member IsActivationAllowed : Type -&gt; bool" Usage="System.Runtime.Remoting.RemotingConfiguration.IsActivationAllowed svrType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="svrType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="svrType"><span data-ttu-id="449d6-190">要检查的对象 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="449d6-190">The object <see cref="T:System.Type" /> to check.</span></span></param>
        <summary><span data-ttu-id="449d6-191">返回一个布尔值，该值指示是否允许由客户端激活指定的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="449d6-191">Returns a Boolean value that indicates whether the specified <see cref="T:System.Type" /> is allowed to be client activated.</span></span></summary>
        <returns><span data-ttu-id="449d6-192">如果允许由客户端激活指定的 <see cref="T:System.Type" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="449d6-192"><see langword="true" /> if the specified <see cref="T:System.Type" /> is allowed to be client activated; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="449d6-193">在服务器端使用当前方法来确定 <xref:System.Type> 服务器是否显式允许激活对象。</span><span class="sxs-lookup"><span data-stu-id="449d6-193">The current method is used at the server end to determine whether an activation of the object <xref:System.Type> is explicitly allowed by the server.</span></span>  
  
   
  
## Examples  
 [!code-cpp[RemotingConfiguration_GetRegisteredActivatedServer_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/CPP/RemotingConfiguration_GetRegisteredActivatedService_server.cpp#1)]
 [!code-csharp[RemotingConfiguration_GetRegisteredActivatedServer_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/CS/remotingconfiguration_getregisteredactivatedservice_server.cs#1)]
 [!code-vb[RemotingConfiguration_GetRegisteredActivatedServer_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/VB/remotingconfiguration_getregisteredactivatedservice_server.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="449d6-194">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span><span class="sxs-lookup"><span data-stu-id="449d6-194">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsRemotelyActivatedClientType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="449d6-195">检查指定的对象类型是否注册为远程激活的客户端类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-195">Checks whether the specified object type is registered as a remotely activated client type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsRemotelyActivatedClientType">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType (Type svrType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType(class System.Type svrType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsRemotelyActivatedClientType (svrType As Type) As ActivatedClientTypeEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ActivatedClientTypeEntry ^ IsRemotelyActivatedClientType(Type ^ svrType);" />
      <MemberSignature Language="F#" Value="static member IsRemotelyActivatedClientType : Type -&gt; System.Runtime.Remoting.ActivatedClientTypeEntry" Usage="System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType svrType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ActivatedClientTypeEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="svrType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="svrType"><span data-ttu-id="449d6-196">要检查的对象类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-196">The object type to check.</span></span></param>
        <summary><span data-ttu-id="449d6-197">检查指定的对象 <see cref="T:System.Type" /> 是否注册为远程激活的客户端类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-197">Checks whether the specified object <see cref="T:System.Type" /> is registered as a remotely activated client type.</span></span></summary>
        <returns><span data-ttu-id="449d6-198">与指定的对象类型对应的 <see cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />。</span><span class="sxs-lookup"><span data-stu-id="449d6-198">The <see cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" /> that corresponds to the specified object type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[RemotingConfiguration_IsRemotelyActivatedClientType1_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType1_Client/CPP/remotingconfiguration_isremotelyactivatedclienttype1_client.cpp#1)]
 [!code-csharp[RemotingConfiguration_IsRemotelyActivatedClientType1_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType1_Client/CS/remotingconfiguration_isremotelyactivatedclienttype1_client.cs#1)]
 [!code-vb[RemotingConfiguration_IsRemotelyActivatedClientType1_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType1_Client/VB/remotingconfiguration_isremotelyactivatedclienttype1_client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="449d6-199">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span><span class="sxs-lookup"><span data-stu-id="449d6-199">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100)"><span data-ttu-id="449d6-200">客户端激活</span><span class="sxs-lookup"><span data-stu-id="449d6-200">Client Activation</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsRemotelyActivatedClientType">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType (string typeName, string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType(string typeName, string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsRemotelyActivatedClientType (typeName As String, assemblyName As String) As ActivatedClientTypeEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ActivatedClientTypeEntry ^ IsRemotelyActivatedClientType(System::String ^ typeName, System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="static member IsRemotelyActivatedClientType : string * string -&gt; System.Runtime.Remoting.ActivatedClientTypeEntry" Usage="System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType (typeName, assemblyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ActivatedClientTypeEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="449d6-201">要检查的对象的类型名称。</span><span class="sxs-lookup"><span data-stu-id="449d6-201">The type name of the object to check.</span></span></param>
        <param name="assemblyName"><span data-ttu-id="449d6-202">要检查的对象的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="449d6-202">The assembly name of the object to check.</span></span></param>
        <summary><span data-ttu-id="449d6-203">检查由其类型名称和程序集名称指定的对象是否注册为远程激活的客户端类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-203">Checks whether the object specified by its type name and assembly name is registered as a remotely activated client type.</span></span></summary>
        <returns><span data-ttu-id="449d6-204">与指定的对象类型对应的 <see cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />。</span><span class="sxs-lookup"><span data-stu-id="449d6-204">The <see cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" /> that corresponds to the specified object type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[RemotingConfiguration_IsRemotelyActivatedClientType2_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType2_Client/CPP/remotingconfiguration_isremotelyactivatedclienttype2_client.cpp#1)]
 [!code-csharp[RemotingConfiguration_IsRemotelyActivatedClientType2_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType2_Client/CS/remotingconfiguration_isremotelyactivatedclienttype2_client.cs#1)]
 [!code-vb[RemotingConfiguration_IsRemotelyActivatedClientType2_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType2_Client/VB/remotingconfiguration_isremotelyactivatedclienttype2_client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="449d6-205">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span><span class="sxs-lookup"><span data-stu-id="449d6-205">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100)"><span data-ttu-id="449d6-206">客户端激活</span><span class="sxs-lookup"><span data-stu-id="449d6-206">Client Activation</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsWellKnownClientType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="449d6-207">检查指定的对象类型是否注册为已知客户端类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-207">Checks whether the specified object type is registered as a well-known client type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsWellKnownClientType">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType (Type svrType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType(class System.Type svrType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsWellKnownClientType (svrType As Type) As WellKnownClientTypeEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::WellKnownClientTypeEntry ^ IsWellKnownClientType(Type ^ svrType);" />
      <MemberSignature Language="F#" Value="static member IsWellKnownClientType : Type -&gt; System.Runtime.Remoting.WellKnownClientTypeEntry" Usage="System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType svrType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.WellKnownClientTypeEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="svrType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="svrType"><span data-ttu-id="449d6-208">要检查的对象 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="449d6-208">The object <see cref="T:System.Type" /> to check.</span></span></param>
        <summary><span data-ttu-id="449d6-209">检查指定的对象 <see cref="T:System.Type" /> 是否注册为已知客户端类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-209">Checks whether the specified object <see cref="T:System.Type" /> is registered as a well-known client type.</span></span></summary>
        <returns><span data-ttu-id="449d6-210">与指定的对象类型对应的 <see cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />。</span><span class="sxs-lookup"><span data-stu-id="449d6-210">The <see cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" /> that corresponds to the specified object type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[RemotingConfiguration_IsWellKnownClientType1_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType1_Client/CPP/remotingconfiguration_iswellknownclienttype1_client.cpp#1)]
 [!code-csharp[RemotingConfiguration_IsWellKnownClientType1_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType1_Client/CS/remotingconfiguration_iswellknownclienttype1_client.cs#1)]
 [!code-vb[RemotingConfiguration_IsWellKnownClientType1_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType1_Client/VB/remotingconfiguration_iswellknownclienttype1_client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="449d6-211">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span><span class="sxs-lookup"><span data-stu-id="449d6-211">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100)"><span data-ttu-id="449d6-212">服务器激活</span><span class="sxs-lookup"><span data-stu-id="449d6-212">Server Activation</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsWellKnownClientType">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType (string typeName, string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType(string typeName, string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsWellKnownClientType (typeName As String, assemblyName As String) As WellKnownClientTypeEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::WellKnownClientTypeEntry ^ IsWellKnownClientType(System::String ^ typeName, System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="static member IsWellKnownClientType : string * string -&gt; System.Runtime.Remoting.WellKnownClientTypeEntry" Usage="System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType (typeName, assemblyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.WellKnownClientTypeEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="449d6-213">要检查的对象的类型名称。</span><span class="sxs-lookup"><span data-stu-id="449d6-213">The type name of the object to check.</span></span></param>
        <param name="assemblyName"><span data-ttu-id="449d6-214">要检查的对象的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="449d6-214">The assembly name of the object to check.</span></span></param>
        <summary><span data-ttu-id="449d6-215">检查由其类型名称和程序集名称指定的对象是否注册为已知客户端类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-215">Checks whether the object specified by its type name and assembly name is registered as a well-known client type.</span></span></summary>
        <returns><span data-ttu-id="449d6-216">与指定的对象类型对应的 <see cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />。</span><span class="sxs-lookup"><span data-stu-id="449d6-216">The <see cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" /> that corresponds to the specified object type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[RemotingConfiguration_IsWellKnownClientType2_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType2_Client/CPP/remotingconfiguration_iswellknownclienttype2_client.cpp#1)]
 [!code-csharp[RemotingConfiguration_IsWellKnownClientType2_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType2_Client/CS/remotingconfiguration_iswellknownclienttype2_client.cs#1)]
 [!code-vb[RemotingConfiguration_IsWellKnownClientType2_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType2_Client/VB/remotingconfiguration_iswellknownclienttype2_client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="449d6-217">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span><span class="sxs-lookup"><span data-stu-id="449d6-217">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100)"><span data-ttu-id="449d6-218">服务器激活</span><span class="sxs-lookup"><span data-stu-id="449d6-218">Server Activation</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ProcessId">
      <MemberSignature Language="C#" Value="public static string ProcessId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProcessId" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.RemotingConfiguration.ProcessId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProcessId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProcessId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessId : string" Usage="System.Runtime.Remoting.RemotingConfiguration.ProcessId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="449d6-219">获取当前正在执行的进程的 ID。</span><span class="sxs-lookup"><span data-stu-id="449d6-219">Gets the ID of the currently executing process.</span></span></summary>
        <value><span data-ttu-id="449d6-220">一个 <see cref="T:System.String" />，其中包含当前正在执行的进程的 ID。</span><span class="sxs-lookup"><span data-stu-id="449d6-220">A <see cref="T:System.String" /> that contains the ID of the currently executing process.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="449d6-221">直接调用方没有基础结构权限。</span><span class="sxs-lookup"><span data-stu-id="449d6-221">The immediate caller does not have infrastructure permission.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterActivatedClientType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="449d6-222">将客户端上的对象 <see cref="T:System.Type" /> 注册为可在服务器上激活的类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-222">Registers an object <see cref="T:System.Type" /> on the client end as a type that can be activated on the server.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterActivatedClientType">
      <MemberSignature Language="C#" Value="public static void RegisterActivatedClientType (System.Runtime.Remoting.ActivatedClientTypeEntry entry);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterActivatedClientType(class System.Runtime.Remoting.ActivatedClientTypeEntry entry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Runtime.Remoting.ActivatedClientTypeEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterActivatedClientType (entry As ActivatedClientTypeEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterActivatedClientType(System::Runtime::Remoting::ActivatedClientTypeEntry ^ entry);" />
      <MemberSignature Language="F#" Value="static member RegisterActivatedClientType : System.Runtime.Remoting.ActivatedClientTypeEntry -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType entry" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="System.Runtime.Remoting.ActivatedClientTypeEntry" />
      </Parameters>
      <Docs>
        <param name="entry"><span data-ttu-id="449d6-223">客户端激活类型的配置设置。</span><span class="sxs-lookup"><span data-stu-id="449d6-223">Configuration settings for the client-activated type.</span></span></param>
        <summary><span data-ttu-id="449d6-224">将在客户端提供的 <see cref="T:System.Type" /> 中记录的对象 <see cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" /> 注册为可在服务器上激活的类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-224">Registers an object <see cref="T:System.Type" /> recorded in the provided <see cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" /> on the client end as a type that can be activated on the server.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="449d6-225">若要在服务器上创建客户端激活的对象的实例，必须知道其 <xref:System.Type> ，并且必须使用方法在服务器端上注册它 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> 。</span><span class="sxs-lookup"><span data-stu-id="449d6-225">To create an instance of a client-activated object on the server, you must know its <xref:System.Type> and it must be registered on the server end by using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> method.</span></span> <span data-ttu-id="449d6-226">若要获取客户端激活对象的新实例的代理，客户端必须首先向注册通道， <xref:System.Runtime.Remoting.Channels.ChannelServices> 然后通过调用来激活该对象 `new` 。</span><span class="sxs-lookup"><span data-stu-id="449d6-226">To obtain a proxy for a new instance of the client-activated object, the client must first register a channel with <xref:System.Runtime.Remoting.Channels.ChannelServices> and then activate the object by calling `new`.</span></span>  
  
 <span data-ttu-id="449d6-227">若要使用关键字激活客户端激活的对象类型 `new` ，必须先使用方法在客户端上注册对象类型 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> 。</span><span class="sxs-lookup"><span data-stu-id="449d6-227">To activate a client-activated object type with the `new` keyword, you must first register the object type on the client end using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method.</span></span> <span data-ttu-id="449d6-228">调用 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> 方法可为远程处理基础结构提供尝试创建远程应用程序的位置 `new` 。</span><span class="sxs-lookup"><span data-stu-id="449d6-228">Calling the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method gives the remoting infrastructure the location of the remote application where `new` attempts to create it.</span></span> <span data-ttu-id="449d6-229">另一方面，如果使用 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 方法来创建客户端激活的对象的新实例，则必须提供远程应用程序的 URL 作为参数，因此，在客户端上注册之前不需要。</span><span class="sxs-lookup"><span data-stu-id="449d6-229">If, on the other hand, you use the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method to create a new instance of the client-activated object, you must supply the remote application's URL as a parameter, so no prior registration on the client end is necessary.</span></span> <span data-ttu-id="449d6-230">若要为该 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 方法提供要在其中创建对象的服务器的 url，则必须将该 url 封装在类的实例中 <xref:System.Runtime.Remoting.Activation.UrlAttribute> 。</span><span class="sxs-lookup"><span data-stu-id="449d6-230">To supply the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method with the URL of the server where you want to create the object, you must encapsulate the URL in an instance of the <xref:System.Runtime.Remoting.Activation.UrlAttribute> class.</span></span>  
  
 <span data-ttu-id="449d6-231">有关客户端激活的对象的详细说明，请参阅 [客户端激活](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="449d6-231">For a detailed description of client-activated objects, see [Client Activation](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100)).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="449d6-232">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span><span class="sxs-lookup"><span data-stu-id="449d6-232">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span></span></exception>
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
      </Docs>
    </Member>
    <Member MemberName="RegisterActivatedClientType">
      <MemberSignature Language="C#" Value="public static void RegisterActivatedClientType (Type type, string appUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterActivatedClientType(class System.Type type, string appUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterActivatedClientType (type As Type, appUrl As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterActivatedClientType(Type ^ type, System::String ^ appUrl);" />
      <MemberSignature Language="F#" Value="static member RegisterActivatedClientType : Type * string -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType (type, appUrl)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="appUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="449d6-233">对象 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="449d6-233">The object <see cref="T:System.Type" />.</span></span></param>
        <param name="appUrl"><span data-ttu-id="449d6-234">在该处激活类型的应用程序的 URL。</span><span class="sxs-lookup"><span data-stu-id="449d6-234">URL of the application where this type is activated.</span></span></param>
        <summary><span data-ttu-id="449d6-235">通过使用给定的参数初始化 <see cref="T:System.Type" /> 类的新实例，将客户端上的对象 <see cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" /> 注册为可在服务器上激活的类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-235">Registers an object <see cref="T:System.Type" /> on the client end as a type that can be activated on the server, using the given parameters to initialize a new instance of the <see cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="449d6-236">若要在服务器上创建客户端激活的对象的实例，必须知道其 <xref:System.Type> ，并且必须使用方法在服务器端上注册它 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> 。</span><span class="sxs-lookup"><span data-stu-id="449d6-236">To create an instance of a client-activated object on the server, you must know its <xref:System.Type> and it must be registered on the server end by using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> method.</span></span> <span data-ttu-id="449d6-237">若要获取客户端激活对象的新实例的代理，客户端必须首先向注册通道， <xref:System.Runtime.Remoting.Channels.ChannelServices> 然后通过调用来激活该对象 `new` 。</span><span class="sxs-lookup"><span data-stu-id="449d6-237">To obtain a proxy for a new instance of the client-activated object, the client must first register a channel with <xref:System.Runtime.Remoting.Channels.ChannelServices> and then activate the object by calling `new`.</span></span>  
  
 <span data-ttu-id="449d6-238">若要使用关键字激活客户端激活的对象类型 `new` ，必须先使用方法在客户端上注册对象类型 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> 。</span><span class="sxs-lookup"><span data-stu-id="449d6-238">To activate a client-activated object type with the `new` keyword, you must first register the object type on the client end using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method.</span></span> <span data-ttu-id="449d6-239">调用 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> 方法可为远程处理基础结构提供尝试创建远程应用程序的位置 `new` 。</span><span class="sxs-lookup"><span data-stu-id="449d6-239">Calling the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method gives the remoting infrastructure the location of the remote application where `new` attempts to create it.</span></span> <span data-ttu-id="449d6-240">另一方面，如果使用 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 方法来创建客户端激活的对象的新实例，则必须提供远程应用程序的 URL 作为参数，因此，在客户端上注册之前不需要。</span><span class="sxs-lookup"><span data-stu-id="449d6-240">If, on the other hand, you use the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method to create a new instance of the client-activated object, you must supply the remote application's URL as a parameter, so no prior registration on the client end is necessary.</span></span> <span data-ttu-id="449d6-241">若要为该 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 方法提供要在其中创建对象的服务器的 url，则必须将该 url 封装在类的实例中 <xref:System.Runtime.Remoting.Activation.UrlAttribute> 。</span><span class="sxs-lookup"><span data-stu-id="449d6-241">To supply the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method with the URL of the server where you want to create the object, you must encapsulate the URL in an instance of the <xref:System.Runtime.Remoting.Activation.UrlAttribute> class.</span></span>  
  
 <span data-ttu-id="449d6-242">有关客户端激活的对象的详细说明，请参阅 [客户端激活](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="449d6-242">For a detailed description of client-activated objects, see [Client Activation](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="449d6-243">下面的代码示例演示如何在客户端上将对象类型注册为可在服务器上激活的类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-243">The following code example demonstrates registration of an object type on the client end as a type that can be activated on the server.</span></span> <span data-ttu-id="449d6-244">有关与所提供的客户端代码相对应的服务器代码，请参阅方法的示例 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> 。</span><span class="sxs-lookup"><span data-stu-id="449d6-244">For the server code that corresponds to the presented client code, see the example for the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> method.</span></span>  
  
 [!code-cpp[RemotingConfiguration.ClientActivation#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CPP/client.cpp#1)]
 [!code-csharp[RemotingConfiguration.ClientActivation#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CS/client.cs#1)]
 [!code-vb[RemotingConfiguration.ClientActivation#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/VB/client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="449d6-245"><paramref name="typeName" /> 或 <paramref name="URI" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="449d6-245">The <paramref name="typeName" /> or <paramref name="URI" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="449d6-246">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span><span class="sxs-lookup"><span data-stu-id="449d6-246">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span></span></exception>
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterActivatedServiceType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="449d6-247">将服务端上的对象 <see cref="T:System.Type" /> 注册为可根据请求从客户端激活的类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-247">Registers an object <see cref="T:System.Type" /> on the service end as one that can be activated on request from a client.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterActivatedServiceType">
      <MemberSignature Language="C#" Value="public static void RegisterActivatedServiceType (System.Runtime.Remoting.ActivatedServiceTypeEntry entry);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterActivatedServiceType(class System.Runtime.Remoting.ActivatedServiceTypeEntry entry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Runtime.Remoting.ActivatedServiceTypeEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterActivatedServiceType (entry As ActivatedServiceTypeEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterActivatedServiceType(System::Runtime::Remoting::ActivatedServiceTypeEntry ^ entry);" />
      <MemberSignature Language="F#" Value="static member RegisterActivatedServiceType : System.Runtime.Remoting.ActivatedServiceTypeEntry -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType entry" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="System.Runtime.Remoting.ActivatedServiceTypeEntry" />
      </Parameters>
      <Docs>
        <param name="entry"><span data-ttu-id="449d6-248">客户端激活类型的配置设置。</span><span class="sxs-lookup"><span data-stu-id="449d6-248">Configuration settings for the client-activated type.</span></span></param>
        <summary><span data-ttu-id="449d6-249">将在服务端提供的 <see cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" /> 中记录的对象类型注册为可根据请求从客户端激活的类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-249">Registers an object type recorded in the provided <see cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" /> on the service end as one that can be activated on request from a client.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="449d6-250">若要在服务器上创建客户端激活的对象的实例，必须知道其 <xref:System.Type> ，并且必须使用方法在服务器端上注册它 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> 。</span><span class="sxs-lookup"><span data-stu-id="449d6-250">To create an instance of a client-activated object on the server, you must know its <xref:System.Type> and it must be registered on the server end by using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> method.</span></span> <span data-ttu-id="449d6-251">若要获取客户端激活对象的新实例的代理，客户端必须首先向注册通道， <xref:System.Runtime.Remoting.Channels.ChannelServices> 然后通过调用或激活该对象 `new` <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="449d6-251">To obtain a proxy for a new instance of the client-activated object, the client must first register a channel with <xref:System.Runtime.Remoting.Channels.ChannelServices> and then activate the object by calling `new` or <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="449d6-252">若要使用关键字激活客户端激活的对象类型 `new` ，必须先使用方法在客户端上注册对象类型 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> 。</span><span class="sxs-lookup"><span data-stu-id="449d6-252">To activate a client-activated object type with the `new` keyword, you must first register the object type on the client end using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method.</span></span> <span data-ttu-id="449d6-253">调用 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> 方法将为远程处理基础结构提供远程应用程序的位置， `new` 并尝试创建该应用程序。</span><span class="sxs-lookup"><span data-stu-id="449d6-253">Calling the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method gives the remoting infrastructure the location of the remote application, where `new` attempts to create it.</span></span> <span data-ttu-id="449d6-254">另一方面，如果使用 <xref:System.Activator.CreateInstance%2A> 方法来创建客户端激活的对象的新实例，则必须提供远程应用程序的 URL 作为参数，因此，在客户端上注册之前不需要。</span><span class="sxs-lookup"><span data-stu-id="449d6-254">If, on the other hand, you use the <xref:System.Activator.CreateInstance%2A> method to create a new instance of the client-activated object, you must supply the remote application's URL as a parameter, so no prior registration on the client end is necessary.</span></span> <span data-ttu-id="449d6-255">若要为该 <xref:System.Activator.CreateInstance%2A> 方法提供要在其中创建对象的服务器的 url，则必须将该 url 封装在类的实例中 <xref:System.Runtime.Remoting.Activation.UrlAttribute> 。</span><span class="sxs-lookup"><span data-stu-id="449d6-255">To supply the <xref:System.Activator.CreateInstance%2A> method with the URL of the server where you want to create the object, you must encapsulate the URL in an instance of the <xref:System.Runtime.Remoting.Activation.UrlAttribute> class.</span></span>  
  
 <span data-ttu-id="449d6-256">有关客户端激活的对象的详细说明，请参阅 [客户端激活](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="449d6-256">For a detailed description of client-activated objects, see [Client Activation](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100)).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="449d6-257">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span><span class="sxs-lookup"><span data-stu-id="449d6-257">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span></span></exception>
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
      </Docs>
    </Member>
    <Member MemberName="RegisterActivatedServiceType">
      <MemberSignature Language="C#" Value="public static void RegisterActivatedServiceType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterActivatedServiceType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterActivatedServiceType (type As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterActivatedServiceType(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member RegisterActivatedServiceType : Type -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="449d6-258">要注册的对象的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="449d6-258">The <see cref="T:System.Type" /> of object to register.</span></span></param>
        <summary><span data-ttu-id="449d6-259">将服务端上指定的对象类型注册为可根据请求从客户端激活的类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-259">Registers a specified object type on the service end as a type that can be activated on request from a client.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="449d6-260">若要在服务器上创建客户端激活的对象的实例，必须知道其 <xref:System.Type> ，并且必须使用方法在服务器端上注册它 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> 。</span><span class="sxs-lookup"><span data-stu-id="449d6-260">To create an instance of a client-activated object on the server, you must know its <xref:System.Type> and it must be registered on the server end by using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> method.</span></span> <span data-ttu-id="449d6-261">若要获取客户端激活对象的新实例的代理，客户端必须首先向注册通道， <xref:System.Runtime.Remoting.Channels.ChannelServices> 然后通过调用或激活该对象 `new` <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="449d6-261">To obtain a proxy for a new instance of the client-activated object, the client must first register a channel with <xref:System.Runtime.Remoting.Channels.ChannelServices> and then activate the object by calling `new` or <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="449d6-262">若要使用关键字激活客户端激活的对象类型 `new` ，必须先使用方法在客户端上注册对象类型 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> 。</span><span class="sxs-lookup"><span data-stu-id="449d6-262">To activate a client-activated object type with the `new` keyword, you must first register the object type on the client end using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method.</span></span> <span data-ttu-id="449d6-263">调用 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> 方法将为远程处理基础结构提供远程应用程序的位置， `new` 并尝试创建该应用程序。</span><span class="sxs-lookup"><span data-stu-id="449d6-263">Calling the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method gives the remoting infrastructure the location of the remote application, where `new` attempts to create it.</span></span> <span data-ttu-id="449d6-264">另一方面，如果使用 <xref:System.Activator.CreateInstance%2A> 方法来创建客户端激活的对象的新实例，则必须提供远程应用程序的 URL 作为参数，因此，在客户端上注册之前不需要。</span><span class="sxs-lookup"><span data-stu-id="449d6-264">If, on the other hand, you use the <xref:System.Activator.CreateInstance%2A> method to create a new instance of the client-activated object, you must supply the remote application's URL as a parameter, so no prior registration on the client end is necessary.</span></span> <span data-ttu-id="449d6-265">若要为该 <xref:System.Activator.CreateInstance%2A> 方法提供要在其中创建对象的服务器的 url，则必须将该 url 封装在类的实例中 <xref:System.Runtime.Remoting.Activation.UrlAttribute> 。</span><span class="sxs-lookup"><span data-stu-id="449d6-265">To supply the <xref:System.Activator.CreateInstance%2A> method with the URL of the server where you want to create the object, you must encapsulate the URL in an instance of the <xref:System.Runtime.Remoting.Activation.UrlAttribute> class.</span></span>  
  
 <span data-ttu-id="449d6-266">有关客户端激活的对象的详细说明，请参阅 [客户端激活](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="449d6-266">For a detailed description of client-activated objects, see [Client Activation](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100)).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="449d6-267">下面的代码示例演示如何将服务器上的对象类型注册为可由客户端激活的类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-267">The following code example demonstrates registration of an object type on the server as a type that can be activated by the client.</span></span> <span data-ttu-id="449d6-268">有关对应于所提供的服务器代码的客户端代码，请参阅方法的示例 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> 。</span><span class="sxs-lookup"><span data-stu-id="449d6-268">For the client code that corresponds to the presented server code, see the example for the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method.</span></span>  
  
 [!code-cpp[RemotingConfiguration.ClientActivation#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CPP/server.cpp#2)]
 [!code-csharp[RemotingConfiguration.ClientActivation#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CS/server.cs#2)]
 [!code-vb[RemotingConfiguration.ClientActivation#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/VB/server.vb#2)]  
  
 <span data-ttu-id="449d6-269">下面的代码示例演示了在上面的示例代码中注册的服务对象。</span><span class="sxs-lookup"><span data-stu-id="449d6-269">The following code example shows the service object registered in the sample code above.</span></span>  
  
 [!code-cpp[RemotingConfiguration.ClientActivation#3](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CPP/service.cpp#3)]
 [!code-csharp[RemotingConfiguration.ClientActivation#3](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CS/service.cs#3)]
 [!code-vb[RemotingConfiguration.ClientActivation#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/VB/service.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="449d6-270">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span><span class="sxs-lookup"><span data-stu-id="449d6-270">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span></span></exception>
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWellKnownClientType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="449d6-271">将客户端上的对象 <see cref="T:System.Type" /> 注册为已知类型（“单个调用”(singlecall) 或 singleton）。</span><span class="sxs-lookup"><span data-stu-id="449d6-271">Registers an object <see cref="T:System.Type" /> on the client end as a well-known type (single call or singleton).</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWellKnownClientType">
      <MemberSignature Language="C#" Value="public static void RegisterWellKnownClientType (System.Runtime.Remoting.WellKnownClientTypeEntry entry);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterWellKnownClientType(class System.Runtime.Remoting.WellKnownClientTypeEntry entry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Runtime.Remoting.WellKnownClientTypeEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterWellKnownClientType (entry As WellKnownClientTypeEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterWellKnownClientType(System::Runtime::Remoting::WellKnownClientTypeEntry ^ entry);" />
      <MemberSignature Language="F#" Value="static member RegisterWellKnownClientType : System.Runtime.Remoting.WellKnownClientTypeEntry -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType entry" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="System.Runtime.Remoting.WellKnownClientTypeEntry" />
      </Parameters>
      <Docs>
        <param name="entry"><span data-ttu-id="449d6-272">已知类型的配置设置。</span><span class="sxs-lookup"><span data-stu-id="449d6-272">Configuration settings for the well-known type.</span></span></param>
        <summary><span data-ttu-id="449d6-273">将在客户端提供的 <see cref="T:System.Type" /> 中记录的对象 <see cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" /> 注册为可在服务器上激活的已知类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-273">Registers an object <see cref="T:System.Type" /> recorded in the provided <see cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" /> on the client end as a well-known type that can be activated on the server.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="449d6-274">知道已注册的已知对象的 URI 的任何客户端都可以通过注册它首选的信道来获取该对象的代理 <xref:System.Runtime.Remoting.Channels.ChannelServices> ，并通过调用或激活该对象 `new` <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="449d6-274">Any client that knows the URI of a registered well-known object can obtain a proxy for the object by registering the channel it prefers with <xref:System.Runtime.Remoting.Channels.ChannelServices>, and activating the object by calling `new` or <xref:System.Activator.GetObject%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="449d6-275">若要使用激活已知对象 `new` ，必须先使用方法在客户端上注册众所周知的对象类型 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> 。</span><span class="sxs-lookup"><span data-stu-id="449d6-275">To activate a well-known object with `new`, you must first register the well-known object type on the client using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method.</span></span> <span data-ttu-id="449d6-276">调用 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> 方法为远程处理基础结构提供了远程对象的位置，这允许 `new` 关键字创建该对象。</span><span class="sxs-lookup"><span data-stu-id="449d6-276">Calling the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method gives the remoting infrastructure the location of the remote object, which allows the `new` keyword to create it.</span></span> <span data-ttu-id="449d6-277">另一方面，如果使用 <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> 方法来激活已知对象，则必须将该对象的 URL 作为参数提供，因此不需要在客户端上进行事先注册。</span><span class="sxs-lookup"><span data-stu-id="449d6-277">If, on the other hand, you use the <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> method to activate the well-known object, you must supply it with the object's URL as an argument, so no prior registration on the client end is necessary.</span></span>  
  
 <span data-ttu-id="449d6-278">有关已知对象的详细说明，请参阅 [服务器激活](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="449d6-278">For a detailed description of well-known objects, see [Server Activation](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100)).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="449d6-279">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span><span class="sxs-lookup"><span data-stu-id="449d6-279">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span></span></exception>
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
      </Docs>
    </Member>
    <Member MemberName="RegisterWellKnownClientType">
      <MemberSignature Language="C#" Value="public static void RegisterWellKnownClientType (Type type, string objectUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterWellKnownClientType(class System.Type type, string objectUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterWellKnownClientType (type As Type, objectUrl As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterWellKnownClientType(Type ^ type, System::String ^ objectUrl);" />
      <MemberSignature Language="F#" Value="static member RegisterWellKnownClientType : Type * string -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType (type, objectUrl)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="objectUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="449d6-280">对象 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="449d6-280">The object <see cref="T:System.Type" />.</span></span></param>
        <param name="objectUrl"><span data-ttu-id="449d6-281">已知客户端对象的 URL。</span><span class="sxs-lookup"><span data-stu-id="449d6-281">URL of a well-known client object.</span></span></param>
        <summary><span data-ttu-id="449d6-282">通过使用给定的参数初始化 <see cref="T:System.Type" /> 类的新实例，将客户端上的对象 <see cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" /> 注册为可在服务器上激活的已知类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-282">Registers an object <see cref="T:System.Type" /> on the client end as a well-known type that can be activated on the server, using the given parameters to initialize a new instance of the <see cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="449d6-283">知道已注册的已知对象的 URI 的任何客户端都可以通过注册它首选的信道来获取该对象的代理 <xref:System.Runtime.Remoting.Channels.ChannelServices> ，并通过调用或激活该对象 `new` <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="449d6-283">Any client that knows the URI of a registered well-known object can obtain a proxy for the object by registering the channel it prefers with <xref:System.Runtime.Remoting.Channels.ChannelServices>, and activating the object by calling `new` or <xref:System.Activator.GetObject%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="449d6-284">若要使用激活已知对象 `new` ，必须先使用方法在客户端上注册众所周知的对象类型 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> 。</span><span class="sxs-lookup"><span data-stu-id="449d6-284">To activate a well-known object with `new`, you must first register the well-known object type on the client using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method.</span></span> <span data-ttu-id="449d6-285">调用 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> 方法为远程处理基础结构提供了远程对象的位置，这允许 `new` 关键字创建该对象。</span><span class="sxs-lookup"><span data-stu-id="449d6-285">Calling the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method gives the remoting infrastructure the location of the remote object, which allows the `new` keyword to create it.</span></span> <span data-ttu-id="449d6-286">另一方面，如果使用 <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> 方法来激活已知对象，则必须将该对象的 URL 作为参数提供，因此不需要在客户端上进行事先注册。</span><span class="sxs-lookup"><span data-stu-id="449d6-286">If, on the other hand, you use the <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> method to activate the well-known object, you must supply it with the object's URL as an argument, so no prior registration on the client end is necessary.</span></span>  
  
 <span data-ttu-id="449d6-287">有关已知对象的详细说明，请参阅 [服务器激活](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="449d6-287">For a detailed description of well-known objects, see [Server Activation](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100)).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="449d6-288">下面的代码示例演示如何在客户端上将对象类型注册为已知类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-288">The following code example demonstrates registration of an object type on the client end as a well-known type.</span></span> <span data-ttu-id="449d6-289">有关与所提供的客户端代码相对应的服务器代码，请参阅方法的示例 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType%2A> 。</span><span class="sxs-lookup"><span data-stu-id="449d6-289">For the server code that corresponds to the presented client code, see the example for the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType%2A> method.</span></span>  
  
 [!code-cpp[RemotingConfiguration.ServerActivation1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/client.cpp#5)]
 [!code-csharp[RemotingConfiguration.ServerActivation1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/client.cs#5)]
 [!code-vb[RemotingConfiguration.ServerActivation1#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/client.vb#5)]  
[!code-cpp[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/client.cpp#6)]
[!code-csharp[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/client.cs#6)]
[!code-vb[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/client.vb#6)]  
[!code-cpp[RemotingConfiguration.ServerActivation1#7](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/client.cpp#7)]
[!code-csharp[RemotingConfiguration.ServerActivation1#7](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/client.cs#7)]
[!code-vb[RemotingConfiguration.ServerActivation1#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/client.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="449d6-290">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span><span class="sxs-lookup"><span data-stu-id="449d6-290">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span></span></exception>
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWellKnownServiceType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="449d6-291">将服务端上的对象 <see cref="T:System.Type" /> 注册为已知类型（“单个调用”(singlecall) 或 singleton）。</span><span class="sxs-lookup"><span data-stu-id="449d6-291">Registers an object <see cref="T:System.Type" /> on the service end as a well-known type (single call or singleton).</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWellKnownServiceType">
      <MemberSignature Language="C#" Value="public static void RegisterWellKnownServiceType (System.Runtime.Remoting.WellKnownServiceTypeEntry entry);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterWellKnownServiceType(class System.Runtime.Remoting.WellKnownServiceTypeEntry entry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Runtime.Remoting.WellKnownServiceTypeEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterWellKnownServiceType (entry As WellKnownServiceTypeEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterWellKnownServiceType(System::Runtime::Remoting::WellKnownServiceTypeEntry ^ entry);" />
      <MemberSignature Language="F#" Value="static member RegisterWellKnownServiceType : System.Runtime.Remoting.WellKnownServiceTypeEntry -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType entry" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="System.Runtime.Remoting.WellKnownServiceTypeEntry" />
      </Parameters>
      <Docs>
        <param name="entry"><span data-ttu-id="449d6-292">已知类型的配置设置。</span><span class="sxs-lookup"><span data-stu-id="449d6-292">Configuration settings for the well-known type.</span></span></param>
        <summary><span data-ttu-id="449d6-293">将在服务端提供的 <see cref="T:System.Type" /> 中记录的对象 <see cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" /> 注册为已知类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-293">Registers an object <see cref="T:System.Type" /> recorded in the provided <see cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" /> on the service end as a well-known type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="449d6-294">知道已注册的已知对象的 URI 的任何客户端都可以通过注册它喜欢的通道 <xref:System.Runtime.Remoting.Channels.ChannelServices> ，并通过调用或方法激活该对象来获取该对象的代理 `new` <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="449d6-294">Any client that knows the URI of a registered well-known object can obtain a proxy for the object by registering the channel it prefers with <xref:System.Runtime.Remoting.Channels.ChannelServices>, and activating the object by calling `new` or the <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="449d6-295">若要使用激活已知对象 `new` ，必须先使用方法在客户端上注册众所周知的对象类型 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> 。</span><span class="sxs-lookup"><span data-stu-id="449d6-295">To activate a well-known object with `new`, you must first register the well-known object type on the client using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method.</span></span> <span data-ttu-id="449d6-296">调用 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> 方法为远程处理基础结构提供了远程对象的位置，这允许 `new` 关键字创建该对象。</span><span class="sxs-lookup"><span data-stu-id="449d6-296">Calling the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method gives the remoting infrastructure the location of the remote object, which allows the `new` keyword to create it.</span></span> <span data-ttu-id="449d6-297">另一方面，如果使用 <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> 方法来激活已知对象，则必须将该对象的 URL 作为参数提供，因此不需要在客户端上进行事先注册。</span><span class="sxs-lookup"><span data-stu-id="449d6-297">If, on the other hand, you use the <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> method to activate the well-known object, you must supply it with the object's URL as an argument, so no prior registration on the client end is necessary.</span></span>  
  
 <span data-ttu-id="449d6-298">当调用到达服务器时，.NET Framework 从消息中提取 URI，检查远程处理表以找到与 URI 匹配的对象的引用，然后根据需要实例化对象（如有必要），将方法调用转发给对象。</span><span class="sxs-lookup"><span data-stu-id="449d6-298">When the call arrives at the server, the .NET Framework extracts the URI from the message, examines the remoting tables to locate the reference for the object that matches the URI, and then instantiates the object if necessary, forwarding the method call to the object.</span></span> <span data-ttu-id="449d6-299">如果将对象注册为，则在 <xref:System.Runtime.Remoting.WellKnownObjectMode.SingleCall> 方法调用完成后将其销毁。</span><span class="sxs-lookup"><span data-stu-id="449d6-299">If the object is registered as <xref:System.Runtime.Remoting.WellKnownObjectMode.SingleCall>, it is destroyed after the method call is completed.</span></span> <span data-ttu-id="449d6-300">将为每个调用的方法创建对象的新实例。</span><span class="sxs-lookup"><span data-stu-id="449d6-300">A new instance of the object is created for each method called.</span></span> <span data-ttu-id="449d6-301">和之间唯一的区别在于 <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> `new` 前者允许您指定一个 url 作为参数，后者从配置中获取 url。</span><span class="sxs-lookup"><span data-stu-id="449d6-301">The only difference between <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> and `new` is that the former allows you to specify a URL as a parameter, and the latter obtains the URL from the configuration.</span></span>  
  
 <span data-ttu-id="449d6-302">注册过程不会实例化远程对象本身。</span><span class="sxs-lookup"><span data-stu-id="449d6-302">The remote object itself is not instantiated by the registration process.</span></span> <span data-ttu-id="449d6-303">仅当客户端尝试调用对象上的方法或从客户端激活对象时，才会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="449d6-303">This only happens when a client attempts to call a method on the object or activates the object from the client side.</span></span>  
  
 <span data-ttu-id="449d6-304">有关已知对象的详细说明，请参阅 [服务器激活](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="449d6-304">For a detailed description of well-known objects, see [Server Activation](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100)).</span></span>  
  
   
  
## Examples  
 [!code-cpp[CreateObjRef2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/CreateObjRef2/CPP/example.cpp#2)]
 [!code-csharp[CreateObjRef2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/CreateObjRef2/CS/example.cs#2)]
 [!code-vb[CreateObjRef2#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/CreateObjRef2/VB/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="449d6-305">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span><span class="sxs-lookup"><span data-stu-id="449d6-305">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span></span></exception>
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
      </Docs>
    </Member>
    <Member MemberName="RegisterWellKnownServiceType">
      <MemberSignature Language="C#" Value="public static void RegisterWellKnownServiceType (Type type, string objectUri, System.Runtime.Remoting.WellKnownObjectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterWellKnownServiceType(class System.Type type, string objectUri, valuetype System.Runtime.Remoting.WellKnownObjectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Type,System.String,System.Runtime.Remoting.WellKnownObjectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterWellKnownServiceType (type As Type, objectUri As String, mode As WellKnownObjectMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterWellKnownServiceType(Type ^ type, System::String ^ objectUri, System::Runtime::Remoting::WellKnownObjectMode mode);" />
      <MemberSignature Language="F#" Value="static member RegisterWellKnownServiceType : Type * string * System.Runtime.Remoting.WellKnownObjectMode -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType (type, objectUri, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="objectUri" Type="System.String" />
        <Parameter Name="mode" Type="System.Runtime.Remoting.WellKnownObjectMode" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="449d6-306">对象 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="449d6-306">The object <see cref="T:System.Type" />.</span></span></param>
        <param name="objectUri"><span data-ttu-id="449d6-307">对象 URI。</span><span class="sxs-lookup"><span data-stu-id="449d6-307">The object URI.</span></span></param>
        <param name="mode"><span data-ttu-id="449d6-308">正在被注册的已知对象类型的激活方式。</span><span class="sxs-lookup"><span data-stu-id="449d6-308">The activation mode of the well-known object type being registered.</span></span> <span data-ttu-id="449d6-309">（请参阅<see cref="T:System.Runtime.Remoting.WellKnownObjectMode" />.)</span><span class="sxs-lookup"><span data-stu-id="449d6-309">(See <see cref="T:System.Runtime.Remoting.WellKnownObjectMode" />.)</span></span></param>
        <summary><span data-ttu-id="449d6-310">通过使用给定的参数初始化 <see cref="T:System.Type" /> 的新实例，将服务端上的对象 <see cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" /> 注册为已知类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-310">Registers an object <see cref="T:System.Type" /> on the service end as a well-known type, using the given parameters to initialize a new instance of <see cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="449d6-311">知道已注册的已知对象的 URI 的任何客户端都可以通过注册它喜欢的通道 <xref:System.Runtime.Remoting.Channels.ChannelServices> ，并通过调用或方法激活该对象来获取该对象的代理 `new` <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="449d6-311">Any client that knows the URI of a registered well-known object can obtain a proxy for the object by registering the channel it prefers with <xref:System.Runtime.Remoting.Channels.ChannelServices>, and activating the object by calling `new` or the <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="449d6-312">若要使用激活已知对象 `new` ，必须先使用方法在客户端上注册众所周知的对象类型 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> 。</span><span class="sxs-lookup"><span data-stu-id="449d6-312">To activate a well-known object with `new`, you must first register the well-known object type on the client using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method.</span></span> <span data-ttu-id="449d6-313">调用 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> 方法为远程处理基础结构提供了远程对象的位置，这允许 `new` 关键字创建该对象。</span><span class="sxs-lookup"><span data-stu-id="449d6-313">Calling the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method gives the remoting infrastructure the location of the remote object, which allows the `new` keyword to create it.</span></span> <span data-ttu-id="449d6-314">另一方面，如果使用 <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> 方法来激活已知对象，则必须将该对象的 URL 作为参数提供，因此不需要在客户端上进行事先注册。</span><span class="sxs-lookup"><span data-stu-id="449d6-314">If, on the other hand, you use the <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> method to activate the well-known object, you must supply it with the object's URL as an argument, so no prior registration on the client end is necessary.</span></span>  
  
 <span data-ttu-id="449d6-315">当调用到达服务器时，.NET Framework 从消息中提取 URI，检查远程处理表以找到与 URI 匹配的对象的引用，然后根据需要实例化对象（如有必要），将方法调用转发给对象。</span><span class="sxs-lookup"><span data-stu-id="449d6-315">When the call arrives at the server, the .NET Framework extracts the URI from the message, examines the remoting tables to locate the reference for the object that matches the URI, and then instantiates the object if necessary, forwarding the method call to the object.</span></span> <span data-ttu-id="449d6-316">如果将对象注册为，则在 <xref:System.Runtime.Remoting.WellKnownObjectMode.SingleCall> 方法调用完成后将其销毁。</span><span class="sxs-lookup"><span data-stu-id="449d6-316">If the object is registered as <xref:System.Runtime.Remoting.WellKnownObjectMode.SingleCall>, it is destroyed after the method call is completed.</span></span> <span data-ttu-id="449d6-317">将为每个调用的方法创建对象的新实例。</span><span class="sxs-lookup"><span data-stu-id="449d6-317">A new instance of the object is created for each method called.</span></span> <span data-ttu-id="449d6-318">和之间唯一的区别在于 <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> `new` 前者允许您指定一个 url 作为参数，后者从配置中获取 url。</span><span class="sxs-lookup"><span data-stu-id="449d6-318">The only difference between <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> and `new` is that the former allows you to specify a URL as a parameter, and the latter obtains the URL from the configuration.</span></span>  
  
 <span data-ttu-id="449d6-319">注册过程不会实例化远程对象本身。</span><span class="sxs-lookup"><span data-stu-id="449d6-319">The remote object itself is not instantiated by the registration process.</span></span> <span data-ttu-id="449d6-320">仅当客户端尝试调用对象上的方法或从客户端激活对象时，才会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="449d6-320">This only happens when a client attempts to call a method on the object or activates the object from the client side.</span></span>  
  
 <span data-ttu-id="449d6-321">有关已知对象的详细说明，请参阅 [服务器激活](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="449d6-321">For a detailed description of well-known objects, see [Server Activation](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100)).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="449d6-322">下面的代码示例演示如何在服务器上将对象类型注册为众所周知的对象类型。</span><span class="sxs-lookup"><span data-stu-id="449d6-322">The following code example demonstrates registration of an object type on the server as a well-known object type.</span></span> <span data-ttu-id="449d6-323">有关对应于所提供的服务器代码的客户端代码，请参阅方法的示例 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> 。</span><span class="sxs-lookup"><span data-stu-id="449d6-323">For the client code that corresponds to the presented server code, see the example for the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method.</span></span>  
  
 [!code-cpp[RemotingConfiguration.ServerActivation1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/server.cpp#1)]
 [!code-csharp[RemotingConfiguration.ServerActivation1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/server.cs#1)]
 [!code-vb[RemotingConfiguration.ServerActivation1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/server.vb#1)]  
[!code-cpp[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/server.cpp#2)]
[!code-csharp[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/server.cs#2)]
[!code-vb[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/server.vb#2)]  
[!code-cpp[RemotingConfiguration.ServerActivation1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/server.cpp#3)]
[!code-csharp[RemotingConfiguration.ServerActivation1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/server.cs#3)]
[!code-vb[RemotingConfiguration.ServerActivation1#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/server.vb#3)]  
  
 <span data-ttu-id="449d6-324">下面的代码示例演示了在上面的示例代码中注册的服务对象。</span><span class="sxs-lookup"><span data-stu-id="449d6-324">The following code example shows the service object registered in the sample code above.</span></span>  
  
 [!code-cpp[RemotingConfiguration.ServerActivation1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/service.cpp#4)]
 [!code-csharp[RemotingConfiguration.ServerActivation1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/service.cs#4)]
 [!code-vb[RemotingConfiguration.ServerActivation1#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/service.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="449d6-325">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span><span class="sxs-lookup"><span data-stu-id="449d6-325">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span></span></exception>
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
      </Docs>
    </Member>
  </Members>
</Type>
