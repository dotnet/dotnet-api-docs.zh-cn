<Type Name="Interlocked" FullName="System.Threading.Interlocked">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c92e897f93f670f55bcdd2ff7515c2e35468b3f9" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83945665" /></Metadata><TypeSignature Language="C#" Value="public static class Interlocked" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Interlocked extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Interlocked" />
  <TypeSignature Language="VB.NET" Value="Public Class Interlocked" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class Interlocked abstract sealed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Interlocked = class" />
  <TypeSignature Language="C#" Value="public sealed class Interlocked" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Interlocked extends System.Object" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Interlocked" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class Interlocked sealed" FrameworkAlternate="netframework-1.1" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Threading" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Threading" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0">
      <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="ed147-101">为多个线程共享的变量提供原子操作。</span><span class="sxs-lookup"><span data-stu-id="ed147-101">Provides atomic operations for variables that are shared by multiple threads.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed147-102">此类的方法可帮助防止在以下情况下发生的错误：在以下情况下发生：计划程序在以下情况下切换上下文：当线程正在更新可被其他线程访问的变量时，或当两个线程同时在不同的处理器上执行时。</span><span class="sxs-lookup"><span data-stu-id="ed147-102">The methods of this class help protect against errors that can occur when the scheduler switches contexts while a thread is updating a variable that can be accessed by other threads, or when two threads are executing concurrently on separate processors.</span></span> <span data-ttu-id="ed147-103">此类的成员不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="ed147-103">The members of this class do not throw exceptions.</span></span>  
  
 <span data-ttu-id="ed147-104"><xref:System.Threading.Interlocked.Increment%2A> 和 <xref:System.Threading.Interlocked.Decrement%2A> 方法递增或递减变量，并在单个操作中存储生成的值。</span><span class="sxs-lookup"><span data-stu-id="ed147-104">The <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A> methods increment or decrement a variable and store the resulting value in a single operation.</span></span> <span data-ttu-id="ed147-105">在大多数计算机上，递增变量不是原子操作，需要执行以下步骤：</span><span class="sxs-lookup"><span data-stu-id="ed147-105">On most computers, incrementing a variable is not an atomic operation, requiring the following steps:</span></span>  
  
1.  <span data-ttu-id="ed147-106">将实例变量中的值加载到寄存器中。</span><span class="sxs-lookup"><span data-stu-id="ed147-106">Load a value from an instance variable into a register.</span></span>  
  
2.  <span data-ttu-id="ed147-107">递增或减小值。</span><span class="sxs-lookup"><span data-stu-id="ed147-107">Increment or decrement the value.</span></span>  
  
3.  <span data-ttu-id="ed147-108">将值存储在实例变量中。</span><span class="sxs-lookup"><span data-stu-id="ed147-108">Store the value in the instance variable.</span></span>  
  
 <span data-ttu-id="ed147-109">如果不使用 <xref:System.Threading.Interlocked.Increment%2A> 和 <xref:System.Threading.Interlocked.Decrement%2A>，则在执行前两个步骤后，可以抢占线程。</span><span class="sxs-lookup"><span data-stu-id="ed147-109">If you do not use <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A>, a thread can be preempted after executing the first two steps.</span></span> <span data-ttu-id="ed147-110">然后，另一个线程可以执行所有三个步骤。</span><span class="sxs-lookup"><span data-stu-id="ed147-110">Another thread can then execute all three steps.</span></span> <span data-ttu-id="ed147-111">当第一个线程继续执行时，它将覆盖实例变量中的值，并且由第二个线程执行的增量或减量的影响将丢失。</span><span class="sxs-lookup"><span data-stu-id="ed147-111">When the first thread resumes execution, it overwrites the value in the instance variable, and the effect of the increment or decrement performed by the second thread is lost.</span></span>  

 <span data-ttu-id="ed147-112"><xref:System.Threading.Interlocked.Add%2A> 方法以原子方式将整数值添加到整数变量中，并返回变量的新值。</span><span class="sxs-lookup"><span data-stu-id="ed147-112">The <xref:System.Threading.Interlocked.Add%2A> method atomically adds an integer value to an integer variable and returns the new value of the variable.</span></span>  
  
 <span data-ttu-id="ed147-113"><xref:System.Threading.Interlocked.Exchange%2A> 方法以原子方式交换指定变量的值。</span><span class="sxs-lookup"><span data-stu-id="ed147-113">The <xref:System.Threading.Interlocked.Exchange%2A> method atomically exchanges the values of the specified variables.</span></span> <span data-ttu-id="ed147-114"><xref:System.Threading.Interlocked.CompareExchange%2A> 方法组合了两个操作：比较两个值，并根据比较结果将第三个值存储在一个变量中。</span><span class="sxs-lookup"><span data-stu-id="ed147-114">The <xref:System.Threading.Interlocked.CompareExchange%2A> method combines two operations: comparing two values and storing a third value in one of the variables, based on the outcome of the comparison.</span></span> <span data-ttu-id="ed147-115">比较和交换操作以原子操作的方式执行。</span><span class="sxs-lookup"><span data-stu-id="ed147-115">The compare and exchange operations are performed as an atomic operation.</span></span>  

 <span data-ttu-id="ed147-116">确保对共享变量的任何写入或读取访问都是原子的。</span><span class="sxs-lookup"><span data-stu-id="ed147-116">Ensure that any write or read access to a shared variable is atomic.</span></span> <span data-ttu-id="ed147-117">否则，数据可能已损坏，或者加载的值可能不正确。</span><span class="sxs-lookup"><span data-stu-id="ed147-117">Otherwise, the data might be corrupted or the loaded value might be incorrect.</span></span>    
   
  
## Examples  
 <span data-ttu-id="ed147-118">下面的代码示例演示线程安全资源锁定机制。</span><span class="sxs-lookup"><span data-stu-id="ed147-118">The following code example shows a thread-safe resource locking mechanism.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="ed147-119">此类型是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="ed147-119">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="ed147-120">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="ed147-120">Managed Threading</span></span></related>
    <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="ed147-121">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="ed147-121">Overview of synchronization primitives</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ed147-122">以原子操作的形式，添加两个整数并用两者的和替换第一个整数。</span><span class="sxs-lookup"><span data-stu-id="ed147-122">Adds two integers and replaces the first integer with the sum, as an atomic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static int Add (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Add(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Add(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member Add : int * int -&gt; int" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="ed147-123">一个变量，包含要添加的第一个值。</span><span class="sxs-lookup"><span data-stu-id="ed147-123">A variable containing the first value to be added.</span></span> <span data-ttu-id="ed147-124">两个值的和存储在 <paramref name="location1" /> 中。</span><span class="sxs-lookup"><span data-stu-id="ed147-124">The sum of the two values is stored in <paramref name="location1" />.</span></span></param>
        <param name="value"><span data-ttu-id="ed147-125">要添加到整数中的 <paramref name="location1" /> 位置的值。</span><span class="sxs-lookup"><span data-stu-id="ed147-125">The value to be added to the integer at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="ed147-126">对两个 32 位整数进行求和并用和替换第一个整数，上述操作作为一个原子操作完成。</span><span class="sxs-lookup"><span data-stu-id="ed147-126">Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="ed147-127">存储在 <paramref name="location1" /> 处的新值。</span><span class="sxs-lookup"><span data-stu-id="ed147-127">The new value stored at <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed147-128">此方法通过包装处理溢出条件：如果 `location1` 上的值 <xref:System.Int32.MaxValue?displayProperty=nameWithType> 并且 `value` 为1，则结果为 <xref:System.Int32.MinValue?displayProperty=nameWithType>;如果 `value` 为2，则结果为（<xref:System.Int32.MinValue?displayProperty=nameWithType> + 1）;依此类推。</span><span class="sxs-lookup"><span data-stu-id="ed147-128">This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int32.MaxValue?displayProperty=nameWithType> and `value` is 1, the result is <xref:System.Int32.MinValue?displayProperty=nameWithType>; if `value` is 2, the result is (<xref:System.Int32.MinValue?displayProperty=nameWithType> + 1); and so on.</span></span> <span data-ttu-id="ed147-129">不引发异常。</span><span class="sxs-lookup"><span data-stu-id="ed147-129">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="ed147-130"><paramref name="location1" /> 的地址为空指针。</span><span class="sxs-lookup"><span data-stu-id="ed147-130">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="ed147-131">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="ed147-131">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="ed147-132">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="ed147-132">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static long Add (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Add(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Add(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member Add : int64 * int64 -&gt; int64" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Int64" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="ed147-133">一个变量，包含要添加的第一个值。</span><span class="sxs-lookup"><span data-stu-id="ed147-133">A variable containing the first value to be added.</span></span> <span data-ttu-id="ed147-134">两个值的和存储在 <paramref name="location1" /> 中。</span><span class="sxs-lookup"><span data-stu-id="ed147-134">The sum of the two values is stored in <paramref name="location1" />.</span></span></param>
        <param name="value"><span data-ttu-id="ed147-135">要添加到整数中的 <paramref name="location1" /> 位置的值。</span><span class="sxs-lookup"><span data-stu-id="ed147-135">The value to be added to the integer at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="ed147-136">对两个 64 位整数进行求和并用和替换第一个整数，上述操作作为一个原子操作完成。</span><span class="sxs-lookup"><span data-stu-id="ed147-136">Adds two 64-bit integers and replaces the first integer with the sum, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="ed147-137">存储在 <paramref name="location1" /> 处的新值。</span><span class="sxs-lookup"><span data-stu-id="ed147-137">The new value stored at <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed147-138">此方法通过包装处理溢出条件：如果 `location1` 上的值 <xref:System.Int64.MaxValue?displayProperty=nameWithType> 并且 `value` 为1，则结果为 <xref:System.Int64.MinValue?displayProperty=nameWithType>;如果 `value` 为2，则结果为（<xref:System.Int64.MinValue?displayProperty=nameWithType> + 1）;依此类推。</span><span class="sxs-lookup"><span data-stu-id="ed147-138">This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int64.MaxValue?displayProperty=nameWithType> and `value` is 1, the result is <xref:System.Int64.MinValue?displayProperty=nameWithType>; if `value` is 2, the result is (<xref:System.Int64.MinValue?displayProperty=nameWithType> + 1); and so on.</span></span> <span data-ttu-id="ed147-139">不引发异常。</span><span class="sxs-lookup"><span data-stu-id="ed147-139">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="ed147-140"><paramref name="location1" /> 的地址为空指针。</span><span class="sxs-lookup"><span data-stu-id="ed147-140">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="ed147-141">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="ed147-141">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="ed147-142">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="ed147-142">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static uint Add (ref uint location1, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Add(unsigned int32&amp; location1, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As UInteger, value As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Add(System::UInt32 % location1, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member Add : uint32 * uint32 -&gt; uint32" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.UInt32" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location1">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static ulong Add (ref ulong location1, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Add(unsigned int64&amp; location1, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As ULong, value As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Add(System::UInt64 % location1, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member Add : uint64 * uint64 -&gt; uint64" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.UInt64" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location1">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static int And (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 And(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.And(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int And(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member And : int * int -&gt; int" Usage="System.Threading.Interlocked.And (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location1">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static long And (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 And(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.And(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long And(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member And : int64 * int64 -&gt; int64" Usage="System.Threading.Interlocked.And (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Int64" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location1">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static uint And (ref uint location1, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 And(unsigned int32&amp; location1, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.And(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (ByRef location1 As UInteger, value As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 And(System::UInt32 % location1, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member And : uint32 * uint32 -&gt; uint32" Usage="System.Threading.Interlocked.And (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.UInt32" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location1">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static ulong And (ref ulong location1, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 And(unsigned int64&amp; location1, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.And(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (ByRef location1 As ULong, value As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 And(System::UInt64 % location1, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member And : uint64 * uint64 -&gt; uint64" Usage="System.Threading.Interlocked.And (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.UInt64" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location1">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareExchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ed147-143">比较两个值是否相等，如果相等，则替换第一个值。</span><span class="sxs-lookup"><span data-stu-id="ed147-143">Compares two values for equality and, if they are equal, replaces the first value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static double CompareExchange (ref double location1, double value, double comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 CompareExchange(float64&amp; location1, float64 value, float64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Double, value As Double, comparand As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double CompareExchange(double % location1, double value, double comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : double * double * double -&gt; double" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparand" Type="System.Double" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="ed147-144">其值将与 <paramref name="comparand" /> 进行比较并且可能被替换的目标。</span><span class="sxs-lookup"><span data-stu-id="ed147-144">The destination, whose value is compared with <paramref name="comparand" /> and possibly replaced.</span></span></param>
        <param name="value"><span data-ttu-id="ed147-145">比较结果相等时替换目标值的值。</span><span class="sxs-lookup"><span data-stu-id="ed147-145">The value that replaces the destination value if the comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="ed147-146">与位于 <paramref name="location1" /> 处的值进行比较的值。</span><span class="sxs-lookup"><span data-stu-id="ed147-146">The value that is compared to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="ed147-147">比较两个双精度浮点数是否相等，如果相等，则替换第一个值。</span><span class="sxs-lookup"><span data-stu-id="ed147-147">Compares two double-precision floating point numbers for equality and, if they are equal, replaces the first value.</span></span></summary>
        <returns><span data-ttu-id="ed147-148"><paramref name="location1" /> 中的原始值。</span><span class="sxs-lookup"><span data-stu-id="ed147-148">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed147-149">如果 `comparand` 和 `location1` 中的值相等，则 `value` 存储在 `location1`中。</span><span class="sxs-lookup"><span data-stu-id="ed147-149">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="ed147-150">否则，不会执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="ed147-150">Otherwise, no operation is performed.</span></span> <span data-ttu-id="ed147-151">比较和交换操作以原子操作的方式执行。</span><span class="sxs-lookup"><span data-stu-id="ed147-151">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="ed147-152"><xref:System.Threading.Interlocked.CompareExchange%2A> 的返回值是 `location1`中的原始值，无论交换是否发生。</span><span class="sxs-lookup"><span data-stu-id="ed147-152">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed147-153">下面的代码示例演示了一种线程安全方法，该方法累积 <xref:System.Double> 值的运行总计。</span><span class="sxs-lookup"><span data-stu-id="ed147-153">The following code example demonstrates a thread-safe method that accumulates a running total of <xref:System.Double> values.</span></span> <span data-ttu-id="ed147-154">两个线程使用线程安全方法和普通加法添加一系列 <xref:System.Double> 值，并在线程完成合计时进行比较。</span><span class="sxs-lookup"><span data-stu-id="ed147-154">Two threads add a series of <xref:System.Double> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared.</span></span> <span data-ttu-id="ed147-155">在双处理器计算机上，总计存在很大的差异。</span><span class="sxs-lookup"><span data-stu-id="ed147-155">On a dual-processor computer, there is a significant difference in the totals.</span></span>  
  
 <span data-ttu-id="ed147-156">在线程安全方法中，保存 "运行总计" 的初始值，然后使用 <xref:System.Threading.Interlocked.CompareExchange%2A> 方法与旧总计交换新计算出的总计。</span><span class="sxs-lookup"><span data-stu-id="ed147-156">In the thread-safe method, the initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="ed147-157">如果返回值与运行总计的保存值不相等，则另一个线程将同时更新总计。</span><span class="sxs-lookup"><span data-stu-id="ed147-157">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="ed147-158">在这种情况下，必须重复更新运行总计的尝试。</span><span class="sxs-lookup"><span data-stu-id="ed147-158">In that case, the attempt to update the running total must be repeated.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="ed147-159"><paramref name="location1" /> 的地址为空指针。</span><span class="sxs-lookup"><span data-stu-id="ed147-159">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="ed147-160">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="ed147-160">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="ed147-161">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="ed147-161">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static int CompareExchange (ref int location1, int value, int comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareExchange(int32&amp; location1, int32 value, int32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Integer, value As Integer, comparand As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareExchange(int % location1, int value, int comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : int * int * int -&gt; int" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
        <Parameter Name="comparand" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="ed147-162">其值将与 <paramref name="comparand" /> 进行比较并且可能被替换的目标。</span><span class="sxs-lookup"><span data-stu-id="ed147-162">The destination, whose value is compared with <paramref name="comparand" /> and possibly replaced.</span></span></param>
        <param name="value"><span data-ttu-id="ed147-163">比较结果相等时替换目标值的值。</span><span class="sxs-lookup"><span data-stu-id="ed147-163">The value that replaces the destination value if the comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="ed147-164">与位于 <paramref name="location1" /> 处的值进行比较的值。</span><span class="sxs-lookup"><span data-stu-id="ed147-164">The value that is compared to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="ed147-165">比较两个 32 位有符号整数是否相等，如果相等，则替换第一个值。</span><span class="sxs-lookup"><span data-stu-id="ed147-165">Compares two 32-bit signed integers for equality and, if they are equal, replaces the first value.</span></span></summary>
        <returns><span data-ttu-id="ed147-166"><paramref name="location1" /> 中的原始值。</span><span class="sxs-lookup"><span data-stu-id="ed147-166">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed147-167">如果 `comparand` 和 `location1` 中的值相等，则 `value` 存储在 `location1`中。</span><span class="sxs-lookup"><span data-stu-id="ed147-167">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="ed147-168">否则，不会执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="ed147-168">Otherwise, no operation is performed.</span></span> <span data-ttu-id="ed147-169">比较和交换操作以原子操作的方式执行。</span><span class="sxs-lookup"><span data-stu-id="ed147-169">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="ed147-170"><xref:System.Threading.Interlocked.CompareExchange%2A> 的返回值是 `location1`中的原始值，无论交换是否发生。</span><span class="sxs-lookup"><span data-stu-id="ed147-170">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed147-171">下面的代码示例演示累积运行总计的线程安全方法。</span><span class="sxs-lookup"><span data-stu-id="ed147-171">The following code example demonstrates a thread-safe method that accumulates a running total.</span></span> <span data-ttu-id="ed147-172">保存 "运行总计" 的初始值，然后使用 <xref:System.Threading.Interlocked.CompareExchange%2A> 方法与旧总计交换新计算出的总计。</span><span class="sxs-lookup"><span data-stu-id="ed147-172">The initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="ed147-173">如果返回值与运行总计的保存值不相等，则另一个线程将同时更新总计。</span><span class="sxs-lookup"><span data-stu-id="ed147-173">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="ed147-174">在这种情况下，必须重复更新运行总计的尝试。</span><span class="sxs-lookup"><span data-stu-id="ed147-174">In that case, the attempt to update the running total must be repeated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ed147-175">.NET Framework 的2.0 版中引入的 <xref:System.Threading.Interlocked.Add%2A> 方法提供了一种更方便的方法来累积整数的线程安全的运行总计。</span><span class="sxs-lookup"><span data-stu-id="ed147-175">The <xref:System.Threading.Interlocked.Add%2A> method, introduced in version 2.0 of the .NET Framework, provides a more convenient way to accumulate thread-safe running totals for integers.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CS/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="ed147-176"><paramref name="location1" /> 的地址为空指针。</span><span class="sxs-lookup"><span data-stu-id="ed147-176">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="ed147-177">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="ed147-177">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="ed147-178">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="ed147-178">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static long CompareExchange (ref long location1, long value, long comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 CompareExchange(int64&amp; location1, int64 value, int64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Long, value As Long, comparand As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long CompareExchange(long % location1, long value, long comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : int64 * int64 * int64 -&gt; int64" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Int64" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparand" Type="System.Int64" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="ed147-179">其值将与 <paramref name="comparand" /> 进行比较并且可能被替换的目标。</span><span class="sxs-lookup"><span data-stu-id="ed147-179">The destination, whose value is compared with <paramref name="comparand" /> and possibly replaced.</span></span></param>
        <param name="value"><span data-ttu-id="ed147-180">比较结果相等时替换目标值的值。</span><span class="sxs-lookup"><span data-stu-id="ed147-180">The value that replaces the destination value if the comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="ed147-181">与位于 <paramref name="location1" /> 处的值进行比较的值。</span><span class="sxs-lookup"><span data-stu-id="ed147-181">The value that is compared to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="ed147-182">比较两个 64 位有符号整数是否相等，如果相等，则替换第一个值。</span><span class="sxs-lookup"><span data-stu-id="ed147-182">Compares two 64-bit signed integers for equality and, if they are equal, replaces the first value.</span></span></summary>
        <returns><span data-ttu-id="ed147-183"><paramref name="location1" /> 中的原始值。</span><span class="sxs-lookup"><span data-stu-id="ed147-183">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed147-184">如果 `comparand` 和 `location1` 中的值相等，则 `value` 存储在 `location1`中。</span><span class="sxs-lookup"><span data-stu-id="ed147-184">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="ed147-185">否则，不会执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="ed147-185">Otherwise, no operation is performed.</span></span> <span data-ttu-id="ed147-186">比较和交换操作以原子操作的方式执行。</span><span class="sxs-lookup"><span data-stu-id="ed147-186">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="ed147-187"><xref:System.Threading.Interlocked.CompareExchange%2A> 的返回值是 `location1`中的原始值，无论交换是否发生。</span><span class="sxs-lookup"><span data-stu-id="ed147-187">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="ed147-188"><paramref name="location1" /> 的地址为空指针。</span><span class="sxs-lookup"><span data-stu-id="ed147-188">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="ed147-189">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="ed147-189">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="ed147-190">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="ed147-190">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static IntPtr CompareExchange (ref IntPtr location1, IntPtr value, IntPtr comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CompareExchange(native int&amp; location1, native int value, native int comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As IntPtr, value As IntPtr, comparand As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CompareExchange(IntPtr % location1, IntPtr value, IntPtr comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : nativeint * nativeint * nativeint -&gt; nativeint" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.IntPtr" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparand" Type="System.IntPtr" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="ed147-191">其值与 <paramref name="comparand" /> 的值进行比较并且可能被 <paramref name="value" /> 替换的目标 <see cref="T:System.IntPtr" />。</span><span class="sxs-lookup"><span data-stu-id="ed147-191">The destination <see cref="T:System.IntPtr" />, whose value is compared with the value of <paramref name="comparand" /> and possibly replaced by <paramref name="value" />.</span></span></param>
        <param name="value"><span data-ttu-id="ed147-192">比较结果相等时替换目标值的 <see cref="T:System.IntPtr" />。</span><span class="sxs-lookup"><span data-stu-id="ed147-192">The <see cref="T:System.IntPtr" /> that replaces the destination value if the comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="ed147-193">与位于 <paramref name="location1" /> 处的值进行比较的 <see cref="T:System.IntPtr" />。</span><span class="sxs-lookup"><span data-stu-id="ed147-193">The <see cref="T:System.IntPtr" /> that is compared to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="ed147-194">比较两个平台特定的句柄或指针是否相等，如果相等，则替换第一个。</span><span class="sxs-lookup"><span data-stu-id="ed147-194">Compares two platform-specific handles or pointers for equality and, if they are equal, replaces the first one.</span></span></summary>
        <returns><span data-ttu-id="ed147-195"><paramref name="location1" /> 中的原始值。</span><span class="sxs-lookup"><span data-stu-id="ed147-195">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed147-196">如果 `comparand` 和 `location1` 中的值相等，则 `value` 存储在 `location1`中。</span><span class="sxs-lookup"><span data-stu-id="ed147-196">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="ed147-197">否则，不会执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="ed147-197">Otherwise, no operation is performed.</span></span> <span data-ttu-id="ed147-198">比较和交换操作以原子操作的方式执行。</span><span class="sxs-lookup"><span data-stu-id="ed147-198">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="ed147-199">此方法的返回值是 `location1`中的原始值，无论交换是否发生。</span><span class="sxs-lookup"><span data-stu-id="ed147-199">The return value of this method is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ed147-200"><xref:System.IntPtr> 是平台特定的类型。</span><span class="sxs-lookup"><span data-stu-id="ed147-200"><xref:System.IntPtr> is a platform-specific type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="ed147-201"><paramref name="location1" /> 的地址为空指针。</span><span class="sxs-lookup"><span data-stu-id="ed147-201">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="ed147-202">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="ed147-202">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="ed147-203">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="ed147-203">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static object CompareExchange (ref object location1, object value, object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CompareExchange(object&amp; location1, object value, object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Object, value As Object, comparand As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CompareExchange(System::Object ^ % location1, System::Object ^ value, System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : obj * obj * obj -&gt; obj" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="ed147-204">通过引用与 <paramref name="comparand" /> 进行比较并且可能被替换的目标对象。</span><span class="sxs-lookup"><span data-stu-id="ed147-204">The destination object that is compared by reference with <paramref name="comparand" /> and possibly replaced.</span></span></param>
        <param name="value"><span data-ttu-id="ed147-205">在引用比较结果相等时替换目标对象的对象。</span><span class="sxs-lookup"><span data-stu-id="ed147-205">The object that replaces the destination object if the reference comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="ed147-206">与位于 <paramref name="location1" /> 处的对象通过引用进行比较的对象。</span><span class="sxs-lookup"><span data-stu-id="ed147-206">The object that is compared by reference to the object at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="ed147-207">比较两个对象是否相等，如果相等，则替换第一个对象。</span><span class="sxs-lookup"><span data-stu-id="ed147-207">Compares two objects for reference equality and, if they are equal, replaces the first object.</span></span></summary>
        <returns><span data-ttu-id="ed147-208"><paramref name="location1" /> 中的原始值。</span><span class="sxs-lookup"><span data-stu-id="ed147-208">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
> <span data-ttu-id="ed147-209">从 .NET Framework 2.0 开始，<xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29> 方法重载为引用类型提供类型安全的替代项。</span><span class="sxs-lookup"><span data-stu-id="ed147-209">Beginning with .NET Framework 2.0, the <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29> method overload provides a type-safe alternative for reference types.</span></span> <span data-ttu-id="ed147-210">建议你调用它，而不是此重载。</span><span class="sxs-lookup"><span data-stu-id="ed147-210">We recommend that you call it instead of this overload.</span></span>

<span data-ttu-id="ed147-211">如果 `comparand` 和 `location1` 中的对象按引用相等，则 `value` 存储在 `location1`中。</span><span class="sxs-lookup"><span data-stu-id="ed147-211">If `comparand` and the object in `location1` are equal by reference, then `value` is stored in `location1`.</span></span> <span data-ttu-id="ed147-212">否则，不会执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="ed147-212">Otherwise, no operation is performed.</span></span> <span data-ttu-id="ed147-213">比较和交换操作以原子操作的方式执行。</span><span class="sxs-lookup"><span data-stu-id="ed147-213">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="ed147-214"><xref:System.Threading.Interlocked.CompareExchange%2A> 的返回值是 `location1`中的原始值，无论交换是否发生。</span><span class="sxs-lookup"><span data-stu-id="ed147-214">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  

> [!NOTE]
>  <span data-ttu-id="ed147-215">对对象进行比较以确定引用是否相等，而不是值相等。</span><span class="sxs-lookup"><span data-stu-id="ed147-215">The objects are compared for reference equality rather than value equality.</span></span> <span data-ttu-id="ed147-216">因此，相同值类型的两个装箱实例（例如，整数3）始终不相等，并且不执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="ed147-216">As a result, two boxed instances of the same value type (for example, the integer 3) always appear to be unequal and no operation is performed.</span></span> <span data-ttu-id="ed147-217">不要将此重载用于值类型。</span><span class="sxs-lookup"><span data-stu-id="ed147-217">Do not use this overload with value types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ed147-218"><paramref name="location1" /> 的地址为空指针。</span><span class="sxs-lookup"><span data-stu-id="ed147-218">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="ed147-219">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="ed147-219">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="ed147-220">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="ed147-220">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static float CompareExchange (ref float location1, float value, float comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 CompareExchange(float32&amp; location1, float32 value, float32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Single, value As Single, comparand As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float CompareExchange(float % location1, float value, float comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : single * single * single -&gt; single" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
        <Parameter Name="comparand" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="ed147-221">其值将与 <paramref name="comparand" /> 进行比较并且可能被替换的目标。</span><span class="sxs-lookup"><span data-stu-id="ed147-221">The destination, whose value is compared with <paramref name="comparand" /> and possibly replaced.</span></span></param>
        <param name="value"><span data-ttu-id="ed147-222">比较结果相等时替换目标值的值。</span><span class="sxs-lookup"><span data-stu-id="ed147-222">The value that replaces the destination value if the comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="ed147-223">与位于 <paramref name="location1" /> 处的值进行比较的值。</span><span class="sxs-lookup"><span data-stu-id="ed147-223">The value that is compared to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="ed147-224">比较两个单精度浮点数是否相等，如果相等，则替换第一个值。</span><span class="sxs-lookup"><span data-stu-id="ed147-224">Compares two single-precision floating point numbers for equality and, if they are equal, replaces the first value.</span></span></summary>
        <returns><span data-ttu-id="ed147-225"><paramref name="location1" /> 中的原始值。</span><span class="sxs-lookup"><span data-stu-id="ed147-225">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed147-226">如果 `comparand` 和 `location1` 中的值相等，则 `value` 存储在 `location1`中。</span><span class="sxs-lookup"><span data-stu-id="ed147-226">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="ed147-227">否则，不会执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="ed147-227">Otherwise, no operation is performed.</span></span> <span data-ttu-id="ed147-228">比较和交换操作以原子操作的方式执行。</span><span class="sxs-lookup"><span data-stu-id="ed147-228">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="ed147-229"><xref:System.Threading.Interlocked.CompareExchange%2A> 的返回值是 `location1`中的原始值，无论交换是否发生。</span><span class="sxs-lookup"><span data-stu-id="ed147-229">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed147-230">下面的代码示例演示了一种线程安全方法，该方法累积 <xref:System.Single> 值的运行总计。</span><span class="sxs-lookup"><span data-stu-id="ed147-230">The following code example demonstrates a thread-safe method that accumulates a running total of <xref:System.Single> values.</span></span> <span data-ttu-id="ed147-231">两个线程使用线程安全方法和普通加法添加一系列 <xref:System.Single> 值，并在线程完成合计时进行比较。</span><span class="sxs-lookup"><span data-stu-id="ed147-231">Two threads add a series of <xref:System.Single> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared.</span></span> <span data-ttu-id="ed147-232">在双处理器计算机上，总计存在很大的差异。</span><span class="sxs-lookup"><span data-stu-id="ed147-232">On a dual-processor computer, there is a significant difference in the totals.</span></span>  
  
 <span data-ttu-id="ed147-233">在线程安全方法中，保存 "运行总计" 的初始值，然后使用 <xref:System.Threading.Interlocked.CompareExchange%2A> 方法与旧总计交换新计算出的总计。</span><span class="sxs-lookup"><span data-stu-id="ed147-233">In the thread-safe method, the initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="ed147-234">如果返回值与运行总计的保存值不相等，则另一个线程将同时更新总计。</span><span class="sxs-lookup"><span data-stu-id="ed147-234">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="ed147-235">在这种情况下，必须重复更新运行总计的尝试。</span><span class="sxs-lookup"><span data-stu-id="ed147-235">In that case, the attempt to update the running total must be repeated.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="ed147-236"><paramref name="location1" /> 的地址为空指针。</span><span class="sxs-lookup"><span data-stu-id="ed147-236">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="ed147-237">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="ed147-237">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="ed147-238">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="ed147-238">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static uint CompareExchange (ref uint location1, uint value, uint comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 CompareExchange(unsigned int32&amp; location1, unsigned int32 value, unsigned int32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.UInt32@,System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As UInteger, value As UInteger, comparand As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 CompareExchange(System::UInt32 % location1, System::UInt32 value, System::UInt32 comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : uint32 * uint32 * uint32 -&gt; uint32" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.UInt32" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="comparand" Type="System.UInt32" Index="2" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location1">To be added.</param>
        <param name="value">To be added.</param>
        <param name="comparand">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static ulong CompareExchange (ref ulong location1, ulong value, ulong comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 CompareExchange(unsigned int64&amp; location1, unsigned int64 value, unsigned int64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.UInt64@,System.UInt64,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As ULong, value As ULong, comparand As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 CompareExchange(System::UInt64 % location1, System::UInt64 value, System::UInt64 comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : uint64 * uint64 * uint64 -&gt; uint64" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.UInt64" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="comparand" Type="System.UInt64" Index="2" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location1">To be added.</param>
        <param name="value">To be added.</param>
        <param name="comparand">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CompareExchange&lt;T&gt; (ref T location1, T value, T comparand) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CompareExchange&lt;class T&gt;(!!T&amp; location1, !!T value, !!T comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange(Of T As Class) (ByRef location1 As T, value As T, comparand As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T CompareExchange(T % location1, T value, T comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : 'T * 'T * 'T -&gt; 'T (requires 'T : null)" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparand" Type="T" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="ed147-239">用于 <paramref name="location1" />、<paramref name="value" /> 和 <paramref name="comparand" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="ed147-239">The type to be used for <paramref name="location1" />, <paramref name="value" />, and <paramref name="comparand" />.</span></span> <span data-ttu-id="ed147-240">此类型必须是引用类型。</span><span class="sxs-lookup"><span data-stu-id="ed147-240">This type must be a reference type.</span></span></typeparam>
        <param name="location1"><span data-ttu-id="ed147-241">其值通过引用与 <paramref name="comparand" /> 进行比较并且可能被替换的目标。</span><span class="sxs-lookup"><span data-stu-id="ed147-241">The destination, whose value is compared by reference with <paramref name="comparand" /> and possibly replaced.</span></span> <span data-ttu-id="ed147-242">这是一个引用参数（C# 中为 <see langword="ref" />，Visual Basic 中为 <see langword="ByRef" />）。</span><span class="sxs-lookup"><span data-stu-id="ed147-242">This is a reference parameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</span></span></param>
        <param name="value"><span data-ttu-id="ed147-243">引用比较结果相等时替换目标值的值。</span><span class="sxs-lookup"><span data-stu-id="ed147-243">The value that replaces the destination value if the comparison by reference results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="ed147-244">与位于 <paramref name="location1" /> 处的值通过引用进行比较的值。</span><span class="sxs-lookup"><span data-stu-id="ed147-244">The value that is compared by reference to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="ed147-245">比较指定的引用类型 <paramref name="T" /> 的两个实例是否引用相等，如果相等，则替换第一个。</span><span class="sxs-lookup"><span data-stu-id="ed147-245">Compares two instances of the specified reference type <paramref name="T" /> for reference equality and, if they are equal, replaces the first one.</span></span></summary>
        <returns><span data-ttu-id="ed147-246"><paramref name="location1" /> 中的原始值。</span><span class="sxs-lookup"><span data-stu-id="ed147-246">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed147-247">如果 `comparand` 和 `location1` 中的值都按引用相等，则 `value` 存储在 `location1`中。</span><span class="sxs-lookup"><span data-stu-id="ed147-247">If `comparand` and the value in `location1` are equal by reference, then `value` is stored in `location1`.</span></span> <span data-ttu-id="ed147-248">否则，不会执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="ed147-248">Otherwise, no operation is performed.</span></span> <span data-ttu-id="ed147-249">比较和交换是作为一个原子操作来执行的。</span><span class="sxs-lookup"><span data-stu-id="ed147-249">The comparison and the exchange are performed as an atomic operation.</span></span> <span data-ttu-id="ed147-250">此方法的返回值是 `location1`中的原始值，无论交换是否发生。</span><span class="sxs-lookup"><span data-stu-id="ed147-250">The return value of this method is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
 <span data-ttu-id="ed147-251">此方法仅支持引用类型。</span><span class="sxs-lookup"><span data-stu-id="ed147-251">This method only supports reference types.</span></span> <span data-ttu-id="ed147-252">值类型 <xref:System.Int32>、<xref:System.Int64>、<xref:System.IntPtr>、<xref:System.Single>和 <xref:System.Double>有 <xref:System.Threading.Interlocked.CompareExchange%2A> 方法的重载，但不支持其他值类型。</span><span class="sxs-lookup"><span data-stu-id="ed147-252">There are overloads of the <xref:System.Threading.Interlocked.CompareExchange%2A> method for the value types <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double>, but there is no support for other value types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ed147-253">此方法重载优于 <xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29> 方法重载，因为后者要求后期绑定访问目标对象。</span><span class="sxs-lookup"><span data-stu-id="ed147-253">This method overload is preferable to the <xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29> method overload, because the latter requires the destination object to be accessed late-bound.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="ed147-254"><paramref name="location1" /> 的地址为空指针。</span><span class="sxs-lookup"><span data-stu-id="ed147-254">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Decrement">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ed147-255">以原子操作的形式递减指定变量的值并存储结果。</span><span class="sxs-lookup"><span data-stu-id="ed147-255">Decrements a specified variable and stores the result, as an atomic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static int Decrement (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Decrement(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Decrement(int % location);" />
      <MemberSignature Language="F#" Value="static member Decrement : int -&gt; int" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location"><span data-ttu-id="ed147-256">其值要递减的变量。</span><span class="sxs-lookup"><span data-stu-id="ed147-256">The variable whose value is to be decremented.</span></span></param>
        <summary><span data-ttu-id="ed147-257">以原子操作的形式递减指定变量的值并存储结果。</span><span class="sxs-lookup"><span data-stu-id="ed147-257">Decrements a specified variable and stores the result, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="ed147-258">递减的值。</span><span class="sxs-lookup"><span data-stu-id="ed147-258">The decremented value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed147-259">此方法通过包装处理溢出条件：如果 `location` = <xref:System.Int32.MinValue?displayProperty=nameWithType>，`location`-1 = <xref:System.Int32.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ed147-259">This method handles an overflow condition by wrapping: If `location` = <xref:System.Int32.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ed147-260">不引发异常。</span><span class="sxs-lookup"><span data-stu-id="ed147-260">No exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed147-261">下面的示例确定了使用中值生成1000个随机数字所需的范围为0到1000的随机数。</span><span class="sxs-lookup"><span data-stu-id="ed147-261">The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value.</span></span> <span data-ttu-id="ed147-262">为了跟踪中间值的数目，变量 `midpointCount`设置为等于1000，并且每次随机数生成器返回中点值时减少。</span><span class="sxs-lookup"><span data-stu-id="ed147-262">To keep track of the number of midpoint values, a variable, `midpointCount`, is set equal to 1,000 and decremented each time the random number generator returns a midpoint value.</span></span> <span data-ttu-id="ed147-263">由于有三个线程生成随机数字，因此调用 <xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29> 方法以确保多个线程不会同时更新 `midpointCount`。</span><span class="sxs-lookup"><span data-stu-id="ed147-263">Because three threads generate the random numbers, the <xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29> method is called to ensure that multiple threads don't update `midpointCount` concurrently.</span></span> <span data-ttu-id="ed147-264">请注意，锁还用于保护随机数生成器，并使用 <xref:System.Threading.CountdownEvent> 对象确保 `Main` 方法在三个线程之前不会完成执行。</span><span class="sxs-lookup"><span data-stu-id="ed147-264">Note that a lock is also used to protect the random number generator, and that a <xref:System.Threading.CountdownEvent> object is used to ensure that the `Main` method doesn't finish execution before the three threads.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Decrement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement1.vb#1)]  
  
 <span data-ttu-id="ed147-265">下面的示例与上一个示例类似，不同之处在于它使用 <xref:System.Threading.Tasks.Task> 类而不是线程过程来生成50000随机中点整数。</span><span class="sxs-lookup"><span data-stu-id="ed147-265">The following example is similar to the previous one, except that it uses the <xref:System.Threading.Tasks.Task> class instead of a thread procedure to generate 50,000 random midpoint integers.</span></span> <span data-ttu-id="ed147-266">在此示例中，lambda 表达式替换 `GenerateNumbers` 线程过程，而对 <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> 方法的调用不需要 <xref:System.Threading.CountdownEvent> 对象。</span><span class="sxs-lookup"><span data-stu-id="ed147-266">In this example, a lambda expression replaces the `GenerateNumbers` thread procedure, and the call to the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method eliminates the need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement2.cs#2)]
 [!code-vb[System.Threading.Interlocked.Decrement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ed147-267"><paramref name="location" /> 的地址为空指针。</span><span class="sxs-lookup"><span data-stu-id="ed147-267">The address of <paramref name="location" /> is a null pointer.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="ed147-268">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="ed147-268">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="ed147-269">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="ed147-269">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static long Decrement (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Decrement(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Decrement(long % location);" />
      <MemberSignature Language="F#" Value="static member Decrement : int64 -&gt; int64" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location"><span data-ttu-id="ed147-270">其值要递减的变量。</span><span class="sxs-lookup"><span data-stu-id="ed147-270">The variable whose value is to be decremented.</span></span></param>
        <summary><span data-ttu-id="ed147-271">以原子操作的形式递减指定变量的值并存储结果。</span><span class="sxs-lookup"><span data-stu-id="ed147-271">Decrements the specified variable and stores the result, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="ed147-272">递减的值。</span><span class="sxs-lookup"><span data-stu-id="ed147-272">The decremented value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed147-273">此方法通过包装处理溢出条件：如果 `location` = <xref:System.Int64.MinValue?displayProperty=nameWithType>，`location`-1 = <xref:System.Int64.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ed147-273">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ed147-274">不引发异常。</span><span class="sxs-lookup"><span data-stu-id="ed147-274">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ed147-275"><paramref name="location" /> 的地址为空指针。</span><span class="sxs-lookup"><span data-stu-id="ed147-275">The address of <paramref name="location" /> is a null pointer.</span></span></exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="ed147-276">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="ed147-276">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="ed147-277">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="ed147-277">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static uint Decrement (ref uint location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Decrement(unsigned int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Decrement(System::UInt32 % location);" />
      <MemberSignature Language="F#" Value="static member Decrement : uint32 -&gt; uint32" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static ulong Decrement (ref ulong location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Decrement(unsigned int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Decrement(System::UInt64 % location);" />
      <MemberSignature Language="F#" Value="static member Decrement : uint64 -&gt; uint64" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ed147-278">以原子操作的形式将变量设置为指定的值。</span><span class="sxs-lookup"><span data-stu-id="ed147-278">Sets a variable to a specified value as an atomic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static double Exchange (ref double location1, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Exchange(float64&amp; location1, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Double, value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Exchange(double % location1, double value);" />
      <MemberSignature Language="F#" Value="static member Exchange : double * double -&gt; double" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="ed147-279">要设置为指定值的变量。</span><span class="sxs-lookup"><span data-stu-id="ed147-279">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="ed147-280"><paramref name="location1" /> 参数要设置成的值。</span><span class="sxs-lookup"><span data-stu-id="ed147-280">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="ed147-281">以原子操作的形式，将双精度浮点数设置为指定的值并返回原始值。</span><span class="sxs-lookup"><span data-stu-id="ed147-281">Sets a double-precision floating point number to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="ed147-282"><paramref name="location1" /> 的原始值。</span><span class="sxs-lookup"><span data-stu-id="ed147-282">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="ed147-283"><paramref name="location1" /> 的地址为空指针。</span><span class="sxs-lookup"><span data-stu-id="ed147-283">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="ed147-284">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="ed147-284">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="ed147-285">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="ed147-285">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static int Exchange (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Exchange(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Exchange(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member Exchange : int * int -&gt; int" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="ed147-286">要设置为指定值的变量。</span><span class="sxs-lookup"><span data-stu-id="ed147-286">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="ed147-287"><paramref name="location1" /> 参数要设置成的值。</span><span class="sxs-lookup"><span data-stu-id="ed147-287">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="ed147-288">以原子操作的形式，将 32 位有符号整数设置为指定的值并返回原始值。</span><span class="sxs-lookup"><span data-stu-id="ed147-288">Sets a 32-bit signed integer to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="ed147-289"><paramref name="location1" /> 的原始值。</span><span class="sxs-lookup"><span data-stu-id="ed147-289">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ed147-290">下面的代码示例演示线程安全资源锁定机制。</span><span class="sxs-lookup"><span data-stu-id="ed147-290">The following code example shows a thread-safe resource locking mechanism.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ed147-291"><paramref name="location1" /> 的地址为空指针。</span><span class="sxs-lookup"><span data-stu-id="ed147-291">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="ed147-292">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="ed147-292">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="ed147-293">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="ed147-293">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static long Exchange (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Exchange(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Exchange(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member Exchange : int64 * int64 -&gt; int64" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Int64" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="ed147-294">要设置为指定值的变量。</span><span class="sxs-lookup"><span data-stu-id="ed147-294">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="ed147-295"><paramref name="location1" /> 参数要设置成的值。</span><span class="sxs-lookup"><span data-stu-id="ed147-295">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="ed147-296">以原子操作的形式，将 64 位有符号整数设置为指定的值并返回原始值。</span><span class="sxs-lookup"><span data-stu-id="ed147-296">Sets a 64-bit signed integer to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="ed147-297"><paramref name="location1" /> 的原始值。</span><span class="sxs-lookup"><span data-stu-id="ed147-297">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="ed147-298"><paramref name="location1" /> 的地址为空指针。</span><span class="sxs-lookup"><span data-stu-id="ed147-298">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="ed147-299">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="ed147-299">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="ed147-300">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="ed147-300">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static IntPtr Exchange (ref IntPtr location1, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Exchange(native int&amp; location1, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As IntPtr, value As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Exchange(IntPtr % location1, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member Exchange : nativeint * nativeint -&gt; nativeint" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.IntPtr" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="ed147-301">要设置为指定值的变量。</span><span class="sxs-lookup"><span data-stu-id="ed147-301">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="ed147-302"><paramref name="location1" /> 参数要设置成的值。</span><span class="sxs-lookup"><span data-stu-id="ed147-302">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="ed147-303">以原子操作的形式，将平台特定的句柄或指针设置为指定的值并返回原始值。</span><span class="sxs-lookup"><span data-stu-id="ed147-303">Sets a platform-specific handle or pointer to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="ed147-304"><paramref name="location1" /> 的原始值。</span><span class="sxs-lookup"><span data-stu-id="ed147-304">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="ed147-305"><paramref name="location1" /> 的地址为空指针。</span><span class="sxs-lookup"><span data-stu-id="ed147-305">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="ed147-306">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="ed147-306">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="ed147-307">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="ed147-307">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static object Exchange (ref object location1, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Exchange(object&amp; location1, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Object, value As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Exchange(System::Object ^ % location1, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Exchange : obj * obj -&gt; obj" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="ed147-308">要设置为指定值的变量。</span><span class="sxs-lookup"><span data-stu-id="ed147-308">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="ed147-309"><paramref name="location1" /> 参数要设置成的值。</span><span class="sxs-lookup"><span data-stu-id="ed147-309">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="ed147-310">以原子操作的形式，将对象设置为指定的值并返回对原始对象的引用。</span><span class="sxs-lookup"><span data-stu-id="ed147-310">Sets an object to a specified value and returns a reference to the original object, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="ed147-311"><paramref name="location1" /> 的原始值。</span><span class="sxs-lookup"><span data-stu-id="ed147-311">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
> <span data-ttu-id="ed147-312">从 .NET Framework 2.0 开始，<xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29> 方法重载为引用类型提供类型安全的替代项。</span><span class="sxs-lookup"><span data-stu-id="ed147-312">Beginning with .NET Framework 2.0, the <xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29> method overload provides a type-safe alternative for reference types.</span></span> <span data-ttu-id="ed147-313">建议你调用它，而不是此重载。</span><span class="sxs-lookup"><span data-stu-id="ed147-313">We recommend that you call it instead of this overload.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ed147-314"><paramref name="location1" /> 的地址为空指针。</span><span class="sxs-lookup"><span data-stu-id="ed147-314">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="ed147-315">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="ed147-315">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="ed147-316">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="ed147-316">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static float Exchange (ref float location1, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Exchange(float32&amp; location1, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Single, value As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Exchange(float % location1, float value);" />
      <MemberSignature Language="F#" Value="static member Exchange : single * single -&gt; single" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="ed147-317">要设置为指定值的变量。</span><span class="sxs-lookup"><span data-stu-id="ed147-317">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="ed147-318"><paramref name="location1" /> 参数要设置成的值。</span><span class="sxs-lookup"><span data-stu-id="ed147-318">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="ed147-319">以原子操作的形式，将单精度浮点数设置为指定的值并返回原始值。</span><span class="sxs-lookup"><span data-stu-id="ed147-319">Sets a single-precision floating point number to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="ed147-320"><paramref name="location1" /> 的原始值。</span><span class="sxs-lookup"><span data-stu-id="ed147-320">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="ed147-321"><paramref name="location1" /> 的地址为空指针。</span><span class="sxs-lookup"><span data-stu-id="ed147-321">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="ed147-322">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="ed147-322">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="ed147-323">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="ed147-323">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static uint Exchange (ref uint location1, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Exchange(unsigned int32&amp; location1, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As UInteger, value As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Exchange(System::UInt32 % location1, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member Exchange : uint32 * uint32 -&gt; uint32" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.UInt32" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location1">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static ulong Exchange (ref ulong location1, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Exchange(unsigned int64&amp; location1, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As ULong, value As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Exchange(System::UInt64 % location1, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member Exchange : uint64 * uint64 -&gt; uint64" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.UInt64" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location1">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Exchange&lt;T&gt; (ref T location1, T value) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Exchange&lt;class T&gt;(!!T&amp; location1, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange``1(``0@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange(Of T As Class) (ByRef location1 As T, value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T Exchange(T % location1, T value);" />
      <MemberSignature Language="F#" Value="static member Exchange : 'T * 'T -&gt; 'T (requires 'T : null)" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="ed147-324">要用于 <paramref name="location1" /> 和 <paramref name="value" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="ed147-324">The type to be used for <paramref name="location1" /> and <paramref name="value" />.</span></span> <span data-ttu-id="ed147-325">此类型必须是引用类型。</span><span class="sxs-lookup"><span data-stu-id="ed147-325">This type must be a reference type.</span></span></typeparam>
        <param name="location1"><span data-ttu-id="ed147-326">要设置为指定值的变量。</span><span class="sxs-lookup"><span data-stu-id="ed147-326">The variable to set to the specified value.</span></span> <span data-ttu-id="ed147-327">这是一个引用参数（C# 中为 <see langword="ref" />，Visual Basic 中为 <see langword="ByRef" />）。</span><span class="sxs-lookup"><span data-stu-id="ed147-327">This is a reference parameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</span></span></param>
        <param name="value"><span data-ttu-id="ed147-328"><paramref name="location1" /> 参数要设置成的值。</span><span class="sxs-lookup"><span data-stu-id="ed147-328">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="ed147-329">将指定类型 <paramref name="T" /> 的变量设置为指定值，并将原始值作为原子操作返回。</span><span class="sxs-lookup"><span data-stu-id="ed147-329">Sets a variable of the specified type <paramref name="T" /> to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="ed147-330"><paramref name="location1" /> 的原始值。</span><span class="sxs-lookup"><span data-stu-id="ed147-330">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed147-331">此方法仅支持引用类型。</span><span class="sxs-lookup"><span data-stu-id="ed147-331">This method only supports reference types.</span></span> <span data-ttu-id="ed147-332"><xref:System.Int32>、<xref:System.Int64>、<xref:System.IntPtr>、<xref:System.Single>和 <xref:System.Double> 值类型存在 <xref:System.Threading.Interlocked.Exchange%2A> 方法的重载，但不支持其他值类型。</span><span class="sxs-lookup"><span data-stu-id="ed147-332">There are overloads of the <xref:System.Threading.Interlocked.Exchange%2A> method for the <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double> value types, but there is no support for other value types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ed147-333">此方法重载优于 <xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29> 方法重载，因为后者需要对目标对象进行后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="ed147-333">This method overload is preferable to the <xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29> method overload, because the latter requires late-bound access to the destination object .</span></span>  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="ed147-334"><paramref name="location1" /> 的地址为空指针。</span><span class="sxs-lookup"><span data-stu-id="ed147-334">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Increment">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ed147-335">以原子操作的形式递增指定变量的值并存储结果。</span><span class="sxs-lookup"><span data-stu-id="ed147-335">Increments a specified variable and stores the result, as an atomic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static int Increment (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Increment(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Increment(int % location);" />
      <MemberSignature Language="F#" Value="static member Increment : int -&gt; int" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location"><span data-ttu-id="ed147-336">其值要递增的变量。</span><span class="sxs-lookup"><span data-stu-id="ed147-336">The variable whose value is to be incremented.</span></span></param>
        <summary><span data-ttu-id="ed147-337">以原子操作的形式递增指定变量的值并存储结果。</span><span class="sxs-lookup"><span data-stu-id="ed147-337">Increments a specified variable and stores the result, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="ed147-338">递增的值。</span><span class="sxs-lookup"><span data-stu-id="ed147-338">The incremented value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed147-339">此方法通过包装处理溢出条件：如果 `location` = <xref:System.Int32.MaxValue?displayProperty=nameWithType>，`location` + 1 = <xref:System.Int32.MinValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ed147-339">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int32.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int32.MinValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ed147-340">不引发异常。</span><span class="sxs-lookup"><span data-stu-id="ed147-340">No exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed147-341">下面的示例确定了使用中值生成1000个随机数字所需的范围为0到1000的随机数。</span><span class="sxs-lookup"><span data-stu-id="ed147-341">The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value.</span></span> <span data-ttu-id="ed147-342">若要跟踪中点值的数目，请将变量 `midpointCount`设置为等于0，并在每次随机数字生成器返回10000时递增。</span><span class="sxs-lookup"><span data-stu-id="ed147-342">To keep track of the number of midpoint values, a variable, `midpointCount`, is set equal to 0 and incremented each time the random number generator returns a midpoint value until it reaches 10,000.</span></span> <span data-ttu-id="ed147-343">由于有三个线程生成随机数字，因此调用 <xref:System.Threading.Interlocked.Increment%28System.Int32%40%29> 方法以确保多个线程不会同时更新 `midpointCount`。</span><span class="sxs-lookup"><span data-stu-id="ed147-343">Because three threads generate the random numbers, the <xref:System.Threading.Interlocked.Increment%28System.Int32%40%29> method is called to ensure that multiple threads don't update `midpointCount` concurrently.</span></span> <span data-ttu-id="ed147-344">请注意，锁还用于保护随机数生成器，并使用 <xref:System.Threading.CountdownEvent> 对象确保 `Main` 方法在三个线程之前不会完成执行。</span><span class="sxs-lookup"><span data-stu-id="ed147-344">Note that a lock is also used to protect the random number generator, and that a <xref:System.Threading.CountdownEvent> object is used to ensure that the `Main` method doesn't finish execution before the three threads.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment3.cs#3)]
 [!code-vb[System.Threading.Interlocked.Increment2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment3.vb#3)]  
  
 <span data-ttu-id="ed147-345">下面的示例与上一个示例类似，不同之处在于它使用 <xref:System.Threading.Tasks.Task> 类而不是线程过程来生成50000随机中点整数。</span><span class="sxs-lookup"><span data-stu-id="ed147-345">The following example is similar to the previous one, except that it uses the <xref:System.Threading.Tasks.Task> class instead of a thread procedure to generate 50,000 random midpoint integers.</span></span> <span data-ttu-id="ed147-346">在此示例中，lambda 表达式替换 `GenerateNumbers` 线程过程，而对 <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> 方法的调用不需要 <xref:System.Threading.CountdownEvent> 对象。</span><span class="sxs-lookup"><span data-stu-id="ed147-346">In this example, a lambda expression replaces the `GenerateNumbers` thread procedure, and the call to the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method eliminates the need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment4.cs#4)]
 [!code-vb[System.Threading.Interlocked.Increment2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="ed147-347"><paramref name="location" /> 的地址为空指针。</span><span class="sxs-lookup"><span data-stu-id="ed147-347">The address of <paramref name="location" /> is a null pointer.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="ed147-348">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="ed147-348">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="ed147-349">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="ed147-349">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static long Increment (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Increment(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Increment(long % location);" />
      <MemberSignature Language="F#" Value="static member Increment : int64 -&gt; int64" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location"><span data-ttu-id="ed147-350">其值要递增的变量。</span><span class="sxs-lookup"><span data-stu-id="ed147-350">The variable whose value is to be incremented.</span></span></param>
        <summary><span data-ttu-id="ed147-351">以原子操作的形式递增指定变量的值并存储结果。</span><span class="sxs-lookup"><span data-stu-id="ed147-351">Increments a specified variable and stores the result, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="ed147-352">递增的值。</span><span class="sxs-lookup"><span data-stu-id="ed147-352">The incremented value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed147-353">此方法通过包装处理溢出条件：如果 `location` = <xref:System.Int64.MaxValue?displayProperty=nameWithType>，`location` + 1 = <xref:System.Int64.MinValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ed147-353">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int64.MinValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ed147-354">不引发异常。</span><span class="sxs-lookup"><span data-stu-id="ed147-354">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="ed147-355"><paramref name="location" /> 的地址为空指针。</span><span class="sxs-lookup"><span data-stu-id="ed147-355">The address of <paramref name="location" /> is a null pointer.</span></span></exception>
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="ed147-356">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="ed147-356">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="ed147-357">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="ed147-357">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static uint Increment (ref uint location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Increment(unsigned int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Increment(System::UInt32 % location);" />
      <MemberSignature Language="F#" Value="static member Increment : uint32 -&gt; uint32" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static ulong Increment (ref ulong location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Increment(unsigned int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Increment(System::UInt64 % location);" />
      <MemberSignature Language="F#" Value="static member Increment : uint64 -&gt; uint64" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Interlocked.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ed147-358">按如下方式同步内存存取：执行当前线程的处理器在对指令重新排序时，不能采用先执行 <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> 调用之后的内存存取，再执行 <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> 调用之前的内存存取的方式。</span><span class="sxs-lookup"><span data-stu-id="ed147-358">Synchronizes memory access as follows: The processor that executes the current thread cannot reorder instructions in such a way that memory accesses before the call to <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> execute after memory accesses that follow the call to <see cref="M:System.Threading.Interlocked.MemoryBarrier" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed147-359">此方法已作为便利添加到 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 中的 <xref:System.Threading.Interlocked> 类;它是 <xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType> 方法的包装器。</span><span class="sxs-lookup"><span data-stu-id="ed147-359">This method was added to the <xref:System.Threading.Interlocked> class in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] as a convenience; it's a wrapper for the <xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="ed147-360">仅在具有弱内存排序（例如，使用多个 Intel Itanium 处理器的系统）的多处理器系统上需要 <xref:System.Threading.Interlocked.MemoryBarrier%2A>。</span><span class="sxs-lookup"><span data-stu-id="ed147-360"><xref:System.Threading.Interlocked.MemoryBarrier%2A> is required only on multiprocessor systems that have weak memory ordering (for example, a system that employs multiple Intel Itanium processors).</span></span>  
  
 <span data-ttu-id="ed147-361">大多数情况下， C# `lock` 语句、Visual Basic `SyncLock` 语句或 <xref:System.Threading.Monitor> 类提供更简单的方法来同步数据。</span><span class="sxs-lookup"><span data-stu-id="ed147-361">For most purposes, the C# `lock` statement, the Visual Basic `SyncLock` statement, or the <xref:System.Threading.Monitor> class provide easier ways to synchronize data.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrierProcessWide">
      <MemberSignature Language="C#" Value="public static void MemoryBarrierProcessWide ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrierProcessWide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrierProcessWide" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrierProcessWide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrierProcessWide();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrierProcessWide : unit -&gt; unit" Usage="System.Threading.Interlocked.MemoryBarrierProcessWide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ed147-362">提供覆盖整个过程的内存屏障，确保来自任何 CPU 的读写都不能越过该屏障。</span><span class="sxs-lookup"><span data-stu-id="ed147-362">Provides a process-wide memory barrier that ensures that reads and writes from any CPU cannot move across the barrier.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="ed147-363">`MemoryBarrierProcessWide` 方法与 "normal" <xref:System.Threading.Interlocked.MemoryBarrier%2A> 方法不同，如下所示：</span><span class="sxs-lookup"><span data-stu-id="ed147-363">The `MemoryBarrierProcessWide` method differs from the "normal" <xref:System.Threading.Interlocked.MemoryBarrier%2A> method as follows:</span></span>

- <span data-ttu-id="ed147-364">正常内存关卡确保从当前 CPU 进行的读取和写入无法在关卡间移动。</span><span class="sxs-lookup"><span data-stu-id="ed147-364">The normal memory barrier ensures that the reads and writes from the current CPU can't move across the barrier.</span></span> <span data-ttu-id="ed147-365">整个进程范围内的内存屏障确保了进程中正在使用的任何 CPU 的任何读取或写入操作都无法跨关卡移动。</span><span class="sxs-lookup"><span data-stu-id="ed147-365">The process-wide memory barrier ensures that any read or write from any CPU being used in the process can't move across the barrier.</span></span>

- <span data-ttu-id="ed147-366">如果访问数据的*每个线程都*使用障碍，则正常的内存屏障允许合理的共享访问。</span><span class="sxs-lookup"><span data-stu-id="ed147-366">The normal memory barrier allows reasonable shared access if *every* thread accessing the data uses barriers.</span></span> <span data-ttu-id="ed147-367">进程范围内存关卡强制*其他 cpu*与进程内存同步（例如，刷新写入缓冲区和同步读取缓冲区）。</span><span class="sxs-lookup"><span data-stu-id="ed147-367">The process-wide memory barrier forces *other CPUs* to synchronize with process memory (for example, to flush write buffers and synchronize read buffers).</span></span> <span data-ttu-id="ed147-368">这允许在某些线程上进行非互锁操作，并且仍具有合理的共享访问权限。</span><span class="sxs-lookup"><span data-stu-id="ed147-368">This allows for non-interlocked operations on some threads and still have reasonable shared access.</span></span> 

- <span data-ttu-id="ed147-369">正常内存屏障的开销极少，正常互锁操作可能成本低于100个周期。</span><span class="sxs-lookup"><span data-stu-id="ed147-369">The normal memory barrier imposes very little overhead; normal interlocked operations probably cost fewer than a hundred cycles.</span></span> <span data-ttu-id="ed147-370">整个进程范围的内存屏障非常昂贵。</span><span class="sxs-lookup"><span data-stu-id="ed147-370">The process-wide memory barrier is very expensive.</span></span> <span data-ttu-id="ed147-371">它必须强制执行进程中的每个 CPU，以可能产生成千上万个循环。</span><span class="sxs-lookup"><span data-stu-id="ed147-371">It has to force every CPU in the process do to something, at a probable cost of thousands of cycles.</span></span> 

<span data-ttu-id="ed147-372">`MemoryBarrierProcessWide` 方法还会受到无锁编程的所有微妙之处。</span><span class="sxs-lookup"><span data-stu-id="ed147-372">The `MemoryBarrierProcessWide` method also suffers from all the subtleties of lock-free programming.</span></span> <span data-ttu-id="ed147-373">尽管如此，当你确实需要调用此方法时，这种方法非常有用。</span><span class="sxs-lookup"><span data-stu-id="ed147-373">Nevertheless, this method can be extremely useful when you actually need to call it, which should be rare.</span></span>

<span data-ttu-id="ed147-374">此方法包装对 Windows 上的[FlushProcessWriteBuffers](/windows/win32/api/processthreadsapi/nf-processthreadsapi-flushprocesswritebuffers)的调用，并在 Linux 上[sys_membarrier](https://lore.kernel.org/patchwork/patch/188708/) 。</span><span class="sxs-lookup"><span data-stu-id="ed147-374">This method wraps a call to [FlushProcessWriteBuffers](/windows/win32/api/processthreadsapi/nf-processthreadsapi-flushprocesswritebuffers) on Windows and [sys_membarrier](https://lore.kernel.org/patchwork/patch/188708/) on Linux.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static int Or (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Or(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Or(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Or(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member Or : int * int -&gt; int" Usage="System.Threading.Interlocked.Or (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location1">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static long Or (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Or(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Or(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Or(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member Or : int64 * int64 -&gt; int64" Usage="System.Threading.Interlocked.Or (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Int64" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location1">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static uint Or (ref uint location1, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Or(unsigned int32&amp; location1, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Or(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (ByRef location1 As UInteger, value As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Or(System::UInt32 % location1, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member Or : uint32 * uint32 -&gt; uint32" Usage="System.Threading.Interlocked.Or (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.UInt32" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location1">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static ulong Or (ref ulong location1, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Or(unsigned int64&amp; location1, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Or(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (ByRef location1 As ULong, value As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Or(System::UInt64 % location1, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member Or : uint64 * uint64 -&gt; uint64" Usage="System.Threading.Interlocked.Or (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.UInt64" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location1">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static long Read (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Read(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Read(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Read (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Read(long % location);" />
      <MemberSignature Language="F#" Value="static member Read : int64 -&gt; int64" Usage="System.Threading.Interlocked.Read location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location"><span data-ttu-id="ed147-375">要加载的 64 位值。</span><span class="sxs-lookup"><span data-stu-id="ed147-375">The 64-bit value to be loaded.</span></span></param>
        <summary><span data-ttu-id="ed147-376">返回一个以原子操作形式加载的 64 位值。</span><span class="sxs-lookup"><span data-stu-id="ed147-376">Returns a 64-bit value, loaded as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="ed147-377">加载的值。</span><span class="sxs-lookup"><span data-stu-id="ed147-377">The loaded value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed147-378">64位系统上不需要 <xref:System.Threading.Interlocked.Read%2A> 方法，因为64位读取操作已是原子操作。</span><span class="sxs-lookup"><span data-stu-id="ed147-378">The <xref:System.Threading.Interlocked.Read%2A> method is unnecessary on 64-bit systems, because 64-bit read operations are already atomic.</span></span> <span data-ttu-id="ed147-379">在32位系统上，64位读取操作不是原子操作，除非使用 <xref:System.Threading.Interlocked.Read%2A>执行。</span><span class="sxs-lookup"><span data-stu-id="ed147-379">On 32-bit systems, 64-bit read operations are not atomic unless performed using <xref:System.Threading.Interlocked.Read%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="ed147-380">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="ed147-380">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="ed147-381">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="ed147-381">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static ulong Read (ref ulong location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Read(unsigned int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Read(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Read (ByRef location As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Read(System::UInt64 % location);" />
      <MemberSignature Language="F#" Value="static member Read : uint64 -&gt; uint64" Usage="System.Threading.Interlocked.Read location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SpeculationBarrier">
      <MemberSignature Language="C#" Value="public static void SpeculationBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpeculationBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.SpeculationBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpeculationBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpeculationBarrier();" />
      <MemberSignature Language="F#" Value="static member SpeculationBarrier : unit -&gt; unit" Usage="System.Threading.Interlocked.SpeculationBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ed147-382">定义内存防护，用于阻止超过此点的预测执行，直至完成挂起的读取和写入操作。</span><span class="sxs-lookup"><span data-stu-id="ed147-382">Defines a memory fence that blocks speculative execution past this point until pending reads and writes are complete.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="ed147-383">`SpeculationBarrier` 方法定义内存隔离（x86 和 amd64 处理器上的 `mfence` 指令），该内存块会阻止在此时间点之前的*推理*执行，直到完成挂起的读取和写入操作。</span><span class="sxs-lookup"><span data-stu-id="ed147-383">The `SpeculationBarrier` method defines a memory fence (an `mfence` instruction on x86 and amd64 processors) that blocks *speculative* execution past this point until pending reads and writes are complete.</span></span> 

 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
