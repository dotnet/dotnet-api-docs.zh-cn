<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="52a933d31948b116e7f91a175ecc624f33acabef" /><Meta Name="ms.sourcegitcommit" Value="9a0316374d19cc78674994106d073aa5ef1bd5f3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="11/10/2020" /><Meta Name="ms.locfileid" Value="94481041" /></Metadata><TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Mutex = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Threading" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Threading" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>还可用于进程间同步的同步基元。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当两个或多个线程同时访问共享资源时，系统需要一个同步机制来确保每次只有一个线程使用资源。 <xref:System.Threading.Mutex> 是一个同步基元，该基元仅向一个线程授予对共享资源的独占访问权限。 如果线程获取互斥体，则需要获取该互斥体的第二个线程将挂起，直到第一个线程释放该互斥体。  
  
> [!IMPORTANT]
>  此类型实现 <xref:System.IDisposable> 接口。 在使用完类型后，您应直接或间接释放类型。 若要直接释放类型，请在 `try`/`catch` 块中调用其 <xref:System.IDisposable.Dispose%2A> 方法。 若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。 有关详细信息，请参阅 <xref:System.IDisposable> 接口主题中的“使用实现 IDisposable 的对象”一节。  
  
 您可以使用 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 方法来请求 mutex 的所有权。 调用线程将会阻塞，直到发生以下情况之一：  
  
-   向互斥体发出信号，指示该互斥体不为所有。 发生这种情况时，此 <xref:System.Threading.WaitHandle.WaitOne%2A> 方法将返回 `true` ，并且调用线程将假定该互斥体的所有权，并访问该 mutex 保护的资源。 完成访问资源后，线程必须调用 <xref:System.Threading.Mutex.ReleaseMutex%2A> 方法以释放互斥体的所有权。 "示例" 部分中的第一个示例说明了此模式。  
  
-   在对具有或参数的方法的调用中指定的超时间隔 <xref:System.Threading.WaitHandle.WaitOne%2A> `millisecondsTimeout` `timeout` 已过。 发生这种情况时， <xref:System.Threading.WaitHandle.WaitOne%2A> 方法返回 `false` ，调用线程不会进一步尝试获取互斥体的所有权。 在这种情况下，您应该构建代码的结构，以便对调用线程拒绝对由 mutex 保护的资源的访问。 由于线程从未获取互斥体的所有权，因此不能调用 <xref:System.Threading.Mutex.ReleaseMutex%2A> 方法。 "示例" 部分中的第二个示例演示了此模式。  
  
 <xref:System.Threading.Mutex>类强制执行线程标识，因此互斥体只能由获取它的线程释放。 与此相反， <xref:System.Threading.Semaphore> 类不强制执行线程标识。 还可以跨应用程序域边界传递互斥体。  
  
 拥有 mutex 的线程可以在重复调用中请求同一互斥体， <xref:System.Threading.WaitHandle.WaitOne%2A> 而不会阻止其执行。 但是，线程必须调用 <xref:System.Threading.Mutex.ReleaseMutex%2A> 方法相同的次数来释放 mutex 的所有权。  
  
 由于 <xref:System.Threading.Mutex> 该类继承自 <xref:System.Threading.WaitHandle> ，因此还可以调用静态 <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> 方法和方法来同步对受保护资源的访问。  
  
 如果线程在拥有互斥体时终止，则会被视为放弃互斥体。 Mutex 的状态设置为 "已终止"，下一个等待线程将获得所有权。 从 .NET Framework 的2.0 版开始，将 <xref:System.Threading.AbandonedMutexException> 在下一个获取被放弃的互斥体的线程中引发。 在 .NET Framework 版本2.0 之前，不引发异常。  
  
> [!CAUTION]
>  被放弃的 mutex 通常表明代码中存在严重错误。 当线程在不释放 mutex 的情况下退出时，由 mutex 保护的数据结构可能不是一致的状态。 如果可以验证数据结构的完整性，下一个请求 mutex 所有权的线程就可以处理此异常并继续操作。  
  
 对于系统范围的 mutex，放弃的 mutex 可能指示应用程序已突然终止（例如，通过使用 Windows 任务管理器终止）。  
  
 Mutex 分为两种类型：本地互斥体，即未命名和命名的系统互斥体。 本地 mutex 仅存在于进程中。 您的进程中的任何线程都可以使用它来引用 <xref:System.Threading.Mutex> 表示 mutex 的对象。 每个未命名 <xref:System.Threading.Mutex> 对象都表示一个单独的本地 mutex。  
  
 命名系统 mutex 在整个操作系统中均可见，可用于同步进程的活动。 您可以 <xref:System.Threading.Mutex> 使用接受名称的构造函数创建表示已命名系统 mutex 的对象。 可以同时创建操作系统对象，也可以在创建对象之前存在该对象 <xref:System.Threading.Mutex> 。 可以创建多个表示同一命名系统 mutex 的 <xref:System.Threading.Mutex> 对象，还能使用 <xref:System.Threading.Mutex.OpenExisting%2A> 方法打开现有的命名系统 mutex。  
  
> [!NOTE]
>  在运行终端服务的服务器上，命名系统 mutex 可以有两个级别的可见性。 如果其名称以前缀 "Global" 开头 \\ ，则 mutex 在所有终端服务器会话中可见。 如果其名称以前缀 "Local" 开头 \\ ，则 mutex 仅在创建它的终端服务器会话中可见。 在这种情况下，可以在服务器上的其他每个终端服务器会话中存在具有相同名称的单独 mutex。 如果在创建已命名的 mutex 时未指定前缀，则采用前缀 "Local \\ "。 在终端服务器会话中，两个互斥体的名称只是它们的前缀不同，它们都是对终端服务器会话中的所有进程都可见。 也就是说，前缀名称 "Global \\ " 和 "Local \\ " 描述互斥体名称相对于终端服务器会话的作用域，而不是相对于进程。  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 此示例演示如何使用本地 <xref:System.Threading.Mutex> 对象同步对受保护资源的访问。 由于每个调用线程都将被阻止，直到它获取互斥体的所有权，因此它必须调用 <xref:System.Threading.Mutex.ReleaseMutex%2A> 方法以释放互斥体的所有权。  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 在下面的示例中，每个线程都调用 <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> 方法来获取互斥体。 如果超时间隔已过，则该方法将返回 `false` ，并且该线程既不会获取互斥体，也不会获得对互斥体保护的资源的访问权限。 <xref:System.Threading.Mutex.ReleaseMutex%2A>方法只由获取互斥体的线程调用。  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此类型是线程安全的。</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="/dotnet/standard/threading/">托管线程处理</related>
    <related type="Article" href="/dotnet/standard/threading/mutexes">Mutexes</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Threading.Mutex" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>使用默认属性初始化 <see cref="T:System.Threading.Mutex" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此构造函数重载与调用 <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> 构造函数重载和指定 `false` 互斥体的初始所有权的方式相同。 也就是说，调用线程不拥有互斥体。  
  
   
  
## Examples  
 下面的代码示例演示如何使用本地 <xref:System.Threading.Mutex> 对象来同步对受保护资源的访问。 创建互斥体的线程最初不负责。  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/threading/">托管线程处理</related>
        <related type="Article" href="/dotnet/standard/threading/mutexes">Mutexes</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex initiallyOwned" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">如果给调用线程赋予互斥体的初始所属权，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>使用 Boolean 值（指示调用线程是否应具有互斥体的初始所有权）初始化 <see cref="T:System.Threading.Mutex" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示如何使用本地 <xref:System.Threading.Mutex> 对象来同步对受保护资源的访问。 最初创建它的线程 <xref:System.Threading.Mutex> 。  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/threading/">托管线程处理</related>
        <related type="Article" href="/dotnet/standard/threading/mutexes">Mutexes</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">如果为 <see langword="true" />，则给予调用线程已命名的系统互斥体的初始所属权（如果已命名的系统互斥体是通过此调用创建的）；否则为 <see langword="false" />。</param>
        <param name="name">如果要与其他进程共享同步对象，则为名称；否则为 <see langword="null" /> 或空字符串。 该名称区分大小写。</param>
        <summary>使用 Boolean 值（指示调用线程是否应具有互斥体的初始所有权以及字符串是否为互斥体的名称）初始化 <see cref="T:System.Threading.Mutex" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `name`可以使用 `Global\` 或前缀 `Local\` 来指定命名空间。 如果 `Global` 指定了命名空间，则同步对象可能与系统上的任何进程共享。 `Local`指定命名空间后，如果未指定命名空间，这也是默认命名空间，则同步对象可能与同一会话中的进程共享。 在 Windows 上，会话是一个登录会话，服务通常在不同的非交互式会话中运行。 在类似 Unix 的操作系统上，每个 shell 都有自己的会话。 会话本地同步对象可能适用于具有父/子关系的进程之间的同步，它们全都在同一会话中运行。 有关 Windows 上的 synchornization 对象名称的详细信息，请参阅 [对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。

 如果提供了， `name` 并且命名空间中已存在请求类型的同步对象，则使用现有的同步对象。 如果命名空间中已存在另一个类型的同步对象， `WaitHandleCannotBeOpenedException` 则会引发。 否则，将创建一个新的同步对象。

 如果不 `name` 为 `null` `initiallyOwned` ，并且为，则 `true` 只有当命名系统 mutex 作为此调用的结果而创建时，调用线程才拥有互斥体。 由于没有用于确定是否已创建命名系统 mutex 的机制，因此最好指定 `false` `initiallyOwned` 何时调用此构造函数重载。 <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29>如果需要确定初始所有权，可以使用构造函数。  
  
 此构造函数初始化 <xref:System.Threading.Mutex> 对象，该对象表示已命名的系统互斥体。 可以创建多个 <xref:System.Threading.Mutex> 表示同一命名系统 mutex 的对象。  
  
 如果已使用访问控制安全性创建了已命名的 mutex 并且调用方没有 <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> ，则会引发异常。 若要使用只同步线程活动所需的权限打开现有的已命名 mutex，请参见 <xref:System.Threading.Mutex.OpenExisting%2A> 方法。  
  
 如果为指定 `null` 或空字符串，则将 `name` 创建本地 mutex，就像您已调用 <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> 构造函数一样。 在此示例中， `createdNew` 始终为 `true` 。  
  
 由于它们是系统范围的，因此可以使用命名的 mutex 跨进程边界协调资源使用。  
  
> [!NOTE]
>  在运行终端服务的服务器上，命名系统 mutex 可以有两个级别的可见性。 如果其名称以前缀 "Global" 开头 \\ ，则 mutex 在所有终端服务器会话中可见。 如果其名称以前缀 "Local" 开头 \\ ，则 mutex 仅在创建它的终端服务器会话中可见。 在这种情况下，可以在服务器上的其他每个终端服务器会话中存在具有相同名称的单独 mutex。 如果在创建已命名的 mutex 时未指定前缀，则采用前缀 "Local \\ "。 在终端服务器会话中，两个互斥体的名称只是它们的前缀不同，它们都是对终端服务器会话中的所有进程都可见。 也就是说，前缀名称 "Global \\ " 和 "Local \\ " 描述互斥体名称相对于终端服务器会话的作用域，而不是相对于进程。  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 下面的示例演示如何使用命名 mutex 在两个不同的进程中运行的线程之间发出信号。  
  
 从两个或更多命令窗口中运行该程序。 每个进程创建一个 <xref:System.Threading.Mutex> 对象，该对象表示已命名的互斥体 `MyMutex` 。 命名的 mutex 是一个系统对象，其生存期由表示它的对象的生存期界定 <xref:System.Threading.Mutex> 。 已命名的互斥体是在第一个进程创建其对象时创建的 <xref:System.Threading.Mutex> ; 在此示例中，已命名的互斥体由运行该程序的第一个进程拥有。 如果 <xref:System.Threading.Mutex> 已释放所有表示它的对象，则会销毁该命名互斥体。  
  
 在此示例中使用的构造函数重载不能告知调用线程是否已授予命名 mutex 的初始所有权。 不应使用此构造函数来请求初始所有权，除非可以确定该线程将创建已命名的互斥体。  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">命名互斥体存在且具有访问控制安全性，但用户不具备 <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />。</exception>
        <exception cref="T:System.IO.IOException"><paramref name="name" /> 无效。 导致这种情况的原因有很多，包括操作系统可能会施加的一些限制，例如未知前缀或无效字符。 请注意，名称和常见前缀 "Global\" 和 "Local\" 区分大小写。

或

存在其他错误。 `HResult` 属性可能提供更多信息。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">仅限 Windows：<paramref name="name" /> 指定了未知命名空间。 有关详细信息，请参阅[对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="name" /> 太长。 长度限制可能取决于操作系统或配置。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">无法创建具有提供的 <paramref name="name" /> 的同步对象。 不同类型的同步对象可能具有相同的名称。</exception>
        <exception cref="T:System.ArgumentException">仅限 .NET Framework：<paramref name="name" /> 的长度超过 MAX_PATH（260 个字符）。</exception>
        <related type="Article" href="/dotnet/standard/threading/">托管线程处理</related>
        <related type="Article" href="/dotnet/standard/threading/mutexes">Mutexes</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string * bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">如果为 <see langword="true" />，则给予调用线程已命名的系统互斥体的初始所属权（如果已命名的系统互斥体是通过此调用创建的）；否则为 <see langword="false" />。</param>
        <param name="name">如果要与其他进程共享同步对象，则为名称；否则为 <see langword="null" /> 或空字符串。 该名称区分大小写。</param>
        <param name="createdNew">在此方法返回时，如果创建了局部互斥体（即，如果 <paramref name="name" /> 为 <see langword="null" /> 或空字符串）或指定的命名系统互斥体，则包含布尔值 <see langword="true" />；如果指定的命名系统互斥体已存在，则为 <see langword="false" />。 此参数未经初始化即被传递。</param>
        <summary>使用可指示调用线程是否应具有互斥体的初始所有权以及字符串是否为互斥体的名称的 Boolean 值和当线程返回时可指示调用线程是否已赋予互斥体的初始所有权的 Boolean 值初始化 <see cref="T:System.Threading.Mutex" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `name`可以使用 `Global\` 或前缀 `Local\` 来指定命名空间。 如果 `Global` 指定了命名空间，则同步对象可能与系统上的任何进程共享。 `Local`指定命名空间后，如果未指定命名空间，这也是默认命名空间，则同步对象可能与同一会话中的进程共享。 在 Windows 上，会话是一个登录会话，服务通常在不同的非交互式会话中运行。 在类似 Unix 的操作系统上，每个 shell 都有自己的会话。 会话本地同步对象可能适用于具有父/子关系的进程之间的同步，它们全都在同一会话中运行。 有关 Windows 上的 synchornization 对象名称的详细信息，请参阅 [对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。

 如果提供了， `name` 并且命名空间中已存在请求类型的同步对象，则使用现有的同步对象。 如果命名空间中已存在另一个类型的同步对象， `WaitHandleCannotBeOpenedException` 则会引发。 否则，将创建一个新的同步对象。

 如果不 `name` 为， `null` 并且 `initiallyOwned` 为，则只有在 `true` `createdNew` `true` 调用之后，调用线程才拥有已命名的互斥体。 否则，线程可以通过调用方法来请求互斥体 <xref:System.Threading.WaitHandle.WaitOne%2A> 。  
  
 此构造函数初始化 <xref:System.Threading.Mutex> 对象，该对象表示已命名的系统互斥体。 可以创建多个 <xref:System.Threading.Mutex> 表示同一命名系统 mutex 的对象。  
  
 如果已使用访问控制安全性创建了已命名的 mutex，并且调用方没有 <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> 权限，则会引发异常。 若要使用只同步线程活动所需的权限打开现有的已命名 mutex，请参见 <xref:System.Threading.Mutex.OpenExisting%2A> 方法。  
  
 如果为指定 `null` 或空字符串，则将 `name` 创建本地 mutex，就像您已调用 <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> 构造函数一样。 在此示例中， `createdNew` 始终为 `true` 。  
  
 由于它们是系统范围的，因此可以使用命名的 mutex 跨进程边界协调资源使用。  
  
> [!NOTE]
>  在运行终端服务的服务器上，命名系统 mutex 可以有两个级别的可见性。 如果其名称以前缀 "Global" 开头 \\ ，则 mutex 在所有终端服务器会话中可见。 如果其名称以前缀 "Local" 开头 \\ ，则 mutex 仅在创建它的终端服务器会话中可见。 在这种情况下，可以在服务器上的其他每个终端服务器会话中存在具有相同名称的单独 mutex。 如果在创建已命名的 mutex 时未指定前缀，则采用前缀 "Local \\ "。 在终端服务器会话中，两个互斥体的名称只是它们的前缀不同，它们都是对终端服务器会话中的所有进程都可见。 也就是说，前缀名称 "Global \\ " 和 "Local \\ " 描述互斥体名称相对于终端服务器会话的作用域，而不是相对于进程。  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 下面的代码示例演示如何使用已命名的 mutex 在进程或线程之间发出信号。 从两个或更多命令窗口中运行该程序。 每个进程都将创建一个 <xref:System.Threading.Mutex> 对象，该对象表示已命名的互斥体 "MyMutex"。 命名的 mutex 是系统对象。 在此示例中，其生存期由表示它的对象的生存期界定 <xref:System.Threading.Mutex> 。 当第一个进程创建其本地对象时，将创建已命名的 mutex <xref:System.Threading.Mutex> ，并在所有 <xref:System.Threading.Mutex> 表示它的对象被释放时销毁。 命名的 mutex 最初由第一个进程拥有。 第二个进程和任何后续进程将等待前面的进程释放已命名的互斥体。  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">命名互斥体存在且具有访问控制安全性，但用户不具备 <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />。</exception>
        <exception cref="T:System.IO.IOException"><paramref name="name" /> 无效。 导致这种情况的原因有很多，包括操作系统可能会施加的一些限制，例如未知前缀或无效字符。 请注意，名称和常见前缀 "Global\" 和 "Local\" 区分大小写。

或

存在其他错误。 `HResult` 属性可能提供更多信息。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">仅限 Windows：<paramref name="name" /> 指定了未知命名空间。 有关详细信息，请参阅[对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="name" /> 太长。 长度限制可能取决于操作系统或配置。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">无法创建具有提供的 <paramref name="name" /> 的同步对象。 不同类型的同步对象可能具有相同的名称。</exception>
        <exception cref="T:System.ArgumentException">仅限 .NET Framework：<paramref name="name" /> 的长度超过 MAX_PATH（260 个字符）。</exception>
        <related type="Article" href="/dotnet/standard/threading/">托管线程处理</related>
        <related type="Article" href="/dotnet/standard/threading/mutexes">Mutexes</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean, mutexSecurity As MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string * bool * System.Security.AccessControl.MutexSecurity -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew, mutexSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">如果为 <see langword="true" />，则给予调用线程已命名的系统互斥体的初始所属权（如果已命名的系统互斥体是通过此调用创建的）；否则为 <see langword="false" />。</param>
        <param name="name">如果要与其他进程共享同步对象，则为名称；否则为 <see langword="null" /> 或空字符串。 该名称区分大小写。</param>
        <param name="createdNew">在此方法返回时，如果创建了局部互斥体（即，如果 <paramref name="name" /> 为 <see langword="null" /> 或空字符串）或指定的命名系统互斥体，则包含布尔值 <see langword="true" />；如果指定的命名系统互斥体已存在，则为 <see langword="false" />。 此参数未经初始化即被传递。</param>
        <param name="mutexSecurity">一个 <see cref="T:System.Security.AccessControl.MutexSecurity" /> 对象，表示应用于已命名的系统互斥体的访问控制安全性。</param>
        <summary>使用可指示调用线程是否应具有互斥体的初始所有权以及字符串是否为互斥体的名称的 Boolean 值和当线程返回时可指示调用线程是否已赋予互斥体的初始所有权以及访问控制安全是否已应用到命名互斥体的 Boolean 变量初始化 <see cref="T:System.Threading.Mutex" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `name`可以使用 `Global\` 或前缀 `Local\` 来指定命名空间。 如果 `Global` 指定了命名空间，则同步对象可能与系统上的任何进程共享。 `Local`指定命名空间后，如果未指定命名空间，这也是默认命名空间，则同步对象可能与同一会话中的进程共享。 在 Windows 上，会话是一个登录会话，服务通常在不同的非交互式会话中运行。 在类似 Unix 的操作系统上，每个 shell 都有自己的会话。 会话本地同步对象可能适用于具有父/子关系的进程之间的同步，它们全都在同一会话中运行。 有关 Windows 上的 synchornization 对象名称的详细信息，请参阅 [对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。

 如果提供了， `name` 并且命名空间中已存在请求类型的同步对象，则使用现有的同步对象。 如果命名空间中已存在另一个类型的同步对象， `WaitHandleCannotBeOpenedException` 则会引发。 否则，将创建一个新的同步对象。

 如果不 `name` 为， `null` 并且 `initiallyOwned` 为，则只有在 `true` `createdNew` `true` 调用之后，调用线程才拥有已命名的互斥体。 否则，线程可以通过调用方法来请求互斥体 <xref:System.Threading.WaitHandle.WaitOne%2A> 。  
  
 使用此构造函数在创建已命名的系统互斥体时对其应用访问控制安全性，防止其他代码控制互斥体。  
  
 此构造函数初始化 <xref:System.Threading.Mutex> 对象，该对象表示已命名的系统互斥体。 可以创建多个 <xref:System.Threading.Mutex> 表示同一命名系统 mutex 的对象。  
  
 如果已命名的系统互斥体不存在，则将使用指定的访问控制安全性来创建它。 如果已命名的互斥体存在，则将忽略指定的访问控制安全性。  
  
> [!NOTE]
>  调用方对新创建的对象拥有完全控制权， <xref:System.Threading.Mutex> 即使 `mutexSecurity` 拒绝或无法向当前用户授予某些访问权限。 但是，如果当前用户尝试 <xref:System.Threading.Mutex> 使用构造函数或方法获取表示相同命名互斥体的另一个对象， <xref:System.Threading.Mutex.OpenExisting%2A> 则会应用 Windows 访问控制安全性。  
  
 如果已使用访问控制安全性创建了已命名的 mutex 并且调用方没有 <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> ，则会引发异常。 若要使用只同步线程活动所需的权限打开现有的已命名 mutex，请参见 <xref:System.Threading.Mutex.OpenExisting%2A> 方法。  
  
 如果为指定 `null` 或空字符串，则将 `name` 创建本地 mutex，就像您已调用 <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> 构造函数一样。 在此示例中， `createdNew` 始终为 `true` 。  
  
 由于它们是系统范围的，因此可以使用命名的 mutex 跨进程边界协调资源使用。  
  
> [!NOTE]
>  在运行终端服务的服务器上，命名系统 mutex 可以有两个级别的可见性。 如果其名称以前缀 "Global" 开头 \\ ，则 mutex 在所有终端服务器会话中可见。 如果其名称以前缀 "Local" 开头 \\ ，则 mutex 仅在创建它的终端服务器会话中可见。 在这种情况下，可以在服务器上的其他每个终端服务器会话中存在具有相同名称的单独 mutex。 如果在创建已命名的 mutex 时未指定前缀，则采用前缀 "Local \\ "。 在终端服务器会话中，两个互斥体的名称只是它们的前缀不同，它们都是对终端服务器会话中的所有进程都可见。 也就是说，前缀名称 "Global \\ " 和 "Local \\ " 描述互斥体名称相对于终端服务器会话的作用域，而不是相对于进程。  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 下面的代码示例演示具有访问控制安全性的已命名 mutex 的跨进程行为。 该示例使用 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 方法重载来测试是否存在已命名的 mutex。  
  
 如果互斥体不存在，则将使用初始所有权和访问控制安全性来创建它，这会拒绝当前用户使用互斥体的权限，但会授予读取和更改互斥体权限的权限。  
  
 如果从两个命令窗口运行已编译的示例，第二个副本将在调用时引发访问冲突异常 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 。 捕获到异常，该示例使用 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 方法重载，以读取和更改权限所需的权限打开互斥体。  
  
 更改权限后，将打开互斥体，其中包含输入和释放该互斥体所需的权限。 如果从第三个命令窗口运行已编译的示例，该示例将使用新的权限运行。  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="name" /> 无效。 导致这种情况的原因有很多，包括操作系统可能会施加的一些限制，例如未知前缀或无效字符。 请注意，名称和常见前缀 "Global\" 和 "Local\" 区分大小写。

或

存在其他错误。 `HResult` 属性可能提供更多信息。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">仅限 Windows：<paramref name="name" /> 指定了未知命名空间。 有关详细信息，请参阅[对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="name" /> 太长。 长度限制可能取决于操作系统或配置。</exception>
        <exception cref="T:System.UnauthorizedAccessException">命名互斥体存在且具有访问控制安全性，但用户不具备 <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">无法创建具有提供的 <paramref name="name" /> 的同步对象。 不同类型的同步对象可能具有相同的名称。</exception>
        <exception cref="T:System.ArgumentException">仅限 .NET Framework：<paramref name="name" /> 的长度超过 MAX_PATH（260 个字符）。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.MutexSecurity" Usage="mutex.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取表示已命名的互斥体的访问控制安全性的 <see cref="T:System.Security.AccessControl.MutexSecurity" /> 对象。</summary>
        <returns>表示已命名的互斥体的访问控制安全性的 <see cref="T:System.Security.AccessControl.MutexSecurity" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Mutex.GetAccessControl%2A>方法使用按位 "或" 运算) 组合 (下面的标志组合来搜索权限： <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType> 、 <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType> 和 <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType> 。  
  
 用户必须 <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> 调用此方法，并且必须已使用打开互斥体 <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> 。  
  
   
  
## Examples  
 下面的代码示例演示具有访问控制安全性的已命名 mutex 的跨进程行为。 该示例使用 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 方法重载来测试是否存在已命名的 mutex。  
  
 如果互斥体不存在，则将使用初始所有权和访问控制安全性来创建它，这会拒绝当前用户使用互斥体的权限，但会授予读取和更改互斥体权限的权限。  
  
 如果从两个命令窗口运行已编译的示例，第二个副本将在调用时引发访问冲突异常 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 。 捕获到异常，该示例使用 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 方法重载，通过使用和方法来打开具有读取和更改权限所需权限的 mutex <xref:System.Threading.Mutex.GetAccessControl%2A> <xref:System.Threading.Mutex.SetAccessControl%2A> 。  
  
 更改权限后，将打开互斥体，其中包含输入和释放该互斥体所需的权限。 如果从第三个命令窗口运行已编译的示例，该示例将使用新的权限运行。  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">当前 <see cref="T:System.Threading.Mutex" /> 对象表示一个已命名的系统互斥体，但用户不具备 <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />。  
  
或 
当前 <see cref="T:System.Threading.Mutex" /> 对象表示一个已命名的系统互斥体，但它未用 <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /> 打开。</exception>
        <exception cref="T:System.NotSupportedException">不支持 Windows 98 或 Windows Millennium Edition。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>打开指定的已命名的互斥体（如果已经存在）。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">要与其他进程共享的同步对象的名称。 该名称区分大小写。</param>
        <summary>打开指定的已命名的互斥体（如果已经存在）。</summary>
        <returns>表示已命名的系统互斥体的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `name`可以使用 `Global\` 或前缀 `Local\` 来指定命名空间。 如果 `Global` 指定了命名空间，则同步对象可能与系统上的任何进程共享。 `Local`指定命名空间后，如果未指定命名空间，这也是默认命名空间，则同步对象可能与同一会话中的进程共享。 在 Windows 上，会话是一个登录会话，服务通常在不同的非交互式会话中运行。 在类似 Unix 的操作系统上，每个 shell 都有自己的会话。 会话本地同步对象可能适用于具有父/子关系的进程之间的同步，它们全都在同一会话中运行。 有关 Windows 上的 synchornization 对象名称的详细信息，请参阅 [对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。

 如果命名空间中存在请求类型的同步对象，则会打开现有的同步对象。 如果命名空间中不存在同步对象，或者命名空间中存在其他类型的同步对象， `WaitHandleCannotBeOpenedException` 则会引发。

 此 <xref:System.Threading.Mutex.OpenExisting%2A> 方法尝试打开指定的命名系统互斥体。 若要创建不存在的系统互斥体，请使用 <xref:System.Threading.Mutex.%23ctor%2A> 具有参数的构造函数之一 `name` 。  
  
 对此方法使用相同值的多个调用 `name` 不一定会返回相同的 <xref:System.Threading.Mutex> 对象，即使返回的对象表示相同的命名系统 mutex。  
  
 此方法重载等效于调用 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 方法重载，并 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 使用按位 "或" 运算来指定和权限。  
  
 指定标志后， <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> 线程可以等待互斥体，指定 <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 标志允许线程调用 <xref:System.Threading.Mutex.ReleaseMutex%2A> 方法。  
  
 此方法不请求 mutex 的所有权。  
  
   
  
## Examples  
 下面的代码示例演示具有访问控制安全性的已命名 mutex 的跨进程行为。 该示例使用 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 方法重载来测试是否存在已命名的 mutex。  
  
 如果互斥体不存在，则将使用初始所有权和访问控制安全性来创建它，这会拒绝当前用户使用互斥体的权限，但会授予读取和更改互斥体权限的权限。  
  
 如果从两个命令窗口运行已编译的示例，第二个副本将在调用时引发访问冲突异常 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 。 捕获到异常，该示例使用 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 方法重载，以读取和更改权限所需的权限打开互斥体。  
  
 更改权限后，将打开互斥体，其中包含输入和释放该互斥体所需的权限。 如果从第三个命令窗口运行已编译的示例，该示例将使用新的权限运行。  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> 是一个空字符串。

或

仅限 .NET Framework：<paramref name="name" /> 的长度超过 MAX_PATH（260 个字符）。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 上声明的默认值为 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">无法创建具有提供的 <paramref name="name" /> 的同步对象。 不同类型的同步对象可能具有相同的名称。 在某些情况下，对于无效名称，可能会引发此异常。</exception>
        <exception cref="T:System.IO.IOException"><paramref name="name" /> 无效。 导致这种情况的原因有很多，包括操作系统可能会施加的一些限制，例如未知前缀或无效字符。 请注意，名称和常见前缀 "Global\" 和 "Local\" 区分大小写。

或

存在其他错误。 `HResult` 属性可能提供更多信息。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">仅限 Windows：<paramref name="name" /> 指定了未知命名空间。 有关详细信息，请参阅[对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="name" /> 太长。 长度限制可能取决于操作系统或配置。</exception>
        <exception cref="T:System.UnauthorizedAccessException">存在命名的互斥，但用户没有使用它时所需的安全访问权限。</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.MutexRights -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">要与其他进程共享的同步对象的名称。 该名称区分大小写。</param>
        <param name="rights">表示所需的安全访问权限的枚举值的按位组合。</param>
        <summary>用安全访问权限打开指定名称为 mutex（如果已经存在），并返回指示操作是否成功的值。</summary>
        <returns>表示已命名的系统互斥体的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `name`可以使用 `Global\` 或前缀 `Local\` 来指定命名空间。 如果 `Global` 指定了命名空间，则同步对象可能与系统上的任何进程共享。 `Local`指定命名空间后，如果未指定命名空间，这也是默认命名空间，则同步对象可能与同一会话中的进程共享。 在 Windows 上，会话是一个登录会话，服务通常在不同的非交互式会话中运行。 在类似 Unix 的操作系统上，每个 shell 都有自己的会话。 会话本地同步对象可能适用于具有父/子关系的进程之间的同步，它们全都在同一会话中运行。 有关 Windows 上的 synchornization 对象名称的详细信息，请参阅 [对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。

 如果命名空间中存在请求类型的同步对象，则会打开现有的同步对象。 如果命名空间中不存在同步对象，或者命名空间中存在其他类型的同步对象， `WaitHandleCannotBeOpenedException` 则会引发。

 `rights`参数必须包括 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> 允许线程在互斥体上等待的标志，以及 <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 允许线程调用方法的标志 <xref:System.Threading.Mutex.ReleaseMutex%2A> 。  
  
 此 <xref:System.Threading.Mutex.OpenExisting%2A> 方法尝试打开现有的已命名的互斥体。 若要创建不存在的系统互斥体，请使用 <xref:System.Threading.Mutex.%23ctor%2A> 具有参数的构造函数之一 `name` 。  
  
 对此方法使用相同值的多个调用 `name` 不一定会返回相同的 <xref:System.Threading.Mutex> 对象，即使返回的对象表示相同的命名系统 mutex。  
  
 此方法不请求 mutex 的所有权。  
  
   
  
## Examples  
 下面的代码示例演示具有访问控制安全性的已命名 mutex 的跨进程行为。 该示例使用 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 方法重载来测试是否存在已命名的 mutex。  
  
 如果互斥体不存在，则将使用初始所有权和访问控制安全性来创建它，这会拒绝当前用户使用互斥体的权限，但会授予读取和更改互斥体权限的权限。  
  
 如果从两个命令窗口运行已编译的示例，第二个副本将在调用时引发访问冲突异常 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 。 捕获到异常，该示例使用 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 方法重载，以读取和更改权限所需的权限打开互斥体。  
  
 更改权限后，将打开互斥体，其中包含输入和释放该互斥体所需的权限。 如果从第三个命令窗口运行已编译的示例，该示例将使用新的权限运行。  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> 是一个空字符串。

或

仅限 .NET Framework：<paramref name="name" /> 的长度超过 MAX_PATH（260 个字符）。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 上声明的默认值为 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">无法创建具有提供的 <paramref name="name" /> 的同步对象。 不同类型的同步对象可能具有相同的名称。 在某些情况下，对于无效名称，可能会引发此异常。</exception>
        <exception cref="T:System.IO.IOException"><paramref name="name" /> 无效。 导致这种情况的原因有很多，包括操作系统可能会施加的一些限制，例如未知前缀或无效字符。 请注意，名称和常见前缀 "Global\" 和 "Local\" 区分大小写。

或

存在其他错误。 `HResult` 属性可能提供更多信息。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">仅限 Windows：<paramref name="name" /> 指定了未知命名空间。 有关详细信息，请参阅[对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="name" /> 太长。 长度限制可能取决于操作系统或配置。</exception>
        <exception cref="T:System.UnauthorizedAccessException">已命名的 mutex 存在，但是用户不具备所需的安全访问权。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberSignature Language="F#" Value="member this.ReleaseMutex : unit -&gt; unit" Usage="mutex.ReleaseMutex " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放 <see cref="T:System.Threading.Mutex" /> 一次。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每当线程获取互斥体时 (例如，通过调用其 <xref:System.Threading.WaitHandle.WaitOne%2A> 方法) ，它必须随后调用 <xref:System.Threading.Mutex.ReleaseMutex%2A> 以放弃互斥体的所有权，并取消阻止其他尝试获取 mutex 所有权的线程。 如果尝试获取互斥体的所有权失败 (例如，当 <xref:System.Threading.WaitHandle.WaitOne%2A> 使用或参数调用方法时，如果 `millisecondsTimeout` `timeout` `false` 请求超时) ，则该线程 <xref:System.Threading.Mutex.ReleaseMutex%2A> 不应调用，在这种情况下，还应不允许该线程访问由 mutex 保护的资源，如下面的示例所示。  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 拥有互斥体的线程可以在重复的 wait 函数调用中指定同一互斥体，而不会阻止其执行。 调用次数由公共语言运行时保留。 线程必须调用 <xref:System.Threading.Mutex.ReleaseMutex%2A> 相同的次数才能释放互斥体的所有权。  
  
 如果线程在拥有互斥体时终止，则会被视为放弃互斥体。 Mutex 的状态设置为 "已终止"，下一个等待线程将获得所有权。 如果没有一个拥有互斥体，则互斥体的状态为 "已终止"。 从 .NET Framework 的2.0 版开始，将 <xref:System.Threading.AbandonedMutexException> 在获取互斥体的下一个线程中引发。 在 .NET Framework 2.0 版之前，不会引发异常。  
  
> [!CAUTION]
>  被放弃的 mutex 通常表明代码中存在严重错误。 当线程在不释放 mutex 的情况下退出时，由 mutex 保护的数据结构可能不是一致的状态。 如果可以验证数据结构的完整性，下一个请求 mutex 所有权的线程就可以处理此异常并继续操作。  
  
 对于系统范围的 mutex，放弃的 mutex 可能指示应用程序已突然终止（例如，通过使用 Windows 任务管理器终止）。  
  
   
  
## Examples  
 下面的示例演示如何使用本地 <xref:System.Threading.Mutex> 对象来同步对受保护资源的访问。 创建互斥体的线程最初不负责。 <xref:System.Threading.Mutex.ReleaseMutex%2A>方法用于在不再需要互斥体时释放互斥体。  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">调用线程不拥有互斥体。</exception>
        <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
        <related type="Article" href="/dotnet/standard/threading/">托管线程处理</related>
        <related type="Article" href="/dotnet/standard/threading/mutexes">Mutexes</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (mutexSecurity As MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.MutexSecurity -&gt; unit" Usage="mutex.SetAccessControl mutexSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity">一个 <see cref="T:System.Security.AccessControl.MutexSecurity" /> 对象，表示应用于已命名的系统互斥体的访问控制安全性。</param>
        <summary>设置已命名的系统互斥体的访问控制安全性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用户必须具有 <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> 调用此方法的权限，并且必须使用打开互斥体 <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> 。  
  
   
  
## Examples  
 下面的代码示例演示具有访问控制安全性的已命名 mutex 的跨进程行为。 该示例使用 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 方法重载来测试是否存在已命名的 mutex。  
  
 如果互斥体不存在，则将使用初始所有权和访问控制安全性来创建它，这会拒绝当前用户使用互斥体的权限，但会授予读取和更改互斥体权限的权限。  
  
 如果从两个命令窗口运行已编译的示例，第二个副本将在调用时引发访问冲突异常 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 。 捕获到异常，该示例使用 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 方法重载，通过使用和方法来打开具有读取和更改权限所需权限的 mutex <xref:System.Threading.Mutex.GetAccessControl%2A> <xref:System.Threading.Mutex.SetAccessControl%2A> 。  
  
 更改权限后，将打开互斥体，其中包含输入和释放该互斥体所需的权限。 如果从第三个命令窗口运行已编译的示例，该示例将使用新的权限运行。  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="mutexSecurity" /> 上声明的默认值为 <see langword="null" />。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户不具备 <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />。  
  
或 
互斥体未用 <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /> 打开。</exception>
        <exception cref="T:System.SystemException">当前 <see cref="T:System.Threading.Mutex" /> 对象不表示已命名的系统互斥体。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>打开指定的已命名的互斥体（如果已经存在），并返回指示操作是否成功的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * Mutex -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, result)" />
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex? result);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">要与其他进程共享的同步对象的名称。 该名称区分大小写。</param>
        <param name="result">当此方法返回时，如果调用成功，则包含表示命名互斥体的 <see cref="T:System.Threading.Mutex" /> 对象；否则为 <see langword="null" />。 该参数未经初始化即被处理。</param>
        <summary>打开指定的已命名的互斥体（如果已经存在），并返回指示操作是否成功的值。</summary>
        <returns>如果命名互斥体成功打开，则为 <see langword="true" />；否则为 <see langword="false" />。 在某些情况下，对于无效名称，可能会返回 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `name`可以使用 `Global\` 或前缀 `Local\` 来指定命名空间。 如果 `Global` 指定了命名空间，则同步对象可能与系统上的任何进程共享。 `Local`指定命名空间后，如果未指定命名空间，这也是默认命名空间，则同步对象可能与同一会话中的进程共享。 在 Windows 上，会话是一个登录会话，服务通常在不同的非交互式会话中运行。 在类似 Unix 的操作系统上，每个 shell 都有自己的会话。 会话本地同步对象可能适用于具有父/子关系的进程之间的同步，它们全都在同一会话中运行。 有关 Windows 上的 synchornization 对象名称的详细信息，请参阅 [对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。

 如果命名空间中存在请求类型的同步对象，则会打开现有的同步对象。 如果命名空间中不存在同步对象，或者命名空间中存在其他类型的同步对象， `false` 则返回。

 若要创建不存在的系统互斥体，请使用 <xref:System.Threading.Mutex.%23ctor%2A> 具有参数的构造函数之一 `name` 。  
  
 如果不确定是否存在已命名的互斥体，请使用此方法重载，而不是 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 方法重载，这会在互斥体不存在时引发异常。  
  
 对此方法使用相同值的多个调用 `name` 不一定会返回相同的 <xref:System.Threading.Mutex> 对象，即使返回的对象表示相同的命名系统 mutex。  
  
 此方法重载等效于调用 <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> 方法重载，并 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 使用按位 "或" 运算来指定和权限。 指定标志后， <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> 线程可以等待互斥体，指定 <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 标志允许线程调用 <xref:System.Threading.Mutex.ReleaseMutex%2A> 方法。  
  
 此方法不请求 mutex 的所有权。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> 是一个空字符串。

或

仅限 .NET Framework：<paramref name="name" /> 的长度超过 MAX_PATH（260 个字符）。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 上声明的默认值为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.IOException"><paramref name="name" /> 无效。 导致这种情况的原因有很多，包括操作系统可能会施加的一些限制，例如未知前缀或无效字符。 请注意，名称和常见前缀 "Global\" 和 "Local\" 区分大小写。 对于某些无效名称，该方法可能返回 <see langword="false" />。

或

存在其他错误。 `HResult` 属性可能提供更多信息。</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="name" /> 太长。 长度限制可能取决于操作系统或配置。</exception>
        <exception cref="T:System.UnauthorizedAccessException">存在命名的互斥，但用户没有使用它时所需的安全访问权限。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.MutexRights * Mutex -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">要与其他进程共享的同步对象的名称。 该名称区分大小写。</param>
        <param name="rights">表示所需的安全访问权限的枚举值的按位组合。</param>
        <param name="result">当此方法返回时，如果调用成功，则包含表示命名互斥体的 <see cref="T:System.Threading.Mutex" /> 对象；否则为 <see langword="null" />。 该参数未经初始化即被处理。</param>
        <summary>利用所需的安全访问权限，打开指定的已命名的互斥体（如果已经存在），并返回指示操作是否成功的值。</summary>
        <returns>如果命名互斥体成功打开，则为 <see langword="true" />；否则为 <see langword="false" />。 在某些情况下，对于无效名称，可能会返回 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `name`可以使用 `Global\` 或前缀 `Local\` 来指定命名空间。 如果 `Global` 指定了命名空间，则同步对象可能与系统上的任何进程共享。 `Local`指定命名空间后，如果未指定命名空间，这也是默认命名空间，则同步对象可能与同一会话中的进程共享。 在 Windows 上，会话是一个登录会话，服务通常在不同的非交互式会话中运行。 在类似 Unix 的操作系统上，每个 shell 都有自己的会话。 会话本地同步对象可能适用于具有父/子关系的进程之间的同步，它们全都在同一会话中运行。 有关 Windows 上的 synchornization 对象名称的详细信息，请参阅 [对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。

 如果命名空间中存在请求类型的同步对象，则会打开现有的同步对象。 如果命名空间中不存在同步对象，或者命名空间中存在其他类型的同步对象， `false` 则返回。

 若要创建不存在的系统互斥体，请使用 <xref:System.Threading.Mutex.%23ctor%2A> 具有参数的构造函数之一 `name` 。  
  
 如果不确定是否存在已命名的互斥体，请使用此方法重载，而不是 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 方法重载，这会在互斥体不存在时引发异常。  
  
 `rights`参数必须包括 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> 允许线程在互斥体上等待的标志，以及 <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 允许线程调用方法的标志 <xref:System.Threading.Mutex.ReleaseMutex%2A> 。  
  
 对此方法使用相同值的多个调用 `name` 不一定会返回相同的 <xref:System.Threading.Mutex> 对象，即使返回的对象表示相同的命名系统 mutex。  
  
 此方法不请求 mutex 的所有权。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> 是一个空字符串。

或

仅限 .NET Framework：<paramref name="name" /> 的长度超过 MAX_PATH（260 个字符）。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 上声明的默认值为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.IOException"><paramref name="name" /> 无效。 导致这种情况的原因有很多，包括操作系统可能会施加的一些限制，例如未知前缀或无效字符。 请注意，名称和常见前缀 "Global\" 和 "Local\" 区分大小写。 对于某些无效名称，该方法可能返回 <see langword="false" />。

或

存在其他错误。 `HResult` 属性可能提供更多信息。</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="name" /> 太长。 长度限制可能取决于操作系统或配置。</exception>
        <exception cref="T:System.UnauthorizedAccessException">存在命名的互斥，但用户没有使用它时所需的安全访问权限。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
