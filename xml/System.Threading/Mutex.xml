<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e66b0389d87ac0b16b6890b4dcba055f5af8ecb1" /><Meta Name="ms.sourcegitcommit" Value="943c8cdbe5b47c6c296a6f4b73038bbd43da0dd2" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="02/12/2021" /><Meta Name="ms.locfileid" Value="100314342" /></Metadata><TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Mutex = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Threading" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Threading" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="395a1-101">还可用于进程间同步的同步基元。</span><span class="sxs-lookup"><span data-stu-id="395a1-101">A synchronization primitive that can also be used for interprocess synchronization.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="395a1-102">当两个或多个线程同时访问共享资源时，系统需要一个同步机制来确保每次只有一个线程使用资源。</span><span class="sxs-lookup"><span data-stu-id="395a1-102">When two or more threads need to access a shared resource at the same time, the system needs a synchronization mechanism to ensure that only one thread at a time uses the resource.</span></span> <span data-ttu-id="395a1-103"><xref:System.Threading.Mutex> 是一个同步基元，该基元仅向一个线程授予对共享资源的独占访问权限。</span><span class="sxs-lookup"><span data-stu-id="395a1-103"><xref:System.Threading.Mutex> is a synchronization primitive that grants exclusive access to the shared resource to only one thread.</span></span> <span data-ttu-id="395a1-104">如果线程获取互斥体，则需要获取该互斥体的第二个线程将挂起，直到第一个线程释放该互斥体。</span><span class="sxs-lookup"><span data-stu-id="395a1-104">If a thread acquires a mutex, the second thread that wants to acquire that mutex is suspended until the first thread releases the mutex.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="395a1-105">此类型实现 <xref:System.IDisposable> 接口。</span><span class="sxs-lookup"><span data-stu-id="395a1-105">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="395a1-106">在使用完类型后，您应直接或间接释放类型。</span><span class="sxs-lookup"><span data-stu-id="395a1-106">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="395a1-107">若要直接释放类型，请在 `try`/`catch` 块中调用其 <xref:System.IDisposable.Dispose%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="395a1-107">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="395a1-108">若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。</span><span class="sxs-lookup"><span data-stu-id="395a1-108">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="395a1-109">有关详细信息，请参阅 <xref:System.IDisposable> 接口主题中的“使用实现 IDisposable 的对象”一节。</span><span class="sxs-lookup"><span data-stu-id="395a1-109">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="395a1-110">您可以使用 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 方法来请求 mutex 的所有权。</span><span class="sxs-lookup"><span data-stu-id="395a1-110">You can use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method to request ownership of a mutex.</span></span> <span data-ttu-id="395a1-111">调用线程将会阻塞，直到发生以下情况之一：</span><span class="sxs-lookup"><span data-stu-id="395a1-111">The calling thread blocks until one of the following occurs:</span></span>  
  
-   <span data-ttu-id="395a1-112">向互斥体发出信号，指示该互斥体不为所有。</span><span class="sxs-lookup"><span data-stu-id="395a1-112">The mutex is signaled to indicate that it is not owned.</span></span> <span data-ttu-id="395a1-113">发生这种情况时，此 <xref:System.Threading.WaitHandle.WaitOne%2A> 方法将返回 `true` ，并且调用线程将假定该互斥体的所有权，并访问该 mutex 保护的资源。</span><span class="sxs-lookup"><span data-stu-id="395a1-113">When this happens, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true`, and the calling thread assumes ownership of the mutex and accesses the resource protected by the mutex.</span></span> <span data-ttu-id="395a1-114">完成访问资源后，线程必须调用 <xref:System.Threading.Mutex.ReleaseMutex%2A> 方法以释放互斥体的所有权。</span><span class="sxs-lookup"><span data-stu-id="395a1-114">When it has finished accessing the resource, the thread must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method to release ownership of the mutex.</span></span> <span data-ttu-id="395a1-115">"示例" 部分中的第一个示例说明了此模式。</span><span class="sxs-lookup"><span data-stu-id="395a1-115">The first example in the Examples section illustrates this pattern.</span></span>  
  
-   <span data-ttu-id="395a1-116">在对具有或参数的方法的调用中指定的超时间隔 <xref:System.Threading.WaitHandle.WaitOne%2A> `millisecondsTimeout` `timeout` 已过。</span><span class="sxs-lookup"><span data-stu-id="395a1-116">The time-out interval specified in the call to a <xref:System.Threading.WaitHandle.WaitOne%2A> method that has a `millisecondsTimeout` or `timeout` parameter has elapsed.</span></span> <span data-ttu-id="395a1-117">发生这种情况时， <xref:System.Threading.WaitHandle.WaitOne%2A> 方法返回 `false` ，调用线程不会进一步尝试获取互斥体的所有权。</span><span class="sxs-lookup"><span data-stu-id="395a1-117">When this happens, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `false`, and the calling thread makes no further attempt to acquire ownership of the mutex.</span></span> <span data-ttu-id="395a1-118">在这种情况下，您应该构建代码的结构，以便对调用线程拒绝对由 mutex 保护的资源的访问。</span><span class="sxs-lookup"><span data-stu-id="395a1-118">In this case, you should structure your code so that access to the resource that is protected by the mutex is denied to the calling thread.</span></span> <span data-ttu-id="395a1-119">由于线程从未获取互斥体的所有权，因此不能调用 <xref:System.Threading.Mutex.ReleaseMutex%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="395a1-119">Because the thread never acquired ownership of the mutex, it must not call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span> <span data-ttu-id="395a1-120">"示例" 部分中的第二个示例演示了此模式。</span><span class="sxs-lookup"><span data-stu-id="395a1-120">The second example in the Examples section illustrates this pattern.</span></span>  
  
 <span data-ttu-id="395a1-121"><xref:System.Threading.Mutex>类强制执行线程标识，因此互斥体只能由获取它的线程释放。</span><span class="sxs-lookup"><span data-stu-id="395a1-121">The <xref:System.Threading.Mutex> class enforces thread identity, so a mutex can be released only by the thread that acquired it.</span></span> <span data-ttu-id="395a1-122">与此相反， <xref:System.Threading.Semaphore> 类不强制执行线程标识。</span><span class="sxs-lookup"><span data-stu-id="395a1-122">By contrast, the <xref:System.Threading.Semaphore> class does not enforce thread identity.</span></span> <span data-ttu-id="395a1-123">还可以跨应用程序域边界传递互斥体。</span><span class="sxs-lookup"><span data-stu-id="395a1-123">A mutex can also be passed across application domain boundaries.</span></span>  
  
 <span data-ttu-id="395a1-124">拥有 mutex 的线程可以在重复调用中请求同一互斥体， <xref:System.Threading.WaitHandle.WaitOne%2A> 而不会阻止其执行。</span><span class="sxs-lookup"><span data-stu-id="395a1-124">The thread that owns a mutex can request the same mutex in repeated calls to <xref:System.Threading.WaitHandle.WaitOne%2A> without blocking its execution.</span></span> <span data-ttu-id="395a1-125">但是，线程必须调用 <xref:System.Threading.Mutex.ReleaseMutex%2A> 方法相同的次数来释放 mutex 的所有权。</span><span class="sxs-lookup"><span data-stu-id="395a1-125">However, the thread must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method the same number of times to release ownership of the mutex.</span></span>  
  
 <span data-ttu-id="395a1-126">由于 <xref:System.Threading.Mutex> 该类继承自 <xref:System.Threading.WaitHandle> ，因此还可以调用静态 <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> 方法和方法来同步对受保护资源的访问。</span><span class="sxs-lookup"><span data-stu-id="395a1-126">Because the <xref:System.Threading.Mutex> class inherits from <xref:System.Threading.WaitHandle>, you can also call the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods to synchronize access to a protected resource.</span></span>  
  
 <span data-ttu-id="395a1-127">如果线程在拥有互斥体时终止，则会被视为放弃互斥体。</span><span class="sxs-lookup"><span data-stu-id="395a1-127">If a thread terminates while owning a mutex, the mutex is said to be abandoned.</span></span> <span data-ttu-id="395a1-128">Mutex 的状态设置为 "已终止"，下一个等待线程将获得所有权。</span><span class="sxs-lookup"><span data-stu-id="395a1-128">The state of the mutex is set to signaled, and the next waiting thread gets ownership.</span></span> <span data-ttu-id="395a1-129">从 .NET Framework 的2.0 版开始，将 <xref:System.Threading.AbandonedMutexException> 在下一个获取被放弃的互斥体的线程中引发。</span><span class="sxs-lookup"><span data-stu-id="395a1-129">Beginning in version 2.0 of the .NET Framework, an <xref:System.Threading.AbandonedMutexException> is thrown in the next thread that acquires the abandoned mutex.</span></span> <span data-ttu-id="395a1-130">在 .NET Framework 版本2.0 之前，不引发异常。</span><span class="sxs-lookup"><span data-stu-id="395a1-130">Before version 2.0 of the .NET Framework, no exception was thrown.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="395a1-131">被放弃的 mutex 通常表明代码中存在严重错误。</span><span class="sxs-lookup"><span data-stu-id="395a1-131">An abandoned mutex often indicates a serious error in the code.</span></span> <span data-ttu-id="395a1-132">当线程在不释放 mutex 的情况下退出时，由 mutex 保护的数据结构可能不是一致的状态。</span><span class="sxs-lookup"><span data-stu-id="395a1-132">When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</span></span> <span data-ttu-id="395a1-133">如果可以验证数据结构的完整性，下一个请求 mutex 所有权的线程就可以处理此异常并继续操作。</span><span class="sxs-lookup"><span data-stu-id="395a1-133">The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</span></span>  
  
 <span data-ttu-id="395a1-134">对于系统范围的 mutex，放弃的 mutex 可能指示应用程序已突然终止（例如，通过使用 Windows 任务管理器终止）。</span><span class="sxs-lookup"><span data-stu-id="395a1-134">In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span>  
  
 <span data-ttu-id="395a1-135">Mutex 分为两种类型：本地互斥体，即未命名和命名的系统互斥体。</span><span class="sxs-lookup"><span data-stu-id="395a1-135">Mutexes are of two types: local mutexes, which are unnamed, and named system mutexes.</span></span> <span data-ttu-id="395a1-136">本地 mutex 仅存在于进程中。</span><span class="sxs-lookup"><span data-stu-id="395a1-136">A local mutex exists only within your process.</span></span> <span data-ttu-id="395a1-137">您的进程中的任何线程都可以使用它来引用 <xref:System.Threading.Mutex> 表示 mutex 的对象。</span><span class="sxs-lookup"><span data-stu-id="395a1-137">It can be used by any thread in your process that has a reference to the <xref:System.Threading.Mutex> object that represents the mutex.</span></span> <span data-ttu-id="395a1-138">每个未命名 <xref:System.Threading.Mutex> 对象都表示一个单独的本地 mutex。</span><span class="sxs-lookup"><span data-stu-id="395a1-138">Each unnamed <xref:System.Threading.Mutex> object represents a separate local mutex.</span></span>  
  
 <span data-ttu-id="395a1-139">命名系统 mutex 在整个操作系统中均可见，可用于同步进程的活动。</span><span class="sxs-lookup"><span data-stu-id="395a1-139">Named system mutexes are visible throughout the operating system, and can be used to synchronize the activities of processes.</span></span> <span data-ttu-id="395a1-140">您可以 <xref:System.Threading.Mutex> 使用接受名称的构造函数创建表示已命名系统 mutex 的对象。</span><span class="sxs-lookup"><span data-stu-id="395a1-140">You can create a <xref:System.Threading.Mutex> object that represents a named system mutex by using a constructor that accepts a name.</span></span> <span data-ttu-id="395a1-141">可以同时创建操作系统对象，也可以在创建对象之前存在该对象 <xref:System.Threading.Mutex> 。</span><span class="sxs-lookup"><span data-stu-id="395a1-141">The operating-system object can be created at the same time, or it can exist before the creation of the <xref:System.Threading.Mutex> object.</span></span> <span data-ttu-id="395a1-142">可以创建多个表示同一命名系统 mutex 的 <xref:System.Threading.Mutex> 对象，还能使用 <xref:System.Threading.Mutex.OpenExisting%2A> 方法打开现有的命名系统 mutex。</span><span class="sxs-lookup"><span data-stu-id="395a1-142">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex, and you can use the <xref:System.Threading.Mutex.OpenExisting%2A> method to open an existing named system mutex.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="395a1-143">在运行终端服务的服务器上，命名系统 mutex 可以有两个级别的可见性。</span><span class="sxs-lookup"><span data-stu-id="395a1-143">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="395a1-144">如果其名称以前缀 "Global" 开头 \\ ，则 mutex 在所有终端服务器会话中可见。</span><span class="sxs-lookup"><span data-stu-id="395a1-144">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="395a1-145">如果其名称以前缀 "Local" 开头 \\ ，则 mutex 仅在创建它的终端服务器会话中可见。</span><span class="sxs-lookup"><span data-stu-id="395a1-145">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="395a1-146">在这种情况下，可以在服务器上的其他每个终端服务器会话中存在具有相同名称的单独 mutex。</span><span class="sxs-lookup"><span data-stu-id="395a1-146">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="395a1-147">如果在创建已命名的 mutex 时未指定前缀，则采用前缀 "Local \\ "。</span><span class="sxs-lookup"><span data-stu-id="395a1-147">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="395a1-148">在终端服务器会话中，两个互斥体的名称只是它们的前缀不同，它们都是对终端服务器会话中的所有进程都可见。</span><span class="sxs-lookup"><span data-stu-id="395a1-148">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="395a1-149">也就是说，前缀名称 "Global \\ " 和 "Local \\ " 描述互斥体名称相对于终端服务器会话的作用域，而不是相对于进程。</span><span class="sxs-lookup"><span data-stu-id="395a1-149">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 <span data-ttu-id="395a1-150">此示例演示如何使用本地 <xref:System.Threading.Mutex> 对象同步对受保护资源的访问。</span><span class="sxs-lookup"><span data-stu-id="395a1-150">This example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="395a1-151">由于每个调用线程都将被阻止，直到它获取互斥体的所有权，因此它必须调用 <xref:System.Threading.Mutex.ReleaseMutex%2A> 方法以释放互斥体的所有权。</span><span class="sxs-lookup"><span data-stu-id="395a1-151">Because each calling thread is blocked until it acquires ownership of the mutex, it must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method to release ownership of the mutex.</span></span>  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 <span data-ttu-id="395a1-152">在下面的示例中，每个线程都调用 <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> 方法来获取互斥体。</span><span class="sxs-lookup"><span data-stu-id="395a1-152">In the following example, each thread calls the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> method to acquire the mutex.</span></span> <span data-ttu-id="395a1-153">如果超时间隔已过，则该方法将返回 `false` ，并且该线程既不会获取互斥体，也不会获得对互斥体保护的资源的访问权限。</span><span class="sxs-lookup"><span data-stu-id="395a1-153">If the time-out interval elapses, the method returns `false`, and the thread neither acquires the mutex nor gains access to the resource the mutex protects.</span></span> <span data-ttu-id="395a1-154"><xref:System.Threading.Mutex.ReleaseMutex%2A>方法只由获取互斥体的线程调用。</span><span class="sxs-lookup"><span data-stu-id="395a1-154">The <xref:System.Threading.Mutex.ReleaseMutex%2A> method is called only by the thread that acquires the mutex.</span></span>  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="395a1-155">此类型是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="395a1-155">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="395a1-156">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="395a1-156">Managed Threading</span></span></related>
    <related type="Article" href="/dotnet/standard/threading/mutexes"><span data-ttu-id="395a1-157">Mutexes</span><span class="sxs-lookup"><span data-stu-id="395a1-157">Mutexes</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="395a1-158">初始化 <see cref="T:System.Threading.Mutex" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="395a1-158">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="395a1-159">使用默认属性初始化 <see cref="T:System.Threading.Mutex" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="395a1-159">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with default properties.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="395a1-160">调用此构造函数重载与调用 <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> 构造函数重载和指定 `false` 互斥体的初始所有权的方式相同。</span><span class="sxs-lookup"><span data-stu-id="395a1-160">Calling this constructor overload is the same as calling the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor overload and specifying `false` for initial ownership of the mutex.</span></span> <span data-ttu-id="395a1-161">也就是说，调用线程不拥有互斥体。</span><span class="sxs-lookup"><span data-stu-id="395a1-161">That is, the calling thread does not own the mutex.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="395a1-162">下面的代码示例演示如何使用本地 <xref:System.Threading.Mutex> 对象来同步对受保护资源的访问。</span><span class="sxs-lookup"><span data-stu-id="395a1-162">The following code example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="395a1-163">创建互斥体的线程最初不负责。</span><span class="sxs-lookup"><span data-stu-id="395a1-163">The thread that creates the mutex does not own it initially.</span></span>  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="395a1-164">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="395a1-164">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/mutexes"><span data-ttu-id="395a1-165">Mutexes</span><span class="sxs-lookup"><span data-stu-id="395a1-165">Mutexes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex initiallyOwned" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><span data-ttu-id="395a1-166">如果给调用线程赋予互斥体的初始所属权，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="395a1-166"><see langword="true" /> to give the calling thread initial ownership of the mutex; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="395a1-167">使用 Boolean 值（指示调用线程是否应具有互斥体的初始所有权）初始化 <see cref="T:System.Threading.Mutex" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="395a1-167">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="395a1-168">下面的代码示例演示如何使用本地 <xref:System.Threading.Mutex> 对象来同步对受保护资源的访问。</span><span class="sxs-lookup"><span data-stu-id="395a1-168">The following code example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="395a1-169">最初创建它的线程 <xref:System.Threading.Mutex> 。</span><span class="sxs-lookup"><span data-stu-id="395a1-169">The thread that creates the <xref:System.Threading.Mutex> owns it initially.</span></span>  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="395a1-170">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="395a1-170">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/mutexes"><span data-ttu-id="395a1-171">Mutexes</span><span class="sxs-lookup"><span data-stu-id="395a1-171">Mutexes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name)" />
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string? name);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><span data-ttu-id="395a1-172">如果为 <see langword="true" />，则给予调用线程已命名的系统互斥体的初始所属权（如果已命名的系统互斥体是通过此调用创建的）；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="395a1-172"><see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</span></span></param>
        <param name="name"><span data-ttu-id="395a1-173">如果要与其他进程共享同步对象，则为名称；否则为 <see langword="null" /> 或空字符串。</span><span class="sxs-lookup"><span data-stu-id="395a1-173">The name, if the synchronization object is to be shared with other processes; otherwise, <see langword="null" /> or an empty string.</span></span> <span data-ttu-id="395a1-174">该名称区分大小写。</span><span class="sxs-lookup"><span data-stu-id="395a1-174">The name is case-sensitive.</span></span></param>
        <summary><span data-ttu-id="395a1-175">使用 Boolean 值（指示调用线程是否应具有互斥体的初始所有权以及字符串是否为互斥体的名称）初始化 <see cref="T:System.Threading.Mutex" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="395a1-175">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="395a1-176">`name`可以使用 `Global\` 或前缀 `Local\` 来指定命名空间。</span><span class="sxs-lookup"><span data-stu-id="395a1-176">The `name` may be prefixed with `Global\` or `Local\` to specify a namespace.</span></span> <span data-ttu-id="395a1-177">如果 `Global` 指定了命名空间，则同步对象可能与系统上的任何进程共享。</span><span class="sxs-lookup"><span data-stu-id="395a1-177">When the `Global` namespace is specified, the synchronization object may be shared with any processes on the system.</span></span> <span data-ttu-id="395a1-178">`Local`指定命名空间后，如果未指定命名空间，这也是默认命名空间，则同步对象可能与同一会话中的进程共享。</span><span class="sxs-lookup"><span data-stu-id="395a1-178">When the `Local` namespace is specified, which is also the default when no namespace is specified, the synchronization object may be shared with processes in the same session.</span></span> <span data-ttu-id="395a1-179">在 Windows 上，会话是一个登录会话，服务通常在不同的非交互式会话中运行。</span><span class="sxs-lookup"><span data-stu-id="395a1-179">On Windows, a session is a login session, and services typically run in a different non-interactive session.</span></span> <span data-ttu-id="395a1-180">在类似 Unix 的操作系统上，每个 shell 都有自己的会话。</span><span class="sxs-lookup"><span data-stu-id="395a1-180">On Unix-like operating systems, each shell has its own session.</span></span> <span data-ttu-id="395a1-181">会话本地同步对象可能适用于具有父/子关系的进程之间的同步，它们全都在同一会话中运行。</span><span class="sxs-lookup"><span data-stu-id="395a1-181">Session-local synchronization objects may be appropriate for synchronizing between processes with a parent/child relationship where they all run in the same session.</span></span> <span data-ttu-id="395a1-182">有关 Windows 上的 synchornization 对象名称的详细信息，请参阅 [对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。</span><span class="sxs-lookup"><span data-stu-id="395a1-182">For more information about synchornization object names on Windows, see [Object Names](https://docs.microsoft.com/windows/win32/sync/object-names).</span></span>

 <span data-ttu-id="395a1-183">如果提供了， `name` 并且命名空间中已存在请求类型的同步对象，则使用现有的同步对象。</span><span class="sxs-lookup"><span data-stu-id="395a1-183">If a `name` is provided and a synchronization object of the requested type already exists in the namespace, the existing synchronization object is used.</span></span> <span data-ttu-id="395a1-184">如果命名空间中已存在另一个类型的同步对象， `WaitHandleCannotBeOpenedException` 则会引发。</span><span class="sxs-lookup"><span data-stu-id="395a1-184">If a synchronization object of a different type already exists in the namespace, a `WaitHandleCannotBeOpenedException` is thrown.</span></span> <span data-ttu-id="395a1-185">否则，将创建一个新的同步对象。</span><span class="sxs-lookup"><span data-stu-id="395a1-185">Otherwise, a new synchronization object is created.</span></span>

 <span data-ttu-id="395a1-186">如果不 `name` 为 `null` `initiallyOwned` ，并且为，则 `true` 只有当命名系统 mutex 作为此调用的结果而创建时，调用线程才拥有互斥体。</span><span class="sxs-lookup"><span data-stu-id="395a1-186">If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the mutex only if the named system mutex was created as a result of this call.</span></span> <span data-ttu-id="395a1-187">由于没有用于确定是否已创建命名系统 mutex 的机制，因此最好指定 `false` `initiallyOwned` 何时调用此构造函数重载。</span><span class="sxs-lookup"><span data-stu-id="395a1-187">Since there is no mechanism for determining whether the named system mutex was created, it is better to specify `false` for `initiallyOwned` when calling this constructor overload.</span></span> <span data-ttu-id="395a1-188"><xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29>如果需要确定初始所有权，可以使用构造函数。</span><span class="sxs-lookup"><span data-stu-id="395a1-188">You can use the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> constructor if you need to determine initial ownership.</span></span>  
  
 <span data-ttu-id="395a1-189">此构造函数初始化 <xref:System.Threading.Mutex> 对象，该对象表示已命名的系统互斥体。</span><span class="sxs-lookup"><span data-stu-id="395a1-189">This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex.</span></span> <span data-ttu-id="395a1-190">可以创建多个 <xref:System.Threading.Mutex> 表示同一命名系统 mutex 的对象。</span><span class="sxs-lookup"><span data-stu-id="395a1-190">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="395a1-191">如果已使用访问控制安全性创建了已命名的 mutex 并且调用方没有 <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> ，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="395a1-191">If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="395a1-192">若要使用只同步线程活动所需的权限打开现有的已命名 mutex，请参见 <xref:System.Threading.Mutex.OpenExisting%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="395a1-192">To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.</span></span>  
  
 <span data-ttu-id="395a1-193">如果为指定 `null` 或空字符串，则将 `name` 创建本地 mutex，就像您已调用 <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> 构造函数一样。</span><span class="sxs-lookup"><span data-stu-id="395a1-193">If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span></span> <span data-ttu-id="395a1-194">在此示例中， `createdNew` 始终为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="395a1-194">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="395a1-195">由于它们是系统范围的，因此可以使用命名的 mutex 跨进程边界协调资源使用。</span><span class="sxs-lookup"><span data-stu-id="395a1-195">Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="395a1-196">在运行终端服务的服务器上，命名系统 mutex 可以有两个级别的可见性。</span><span class="sxs-lookup"><span data-stu-id="395a1-196">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="395a1-197">如果其名称以前缀 "Global" 开头 \\ ，则 mutex 在所有终端服务器会话中可见。</span><span class="sxs-lookup"><span data-stu-id="395a1-197">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="395a1-198">如果其名称以前缀 "Local" 开头 \\ ，则 mutex 仅在创建它的终端服务器会话中可见。</span><span class="sxs-lookup"><span data-stu-id="395a1-198">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="395a1-199">在这种情况下，可以在服务器上的其他每个终端服务器会话中存在具有相同名称的单独 mutex。</span><span class="sxs-lookup"><span data-stu-id="395a1-199">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="395a1-200">如果在创建已命名的 mutex 时未指定前缀，则采用前缀 "Local \\ "。</span><span class="sxs-lookup"><span data-stu-id="395a1-200">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="395a1-201">在终端服务器会话中，两个互斥体的名称只是它们的前缀不同，它们都是对终端服务器会话中的所有进程都可见。</span><span class="sxs-lookup"><span data-stu-id="395a1-201">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="395a1-202">也就是说，前缀名称 "Global \\ " 和 "Local \\ " 描述互斥体名称相对于终端服务器会话的作用域，而不是相对于进程。</span><span class="sxs-lookup"><span data-stu-id="395a1-202">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 <span data-ttu-id="395a1-203">下面的示例演示如何使用命名 mutex 在两个不同的进程中运行的线程之间发出信号。</span><span class="sxs-lookup"><span data-stu-id="395a1-203">The following example shows how a named mutex is used to signal between threads running in two separate processes.</span></span>  
  
 <span data-ttu-id="395a1-204">从两个或更多命令窗口中运行该程序。</span><span class="sxs-lookup"><span data-stu-id="395a1-204">Run this program from two or more command windows.</span></span> <span data-ttu-id="395a1-205">每个进程创建一个 <xref:System.Threading.Mutex> 对象，该对象表示已命名的互斥体 `MyMutex` 。</span><span class="sxs-lookup"><span data-stu-id="395a1-205">Each process creates a <xref:System.Threading.Mutex> object that represents the named mutex `MyMutex`.</span></span> <span data-ttu-id="395a1-206">命名的 mutex 是一个系统对象，其生存期由表示它的对象的生存期界定 <xref:System.Threading.Mutex> 。</span><span class="sxs-lookup"><span data-stu-id="395a1-206">The named mutex is a system object whose lifetime is bounded by the lifetimes of the <xref:System.Threading.Mutex> objects that represent it.</span></span> <span data-ttu-id="395a1-207">已命名的互斥体是在第一个进程创建其对象时创建的 <xref:System.Threading.Mutex> ; 在此示例中，已命名的互斥体由运行该程序的第一个进程拥有。</span><span class="sxs-lookup"><span data-stu-id="395a1-207">The named mutex is created when the first process creates its <xref:System.Threading.Mutex> object; in this example, the named mutex is owned by the first process that runs the program.</span></span> <span data-ttu-id="395a1-208">如果 <xref:System.Threading.Mutex> 已释放所有表示它的对象，则会销毁该命名互斥体。</span><span class="sxs-lookup"><span data-stu-id="395a1-208">The named mutex is destroyed when all the <xref:System.Threading.Mutex> objects that represent it have been released.</span></span>  
  
 <span data-ttu-id="395a1-209">在此示例中使用的构造函数重载不能告知调用线程是否已授予命名 mutex 的初始所有权。</span><span class="sxs-lookup"><span data-stu-id="395a1-209">The constructor overload used in this example cannot tell the calling thread whether initial ownership of the named mutex was granted.</span></span> <span data-ttu-id="395a1-210">不应使用此构造函数来请求初始所有权，除非可以确定该线程将创建已命名的互斥体。</span><span class="sxs-lookup"><span data-stu-id="395a1-210">You should not use this constructor to request initial ownership unless you can be certain that the thread will create the named mutex.</span></span>  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="395a1-211">命名互斥体存在且具有访问控制安全性，但用户不具备 <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />。</span><span class="sxs-lookup"><span data-stu-id="395a1-211">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="395a1-212"><paramref name="name" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="395a1-212"><paramref name="name" /> is invalid.</span></span> <span data-ttu-id="395a1-213">导致这种情况的原因有很多，包括操作系统可能会施加的一些限制，例如未知前缀或无效字符。</span><span class="sxs-lookup"><span data-stu-id="395a1-213">This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters.</span></span> <span data-ttu-id="395a1-214">请注意，名称和常见前缀 "Global\" 和 "Local\" 区分大小写。</span><span class="sxs-lookup"><span data-stu-id="395a1-214">Note that the name and common prefixes "Global\" and "Local\" are case-sensitive.</span></span>

<span data-ttu-id="395a1-215">或</span><span class="sxs-lookup"><span data-stu-id="395a1-215">-or-</span></span>

<span data-ttu-id="395a1-216">存在其他错误。</span><span class="sxs-lookup"><span data-stu-id="395a1-216">There was some other error.</span></span> <span data-ttu-id="395a1-217">`HResult` 属性可能提供更多信息。</span><span class="sxs-lookup"><span data-stu-id="395a1-217">The `HResult` property may provide more information.</span></span></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><span data-ttu-id="395a1-218">仅限 Windows：<paramref name="name" /> 指定了未知命名空间。</span><span class="sxs-lookup"><span data-stu-id="395a1-218">Windows only: <paramref name="name" /> specified an unknown namespace.</span></span> <span data-ttu-id="395a1-219">有关详细信息，请参阅[对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。</span><span class="sxs-lookup"><span data-stu-id="395a1-219">See [Object Names](https://docs.microsoft.com/windows/win32/sync/object-names) for more information.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="395a1-220"><paramref name="name" /> 太长。</span><span class="sxs-lookup"><span data-stu-id="395a1-220">The <paramref name="name" /> is too long.</span></span> <span data-ttu-id="395a1-221">长度限制可能取决于操作系统或配置。</span><span class="sxs-lookup"><span data-stu-id="395a1-221">Length restrictions may depend on the operating system or configuration.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="395a1-222">无法创建具有提供的 <paramref name="name" /> 的同步对象。</span><span class="sxs-lookup"><span data-stu-id="395a1-222">A synchronization object with the provided <paramref name="name" /> cannot be created.</span></span> <span data-ttu-id="395a1-223">不同类型的同步对象可能具有相同的名称。</span><span class="sxs-lookup"><span data-stu-id="395a1-223">A synchronization object of a different type might have the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="395a1-224">仅限 .NET Framework：<paramref name="name" /> 的长度超过 MAX_PATH（260 个字符）。</span><span class="sxs-lookup"><span data-stu-id="395a1-224">.NET Framework only: <paramref name="name" /> is longer than MAX_PATH (260 characters).</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="395a1-225">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="395a1-225">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/mutexes"><span data-ttu-id="395a1-226">Mutexes</span><span class="sxs-lookup"><span data-stu-id="395a1-226">Mutexes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string * bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew)" />
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string? name, out bool? createdNew);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><span data-ttu-id="395a1-227">如果为 <see langword="true" />，则给予调用线程已命名的系统互斥体的初始所属权（如果已命名的系统互斥体是通过此调用创建的）；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="395a1-227"><see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</span></span></param>
        <param name="name"><span data-ttu-id="395a1-228">如果要与其他进程共享同步对象，则为名称；否则为 <see langword="null" /> 或空字符串。</span><span class="sxs-lookup"><span data-stu-id="395a1-228">The name, if the synchronization object is to be shared with other processes; otherwise, <see langword="null" /> or an empty string.</span></span> <span data-ttu-id="395a1-229">该名称区分大小写。</span><span class="sxs-lookup"><span data-stu-id="395a1-229">The name is case-sensitive.</span></span></param>
        <param name="createdNew"><span data-ttu-id="395a1-230">在此方法返回时，如果创建了局部互斥体（即，如果 <paramref name="name" /> 为 <see langword="null" /> 或空字符串）或指定的命名系统互斥体，则包含布尔值 <see langword="true" />；如果指定的命名系统互斥体已存在，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="395a1-230">When this method returns, contains a Boolean that is <see langword="true" /> if a local mutex was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system mutex was created; <see langword="false" /> if the specified named system mutex already existed.</span></span> <span data-ttu-id="395a1-231">此参数未经初始化即被传递。</span><span class="sxs-lookup"><span data-stu-id="395a1-231">This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="395a1-232">使用可指示调用线程是否应具有互斥体的初始所有权以及字符串是否为互斥体的名称的 Boolean 值和当线程返回时可指示调用线程是否已赋予互斥体的初始所有权的 Boolean 值初始化 <see cref="T:System.Threading.Mutex" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="395a1-232">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="395a1-233">`name`可以使用 `Global\` 或前缀 `Local\` 来指定命名空间。</span><span class="sxs-lookup"><span data-stu-id="395a1-233">The `name` may be prefixed with `Global\` or `Local\` to specify a namespace.</span></span> <span data-ttu-id="395a1-234">如果 `Global` 指定了命名空间，则同步对象可能与系统上的任何进程共享。</span><span class="sxs-lookup"><span data-stu-id="395a1-234">When the `Global` namespace is specified, the synchronization object may be shared with any processes on the system.</span></span> <span data-ttu-id="395a1-235">`Local`指定命名空间后，如果未指定命名空间，这也是默认命名空间，则同步对象可能与同一会话中的进程共享。</span><span class="sxs-lookup"><span data-stu-id="395a1-235">When the `Local` namespace is specified, which is also the default when no namespace is specified, the synchronization object may be shared with processes in the same session.</span></span> <span data-ttu-id="395a1-236">在 Windows 上，会话是一个登录会话，服务通常在不同的非交互式会话中运行。</span><span class="sxs-lookup"><span data-stu-id="395a1-236">On Windows, a session is a login session, and services typically run in a different non-interactive session.</span></span> <span data-ttu-id="395a1-237">在类似 Unix 的操作系统上，每个 shell 都有自己的会话。</span><span class="sxs-lookup"><span data-stu-id="395a1-237">On Unix-like operating systems, each shell has its own session.</span></span> <span data-ttu-id="395a1-238">会话本地同步对象可能适用于具有父/子关系的进程之间的同步，它们全都在同一会话中运行。</span><span class="sxs-lookup"><span data-stu-id="395a1-238">Session-local synchronization objects may be appropriate for synchronizing between processes with a parent/child relationship where they all run in the same session.</span></span> <span data-ttu-id="395a1-239">有关 Windows 上的 synchornization 对象名称的详细信息，请参阅 [对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。</span><span class="sxs-lookup"><span data-stu-id="395a1-239">For more information about synchornization object names on Windows, see [Object Names](https://docs.microsoft.com/windows/win32/sync/object-names).</span></span>

 <span data-ttu-id="395a1-240">如果提供了， `name` 并且命名空间中已存在请求类型的同步对象，则使用现有的同步对象。</span><span class="sxs-lookup"><span data-stu-id="395a1-240">If a `name` is provided and a synchronization object of the requested type already exists in the namespace, the existing synchronization object is used.</span></span> <span data-ttu-id="395a1-241">如果命名空间中已存在另一个类型的同步对象， `WaitHandleCannotBeOpenedException` 则会引发。</span><span class="sxs-lookup"><span data-stu-id="395a1-241">If a synchronization object of a different type already exists in the namespace, a `WaitHandleCannotBeOpenedException` is thrown.</span></span> <span data-ttu-id="395a1-242">否则，将创建一个新的同步对象。</span><span class="sxs-lookup"><span data-stu-id="395a1-242">Otherwise, a new synchronization object is created.</span></span>

 <span data-ttu-id="395a1-243">如果不 `name` 为， `null` 并且 `initiallyOwned` 为，则只有在 `true` `createdNew` `true` 调用之后，调用线程才拥有已命名的互斥体。</span><span class="sxs-lookup"><span data-stu-id="395a1-243">If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the named mutex only if `createdNew` is `true` after the call.</span></span> <span data-ttu-id="395a1-244">否则，线程可以通过调用方法来请求互斥体 <xref:System.Threading.WaitHandle.WaitOne%2A> 。</span><span class="sxs-lookup"><span data-stu-id="395a1-244">Otherwise the thread can request the mutex by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span>  
  
 <span data-ttu-id="395a1-245">此构造函数初始化 <xref:System.Threading.Mutex> 对象，该对象表示已命名的系统互斥体。</span><span class="sxs-lookup"><span data-stu-id="395a1-245">This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex.</span></span> <span data-ttu-id="395a1-246">可以创建多个 <xref:System.Threading.Mutex> 表示同一命名系统 mutex 的对象。</span><span class="sxs-lookup"><span data-stu-id="395a1-246">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="395a1-247">如果已使用访问控制安全性创建了已命名的 mutex，并且调用方没有 <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> 权限，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="395a1-247">If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> rights, an exception is thrown.</span></span> <span data-ttu-id="395a1-248">若要使用只同步线程活动所需的权限打开现有的已命名 mutex，请参见 <xref:System.Threading.Mutex.OpenExisting%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="395a1-248">To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.</span></span>  
  
 <span data-ttu-id="395a1-249">如果为指定 `null` 或空字符串，则将 `name` 创建本地 mutex，就像您已调用 <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> 构造函数一样。</span><span class="sxs-lookup"><span data-stu-id="395a1-249">If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span></span> <span data-ttu-id="395a1-250">在此示例中， `createdNew` 始终为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="395a1-250">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="395a1-251">由于它们是系统范围的，因此可以使用命名的 mutex 跨进程边界协调资源使用。</span><span class="sxs-lookup"><span data-stu-id="395a1-251">Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="395a1-252">在运行终端服务的服务器上，命名系统 mutex 可以有两个级别的可见性。</span><span class="sxs-lookup"><span data-stu-id="395a1-252">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="395a1-253">如果其名称以前缀 "Global" 开头 \\ ，则 mutex 在所有终端服务器会话中可见。</span><span class="sxs-lookup"><span data-stu-id="395a1-253">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="395a1-254">如果其名称以前缀 "Local" 开头 \\ ，则 mutex 仅在创建它的终端服务器会话中可见。</span><span class="sxs-lookup"><span data-stu-id="395a1-254">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="395a1-255">在这种情况下，可以在服务器上的其他每个终端服务器会话中存在具有相同名称的单独 mutex。</span><span class="sxs-lookup"><span data-stu-id="395a1-255">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="395a1-256">如果在创建已命名的 mutex 时未指定前缀，则采用前缀 "Local \\ "。</span><span class="sxs-lookup"><span data-stu-id="395a1-256">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="395a1-257">在终端服务器会话中，两个互斥体的名称只是它们的前缀不同，它们都是对终端服务器会话中的所有进程都可见。</span><span class="sxs-lookup"><span data-stu-id="395a1-257">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="395a1-258">也就是说，前缀名称 "Global \\ " 和 "Local \\ " 描述互斥体名称相对于终端服务器会话的作用域，而不是相对于进程。</span><span class="sxs-lookup"><span data-stu-id="395a1-258">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 <span data-ttu-id="395a1-259">下面的代码示例演示如何使用已命名的 mutex 在进程或线程之间发出信号。</span><span class="sxs-lookup"><span data-stu-id="395a1-259">The following code example shows how a named mutex is used to signal between processes or threads.</span></span> <span data-ttu-id="395a1-260">从两个或更多命令窗口中运行该程序。</span><span class="sxs-lookup"><span data-stu-id="395a1-260">Run this program from two or more command windows.</span></span> <span data-ttu-id="395a1-261">每个进程都将创建一个 <xref:System.Threading.Mutex> 对象，该对象表示已命名的互斥体 "MyMutex"。</span><span class="sxs-lookup"><span data-stu-id="395a1-261">Each process creates a <xref:System.Threading.Mutex> object that represents the named mutex "MyMutex".</span></span> <span data-ttu-id="395a1-262">命名的 mutex 是系统对象。</span><span class="sxs-lookup"><span data-stu-id="395a1-262">The named mutex is a system object.</span></span> <span data-ttu-id="395a1-263">在此示例中，其生存期由表示它的对象的生存期界定 <xref:System.Threading.Mutex> 。</span><span class="sxs-lookup"><span data-stu-id="395a1-263">In this example, its lifetime is bounded by the lifetimes of the <xref:System.Threading.Mutex> objects that represent it.</span></span> <span data-ttu-id="395a1-264">当第一个进程创建其本地对象时，将创建已命名的 mutex <xref:System.Threading.Mutex> ，并在所有 <xref:System.Threading.Mutex> 表示它的对象被释放时销毁。</span><span class="sxs-lookup"><span data-stu-id="395a1-264">The named mutex is created when the first process creates its local <xref:System.Threading.Mutex> object, and destroyed when all the <xref:System.Threading.Mutex> objects that represent it have been released.</span></span> <span data-ttu-id="395a1-265">命名的 mutex 最初由第一个进程拥有。</span><span class="sxs-lookup"><span data-stu-id="395a1-265">The named mutex is initially owned by the first process.</span></span> <span data-ttu-id="395a1-266">第二个进程和任何后续进程将等待前面的进程释放已命名的互斥体。</span><span class="sxs-lookup"><span data-stu-id="395a1-266">The second process and any subsequent processes wait for earlier processes to release the named mutex.</span></span>  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="395a1-267">命名互斥体存在且具有访问控制安全性，但用户不具备 <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />。</span><span class="sxs-lookup"><span data-stu-id="395a1-267">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="395a1-268"><paramref name="name" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="395a1-268"><paramref name="name" /> is invalid.</span></span> <span data-ttu-id="395a1-269">导致这种情况的原因有很多，包括操作系统可能会施加的一些限制，例如未知前缀或无效字符。</span><span class="sxs-lookup"><span data-stu-id="395a1-269">This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters.</span></span> <span data-ttu-id="395a1-270">请注意，名称和常见前缀 "Global\" 和 "Local\" 区分大小写。</span><span class="sxs-lookup"><span data-stu-id="395a1-270">Note that the name and common prefixes "Global\" and "Local\" are case-sensitive.</span></span>

<span data-ttu-id="395a1-271">或</span><span class="sxs-lookup"><span data-stu-id="395a1-271">-or-</span></span>

<span data-ttu-id="395a1-272">存在其他错误。</span><span class="sxs-lookup"><span data-stu-id="395a1-272">There was some other error.</span></span> <span data-ttu-id="395a1-273">`HResult` 属性可能提供更多信息。</span><span class="sxs-lookup"><span data-stu-id="395a1-273">The `HResult` property may provide more information.</span></span></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><span data-ttu-id="395a1-274">仅限 Windows：<paramref name="name" /> 指定了未知命名空间。</span><span class="sxs-lookup"><span data-stu-id="395a1-274">Windows only: <paramref name="name" /> specified an unknown namespace.</span></span> <span data-ttu-id="395a1-275">有关详细信息，请参阅[对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。</span><span class="sxs-lookup"><span data-stu-id="395a1-275">See [Object Names](https://docs.microsoft.com/windows/win32/sync/object-names) for more information.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="395a1-276"><paramref name="name" /> 太长。</span><span class="sxs-lookup"><span data-stu-id="395a1-276">The <paramref name="name" /> is too long.</span></span> <span data-ttu-id="395a1-277">长度限制可能取决于操作系统或配置。</span><span class="sxs-lookup"><span data-stu-id="395a1-277">Length restrictions may depend on the operating system or configuration.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="395a1-278">无法创建具有提供的 <paramref name="name" /> 的同步对象。</span><span class="sxs-lookup"><span data-stu-id="395a1-278">A synchronization object with the provided <paramref name="name" /> cannot be created.</span></span> <span data-ttu-id="395a1-279">不同类型的同步对象可能具有相同的名称。</span><span class="sxs-lookup"><span data-stu-id="395a1-279">A synchronization object of a different type might have the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="395a1-280">仅限 .NET Framework：<paramref name="name" /> 的长度超过 MAX_PATH（260 个字符）。</span><span class="sxs-lookup"><span data-stu-id="395a1-280">.NET Framework only: <paramref name="name" /> is longer than MAX_PATH (260 characters).</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="395a1-281">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="395a1-281">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/mutexes"><span data-ttu-id="395a1-282">Mutexes</span><span class="sxs-lookup"><span data-stu-id="395a1-282">Mutexes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean, mutexSecurity As MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string * bool * System.Security.AccessControl.MutexSecurity -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew, mutexSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><span data-ttu-id="395a1-283">如果为 <see langword="true" />，则给予调用线程已命名的系统互斥体的初始所属权（如果已命名的系统互斥体是通过此调用创建的）；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="395a1-283"><see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</span></span></param>
        <param name="name"><span data-ttu-id="395a1-284">如果要与其他进程共享同步对象，则为名称；否则为 <see langword="null" /> 或空字符串。</span><span class="sxs-lookup"><span data-stu-id="395a1-284">The name, if the synchronization object is to be shared with other processes; otherwise, <see langword="null" /> or an empty string.</span></span> <span data-ttu-id="395a1-285">该名称区分大小写。</span><span class="sxs-lookup"><span data-stu-id="395a1-285">The name is case-sensitive.</span></span></param>
        <param name="createdNew"><span data-ttu-id="395a1-286">在此方法返回时，如果创建了局部互斥体（即，如果 <paramref name="name" /> 为 <see langword="null" /> 或空字符串）或指定的命名系统互斥体，则包含布尔值 <see langword="true" />；如果指定的命名系统互斥体已存在，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="395a1-286">When this method returns, contains a Boolean that is <see langword="true" /> if a local mutex was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system mutex was created; <see langword="false" /> if the specified named system mutex already existed.</span></span> <span data-ttu-id="395a1-287">此参数未经初始化即被传递。</span><span class="sxs-lookup"><span data-stu-id="395a1-287">This parameter is passed uninitialized.</span></span></param>
        <param name="mutexSecurity"><span data-ttu-id="395a1-288">一个 <see cref="T:System.Security.AccessControl.MutexSecurity" /> 对象，表示应用于已命名的系统互斥体的访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="395a1-288">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security to be applied to the named system mutex.</span></span></param>
        <summary><span data-ttu-id="395a1-289">使用可指示调用线程是否应具有互斥体的初始所有权以及字符串是否为互斥体的名称的 Boolean 值和当线程返回时可指示调用线程是否已赋予互斥体的初始所有权以及访问控制安全是否已应用到命名互斥体的 Boolean 变量初始化 <see cref="T:System.Threading.Mutex" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="395a1-289">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, a Boolean variable that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex, and the access control security to be applied to the named mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="395a1-290">`name`可以使用 `Global\` 或前缀 `Local\` 来指定命名空间。</span><span class="sxs-lookup"><span data-stu-id="395a1-290">The `name` may be prefixed with `Global\` or `Local\` to specify a namespace.</span></span> <span data-ttu-id="395a1-291">如果 `Global` 指定了命名空间，则同步对象可能与系统上的任何进程共享。</span><span class="sxs-lookup"><span data-stu-id="395a1-291">When the `Global` namespace is specified, the synchronization object may be shared with any processes on the system.</span></span> <span data-ttu-id="395a1-292">`Local`指定命名空间后，如果未指定命名空间，这也是默认命名空间，则同步对象可能与同一会话中的进程共享。</span><span class="sxs-lookup"><span data-stu-id="395a1-292">When the `Local` namespace is specified, which is also the default when no namespace is specified, the synchronization object may be shared with processes in the same session.</span></span> <span data-ttu-id="395a1-293">在 Windows 上，会话是一个登录会话，服务通常在不同的非交互式会话中运行。</span><span class="sxs-lookup"><span data-stu-id="395a1-293">On Windows, a session is a login session, and services typically run in a different non-interactive session.</span></span> <span data-ttu-id="395a1-294">在类似 Unix 的操作系统上，每个 shell 都有自己的会话。</span><span class="sxs-lookup"><span data-stu-id="395a1-294">On Unix-like operating systems, each shell has its own session.</span></span> <span data-ttu-id="395a1-295">会话本地同步对象可能适用于具有父/子关系的进程之间的同步，它们全都在同一会话中运行。</span><span class="sxs-lookup"><span data-stu-id="395a1-295">Session-local synchronization objects may be appropriate for synchronizing between processes with a parent/child relationship where they all run in the same session.</span></span> <span data-ttu-id="395a1-296">有关 Windows 上的 synchornization 对象名称的详细信息，请参阅 [对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。</span><span class="sxs-lookup"><span data-stu-id="395a1-296">For more information about synchornization object names on Windows, see [Object Names](https://docs.microsoft.com/windows/win32/sync/object-names).</span></span>

 <span data-ttu-id="395a1-297">如果提供了， `name` 并且命名空间中已存在请求类型的同步对象，则使用现有的同步对象。</span><span class="sxs-lookup"><span data-stu-id="395a1-297">If a `name` is provided and a synchronization object of the requested type already exists in the namespace, the existing synchronization object is used.</span></span> <span data-ttu-id="395a1-298">如果命名空间中已存在另一个类型的同步对象， `WaitHandleCannotBeOpenedException` 则会引发。</span><span class="sxs-lookup"><span data-stu-id="395a1-298">If a synchronization object of a different type already exists in the namespace, a `WaitHandleCannotBeOpenedException` is thrown.</span></span> <span data-ttu-id="395a1-299">否则，将创建一个新的同步对象。</span><span class="sxs-lookup"><span data-stu-id="395a1-299">Otherwise, a new synchronization object is created.</span></span>

 <span data-ttu-id="395a1-300">如果不 `name` 为， `null` 并且 `initiallyOwned` 为，则只有在 `true` `createdNew` `true` 调用之后，调用线程才拥有已命名的互斥体。</span><span class="sxs-lookup"><span data-stu-id="395a1-300">If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the named mutex only if `createdNew` is `true` after the call.</span></span> <span data-ttu-id="395a1-301">否则，线程可以通过调用方法来请求互斥体 <xref:System.Threading.WaitHandle.WaitOne%2A> 。</span><span class="sxs-lookup"><span data-stu-id="395a1-301">Otherwise the thread can request the mutex by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span>  
  
 <span data-ttu-id="395a1-302">使用此构造函数在创建已命名的系统互斥体时对其应用访问控制安全性，防止其他代码控制互斥体。</span><span class="sxs-lookup"><span data-stu-id="395a1-302">Use this constructor to apply access control security to a named system mutex when it is created, preventing other code from taking control of the mutex.</span></span>  
  
 <span data-ttu-id="395a1-303">此构造函数初始化 <xref:System.Threading.Mutex> 对象，该对象表示已命名的系统互斥体。</span><span class="sxs-lookup"><span data-stu-id="395a1-303">This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex.</span></span> <span data-ttu-id="395a1-304">可以创建多个 <xref:System.Threading.Mutex> 表示同一命名系统 mutex 的对象。</span><span class="sxs-lookup"><span data-stu-id="395a1-304">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="395a1-305">如果已命名的系统互斥体不存在，则将使用指定的访问控制安全性来创建它。</span><span class="sxs-lookup"><span data-stu-id="395a1-305">If the named system mutex does not exist, it is created with the specified access control security.</span></span> <span data-ttu-id="395a1-306">如果已命名的互斥体存在，则将忽略指定的访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="395a1-306">If the named mutex exists, the specified access control security is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="395a1-307">调用方对新创建的对象拥有完全控制权， <xref:System.Threading.Mutex> 即使 `mutexSecurity` 拒绝或无法向当前用户授予某些访问权限。</span><span class="sxs-lookup"><span data-stu-id="395a1-307">The caller has full control over the newly created <xref:System.Threading.Mutex> object even if `mutexSecurity` denies or fails to grant some access rights to the current user.</span></span> <span data-ttu-id="395a1-308">但是，如果当前用户尝试 <xref:System.Threading.Mutex> 使用构造函数或方法获取表示相同命名互斥体的另一个对象， <xref:System.Threading.Mutex.OpenExisting%2A> 则会应用 Windows 访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="395a1-308">However, if the current user attempts to get another <xref:System.Threading.Mutex> object to represent the same named mutex, using either a constructor or the <xref:System.Threading.Mutex.OpenExisting%2A> method, Windows access control security is applied.</span></span>  
  
 <span data-ttu-id="395a1-309">如果已使用访问控制安全性创建了已命名的 mutex 并且调用方没有 <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> ，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="395a1-309">If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="395a1-310">若要使用只同步线程活动所需的权限打开现有的已命名 mutex，请参见 <xref:System.Threading.Mutex.OpenExisting%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="395a1-310">To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.</span></span>  
  
 <span data-ttu-id="395a1-311">如果为指定 `null` 或空字符串，则将 `name` 创建本地 mutex，就像您已调用 <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> 构造函数一样。</span><span class="sxs-lookup"><span data-stu-id="395a1-311">If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span></span> <span data-ttu-id="395a1-312">在此示例中， `createdNew` 始终为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="395a1-312">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="395a1-313">由于它们是系统范围的，因此可以使用命名的 mutex 跨进程边界协调资源使用。</span><span class="sxs-lookup"><span data-stu-id="395a1-313">Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="395a1-314">在运行终端服务的服务器上，命名系统 mutex 可以有两个级别的可见性。</span><span class="sxs-lookup"><span data-stu-id="395a1-314">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="395a1-315">如果其名称以前缀 "Global" 开头 \\ ，则 mutex 在所有终端服务器会话中可见。</span><span class="sxs-lookup"><span data-stu-id="395a1-315">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="395a1-316">如果其名称以前缀 "Local" 开头 \\ ，则 mutex 仅在创建它的终端服务器会话中可见。</span><span class="sxs-lookup"><span data-stu-id="395a1-316">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="395a1-317">在这种情况下，可以在服务器上的其他每个终端服务器会话中存在具有相同名称的单独 mutex。</span><span class="sxs-lookup"><span data-stu-id="395a1-317">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="395a1-318">如果在创建已命名的 mutex 时未指定前缀，则采用前缀 "Local \\ "。</span><span class="sxs-lookup"><span data-stu-id="395a1-318">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="395a1-319">在终端服务器会话中，两个互斥体的名称只是它们的前缀不同，它们都是对终端服务器会话中的所有进程都可见。</span><span class="sxs-lookup"><span data-stu-id="395a1-319">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="395a1-320">也就是说，前缀名称 "Global \\ " 和 "Local \\ " 描述互斥体名称相对于终端服务器会话的作用域，而不是相对于进程。</span><span class="sxs-lookup"><span data-stu-id="395a1-320">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 <span data-ttu-id="395a1-321">下面的代码示例演示具有访问控制安全性的已命名 mutex 的跨进程行为。</span><span class="sxs-lookup"><span data-stu-id="395a1-321">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="395a1-322">该示例使用 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 方法重载来测试是否存在已命名的 mutex。</span><span class="sxs-lookup"><span data-stu-id="395a1-322">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="395a1-323">如果互斥体不存在，则将使用初始所有权和访问控制安全性来创建它，这会拒绝当前用户使用互斥体的权限，但会授予读取和更改互斥体权限的权限。</span><span class="sxs-lookup"><span data-stu-id="395a1-323">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="395a1-324">如果从两个命令窗口运行已编译的示例，第二个副本将在调用时引发访问冲突异常 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="395a1-324">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="395a1-325">捕获到异常，该示例使用 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 方法重载，以读取和更改权限所需的权限打开互斥体。</span><span class="sxs-lookup"><span data-stu-id="395a1-325">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="395a1-326">更改权限后，将打开互斥体，其中包含输入和释放该互斥体所需的权限。</span><span class="sxs-lookup"><span data-stu-id="395a1-326">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="395a1-327">如果从第三个命令窗口运行已编译的示例，该示例将使用新的权限运行。</span><span class="sxs-lookup"><span data-stu-id="395a1-327">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="395a1-328"><paramref name="name" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="395a1-328"><paramref name="name" /> is invalid.</span></span> <span data-ttu-id="395a1-329">导致这种情况的原因有很多，包括操作系统可能会施加的一些限制，例如未知前缀或无效字符。</span><span class="sxs-lookup"><span data-stu-id="395a1-329">This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters.</span></span> <span data-ttu-id="395a1-330">请注意，名称和常见前缀 "Global\" 和 "Local\" 区分大小写。</span><span class="sxs-lookup"><span data-stu-id="395a1-330">Note that the name and common prefixes "Global\" and "Local\" are case-sensitive.</span></span>

<span data-ttu-id="395a1-331">或</span><span class="sxs-lookup"><span data-stu-id="395a1-331">-or-</span></span>

<span data-ttu-id="395a1-332">存在其他错误。</span><span class="sxs-lookup"><span data-stu-id="395a1-332">There was some other error.</span></span> <span data-ttu-id="395a1-333">`HResult` 属性可能提供更多信息。</span><span class="sxs-lookup"><span data-stu-id="395a1-333">The `HResult` property may provide more information.</span></span></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><span data-ttu-id="395a1-334">仅限 Windows：<paramref name="name" /> 指定了未知命名空间。</span><span class="sxs-lookup"><span data-stu-id="395a1-334">Windows only: <paramref name="name" /> specified an unknown namespace.</span></span> <span data-ttu-id="395a1-335">有关详细信息，请参阅[对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。</span><span class="sxs-lookup"><span data-stu-id="395a1-335">See [Object Names](https://docs.microsoft.com/windows/win32/sync/object-names) for more information.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="395a1-336"><paramref name="name" /> 太长。</span><span class="sxs-lookup"><span data-stu-id="395a1-336">The <paramref name="name" /> is too long.</span></span> <span data-ttu-id="395a1-337">长度限制可能取决于操作系统或配置。</span><span class="sxs-lookup"><span data-stu-id="395a1-337">Length restrictions may depend on the operating system or configuration.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="395a1-338">命名互斥体存在且具有访问控制安全性，但用户不具备 <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />。</span><span class="sxs-lookup"><span data-stu-id="395a1-338">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="395a1-339">无法创建具有提供的 <paramref name="name" /> 的同步对象。</span><span class="sxs-lookup"><span data-stu-id="395a1-339">A synchronization object with the provided <paramref name="name" /> cannot be created.</span></span> <span data-ttu-id="395a1-340">不同类型的同步对象可能具有相同的名称。</span><span class="sxs-lookup"><span data-stu-id="395a1-340">A synchronization object of a different type might have the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="395a1-341">仅限 .NET Framework：<paramref name="name" /> 的长度超过 MAX_PATH（260 个字符）。</span><span class="sxs-lookup"><span data-stu-id="395a1-341">.NET Framework only: <paramref name="name" /> is longer than MAX_PATH (260 characters).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.MutexSecurity" Usage="mutex.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="395a1-342">获取表示已命名的互斥体的访问控制安全性的 <see cref="T:System.Security.AccessControl.MutexSecurity" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="395a1-342">Gets a <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security for the named mutex.</span></span></summary>
        <returns><span data-ttu-id="395a1-343">表示已命名的互斥体的访问控制安全性的 <see cref="T:System.Security.AccessControl.MutexSecurity" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="395a1-343">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security for the named mutex.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="395a1-344"><xref:System.Threading.Mutex.GetAccessControl%2A>方法使用按位 "或" 运算) 组合 (下面的标志组合来搜索权限： <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType> 、 <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType> 和 <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="395a1-344">The <xref:System.Threading.Mutex.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, and <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="395a1-345">用户必须 <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> 调用此方法，并且必须已使用打开互斥体 <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="395a1-345">The user must have <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> to call this method, and the mutex must have been opened with <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="395a1-346">下面的代码示例演示具有访问控制安全性的已命名 mutex 的跨进程行为。</span><span class="sxs-lookup"><span data-stu-id="395a1-346">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="395a1-347">该示例使用 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 方法重载来测试是否存在已命名的 mutex。</span><span class="sxs-lookup"><span data-stu-id="395a1-347">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="395a1-348">如果互斥体不存在，则将使用初始所有权和访问控制安全性来创建它，这会拒绝当前用户使用互斥体的权限，但会授予读取和更改互斥体权限的权限。</span><span class="sxs-lookup"><span data-stu-id="395a1-348">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="395a1-349">如果从两个命令窗口运行已编译的示例，第二个副本将在调用时引发访问冲突异常 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="395a1-349">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="395a1-350">捕获到异常，该示例使用 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 方法重载，通过使用和方法来打开具有读取和更改权限所需权限的 mutex <xref:System.Threading.Mutex.GetAccessControl%2A> <xref:System.Threading.Mutex.SetAccessControl%2A> 。</span><span class="sxs-lookup"><span data-stu-id="395a1-350">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions, using the <xref:System.Threading.Mutex.GetAccessControl%2A> and <xref:System.Threading.Mutex.SetAccessControl%2A> methods.</span></span>  
  
 <span data-ttu-id="395a1-351">更改权限后，将打开互斥体，其中包含输入和释放该互斥体所需的权限。</span><span class="sxs-lookup"><span data-stu-id="395a1-351">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="395a1-352">如果从第三个命令窗口运行已编译的示例，该示例将使用新的权限运行。</span><span class="sxs-lookup"><span data-stu-id="395a1-352">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="395a1-353">当前 <see cref="T:System.Threading.Mutex" /> 对象表示一个已命名的系统互斥体，但用户不具备 <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />。</span><span class="sxs-lookup"><span data-stu-id="395a1-353">The current <see cref="T:System.Threading.Mutex" /> object represents a named system mutex, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</span></span>  
  
<span data-ttu-id="395a1-354">- 或 -</span><span class="sxs-lookup"><span data-stu-id="395a1-354">-or-</span></span> 
<span data-ttu-id="395a1-355">当前 <see cref="T:System.Threading.Mutex" /> 对象表示一个已命名的系统互斥体，但它未用 <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /> 打开。</span><span class="sxs-lookup"><span data-stu-id="395a1-355">The current <see cref="T:System.Threading.Mutex" /> object represents a named system mutex, and was not opened with <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="395a1-356">不支持 Windows 98 或 Windows Millennium Edition。</span><span class="sxs-lookup"><span data-stu-id="395a1-356">Not supported for Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="395a1-357">打开指定的已命名的互斥体（如果已经存在）。</span><span class="sxs-lookup"><span data-stu-id="395a1-357">Opens a specified named mutex, if it already exists.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="395a1-358">要与其他进程共享的同步对象的名称。</span><span class="sxs-lookup"><span data-stu-id="395a1-358">The name of the synchronization object to be shared with other processes.</span></span> <span data-ttu-id="395a1-359">该名称区分大小写。</span><span class="sxs-lookup"><span data-stu-id="395a1-359">The name is case-sensitive.</span></span></param>
        <summary><span data-ttu-id="395a1-360">打开指定的已命名的互斥体（如果已经存在）。</span><span class="sxs-lookup"><span data-stu-id="395a1-360">Opens the specified named mutex, if it already exists.</span></span></summary>
        <returns><span data-ttu-id="395a1-361">表示已命名的系统互斥体的对象。</span><span class="sxs-lookup"><span data-stu-id="395a1-361">An object that represents the named system mutex.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="395a1-362">`name`可以使用 `Global\` 或前缀 `Local\` 来指定命名空间。</span><span class="sxs-lookup"><span data-stu-id="395a1-362">The `name` may be prefixed with `Global\` or `Local\` to specify a namespace.</span></span> <span data-ttu-id="395a1-363">如果 `Global` 指定了命名空间，则同步对象可能与系统上的任何进程共享。</span><span class="sxs-lookup"><span data-stu-id="395a1-363">When the `Global` namespace is specified, the synchronization object may be shared with any processes on the system.</span></span> <span data-ttu-id="395a1-364">`Local`指定命名空间后，如果未指定命名空间，这也是默认命名空间，则同步对象可能与同一会话中的进程共享。</span><span class="sxs-lookup"><span data-stu-id="395a1-364">When the `Local` namespace is specified, which is also the default when no namespace is specified, the synchronization object may be shared with processes in the same session.</span></span> <span data-ttu-id="395a1-365">在 Windows 上，会话是一个登录会话，服务通常在不同的非交互式会话中运行。</span><span class="sxs-lookup"><span data-stu-id="395a1-365">On Windows, a session is a login session, and services typically run in a different non-interactive session.</span></span> <span data-ttu-id="395a1-366">在类似 Unix 的操作系统上，每个 shell 都有自己的会话。</span><span class="sxs-lookup"><span data-stu-id="395a1-366">On Unix-like operating systems, each shell has its own session.</span></span> <span data-ttu-id="395a1-367">会话本地同步对象可能适用于具有父/子关系的进程之间的同步，它们全都在同一会话中运行。</span><span class="sxs-lookup"><span data-stu-id="395a1-367">Session-local synchronization objects may be appropriate for synchronizing between processes with a parent/child relationship where they all run in the same session.</span></span> <span data-ttu-id="395a1-368">有关 Windows 上的 synchornization 对象名称的详细信息，请参阅 [对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。</span><span class="sxs-lookup"><span data-stu-id="395a1-368">For more information about synchornization object names on Windows, see [Object Names](https://docs.microsoft.com/windows/win32/sync/object-names).</span></span>

 <span data-ttu-id="395a1-369">如果命名空间中存在请求类型的同步对象，则会打开现有的同步对象。</span><span class="sxs-lookup"><span data-stu-id="395a1-369">If a synchronization object of the requested type exists in the namespace, the existing synchronization object is opened.</span></span> <span data-ttu-id="395a1-370">如果命名空间中不存在同步对象，或者命名空间中存在其他类型的同步对象， `WaitHandleCannotBeOpenedException` 则会引发。</span><span class="sxs-lookup"><span data-stu-id="395a1-370">If a synchronization object does not exist in the namespace, or a synchronization object of a different type exists in the namespace, a `WaitHandleCannotBeOpenedException` is thrown.</span></span>

 <span data-ttu-id="395a1-371">此 <xref:System.Threading.Mutex.OpenExisting%2A> 方法尝试打开指定的命名系统互斥体。</span><span class="sxs-lookup"><span data-stu-id="395a1-371">The <xref:System.Threading.Mutex.OpenExisting%2A> method tries to open the specified named system mutex.</span></span> <span data-ttu-id="395a1-372">若要创建不存在的系统互斥体，请使用 <xref:System.Threading.Mutex.%23ctor%2A> 具有参数的构造函数之一 `name` 。</span><span class="sxs-lookup"><span data-stu-id="395a1-372">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="395a1-373">对此方法使用相同值的多个调用 `name` 不一定会返回相同的 <xref:System.Threading.Mutex> 对象，即使返回的对象表示相同的命名系统 mutex。</span><span class="sxs-lookup"><span data-stu-id="395a1-373">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="395a1-374">此方法重载等效于调用 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 方法重载，并 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 使用按位 "或" 运算来指定和权限。</span><span class="sxs-lookup"><span data-stu-id="395a1-374">This method overload is equivalent to calling the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload and specifying <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span>  
  
 <span data-ttu-id="395a1-375">指定标志后， <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> 线程可以等待互斥体，指定 <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 标志允许线程调用 <xref:System.Threading.Mutex.ReleaseMutex%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="395a1-375">Specifying the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the mutex, and specifying the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="395a1-376">此方法不请求 mutex 的所有权。</span><span class="sxs-lookup"><span data-stu-id="395a1-376">This method does not request ownership of the mutex.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="395a1-377">下面的代码示例演示具有访问控制安全性的已命名 mutex 的跨进程行为。</span><span class="sxs-lookup"><span data-stu-id="395a1-377">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="395a1-378">该示例使用 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 方法重载来测试是否存在已命名的 mutex。</span><span class="sxs-lookup"><span data-stu-id="395a1-378">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="395a1-379">如果互斥体不存在，则将使用初始所有权和访问控制安全性来创建它，这会拒绝当前用户使用互斥体的权限，但会授予读取和更改互斥体权限的权限。</span><span class="sxs-lookup"><span data-stu-id="395a1-379">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="395a1-380">如果从两个命令窗口运行已编译的示例，第二个副本将在调用时引发访问冲突异常 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="395a1-380">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="395a1-381">捕获到异常，该示例使用 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 方法重载，以读取和更改权限所需的权限打开互斥体。</span><span class="sxs-lookup"><span data-stu-id="395a1-381">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="395a1-382">更改权限后，将打开互斥体，其中包含输入和释放该互斥体所需的权限。</span><span class="sxs-lookup"><span data-stu-id="395a1-382">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="395a1-383">如果从第三个命令窗口运行已编译的示例，该示例将使用新的权限运行。</span><span class="sxs-lookup"><span data-stu-id="395a1-383">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="395a1-384"><paramref name="name" /> 是一个空字符串。</span><span class="sxs-lookup"><span data-stu-id="395a1-384"><paramref name="name" /> is an empty string.</span></span>

<span data-ttu-id="395a1-385">或</span><span class="sxs-lookup"><span data-stu-id="395a1-385">-or-</span></span>

<span data-ttu-id="395a1-386">仅限 .NET Framework：<paramref name="name" /> 的长度超过 MAX_PATH（260 个字符）。</span><span class="sxs-lookup"><span data-stu-id="395a1-386">.NET Framework only: <paramref name="name" /> is longer than MAX_PATH (260 characters).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="395a1-387"><paramref name="name" /> 上声明的默认值为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="395a1-387"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="395a1-388">无法创建具有提供的 <paramref name="name" /> 的同步对象。</span><span class="sxs-lookup"><span data-stu-id="395a1-388">A synchronization object with the provided <paramref name="name" /> cannot be created.</span></span> <span data-ttu-id="395a1-389">不同类型的同步对象可能具有相同的名称。</span><span class="sxs-lookup"><span data-stu-id="395a1-389">A synchronization object of a different type might have the same name.</span></span> <span data-ttu-id="395a1-390">在某些情况下，对于无效名称，可能会引发此异常。</span><span class="sxs-lookup"><span data-stu-id="395a1-390">In some cases, this exception may be thrown for invalid names.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="395a1-391"><paramref name="name" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="395a1-391"><paramref name="name" /> is invalid.</span></span> <span data-ttu-id="395a1-392">导致这种情况的原因有很多，包括操作系统可能会施加的一些限制，例如未知前缀或无效字符。</span><span class="sxs-lookup"><span data-stu-id="395a1-392">This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters.</span></span> <span data-ttu-id="395a1-393">请注意，名称和常见前缀 "Global\" 和 "Local\" 区分大小写。</span><span class="sxs-lookup"><span data-stu-id="395a1-393">Note that the name and common prefixes "Global\" and "Local\" are case-sensitive.</span></span>

<span data-ttu-id="395a1-394">或</span><span class="sxs-lookup"><span data-stu-id="395a1-394">-or-</span></span>

<span data-ttu-id="395a1-395">存在其他错误。</span><span class="sxs-lookup"><span data-stu-id="395a1-395">There was some other error.</span></span> <span data-ttu-id="395a1-396">`HResult` 属性可能提供更多信息。</span><span class="sxs-lookup"><span data-stu-id="395a1-396">The `HResult` property may provide more information.</span></span></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><span data-ttu-id="395a1-397">仅限 Windows：<paramref name="name" /> 指定了未知命名空间。</span><span class="sxs-lookup"><span data-stu-id="395a1-397">Windows only: <paramref name="name" /> specified an unknown namespace.</span></span> <span data-ttu-id="395a1-398">有关详细信息，请参阅[对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。</span><span class="sxs-lookup"><span data-stu-id="395a1-398">See [Object Names](https://docs.microsoft.com/windows/win32/sync/object-names) for more information.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="395a1-399"><paramref name="name" /> 太长。</span><span class="sxs-lookup"><span data-stu-id="395a1-399">The <paramref name="name" /> is too long.</span></span> <span data-ttu-id="395a1-400">长度限制可能取决于操作系统或配置。</span><span class="sxs-lookup"><span data-stu-id="395a1-400">Length restrictions may depend on the operating system or configuration.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="395a1-401">存在命名的互斥，但用户没有使用它时所需的安全访问权限。</span><span class="sxs-lookup"><span data-stu-id="395a1-401">The named mutex exists, but the user does not have the security access required to use it.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.MutexRights -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="395a1-402">要与其他进程共享的同步对象的名称。</span><span class="sxs-lookup"><span data-stu-id="395a1-402">The name of the synchronization object to be shared with other processes.</span></span> <span data-ttu-id="395a1-403">该名称区分大小写。</span><span class="sxs-lookup"><span data-stu-id="395a1-403">The name is case-sensitive.</span></span></param>
        <param name="rights"><span data-ttu-id="395a1-404">表示所需的安全访问权限的枚举值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="395a1-404">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <summary><span data-ttu-id="395a1-405">用安全访问权限打开指定名称为 mutex（如果已经存在），并返回指示操作是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="395a1-405">Opens the specified named mutex, if it already exists, with the desired security access.</span></span></summary>
        <returns><span data-ttu-id="395a1-406">表示已命名的系统互斥体的对象。</span><span class="sxs-lookup"><span data-stu-id="395a1-406">An object that represents the named system mutex.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="395a1-407">`name`可以使用 `Global\` 或前缀 `Local\` 来指定命名空间。</span><span class="sxs-lookup"><span data-stu-id="395a1-407">The `name` may be prefixed with `Global\` or `Local\` to specify a namespace.</span></span> <span data-ttu-id="395a1-408">如果 `Global` 指定了命名空间，则同步对象可能与系统上的任何进程共享。</span><span class="sxs-lookup"><span data-stu-id="395a1-408">When the `Global` namespace is specified, the synchronization object may be shared with any processes on the system.</span></span> <span data-ttu-id="395a1-409">`Local`指定命名空间后，如果未指定命名空间，这也是默认命名空间，则同步对象可能与同一会话中的进程共享。</span><span class="sxs-lookup"><span data-stu-id="395a1-409">When the `Local` namespace is specified, which is also the default when no namespace is specified, the synchronization object may be shared with processes in the same session.</span></span> <span data-ttu-id="395a1-410">在 Windows 上，会话是一个登录会话，服务通常在不同的非交互式会话中运行。</span><span class="sxs-lookup"><span data-stu-id="395a1-410">On Windows, a session is a login session, and services typically run in a different non-interactive session.</span></span> <span data-ttu-id="395a1-411">在类似 Unix 的操作系统上，每个 shell 都有自己的会话。</span><span class="sxs-lookup"><span data-stu-id="395a1-411">On Unix-like operating systems, each shell has its own session.</span></span> <span data-ttu-id="395a1-412">会话本地同步对象可能适用于具有父/子关系的进程之间的同步，它们全都在同一会话中运行。</span><span class="sxs-lookup"><span data-stu-id="395a1-412">Session-local synchronization objects may be appropriate for synchronizing between processes with a parent/child relationship where they all run in the same session.</span></span> <span data-ttu-id="395a1-413">有关 Windows 上的 synchornization 对象名称的详细信息，请参阅 [对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。</span><span class="sxs-lookup"><span data-stu-id="395a1-413">For more information about synchornization object names on Windows, see [Object Names](https://docs.microsoft.com/windows/win32/sync/object-names).</span></span>

 <span data-ttu-id="395a1-414">如果命名空间中存在请求类型的同步对象，则会打开现有的同步对象。</span><span class="sxs-lookup"><span data-stu-id="395a1-414">If a synchronization object of the requested type exists in the namespace, the existing synchronization object is opened.</span></span> <span data-ttu-id="395a1-415">如果命名空间中不存在同步对象，或者命名空间中存在其他类型的同步对象， `WaitHandleCannotBeOpenedException` 则会引发。</span><span class="sxs-lookup"><span data-stu-id="395a1-415">If a synchronization object does not exist in the namespace, or a synchronization object of a different type exists in the namespace, a `WaitHandleCannotBeOpenedException` is thrown.</span></span>

 <span data-ttu-id="395a1-416">`rights`参数必须包括 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> 允许线程在互斥体上等待的标志，以及 <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 允许线程调用方法的标志 <xref:System.Threading.Mutex.ReleaseMutex%2A> 。</span><span class="sxs-lookup"><span data-stu-id="395a1-416">The `rights` parameter must include the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the mutex, and the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="395a1-417">此 <xref:System.Threading.Mutex.OpenExisting%2A> 方法尝试打开现有的已命名的互斥体。</span><span class="sxs-lookup"><span data-stu-id="395a1-417">The <xref:System.Threading.Mutex.OpenExisting%2A> method tries to open an existing named mutex.</span></span> <span data-ttu-id="395a1-418">若要创建不存在的系统互斥体，请使用 <xref:System.Threading.Mutex.%23ctor%2A> 具有参数的构造函数之一 `name` 。</span><span class="sxs-lookup"><span data-stu-id="395a1-418">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="395a1-419">对此方法使用相同值的多个调用 `name` 不一定会返回相同的 <xref:System.Threading.Mutex> 对象，即使返回的对象表示相同的命名系统 mutex。</span><span class="sxs-lookup"><span data-stu-id="395a1-419">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="395a1-420">此方法不请求 mutex 的所有权。</span><span class="sxs-lookup"><span data-stu-id="395a1-420">This method does not request ownership of the mutex.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="395a1-421">下面的代码示例演示具有访问控制安全性的已命名 mutex 的跨进程行为。</span><span class="sxs-lookup"><span data-stu-id="395a1-421">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="395a1-422">该示例使用 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 方法重载来测试是否存在已命名的 mutex。</span><span class="sxs-lookup"><span data-stu-id="395a1-422">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="395a1-423">如果互斥体不存在，则将使用初始所有权和访问控制安全性来创建它，这会拒绝当前用户使用互斥体的权限，但会授予读取和更改互斥体权限的权限。</span><span class="sxs-lookup"><span data-stu-id="395a1-423">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="395a1-424">如果从两个命令窗口运行已编译的示例，第二个副本将在调用时引发访问冲突异常 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="395a1-424">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="395a1-425">捕获到异常，该示例使用 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 方法重载，以读取和更改权限所需的权限打开互斥体。</span><span class="sxs-lookup"><span data-stu-id="395a1-425">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="395a1-426">更改权限后，将打开互斥体，其中包含输入和释放该互斥体所需的权限。</span><span class="sxs-lookup"><span data-stu-id="395a1-426">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="395a1-427">如果从第三个命令窗口运行已编译的示例，该示例将使用新的权限运行。</span><span class="sxs-lookup"><span data-stu-id="395a1-427">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="395a1-428"><paramref name="name" /> 是一个空字符串。</span><span class="sxs-lookup"><span data-stu-id="395a1-428"><paramref name="name" /> is an empty string.</span></span>

<span data-ttu-id="395a1-429">或</span><span class="sxs-lookup"><span data-stu-id="395a1-429">-or-</span></span>

<span data-ttu-id="395a1-430">仅限 .NET Framework：<paramref name="name" /> 的长度超过 MAX_PATH（260 个字符）。</span><span class="sxs-lookup"><span data-stu-id="395a1-430">.NET Framework only: <paramref name="name" /> is longer than MAX_PATH (260 characters).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="395a1-431"><paramref name="name" /> 上声明的默认值为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="395a1-431"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="395a1-432">无法创建具有提供的 <paramref name="name" /> 的同步对象。</span><span class="sxs-lookup"><span data-stu-id="395a1-432">A synchronization object with the provided <paramref name="name" /> cannot be created.</span></span> <span data-ttu-id="395a1-433">不同类型的同步对象可能具有相同的名称。</span><span class="sxs-lookup"><span data-stu-id="395a1-433">A synchronization object of a different type might have the same name.</span></span> <span data-ttu-id="395a1-434">在某些情况下，对于无效名称，可能会引发此异常。</span><span class="sxs-lookup"><span data-stu-id="395a1-434">In some cases, this exception may be thrown for invalid names.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="395a1-435"><paramref name="name" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="395a1-435"><paramref name="name" /> is invalid.</span></span> <span data-ttu-id="395a1-436">导致这种情况的原因有很多，包括操作系统可能会施加的一些限制，例如未知前缀或无效字符。</span><span class="sxs-lookup"><span data-stu-id="395a1-436">This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters.</span></span> <span data-ttu-id="395a1-437">请注意，名称和常见前缀 "Global\" 和 "Local\" 区分大小写。</span><span class="sxs-lookup"><span data-stu-id="395a1-437">Note that the name and common prefixes "Global\" and "Local\" are case-sensitive.</span></span>

<span data-ttu-id="395a1-438">或</span><span class="sxs-lookup"><span data-stu-id="395a1-438">-or-</span></span>

<span data-ttu-id="395a1-439">存在其他错误。</span><span class="sxs-lookup"><span data-stu-id="395a1-439">There was some other error.</span></span> <span data-ttu-id="395a1-440">`HResult` 属性可能提供更多信息。</span><span class="sxs-lookup"><span data-stu-id="395a1-440">The `HResult` property may provide more information.</span></span></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><span data-ttu-id="395a1-441">仅限 Windows：<paramref name="name" /> 指定了未知命名空间。</span><span class="sxs-lookup"><span data-stu-id="395a1-441">Windows only: <paramref name="name" /> specified an unknown namespace.</span></span> <span data-ttu-id="395a1-442">有关详细信息，请参阅[对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。</span><span class="sxs-lookup"><span data-stu-id="395a1-442">See [Object Names](https://docs.microsoft.com/windows/win32/sync/object-names) for more information.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="395a1-443"><paramref name="name" /> 太长。</span><span class="sxs-lookup"><span data-stu-id="395a1-443">The <paramref name="name" /> is too long.</span></span> <span data-ttu-id="395a1-444">长度限制可能取决于操作系统或配置。</span><span class="sxs-lookup"><span data-stu-id="395a1-444">Length restrictions may depend on the operating system or configuration.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="395a1-445">已命名的 mutex 存在，但是用户不具备所需的安全访问权。</span><span class="sxs-lookup"><span data-stu-id="395a1-445">The named mutex exists, but the user does not have the desired security access.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberSignature Language="F#" Value="member this.ReleaseMutex : unit -&gt; unit" Usage="mutex.ReleaseMutex " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="395a1-446">释放 <see cref="T:System.Threading.Mutex" /> 一次。</span><span class="sxs-lookup"><span data-stu-id="395a1-446">Releases the <see cref="T:System.Threading.Mutex" /> once.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="395a1-447">每当线程获取互斥体时 (例如，通过调用其 <xref:System.Threading.WaitHandle.WaitOne%2A> 方法) ，它必须随后调用 <xref:System.Threading.Mutex.ReleaseMutex%2A> 以放弃互斥体的所有权，并取消阻止其他尝试获取 mutex 所有权的线程。</span><span class="sxs-lookup"><span data-stu-id="395a1-447">Whenever a thread acquires a mutex (for example, by calling its <xref:System.Threading.WaitHandle.WaitOne%2A> method), it must subsequently call <xref:System.Threading.Mutex.ReleaseMutex%2A> to relinquish ownership of the mutex and unblock other threads that are trying to gain ownership of the mutex.</span></span> <span data-ttu-id="395a1-448">如果尝试获取互斥体的所有权失败 (例如，当 <xref:System.Threading.WaitHandle.WaitOne%2A> 使用或参数调用方法时，如果 `millisecondsTimeout` `timeout` `false` 请求超时) ，则该线程 <xref:System.Threading.Mutex.ReleaseMutex%2A> 不应调用，在这种情况下，还应不允许该线程访问由 mutex 保护的资源，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="395a1-448">If the attempt to get ownership of the mutex fails (for example, when a call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method with a `millisecondsTimeout` or a `timeout` parameter returns `false` because the request times out), the thread shouldn't call <xref:System.Threading.Mutex.ReleaseMutex%2A>, In this case, the thread should also not be allowed to access the resource protected by the mutex, as the following example shows.</span></span>  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 <span data-ttu-id="395a1-449">拥有互斥体的线程可以在重复的 wait 函数调用中指定同一互斥体，而不会阻止其执行。</span><span class="sxs-lookup"><span data-stu-id="395a1-449">A thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution.</span></span> <span data-ttu-id="395a1-450">调用次数由公共语言运行时保留。</span><span class="sxs-lookup"><span data-stu-id="395a1-450">The number of calls is kept by the common language runtime.</span></span> <span data-ttu-id="395a1-451">线程必须调用 <xref:System.Threading.Mutex.ReleaseMutex%2A> 相同的次数才能释放互斥体的所有权。</span><span class="sxs-lookup"><span data-stu-id="395a1-451">The thread must call <xref:System.Threading.Mutex.ReleaseMutex%2A> the same number of times to release ownership of the mutex.</span></span>  
  
 <span data-ttu-id="395a1-452">如果线程在拥有互斥体时终止，则会被视为放弃互斥体。</span><span class="sxs-lookup"><span data-stu-id="395a1-452">If a thread terminates while owning a mutex, the mutex is said to be abandoned.</span></span> <span data-ttu-id="395a1-453">Mutex 的状态设置为 "已终止"，下一个等待线程将获得所有权。</span><span class="sxs-lookup"><span data-stu-id="395a1-453">The state of the mutex is set to signaled and the next waiting thread gets ownership.</span></span> <span data-ttu-id="395a1-454">如果没有一个拥有互斥体，则互斥体的状态为 "已终止"。</span><span class="sxs-lookup"><span data-stu-id="395a1-454">If no one owns the mutex, the state of the mutex is signaled.</span></span> <span data-ttu-id="395a1-455">从 .NET Framework 的2.0 版开始，将 <xref:System.Threading.AbandonedMutexException> 在获取互斥体的下一个线程中引发。</span><span class="sxs-lookup"><span data-stu-id="395a1-455">Beginning in version 2.0 of the .NET Framework, an <xref:System.Threading.AbandonedMutexException> is thrown in the next thread that acquires the mutex.</span></span> <span data-ttu-id="395a1-456">在 .NET Framework 2.0 版之前，不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="395a1-456">Prior to version 2.0 of the .NET Framework, no exception was thrown.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="395a1-457">被放弃的 mutex 通常表明代码中存在严重错误。</span><span class="sxs-lookup"><span data-stu-id="395a1-457">An abandoned mutex often indicates a serious error in the code.</span></span> <span data-ttu-id="395a1-458">当线程在不释放 mutex 的情况下退出时，由 mutex 保护的数据结构可能不是一致的状态。</span><span class="sxs-lookup"><span data-stu-id="395a1-458">When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</span></span> <span data-ttu-id="395a1-459">如果可以验证数据结构的完整性，下一个请求 mutex 所有权的线程就可以处理此异常并继续操作。</span><span class="sxs-lookup"><span data-stu-id="395a1-459">The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</span></span>  
  
 <span data-ttu-id="395a1-460">对于系统范围的 mutex，放弃的 mutex 可能指示应用程序已突然终止（例如，通过使用 Windows 任务管理器终止）。</span><span class="sxs-lookup"><span data-stu-id="395a1-460">In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="395a1-461">下面的示例演示如何使用本地 <xref:System.Threading.Mutex> 对象来同步对受保护资源的访问。</span><span class="sxs-lookup"><span data-stu-id="395a1-461">The following example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="395a1-462">创建互斥体的线程最初不负责。</span><span class="sxs-lookup"><span data-stu-id="395a1-462">The thread that creates the mutex does not own it initially.</span></span> <span data-ttu-id="395a1-463"><xref:System.Threading.Mutex.ReleaseMutex%2A>方法用于在不再需要互斥体时释放互斥体。</span><span class="sxs-lookup"><span data-stu-id="395a1-463">The <xref:System.Threading.Mutex.ReleaseMutex%2A> method is used to release the mutex when it is no longer needed.</span></span>  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="395a1-464">调用线程不拥有互斥体。</span><span class="sxs-lookup"><span data-stu-id="395a1-464">The calling thread does not own the mutex.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="395a1-465">已释放当前实例。</span><span class="sxs-lookup"><span data-stu-id="395a1-465">The current instance has already been disposed.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="395a1-466">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="395a1-466">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/mutexes"><span data-ttu-id="395a1-467">Mutexes</span><span class="sxs-lookup"><span data-stu-id="395a1-467">Mutexes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (mutexSecurity As MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.MutexSecurity -&gt; unit" Usage="mutex.SetAccessControl mutexSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity"><span data-ttu-id="395a1-468">一个 <see cref="T:System.Security.AccessControl.MutexSecurity" /> 对象，表示应用于已命名的系统互斥体的访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="395a1-468">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security to be applied to the named system mutex.</span></span></param>
        <summary><span data-ttu-id="395a1-469">设置已命名的系统互斥体的访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="395a1-469">Sets the access control security for a named system mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="395a1-470">用户必须具有 <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> 调用此方法的权限，并且必须使用打开互斥体 <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="395a1-470">The user must have <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> rights to call this method, and the mutex must have been opened with <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="395a1-471">下面的代码示例演示具有访问控制安全性的已命名 mutex 的跨进程行为。</span><span class="sxs-lookup"><span data-stu-id="395a1-471">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="395a1-472">该示例使用 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 方法重载来测试是否存在已命名的 mutex。</span><span class="sxs-lookup"><span data-stu-id="395a1-472">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="395a1-473">如果互斥体不存在，则将使用初始所有权和访问控制安全性来创建它，这会拒绝当前用户使用互斥体的权限，但会授予读取和更改互斥体权限的权限。</span><span class="sxs-lookup"><span data-stu-id="395a1-473">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="395a1-474">如果从两个命令窗口运行已编译的示例，第二个副本将在调用时引发访问冲突异常 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="395a1-474">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="395a1-475">捕获到异常，该示例使用 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 方法重载，通过使用和方法来打开具有读取和更改权限所需权限的 mutex <xref:System.Threading.Mutex.GetAccessControl%2A> <xref:System.Threading.Mutex.SetAccessControl%2A> 。</span><span class="sxs-lookup"><span data-stu-id="395a1-475">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions, using the <xref:System.Threading.Mutex.GetAccessControl%2A> and <xref:System.Threading.Mutex.SetAccessControl%2A> methods.</span></span>  
  
 <span data-ttu-id="395a1-476">更改权限后，将打开互斥体，其中包含输入和释放该互斥体所需的权限。</span><span class="sxs-lookup"><span data-stu-id="395a1-476">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="395a1-477">如果从第三个命令窗口运行已编译的示例，该示例将使用新的权限运行。</span><span class="sxs-lookup"><span data-stu-id="395a1-477">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="395a1-478"><paramref name="mutexSecurity" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="395a1-478"><paramref name="mutexSecurity" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="395a1-479">用户不具备 <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />。</span><span class="sxs-lookup"><span data-stu-id="395a1-479">The user does not have <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</span></span>  
  
<span data-ttu-id="395a1-480">- 或 -</span><span class="sxs-lookup"><span data-stu-id="395a1-480">-or-</span></span> 
<span data-ttu-id="395a1-481">互斥体未用 <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /> 打开。</span><span class="sxs-lookup"><span data-stu-id="395a1-481">The mutex was not opened with <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</span></span></exception>
        <exception cref="T:System.SystemException"><span data-ttu-id="395a1-482">当前 <see cref="T:System.Threading.Mutex" /> 对象不表示已命名的系统互斥体。</span><span class="sxs-lookup"><span data-stu-id="395a1-482">The current <see cref="T:System.Threading.Mutex" /> object does not represent a named system mutex.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="395a1-483">打开指定的已命名的互斥体（如果已经存在），并返回指示操作是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="395a1-483">Opens a specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * Mutex -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, result)" />
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex? result);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="395a1-484">要与其他进程共享的同步对象的名称。</span><span class="sxs-lookup"><span data-stu-id="395a1-484">The name of the synchronization object to be shared with other processes.</span></span> <span data-ttu-id="395a1-485">该名称区分大小写。</span><span class="sxs-lookup"><span data-stu-id="395a1-485">The name is case-sensitive.</span></span></param>
        <param name="result"><span data-ttu-id="395a1-486">当此方法返回时，如果调用成功，则包含表示命名互斥体的 <see cref="T:System.Threading.Mutex" /> 对象；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="395a1-486">When this method returns, contains a <see cref="T:System.Threading.Mutex" /> object that represents the named mutex if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="395a1-487">该参数未经初始化即被处理。</span><span class="sxs-lookup"><span data-stu-id="395a1-487">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="395a1-488">打开指定的已命名的互斥体（如果已经存在），并返回指示操作是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="395a1-488">Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="395a1-489">如果命名互斥体成功打开，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="395a1-489"><see langword="true" /> if the named mutex was opened successfully; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="395a1-490">在某些情况下，对于无效名称，可能会返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="395a1-490">In some cases, <see langword="false" /> may be returned for invalid names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="395a1-491">`name`可以使用 `Global\` 或前缀 `Local\` 来指定命名空间。</span><span class="sxs-lookup"><span data-stu-id="395a1-491">The `name` may be prefixed with `Global\` or `Local\` to specify a namespace.</span></span> <span data-ttu-id="395a1-492">如果 `Global` 指定了命名空间，则同步对象可能与系统上的任何进程共享。</span><span class="sxs-lookup"><span data-stu-id="395a1-492">When the `Global` namespace is specified, the synchronization object may be shared with any processes on the system.</span></span> <span data-ttu-id="395a1-493">`Local`指定命名空间后，如果未指定命名空间，这也是默认命名空间，则同步对象可能与同一会话中的进程共享。</span><span class="sxs-lookup"><span data-stu-id="395a1-493">When the `Local` namespace is specified, which is also the default when no namespace is specified, the synchronization object may be shared with processes in the same session.</span></span> <span data-ttu-id="395a1-494">在 Windows 上，会话是一个登录会话，服务通常在不同的非交互式会话中运行。</span><span class="sxs-lookup"><span data-stu-id="395a1-494">On Windows, a session is a login session, and services typically run in a different non-interactive session.</span></span> <span data-ttu-id="395a1-495">在类似 Unix 的操作系统上，每个 shell 都有自己的会话。</span><span class="sxs-lookup"><span data-stu-id="395a1-495">On Unix-like operating systems, each shell has its own session.</span></span> <span data-ttu-id="395a1-496">会话本地同步对象可能适用于具有父/子关系的进程之间的同步，它们全都在同一会话中运行。</span><span class="sxs-lookup"><span data-stu-id="395a1-496">Session-local synchronization objects may be appropriate for synchronizing between processes with a parent/child relationship where they all run in the same session.</span></span> <span data-ttu-id="395a1-497">有关 Windows 上的 synchornization 对象名称的详细信息，请参阅 [对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。</span><span class="sxs-lookup"><span data-stu-id="395a1-497">For more information about synchornization object names on Windows, see [Object Names](https://docs.microsoft.com/windows/win32/sync/object-names).</span></span>

 <span data-ttu-id="395a1-498">如果命名空间中存在请求类型的同步对象，则会打开现有的同步对象。</span><span class="sxs-lookup"><span data-stu-id="395a1-498">If a synchronization object of the requested type exists in the namespace, the existing synchronization object is opened.</span></span> <span data-ttu-id="395a1-499">如果命名空间中不存在同步对象，或者命名空间中存在其他类型的同步对象， `false` 则返回。</span><span class="sxs-lookup"><span data-stu-id="395a1-499">If a synchronization object does not exist in the namespace, or a synchronization object of a different type exists in the namespace, `false` is returned.</span></span>

 <span data-ttu-id="395a1-500">若要创建不存在的系统互斥体，请使用 <xref:System.Threading.Mutex.%23ctor%2A> 具有参数的构造函数之一 `name` 。</span><span class="sxs-lookup"><span data-stu-id="395a1-500">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="395a1-501">如果不确定是否存在已命名的互斥体，请使用此方法重载，而不是 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 方法重载，这会在互斥体不存在时引发异常。</span><span class="sxs-lookup"><span data-stu-id="395a1-501">If you are uncertain whether a named mutex exists, use this method overload instead of the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload, which throws an exception if the mutex does not exist.</span></span>  
  
 <span data-ttu-id="395a1-502">对此方法使用相同值的多个调用 `name` 不一定会返回相同的 <xref:System.Threading.Mutex> 对象，即使返回的对象表示相同的命名系统 mutex。</span><span class="sxs-lookup"><span data-stu-id="395a1-502">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="395a1-503">此方法重载等效于调用 <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> 方法重载，并 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 使用按位 "或" 运算来指定和权限。</span><span class="sxs-lookup"><span data-stu-id="395a1-503">This method overload is equivalent to calling the <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> method overload and specifying <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span> <span data-ttu-id="395a1-504">指定标志后， <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> 线程可以等待互斥体，指定 <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 标志允许线程调用 <xref:System.Threading.Mutex.ReleaseMutex%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="395a1-504">Specifying the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the mutex, and specifying the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="395a1-505">此方法不请求 mutex 的所有权。</span><span class="sxs-lookup"><span data-stu-id="395a1-505">This method does not request ownership of the mutex.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="395a1-506"><paramref name="name" /> 是一个空字符串。</span><span class="sxs-lookup"><span data-stu-id="395a1-506"><paramref name="name" /> is an empty string.</span></span>

<span data-ttu-id="395a1-507">或</span><span class="sxs-lookup"><span data-stu-id="395a1-507">-or-</span></span>

<span data-ttu-id="395a1-508">仅限 .NET Framework：<paramref name="name" /> 的长度超过 MAX_PATH（260 个字符）。</span><span class="sxs-lookup"><span data-stu-id="395a1-508">.NET Framework only: <paramref name="name" /> is longer than MAX_PATH (260 characters).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="395a1-509"><paramref name="name" /> 上声明的默认值为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="395a1-509"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="395a1-510"><paramref name="name" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="395a1-510"><paramref name="name" /> is invalid.</span></span> <span data-ttu-id="395a1-511">导致这种情况的原因有很多，包括操作系统可能会施加的一些限制，例如未知前缀或无效字符。</span><span class="sxs-lookup"><span data-stu-id="395a1-511">This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters.</span></span> <span data-ttu-id="395a1-512">请注意，名称和常见前缀 "Global\" 和 "Local\" 区分大小写。</span><span class="sxs-lookup"><span data-stu-id="395a1-512">Note that the name and common prefixes "Global\" and "Local\" are case-sensitive.</span></span> <span data-ttu-id="395a1-513">对于某些无效名称，该方法可能返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="395a1-513">For some invalid names, the method may return <see langword="false" /> instead.</span></span>

<span data-ttu-id="395a1-514">或</span><span class="sxs-lookup"><span data-stu-id="395a1-514">-or-</span></span>

<span data-ttu-id="395a1-515">存在其他错误。</span><span class="sxs-lookup"><span data-stu-id="395a1-515">There was some other error.</span></span> <span data-ttu-id="395a1-516">`HResult` 属性可能提供更多信息。</span><span class="sxs-lookup"><span data-stu-id="395a1-516">The `HResult` property may provide more information.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="395a1-517"><paramref name="name" /> 太长。</span><span class="sxs-lookup"><span data-stu-id="395a1-517">The <paramref name="name" /> is too long.</span></span> <span data-ttu-id="395a1-518">长度限制可能取决于操作系统或配置。</span><span class="sxs-lookup"><span data-stu-id="395a1-518">Length restrictions may depend on the operating system or configuration.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="395a1-519">存在命名的互斥，但用户没有使用它时所需的安全访问权限。</span><span class="sxs-lookup"><span data-stu-id="395a1-519">The named mutex exists, but the user does not have the security access required to use it.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.MutexRights * Mutex -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="395a1-520">要与其他进程共享的同步对象的名称。</span><span class="sxs-lookup"><span data-stu-id="395a1-520">The name of the synchronization object to be shared with other processes.</span></span> <span data-ttu-id="395a1-521">该名称区分大小写。</span><span class="sxs-lookup"><span data-stu-id="395a1-521">The name is case-sensitive.</span></span></param>
        <param name="rights"><span data-ttu-id="395a1-522">表示所需的安全访问权限的枚举值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="395a1-522">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <param name="result"><span data-ttu-id="395a1-523">当此方法返回时，如果调用成功，则包含表示命名互斥体的 <see cref="T:System.Threading.Mutex" /> 对象；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="395a1-523">When this method returns, contains a <see cref="T:System.Threading.Mutex" /> object that represents the named mutex if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="395a1-524">该参数未经初始化即被处理。</span><span class="sxs-lookup"><span data-stu-id="395a1-524">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="395a1-525">利用所需的安全访问权限，打开指定的已命名的互斥体（如果已经存在），并返回指示操作是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="395a1-525">Opens the specified named mutex, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="395a1-526">如果命名互斥体成功打开，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="395a1-526"><see langword="true" /> if the named mutex was opened successfully; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="395a1-527">在某些情况下，对于无效名称，可能会返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="395a1-527">In some cases, <see langword="false" /> may be returned for invalid names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="395a1-528">`name`可以使用 `Global\` 或前缀 `Local\` 来指定命名空间。</span><span class="sxs-lookup"><span data-stu-id="395a1-528">The `name` may be prefixed with `Global\` or `Local\` to specify a namespace.</span></span> <span data-ttu-id="395a1-529">如果 `Global` 指定了命名空间，则同步对象可能与系统上的任何进程共享。</span><span class="sxs-lookup"><span data-stu-id="395a1-529">When the `Global` namespace is specified, the synchronization object may be shared with any processes on the system.</span></span> <span data-ttu-id="395a1-530">`Local`指定命名空间后，如果未指定命名空间，这也是默认命名空间，则同步对象可能与同一会话中的进程共享。</span><span class="sxs-lookup"><span data-stu-id="395a1-530">When the `Local` namespace is specified, which is also the default when no namespace is specified, the synchronization object may be shared with processes in the same session.</span></span> <span data-ttu-id="395a1-531">在 Windows 上，会话是一个登录会话，服务通常在不同的非交互式会话中运行。</span><span class="sxs-lookup"><span data-stu-id="395a1-531">On Windows, a session is a login session, and services typically run in a different non-interactive session.</span></span> <span data-ttu-id="395a1-532">在类似 Unix 的操作系统上，每个 shell 都有自己的会话。</span><span class="sxs-lookup"><span data-stu-id="395a1-532">On Unix-like operating systems, each shell has its own session.</span></span> <span data-ttu-id="395a1-533">会话本地同步对象可能适用于具有父/子关系的进程之间的同步，它们全都在同一会话中运行。</span><span class="sxs-lookup"><span data-stu-id="395a1-533">Session-local synchronization objects may be appropriate for synchronizing between processes with a parent/child relationship where they all run in the same session.</span></span> <span data-ttu-id="395a1-534">有关 Windows 上的 synchornization 对象名称的详细信息，请参阅 [对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。</span><span class="sxs-lookup"><span data-stu-id="395a1-534">For more information about synchornization object names on Windows, see [Object Names](https://docs.microsoft.com/windows/win32/sync/object-names).</span></span>

 <span data-ttu-id="395a1-535">如果命名空间中存在请求类型的同步对象，则会打开现有的同步对象。</span><span class="sxs-lookup"><span data-stu-id="395a1-535">If a synchronization object of the requested type exists in the namespace, the existing synchronization object is opened.</span></span> <span data-ttu-id="395a1-536">如果命名空间中不存在同步对象，或者命名空间中存在其他类型的同步对象， `false` 则返回。</span><span class="sxs-lookup"><span data-stu-id="395a1-536">If a synchronization object does not exist in the namespace, or a synchronization object of a different type exists in the namespace, `false` is returned.</span></span>

 <span data-ttu-id="395a1-537">若要创建不存在的系统互斥体，请使用 <xref:System.Threading.Mutex.%23ctor%2A> 具有参数的构造函数之一 `name` 。</span><span class="sxs-lookup"><span data-stu-id="395a1-537">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="395a1-538">如果不确定是否存在已命名的互斥体，请使用此方法重载，而不是 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 方法重载，这会在互斥体不存在时引发异常。</span><span class="sxs-lookup"><span data-stu-id="395a1-538">If you are uncertain whether a named mutex exists, use this method overload instead of the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload, which throws an exception if the mutex does not exist.</span></span>  
  
 <span data-ttu-id="395a1-539">`rights`参数必须包括 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> 允许线程在互斥体上等待的标志，以及 <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 允许线程调用方法的标志 <xref:System.Threading.Mutex.ReleaseMutex%2A> 。</span><span class="sxs-lookup"><span data-stu-id="395a1-539">The `rights` parameter must include the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the mutex, and the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="395a1-540">对此方法使用相同值的多个调用 `name` 不一定会返回相同的 <xref:System.Threading.Mutex> 对象，即使返回的对象表示相同的命名系统 mutex。</span><span class="sxs-lookup"><span data-stu-id="395a1-540">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="395a1-541">此方法不请求 mutex 的所有权。</span><span class="sxs-lookup"><span data-stu-id="395a1-541">This method does not request ownership of the mutex.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="395a1-542"><paramref name="name" /> 是一个空字符串。</span><span class="sxs-lookup"><span data-stu-id="395a1-542"><paramref name="name" /> is an empty string.</span></span>

<span data-ttu-id="395a1-543">或</span><span class="sxs-lookup"><span data-stu-id="395a1-543">-or-</span></span>

<span data-ttu-id="395a1-544">仅限 .NET Framework：<paramref name="name" /> 的长度超过 MAX_PATH（260 个字符）。</span><span class="sxs-lookup"><span data-stu-id="395a1-544">.NET Framework only: <paramref name="name" /> is longer than MAX_PATH (260 characters).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="395a1-545"><paramref name="name" /> 上声明的默认值为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="395a1-545"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="395a1-546"><paramref name="name" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="395a1-546"><paramref name="name" /> is invalid.</span></span> <span data-ttu-id="395a1-547">导致这种情况的原因有很多，包括操作系统可能会施加的一些限制，例如未知前缀或无效字符。</span><span class="sxs-lookup"><span data-stu-id="395a1-547">This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters.</span></span> <span data-ttu-id="395a1-548">请注意，名称和常见前缀 "Global\" 和 "Local\" 区分大小写。</span><span class="sxs-lookup"><span data-stu-id="395a1-548">Note that the name and common prefixes "Global\" and "Local\" are case-sensitive.</span></span> <span data-ttu-id="395a1-549">对于某些无效名称，该方法可能返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="395a1-549">For some invalid names, the method may return <see langword="false" /> instead.</span></span>

<span data-ttu-id="395a1-550">或</span><span class="sxs-lookup"><span data-stu-id="395a1-550">-or-</span></span>

<span data-ttu-id="395a1-551">存在其他错误。</span><span class="sxs-lookup"><span data-stu-id="395a1-551">There was some other error.</span></span> <span data-ttu-id="395a1-552">`HResult` 属性可能提供更多信息。</span><span class="sxs-lookup"><span data-stu-id="395a1-552">The `HResult` property may provide more information.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="395a1-553"><paramref name="name" /> 太长。</span><span class="sxs-lookup"><span data-stu-id="395a1-553">The <paramref name="name" /> is too long.</span></span> <span data-ttu-id="395a1-554">长度限制可能取决于操作系统或配置。</span><span class="sxs-lookup"><span data-stu-id="395a1-554">Length restrictions may depend on the operating system or configuration.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="395a1-555">存在命名的互斥，但用户没有使用它时所需的安全访问权限。</span><span class="sxs-lookup"><span data-stu-id="395a1-555">The named mutex exists, but the user does not have the security access required to use it.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
