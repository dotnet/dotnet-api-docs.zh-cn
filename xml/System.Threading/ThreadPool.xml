<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7fc6756a84213dc83680705176195a87a57738e0" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82404625" /></Metadata><TypeSignature Language="C#" Value="public static class ThreadPool" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <TypeSignature Language="C#" Value="public sealed class ThreadPool" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ThreadPool extends System.Object" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ThreadPool" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool sealed" FrameworkAlternate="netframework-1.1" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="ee9c8-101">提供一个线程池，该线程池可用于执行任务、发送工作项、处理异步 I/O、代表其他线程等待以及处理计时器。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-101">Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I/O, wait on behalf of other threads, and process timers.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee9c8-102">许多应用程序创建线程，在休眠状态中花费大量时间等待事件发生。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-102">Many applications create threads that spend a great deal of time in the sleeping state, waiting for an event to occur.</span></span> <span data-ttu-id="ee9c8-103">其他线程可能会进入休眠状态，只需要定期唤醒才能轮询更改或更新状态信息。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-103">Other threads might enter a sleeping state only to be awakened periodically to poll for a change or update status information.</span></span> <span data-ttu-id="ee9c8-104">使用线程池，可以通过向应用程序提供由系统管理的工作线程池，来更有效地使用线程。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-104">The thread pool enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system.</span></span> <span data-ttu-id="ee9c8-105">使用线程池线程的操作示例包括：</span><span class="sxs-lookup"><span data-stu-id="ee9c8-105">Examples of operations that use thread pool threads include the following:</span></span>  
  
-   <span data-ttu-id="ee9c8-106">创建 <xref:System.Threading.Tasks.Task> 或 <xref:System.Threading.Tasks.Task%601> 对象以异步方式执行某些任务时，默认情况下，任务计划在线程池线程上运行。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-106">When you create a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object to perform some task asynchronously, by default the task is scheduled to run on a thread pool thread.</span></span>  
  
-   <span data-ttu-id="ee9c8-107">异步计时器使用线程池。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-107">Asynchronous timers use the thread pool.</span></span> <span data-ttu-id="ee9c8-108">线程池线程执行来自 <xref:System.Threading.Timer?displayProperty=nameWithType> 类的回调，并引发来自 <xref:System.Timers.Timer?displayProperty=nameWithType> 类的事件。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-108">Thread pool threads execute callbacks from the <xref:System.Threading.Timer?displayProperty=nameWithType> class and raise events from the <xref:System.Timers.Timer?displayProperty=nameWithType> class.</span></span>  
  
-   <span data-ttu-id="ee9c8-109">使用已注册的等待句柄时，系统线程会监视等待句柄的状态。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-109">When you use registered wait handles, a system thread monitors the status of the wait handles.</span></span> <span data-ttu-id="ee9c8-110">等待操作完成后，线程池中的工作线程会执行相应的回调函数。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-110">When a wait operation completes, a worker thread from the thread pool executes the corresponding callback function.</span></span>  
  
-   <span data-ttu-id="ee9c8-111">调用 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> 方法，以便在线程池线程上对要执行的方法进行排队。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-111">When you call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to queue a method for execution on a thread pool thread.</span></span> <span data-ttu-id="ee9c8-112">为此，可将方法传递给 <xref:System.Threading.WaitCallback> 委托。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-112">You do this by passing the method a <xref:System.Threading.WaitCallback> delegate.</span></span>   <span data-ttu-id="ee9c8-113">委托具有签名</span><span class="sxs-lookup"><span data-stu-id="ee9c8-113">The delegate has the signature</span></span>  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     <span data-ttu-id="ee9c8-114">其中 `state` 是包含要由委托使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-114">where `state` is an object that contains data to be used by the delegate.</span></span> <span data-ttu-id="ee9c8-115">可以通过调用 <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> 方法，将实际数据传递到委托。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-115">The actual data can be passed to the delegate by calling the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ee9c8-116">托管线程池中的线程是后台线程。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-116">The threads in the managed thread pool are background threads.</span></span> <span data-ttu-id="ee9c8-117">也就是说，它们的 <xref:System.Threading.Thread.IsBackground%2A> 属性是 `true`的。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-117">That is, their <xref:System.Threading.Thread.IsBackground%2A> properties are `true`.</span></span> <span data-ttu-id="ee9c8-118">这意味着，在所有前台线程退出后，<xref:System.Threading.ThreadPool> 线程不会使应用程序保持运行。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-118">This means that a <xref:System.Threading.ThreadPool> thread will not keep an application running after all foreground threads have exited.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ee9c8-119">当线程池重用某个线程时，它不会清除线程本地存储区中的数据或用 <xref:System.ThreadStaticAttribute> 特性标记的字段中的数据。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-119">When the thread pool reuses a thread, it does not clear the data in thread local storage or in fields that are marked with the <xref:System.ThreadStaticAttribute> attribute.</span></span> <span data-ttu-id="ee9c8-120">因此，当某个方法检查线程本地存储区或用 <xref:System.ThreadStaticAttribute> 特性标记的字段时，它所找到的值可能会从先前使用线程池线程的过程中遗留。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-120">Therefore, when a method examines thread local storage or fields that are marked with the <xref:System.ThreadStaticAttribute> attribute, the values it finds might be left over from an earlier use of the thread pool thread.</span></span>  
  
 <span data-ttu-id="ee9c8-121">你还可以将与等待操作无关的工作项排队到线程池。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-121">You can also queue work items that are not related to a wait operation to the thread pool.</span></span> <span data-ttu-id="ee9c8-122">若要请求由线程池中的线程处理工作项，请调用 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-122">To request that a work item be handled by a thread in the thread pool, call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="ee9c8-123">此方法将引用从线程池中选择的线程调用的方法或委托作为参数。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-123">This method takes as a parameter a reference to the method or delegate that will be called by the thread selected from the thread pool.</span></span> <span data-ttu-id="ee9c8-124">在工作项排队后，无法取消该工作项。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-124">There is no way to cancel a work item after it has been queued.</span></span>  
  
 <span data-ttu-id="ee9c8-125">计时器-队列计时器和已注册的等待操作也使用线程池。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-125">Timer-queue timers and registered wait operations also use the thread pool.</span></span> <span data-ttu-id="ee9c8-126">它们的回调函数将排队到线程池。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-126">Their callback functions are queued to the thread pool.</span></span>  
  
 <span data-ttu-id="ee9c8-127">每个进程都有一个线程池。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-127">There is one thread pool per process.</span></span> <span data-ttu-id="ee9c8-128">从 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 开始，进程的线程池的默认大小取决于若干因素，例如虚拟地址空间的大小。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-128">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space.</span></span> <span data-ttu-id="ee9c8-129">进程可以调用 <xref:System.Threading.ThreadPool.GetMaxThreads%2A> 方法，以确定线程数。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-129">A process can call the <xref:System.Threading.ThreadPool.GetMaxThreads%2A> method to determine the number of threads.</span></span> <span data-ttu-id="ee9c8-130">可以使用 <xref:System.Threading.ThreadPool.SetMaxThreads%2A> 方法更改线程池中的线程数。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-130">The number of threads in the thread pool can be changed by using the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> method.</span></span> <span data-ttu-id="ee9c8-131">每个线程都使用默认堆栈大小，并按默认优先级运行。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-131">Each thread uses the default stack size and runs at the default priority.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ee9c8-132">承载 .NET Framework 的非托管代码可以使用在 mscoree.dll 文件中定义的 `CorSetMaxThreads` 函数更改线程池的大小。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-132">Unmanaged code that hosts the .NET Framework can change the size of the thread pool by using the `CorSetMaxThreads` function, defined in the mscoree.h file.</span></span>  
  
 <span data-ttu-id="ee9c8-133">线程池按需提供新的工作线程或 i/o 完成线程，直到达到每个类别的最大值。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-133">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the maximum for each category.</span></span> <span data-ttu-id="ee9c8-134">达到最大值时，线程池可以在该类别中创建更多的线程，或等待某些任务完成。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-134">When a maximum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="ee9c8-135">从 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 开始，线程池创建和销毁工作线程以优化吞吐量，吞吐量被定义为每个单位时间完成的任务数。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-135">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="ee9c8-136">线程过少可能无法实现可用资源的最优利用，而线程过多则可能增加资源争用。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-136">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ee9c8-137">需求较低时，线程池线程的实际数量可以低于最小值。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-137">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="ee9c8-138">可以使用 <xref:System.Threading.ThreadPool.GetMinThreads%2A> 方法来获取这些最小值。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-138">You can use the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method to obtain these minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ee9c8-139">您可以使用 <xref:System.Threading.ThreadPool.SetMinThreads%2A> 方法来增加最小线程数。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-139">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of threads.</span></span> <span data-ttu-id="ee9c8-140">但是，不必要地增加这些值可能导致性能问题。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-140">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="ee9c8-141">如果在同一时间开始太多的任务，则所有任务均可能会很慢。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-141">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="ee9c8-142">大多数情况下，使用自己的分配线程算法，线程池将更好地执行任务。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-142">In most cases the thread pool will perform better with its own algorithm for allocating threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee9c8-143">在下面的示例中，主应用程序线程会将名为 `ThreadProc` 的方法排队，以便在线程池线程上执行，休眠一秒钟，然后退出。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-143">In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits.</span></span> <span data-ttu-id="ee9c8-144">`ThreadProc` 方法只是显示一条消息。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-144">The `ThreadProc` method simply displays a message.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 <span data-ttu-id="ee9c8-145">如果注释掉对 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 方法的调用，则在线程池线程上运行方法之前，主线程将退出。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-145">If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method, the main thread exits before         method runs on the thread pool thread.</span></span>  <span data-ttu-id="ee9c8-146">线程池使用后台线程，如果所有前台线程均已终止，则不会使应用程序保持运行。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-146">The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.</span></span>  <span data-ttu-id="ee9c8-147">（这是争用条件的一个简单示例。）</span><span class="sxs-lookup"><span data-stu-id="ee9c8-147">(This         is a simple example of a race condition.)</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="ee9c8-148">此类型是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-148">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="ee9c8-149">线程与线程处理</span><span class="sxs-lookup"><span data-stu-id="ee9c8-149">Threads and Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="ee9c8-150">托管线程池</span><span class="sxs-lookup"><span data-stu-id="ee9c8-150">The Managed Thread Pooling</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ee9c8-151">将操作系统句柄绑定到 <see cref="T:System.Threading.ThreadPool" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-151">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="osHandle"><span data-ttu-id="ee9c8-152">持有句柄的 <see cref="T:System.IntPtr" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-152">An <see cref="T:System.IntPtr" /> that holds the handle.</span></span> <span data-ttu-id="ee9c8-153">在非托管端必须为重叠 I/O 打开该句柄。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-153">The handle must have been opened for overlapped I/O on the unmanaged side.</span></span></param>
        <summary><span data-ttu-id="ee9c8-154">将操作系统句柄绑定到 <see cref="T:System.Threading.ThreadPool" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-154">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span></span></summary>
        <returns><span data-ttu-id="ee9c8-155">如果绑定了句柄，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-155"><see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="ee9c8-156">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-156">The caller does not have the required permission.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="osHandle"><span data-ttu-id="ee9c8-157">保存操作系统句柄的 <see cref="T:System.Runtime.InteropServices.SafeHandle" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-157">A <see cref="T:System.Runtime.InteropServices.SafeHandle" /> that holds the operating system handle.</span></span> <span data-ttu-id="ee9c8-158">在非托管端必须为重叠 I/O 打开该句柄。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-158">The handle must have been opened for overlapped I/O on the unmanaged side.</span></span></param>
        <summary><span data-ttu-id="ee9c8-159">将操作系统句柄绑定到 <see cref="T:System.Threading.ThreadPool" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-159">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span></span></summary>
        <returns><span data-ttu-id="ee9c8-160">如果绑定了句柄，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-160"><see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee9c8-161">`osHandle` 参数应是从 abstract <xref:System.Runtime.InteropServices.SafeHandle> 类派生的 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-161">The `osHandle` parameter should be a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, which derives from the abstract <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ee9c8-162"><paramref name="osHandle" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-162"><paramref name="osHandle" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CompletedWorkItemCount">
      <MemberSignature Language="C#" Value="public static long CompletedWorkItemCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 CompletedWorkItemCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.CompletedWorkItemCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompletedWorkItemCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long CompletedWorkItemCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.CompletedWorkItemCount : int64" Usage="System.Threading.ThreadPool.CompletedWorkItemCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ee9c8-163">获取迄今为止已处理的工作项数。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-163">Gets the number of work items that have been processed so far.</span></span></summary>
        <value><span data-ttu-id="ee9c8-164">到目前为止已处理的工作项的数目。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-164">The number of work items that have been processed so far.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

<span data-ttu-id="ee9c8-165">如果线程池实现可能具有不同类型的工作项，则计数将包括所有类型。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-165">If a thread pool implementation may have different types of work items, the count includes all types.</span></span>

        ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads : int * int -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="ee9c8-166">可用辅助线程的数目。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-166">The number of available worker threads.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="ee9c8-167">可用异步 I/O 线程的数目。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-167">The number of available asynchronous I/O threads.</span></span></param>
        <summary><span data-ttu-id="ee9c8-168">检索由 <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> 方法返回的最大线程池线程数和当前活动线程数之间的差值。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-168">Retrieves the difference between the maximum number of thread pool threads returned by the <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> method, and the number currently active.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee9c8-169">当 <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> 返回时，由 `workerThreads` 指定的变量包含可启动的附加工作线程的数目，而 `completionPortThreads` 指定的变量包含可启动的其他异步 i/o 线程的数目。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-169">When <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> returns, the variable specified by `workerThreads` contains the number of additional worker threads that can be started, and the variable specified by `completionPortThreads` contains the number of additional asynchronous I/O threads that can be started.</span></span>  
  
 <span data-ttu-id="ee9c8-170">如果没有可用的线程，附加的线程池请求将保持排队状态，直到线程池线程变为可用。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-170">If there are no available threads, additional thread pool requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee9c8-171">下面的示例显示了启动简单应用时可用的工作线程和 i/o 线程的数目。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-171">The following example displays the number of worker threads and I/O threads available when a simple app is started.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads : int * int -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="ee9c8-172">线程池中辅助线程的最大数目。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-172">The maximum number of worker threads in the thread pool.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="ee9c8-173">线程池中异步 I/O 线程的最大数目。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-173">The maximum number of asynchronous I/O threads in the thread pool.</span></span></param>
        <summary><span data-ttu-id="ee9c8-174">检索可以同时处于活动状态的线程池请求的数目。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-174">Retrieves the number of requests to the thread pool that can be active concurrently.</span></span> <span data-ttu-id="ee9c8-175">所有大于此数目的请求将保持排队状态，直到线程池线程变为可用。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-175">All requests above that number remain queued until thread pool threads become available.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee9c8-176">当 <xref:System.Threading.ThreadPool.GetMaxThreads%2A> 返回时，由 `workerThreads` 指定的变量包含线程池中允许的最大工作线程数，而 `completionPortThreads` 指定的变量包含线程池中允许的最大异步 i/o 线程数。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-176">When <xref:System.Threading.ThreadPool.GetMaxThreads%2A> returns, the variable specified by `workerThreads` contains the maximum number of worker threads allowed in the thread pool, and the variable specified by `completionPortThreads` contains the maximum number of asynchronous I/O threads allowed in the thread pool.</span></span>  
  
 <span data-ttu-id="ee9c8-177">在任何给定时间，都可以使用 <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> 方法来确定线程池中的实际线程数。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-177">You can use the <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> method to determine the actual number of threads in the thread pool at any given time.</span></span>  
  
 <span data-ttu-id="ee9c8-178">您可以使用 <xref:System.Threading.ThreadPool.SetMaxThreads%2A> 设置线程池中的最大工作线程数和异步 i/o 线程数。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-178">You can use the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> to set the maximum number of worker threads and asynchronous I/O threads in the thread pool.</span></span>  
  
 <span data-ttu-id="ee9c8-179">可以将任意数量的线程池请求排队，因为系统内存允许。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-179">You can queue as many thread pool requests as system memory allows.</span></span> <span data-ttu-id="ee9c8-180">如果请求数超过线程池线程数，则在线程池线程变得可用之前，附加请求将保持排队。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-180">If there are more requests than thread pool threads, the additional requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee9c8-181">下面的代码示例演示如何检索线程池中的最大和可用线程数的计数。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-181">The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool.</span></span> <span data-ttu-id="ee9c8-182">工作项排队，使用 `FileStream` 异步写入两个文件。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-182">A work item is queued that uses `FileStream` to asynchronously write to two files.</span></span> <span data-ttu-id="ee9c8-183">回调方法被计时为重叠。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-183">The callback methods are timed to overlap.</span></span> <span data-ttu-id="ee9c8-184">工作线程处理工作项，并根据计算机上的处理器速度和数量，一个或两个完成端口线程处理写入操作。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-184">A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads : int * int -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="ee9c8-185">当此方法返回时，将包含线程池根据需要创建的最少数量的辅助线程。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-185">When this method returns, contains the minimum number of worker threads that the thread pool creates on demand.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="ee9c8-186">当此方法返回时，将包含线程池根据需要创建的最少数量的异步 I/O 线程。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-186">When this method returns, contains the minimum number of asynchronous I/O threads that the thread pool creates on demand.</span></span></param>
        <summary><span data-ttu-id="ee9c8-187">发出新的请求时，在切换到管理线程创建和销毁的算法之前检索线程池按需创建的线程的最小数量。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-187">Retrieves the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee9c8-188">线程池按需提供新的工作线程或 i/o 完成线程，直到达到每个类别的最小值。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-188">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="ee9c8-189">默认情况下，最小线程数设置为系统上的处理器数。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-189">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="ee9c8-190">达到最小值时，线程池可以在该类别中创建更多的线程，或等待某些任务完成。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-190">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="ee9c8-191">从 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]开始，线程池会创建并销毁线程，以优化吞吐量，定义为每个时间单位完成的任务数。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-191">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="ee9c8-192">线程过少可能无法实现可用资源的最优利用，而线程过多则可能增加资源争用。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-192">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ee9c8-193">需求较低时，线程池线程的实际数量可以低于最小值。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-193">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee9c8-194">下面的示例将最小工作线程数设置为4，并保留最小异步 i/o 完成线程数的原始值。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-194">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="PendingWorkItemCount">
      <MemberSignature Language="C#" Value="public static long PendingWorkItemCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 PendingWorkItemCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.PendingWorkItemCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property PendingWorkItemCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long PendingWorkItemCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PendingWorkItemCount : int64" Usage="System.Threading.ThreadPool.PendingWorkItemCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ee9c8-195">获取当前已加入处理队列的工作项数。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-195">Gets the number of work items that are currently queued to be processed.</span></span></summary>
        <value><span data-ttu-id="ee9c8-196">当前排队等候处理的工作项的数目。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-196">The number of work items that are currently queued to be processed.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

<span data-ttu-id="ee9c8-197">如果线程池实现可能具有不同类型的工作项，则计数将包括可以跟踪的所有类型，这些类型只能是用户工作项（包括任务）。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-197">If a thread pool implementation may have different types of work items, the count includes all types that can be tracked, which may only be the user work items, including tasks.</span></span> <span data-ttu-id="ee9c8-198">某些实现可能还包括队列中的计时器和等待回调。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-198">Some implementations may also include queued timer and wait callbacks in the count.</span></span> <span data-ttu-id="ee9c8-199">在 Windows 上，计数不太可能包含挂起的 IO 完成次数，因为它们直接发送到 IO 完成端口。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-199">On Windows, the count is unlikely to include the number of pending IO completions, because they are posted directly to an IO completion port.</span></span>

        ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ee9c8-200">将方法排入队列以便执行。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-200">Queues a method for execution.</span></span> <span data-ttu-id="ee9c8-201">此方法在有线程池线程变得可用时执行。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-201">The method executes when a thread pool thread becomes available.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="ee9c8-202">一个 <see cref="T:System.Threading.WaitCallback" />，表示要执行的方法。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-202">A <see cref="T:System.Threading.WaitCallback" /> that represents the method to be executed.</span></span></param>
        <summary><span data-ttu-id="ee9c8-203">将方法排入队列以便执行。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-203">Queues a method for execution.</span></span> <span data-ttu-id="ee9c8-204">此方法在有线程池线程变得可用时执行。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-204">The method executes when a thread pool thread becomes available.</span></span></summary>
        <returns><span data-ttu-id="ee9c8-205">如果此方法成功排队，则为 <see langword="true" />；如果无法将该工作项排队，则引发 <see cref="T:System.NotSupportedException" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-205"><see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee9c8-206">可以在定义方法的类的实例字段中放置排队方法所需的数据，也可以使用接受包含所需数据的对象的 <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> 重载。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-206">You can place data required by the queued method in the instance fields of the class in which the method is defined, or you can use the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> overload that accepts an object containing the necessary data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ee9c8-207">Visual Basic 用户可以省略 <xref:System.Threading.WaitCallback> 构造函数，只需在将回调方法传递给 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>时使用 `AddressOf` 运算符。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-207">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="ee9c8-208">Visual Basic 自动调用正确的委托构造函数。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-208">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="ee9c8-209">版本信息</span><span class="sxs-lookup"><span data-stu-id="ee9c8-209">Version Information</span></span>  
 <span data-ttu-id="ee9c8-210">在 .NET Framework 版本2.0 中，<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> 属性值将传播到使用 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> 方法排队的工作线程。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-210">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="ee9c8-211">在早期版本中，不传播主体信息。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-211">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee9c8-212">下面的示例使用 <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> 方法重载对任务进行排队，该任务由 `ThreadProc` 方法表示，以便在线程变为可用时执行。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-212">The following example uses the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> method overload to queue a task, which is represented by the `ThreadProc` method, to execute when a thread becomes available.</span></span> <span data-ttu-id="ee9c8-213">此重载未提供任何任务信息。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-213">No task information is supplied with this overload.</span></span> <span data-ttu-id="ee9c8-214">因此，可用于 `ThreadProc` 方法的信息仅限于该方法所属的对象。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-214">Therefore, the information that is available to the `ThreadProc` method is limited to the object the method belongs to.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ee9c8-215"><paramref name="callBack" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-215"><paramref name="callBack" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ee9c8-216">承载公共语言运行时 (CLR) 的宿主不支持此操作。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-216">The common language runtime (CLR) is hosted, and the host does not support this action.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="ee9c8-217">托管线程池</span><span class="sxs-lookup"><span data-stu-id="ee9c8-217">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="ee9c8-218"><see cref="T:System.Threading.WaitCallback" />，它表示要执行的方法。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-218">A <see cref="T:System.Threading.WaitCallback" /> representing the method to execute.</span></span></param>
        <param name="state"><span data-ttu-id="ee9c8-219">包含方法所用数据的对象。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-219">An object containing data to be used by the method.</span></span></param>
        <summary><span data-ttu-id="ee9c8-220">将方法排入队列以便执行，并指定包含该方法所用数据的对象。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-220">Queues a method for execution, and specifies an object containing data to be used by the method.</span></span> <span data-ttu-id="ee9c8-221">此方法在有线程池线程变得可用时执行。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-221">The method executes when a thread pool thread becomes available.</span></span></summary>
        <returns><span data-ttu-id="ee9c8-222">如果此方法成功排队，则为 <see langword="true" />；如果无法将该工作项排队，则引发 <see cref="T:System.NotSupportedException" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-222"><see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee9c8-223">如果回调方法需要复杂数据，则可以定义一个包含数据的类。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-223">If the callback method requires complex data, you can define a class to contain the data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ee9c8-224">Visual Basic 用户可以省略 <xref:System.Threading.WaitCallback> 构造函数，只需在将回调方法传递给 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>时使用 `AddressOf` 运算符。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-224">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="ee9c8-225">Visual Basic 自动调用正确的委托构造函数。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-225">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="ee9c8-226">版本信息</span><span class="sxs-lookup"><span data-stu-id="ee9c8-226">Version Information</span></span>  
 <span data-ttu-id="ee9c8-227">在 .NET Framework 版本2.0 中，<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> 属性值将传播到使用 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> 方法排队的工作线程。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-227">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="ee9c8-228">在早期版本中，不传播主体信息。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-228">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee9c8-229">下面的示例使用 .NET 线程池来计算介于20和40之间的五个数字的 `Fibonacci` 结果。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-229">The following example uses the .NET thread pool to calculate the `Fibonacci` result for five numbers between 20 and 40.</span></span> <span data-ttu-id="ee9c8-230">每个 `Fibonacci` 结果都由 `Fibonacci` 类表示，该类提供一个名为 `ThreadPoolCallback` 的方法，用于执行计算。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-230">Each `Fibonacci` result is represented by the `Fibonacci` class, which provides a method named `ThreadPoolCallback` that performs the calculation.</span></span> <span data-ttu-id="ee9c8-231">创建表示每个 `Fibonacci` 值的对象，并将 `ThreadPoolCallback` 方法传递给 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>，它分配池中的一个可用线程来执行此方法。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-231">An object that represents each `Fibonacci` value is created, and the `ThreadPoolCallback` method is passed to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>, which assigns an available thread in the pool to execute the method.</span></span>  
  
 <span data-ttu-id="ee9c8-232">由于每个 `Fibonacci` 对象都为计算提供半随机值，并且每个线程都将争用处理器时间，因此您无法提前知道要计算所有五个结果所需的时间。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-232">Because each `Fibonacci` object is given a semi-random value to compute, and because each thread will be competing for processor time, you cannot know in advance how long it will take for all five results to be calculated.</span></span> <span data-ttu-id="ee9c8-233">这就是在构造期间为每个 `Fibonacci` 对象传递 <xref:System.Threading.ManualResetEvent> 类的一个实例的原因。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-233">That is why each `Fibonacci` object is passed an instance of the <xref:System.Threading.ManualResetEvent> class during construction.</span></span> <span data-ttu-id="ee9c8-234">每个对象在其计算完成时向提供的事件对象发出信号，这允许主线程阻止执行 <xref:System.Threading.WaitHandle.WaitAll%2A>，直到所有五个 `Fibonacci` 对象都计算出结果。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-234">Each object signals the provided event object when its calculation is complete, which allows the primary thread to block execution with <xref:System.Threading.WaitHandle.WaitAll%2A> until all five `Fibonacci` objects have calculated a result.</span></span> <span data-ttu-id="ee9c8-235">然后 `Main` 方法会显示每个 `Fibonacci` 结果。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-235">The `Main` method then displays each `Fibonacci` result.</span></span>
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ee9c8-236">承载公共语言运行时 (CLR) 的宿主不支持此操作。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-236">The common language runtime (CLR) is hosted, and the host does not support this action.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ee9c8-237"><paramref name="callBack" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-237"><paramref name="callBack" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="ee9c8-238">托管线程池</span><span class="sxs-lookup"><span data-stu-id="ee9c8-238">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="2" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TState"><span data-ttu-id="ee9c8-239"><paramref name="state" /> 的元素类型。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-239">The type of elements of <paramref name="state" />.</span></span></typeparam>
        <param name="callBack"><span data-ttu-id="ee9c8-240"><see cref="T:System.Action`1" />，它表示要执行的方法。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-240">An <see cref="T:System.Action`1" /> representing the method to execute.</span></span></param>
        <param name="state"><span data-ttu-id="ee9c8-241">包含方法所用数据的对象。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-241">An object containing data to be used by the method.</span></span></param>
        <param name="preferLocal"><span data-ttu-id="ee9c8-242"><see langword="true" /> 表示首选在靠近当前线程的队列中对工作项进行排队；<see langword="false" /> 则表示首选将工作项排队到线程池的共享队列中。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-242"><see langword="true" /> to prefer queueing the work item in a queue close to the current thread; <see langword="false" /> to prefer queueing the work item to the thread pool's shared queue.</span></span></param>
        <summary><span data-ttu-id="ee9c8-243">将 <see cref="T:System.Action`1" /> 委托指定的方法排入队列以便执行，并提供该方法使用的数据。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-243">Queues a method specified by an <see cref="T:System.Action`1" /> delegate for execution, and provides data to be used by the method.</span></span> <span data-ttu-id="ee9c8-244">此方法在有线程池线程变得可用时执行。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-244">The method executes when a thread pool thread becomes available.</span></span></summary>
        <returns><span data-ttu-id="ee9c8-245">如果此方法成功排队，则为 <see langword="true" />；如果无法将该工作项排队，则引发 <see cref="T:System.NotSupportedException" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-245"><see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span></span>
<span data-ttu-id="ee9c8-246">。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-246">.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ee9c8-247">注册正在等待 <see cref="T:System.Threading.WaitHandle" /> 的委托。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-247">Registers a delegate that is waiting for a <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="ee9c8-248">要注册的 <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-248">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="ee9c8-249">使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-249">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="ee9c8-250">向 <paramref name="waitObject" /> 参数发出信号时调用的 <see cref="T:System.Threading.WaitOrTimerCallback" /> 委托。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-250">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="ee9c8-251">传递给委托的对象。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-251">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="ee9c8-252">以毫秒为单位的超时。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-252">The time-out in milliseconds.</span></span> <span data-ttu-id="ee9c8-253">如果 <paramref name="millisecondsTimeOutInterval" /> 参数为 0（零），函数将测试对象的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-253">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="ee9c8-254">如果 <paramref name="millisecondsTimeOutInterval" /> 为 -1，则函数的超时间隔永远不过期。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-254">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="ee9c8-255">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <paramref name="waitObject" /> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-255"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="ee9c8-256">注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并指定一个 32 位有符号整数来表示超时值（以毫秒为单位）。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-256">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit signed integer for the time-out in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="ee9c8-257">封装本机句柄的 <see cref="T:System.Threading.RegisteredWaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-257">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee9c8-258">使用完此方法返回的 <xref:System.Threading.RegisteredWaitHandle> 后，调用其 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 方法以释放对等待句柄的引用。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-258">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="ee9c8-259">建议您始终调用 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 方法，即使您为 `executeOnlyOnce`指定 `true` 也是如此。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-259">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="ee9c8-260">如果调用 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 方法，而不是根据注册的等待句柄的终结器，则垃圾回收的工作效率更高。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-260">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="ee9c8-261"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 方法将指定的委托排队到线程池。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-261">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="ee9c8-262">当发生以下情况之一时，工作线程将执行委托：</span><span class="sxs-lookup"><span data-stu-id="ee9c8-262">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="ee9c8-263">指定的对象处于终止状态。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-263">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="ee9c8-264">超时间隔已过去。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-264">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="ee9c8-265"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 方法检查指定对象的 <xref:System.Threading.WaitHandle>的当前状态。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-265">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="ee9c8-266">如果对象的状态为信号，则该方法将注册等待操作。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-266">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="ee9c8-267">等待操作由线程池中的一个线程执行。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-267">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="ee9c8-268">当对象的状态变为 "已终止" 或超时间隔结束时，工作线程会执行委托。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-268">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="ee9c8-269">如果 `timeOutInterval` 参数不为0（零），并且 `executeOnlyOnce` 参数 `false`，则每当事件发出信号或超时间隔结束时，将重置计时器。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-269">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ee9c8-270">使用 `waitObject` 的 <xref:System.Threading.Mutex> 不会为回调提供互斥，因为基础 Windows API 使用默认的 `WT_EXECUTEDEFAULT` 标志，因此每个回调都在单独的线程池线程上进行调度。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-270">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="ee9c8-271">请使用最大计数为1的 <xref:System.Threading.Semaphore> 而不是 <xref:System.Threading.Mutex>。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-271">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="ee9c8-272">若要取消等待操作，请调用 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-272">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="ee9c8-273">等待线程使用 Win32 `WaitForMultipleObjects` 函数来监视已注册的等待操作。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-273">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="ee9c8-274">因此，如果必须在多个调用中使用相同的本机操作系统句柄 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，则必须使用 Win32 `DuplicateHandle` 函数复制句柄。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-274">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="ee9c8-275">请注意，不应脉冲传递给 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>的事件对象，因为等待线程可能检测不到事件在重置前已发出信号。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-275">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="ee9c8-276">在返回之前，函数会修改某些类型的同步对象的状态。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-276">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="ee9c8-277">仅对其终止状态导致等待条件得到满足的对象进行修改。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-277">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="ee9c8-278">例如，信号量的计数减少1。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-278">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="ee9c8-279">版本信息</span><span class="sxs-lookup"><span data-stu-id="ee9c8-279">Version Information</span></span>  
 <span data-ttu-id="ee9c8-280">从 .NET Framework 版本2.0 开始，<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> 属性值将传播到使用 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 方法排队的工作线程。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-280">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="ee9c8-281">在早期版本中，不传播主体信息。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-281">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ee9c8-282"><paramref name="millisecondsTimeOutInterval" /> 参数小于 -1。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-282">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="ee9c8-283">托管线程池</span><span class="sxs-lookup"><span data-stu-id="ee9c8-283">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="ee9c8-284">要注册的 <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-284">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="ee9c8-285">使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-285">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="ee9c8-286">向 <paramref name="waitObject" /> 参数发出信号时调用的 <see cref="T:System.Threading.WaitOrTimerCallback" /> 委托。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-286">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="ee9c8-287">传递给委托的对象。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-287">The object passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="ee9c8-288">以毫秒为单位的超时。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-288">The time-out in milliseconds.</span></span> <span data-ttu-id="ee9c8-289">如果 <paramref name="millisecondsTimeOutInterval" /> 参数为 0（零），函数将测试对象的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-289">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="ee9c8-290">如果 <paramref name="millisecondsTimeOutInterval" /> 为 -1，则函数的超时间隔永远不过期。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-290">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="ee9c8-291">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <paramref name="waitObject" /> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-291"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="ee9c8-292">注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并指定一个 64 位有符号整数来表示超时值（以毫秒为单位）。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-292">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="ee9c8-293">封装本机句柄的 <see cref="T:System.Threading.RegisteredWaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-293">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee9c8-294">使用完此方法返回的 <xref:System.Threading.RegisteredWaitHandle> 后，调用其 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 方法以释放对等待句柄的引用。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-294">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="ee9c8-295">建议您始终调用 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 方法，即使您为 `executeOnlyOnce`指定 `true` 也是如此。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-295">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="ee9c8-296">如果调用 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 方法，而不是根据注册的等待句柄的终结器，则垃圾回收的工作效率更高。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-296">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="ee9c8-297"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 方法将指定的委托排队到线程池。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-297">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="ee9c8-298">当发生以下情况之一时，工作线程将执行委托：</span><span class="sxs-lookup"><span data-stu-id="ee9c8-298">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="ee9c8-299">指定的对象处于终止状态。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-299">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="ee9c8-300">超时间隔已过去。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-300">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="ee9c8-301"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 方法检查指定对象的 <xref:System.Threading.WaitHandle>的当前状态。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-301">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="ee9c8-302">如果对象的状态为信号，则该方法将注册等待操作。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-302">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="ee9c8-303">等待操作由线程池中的一个线程执行。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-303">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="ee9c8-304">当对象的状态变为 "已终止" 或超时间隔结束时，工作线程会执行委托。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-304">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="ee9c8-305">如果 `timeOutInterval` 参数不为0（零），并且 `executeOnlyOnce` 参数 `false`，则每当事件发出信号或超时间隔结束时，将重置计时器。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-305">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ee9c8-306">使用 `waitObject` 的 <xref:System.Threading.Mutex> 不会为回调提供互斥，因为基础 Windows API 使用默认的 `WT_EXECUTEDEFAULT` 标志，因此每个回调都在单独的线程池线程上进行调度。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-306">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="ee9c8-307">请使用最大计数为1的 <xref:System.Threading.Semaphore> 而不是 <xref:System.Threading.Mutex>。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-307">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="ee9c8-308">若要取消等待操作，请调用 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-308">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="ee9c8-309">等待线程使用 Win32 `WaitForMultipleObjects` 函数来监视已注册的等待操作。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-309">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="ee9c8-310">因此，如果必须在多个调用中使用相同的本机操作系统句柄 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，则必须使用 Win32 `DuplicateHandle` 函数复制句柄。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-310">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="ee9c8-311">请注意，不应脉冲传递给 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>的事件对象，因为等待线程可能检测不到事件在重置前已发出信号。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-311">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="ee9c8-312">在返回之前，函数会修改某些类型的同步对象的状态。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-312">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="ee9c8-313">仅对其终止状态导致等待条件得到满足的对象进行修改。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-313">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="ee9c8-314">例如，信号量的计数减少1。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-314">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="ee9c8-315">版本信息</span><span class="sxs-lookup"><span data-stu-id="ee9c8-315">Version Information</span></span>  
 <span data-ttu-id="ee9c8-316">从 .NET Framework 版本2.0 开始，<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> 属性值将传播到使用 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 方法排队的工作线程。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-316">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="ee9c8-317">在早期版本中，不传播主体信息。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-317">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ee9c8-318"><paramref name="millisecondsTimeOutInterval" /> 参数小于 -1。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-318">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="ee9c8-319">托管线程池</span><span class="sxs-lookup"><span data-stu-id="ee9c8-319">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="ee9c8-320">要注册的 <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-320">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="ee9c8-321">使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-321">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="ee9c8-322">向 <paramref name="waitObject" /> 参数发出信号时调用的 <see cref="T:System.Threading.WaitOrTimerCallback" /> 委托。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-322">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="ee9c8-323">传递给委托的对象。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-323">The object passed to the delegate.</span></span></param>
        <param name="timeout"><span data-ttu-id="ee9c8-324"><see cref="T:System.TimeSpan" /> 表示的超时时间。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-324">The time-out represented by a <see cref="T:System.TimeSpan" />.</span></span> <span data-ttu-id="ee9c8-325">如果 <paramref name="timeout" /> 为 0（零），则函数将测试对象的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-325">If <paramref name="timeout" /> is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="ee9c8-326">如果 <paramref name="timeout" /> 为 -1，则函数的超时间隔永远不过期。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-326">If <paramref name="timeout" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="ee9c8-327">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <paramref name="waitObject" /> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-327"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="ee9c8-328">注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并指定一个 <see cref="T:System.TimeSpan" /> 值来表示超时时间。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-328">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out.</span></span></summary>
        <returns><span data-ttu-id="ee9c8-329">封装本机句柄的 <see cref="T:System.Threading.RegisteredWaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-329">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee9c8-330">使用完此方法返回的 <xref:System.Threading.RegisteredWaitHandle> 后，调用其 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 方法以释放对等待句柄的引用。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-330">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="ee9c8-331">建议您始终调用 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 方法，即使您为 `executeOnlyOnce`指定 `true` 也是如此。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-331">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="ee9c8-332">如果调用 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 方法，而不是根据注册的等待句柄的终结器，则垃圾回收的工作效率更高。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-332">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="ee9c8-333"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 方法将指定的委托排队到线程池。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-333">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="ee9c8-334">当发生以下情况之一时，工作线程将执行委托：</span><span class="sxs-lookup"><span data-stu-id="ee9c8-334">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="ee9c8-335">指定的对象处于终止状态。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-335">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="ee9c8-336">超时间隔已过去。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-336">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="ee9c8-337"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 方法检查指定对象的 <xref:System.Threading.WaitHandle>的当前状态。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-337">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="ee9c8-338">如果对象的状态为信号，则该方法将注册等待操作。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-338">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="ee9c8-339">等待操作由线程池中的一个线程执行。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-339">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="ee9c8-340">当对象的状态变为 "已终止" 或超时间隔结束时，工作线程会执行委托。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-340">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="ee9c8-341">如果 `timeOutInterval` 参数不为0（零），并且 `executeOnlyOnce` 参数 `false`，则每当事件发出信号或超时间隔结束时，将重置计时器。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-341">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ee9c8-342">使用 `waitObject` 的 <xref:System.Threading.Mutex> 不会为回调提供互斥，因为基础 Windows API 使用默认的 `WT_EXECUTEDEFAULT` 标志，因此每个回调都在单独的线程池线程上进行调度。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-342">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="ee9c8-343">请使用最大计数为1的 <xref:System.Threading.Semaphore> 而不是 <xref:System.Threading.Mutex>。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-343">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="ee9c8-344">若要取消等待操作，请调用 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-344">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="ee9c8-345">等待线程使用 Win32 `WaitForMultipleObjects` 函数来监视已注册的等待操作。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-345">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="ee9c8-346">因此，如果必须在多个调用中使用相同的本机操作系统句柄 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，则必须使用 Win32 `DuplicateHandle` 函数复制句柄。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-346">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="ee9c8-347">请注意，不应脉冲传递给 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>的事件对象，因为等待线程可能检测不到事件在重置前已发出信号。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-347">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="ee9c8-348">在返回之前，函数会修改某些类型的同步对象的状态。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-348">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="ee9c8-349">仅对其终止状态导致等待条件得到满足的对象进行修改。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-349">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="ee9c8-350">例如，信号量的计数减少1。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-350">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="ee9c8-351">版本信息</span><span class="sxs-lookup"><span data-stu-id="ee9c8-351">Version Information</span></span>  
 <span data-ttu-id="ee9c8-352">从 .NET Framework 版本2.0 开始，<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> 属性值将传播到使用 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 方法排队的工作线程。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-352">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="ee9c8-353">在早期版本中，不传播主体信息。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-353">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ee9c8-354"><paramref name="timeout" /> 参数小于 -1。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-354">The <paramref name="timeout" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ee9c8-355"><paramref name="timeout" /> 参数大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-355">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="ee9c8-356">托管线程池</span><span class="sxs-lookup"><span data-stu-id="ee9c8-356">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="ee9c8-357">要注册的 <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-357">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="ee9c8-358">使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-358">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="ee9c8-359">向 <paramref name="waitObject" /> 参数发出信号时调用的 <see cref="T:System.Threading.WaitOrTimerCallback" /> 委托。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-359">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="ee9c8-360">传递给委托的对象。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-360">The object passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="ee9c8-361">以毫秒为单位的超时。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-361">The time-out in milliseconds.</span></span> <span data-ttu-id="ee9c8-362">如果 <paramref name="millisecondsTimeOutInterval" /> 参数为 0（零），函数将测试对象的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-362">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="ee9c8-363">如果 <paramref name="millisecondsTimeOutInterval" /> 为 -1，则函数的超时间隔永远不过期。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-363">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="ee9c8-364">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <paramref name="waitObject" /> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-364"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="ee9c8-365">指定表示超时（以毫秒为单位）的 32 位无符号整数，注册一个委托等待 <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-365">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="ee9c8-366"><see cref="T:System.Threading.RegisteredWaitHandle" />，可用于取消已注册的等待操作。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-366">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee9c8-367">使用完此方法返回的 <xref:System.Threading.RegisteredWaitHandle> 后，调用其 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 方法以释放对等待句柄的引用。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-367">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="ee9c8-368">建议您始终调用 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 方法，即使您为 `executeOnlyOnce`指定 `true` 也是如此。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-368">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="ee9c8-369">如果调用 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 方法，而不是根据注册的等待句柄的终结器，则垃圾回收的工作效率更高。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-369">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="ee9c8-370"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 方法将指定的委托排队到线程池。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-370">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="ee9c8-371">当发生以下情况之一时，工作线程将执行委托：</span><span class="sxs-lookup"><span data-stu-id="ee9c8-371">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="ee9c8-372">指定的对象处于终止状态。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-372">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="ee9c8-373">超时间隔已过去。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-373">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="ee9c8-374"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 方法检查指定对象的 <xref:System.Threading.WaitHandle>的当前状态。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-374">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="ee9c8-375">如果对象的状态为信号，则该方法将注册等待操作。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-375">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="ee9c8-376">等待操作由线程池中的一个线程执行。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-376">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="ee9c8-377">当对象的状态变为 "已终止" 或超时间隔结束时，工作线程会执行委托。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-377">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="ee9c8-378">如果 `timeOutInterval` 参数不为0（零），并且 `executeOnlyOnce` 参数 `false`，则每当事件发出信号或超时间隔结束时，将重置计时器。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-378">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ee9c8-379">使用 `waitObject` 的 <xref:System.Threading.Mutex> 不会为回调提供互斥，因为基础 Windows API 使用默认的 `WT_EXECUTEDEFAULT` 标志，因此每个回调都在单独的线程池线程上进行调度。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-379">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="ee9c8-380">请使用最大计数为1的 <xref:System.Threading.Semaphore> 而不是 <xref:System.Threading.Mutex>。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-380">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="ee9c8-381">若要取消等待操作，请调用 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-381">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="ee9c8-382">等待线程使用 Win32 `WaitForMultipleObjects` 函数来监视已注册的等待操作。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-382">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="ee9c8-383">因此，如果必须在多个调用中使用相同的本机操作系统句柄 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，则必须使用 Win32 `DuplicateHandle` 函数复制句柄。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-383">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="ee9c8-384">请注意，不应脉冲传递给 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>的事件对象，因为等待线程可能检测不到事件在重置前已发出信号。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-384">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="ee9c8-385">在返回之前，函数会修改某些类型的同步对象的状态。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-385">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="ee9c8-386">仅对其终止状态导致等待条件得到满足的对象进行修改。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-386">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="ee9c8-387">例如，信号量的计数减少1。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-387">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="ee9c8-388">版本信息</span><span class="sxs-lookup"><span data-stu-id="ee9c8-388">Version Information</span></span>  
 <span data-ttu-id="ee9c8-389">从 .NET Framework 版本2.0 开始，<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> 属性值将传播到使用 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 方法排队的工作线程。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-389">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="ee9c8-390">在早期版本中，不传播主体信息。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-390">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee9c8-391">下面的示例演示如何使用 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 方法在指定的等待句柄终止时执行指定的回调方法。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-391">The following example shows how to use the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method to execute a specified callback method when a specified wait handle is signaled.</span></span> <span data-ttu-id="ee9c8-392">在此示例中，回调方法为 `WaitProc`，等待句柄是一个 <xref:System.Threading.AutoResetEvent>。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-392">In this example, the callback method is `WaitProc`, and the wait handle is an <xref:System.Threading.AutoResetEvent>.</span></span>  
  
 <span data-ttu-id="ee9c8-393">该示例定义了一个 `TaskInfo` 类，用于保存在执行时传递到回调的信息。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-393">The example defines a `TaskInfo` class to hold the information that is passed to the callback when it executes.</span></span> <span data-ttu-id="ee9c8-394">该示例创建一个 `TaskInfo` 对象，并为其分配一些字符串数据。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-394">The example creates a `TaskInfo` object and assigns it some string data.</span></span> <span data-ttu-id="ee9c8-395"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 方法返回的 <xref:System.Threading.RegisteredWaitHandle> 将分配给 `TaskInfo` 对象的 `Handle` 字段，以便回调方法有权访问该 <xref:System.Threading.RegisteredWaitHandle>。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-395">The <xref:System.Threading.RegisteredWaitHandle> that is returned by the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method is assigned to the `Handle` field of the `TaskInfo` object so that the callback method has access to the <xref:System.Threading.RegisteredWaitHandle>.</span></span>  
  
 <span data-ttu-id="ee9c8-396">除了将 `TaskInfo` 指定为要传递给回调方法的对象之外，对 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 方法的调用还指定任务将等待的 <xref:System.Threading.AutoResetEvent>、表示 `WaitProc` 回调方法的 <xref:System.Threading.WaitOrTimerCallback> 委托、一个秒的超时间隔和多个回调。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-396">In addition to specifying `TaskInfo` as the object to pass to the callback method, the call to the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method specifies the <xref:System.Threading.AutoResetEvent> that the task will wait for, a <xref:System.Threading.WaitOrTimerCallback> delegate that represents the `WaitProc` callback method, a one second time-out interval, and multiple callbacks.</span></span>  
  
 <span data-ttu-id="ee9c8-397">当主线程通过调用其 <xref:System.Threading.EventWaitHandle.Set%2A> 方法发出 <xref:System.Threading.AutoResetEvent> 信号时，将调用 <xref:System.Threading.WaitOrTimerCallback> 委托。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-397">When the main thread signals the <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, the <xref:System.Threading.WaitOrTimerCallback> delegate is invoked.</span></span> <span data-ttu-id="ee9c8-398">`WaitProc` 方法测试 <xref:System.Threading.RegisteredWaitHandle> 以确定是否发生了超时。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-398">The `WaitProc` method tests <xref:System.Threading.RegisteredWaitHandle> to determine whether a time-out occurred.</span></span> <span data-ttu-id="ee9c8-399">如果回调是由于等待句柄已发出信号而调用的，则 `WaitProc` 方法会取消注册 <xref:System.Threading.RegisteredWaitHandle>，从而停止其他回调。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-399">If the callback was invoked because the wait handle was signaled, the `WaitProc` method unregisters the <xref:System.Threading.RegisteredWaitHandle>, stopping additional callbacks.</span></span> <span data-ttu-id="ee9c8-400">在超时情况下，任务将继续等待。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-400">In the case of a time-out, the task continues to wait.</span></span> <span data-ttu-id="ee9c8-401">`WaitProc` 方法通过将消息打印到控制台来结束。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-401">The `WaitProc` method ends by printing a message to the console.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ee9c8-402"><paramref name="millisecondsTimeOutInterval" /> 参数小于 -1。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-402">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="ee9c8-403">托管线程池</span><span class="sxs-lookup"><span data-stu-id="ee9c8-403">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="completionPortThreads" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="ee9c8-404">线程池中辅助线程的最大数目。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-404">The maximum number of worker threads in the thread pool.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="ee9c8-405">线程池中异步 I/O 线程的最大数目。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-405">The maximum number of asynchronous I/O threads in the thread pool.</span></span></param>
        <summary><span data-ttu-id="ee9c8-406">设置可以同时处于活动状态的线程池的请求数目。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-406">Sets the number of requests to the thread pool that can be active concurrently.</span></span> <span data-ttu-id="ee9c8-407">所有大于此数目的请求将保持排队状态，直到线程池线程变为可用。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-407">All requests above that number remain queued until thread pool threads become available.</span></span></summary>
        <returns><span data-ttu-id="ee9c8-408">如果更改成功，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-408"><see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee9c8-409">不能将工作线程或 i/o 完成线程的最大数目设置为小于计算机上的处理器数。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-409">You cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the number of processors on the computer.</span></span> <span data-ttu-id="ee9c8-410">若要确定有多少个处理器，请检索 <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> 属性的值。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-410">To determine how many processors are present, retrieve the value of the <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="ee9c8-411">此外，不能将最大工作线程或 i/o 完成线程的最大数目设置为小于工作线程或 i/o 完成线程对应的最小数目的数字。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-411">In addition, you cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the corresponding minimum number of worker threads or I/O completion threads.</span></span> <span data-ttu-id="ee9c8-412">若要确定最小线程池大小，请调用 <xref:System.Threading.ThreadPool.GetMinThreads%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-412">To determine the minimum thread pool size,  call the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method.</span></span>  
  
 <span data-ttu-id="ee9c8-413">如果托管公共语言运行时（例如 Internet Information Services （IIS）或 SQL Server），则宿主可能会限制或阻止对线程池大小所做的更改。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-413">If the common language runtime is hosted, for example by Internet Information Services (IIS) or SQL Server, the host can limit or prevent changes to the thread pool size.</span></span>  
  
 <span data-ttu-id="ee9c8-414">更改线程池中线程的最大数量时，请务必小心。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-414">Use caution when changing the maximum number of threads in the thread pool.</span></span> <span data-ttu-id="ee9c8-415">虽然你的代码可能会受益，但所做的更改可能会对你使用的代码库产生不利影响。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-415">While your code might benefit, the changes might have an adverse effect on code libraries you use.</span></span>  
  
 <span data-ttu-id="ee9c8-416">将线程池大小设置得太大可能会导致性能问题。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-416">Setting the thread pool size too large can cause performance problems.</span></span> <span data-ttu-id="ee9c8-417">如果同时执行的线程太多，任务切换开销会成为一个重要因素。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-417">If too many threads are executing at the same time, the task switching overhead becomes a significant factor.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="completionPortThreads" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="ee9c8-418">要由线程池根据需要创建的新的最小工作程序线程数。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-418">The minimum number of worker threads that the thread pool creates on demand.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="ee9c8-419">要由线程池根据需要创建的新的最小空闲异步 I/O 线程数。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-419">The minimum number of asynchronous I/O threads that the thread pool creates on demand.</span></span></param>
        <summary><span data-ttu-id="ee9c8-420">发出新的请求时，在切换到管理线程创建和销毁的算法之前设置线程池按需创建的线程的最小数量。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-420">Sets the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span></span></summary>
        <returns><span data-ttu-id="ee9c8-421">如果更改成功，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-421"><see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee9c8-422">线程池按需提供新的工作线程或 i/o 完成线程，直到达到每个类别的最小值。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-422">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="ee9c8-423">达到最小值时，线程池可以在该类别中创建更多的线程，或等待某些任务完成。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-423">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="ee9c8-424">从 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]开始，线程池会创建并销毁线程，以优化吞吐量，定义为每个时间单位完成的任务数。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-424">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="ee9c8-425">线程过少可能无法实现可用资源的最优利用，而线程过多则可能增加资源争用。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-425">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
 <span data-ttu-id="ee9c8-426">需求较低时，线程池线程的实际数量可以低于最小值。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-426">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="ee9c8-427">如果指定一个负数或一个大于活动线程池线程的最大数目（使用 <xref:System.Threading.ThreadPool.GetMaxThreads%2A>获取）的数字，则 <xref:System.Threading.ThreadPool.SetMinThreads%2A> 返回 `false`，并且不会更改其中一个最小值。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-427">If you specify a negative number or a number larger than the maximum number of active thread pool threads (obtained using <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> returns `false` and does not change either of the minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ee9c8-428">默认情况下，最小线程数设置为系统上的处理器数。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-428">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="ee9c8-429">您可以使用 <xref:System.Threading.ThreadPool.SetMinThreads%2A> 方法来增加最小线程数。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-429">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of threads.</span></span> <span data-ttu-id="ee9c8-430">但是，不必要地增加这些值可能导致性能问题。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-430">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="ee9c8-431">如果在同一时间开始太多的任务，则所有任务均可能会很慢。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-431">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="ee9c8-432">在大多数情况下，线程池可通过其自身用于分配线程的算法来更好地执行。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-432">In most cases, the thread pool will perform better with its own algorithm for allocating threads.</span></span> <span data-ttu-id="ee9c8-433">将最小值减小到小于处理器数量也可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-433">Reducing the minimum to less than the number of processors can also hurt performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee9c8-434">下面的示例将最小工作线程数设置为4，并保留最小异步 i/o 完成线程数的原始值。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-434">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="ThreadCount">
      <MemberSignature Language="C#" Value="public static int ThreadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ThreadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.ThreadCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ThreadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ThreadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadCount : int" Usage="System.Threading.ThreadPool.ThreadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ee9c8-435">获取当前存在的线程池线程数。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-435">Gets the number of thread pool threads that currently exist.</span></span></summary>
        <value><span data-ttu-id="ee9c8-436">当前存在的线程池线程数。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-436">The number of thread pool threads that currently exist.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

<span data-ttu-id="ee9c8-437">如果线程池实现可能具有不同类型的线程，则计数将包括所有类型。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-437">If a thread pool implementation may have different types of threads, the count includes all types.</span></span>

        ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="overlapped"><span data-ttu-id="ee9c8-438">要排队的 <see cref="T:System.Threading.NativeOverlapped" /> 结构。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-438">The <see cref="T:System.Threading.NativeOverlapped" /> structure to queue.</span></span></param>
        <summary><span data-ttu-id="ee9c8-439">将重叠的 I/O 操作排队以便执行。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-439">Queues an overlapped I/O operation for execution.</span></span></summary>
        <returns><span data-ttu-id="ee9c8-440">如果成功地将此操作排队到 I/O 完成端口，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-440"><see langword="true" /> if the operation was successfully queued to an I/O completion port; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee9c8-441">有关使用本机 Win32 重叠 i/o 的信息，请参阅 Win32 Platform SDK 中的 <xref:System.Threading.Overlapped> 类、<xref:System.Threading.NativeOverlapped> 结构和 `OVERLAPPED` 结构。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-441">For information about using native Win32 overlapped I/O, see the <xref:System.Threading.Overlapped> class, the <xref:System.Threading.NativeOverlapped> structure, and the `OVERLAPPED` structure in the Win32 Platform SDK.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ee9c8-442">使用 <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> 方法可能会无意中打开安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-442">Using the <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> method could inadvertently open up a security hole.</span></span> <span data-ttu-id="ee9c8-443">代码访问安全性根据堆栈上所有调用方的权限检查其权限。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-443">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="ee9c8-444">当使用 <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>在线程池线程上对工作进行排队时，线程池线程的堆栈没有实际调用方的上下文。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-444">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, the stack of the thread pool thread does not have the context of the actual callers.</span></span> <span data-ttu-id="ee9c8-445">恶意代码可以利用此漏洞来避免权限检查。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-445">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.IThreadPoolWorkItem callBack, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.IThreadPoolWorkItem callBack, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.IThreadPoolWorkItem,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As IThreadPoolWorkItem, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::IThreadPoolWorkItem ^ callBack, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.IThreadPoolWorkItem * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.IThreadPoolWorkItem" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="ee9c8-446">当线程池中的线程选择工作项时调用的工作项。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-446">The work item to invoke when a thread in the thread pool picks up the work item.</span></span></param>
        <param name="preferLocal"><span data-ttu-id="ee9c8-447"><see langword="true" /> 表示首选在靠近当前线程的队列中对工作项进行排队；<see langword="false" /> 则表示首选将工作项排队到线程池的共享队列中。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-447"><see langword="true" /> to prefer queueing the work item in a queue close to the current thread; <see langword="false" /> to prefer queueing the work item to the thread pool's shared queue.</span></span></param>
        <summary><span data-ttu-id="ee9c8-448">将指定的工作项对象排队到线程池。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-448">Queues the specified work item object to the thread pool.</span></span></summary>
        <returns><span data-ttu-id="ee9c8-449">如果方法成功，则为 <see langword="true" />；如果未能将该工作项排队，则引发 <see cref="T:System.OutOfMemoryException" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-449"><see langword="true" /> if the method succeeds; <see cref="T:System.OutOfMemoryException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="ee9c8-450">线程池将调用工作项的 <xref:System.Threading.IThreadPoolWorkItem.Execute> 方法。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-450">The thread pool will invoke the work item's <xref:System.Threading.IThreadPoolWorkItem.Execute> method.</span></span> <span data-ttu-id="ee9c8-451">如果需要，该工作项负责传播 <xref:System.Threading.ExecutionContext>;线程池不会这样做。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-451">It is the responsibility of that work item to propagate <xref:System.Threading.ExecutionContext> if it's needed; the thread pool will not do so.</span></span>

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ee9c8-452"><paramref name="callback" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-452"><paramref name="callback" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ee9c8-453">该工作项是一个 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-453">The work item is a <see cref="T:System.Threading.Tasks.Task" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="ee9c8-454">未能将该工作项排队。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-454">The work item could not be queued.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="ee9c8-455">一个 <see cref="T:System.Threading.WaitCallback" />，表示当线程池中的线程选择工作项时调用的委托。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-455">A <see cref="T:System.Threading.WaitCallback" /> that represents the delegate to invoke when a thread in the thread pool picks up the work item.</span></span></param>
        <param name="state"><span data-ttu-id="ee9c8-456">在接受线程池服务时传递给委托的对象。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-456">The object that is passed to the delegate when serviced from the thread pool.</span></span></param>
        <summary><span data-ttu-id="ee9c8-457">将指定的委托排队到线程池，但不会将调用堆栈传播到辅助线程。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-457">Queues the specified delegate to the thread pool, but does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="ee9c8-458">如果方法成功，则为 <see langword="true" />；如果未能将该工作项排队，则引发 <see cref="T:System.OutOfMemoryException" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-458"><see langword="true" /> if the method succeeds; <see cref="T:System.OutOfMemoryException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee9c8-459">与 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> 方法不同，<xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> 不会将调用堆栈传播到辅助线程。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-459">Unlike the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method, <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="ee9c8-460">这允许代码丢失调用堆栈，从而提升其安全权限。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-460">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ee9c8-461">使用 <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> 可能会无意中打开安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-461">Using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="ee9c8-462">代码访问安全性根据堆栈上所有调用方的权限检查其权限。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-462">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="ee9c8-463">当使用 <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>在线程池线程上对工作排队时，线程池线程的堆栈将不具有实际调用方的上下文。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-463">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="ee9c8-464">恶意代码可以利用此漏洞来避免权限检查。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-464">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="ee9c8-465">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-465">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="ee9c8-466">遇到了内存不足的情况。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-466">An out-of-memory condition was encountered.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="ee9c8-467">未能将该工作项排队。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-467">The work item could not be queued.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ee9c8-468"><paramref name="callBack" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-468"><paramref name="callBack" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="ee9c8-469">托管线程池</span><span class="sxs-lookup"><span data-stu-id="ee9c8-469">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool UnsafeQueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="2" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="TState"><span data-ttu-id="ee9c8-470"><paramref name="state" /> 的元素类型。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-470">The type of elements of <paramref name="state" />.</span></span></typeparam>
        <param name="callBack"><span data-ttu-id="ee9c8-471">表示要执行的方法的委托。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-471">A delegate representing the method to execute.</span></span></param>
        <param name="state"><span data-ttu-id="ee9c8-472">包含方法所用数据的对象。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-472">An object containing data to be used by the method.</span></span></param>
        <param name="preferLocal"><span data-ttu-id="ee9c8-473"><see langword="true" /> 表示首选在靠近当前线程的队列中对工作项进行排队；<see langword="false" /> 则表示首选将工作项排队到线程池的共享队列中。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-473"><see langword="true" /> to prefer queueing the work item in a queue close to the current thread; <see langword="false" /> to prefer queueing the work item to the thread pool's shared queue.</span></span></param>
        <summary><span data-ttu-id="ee9c8-474">将 <see cref="T:System.Action`1" /> 委托指定的方法排入队列以便执行，并指定包含该方法使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-474">Queues a method specified by an <see cref="T:System.Action`1" /> delegate for execution, and specifies an object containing data to be used by the method.</span></span> <span data-ttu-id="ee9c8-475">此方法在有线程池线程变得可用时执行。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-475">The method executes when a thread pool thread becomes available.</span></span></summary>
        <returns><span data-ttu-id="ee9c8-476">如果此方法成功排队，则为 <see langword="true" />；如果无法将该工作项排队，则引发 <see cref="T:System.NotSupportedException" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-476"><see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ee9c8-477"><paramref name="callback" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-477"><paramref name="callback" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ee9c8-478">未能将该工作项排队。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-478">The work item could not be queued.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ee9c8-479">注册委托以等待 <see cref="T:System.Threading.WaitHandle" />，但不会将调用堆栈传播到辅助线程。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-479">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, but does not propagate the calling stack to the worker thread.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" Index="3" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="ee9c8-480">要注册的 <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-480">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="ee9c8-481">使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-481">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="ee9c8-482">向 <paramref name="waitObject" /> 参数发出信号时调用的委托。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-482">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="ee9c8-483">传递给委托的对象。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-483">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="ee9c8-484">以毫秒为单位的超时。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-484">The time-out in milliseconds.</span></span> <span data-ttu-id="ee9c8-485">如果 <paramref name="millisecondsTimeOutInterval" /> 参数为 0（零），函数将测试对象的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-485">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="ee9c8-486">如果 <paramref name="millisecondsTimeOutInterval" /> 为 -1，则函数的超时间隔永远不过期。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-486">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="ee9c8-487">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <paramref name="waitObject" /> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-487"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="ee9c8-488">注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并使用一个 32 位带符号整数来表示超时时间（以毫秒为单位）。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-488">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, using a 32-bit signed integer for the time-out in milliseconds.</span></span> <span data-ttu-id="ee9c8-489">此方法不将调用堆栈传播到辅助线程。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-489">This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="ee9c8-490"><see cref="T:System.Threading.RegisteredWaitHandle" /> 对象，可用于取消已注册的等待操作。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-490">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee9c8-491">与 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 方法不同，<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> 不会将调用堆栈传播到辅助线程。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-491">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="ee9c8-492">这允许代码丢失调用堆栈，从而提升其安全权限。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-492">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ee9c8-493">使用 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> 可能会无意中打开安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-493">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="ee9c8-494">代码访问安全性根据堆栈上所有调用方的权限检查其权限。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-494">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="ee9c8-495">当使用 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>在线程池线程上对工作排队时，线程池线程的堆栈将不具有实际调用方的上下文。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-495">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="ee9c8-496">恶意代码可以利用此漏洞来避免权限检查。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-496">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="ee9c8-497">使用 `waitObject` 的 <xref:System.Threading.Mutex> 不会为回调提供互斥，因为基础 Windows API 使用默认的 `WT_EXECUTEDEFAULT` 标志，因此每个回调都在单独的线程池线程上进行调度。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-497">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="ee9c8-498">使用完此方法返回的 <xref:System.Threading.RegisteredWaitHandle> 后，调用其 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 方法以释放对等待句柄的引用。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-498">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="ee9c8-499">建议您始终调用 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 方法，即使您为 `executeOnlyOnce`指定 `true` 也是如此。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-499">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="ee9c8-500">如果调用 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 方法，而不是根据注册的等待句柄的终结器，则垃圾回收的工作效率更高。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-500">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ee9c8-501"><paramref name="millisecondsTimeOutInterval" /> 参数小于 -1。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-501">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="ee9c8-502">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-502">The caller does not have the required permission.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="ee9c8-503">托管线程池</span><span class="sxs-lookup"><span data-stu-id="ee9c8-503">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" Index="3" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="ee9c8-504">要注册的 <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-504">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="ee9c8-505">使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-505">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="ee9c8-506">向 <paramref name="waitObject" /> 参数发出信号时调用的委托。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-506">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="ee9c8-507">传递给委托的对象。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-507">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="ee9c8-508">以毫秒为单位的超时。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-508">The time-out in milliseconds.</span></span> <span data-ttu-id="ee9c8-509">如果 <paramref name="millisecondsTimeOutInterval" /> 参数为 0（零），函数将测试对象的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-509">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="ee9c8-510">如果 <paramref name="millisecondsTimeOutInterval" /> 为 -1，则函数的超时间隔永远不过期。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-510">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="ee9c8-511">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <paramref name="waitObject" /> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-511"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="ee9c8-512">注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并指定一个 64 位有符号整数来表示超时值（以毫秒为单位）。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-512">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span></span> <span data-ttu-id="ee9c8-513">此方法不将调用堆栈传播到辅助线程。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-513">This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="ee9c8-514"><see cref="T:System.Threading.RegisteredWaitHandle" /> 对象，可用于取消已注册的等待操作。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-514">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee9c8-515">与 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 方法不同，<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> 不会将调用堆栈传播到辅助线程。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-515">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="ee9c8-516">这允许代码丢失调用堆栈，从而提升其安全权限。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-516">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ee9c8-517">使用 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> 可能会无意中打开安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-517">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="ee9c8-518">代码访问安全性根据堆栈上所有调用方的权限检查其权限。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-518">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="ee9c8-519">当使用 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>在线程池线程上对工作排队时，线程池线程的堆栈将不具有实际调用方的上下文。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-519">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="ee9c8-520">恶意代码可以利用此漏洞来避免权限检查。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-520">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="ee9c8-521">使用 `waitObject` 的 <xref:System.Threading.Mutex> 不会为回调提供互斥，因为基础 Windows API 使用默认的 `WT_EXECUTEDEFAULT` 标志，因此每个回调都在单独的线程池线程上进行调度。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-521">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="ee9c8-522">使用完此方法返回的 <xref:System.Threading.RegisteredWaitHandle> 后，调用其 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 方法以释放对等待句柄的引用。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-522">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="ee9c8-523">建议您始终调用 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 方法，即使您为 `executeOnlyOnce`指定 `true` 也是如此。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-523">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="ee9c8-524">如果调用 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 方法，而不是根据注册的等待句柄的终结器，则垃圾回收的工作效率更高。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-524">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ee9c8-525"><paramref name="millisecondsTimeOutInterval" /> 参数小于 -1。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-525">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="ee9c8-526">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-526">The caller does not have the required permission.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="ee9c8-527">托管线程池</span><span class="sxs-lookup"><span data-stu-id="ee9c8-527">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="ee9c8-528">要注册的 <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-528">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="ee9c8-529">使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-529">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="ee9c8-530">向 <paramref name="waitObject" /> 参数发出信号时调用的委托。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-530">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="ee9c8-531">传递给委托的对象。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-531">The object that is passed to the delegate.</span></span></param>
        <param name="timeout"><span data-ttu-id="ee9c8-532"><see cref="T:System.TimeSpan" /> 表示的超时时间。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-532">The time-out represented by a <see cref="T:System.TimeSpan" />.</span></span> <span data-ttu-id="ee9c8-533">如果 <paramref name="timeout" /> 为 0（零），则函数将测试对象的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-533">If <paramref name="timeout" /> is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="ee9c8-534">如果 <paramref name="timeout" /> 为 -1，则函数的超时间隔永远不过期。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-534">If <paramref name="timeout" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="ee9c8-535">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <paramref name="waitObject" /> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-535"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="ee9c8-536">注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并指定一个 <see cref="T:System.TimeSpan" /> 值来表示超时时间。此方法不将调用堆栈传播到辅助线程。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-536">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out. This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="ee9c8-537"><see cref="T:System.Threading.RegisteredWaitHandle" /> 对象，可用于取消已注册的等待操作。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-537">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee9c8-538">与 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 方法不同，<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> 不会将调用堆栈传播到辅助线程。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-538">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="ee9c8-539">这允许代码丢失调用堆栈，从而提升其安全权限。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-539">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ee9c8-540">使用 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> 可能会无意中打开安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-540">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="ee9c8-541">代码访问安全性根据堆栈上所有调用方的权限检查其权限。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-541">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="ee9c8-542">当使用 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>在线程池线程上对工作排队时，线程池线程的堆栈将不具有实际调用方的上下文。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-542">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="ee9c8-543">恶意代码可以利用此漏洞来避免权限检查。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-543">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="ee9c8-544">使用 `waitObject` 的 <xref:System.Threading.Mutex> 不会为回调提供互斥，因为基础 Windows API 使用默认的 `WT_EXECUTEDEFAULT` 标志，因此每个回调都在单独的线程池线程上进行调度。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-544">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="ee9c8-545">使用完此方法返回的 <xref:System.Threading.RegisteredWaitHandle> 后，调用其 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 方法以释放对等待句柄的引用。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-545">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="ee9c8-546">建议您始终调用 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 方法，即使您为 `executeOnlyOnce`指定 `true` 也是如此。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-546">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="ee9c8-547">如果调用 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 方法，而不是根据注册的等待句柄的终结器，则垃圾回收的工作效率更高。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-547">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ee9c8-548"><paramref name="timeout" /> 参数小于 -1。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-548">The <paramref name="timeout" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ee9c8-549"><paramref name="timeout" /> 参数大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-549">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="ee9c8-550">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-550">The caller does not have the required permission.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="ee9c8-551">托管线程池</span><span class="sxs-lookup"><span data-stu-id="ee9c8-551">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" Index="3" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="ee9c8-552">要注册的 <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-552">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="ee9c8-553">使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-553">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="ee9c8-554">向 <paramref name="waitObject" /> 参数发出信号时调用的委托。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-554">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="ee9c8-555">传递给委托的对象。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-555">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="ee9c8-556">以毫秒为单位的超时。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-556">The time-out in milliseconds.</span></span> <span data-ttu-id="ee9c8-557">如果 <paramref name="millisecondsTimeOutInterval" /> 参数为 0（零），函数将测试对象的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-557">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="ee9c8-558">如果 <paramref name="millisecondsTimeOutInterval" /> 为 -1，则函数的超时间隔永远不过期。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-558">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="ee9c8-559">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <paramref name="waitObject" /> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-559"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="ee9c8-560">指定表示超时（以毫秒为单位）的 32 位无符号整数，注册一个委托等待 <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-560">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span></span> <span data-ttu-id="ee9c8-561">此方法不将调用堆栈传播到辅助线程。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-561">This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="ee9c8-562"><see cref="T:System.Threading.RegisteredWaitHandle" /> 对象，可用于取消已注册的等待操作。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-562">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee9c8-563">与 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 方法不同，<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> 不会将调用堆栈传播到辅助线程。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-563">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="ee9c8-564">这允许代码丢失调用堆栈，从而提升其安全权限。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-564">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ee9c8-565">使用 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> 可能会无意中打开安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-565">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="ee9c8-566">代码访问安全性根据堆栈上所有调用方的权限检查其权限。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-566">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="ee9c8-567">当使用 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>在线程池线程上对工作排队时，线程池线程的堆栈将不具有实际调用方的上下文。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-567">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="ee9c8-568">恶意代码可以利用此漏洞来避免权限检查。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-568">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="ee9c8-569">使用 `waitObject` 的 <xref:System.Threading.Mutex> 不会为回调提供互斥，因为基础 Windows API 使用默认的 `WT_EXECUTEDEFAULT` 标志，因此每个回调都在单独的线程池线程上进行调度。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-569">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="ee9c8-570">使用完此方法返回的 <xref:System.Threading.RegisteredWaitHandle> 后，调用其 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 方法以释放对等待句柄的引用。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-570">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="ee9c8-571">建议您始终调用 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 方法，即使您为 `executeOnlyOnce`指定 `true` 也是如此。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-571">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="ee9c8-572">如果调用 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 方法，而不是根据注册的等待句柄的终结器，则垃圾回收的工作效率更高。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-572">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="ee9c8-573">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="ee9c8-573">The caller does not have the required permission.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="ee9c8-574">托管线程池</span><span class="sxs-lookup"><span data-stu-id="ee9c8-574">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
