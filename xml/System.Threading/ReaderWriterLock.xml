<Type Name="ReaderWriterLock" FullName="System.Threading.ReaderWriterLock">
  <Metadata><Meta Name="ms.openlocfilehash" Value="109d3c1cf7e07e829df6ed9ab59ec35c852d025d" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83891399" /></Metadata><TypeSignature Language="C#" Value="public sealed class ReaderWriterLock : System.Runtime.ConstrainedExecution.CriticalFinalizerObject" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ReaderWriterLock extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLock" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ReaderWriterLock&#xA;Inherits CriticalFinalizerObject" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLock sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type ReaderWriterLock = class&#xA;    inherit CriticalFinalizerObject" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C#" Value="public sealed class ReaderWriterLock" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ReaderWriterLock extends System.Object" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ReaderWriterLock" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLock sealed" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="F#" Value="type ReaderWriterLock = class" FrameworkAlternate="netframework-1.1" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Threading" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="3c956-101">定义支持单个写线程和多个读线程的锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-101">Defines a lock that supports single writers and multiple readers.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="3c956-102">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 有下面两个读取器-编写器锁：<xref:System.Threading.ReaderWriterLockSlim> 和 <xref:System.Threading.ReaderWriterLock>。</span><span class="sxs-lookup"><span data-stu-id="3c956-102">The [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] has two reader-writer locks, <xref:System.Threading.ReaderWriterLockSlim> and <xref:System.Threading.ReaderWriterLock>.</span></span> <span data-ttu-id="3c956-103">建议对所有新开发的项目使用 <xref:System.Threading.ReaderWriterLockSlim>。</span><span class="sxs-lookup"><span data-stu-id="3c956-103"><xref:System.Threading.ReaderWriterLockSlim> is recommended for all new development.</span></span> <span data-ttu-id="3c956-104">虽然 <xref:System.Threading.ReaderWriterLockSlim> 类似于 <xref:System.Threading.ReaderWriterLock>，但不同之处在于，前者简化了递归规则以及锁状态的升级和降级规则。</span><span class="sxs-lookup"><span data-stu-id="3c956-104"><xref:System.Threading.ReaderWriterLockSlim> is similar to <xref:System.Threading.ReaderWriterLock>, but it has simplified rules for recursion and for upgrading and downgrading lock state.</span></span> <span data-ttu-id="3c956-105"><xref:System.Threading.ReaderWriterLockSlim> 避免了许多潜在的死锁情况。</span><span class="sxs-lookup"><span data-stu-id="3c956-105"><xref:System.Threading.ReaderWriterLockSlim> avoids many cases of potential deadlock.</span></span> <span data-ttu-id="3c956-106">另外，<xref:System.Threading.ReaderWriterLockSlim> 的性能显著优于 <xref:System.Threading.ReaderWriterLock>。</span><span class="sxs-lookup"><span data-stu-id="3c956-106">In addition, the performance of <xref:System.Threading.ReaderWriterLockSlim> is significantly better than <xref:System.Threading.ReaderWriterLock>.</span></span>  
  
 <span data-ttu-id="3c956-107"><xref:System.Threading.ReaderWriterLock> 用于同步对资源的访问。</span><span class="sxs-lookup"><span data-stu-id="3c956-107"><xref:System.Threading.ReaderWriterLock> is used to synchronize access to a resource.</span></span> <span data-ttu-id="3c956-108">在任何给定时间，它都允许对多个线程执行并发读取访问，或允许单个线程的写入访问。</span><span class="sxs-lookup"><span data-stu-id="3c956-108">At any given time, it allows either concurrent read access for multiple threads, or write access for a single thread.</span></span> <span data-ttu-id="3c956-109">在资源更改不频繁的情况下，`ReaderWriterLock` 比简单的一次性锁（如 <xref:System.Threading.Monitor>）提供更好的吞吐量。</span><span class="sxs-lookup"><span data-stu-id="3c956-109">In a situation where a resource is changed infrequently, a `ReaderWriterLock` provides better throughput than a simple one-at-a-time lock, such as <xref:System.Threading.Monitor>.</span></span>  
  
 <span data-ttu-id="3c956-110">在大多数访问都是读取的情况下，`ReaderWriterLock` 的效果最佳，而写入的时间很短且持续时间较短。</span><span class="sxs-lookup"><span data-stu-id="3c956-110">`ReaderWriterLock` works best where most accesses are reads, while writes are infrequent and of short duration.</span></span> <span data-ttu-id="3c956-111">多个读取器将替换为单个编写器，这样就不会长时间阻止读取器和编写器。</span><span class="sxs-lookup"><span data-stu-id="3c956-111">Multiple readers alternate with single writers, so that neither readers nor writers are blocked for long periods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3c956-112">长时间持有读取器锁或写入器锁将枯竭其他线程。</span><span class="sxs-lookup"><span data-stu-id="3c956-112">Holding reader locks or writer locks for long periods will starve other threads.</span></span> <span data-ttu-id="3c956-113">为了获得最佳性能，请考虑重构应用程序以最大程度地缩短写入的持续时间。</span><span class="sxs-lookup"><span data-stu-id="3c956-113">For best performance, consider restructuring your application to minimize the duration of writes.</span></span>  
  
 <span data-ttu-id="3c956-114">线程可以持有读取器锁或写入器锁，但不能同时持有两者。</span><span class="sxs-lookup"><span data-stu-id="3c956-114">A thread can hold a reader lock or a writer lock, but not both at the same time.</span></span> <span data-ttu-id="3c956-115">您可以使用 <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> 和 <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>，而不是释放读取器锁以获取写线程锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-115">Instead of releasing a reader lock in order to acquire the writer lock, you can use <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> and <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>.</span></span>  
  
 <span data-ttu-id="3c956-116">递归锁请求增加了锁的锁计数。</span><span class="sxs-lookup"><span data-stu-id="3c956-116">Recursive lock requests increase the lock count on a lock.</span></span>  
  
 <span data-ttu-id="3c956-117">读取器和编写器分别排入队列。</span><span class="sxs-lookup"><span data-stu-id="3c956-117">Readers and writers are queued separately.</span></span> <span data-ttu-id="3c956-118">当某个线程释放写入器锁时，在该时刻等待读取器队列中的所有线程都被授予读取器锁;所有这些读取器锁都已释放后，在编写器队列中等待的下一个线程（如果有）被授予写入器锁，依此类推。</span><span class="sxs-lookup"><span data-stu-id="3c956-118">When a thread releases the writer lock, all threads waiting in the reader queue at that instant are granted reader locks; when all of those reader locks have been released, the next thread waiting in the writer queue, if any, is granted the writer lock, and so on.</span></span> <span data-ttu-id="3c956-119">换句话说，`ReaderWriterLock` 在读取器集合和一个编写器之间交替。</span><span class="sxs-lookup"><span data-stu-id="3c956-119">In other words, `ReaderWriterLock` alternates between a collection of readers, and one writer.</span></span>  
  
 <span data-ttu-id="3c956-120">当编写器队列中的线程正在等待释放活动的读取器锁时，请求新读取器锁的线程将在读取器队列中累积。</span><span class="sxs-lookup"><span data-stu-id="3c956-120">While a thread in the writer queue is waiting for active reader locks to be released, threads requesting new reader locks accumulate in the reader queue.</span></span> <span data-ttu-id="3c956-121">不会授予其请求，即使它们可能与现有读取器锁持有者共享并发访问;这有助于防止读者无限的读者堵塞写入器。</span><span class="sxs-lookup"><span data-stu-id="3c956-121">Their requests are not granted, even though they could share concurrent access with existing reader-lock holders; this helps protect writers against indefinite blockage by readers.</span></span>  
  
 <span data-ttu-id="3c956-122">获取 `ReaderWriterLock` 的锁定的大多数方法接受超时值。</span><span class="sxs-lookup"><span data-stu-id="3c956-122">Most methods for acquiring locks on a `ReaderWriterLock` accept time-out values.</span></span> <span data-ttu-id="3c956-123">使用超时可避免应用程序中出现死锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-123">Use time-outs to avoid deadlocks in your application.</span></span> <span data-ttu-id="3c956-124">例如，线程可能会在一个资源上获取写线程锁，然后在第二个资源上请求读取器锁;同时，另一个线程可能会在第二个资源上获取写线程锁，并在第一个资源上请求读取器锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-124">For example, a thread might acquire the writer lock on one resource and then request a reader lock on a second resource; in the meantime, another thread might acquire the writer lock on the second resource, and request a reader lock on the first.</span></span> <span data-ttu-id="3c956-125">除非使用超时，否则线程会死锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-125">Unless time-outs are used, the threads deadlock.</span></span>  
  
 <span data-ttu-id="3c956-126">如果超时间隔过期并且尚未授予锁请求，则方法会通过引发 <xref:System.ApplicationException>将控件返回给调用线程。</span><span class="sxs-lookup"><span data-stu-id="3c956-126">If the time-out interval expires and the lock request has not been granted, the method returns control to the calling thread by throwing an <xref:System.ApplicationException>.</span></span> <span data-ttu-id="3c956-127">线程可以捕获此异常，并确定接下来要执行的操作。</span><span class="sxs-lookup"><span data-stu-id="3c956-127">A thread can catch this exception and determine what action to take next.</span></span>  
  
 <span data-ttu-id="3c956-128">超时以毫秒为单位。</span><span class="sxs-lookup"><span data-stu-id="3c956-128">Time-outs are expressed in milliseconds.</span></span> <span data-ttu-id="3c956-129">如果使用 <xref:System.TimeSpan?displayProperty=nameWithType> 指定超时值，则使用的值是 <xref:System.TimeSpan>所表示的总毫秒数。</span><span class="sxs-lookup"><span data-stu-id="3c956-129">If you use a <xref:System.TimeSpan?displayProperty=nameWithType> to specify the time-out, the value used is the total number of whole milliseconds represented by the <xref:System.TimeSpan>.</span></span> <span data-ttu-id="3c956-130">下表显示了有效的超时值（以毫秒为单位）。</span><span class="sxs-lookup"><span data-stu-id="3c956-130">The following table shows the valid time-out values in milliseconds.</span></span>  
  
|<span data-ttu-id="3c956-131">值</span><span class="sxs-lookup"><span data-stu-id="3c956-131">Value</span></span>|<span data-ttu-id="3c956-132">说明</span><span class="sxs-lookup"><span data-stu-id="3c956-132">Description</span></span>|  
|-----------|-----------------|  
|<span data-ttu-id="3c956-133">-1</span><span class="sxs-lookup"><span data-stu-id="3c956-133">-1</span></span>|<span data-ttu-id="3c956-134">线程会一直等待，直到获取锁，而不考虑它所需的时间。</span><span class="sxs-lookup"><span data-stu-id="3c956-134">The thread waits until the lock is acquired, regardless of how long it takes.</span></span> <span data-ttu-id="3c956-135">对于指定整数超时的方法，可以使用常量 <xref:System.Threading.Timeout.Infinite>。</span><span class="sxs-lookup"><span data-stu-id="3c956-135">For methods that specify integer time-outs, the constant <xref:System.Threading.Timeout.Infinite> can be used.</span></span>|  
|<span data-ttu-id="3c956-136">0</span><span class="sxs-lookup"><span data-stu-id="3c956-136">0</span></span>|<span data-ttu-id="3c956-137">线程不等待获取锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-137">The thread does not wait to acquire the lock.</span></span> <span data-ttu-id="3c956-138">如果无法立即获取锁定，则该方法将返回。</span><span class="sxs-lookup"><span data-stu-id="3c956-138">If the lock cannot be acquired immediately, the method returns.</span></span>|  
|<span data-ttu-id="3c956-139">>0</span><span class="sxs-lookup"><span data-stu-id="3c956-139">>0</span></span>|<span data-ttu-id="3c956-140">要等待的毫秒数。</span><span class="sxs-lookup"><span data-stu-id="3c956-140">The number of milliseconds to wait.</span></span>|  
  
 <span data-ttu-id="3c956-141">但不允许使用负超时值（-1）。</span><span class="sxs-lookup"><span data-stu-id="3c956-141">With the exception of -1, negative time-out values are not allowed.</span></span> <span data-ttu-id="3c956-142">如果指定一个非-1 的负整数，则改用超时值0。</span><span class="sxs-lookup"><span data-stu-id="3c956-142">If you specify a negative integer other than -1, a time-out value of zero is used instead.</span></span> <span data-ttu-id="3c956-143">（也就是说，如果无法立即获取锁定，则该方法将返回而不等待。）如果指定的 <xref:System.TimeSpan> 表示不是-1 的负毫秒数，则会引发 <xref:System.ArgumentOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="3c956-143">(That is, the method returns without waiting, if the lock cannot be acquired immediately.) If you specify a <xref:System.TimeSpan> that represents a negative number of milliseconds other than -1, <xref:System.ArgumentOutOfRangeException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c956-144">下面的示例演示如何使用 <xref:System.Threading.ReaderWriterLock> 来保护共享资源（一个名为 `resource`的整数值），该资源同时以多个线程的形式进行读取和写入。</span><span class="sxs-lookup"><span data-stu-id="3c956-144">The following example demonstrates how to use a <xref:System.Threading.ReaderWriterLock> to protect a shared resource, an integer value named `resource`, that is read concurrently and written exclusively by multiple threads.</span></span> <span data-ttu-id="3c956-145">请注意，<xref:System.Threading.ReaderWriterLock> 是在类级别上声明的，因此它对所有线程都可见。</span><span class="sxs-lookup"><span data-stu-id="3c956-145">Note that the <xref:System.Threading.ReaderWriterLock> is declared at the class level so that it is visible to all threads.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="3c956-146">此类型是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="3c956-146">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="3c956-147">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="3c956-147">Managed Threading</span></span></related>
    <related type="Article" href="/dotnet/standard/threading/reader-writer-locks"><span data-ttu-id="3c956-148">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="3c956-148">ReaderWriterLock</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLock();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3c956-149">初始化 <see cref="T:System.Threading.ReaderWriterLock" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="3c956-149">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLock" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3c956-150">下面的代码示例演示如何创建 <xref:System.Threading.ReaderWriterLock> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="3c956-150">The following code example demonstrates how to create a new instance of the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 <span data-ttu-id="3c956-151">此代码是为 <xref:System.Threading.ReaderWriterLock> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="3c956-151">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="3c956-152">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="3c956-152">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks"><span data-ttu-id="3c956-153">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="3c956-153">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcquireReaderLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3c956-154">获取读线程锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-154">Acquires a reader lock.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcquireReaderLock">
      <MemberSignature Language="C#" Value="public void AcquireReaderLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireReaderLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireReaderLock (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireReaderLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireReaderLock : int -&gt; unit" Usage="readerWriterLock.AcquireReaderLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="3c956-155">以毫秒为单位的超时。</span><span class="sxs-lookup"><span data-stu-id="3c956-155">The time-out in milliseconds.</span></span></param>
        <summary><span data-ttu-id="3c956-156">使用一个 <see cref="T:System.Int32" /> 超时值获取读线程锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-156">Acquires a reader lock, using an <see cref="T:System.Int32" /> value for the time-out.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c956-157">如果其他线程具有写入器锁，或者至少有一个线程正在等待编写器锁，则 <xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> 块。</span><span class="sxs-lookup"><span data-stu-id="3c956-157"><xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> blocks if a different thread has the writer lock, or if at least one thread is waiting for the writer lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3c956-158">如果当前线程已具有写入器锁，则不获取读取器锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-158">If the current thread already has the writer lock, no reader lock is acquired.</span></span> <span data-ttu-id="3c956-159">相反，写入器锁的锁计数将增加。</span><span class="sxs-lookup"><span data-stu-id="3c956-159">Instead, the lock count on the writer lock is incremented.</span></span> <span data-ttu-id="3c956-160">这会阻止线程在其自己的编写器锁上阻塞。</span><span class="sxs-lookup"><span data-stu-id="3c956-160">This prevents a thread from blocking on its own writer lock.</span></span> <span data-ttu-id="3c956-161">结果与调用 <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>完全相同，并且释放写入器锁时需要对 <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> 的额外调用。</span><span class="sxs-lookup"><span data-stu-id="3c956-161">The result is exactly the same as calling <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, and an additional call to <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> is required when releasing the writer lock.</span></span>  
  
 <span data-ttu-id="3c956-162">`AcquireReaderLock` 支持递归读取器-锁请求。</span><span class="sxs-lookup"><span data-stu-id="3c956-162">`AcquireReaderLock` supports recursive reader-lock requests.</span></span> <span data-ttu-id="3c956-163">也就是说，一个线程可多次调用 AcquireReaderLock，这将每次递增锁计数。</span><span class="sxs-lookup"><span data-stu-id="3c956-163">That is, a thread can call AcquireReaderLock multiple times, which increments the lock count each time.</span></span> <span data-ttu-id="3c956-164">每次调用 `AcquireReaderLock`时，都必须调用 <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> 一次。</span><span class="sxs-lookup"><span data-stu-id="3c956-164">You must call <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> once for each time you call `AcquireReaderLock`.</span></span> <span data-ttu-id="3c956-165">另外，还可以调用 <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> 将锁计数立即缩小为零。</span><span class="sxs-lookup"><span data-stu-id="3c956-165">Alternatively, you can call <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> to reduce the lock count to zero immediately.</span></span>  
  
 <span data-ttu-id="3c956-166">始终立即授予递归锁请求，而无需将请求线程放入读取器队列。</span><span class="sxs-lookup"><span data-stu-id="3c956-166">Recursive lock requests are always granted immediately, without placing the requesting thread in the reader queue.</span></span> <span data-ttu-id="3c956-167">请谨慎使用递归锁，以避免长时间阻止写入方锁请求。</span><span class="sxs-lookup"><span data-stu-id="3c956-167">Use recursive locks with caution, to avoid blocking writer-lock requests for long periods.</span></span>  
  
 <span data-ttu-id="3c956-168">有关有效的超时值，请参阅 <xref:System.Threading.ReaderWriterLock>。</span><span class="sxs-lookup"><span data-stu-id="3c956-168">For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c956-169">下面的代码示例演示如何获取和释放读取器锁，以及如何处理请求超时时引发的异常。</span><span class="sxs-lookup"><span data-stu-id="3c956-169">The following code example shows how to acquire and release a reader lock, and how to handle the exception thrown when a request times out.</span></span>  
  
 <span data-ttu-id="3c956-170">此代码是为 <xref:System.Threading.ReaderWriterLock> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="3c956-170">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#3)]
[!code-csharp[System.Threading.ReaderWriterLock#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLock#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#3)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="3c956-171"><paramref name="millisecondsTimeout" /> 在授予锁定请求前过期。</span><span class="sxs-lookup"><span data-stu-id="3c956-171"><paramref name="millisecondsTimeout" /> expires before the lock request is granted.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="3c956-172">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="3c956-172">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks"><span data-ttu-id="3c956-173">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="3c956-173">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AcquireReaderLock">
      <MemberSignature Language="C#" Value="public void AcquireReaderLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireReaderLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireReaderLock (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireReaderLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireReaderLock : TimeSpan -&gt; unit" Usage="readerWriterLock.AcquireReaderLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="3c956-174">一个 <see langword="TimeSpan" />，用于指定超时时间。</span><span class="sxs-lookup"><span data-stu-id="3c956-174">A <see langword="TimeSpan" /> specifying the time-out period.</span></span></param>
        <summary><span data-ttu-id="3c956-175">使用一个 <see cref="T:System.TimeSpan" /> 超时值获取读线程锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-175">Acquires a reader lock, using a <see cref="T:System.TimeSpan" /> value for the time-out.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c956-176">如果其他线程具有写入器锁，或者至少有一个线程正在等待编写器锁，则 <xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> 块。</span><span class="sxs-lookup"><span data-stu-id="3c956-176"><xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> blocks if a different thread has the writer lock, or if at least one thread is waiting for the writer lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3c956-177">如果当前线程已具有写入器锁，则不获取读取器锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-177">If the current thread already has the writer lock, no reader lock is acquired.</span></span> <span data-ttu-id="3c956-178">相反，写入器锁的锁计数将增加。</span><span class="sxs-lookup"><span data-stu-id="3c956-178">Instead, the lock count on the writer lock is incremented.</span></span> <span data-ttu-id="3c956-179">这会阻止线程在其自己的编写器锁上阻塞。</span><span class="sxs-lookup"><span data-stu-id="3c956-179">This prevents a thread from blocking on its own writer lock.</span></span> <span data-ttu-id="3c956-180">结果与调用 <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>完全相同，并且释放写入器锁时需要对 <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> 的额外调用。</span><span class="sxs-lookup"><span data-stu-id="3c956-180">The result is exactly the same as calling <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, and an additional call to <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> is required when releasing the writer lock.</span></span>  
  
 <span data-ttu-id="3c956-181">`AcquireReaderLock` 支持递归读取器-锁请求。</span><span class="sxs-lookup"><span data-stu-id="3c956-181">`AcquireReaderLock` supports recursive reader-lock requests.</span></span> <span data-ttu-id="3c956-182">也就是说，一个线程可多次调用 AcquireReaderLock，这将每次递增锁计数。</span><span class="sxs-lookup"><span data-stu-id="3c956-182">That is, a thread can call AcquireReaderLock multiple times, which increments the lock count each time.</span></span> <span data-ttu-id="3c956-183">每次调用 `AcquireReaderLock`时，都必须调用 <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> 一次。</span><span class="sxs-lookup"><span data-stu-id="3c956-183">You must call <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> once for each time you call `AcquireReaderLock`.</span></span> <span data-ttu-id="3c956-184">另外，还可以调用 <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> 将锁计数立即缩小为零。</span><span class="sxs-lookup"><span data-stu-id="3c956-184">Alternatively, you can call <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> to reduce the lock count to zero immediately.</span></span>  
  
 <span data-ttu-id="3c956-185">始终立即授予递归锁请求，而无需将请求线程放入读取器队列。</span><span class="sxs-lookup"><span data-stu-id="3c956-185">Recursive lock requests are always granted immediately, without placing the requesting thread in the reader queue.</span></span> <span data-ttu-id="3c956-186">请谨慎使用递归锁，以避免长时间阻止写入方锁请求。</span><span class="sxs-lookup"><span data-stu-id="3c956-186">Use recursive locks with caution, to avoid blocking writer-lock requests for long periods.</span></span>  
  
 <span data-ttu-id="3c956-187">有关有效的超时值，请参阅 <xref:System.Threading.ReaderWriterLock>。</span><span class="sxs-lookup"><span data-stu-id="3c956-187">For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="3c956-188"><paramref name="timeout" /> 在授予锁定请求前过期。</span><span class="sxs-lookup"><span data-stu-id="3c956-188"><paramref name="timeout" /> expires before the lock request is granted.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3c956-189"><paramref name="timeout" /> 可指定 -1 毫秒以外的任何负值。</span><span class="sxs-lookup"><span data-stu-id="3c956-189"><paramref name="timeout" /> specifies a negative value other than -1 milliseconds.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="3c956-190">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="3c956-190">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks"><span data-ttu-id="3c956-191">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="3c956-191">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcquireWriterLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3c956-192">获取写线程锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-192">Acquires the writer lock.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcquireWriterLock">
      <MemberSignature Language="C#" Value="public void AcquireWriterLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireWriterLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireWriterLock (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireWriterLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireWriterLock : int -&gt; unit" Usage="readerWriterLock.AcquireWriterLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="3c956-193">以毫秒为单位的超时。</span><span class="sxs-lookup"><span data-stu-id="3c956-193">The time-out in milliseconds.</span></span></param>
        <summary><span data-ttu-id="3c956-194">使用一个 <see cref="T:System.Int32" /> 超时值获取写线程锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-194">Acquires the writer lock, using an <see cref="T:System.Int32" /> value for the time-out.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c956-195">如果其他线程具有读取器锁或写入器锁，则此方法将会阻止。</span><span class="sxs-lookup"><span data-stu-id="3c956-195">This method blocks if another thread has a reader lock or writer lock.</span></span> <span data-ttu-id="3c956-196">有关编写器锁与多个并发读取器锁交替的方式的说明，请参阅 <xref:System.Threading.ReaderWriterLock> 类。</span><span class="sxs-lookup"><span data-stu-id="3c956-196">For a description of the way the writer lock alternates with multiple concurrent reader locks, see the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 <span data-ttu-id="3c956-197">已具有读取器锁的线程可以通过以下两种方式之一获取编写器锁：在调用 <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>之前释放读取器锁，或通过调用 <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>。</span><span class="sxs-lookup"><span data-stu-id="3c956-197">A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, or by calling <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="3c956-198">如果线程在仍具有读取器锁的情况下调用 `AcquireWriterLock`，它将在其自己的读取器锁上阻塞;如果指定了无限超时，则线程将死锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-198">If a thread calls `AcquireWriterLock` while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock.</span></span> <span data-ttu-id="3c956-199">若要避免这种死锁，请使用 <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> 来确定当前线程是否已具有读取器锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-199">To avoid such deadlocks, use <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> to determine whether the current thread already has a reader lock.</span></span>  
  
 <span data-ttu-id="3c956-200">`AcquireWriterLock` 支持递归写入方锁请求。</span><span class="sxs-lookup"><span data-stu-id="3c956-200">`AcquireWriterLock` supports recursive writer-lock requests.</span></span> <span data-ttu-id="3c956-201">也就是说，线程可以多次调用 `AcquireWriterLock`，这将每次递增锁计数。</span><span class="sxs-lookup"><span data-stu-id="3c956-201">That is, a thread can call `AcquireWriterLock` multiple times, which increments the lock count each time.</span></span> <span data-ttu-id="3c956-202">每次调用 `AcquireWriterLock`时，都必须调用 <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> 一次。</span><span class="sxs-lookup"><span data-stu-id="3c956-202">You must call <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> once for each time you call `AcquireWriterLock`.</span></span> <span data-ttu-id="3c956-203">另外，还可以调用 <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> 将锁计数立即缩小为零。</span><span class="sxs-lookup"><span data-stu-id="3c956-203">Alternatively, you can call <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> to reduce the lock count to zero immediately.</span></span>  
  
 <span data-ttu-id="3c956-204">始终立即授予递归锁请求，而不将发出请求的线程置于编写器队列中。</span><span class="sxs-lookup"><span data-stu-id="3c956-204">Recursive lock requests are always granted immediately, without placing the requesting thread in the writer queue.</span></span>  
  
 <span data-ttu-id="3c956-205">有关有效的超时值，请参阅 <xref:System.Threading.ReaderWriterLock>。</span><span class="sxs-lookup"><span data-stu-id="3c956-205">For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c956-206">下面的代码示例演示如何获取和释放编写器锁，以及如何处理请求超时时引发的异常。</span><span class="sxs-lookup"><span data-stu-id="3c956-206">The following code example shows how to acquire and release a writer lock, and how to handle the exception thrown when a request times out.</span></span>  
  
 <span data-ttu-id="3c956-207">此代码是为 <xref:System.Threading.ReaderWriterLock> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="3c956-207">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#4)]
[!code-csharp[System.Threading.ReaderWriterLock#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLock#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#4)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="3c956-208"><paramref name="timeout" /> 在授予锁定请求前过期。</span><span class="sxs-lookup"><span data-stu-id="3c956-208"><paramref name="timeout" /> expires before the lock request is granted.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="3c956-209">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="3c956-209">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks"><span data-ttu-id="3c956-210">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="3c956-210">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AcquireWriterLock">
      <MemberSignature Language="C#" Value="public void AcquireWriterLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireWriterLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireWriterLock (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireWriterLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireWriterLock : TimeSpan -&gt; unit" Usage="readerWriterLock.AcquireWriterLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="3c956-211"><see langword="TimeSpan" />，用于指定超时时间。</span><span class="sxs-lookup"><span data-stu-id="3c956-211">The <see langword="TimeSpan" /> specifying the time-out period.</span></span></param>
        <summary><span data-ttu-id="3c956-212">使用一个 <see cref="T:System.TimeSpan" /> 超时值获取写线程锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-212">Acquires the writer lock, using a <see cref="T:System.TimeSpan" /> value for the time-out.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c956-213">如果其他线程具有读取器锁或写入器锁，则此方法将会阻止。</span><span class="sxs-lookup"><span data-stu-id="3c956-213">This method blocks if another thread has a reader lock or writer lock.</span></span> <span data-ttu-id="3c956-214">有关编写器锁与多个并发读取器锁交替的方式的说明，请参阅 <xref:System.Threading.ReaderWriterLock> 类。</span><span class="sxs-lookup"><span data-stu-id="3c956-214">For a description of the way the writer lock alternates with multiple concurrent reader locks, see the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 <span data-ttu-id="3c956-215">已具有读取器锁的线程可以通过以下两种方式之一获取编写器锁：在调用 <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>之前释放读取器锁，或通过调用 <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>。</span><span class="sxs-lookup"><span data-stu-id="3c956-215">A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, or by calling <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="3c956-216">如果线程在仍具有读取器锁的情况下调用 `AcquireWriterLock`，它将在其自己的读取器锁上阻塞;如果指定了无限超时，则线程将死锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-216">If a thread calls `AcquireWriterLock` while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock.</span></span> <span data-ttu-id="3c956-217">若要避免这种死锁，请使用 <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> 来确定当前线程是否已具有读取器锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-217">To avoid such deadlocks, use <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> to determine whether the current thread already has a reader lock.</span></span>  
  
 <span data-ttu-id="3c956-218">`AcquireWriterLock` 支持递归写入方锁请求。</span><span class="sxs-lookup"><span data-stu-id="3c956-218">`AcquireWriterLock` supports recursive writer-lock requests.</span></span> <span data-ttu-id="3c956-219">也就是说，线程可以多次调用 `AcquireWriterLock`，这将每次递增锁计数。</span><span class="sxs-lookup"><span data-stu-id="3c956-219">That is, a thread can call `AcquireWriterLock` multiple times, which increments the lock count each time.</span></span> <span data-ttu-id="3c956-220">每次调用 `AcquireWriterLock`时，都必须调用 <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> 一次。</span><span class="sxs-lookup"><span data-stu-id="3c956-220">You must call <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> once for each time you call `AcquireWriterLock`.</span></span> <span data-ttu-id="3c956-221">另外，还可以调用 <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> 将锁计数立即缩小为零。</span><span class="sxs-lookup"><span data-stu-id="3c956-221">Alternatively, you can call <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> to reduce the lock count to zero immediately.</span></span>  
  
 <span data-ttu-id="3c956-222">始终立即授予递归锁请求，而不将发出请求的线程置于编写器队列中。</span><span class="sxs-lookup"><span data-stu-id="3c956-222">Recursive lock requests are always granted immediately, without placing the requesting thread in the writer queue.</span></span>  
  
 <span data-ttu-id="3c956-223">有关有效的超时值，请参阅 <xref:System.Threading.ReaderWriterLock>。</span><span class="sxs-lookup"><span data-stu-id="3c956-223">For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="3c956-224"><paramref name="timeout" /> 在授予锁定请求前过期。</span><span class="sxs-lookup"><span data-stu-id="3c956-224"><paramref name="timeout" /> expires before the lock request is granted.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3c956-225"><paramref name="timeout" /> 可指定 -1 毫秒以外的任何负值。</span><span class="sxs-lookup"><span data-stu-id="3c956-225"><paramref name="timeout" /> specifies a negative value other than -1 milliseconds.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="3c956-226">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="3c956-226">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks"><span data-ttu-id="3c956-227">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="3c956-227">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AnyWritersSince">
      <MemberSignature Language="C#" Value="public bool AnyWritersSince (int seqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AnyWritersSince(int32 seqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function AnyWritersSince (seqNum As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AnyWritersSince(int seqNum);" />
      <MemberSignature Language="F#" Value="member this.AnyWritersSince : int -&gt; bool" Usage="readerWriterLock.AnyWritersSince seqNum" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="seqNum" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="seqNum"><span data-ttu-id="3c956-228">序列号。</span><span class="sxs-lookup"><span data-stu-id="3c956-228">The sequence number.</span></span></param>
        <summary><span data-ttu-id="3c956-229">指示获取序列号之后是否已将写线程锁授予某个线程。</span><span class="sxs-lookup"><span data-stu-id="3c956-229">Indicates whether the writer lock has been granted to any thread since the sequence number was obtained.</span></span></summary>
        <returns><span data-ttu-id="3c956-230">如果获取序列号之后已将写线程锁授予某一线程，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3c956-230"><see langword="true" /> if the writer lock has been granted to any thread since the sequence number was obtained; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c956-231">您可以使用 <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> 和 `AnyWritersSince` 来提高应用程序性能。</span><span class="sxs-lookup"><span data-stu-id="3c956-231">You can use <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> and `AnyWritersSince` to improve application performance.</span></span> <span data-ttu-id="3c956-232">例如，线程可能会缓存它在持有读线程锁时获得的信息。</span><span class="sxs-lookup"><span data-stu-id="3c956-232">For example, a thread might cache the information it obtains while holding a reader lock.</span></span> <span data-ttu-id="3c956-233">在释放并之后 reacquiring 该锁后，线程可以使用 `AnyWritersSince` 来确定其他线程是否已在过渡中写入资源;如果不是，则可以使用缓存的信息。</span><span class="sxs-lookup"><span data-stu-id="3c956-233">After releasing and later reacquiring the lock, the thread can use `AnyWritersSince` to determine whether other threads have written to the resource in the interim; if not, the cached information can be used.</span></span> <span data-ttu-id="3c956-234">此方法在读取受锁定保护的信息时非常有用，例如，运行数据库查询。</span><span class="sxs-lookup"><span data-stu-id="3c956-234">This technique is useful where reading the information protected by the lock is expensive; for example, running a database query.</span></span>  
  
 <span data-ttu-id="3c956-235">为了使序列号有用，调用方必须持有读取器锁或写入器锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-235">The caller must be holding a reader lock or a writer lock in order for the sequence number to be useful.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c956-236">下面的代码示例演示如何使用 <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> 方法和 <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> 属性来确定在当前线程上次持有写入器锁后，另一个线程是否已获取受保护资源上的编写器锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-236">The following code example shows how to use the <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> method and the <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> property to determine whether another thread acquired the writer lock on the protected resource since the current thread last held the writer lock.</span></span>  
  
 <span data-ttu-id="3c956-237">此代码是为 <xref:System.Threading.ReaderWriterLock> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="3c956-237">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="3c956-238">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="3c956-238">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks"><span data-ttu-id="3c956-239">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="3c956-239">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DowngradeFromWriterLock">
      <MemberSignature Language="C#" Value="public void DowngradeFromWriterLock (ref System.Threading.LockCookie lockCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DowngradeFromWriterLock(valuetype System.Threading.LockCookie&amp; lockCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DowngradeFromWriterLock (ByRef lockCookie As LockCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DowngradeFromWriterLock(System::Threading::LockCookie % lockCookie);" />
      <MemberSignature Language="F#" Value="member this.DowngradeFromWriterLock : LockCookie -&gt; unit" Usage="readerWriterLock.DowngradeFromWriterLock lockCookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockCookie" Type="System.Threading.LockCookie" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockCookie"><span data-ttu-id="3c956-240">一个 <see cref="T:System.Threading.LockCookie" />，由 <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" /> 返回。</span><span class="sxs-lookup"><span data-stu-id="3c956-240">A <see cref="T:System.Threading.LockCookie" /> returned by <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</span></span></param>
        <summary><span data-ttu-id="3c956-241">将线程的锁状态还原为调用 <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" /> 前的状态。</span><span class="sxs-lookup"><span data-stu-id="3c956-241">Restores the lock status of the thread to what it was before <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" /> was called.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c956-242"><xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> 释放编写器锁，而不考虑递归锁计数，并在升级到写入器锁之前还原线程所持有的读取器锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-242"><xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> releases the writer lock, regardless of the recursive lock count, and restores the reader lock that was held by the thread before upgrading to the writer lock.</span></span> <span data-ttu-id="3c956-243">对读取器锁的锁计数进行了还原。</span><span class="sxs-lookup"><span data-stu-id="3c956-243">The lock count on the reader lock is restored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3c956-244">`DowngradeFromWriterLock` 接受通过调用 <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>获得的 <xref:System.Threading.LockCookie>。</span><span class="sxs-lookup"><span data-stu-id="3c956-244">`DowngradeFromWriterLock` accepts a <xref:System.Threading.LockCookie> obtained by calling <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span></span> <span data-ttu-id="3c956-245">不要使用 <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>返回的 `LockCookie`。</span><span class="sxs-lookup"><span data-stu-id="3c956-245">Do not use a `LockCookie` returned by <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.</span></span>  
  
 <span data-ttu-id="3c956-246">当从编写器锁降级时，即使其他线程正在等待编写器锁，线程也不会阻止，因为在释放编写器锁时，将授予所有读取器锁请求。</span><span class="sxs-lookup"><span data-stu-id="3c956-246">A thread does not block when downgrading from the writer lock, even if other threads are waiting for the writer lock, because all reader-lock requests are granted when the writer lock is released.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c956-247">下面的代码示例演示如何请求读取器锁，将读取器锁升级到写入器锁，并再次降级到读取器锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-247">The following code example shows how to request a reader lock, upgrade the reader lock to a writer lock, and downgrade to a reader lock again.</span></span>  
  
 <span data-ttu-id="3c956-248">此代码是为 <xref:System.Threading.ReaderWriterLock> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="3c956-248">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#5)]
[!code-csharp[System.Threading.ReaderWriterLock#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLock#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#5)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="3c956-249">线程没有写线程锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-249">The thread does not have the writer lock.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="3c956-250"><paramref name="lockCookie" /> 的地址为空指针。</span><span class="sxs-lookup"><span data-stu-id="3c956-250">The address of <paramref name="lockCookie" /> is a null pointer.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="3c956-251">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="3c956-251">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks"><span data-ttu-id="3c956-252">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="3c956-252">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ReaderWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ReaderWriterLock ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="readerWriterLock.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3c956-253">确保垃圾回收器回收 <see cref="T:System.Threading.ReaderWriterLock" /> 对象时释放资源并执行其他清理操作。</span><span class="sxs-lookup"><span data-stu-id="3c956-253">Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <see cref="T:System.Threading.ReaderWriterLock" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c956-254">当当前 <xref:System.Threading.ReaderWriterLock> 对象准备好完成时，垃圾回收器将调用 <xref:System.Threading.ReaderWriterLock.Finalize%2A>。</span><span class="sxs-lookup"><span data-stu-id="3c956-254">The garbage collector calls <xref:System.Threading.ReaderWriterLock.Finalize%2A> when the current <xref:System.Threading.ReaderWriterLock> object is ready to be finalized.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReaderLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReaderLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReaderLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.IsReaderLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReaderLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReaderLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReaderLockHeld : bool" Usage="System.Threading.ReaderWriterLock.IsReaderLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3c956-255">获取一个值，该值指示当前线程是否持有读线程锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-255">Gets a value indicating whether the current thread holds a reader lock.</span></span></summary>
        <value><span data-ttu-id="3c956-256">如果当前线程持有读线程锁，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3c956-256"><see langword="true" /> if the current thread holds a reader lock; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3c956-257">下面的代码示例演示如何使用 `IsReaderLockHeld` 以避免死锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-257">The following code example demonstrates how to use `IsReaderLockHeld` to avoid deadlocks.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="3c956-258">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="3c956-258">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks"><span data-ttu-id="3c956-259">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="3c956-259">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsWriterLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriterLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriterLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.IsWriterLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriterLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriterLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriterLockHeld : bool" Usage="System.Threading.ReaderWriterLock.IsWriterLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3c956-260">获取一个值，该值指示当前线程是否持有写线程锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-260">Gets a value indicating whether the current thread holds the writer lock.</span></span></summary>
        <value><span data-ttu-id="3c956-261">如果当前线程持有写线程锁，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3c956-261"><see langword="true" /> if the current thread holds the writer lock; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3c956-262">下面的代码示例演示当尝试获取具有编写器锁的线程上的读取器锁时，`ReaderWriterLock` 不授予读取器锁，而是递增写入器锁上的锁计数。</span><span class="sxs-lookup"><span data-stu-id="3c956-262">The following code example demonstrates that when an attempt is made to acquire a reader lock on a thread that has a writer lock, `ReaderWriterLock` does not grant the reader lock but instead increments the lock count on the writer lock.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="3c956-263">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="3c956-263">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks"><span data-ttu-id="3c956-264">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="3c956-264">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReleaseLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie ReleaseLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie ReleaseLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseLock" />
      <MemberSignature Language="VB.NET" Value="Public Function ReleaseLock () As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie ReleaseLock();" />
      <MemberSignature Language="F#" Value="member this.ReleaseLock : unit -&gt; System.Threading.LockCookie" Usage="readerWriterLock.ReleaseLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3c956-265">释放锁，不管线程获取锁的次数如何。</span><span class="sxs-lookup"><span data-stu-id="3c956-265">Releases the lock, regardless of the number of times the thread acquired the lock.</span></span></summary>
        <returns><span data-ttu-id="3c956-266">一个 <see cref="T:System.Threading.LockCookie" /> 值，表示释放的锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-266">A <see cref="T:System.Threading.LockCookie" /> value representing the released lock.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c956-267"><xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> 释放读取器锁或写入器锁，而不考虑递归锁计数。</span><span class="sxs-lookup"><span data-stu-id="3c956-267"><xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> releases the reader lock or writer lock, regardless of the recursive lock count.</span></span> <span data-ttu-id="3c956-268">若要还原锁的状态，包括锁计数，请将 <xref:System.Threading.LockCookie> 传递到 <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>。</span><span class="sxs-lookup"><span data-stu-id="3c956-268">To restore the state of the lock, including the lock count, pass the <xref:System.Threading.LockCookie> to <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c956-269">下面的代码示例演示如何使用 <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> 方法来释放锁，而不考虑线程获取该锁的次数，以及如何在以后还原该锁的状态。</span><span class="sxs-lookup"><span data-stu-id="3c956-269">The following code example shows how to use the <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> method to release the lock, regardless of how many times it has been acquired by the thread, and how to restore the state of the lock later.</span></span>  
  
 <span data-ttu-id="3c956-270">此代码是为 <xref:System.Threading.ReaderWriterLock> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="3c956-270">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="3c956-271">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="3c956-271">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks"><span data-ttu-id="3c956-272">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="3c956-272">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReleaseReaderLock">
      <MemberSignature Language="C#" Value="public void ReleaseReaderLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseReaderLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseReaderLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseReaderLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseReaderLock();" />
      <MemberSignature Language="F#" Value="member this.ReleaseReaderLock : unit -&gt; unit" Usage="readerWriterLock.ReleaseReaderLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3c956-273">减少锁计数。</span><span class="sxs-lookup"><span data-stu-id="3c956-273">Decrements the lock count.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c956-274"><xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> 递减锁计数。</span><span class="sxs-lookup"><span data-stu-id="3c956-274"><xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> decrements the lock count.</span></span> <span data-ttu-id="3c956-275">如果计数为零，则释放锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-275">When the count reaches zero, the lock is released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3c956-276">如果线程具有写入器锁，则调用 `ReleaseReaderLock` 与调用 <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>具有相同的效果。</span><span class="sxs-lookup"><span data-stu-id="3c956-276">If a thread has the writer lock, calling `ReleaseReaderLock` has the same effect as calling <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>.</span></span> <span data-ttu-id="3c956-277">如果线程没有锁，调用 `ReleaseReaderLock` 将引发 <xref:System.ApplicationException>。</span><span class="sxs-lookup"><span data-stu-id="3c956-277">If a thread has no locks, calling `ReleaseReaderLock` throws an <xref:System.ApplicationException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c956-278">下面的代码示例演示如何获取和释放读取器锁，以及如何处理请求超时时引发的异常。</span><span class="sxs-lookup"><span data-stu-id="3c956-278">The following code example shows how to acquire and release a reader lock, and how to handle the exception thrown when a request times out.</span></span>  
  
 <span data-ttu-id="3c956-279">此代码是为 <xref:System.Threading.ReaderWriterLock> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="3c956-279">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#3)]
[!code-csharp[System.Threading.ReaderWriterLock#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLock#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#3)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="3c956-280">线程没有读线程锁或写线程锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-280">The thread does not have any reader or writer locks.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="3c956-281">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="3c956-281">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks"><span data-ttu-id="3c956-282">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="3c956-282">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReleaseWriterLock">
      <MemberSignature Language="C#" Value="public void ReleaseWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseWriterLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseWriterLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseWriterLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseWriterLock();" />
      <MemberSignature Language="F#" Value="member this.ReleaseWriterLock : unit -&gt; unit" Usage="readerWriterLock.ReleaseWriterLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3c956-283">减少写线程锁上的锁计数。</span><span class="sxs-lookup"><span data-stu-id="3c956-283">Decrements the lock count on the writer lock.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c956-284"><xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> 递减写入器锁计数。</span><span class="sxs-lookup"><span data-stu-id="3c956-284"><xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> decrements the writer lock count.</span></span> <span data-ttu-id="3c956-285">当计数达到零时，将释放写入器锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-285">When the count reaches zero, the writer lock is released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3c956-286">如果线程具有读取器锁或没有锁，则调用 `ReleaseWriterLock` 将引发 <xref:System.ApplicationException>。</span><span class="sxs-lookup"><span data-stu-id="3c956-286">If a thread has a reader lock, or no locks, calling `ReleaseWriterLock` throws an <xref:System.ApplicationException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c956-287">下面的代码示例演示如何获取和释放编写器锁，以及如何处理请求超时时引发的异常。</span><span class="sxs-lookup"><span data-stu-id="3c956-287">The following code example shows how to acquire and release a writer lock, and how to handle the exception thrown when a request times out.</span></span>  
  
 <span data-ttu-id="3c956-288">此代码是为 <xref:System.Threading.ReaderWriterLock> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="3c956-288">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#4)]
[!code-csharp[System.Threading.ReaderWriterLock#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLock#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#4)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="3c956-289">线程没有写线程锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-289">The thread does not have the writer lock.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="3c956-290">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="3c956-290">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks"><span data-ttu-id="3c956-291">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="3c956-291">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RestoreLock">
      <MemberSignature Language="C#" Value="public void RestoreLock (ref System.Threading.LockCookie lockCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RestoreLock(valuetype System.Threading.LockCookie&amp; lockCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RestoreLock (ByRef lockCookie As LockCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RestoreLock(System::Threading::LockCookie % lockCookie);" />
      <MemberSignature Language="F#" Value="member this.RestoreLock : LockCookie -&gt; unit" Usage="readerWriterLock.RestoreLock lockCookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockCookie" Type="System.Threading.LockCookie" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockCookie"><span data-ttu-id="3c956-292">一个 <see cref="T:System.Threading.LockCookie" />，由 <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" /> 返回。</span><span class="sxs-lookup"><span data-stu-id="3c956-292">A <see cref="T:System.Threading.LockCookie" /> returned by <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</span></span></param>
        <summary><span data-ttu-id="3c956-293">将线程的锁状态还原为调用 <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" /> 前的状态。</span><span class="sxs-lookup"><span data-stu-id="3c956-293">Restores the lock status of the thread to what it was before calling <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c956-294">`RestoreLock` 还原的状态包括递归锁计数。</span><span class="sxs-lookup"><span data-stu-id="3c956-294">The state restored by `RestoreLock` includes the recursive lock count.</span></span>  
  
 <span data-ttu-id="3c956-295">如果线程在另一个线程获取了写入器锁后尝试还原读取器锁，或在另一个线程获取了读取器锁或写入器锁之后尝试还原写入器锁，则会阻止该线程。</span><span class="sxs-lookup"><span data-stu-id="3c956-295">A thread blocks if it tries to restore a reader lock after another thread has acquired the writer lock, or if it tries to restore the writer lock after another thread has acquired a reader lock or writer lock.</span></span> <span data-ttu-id="3c956-296">由于 `RestoreLock` 不接受超时，因此应注意避免可能出现的死锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-296">Because `RestoreLock` does not accept a time-out, you should take care to avoid possible deadlocks.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="3c956-297">在调用 `RestoreLock`之前，请确保已释放自调用 <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>以来获取的所有锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-297">Before calling `RestoreLock`, make sure you have released all locks acquired since the call to <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.</span></span> <span data-ttu-id="3c956-298">例如，如果线程获取读取器锁，然后尝试还原以前的编写器锁，则该线程会死锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-298">For example, a thread deadlocks if it acquires a reader lock, and then attempts to restore an earlier writer lock.</span></span> <span data-ttu-id="3c956-299">使用 <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> 和 <xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A> 检测此类附加锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-299">Use <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> and <xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A> to detect such additional locks.</span></span>  
  
 <span data-ttu-id="3c956-300">不要使用从 <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>返回的 <xref:System.Threading.LockCookie>。</span><span class="sxs-lookup"><span data-stu-id="3c956-300">Do not use a <xref:System.Threading.LockCookie> returned from <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c956-301">下面的代码示例演示如何使用 <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> 方法来释放锁，而不考虑线程获取该锁的次数，以及如何在以后还原该锁的状态。</span><span class="sxs-lookup"><span data-stu-id="3c956-301">The following code example shows how to use the <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> method to release the lock, regardless of how many times it has been acquired by the thread, and how to restore the state of the lock later.</span></span>  
  
 <span data-ttu-id="3c956-302">此代码是为 <xref:System.Threading.ReaderWriterLock> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="3c956-302">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="3c956-303"><paramref name="lockCookie" /> 的地址为空指针。</span><span class="sxs-lookup"><span data-stu-id="3c956-303">The address of <paramref name="lockCookie" /> is a null pointer.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="3c956-304">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="3c956-304">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks"><span data-ttu-id="3c956-305">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="3c956-305">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="UpgradeToWriterLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3c956-306">将读线程锁升级为写线程锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-306">Upgrades a reader lock to the writer lock.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpgradeToWriterLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie UpgradeToWriterLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie UpgradeToWriterLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function UpgradeToWriterLock (millisecondsTimeout As Integer) As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie UpgradeToWriterLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.UpgradeToWriterLock : int -&gt; System.Threading.LockCookie" Usage="readerWriterLock.UpgradeToWriterLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="3c956-307">以毫秒为单位的超时。</span><span class="sxs-lookup"><span data-stu-id="3c956-307">The time-out in milliseconds.</span></span></param>
        <summary><span data-ttu-id="3c956-308">使用一个 <see cref="T:System.Int32" /> 超时值将读线程锁升级为写线程锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-308">Upgrades a reader lock to the writer lock, using an <see cref="T:System.Int32" /> value for the time-out.</span></span></summary>
        <returns><span data-ttu-id="3c956-309">一个 <see cref="T:System.Threading.LockCookie" /> 值。</span><span class="sxs-lookup"><span data-stu-id="3c956-309">A <see cref="T:System.Threading.LockCookie" /> value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c956-310">当线程调用时 `UpgradeToWriterLock` 释放读取器锁，而不考虑锁计数，并且线程将进入写入器锁的队列的末尾。</span><span class="sxs-lookup"><span data-stu-id="3c956-310">When a thread calls `UpgradeToWriterLock` the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock.</span></span> <span data-ttu-id="3c956-311">因此，在向请求升级的线程授予了写入方锁之前，其他线程可能会写入资源。</span><span class="sxs-lookup"><span data-stu-id="3c956-311">Thus, other threads might write to the resource before the thread that requested the upgrade is granted the writer lock.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3c956-312">在调用 <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> 方法的线程可以重新获取读取器锁之前，不会引发超时异常。</span><span class="sxs-lookup"><span data-stu-id="3c956-312">The time-out exception is not thrown until the thread that called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method can reacquire the reader lock.</span></span> <span data-ttu-id="3c956-313">如果没有其他线程正在等待编写器锁，则会立即发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="3c956-313">If there are no other threads waiting for the writer lock, this happens immediately.</span></span> <span data-ttu-id="3c956-314">但是，如果另一个线程排队等候写入器锁，则调用 <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> 方法的线程将无法重新获取读取器锁，直到所有当前读取器都释放了锁，并且一个线程已获取并释放了写入器锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-314">However, if another thread is queued for the writer lock, the thread that called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method cannot reacquire the reader lock until all current readers have released their locks, and one thread has acquired and released the writer lock.</span></span> <span data-ttu-id="3c956-315">即使在当前线程调用了 <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> 方法之后，请求编写器锁的其他线程也是如此。</span><span class="sxs-lookup"><span data-stu-id="3c956-315">This is true even if the other thread that requested the writer lock requested it after the current thread called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method.</span></span>  
  
 <span data-ttu-id="3c956-316">若要还原锁定状态，请使用 `UpgradeToWriterLock`返回的 <xref:System.Threading.LockCookie> 调用 <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>。</span><span class="sxs-lookup"><span data-stu-id="3c956-316">To restore the lock state, call <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> using the <xref:System.Threading.LockCookie> returned by `UpgradeToWriterLock`.</span></span> <span data-ttu-id="3c956-317">不要将此 `LockCookie` 与 <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>一起使用。</span><span class="sxs-lookup"><span data-stu-id="3c956-317">Do not use this `LockCookie` with <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</span></span>  
  
 <span data-ttu-id="3c956-318">当线程没有读取器锁时，请不要使用 `UpgradeToWriterLock`。</span><span class="sxs-lookup"><span data-stu-id="3c956-318">When a thread has no reader lock, do not use `UpgradeToWriterLock`.</span></span> <span data-ttu-id="3c956-319">请改用 <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>。</span><span class="sxs-lookup"><span data-stu-id="3c956-319">Use <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A> instead.</span></span>  
  
 <span data-ttu-id="3c956-320">有关有效的超时值，请参阅 <xref:System.Threading.ReaderWriterLock>。</span><span class="sxs-lookup"><span data-stu-id="3c956-320">For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c956-321">下面的代码示例演示如何请求读取器锁，将读取器锁升级到写入器锁，并再次降级到读取器锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-321">The following code example shows how to request a reader lock, upgrade the reader lock to a writer lock, and downgrade to a reader lock again.</span></span>  
  
 <span data-ttu-id="3c956-322">此代码是为 <xref:System.Threading.ReaderWriterLock> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="3c956-322">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#5)]
[!code-csharp[System.Threading.ReaderWriterLock#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLock#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#5)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="3c956-323"><paramref name="millisecondsTimeout" /> 在授予锁定请求前过期。</span><span class="sxs-lookup"><span data-stu-id="3c956-323"><paramref name="millisecondsTimeout" /> expires before the lock request is granted.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="3c956-324">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="3c956-324">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks"><span data-ttu-id="3c956-325">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="3c956-325">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UpgradeToWriterLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie UpgradeToWriterLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie UpgradeToWriterLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function UpgradeToWriterLock (timeout As TimeSpan) As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie UpgradeToWriterLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.UpgradeToWriterLock : TimeSpan -&gt; System.Threading.LockCookie" Usage="readerWriterLock.UpgradeToWriterLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="3c956-326"><see langword="TimeSpan" />，用于指定超时时间。</span><span class="sxs-lookup"><span data-stu-id="3c956-326">The <see langword="TimeSpan" /> specifying the time-out period.</span></span></param>
        <summary><span data-ttu-id="3c956-327">使用一个 <see langword="TimeSpan" /> 超时值将读线程锁升级为写线程锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-327">Upgrades a reader lock to the writer lock, using a <see langword="TimeSpan" /> value for the time-out.</span></span></summary>
        <returns><span data-ttu-id="3c956-328">一个 <see cref="T:System.Threading.LockCookie" /> 值。</span><span class="sxs-lookup"><span data-stu-id="3c956-328">A <see cref="T:System.Threading.LockCookie" /> value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c956-329">当线程调用时 `UpgradeToWriterLock` 释放读取器锁，而不考虑锁计数，并且线程将进入写入器锁的队列的末尾。</span><span class="sxs-lookup"><span data-stu-id="3c956-329">When a thread calls `UpgradeToWriterLock` the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock.</span></span> <span data-ttu-id="3c956-330">因此，在向请求升级的线程授予了写入方锁之前，其他线程可能会写入资源。</span><span class="sxs-lookup"><span data-stu-id="3c956-330">Thus, other threads might write to the resource before the thread that requested the upgrade is granted the writer lock.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3c956-331">在调用 <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> 方法的线程可以重新获取读取器锁之前，不会引发超时异常。</span><span class="sxs-lookup"><span data-stu-id="3c956-331">The time-out exception is not thrown until the thread that called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method can reacquire the reader lock.</span></span> <span data-ttu-id="3c956-332">如果没有其他线程正在等待编写器锁，则会立即发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="3c956-332">If there are no other threads waiting for the writer lock, this happens immediately.</span></span> <span data-ttu-id="3c956-333">但是，如果另一个线程排队等候写入器锁，则调用 <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> 方法的线程将无法重新获取读取器锁，直到所有当前读取器都释放了锁，并且一个线程已获取并释放了写入器锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-333">However, if another thread is queued for the writer lock, the thread that called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method cannot reacquire the reader lock until all current readers have released their locks, and one thread has acquired and released the writer lock.</span></span> <span data-ttu-id="3c956-334">即使在当前线程调用了 <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> 方法之后，请求编写器锁的其他线程也是如此。</span><span class="sxs-lookup"><span data-stu-id="3c956-334">This is true even if the other thread that requested the writer lock requested it after the current thread called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method.</span></span>  
  
 <span data-ttu-id="3c956-335">若要还原锁定状态，请使用 `UpgradeToWriterLock`返回的 <xref:System.Threading.LockCookie> 调用 <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>。</span><span class="sxs-lookup"><span data-stu-id="3c956-335">To restore the lock state, call <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> using the <xref:System.Threading.LockCookie> returned by `UpgradeToWriterLock`.</span></span> <span data-ttu-id="3c956-336">不要将此 `LockCookie` 与 <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>一起使用。</span><span class="sxs-lookup"><span data-stu-id="3c956-336">Do not use this `LockCookie` with <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</span></span>  
  
 <span data-ttu-id="3c956-337">当线程没有读取器锁时，请不要使用 `UpgradeToWriterLock`。</span><span class="sxs-lookup"><span data-stu-id="3c956-337">When a thread has no reader lock, do not use `UpgradeToWriterLock`.</span></span> <span data-ttu-id="3c956-338">请改用 <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>。</span><span class="sxs-lookup"><span data-stu-id="3c956-338">Use <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A> instead.</span></span>  
  
 <span data-ttu-id="3c956-339">有关有效的超时值，请参阅 <xref:System.Threading.ReaderWriterLock>。</span><span class="sxs-lookup"><span data-stu-id="3c956-339">For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="3c956-340"><paramref name="timeout" /> 在授予锁定请求前过期。</span><span class="sxs-lookup"><span data-stu-id="3c956-340"><paramref name="timeout" /> expires before the lock request is granted.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3c956-341"><paramref name="timeout" /> 可指定 -1 毫秒以外的任何负值。</span><span class="sxs-lookup"><span data-stu-id="3c956-341"><paramref name="timeout" /> specifies a negative value other than -1 milliseconds.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="3c956-342">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="3c956-342">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks"><span data-ttu-id="3c956-343">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="3c956-343">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriterSeqNum">
      <MemberSignature Language="C#" Value="public int WriterSeqNum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriterSeqNum" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.WriterSeqNum" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriterSeqNum As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WriterSeqNum { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WriterSeqNum : int" Usage="System.Threading.ReaderWriterLock.WriterSeqNum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3c956-344">获取当前序列号。</span><span class="sxs-lookup"><span data-stu-id="3c956-344">Gets the current sequence number.</span></span></summary>
        <value><span data-ttu-id="3c956-345">当前序列号。</span><span class="sxs-lookup"><span data-stu-id="3c956-345">The current sequence number.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c956-346">每当线程获取写线程锁时，序列号就会增加。</span><span class="sxs-lookup"><span data-stu-id="3c956-346">The sequence number increases whenever a thread acquires the writer lock.</span></span> <span data-ttu-id="3c956-347">如果要确定其他线程是否在同一时间获取了编写器锁，可以保存序列号并将其传递到 <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A>。</span><span class="sxs-lookup"><span data-stu-id="3c956-347">You can save the sequence number and pass it to <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> at a later time, if you want to determine whether other threads have acquired the writer lock in the meantime.</span></span>  
  
 <span data-ttu-id="3c956-348">你可以使用 `WriterSeqNum` 来提高应用程序性能。</span><span class="sxs-lookup"><span data-stu-id="3c956-348">You can use `WriterSeqNum` to improve application performance.</span></span> <span data-ttu-id="3c956-349">例如，线程可能会缓存它在持有读线程锁时获得的信息。</span><span class="sxs-lookup"><span data-stu-id="3c956-349">For example, a thread might cache the information it obtains while holding a reader lock.</span></span> <span data-ttu-id="3c956-350">在释放并之后 reacquiring 锁定后，线程可以通过调用 `AnyWritersSince`来确定是否已将其他线程写入资源。如果不是，则可以使用缓存的信息。</span><span class="sxs-lookup"><span data-stu-id="3c956-350">After releasing and later reacquiring the lock, the thread can determine whether other threads have written to the resource by calling `AnyWritersSince`; if not, the cached information can be used.</span></span> <span data-ttu-id="3c956-351">当读取受锁定保护的信息时，此方法非常有用;例如，运行数据库查询。</span><span class="sxs-lookup"><span data-stu-id="3c956-351">This technique is useful when reading the information protected by the lock is expensive; for example, running a database query.</span></span>  
  
 <span data-ttu-id="3c956-352">为了使序列号有用，调用方必须持有读取器锁或写入器锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-352">The caller must be holding a reader lock or a writer lock in order for the sequence number to be useful.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c956-353">下面的代码示例演示如何使用 <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> 属性和 <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> 方法来确定自当前线程上次持有写入器锁后，另一个线程是否获取受保护资源上的编写器锁。</span><span class="sxs-lookup"><span data-stu-id="3c956-353">The following code example shows how to use the <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> property and the <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> method to determine whether another thread acquired the writer lock on the protected resource since the current thread last held the writer lock.</span></span>  
  
 <span data-ttu-id="3c956-354">此代码是为 <xref:System.Threading.ReaderWriterLock> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="3c956-354">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="3c956-355">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="3c956-355">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/reader-writer-locks"><span data-ttu-id="3c956-356">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="3c956-356">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
