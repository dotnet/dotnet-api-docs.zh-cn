<Type Name="ReaderWriterLockSlim" FullName="System.Threading.ReaderWriterLockSlim">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e120396dbb247c69f6f7ad04656d156a2cf57415" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83958042" /></Metadata><TypeSignature Language="C#" Value="public class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReaderWriterLockSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLockSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class ReaderWriterLockSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="F#" Value="type ReaderWriterLockSlim = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System.Core" FromVersion="4.0.0.0" To="System.Threading" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Threading" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="f409b-101">表示用于管理资源访问的锁定状态，可实现多线程读取或进行独占式写入访问。</span><span class="sxs-lookup"><span data-stu-id="f409b-101">Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f409b-102">使用 <xref:System.Threading.ReaderWriterLockSlim> 保护由多个线程读取的资源并一次写入一个线程。</span><span class="sxs-lookup"><span data-stu-id="f409b-102">Use <xref:System.Threading.ReaderWriterLockSlim> to protect a resource that is read by multiple threads and written to by one thread at a time.</span></span> <span data-ttu-id="f409b-103"><xref:System.Threading.ReaderWriterLockSlim> 允许多个线程处于读取模式，则允许一个线程处于具有独占锁定所有权的写入模式，并且允许具有读取访问权限的一个线程处于可升级读取模式，在该模式下，线程可以升级到写入模式，而无需放弃对资源的读取访问权限。</span><span class="sxs-lookup"><span data-stu-id="f409b-103"><xref:System.Threading.ReaderWriterLockSlim> allows multiple threads to be in read mode, allows one thread to be in write mode with exclusive ownership of the lock, and allows one thread that has read access to be in upgradeable read mode, from which the thread can upgrade to write mode without having to relinquish its read access to the resource.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f409b-104">虽然 <xref:System.Threading.ReaderWriterLockSlim> 类似于 <xref:System.Threading.ReaderWriterLock>，但不同之处在于，前者简化了递归规则以及锁状态的升级和降级规则。</span><span class="sxs-lookup"><span data-stu-id="f409b-104"><xref:System.Threading.ReaderWriterLockSlim> is similar to <xref:System.Threading.ReaderWriterLock>, but it has simplified rules for recursion and for upgrading and downgrading lock state.</span></span> <span data-ttu-id="f409b-105"><xref:System.Threading.ReaderWriterLockSlim> 避免了许多潜在的死锁情况。</span><span class="sxs-lookup"><span data-stu-id="f409b-105"><xref:System.Threading.ReaderWriterLockSlim> avoids many cases of potential deadlock.</span></span> <span data-ttu-id="f409b-106">另外，<xref:System.Threading.ReaderWriterLockSlim> 的性能显著优于 <xref:System.Threading.ReaderWriterLock>。</span><span class="sxs-lookup"><span data-stu-id="f409b-106">In addition, the performance of <xref:System.Threading.ReaderWriterLockSlim> is significantly better than <xref:System.Threading.ReaderWriterLock>.</span></span> <span data-ttu-id="f409b-107">建议对所有新开发的项目使用 <xref:System.Threading.ReaderWriterLockSlim>。</span><span class="sxs-lookup"><span data-stu-id="f409b-107"><xref:System.Threading.ReaderWriterLockSlim> is recommended for all new development.</span></span>  
  
 <span data-ttu-id="f409b-108">默认情况下，<xref:System.Threading.ReaderWriterLockSlim> 的新实例是使用 <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> 标志创建的，不允许使用递归。</span><span class="sxs-lookup"><span data-stu-id="f409b-108">By default, new instances of <xref:System.Threading.ReaderWriterLockSlim> are created with the <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> flag and do not allow recursion.</span></span> <span data-ttu-id="f409b-109">建议对所有新的开发使用此默认策略，因为递归引入了不必要的复杂性，并使代码更容易发生死锁。</span><span class="sxs-lookup"><span data-stu-id="f409b-109">This default policy is recommended for all new development, because recursion introduces unnecessary complications and makes your code more prone to deadlocks.</span></span> <span data-ttu-id="f409b-110">若要简化从使用 <xref:System.Threading.Monitor> 或 <xref:System.Threading.ReaderWriterLock>的现有项目的迁移，可以使用 <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> 标志创建允许递归的 <xref:System.Threading.ReaderWriterLockSlim> 实例。</span><span class="sxs-lookup"><span data-stu-id="f409b-110">To simplify migration from existing projects that use <xref:System.Threading.Monitor> or <xref:System.Threading.ReaderWriterLock>, you can use the <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> flag to create instances of <xref:System.Threading.ReaderWriterLockSlim> that allow recursion.</span></span>  
  
 <span data-ttu-id="f409b-111">线程可以在三种模式下进入锁定：读取模式、写入模式和可升级读取模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-111">A thread can enter the lock in three modes: read mode, write mode, and upgradeable read mode.</span></span> <span data-ttu-id="f409b-112">（在本主题的其余部分中，"可升级的读取模式" 称为 "可升级模式"，将优先使用 "输入 `x` 模式" 短语来 "在 `x` 模式下进入锁定"。）</span><span class="sxs-lookup"><span data-stu-id="f409b-112">(In the rest of this topic, "upgradeable read mode" is referred to as "upgradeable mode", and the phrase "enter `x` mode" is used in preference to the longer phrase "enter the lock in `x` mode".)</span></span>  
  
 <span data-ttu-id="f409b-113">不管递归策略如何，在任何时候都只能有一个线程处于写入模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-113">Regardless of recursion policy, only one thread can be in write mode at any time.</span></span> <span data-ttu-id="f409b-114">当线程处于写入模式时，任何其他线程都不能在任何模式下进入锁定状态。</span><span class="sxs-lookup"><span data-stu-id="f409b-114">When a thread is in write mode, no other thread can enter the lock in any mode.</span></span> <span data-ttu-id="f409b-115">在任何时候，只能有一个线程处于可升级模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-115">Only one thread can be in upgradeable mode at any time.</span></span> <span data-ttu-id="f409b-116">任意数量的线程都可以处于读取模式，并且在其他线程处于读取模式时，可以有一个处于可升级模式的线程。</span><span class="sxs-lookup"><span data-stu-id="f409b-116">Any number of threads can be in read mode, and there can be one thread in upgradeable mode while other threads are in read mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f409b-117">此类型实现 <xref:System.IDisposable> 接口。</span><span class="sxs-lookup"><span data-stu-id="f409b-117">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="f409b-118">在使用完类型后，您应直接或间接释放类型。</span><span class="sxs-lookup"><span data-stu-id="f409b-118">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="f409b-119">若要直接释放类型，请在 `try`/`catch` 块中调用其 <xref:System.IDisposable.Dispose%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f409b-119">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="f409b-120">若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。</span><span class="sxs-lookup"><span data-stu-id="f409b-120">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="f409b-121">有关详细信息，请参阅 <xref:System.IDisposable> 接口主题中的“使用实现 IDisposable 的对象”一节。</span><span class="sxs-lookup"><span data-stu-id="f409b-121">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="f409b-122"><xref:System.Threading.ReaderWriterLockSlim> 具有托管线程关联;也就是说，每个 <xref:System.Threading.Thread> 对象都必须进行自己的方法调用来进入和退出锁模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-122"><xref:System.Threading.ReaderWriterLockSlim> has managed thread affinity; that is, each <xref:System.Threading.Thread> object must make its own method calls to enter and exit lock modes.</span></span> <span data-ttu-id="f409b-123">任何线程都无法更改另一个线程的模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-123">No thread can change the mode of another thread.</span></span>  
  
 <span data-ttu-id="f409b-124">如果 <xref:System.Threading.ReaderWriterLockSlim> 不允许使用递归，尝试进入锁定的线程可能会出于多种原因而阻塞：</span><span class="sxs-lookup"><span data-stu-id="f409b-124">If a <xref:System.Threading.ReaderWriterLockSlim> does not allow recursion, a thread that tries to enter the lock can block for several reasons:</span></span>  
  
-   <span data-ttu-id="f409b-125">如果有等待进入写入模式的线程或在写入模式下有单个线程，则尝试进入读取模式的线程会被阻止。</span><span class="sxs-lookup"><span data-stu-id="f409b-125">A thread that tries to enter read mode blocks if there are threads waiting to enter write mode or if there is a single thread in write mode.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="f409b-126">在编写器排队时阻止新的读取器是优先写入器的锁公平策略。</span><span class="sxs-lookup"><span data-stu-id="f409b-126">Blocking new readers when writers are queued is a lock fairness policy that favors writers.</span></span> <span data-ttu-id="f409b-127">当前的公平策略在最常见的情况下，将公平与读者和编写者进行平衡，以提高吞吐量。</span><span class="sxs-lookup"><span data-stu-id="f409b-127">The current fairness policy balances fairness to readers and writers, to promote throughput in the most common scenarios.</span></span> <span data-ttu-id="f409b-128">未来版本的 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 可能会引入新的公平策略。</span><span class="sxs-lookup"><span data-stu-id="f409b-128">Future versions of the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] may introduce new fairness policies.</span></span>  
  
-   <span data-ttu-id="f409b-129">如果已存在处于可升级模式的线程，则为尝试进入可升级模式的线程，如果存在等待进入写入模式的线程，则为; 如果在写入模式下有单个线程，则为。</span><span class="sxs-lookup"><span data-stu-id="f409b-129">A thread that tries to enter upgradeable mode blocks if there is already a thread in upgradeable mode, if there are threads waiting to enter write mode, or if there is a single thread in write mode.</span></span>  
  
-   <span data-ttu-id="f409b-130">如果在三种模式中的任何一种模式下有线程，则尝试进入写入模式块的线程。</span><span class="sxs-lookup"><span data-stu-id="f409b-130">A thread that tries to enter write mode blocks if there is a thread in any of the three modes.</span></span>  
  
## <a name="upgrading-and-downgrading-locks"></a><span data-ttu-id="f409b-131">升级和降级锁</span><span class="sxs-lookup"><span data-stu-id="f409b-131">Upgrading and Downgrading Locks</span></span>  
 <span data-ttu-id="f409b-132">可升级模式适用于以下情况：线程通常会从受保护的资源中读取内容，但如果满足某些条件，则可能需要对其进行写入。</span><span class="sxs-lookup"><span data-stu-id="f409b-132">Upgradeable mode is intended for cases where a thread usually reads from the protected resource, but might need to write to it if some condition is met.</span></span> <span data-ttu-id="f409b-133">在可升级模式下进入 <xref:System.Threading.ReaderWriterLockSlim> 的线程具有对受保护资源的读取访问权限，并且可以通过调用 <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> 或 <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> 方法升级为写入模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-133">A thread that has entered a <xref:System.Threading.ReaderWriterLockSlim> in upgradeable mode has read access to the protected resource, and can upgrade to write mode by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> methods.</span></span> <span data-ttu-id="f409b-134">由于一次只能有一个处于可升级模式的线程，因此当不允许递归时，升级到写入模式不会死锁，这是默认策略。</span><span class="sxs-lookup"><span data-stu-id="f409b-134">Because there can be only one thread in upgradeable mode at a time, upgrading to write mode cannot deadlock when recursion is not allowed, which is the default policy.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f409b-135">不管递归策略如何，最初进入读取模式的线程都不允许升级到可升级模式或写入模式，因为这种模式产生了死锁的概率。</span><span class="sxs-lookup"><span data-stu-id="f409b-135">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span> <span data-ttu-id="f409b-136">例如，在读取模式下的两个线程都尝试进入写入模式时，它们会死锁。</span><span class="sxs-lookup"><span data-stu-id="f409b-136">For example, if two threads in read mode both try to enter write mode, they will deadlock.</span></span> <span data-ttu-id="f409b-137">可升级模式旨在避免这类死锁。</span><span class="sxs-lookup"><span data-stu-id="f409b-137">Upgradeable mode is designed to avoid such deadlocks.</span></span>  
  
 <span data-ttu-id="f409b-138">如果其他线程处于读取模式，则正在升级的线程会被阻止。</span><span class="sxs-lookup"><span data-stu-id="f409b-138">If there are other threads in read mode, the thread that is upgrading blocks.</span></span> <span data-ttu-id="f409b-139">当线程被阻止时，其他尝试进入读取模式的线程将被阻止。</span><span class="sxs-lookup"><span data-stu-id="f409b-139">While the thread is blocked, other threads that try to enter read mode are blocked.</span></span> <span data-ttu-id="f409b-140">如果所有线程都退出了读取模式，则被阻止的可升级线程进入写入模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-140">When all threads have exited from read mode, the blocked upgradeable thread enters write mode.</span></span> <span data-ttu-id="f409b-141">如果有其他等待进入写入模式的线程，它们将保持阻止状态，因为处于可升级模式的单个线程会阻止它们获取对资源的独占访问权限。</span><span class="sxs-lookup"><span data-stu-id="f409b-141">If there are other threads waiting to enter write mode, they remain blocked, because the single thread that is in upgradeable mode prevents them from gaining exclusive access to the resource.</span></span>  
  
 <span data-ttu-id="f409b-142">当处于可升级模式的线程退出写入模式时，除非有等待进入写入模式的线程，否则等待进入读取模式的其他线程可以执行此操作。</span><span class="sxs-lookup"><span data-stu-id="f409b-142">When the thread in upgradeable mode exits write mode, other threads that are waiting to enter read mode can do so, unless there are threads waiting to enter write mode.</span></span> <span data-ttu-id="f409b-143">处于可升级模式的线程可以无限期地升级和降级，只要它是写入受保护资源的唯一线程。</span><span class="sxs-lookup"><span data-stu-id="f409b-143">The thread in upgradeable mode can upgrade and downgrade indefinitely, as long as it is the only thread that writes to the protected resource.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f409b-144">如果允许多个线程进入写入模式或可升级模式，则不得允许一个线程独占可升级模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-144">If you allow multiple threads to enter write mode or upgradeable mode, you must not allow one thread to monopolize upgradeable mode.</span></span> <span data-ttu-id="f409b-145">否则，尝试直接进入写入模式的线程会无限期阻止，而在被阻止时，其他线程将无法进入读取模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-145">Otherwise, threads that try to enter write mode directly will be blocked indefinitely, and while they are blocked, other threads will be unable to enter read mode.</span></span>  
  
 <span data-ttu-id="f409b-146">处于可升级模式的线程可以通过首先调用 <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> 方法，然后调用 <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> 方法，降级到读取模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-146">A thread in upgradeable mode can downgrade to read mode by first calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method and then calling the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method.</span></span> <span data-ttu-id="f409b-147">所有锁递归策略都允许使用此降级模式，甚至 <xref:System.Threading.LockRecursionPolicy.NoRecursion>。</span><span class="sxs-lookup"><span data-stu-id="f409b-147">This downgrade pattern is allowed for all lock recursion policies, even <xref:System.Threading.LockRecursionPolicy.NoRecursion>.</span></span>  
  
 <span data-ttu-id="f409b-148">降级到读取模式后，线程无法重新进入可升级模式，除非它已退出读取模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-148">After downgrading to read mode, a thread cannot reenter upgradeable mode until it has exited from read mode.</span></span>  
  
## <a name="entering-the-lock-recursively"></a><span data-ttu-id="f409b-149">以递归方式进入锁定</span><span class="sxs-lookup"><span data-stu-id="f409b-149">Entering the Lock Recursively</span></span>  
 <span data-ttu-id="f409b-150">您可以通过使用指定锁定策略的 <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> 构造函数并指定 <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>来创建支持递归锁定条目的 <xref:System.Threading.ReaderWriterLockSlim>。</span><span class="sxs-lookup"><span data-stu-id="f409b-150">You can create a <xref:System.Threading.ReaderWriterLockSlim> that supports recursive lock entry by using the <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> constructor that specifies lock policy, and specifying <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f409b-151">建议不要将递归用于新的开发，因为这会引入不必要的复杂性，并使代码更容易发生死锁。</span><span class="sxs-lookup"><span data-stu-id="f409b-151">The use of recursion is not recommended for new development, because it introduces unnecessary complications and makes your code more prone to deadlocks.</span></span>  
  
 <span data-ttu-id="f409b-152">对于允许递归的 <xref:System.Threading.ReaderWriterLockSlim>，可以通过以下方式了解线程可输入的模式：</span><span class="sxs-lookup"><span data-stu-id="f409b-152">For a <xref:System.Threading.ReaderWriterLockSlim> that allows recursion, the following can be said about the modes a thread can enter:</span></span>  
  
-   <span data-ttu-id="f409b-153">处于读取模式的线程可以以递归方式进入读取模式，但不能进入写入模式或可升级模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-153">A thread in read mode can enter read mode recursively, but cannot enter write mode or upgradeable mode.</span></span> <span data-ttu-id="f409b-154">如果尝试执行此操作，则会引发 <xref:System.Threading.LockRecursionException>。</span><span class="sxs-lookup"><span data-stu-id="f409b-154">If it tries to do this, a <xref:System.Threading.LockRecursionException> is thrown.</span></span> <span data-ttu-id="f409b-155">进入读取模式，然后进入写入模式或可升级模式是一种具有极大的死锁概率的模式，因此不允许这样做。</span><span class="sxs-lookup"><span data-stu-id="f409b-155">Entering read mode and then entering write mode or upgradeable mode is a pattern with a strong probability of deadlocks, so it is not allowed.</span></span> <span data-ttu-id="f409b-156">如前文所述，可升级模式适用于需要升级锁定的情况。</span><span class="sxs-lookup"><span data-stu-id="f409b-156">As discussed earlier, upgradeable mode is provided for cases where it is necessary to upgrade a lock.</span></span>  
  
-   <span data-ttu-id="f409b-157">处于可升级模式的线程可以进入写入模式和/或读取模式，并且可以递归输入三种模式中的任何一种。</span><span class="sxs-lookup"><span data-stu-id="f409b-157">A thread in upgradeable mode can enter write mode and/or read mode, and can enter any of the three modes recursively.</span></span> <span data-ttu-id="f409b-158">但是，如果有其他线程处于读取模式，则尝试进入写入模式块。</span><span class="sxs-lookup"><span data-stu-id="f409b-158">However, an attempt to enter write mode blocks if there are other threads in read mode.</span></span>  
  
-   <span data-ttu-id="f409b-159">处于写入模式的线程可以进入读取模式和/或可升级模式，并且可以递归输入三种模式中的任何一种。</span><span class="sxs-lookup"><span data-stu-id="f409b-159">A thread in write mode can enter read mode and/or upgradeable mode, and can enter any of the three modes recursively.</span></span>  
  
-   <span data-ttu-id="f409b-160">未进入锁定状态的线程可以进入任何模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-160">A thread that has not entered the lock can enter any mode.</span></span> <span data-ttu-id="f409b-161">尝试输入非递归锁的原因与此尝试相同。</span><span class="sxs-lookup"><span data-stu-id="f409b-161">This attempt can block for the same reasons as an attempt to enter a non-recursive lock.</span></span>  
  
 <span data-ttu-id="f409b-162">线程可以退出它已经按任意顺序进入的模式，只要它进入该模式时，它的每一种模式就会发生的次数完全相同。</span><span class="sxs-lookup"><span data-stu-id="f409b-162">A thread can exit the modes it has entered in any order, as long as it exits each mode exactly as many times as it entered that mode.</span></span> <span data-ttu-id="f409b-163">如果线程尝试退出模式的次数过多，或退出未输入的模式，则会引发 <xref:System.Threading.SynchronizationLockException>。</span><span class="sxs-lookup"><span data-stu-id="f409b-163">If a thread tries to exit a mode too many times, or to exit a mode it has not entered, a <xref:System.Threading.SynchronizationLockException> is thrown.</span></span>  
  
## <a name="lock-states"></a><span data-ttu-id="f409b-164">锁定状态</span><span class="sxs-lookup"><span data-stu-id="f409b-164">Lock States</span></span>  
 <span data-ttu-id="f409b-165">你可能会发现，将锁视为其状态是非常有用的。</span><span class="sxs-lookup"><span data-stu-id="f409b-165">You may find it useful to think of the lock in terms of its states.</span></span> <span data-ttu-id="f409b-166"><xref:System.Threading.ReaderWriterLockSlim> 可以是以下四种状态之一：未输入、读取、升级和写入。</span><span class="sxs-lookup"><span data-stu-id="f409b-166">A <xref:System.Threading.ReaderWriterLockSlim> can be in one of four states: not entered, read, upgrade, and write.</span></span>  
  
-   <span data-ttu-id="f409b-167">未输入：在此状态下，没有线程进入锁定状态（或所有线程都已退出锁）。</span><span class="sxs-lookup"><span data-stu-id="f409b-167">Not entered: In this state, no threads have entered the lock (or all threads have exited the lock).</span></span>  
  
-   <span data-ttu-id="f409b-168">读取：在此状态中，一个或多个线程已进入对受保护资源的读取访问权限。</span><span class="sxs-lookup"><span data-stu-id="f409b-168">Read: In this state, one or more threads have entered the lock for read access to the protected resource.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="f409b-169">线程可以使用 <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> 或 <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> 方法进入读取模式锁定状态，也可以通过从可升级模式降级进入。</span><span class="sxs-lookup"><span data-stu-id="f409b-169">A thread can enter the lock in read mode by using the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> methods, or by downgrading from upgradeable mode.</span></span>  
  
-   <span data-ttu-id="f409b-170">升级：在此状态下，一个线程已进入具有 "升级到写入访问权限" 选项（即在可升级模式下）的 "读取" 访问锁定，并且零个或多个线程已进入读取访问锁定状态。</span><span class="sxs-lookup"><span data-stu-id="f409b-170">Upgrade: In this state, one thread has entered the lock for read access with the option to upgrade to write access (that is, in upgradeable mode), and zero or more threads have entered the lock for read access.</span></span> <span data-ttu-id="f409b-171">一次不能有多个线程可使用升级选项输入锁定;阻止尝试进入可升级模式的其他线程。</span><span class="sxs-lookup"><span data-stu-id="f409b-171">No more than one thread at a time can enter the lock with the option to upgrade; additional threads that try to enter upgradeable mode are blocked.</span></span>  
  
-   <span data-ttu-id="f409b-172">写入：在此状态下，一个线程已进入对受保护资源的写访问锁定。</span><span class="sxs-lookup"><span data-stu-id="f409b-172">Write: In this state, one thread has entered the lock for write access to the protected resource.</span></span> <span data-ttu-id="f409b-173">该线程独占持有锁。</span><span class="sxs-lookup"><span data-stu-id="f409b-173">That thread has exclusive possession of the lock.</span></span> <span data-ttu-id="f409b-174">会阻止任何其他尝试输入锁定的其他线程。</span><span class="sxs-lookup"><span data-stu-id="f409b-174">Any other thread that tries to enter the lock for any reason is blocked.</span></span>  
  
 <span data-ttu-id="f409b-175">下表描述了在线程 `t` 采用最左侧的列中所述的操作时，锁定状态与不允许递归的锁之间的转换。</span><span class="sxs-lookup"><span data-stu-id="f409b-175">The following table describes the transitions between lock states, for locks that do not allow recursion, when a thread `t` takes the action described in the leftmost column.</span></span> <span data-ttu-id="f409b-176">执行操作时，`t` 没有模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-176">At the time it takes the action, `t` has no mode.</span></span> <span data-ttu-id="f409b-177">（表脚注中介绍了 `t` 处于可升级模式的特殊情况。）最上面一行介绍锁定的开始状态。</span><span class="sxs-lookup"><span data-stu-id="f409b-177">(The special case where `t` is in upgradeable mode is described in the table footnotes.) The top row describes the starting state of the lock.</span></span> <span data-ttu-id="f409b-178">单元格描述对线程发生的操作，并在括号中显示锁定状态的更改。</span><span class="sxs-lookup"><span data-stu-id="f409b-178">The cells describe what happens to the thread, and show changes to the lock state in parentheses.</span></span>  
  
||<span data-ttu-id="f409b-179">未输入（N）</span><span class="sxs-lookup"><span data-stu-id="f409b-179">Not entered (N)</span></span>|<span data-ttu-id="f409b-180">读取（R）</span><span class="sxs-lookup"><span data-stu-id="f409b-180">Read (R)</span></span>|<span data-ttu-id="f409b-181">升级（U）</span><span class="sxs-lookup"><span data-stu-id="f409b-181">Upgrade (U)</span></span>|<span data-ttu-id="f409b-182">写入（W）</span><span class="sxs-lookup"><span data-stu-id="f409b-182">Write (W)</span></span>|  
|-|-----------------------|----------------|-------------------|-----------------|  
|<span data-ttu-id="f409b-183">`t` 进入读取模式</span><span class="sxs-lookup"><span data-stu-id="f409b-183">`t` enters read mode</span></span>|<span data-ttu-id="f409b-184">`t` 进入（R）。</span><span class="sxs-lookup"><span data-stu-id="f409b-184">`t` enters (R).</span></span>|<span data-ttu-id="f409b-185">如果线程正在等待写入模式，则 `t` 块;否则，`t` 进入。</span><span class="sxs-lookup"><span data-stu-id="f409b-185">`t` blocks if threads are waiting for write mode; otherwise, `t` enters.</span></span>|<span data-ttu-id="f409b-186">如果线程正在等待写入模式，则 `t` 块;否则，`t` 进入。<sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="f409b-186">`t` blocks if threads are waiting for write mode; otherwise, `t` enters.<sup>1</sup></span></span>|<span data-ttu-id="f409b-187">`t` 块。</span><span class="sxs-lookup"><span data-stu-id="f409b-187">`t` blocks.</span></span>|  
|<span data-ttu-id="f409b-188">`t` 进入可升级模式</span><span class="sxs-lookup"><span data-stu-id="f409b-188">`t` enters upgradeable mode</span></span>|<span data-ttu-id="f409b-189">`t` 进入（U）。</span><span class="sxs-lookup"><span data-stu-id="f409b-189">`t` enters (U).</span></span>|<span data-ttu-id="f409b-190">如果线程正在等待写入模式或升级模式，则 `t` 块;否则，`t` 进入（U）。</span><span class="sxs-lookup"><span data-stu-id="f409b-190">`t` blocks if threads are waiting for write mode or upgrade mode; otherwise, `t` enters (U).</span></span>|<span data-ttu-id="f409b-191">`t` 块。</span><span class="sxs-lookup"><span data-stu-id="f409b-191">`t` blocks.</span></span>|<span data-ttu-id="f409b-192">`t` 块。</span><span class="sxs-lookup"><span data-stu-id="f409b-192">`t` blocks.</span></span>|  
|<span data-ttu-id="f409b-193">`t` 进入写入模式</span><span class="sxs-lookup"><span data-stu-id="f409b-193">`t` enters write mode</span></span>|<span data-ttu-id="f409b-194">`t` 进入（W）。</span><span class="sxs-lookup"><span data-stu-id="f409b-194">`t` enters (W).</span></span>|<span data-ttu-id="f409b-195">`t` 块。</span><span class="sxs-lookup"><span data-stu-id="f409b-195">`t` blocks.</span></span>|<span data-ttu-id="f409b-196">`t` 块。<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="f409b-196">`t` blocks.<sup>2</sup></span></span>|<span data-ttu-id="f409b-197">`t` 块。</span><span class="sxs-lookup"><span data-stu-id="f409b-197">`t` blocks.</span></span>|  
  
 <span data-ttu-id="f409b-198">如果 `t` 在可升级模式下启动，则为<sup>1</sup> ; 否则进入读取模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-198"><sup>1</sup> If `t` starts out in upgradeable mode, it enters read mode.</span></span> <span data-ttu-id="f409b-199">此操作永远不会阻止。</span><span class="sxs-lookup"><span data-stu-id="f409b-199">This action never blocks.</span></span> <span data-ttu-id="f409b-200">锁定状态不会更改。</span><span class="sxs-lookup"><span data-stu-id="f409b-200">The lock state does not change.</span></span> <span data-ttu-id="f409b-201">（然后，线程可以通过退出可升级模式来完成降级到读取模式。）</span><span class="sxs-lookup"><span data-stu-id="f409b-201">(The thread can then complete a downgrade to read mode by exiting upgradeable mode.)</span></span>  
  
 <span data-ttu-id="f409b-202"><sup>2</sup>如果 `t` 在可升级模式下启动，则会阻止处于读取模式的线程。</span><span class="sxs-lookup"><span data-stu-id="f409b-202"><sup>2</sup> If `t` starts out in upgradeable mode, it blocks if there are threads in read mode.</span></span> <span data-ttu-id="f409b-203">否则，会升级到写入模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-203">Otherwise it upgrades to write mode.</span></span> <span data-ttu-id="f409b-204">锁定状态将更改为写入（W）。</span><span class="sxs-lookup"><span data-stu-id="f409b-204">The lock state changes to Write (W).</span></span> <span data-ttu-id="f409b-205">如果 `t` 块是因为在读取模式下有线程，则当最后一个线程退出读取模式（即使有等待进入写入模式的线程）时，它将进入写入模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-205">If `t` blocks because there are threads in read mode, it enters write mode as soon as the last thread exits read mode, even if there are threads waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="f409b-206">当由于线程退出锁而发生状态更改时，将选择下一个要唤醒的线程，如下所示：</span><span class="sxs-lookup"><span data-stu-id="f409b-206">When a state change occurs because a thread exits the lock, the next thread to be awakened is selected as follows:</span></span>  
  
-   <span data-ttu-id="f409b-207">首先，线程正在等待写入模式，并且已经处于可升级模式（最多可以有一个此类线程）。</span><span class="sxs-lookup"><span data-stu-id="f409b-207">First, a thread that is waiting for write mode and is already in upgradeable mode (there can be at most one such thread).</span></span>  
  
-   <span data-ttu-id="f409b-208">如果失败，则为等待写入模式的线程。</span><span class="sxs-lookup"><span data-stu-id="f409b-208">Failing that, a thread that is waiting for write mode.</span></span>  
  
-   <span data-ttu-id="f409b-209">如果失败，则为等待可升级模式的线程。</span><span class="sxs-lookup"><span data-stu-id="f409b-209">Failing that, a thread that is waiting for upgradeable mode.</span></span>  
  
-   <span data-ttu-id="f409b-210">如果未成功，则为等待读取模式的所有线程。</span><span class="sxs-lookup"><span data-stu-id="f409b-210">Failing that, all threads that are waiting for read mode.</span></span>  
  
 <span data-ttu-id="f409b-211">在前两种情况下，该锁的后续状态始终为 Write （W），在第三种情况下为 Upgrade （U）。</span><span class="sxs-lookup"><span data-stu-id="f409b-211">The subsequent state of the lock is always Write (W) in the first two cases and Upgrade (U) in the third case, regardless of the state of the lock when the exiting thread triggered the state change.</span></span> <span data-ttu-id="f409b-212">在最后一种情况下，如果状态更改后有一个处于可升级模式的线程处于可升级模式，则锁定的状态为 "升级（U）"; 否则为 "读取（R）"。</span><span class="sxs-lookup"><span data-stu-id="f409b-212">In the last case, the state of the lock is Upgrade (U) if there is a thread in upgradeable mode after the state change, and Read (R) otherwise, regardless of the prior state.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f409b-213">下面的示例演示了一个简单的同步缓存，该缓存包含包含整数键的字符串。</span><span class="sxs-lookup"><span data-stu-id="f409b-213">The following example shows a simple synchronized cache that holds strings with integer keys.</span></span> <span data-ttu-id="f409b-214"><xref:System.Threading.ReaderWriterLockSlim> 的实例用于同步对充当内部缓存的 <xref:System.Collections.Generic.Dictionary%602> 的访问。</span><span class="sxs-lookup"><span data-stu-id="f409b-214">An instance of <xref:System.Threading.ReaderWriterLockSlim> is used to synchronize access to the <xref:System.Collections.Generic.Dictionary%602> that serves as the inner cache.</span></span>  
  
 <span data-ttu-id="f409b-215">该示例包括要添加到缓存中、从缓存中删除以及从缓存中读取的简单方法。</span><span class="sxs-lookup"><span data-stu-id="f409b-215">The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</span></span> <span data-ttu-id="f409b-216">为了演示超时，此示例包含一个方法，该方法仅在指定的超时时间内添加到缓存中。</span><span class="sxs-lookup"><span data-stu-id="f409b-216">To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</span></span>  
  
 <span data-ttu-id="f409b-217">为了演示可升级模式，该示例包含一个方法，该方法检索与键关联的值，并将其与新值进行比较。</span><span class="sxs-lookup"><span data-stu-id="f409b-217">To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="f409b-218">如果值不变，则方法将返回一个状态，指示没有任何更改。</span><span class="sxs-lookup"><span data-stu-id="f409b-218">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="f409b-219">如果未找到键的值，则插入键/值对。</span><span class="sxs-lookup"><span data-stu-id="f409b-219">If no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="f409b-220">如果值已更改，则会更新。</span><span class="sxs-lookup"><span data-stu-id="f409b-220">If the value has changed, it is updated.</span></span> <span data-ttu-id="f409b-221">可升级模式允许线程从读取访问权限升级到按需写入访问权限，而不会导致死锁风险。</span><span class="sxs-lookup"><span data-stu-id="f409b-221">Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</span></span>  
  
 <span data-ttu-id="f409b-222">该示例包含一个嵌套枚举，该枚举指定演示可升级模式的方法的返回值。</span><span class="sxs-lookup"><span data-stu-id="f409b-222">The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</span></span>  
  
 <span data-ttu-id="f409b-223">该示例使用无参数构造函数创建锁，因此不允许使用递归。</span><span class="sxs-lookup"><span data-stu-id="f409b-223">The example uses the parameterless constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="f409b-224">当锁定不允许递归时，对 <xref:System.Threading.ReaderWriterLockSlim> 进行编程更简单，并且不易出错。</span><span class="sxs-lookup"><span data-stu-id="f409b-224">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 <span data-ttu-id="f409b-225">然后，下面的代码使用 `SynchronizedCache` 对象存储蔬菜名称的字典。</span><span class="sxs-lookup"><span data-stu-id="f409b-225">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="f409b-226">它创建三个任务。</span><span class="sxs-lookup"><span data-stu-id="f409b-226">It creates three tasks.</span></span> <span data-ttu-id="f409b-227">首先将存储在数组中的蔬菜名称写入 `SynchronizedCache` 实例。</span><span class="sxs-lookup"><span data-stu-id="f409b-227">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="f409b-228">第二个和第三个任务以升序顺序显示了蔬菜的名称（从低索引到高索引）。</span><span class="sxs-lookup"><span data-stu-id="f409b-228">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="f409b-229">最终任务会搜索字符串 "cucumber"，找到它时，将调用 <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> 方法来替换字符串 "绿色 bean"。</span><span class="sxs-lookup"><span data-stu-id="f409b-229">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="f409b-230">此类型是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="f409b-230">This type is thread safe.</span></span></threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f409b-231">初始化 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="f409b-231">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f409b-232">使用默认属性值初始化 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="f409b-232">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class with default property values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f409b-233">使用此构造函数初始化的 <xref:System.Threading.ReaderWriterLockSlim> 不允许使用递归。</span><span class="sxs-lookup"><span data-stu-id="f409b-233">A <xref:System.Threading.ReaderWriterLockSlim> that is initialized with this constructor does not allow recursion.</span></span> <span data-ttu-id="f409b-234">也就是说，<xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> 属性将返回 <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f409b-234">That is, the <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> property returns <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f409b-235">有关递归策略及其效果的详细信息，请参阅 <xref:System.Threading.LockRecursionPolicy> 枚举和 <xref:System.Threading.ReaderWriterLockSlim> 类。</span><span class="sxs-lookup"><span data-stu-id="f409b-235">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f409b-236">下面的示例演示了一个简单的同步缓存，该缓存包含包含整数键的字符串。</span><span class="sxs-lookup"><span data-stu-id="f409b-236">The following example shows a simple synchronized cache that holds strings with integer keys.</span></span> <span data-ttu-id="f409b-237"><xref:System.Threading.ReaderWriterLockSlim> 的实例用于同步对充当内部缓存的 <xref:System.Collections.Generic.Dictionary%602> 的访问。</span><span class="sxs-lookup"><span data-stu-id="f409b-237">An instance of <xref:System.Threading.ReaderWriterLockSlim> is used to synchronize access to the <xref:System.Collections.Generic.Dictionary%602> that serves as the inner cache.</span></span> <span data-ttu-id="f409b-238">无参数构造函数用于创建锁。</span><span class="sxs-lookup"><span data-stu-id="f409b-238">The parameterless constructor is used to create the lock.</span></span>  
  
 <span data-ttu-id="f409b-239">该示例包括要添加到缓存中、从缓存中删除以及从缓存中读取的简单方法。</span><span class="sxs-lookup"><span data-stu-id="f409b-239">The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</span></span> <span data-ttu-id="f409b-240">为了演示超时，此示例包含一个方法，该方法仅在指定的超时时间内添加到缓存中。</span><span class="sxs-lookup"><span data-stu-id="f409b-240">To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</span></span>  
  
 <span data-ttu-id="f409b-241">为了演示可升级模式，该示例包含一个方法，该方法检索与键关联的值，并将其与新值进行比较。</span><span class="sxs-lookup"><span data-stu-id="f409b-241">To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="f409b-242">如果值不变，则方法将返回一个状态，指示没有任何更改。</span><span class="sxs-lookup"><span data-stu-id="f409b-242">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="f409b-243">如果未找到键的值，则插入键/值对。</span><span class="sxs-lookup"><span data-stu-id="f409b-243">If no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="f409b-244">如果值已更改，则会更新。</span><span class="sxs-lookup"><span data-stu-id="f409b-244">If the value has changed, it is updated.</span></span> <span data-ttu-id="f409b-245">可升级模式允许线程从读取访问权限升级到按需写入访问权限，而不会导致死锁风险。</span><span class="sxs-lookup"><span data-stu-id="f409b-245">Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</span></span>  
  
 <span data-ttu-id="f409b-246">该示例包含一个嵌套枚举，该枚举指定演示可升级模式的方法的返回值。</span><span class="sxs-lookup"><span data-stu-id="f409b-246">The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</span></span>  
  
 <span data-ttu-id="f409b-247">该示例使用无参数构造函数创建锁，因此不允许使用递归。</span><span class="sxs-lookup"><span data-stu-id="f409b-247">The example uses the parameterless constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="f409b-248">当锁定不允许递归时，对 <xref:System.Threading.ReaderWriterLockSlim> 进行编程更简单，并且不易出错。</span><span class="sxs-lookup"><span data-stu-id="f409b-248">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 <span data-ttu-id="f409b-249">然后，下面的代码使用 `SynchronizedCache` 对象存储蔬菜名称的字典。</span><span class="sxs-lookup"><span data-stu-id="f409b-249">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="f409b-250">它创建三个任务。</span><span class="sxs-lookup"><span data-stu-id="f409b-250">It creates three tasks.</span></span> <span data-ttu-id="f409b-251">首先将存储在数组中的蔬菜名称写入 `SynchronizedCache` 实例。</span><span class="sxs-lookup"><span data-stu-id="f409b-251">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="f409b-252">第二个和第三个任务以升序顺序显示了蔬菜的名称（从低索引到高索引）。</span><span class="sxs-lookup"><span data-stu-id="f409b-252">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="f409b-253">最终任务会搜索字符串 "cucumber"，找到它时，将调用 <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> 方法来替换字符串 "绿色 bean"。</span><span class="sxs-lookup"><span data-stu-id="f409b-253">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim (System.Threading.LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LockRecursionPolicy recursionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (recursionPolicy As LockRecursionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim(System::Threading::LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="F#" Value="new System.Threading.ReaderWriterLockSlim : System.Threading.LockRecursionPolicy -&gt; System.Threading.ReaderWriterLockSlim" Usage="new System.Threading.ReaderWriterLockSlim recursionPolicy" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="recursionPolicy" Type="System.Threading.LockRecursionPolicy" />
      </Parameters>
      <Docs>
        <param name="recursionPolicy"><span data-ttu-id="f409b-254">枚举值之一，用于指定锁定递归策略。</span><span class="sxs-lookup"><span data-stu-id="f409b-254">One of the enumeration values that specifies the lock recursion policy.</span></span></param>
        <summary><span data-ttu-id="f409b-255">在指定锁定递归策略的情况下初始化 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="f409b-255">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class, specifying the lock recursion policy.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f409b-256">递归策略确定对多次输入锁定的线程的限制。</span><span class="sxs-lookup"><span data-stu-id="f409b-256">Recursion policy determines the restrictions on threads that enter the lock more than once.</span></span> <span data-ttu-id="f409b-257">例如，如果使用 <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> 创建了一个锁，并且某个线程已进入读取模式锁定状态，则在该线程尝试重新进入读取模式锁定状态时将引发 <xref:System.Threading.LockRecursionException>。</span><span class="sxs-lookup"><span data-stu-id="f409b-257">For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode.</span></span> <span data-ttu-id="f409b-258">同样，如果某个线程进入写入模式锁定状态，则如果该线程尝试在任何模式下重新进入锁定，则会引发 <xref:System.Threading.LockRecursionException>。</span><span class="sxs-lookup"><span data-stu-id="f409b-258">Similarly, if a thread has entered the lock in write mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in any mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f409b-259">可升级模式的线程可以升级到写入模式或降级到读取模式，而不考虑锁定递归策略设置。</span><span class="sxs-lookup"><span data-stu-id="f409b-259">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</span></span>  
  
 <span data-ttu-id="f409b-260">不管递归策略如何，最初进入读取模式的线程都不允许升级到可升级模式或写入模式，因为这种模式产生了死锁的概率。</span><span class="sxs-lookup"><span data-stu-id="f409b-260">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span>  
  
 <span data-ttu-id="f409b-261">有关递归策略及其效果的详细信息，请参阅 <xref:System.Threading.LockRecursionPolicy> 枚举和 <xref:System.Threading.ReaderWriterLockSlim> 类。</span><span class="sxs-lookup"><span data-stu-id="f409b-261">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f409b-262">下面的示例演示两个异常方案，一个依赖于 <xref:System.Threading.LockRecursionPolicy> 设置，另一个不依赖。</span><span class="sxs-lookup"><span data-stu-id="f409b-262">The following example shows two exception scenarios, one that depends on the <xref:System.Threading.LockRecursionPolicy> setting and one that does not.</span></span>  
  
 <span data-ttu-id="f409b-263">在第一个方案中，线程进入读取模式，然后尝试以递归方式进入读取模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-263">In the first scenario, the thread enters read mode and then tries to enter read mode recursively.</span></span> <span data-ttu-id="f409b-264">如果 <xref:System.Threading.ReaderWriterLockSlim> 是使用无参数构造函数创建的，而该构造函数将递归策略设置为 <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="f409b-264">If the <xref:System.Threading.ReaderWriterLockSlim> is created by using the parameterless constructor, which sets recursion policy to <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="f409b-265">如果使用 <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> 来创建 <xref:System.Threading.ReaderWriterLockSlim>，则不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="f409b-265">If <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> is used to create the <xref:System.Threading.ReaderWriterLockSlim>, no exception is thrown.</span></span>  
  
 <span data-ttu-id="f409b-266">在第二种情况下，线程进入读取模式，然后尝试进入写入模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-266">In the second scenario, the thread enters read mode and then tries to enter write mode.</span></span> <span data-ttu-id="f409b-267">无论锁递归策略如何，都将引发 <xref:System.Threading.LockRecursionException>。</span><span class="sxs-lookup"><span data-stu-id="f409b-267"><xref:System.Threading.LockRecursionException> is thrown regardless of the lock recursion policy.</span></span>  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#12)] 
[!code-vb[System.Threading.LockRecursionPolicy#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#12)]  
  
 <span data-ttu-id="f409b-268">然后，下面的代码使用 `SynchronizedCache` 对象存储蔬菜名称的字典。</span><span class="sxs-lookup"><span data-stu-id="f409b-268">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="f409b-269">它创建三个任务。</span><span class="sxs-lookup"><span data-stu-id="f409b-269">It creates three tasks.</span></span> <span data-ttu-id="f409b-270">首先将存储在数组中的蔬菜名称写入 `SynchronizedCache` 实例。</span><span class="sxs-lookup"><span data-stu-id="f409b-270">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="f409b-271">第二个和第三个任务以升序顺序显示了蔬菜的名称（从低索引到高索引）。</span><span class="sxs-lookup"><span data-stu-id="f409b-271">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="f409b-272">最终任务会搜索字符串 "cucumber"，找到它时，将调用 <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> 方法来替换字符串 "绿色 bean"。</span><span class="sxs-lookup"><span data-stu-id="f409b-272">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#13)] 
[!code-vb[System.Threading.LockRecursionPolicy#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
        <altmember cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="CurrentReadCount">
      <MemberSignature Language="C#" Value="public int CurrentReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f409b-273">获取已进入读取模式锁定状态的独有线程的总数。</span><span class="sxs-lookup"><span data-stu-id="f409b-273">Gets the total number of unique threads that have entered the lock in read mode.</span></span></summary>
        <value><span data-ttu-id="f409b-274">已进入读取模式锁定状态的独有线程的数量。</span><span class="sxs-lookup"><span data-stu-id="f409b-274">The number of unique threads that have entered the lock in read mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f409b-275">即使锁允许递归并且线程已多次进入读取模式，也只会对线程计数一次。</span><span class="sxs-lookup"><span data-stu-id="f409b-275">A thread is counted only once, even if the lock allows recursion and the thread has entered read mode multiple times.</span></span>  
  
 <span data-ttu-id="f409b-276">此属性仅用于调试、分析和日志记录目的，而不用于控制算法的行为。</span><span class="sxs-lookup"><span data-stu-id="f409b-276">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="f409b-277">计算结果后，结果就会更改。</span><span class="sxs-lookup"><span data-stu-id="f409b-277">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="f409b-278">因此，根据此属性做出决策并不安全。</span><span class="sxs-lookup"><span data-stu-id="f409b-278">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f409b-279">下面的示例演示如何使用 <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A> 属性在读取模式中的线程数超过阈值时生成事件日志项。</span><span class="sxs-lookup"><span data-stu-id="f409b-279">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A> property to generate an event log entry if the number of threads in read mode exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#2)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#11)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="readerWriterLockSlim.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f409b-280">释放由 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 类的当前实例占用的所有资源。</span><span class="sxs-lookup"><span data-stu-id="f409b-280">Releases all resources used by the current instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f409b-281">在完成使用 <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> 后，应调用 <xref:System.Threading.ReaderWriterLockSlim>。</span><span class="sxs-lookup"><span data-stu-id="f409b-281">Call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> when you are finished using the <xref:System.Threading.ReaderWriterLockSlim>.</span></span> <span data-ttu-id="f409b-282"><xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> 方法使 <xref:System.Threading.ReaderWriterLockSlim> 处于不可用状态。</span><span class="sxs-lookup"><span data-stu-id="f409b-282">The <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> method leaves the <xref:System.Threading.ReaderWriterLockSlim> in an unusable state.</span></span> <span data-ttu-id="f409b-283">调用 <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>后，必须释放对 <xref:System.Threading.ReaderWriterLockSlim> 的所有引用，以便垃圾回收器可以回收 <xref:System.Threading.ReaderWriterLockSlim> 占用的内存。</span><span class="sxs-lookup"><span data-stu-id="f409b-283">After calling <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>, you must release all references to the <xref:System.Threading.ReaderWriterLockSlim> so the garbage collector can reclaim the memory that the <xref:System.Threading.ReaderWriterLockSlim> was occupying.</span></span> <span data-ttu-id="f409b-284">有关详细信息，请参阅[清理非托管资源](/dotnet/standard/garbage-collection/unmanaged)和[实现 Dispose 方法](/dotnet/standard/garbage-collection/implementing-dispose)。</span><span class="sxs-lookup"><span data-stu-id="f409b-284">For more information, see [Cleaning Up Unmanaged Resources](/dotnet/standard/garbage-collection/unmanaged) and [Implementing a Dispose Method](/dotnet/standard/garbage-collection/implementing-dispose).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f409b-285">在释放对 <xref:System.Threading.ReaderWriterLockSlim> 对象的最后一个引用之前，请始终调用 <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>。</span><span class="sxs-lookup"><span data-stu-id="f409b-285">Always call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> before you release your last reference to the <xref:System.Threading.ReaderWriterLockSlim> object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="f409b-286"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> 大于零。</span><span class="sxs-lookup"><span data-stu-id="f409b-286"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> is greater than zero.</span></span>  
  
<span data-ttu-id="f409b-287">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f409b-287">-or-</span></span> 
 <span data-ttu-id="f409b-288"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> 大于零。</span><span class="sxs-lookup"><span data-stu-id="f409b-288"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> is greater than zero.</span></span>  
  
<span data-ttu-id="f409b-289">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f409b-289">-or-</span></span> 
 <span data-ttu-id="f409b-290"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> 大于零。</span><span class="sxs-lookup"><span data-stu-id="f409b-290"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> is greater than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnterReadLock">
      <MemberSignature Language="C#" Value="public void EnterReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f409b-291">尝试进入读取模式锁定状态。</span><span class="sxs-lookup"><span data-stu-id="f409b-291">Tries to enter the lock in read mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f409b-292">此方法会一直阻止，直到调用线程进入锁定状态，因此可能永远不会返回。</span><span class="sxs-lookup"><span data-stu-id="f409b-292">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="f409b-293">使用 <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> 方法可在指定的时间间隔内阻塞，如果调用线程未在该间隔内进入读取模式，则返回。</span><span class="sxs-lookup"><span data-stu-id="f409b-293">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered read mode during that interval.</span></span>  
  
 <span data-ttu-id="f409b-294">多个线程可以同时进入读取模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-294">Multiple threads can enter read mode at the same time.</span></span>  
  
 <span data-ttu-id="f409b-295">如果一个或多个线程正在等待进入写入模式，则调用 <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> 方法的线程将受阻，直到这些线程超时或进入写入模式，然后再从中退出。</span><span class="sxs-lookup"><span data-stu-id="f409b-295">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f409b-296">如果某个锁允许递归，则进入读取模式锁定状态的线程可以以递归方式进入读取模式，即使其他线程正在等待进入写入模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-296">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="f409b-297">当其他线程处于读取模式时，最多只能有一个线程处于可升级模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-297">At most one thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="f409b-298">如果其他线程正在等待进入可升级模式，并且没有等待进入写入模式的线程，则调用 <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> 方法的线程会立即进入读取模式，而不会阻止。</span><span class="sxs-lookup"><span data-stu-id="f409b-298">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f409b-299">下面的示例演示如何使用 <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> 方法进入读取模式锁定状态。</span><span class="sxs-lookup"><span data-stu-id="f409b-299">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method to enter the lock in read mode.</span></span> <span data-ttu-id="f409b-300">示例中所示的方法检索与键关联的值。</span><span class="sxs-lookup"><span data-stu-id="f409b-300">The method shown in the example retrieves the value associated with a key.</span></span> <span data-ttu-id="f409b-301">如果未找到该键，则允许由内部 <xref:System.Collections.Generic.Dictionary%602> 引发的异常终止方法。</span><span class="sxs-lookup"><span data-stu-id="f409b-301">If the key is not found, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="f409b-302">`finally` 块用于执行 <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> 方法，确保调用方退出读取模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-302">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> method, ensuring that the caller exits read mode.</span></span>  
  
 <span data-ttu-id="f409b-303">此代码是为 <xref:System.Threading.ReaderWriterLockSlim> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="f409b-303">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="f409b-304"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，并且当前线程在已持有读取锁时已尝试获取读取锁。</span><span class="sxs-lookup"><span data-stu-id="f409b-304">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, and the current thread has attempted to acquire the read lock when it already holds the read lock.</span></span>  
  
<span data-ttu-id="f409b-305">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f409b-305">-or-</span></span> 
<span data-ttu-id="f409b-306"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，并且当前线程在已持有写入锁时已尝试获取读取锁。</span><span class="sxs-lookup"><span data-stu-id="f409b-306">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, and the current thread has attempted to acquire the read lock when it already holds the write lock.</span></span>  
  
<span data-ttu-id="f409b-307">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f409b-307">-or-</span></span> 
<span data-ttu-id="f409b-308">递归数将超出该计数器的容量。</span><span class="sxs-lookup"><span data-stu-id="f409b-308">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="f409b-309">此限值很大，因此应用程序永远不会遇到此异常。</span><span class="sxs-lookup"><span data-stu-id="f409b-309">This limit is so large that applications should never encounter this exception.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f409b-310"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</span><span class="sxs-lookup"><span data-stu-id="f409b-310">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void EnterUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f409b-311">尝试进入可升级模式锁定状态。</span><span class="sxs-lookup"><span data-stu-id="f409b-311">Tries to enter the lock in upgradeable mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f409b-312">此方法会一直阻止，直到调用线程进入锁定状态，因此可能永远不会返回。</span><span class="sxs-lookup"><span data-stu-id="f409b-312">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="f409b-313">使用 <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> 方法可在指定的时间间隔内阻塞，如果调用线程未在该时间间隔内进入可升级模式，则返回。</span><span class="sxs-lookup"><span data-stu-id="f409b-313">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered upgradeable mode during that interval.</span></span>  
  
 <span data-ttu-id="f409b-314">当线程通常访问在读取模式下受 <xref:System.Threading.ReaderWriterLockSlim> 保护的资源时，请使用可升级模式，但如果满足某些条件，则可能需要进入写入模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-314">Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="f409b-315">处于可升级模式的线程可以降级到读取模式或升级到写入模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-315">A thread in upgradeable mode can downgrade to read mode or upgrade to write mode.</span></span>  
  
 <span data-ttu-id="f409b-316">在任何给定时间，只有一个线程可以进入可升级模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-316">Only one thread can enter upgradeable mode at any given time.</span></span> <span data-ttu-id="f409b-317">如果某个线程处于可升级模式，并且没有等待进入写入模式的线程，则任何数量的其他线程都可以进入读取模式，即使有等待进入可升级模式的线程。</span><span class="sxs-lookup"><span data-stu-id="f409b-317">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="f409b-318">如果一个或多个线程正在等待进入写入模式，则调用 <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> 方法的线程将受阻，直到这些线程超时或进入写入模式，然后再从中退出。</span><span class="sxs-lookup"><span data-stu-id="f409b-318">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f409b-319">如果某个锁允许递归，则进入可升级模式锁定状态的线程可以以递归方式进入可升级模式，即使其他线程正在等待进入写入模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-319">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f409b-320">下面的示例演示如何使用 <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> 方法进入可升级模式锁定状态。</span><span class="sxs-lookup"><span data-stu-id="f409b-320">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method to enter the lock in upgradeable mode.</span></span> <span data-ttu-id="f409b-321">`finally` 块用于执行 <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> 方法，确保调用方退出可升级模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-321">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method, ensuring that the caller exits upgradeable mode.</span></span>  
  
 <span data-ttu-id="f409b-322">示例中所示的方法检索与键关联的值，并将其与新值进行比较。</span><span class="sxs-lookup"><span data-stu-id="f409b-322">The method shown in the example retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="f409b-323">如果值不变，则方法将返回一个状态，指示没有任何更改。</span><span class="sxs-lookup"><span data-stu-id="f409b-323">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="f409b-324">如果未找到键的值，则插入键/值对。</span><span class="sxs-lookup"><span data-stu-id="f409b-324">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="f409b-325">如果值已更改，则会更新。</span><span class="sxs-lookup"><span data-stu-id="f409b-325">If the value has changed, it is updated.</span></span> <span data-ttu-id="f409b-326">可升级模式允许线程根据需要升级读取锁定，而不会导致死锁的风险。</span><span class="sxs-lookup"><span data-stu-id="f409b-326">Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</span></span>  
  
 <span data-ttu-id="f409b-327">该示例使用无参数构造函数创建锁，因此不允许使用递归。</span><span class="sxs-lookup"><span data-stu-id="f409b-327">The example uses the parameterless constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="f409b-328">当锁定不允许递归时，对 <xref:System.Threading.ReaderWriterLockSlim> 进行编程更简单，并且不易出错。</span><span class="sxs-lookup"><span data-stu-id="f409b-328">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 <span data-ttu-id="f409b-329">此代码是为 <xref:System.Threading.ReaderWriterLockSlim> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="f409b-329">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="f409b-330"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入任意模式的锁定状态。</span><span class="sxs-lookup"><span data-stu-id="f409b-330">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode.</span></span>  
  
<span data-ttu-id="f409b-331">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f409b-331">-or-</span></span> 
<span data-ttu-id="f409b-332">当前线程已进入读取模式，因此尝试进入可升级模式将有可能导致死锁。</span><span class="sxs-lookup"><span data-stu-id="f409b-332">The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="f409b-333">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f409b-333">-or-</span></span> 
<span data-ttu-id="f409b-334">递归数将超出该计数器的容量。</span><span class="sxs-lookup"><span data-stu-id="f409b-334">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="f409b-335">此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</span><span class="sxs-lookup"><span data-stu-id="f409b-335">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f409b-336"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</span><span class="sxs-lookup"><span data-stu-id="f409b-336">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnterWriteLock">
      <MemberSignature Language="C#" Value="public void EnterWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterWriteLock();" />
      <MemberSignature Language="F#" Value="member this.EnterWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f409b-337">尝试进入写入模式锁定状态。</span><span class="sxs-lookup"><span data-stu-id="f409b-337">Tries to enter the lock in write mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f409b-338">此方法会一直阻止，直到调用线程进入锁定状态，因此可能永远不会返回。</span><span class="sxs-lookup"><span data-stu-id="f409b-338">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="f409b-339">使用 <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> 方法可在指定的时间间隔内阻塞，如果调用线程未在该时间间隔内进入写入模式，则返回。</span><span class="sxs-lookup"><span data-stu-id="f409b-339">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to block for a specified interval, and then return if the calling thread has not entered write mode during that interval.</span></span>  
  
 <span data-ttu-id="f409b-340">如果其他线程已进入读取模式锁定状态，则调用 <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> 方法的线程将会阻塞，直到这些线程退出读取模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-340">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method blocks until those threads have exited read mode.</span></span> <span data-ttu-id="f409b-341">当有等待进入写入模式的线程时，尝试进入读取模式或可升级模式的其他线程将会阻止，直到所有等待进入写入模式的线程超时或进入写入模式，然后再从中退出。</span><span class="sxs-lookup"><span data-stu-id="f409b-341">When there are threads waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f409b-342">如果某个锁允许递归，则进入写入模式锁定状态的线程可以以递归方式进入写入模式，即使其他线程正在等待进入写入模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-342">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f409b-343">下面的示例演示如何使用 <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> 方法进入写入模式锁定状态。</span><span class="sxs-lookup"><span data-stu-id="f409b-343">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method to enter the lock in write mode.</span></span> <span data-ttu-id="f409b-344">示例中显示的方法将新的键/值对添加到同步的缓存中。</span><span class="sxs-lookup"><span data-stu-id="f409b-344">The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="f409b-345">如果该密钥已在缓存中，则允许由内部 <xref:System.Collections.Generic.Dictionary%602> 引发的异常终止该方法。</span><span class="sxs-lookup"><span data-stu-id="f409b-345">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="f409b-346">`finally` 块用于执行 <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> 方法，确保调用方退出写入模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-346">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits write mode.</span></span>  
  
 <span data-ttu-id="f409b-347">此代码是为 <xref:System.Threading.ReaderWriterLockSlim> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="f409b-347">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="f409b-348"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入任意模式的锁定状态。</span><span class="sxs-lookup"><span data-stu-id="f409b-348">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode.</span></span>  
  
<span data-ttu-id="f409b-349">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f409b-349">-or-</span></span> 
<span data-ttu-id="f409b-350">当前线程已进入读取模式且尚无写锁定，因此尝试进入写入模式锁定状态将有可能导致死锁。</span><span class="sxs-lookup"><span data-stu-id="f409b-350">The current thread has entered read mode and doesn't already own a write lock, so trying to enter the lock in write mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="f409b-351">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f409b-351">-or-</span></span> 
<span data-ttu-id="f409b-352">递归数将超出该计数器的容量。</span><span class="sxs-lookup"><span data-stu-id="f409b-352">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="f409b-353">此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</span><span class="sxs-lookup"><span data-stu-id="f409b-353">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f409b-354"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</span><span class="sxs-lookup"><span data-stu-id="f409b-354">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExitReadLock">
      <MemberSignature Language="C#" Value="public void ExitReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f409b-355">减少读取模式的递归计数，并在生成的计数为 0（零）时退出读取模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-355">Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f409b-356">此方法对于递归顺序是不敏感的。</span><span class="sxs-lookup"><span data-stu-id="f409b-356">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="f409b-357">例如，如果某个线程进入可升级模式的锁定状态，然后进入读取模式锁定状态，则线程退出这两种模式的顺序并不重要。</span><span class="sxs-lookup"><span data-stu-id="f409b-357">For example, if a thread enters a lock in upgradeable mode and then enters the lock in read mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="f409b-358">如果某个锁允许递归，则线程可以进入写入模式的锁定，然后以递归方式进入读取模式;线程退出读取模式和写入模式的顺序并不重要。</span><span class="sxs-lookup"><span data-stu-id="f409b-358">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="f409b-359">退出锁可能会发出其他等待线程的信号。</span><span class="sxs-lookup"><span data-stu-id="f409b-359">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f409b-360">下面的示例演示如何使用 `finally` 块执行 <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> 方法，确保调用方退出读取模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-360">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> method, ensuring that the caller exits read mode.</span></span> <span data-ttu-id="f409b-361">示例中所示的方法检索与键关联的值。</span><span class="sxs-lookup"><span data-stu-id="f409b-361">The method shown in the example retrieves the value associated with a key.</span></span> <span data-ttu-id="f409b-362">如果未找到该键，则允许由内部 <xref:System.Collections.Generic.Dictionary%602> 引发的异常终止方法。</span><span class="sxs-lookup"><span data-stu-id="f409b-362">If the key is not found, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="f409b-363"><xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> 方法用于进入读取模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-363">The <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method is used to enter read mode.</span></span>  
  
 <span data-ttu-id="f409b-364">此代码是为 <xref:System.Threading.ReaderWriterLockSlim> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="f409b-364">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="f409b-365">当前线程未进入读取模式锁定状态。</span><span class="sxs-lookup"><span data-stu-id="f409b-365">The current thread has not entered the lock in read mode.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExitUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void ExitUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f409b-366">减少可升级模式的递归计数，并在生成的计数为 0（零）时退出可升级模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-366">Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f409b-367">此方法对于递归顺序是不敏感的。</span><span class="sxs-lookup"><span data-stu-id="f409b-367">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="f409b-368">例如，如果某个线程进入可升级模式的锁定，然后在写入模式下进入锁定状态，则该线程退出这两个模式的顺序并不重要。</span><span class="sxs-lookup"><span data-stu-id="f409b-368">For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="f409b-369">如果锁允许递归，则线程可以进入写入模式的锁定，然后以递归方式进入可升级模式;线程退出可升级模式和写入模式的顺序并不重要。</span><span class="sxs-lookup"><span data-stu-id="f409b-369">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in upgradeable mode; the order in which the thread exits upgradeable mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="f409b-370">退出锁可能会发出其他等待线程的信号。</span><span class="sxs-lookup"><span data-stu-id="f409b-370">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f409b-371">下面的示例演示如何使用 `finally` 块执行 <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> 方法，确保调用方退出可升级模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-371">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method, ensuring that the caller exits upgradeable mode.</span></span>  
  
 <span data-ttu-id="f409b-372">示例中所示的方法检索与键关联的值，并将其与新值进行比较。</span><span class="sxs-lookup"><span data-stu-id="f409b-372">The method shown in the example retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="f409b-373">如果值不变，则方法将返回一个状态，指示没有任何更改。</span><span class="sxs-lookup"><span data-stu-id="f409b-373">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="f409b-374">如果未找到键的值，则插入键/值对。</span><span class="sxs-lookup"><span data-stu-id="f409b-374">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="f409b-375">如果值已更改，则会更新。</span><span class="sxs-lookup"><span data-stu-id="f409b-375">If the value has changed, it is updated.</span></span> <span data-ttu-id="f409b-376">可升级模式允许线程根据需要升级读取锁定，而不会导致死锁的风险。</span><span class="sxs-lookup"><span data-stu-id="f409b-376">Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</span></span>  
  
 <span data-ttu-id="f409b-377">该示例使用无参数构造函数创建锁，因此不允许使用递归。</span><span class="sxs-lookup"><span data-stu-id="f409b-377">The example uses the parameterless constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="f409b-378">当锁定不允许递归时，对 <xref:System.Threading.ReaderWriterLockSlim> 进行编程更简单，并且不易出错。</span><span class="sxs-lookup"><span data-stu-id="f409b-378">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 <span data-ttu-id="f409b-379">此代码是为 <xref:System.Threading.ReaderWriterLockSlim> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="f409b-379">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="f409b-380">当前线程未进入可升级模式锁定状态。</span><span class="sxs-lookup"><span data-stu-id="f409b-380">The current thread has not entered the lock in upgradeable mode.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExitWriteLock">
      <MemberSignature Language="C#" Value="public void ExitWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitWriteLock();" />
      <MemberSignature Language="F#" Value="member this.ExitWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f409b-381">减少写入模式的递归计数，并在生成的计数为 0（零）时退出写入模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-381">Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f409b-382">此方法对于递归顺序是不敏感的。</span><span class="sxs-lookup"><span data-stu-id="f409b-382">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="f409b-383">例如，如果某个线程进入可升级模式的锁定，然后在写入模式下进入锁定状态，则该线程退出这两个模式的顺序并不重要。</span><span class="sxs-lookup"><span data-stu-id="f409b-383">For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="f409b-384">如果某个锁允许递归，则线程可以进入写入模式的锁定，然后以递归方式进入读取模式;线程退出读取模式和写入模式的顺序并不重要。</span><span class="sxs-lookup"><span data-stu-id="f409b-384">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="f409b-385">退出锁可能会发出其他等待线程的信号。</span><span class="sxs-lookup"><span data-stu-id="f409b-385">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f409b-386">下面的示例演示如何使用 `finally` 块执行 <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> 方法，确保调用方退出写入模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-386">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits write mode.</span></span> <span data-ttu-id="f409b-387">示例中显示的方法将新的键/值对添加到同步的缓存中。</span><span class="sxs-lookup"><span data-stu-id="f409b-387">The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="f409b-388">如果该密钥已在缓存中，则允许由内部 <xref:System.Collections.Generic.Dictionary%602> 引发的异常终止该方法。</span><span class="sxs-lookup"><span data-stu-id="f409b-388">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="f409b-389"><xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> 方法用于进入写入模式锁定状态。</span><span class="sxs-lookup"><span data-stu-id="f409b-389">The <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method is used to enter the lock in write mode.</span></span>  
  
 <span data-ttu-id="f409b-390">此代码是为 <xref:System.Threading.ReaderWriterLockSlim> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="f409b-390">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="f409b-391">当前线程未进入写入模式锁定状态。</span><span class="sxs-lookup"><span data-stu-id="f409b-391">The current thread has not entered the lock in write mode.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f409b-392">获取一个值，该值指示当前线程是否已进入读取模式的锁定状态。</span><span class="sxs-lookup"><span data-stu-id="f409b-392">Gets a value that indicates whether the current thread has entered the lock in read mode.</span></span></summary>
        <value><span data-ttu-id="f409b-393">如果当前线程已进入读取模式，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f409b-393"><see langword="true" /> if the current thread has entered read mode; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f409b-394">此属性用于断言或其他调试目的。</span><span class="sxs-lookup"><span data-stu-id="f409b-394">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="f409b-395">不要使用它来控制程序执行的流动。</span><span class="sxs-lookup"><span data-stu-id="f409b-395">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f409b-396">下面的示例演示如何使用 <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A> 属性在当前线程意外进入读取模式的情况下生成断言。</span><span class="sxs-lookup"><span data-stu-id="f409b-396">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A> property to generate an assert if the current thread has entered read mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#21)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpgradeableReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsUpgradeableReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUpgradeableReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUpgradeableReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUpgradeableReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUpgradeableReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f409b-397">获取一个值，该值指示当前线程是否已进入可升级模式的锁定状态。</span><span class="sxs-lookup"><span data-stu-id="f409b-397">Gets a value that indicates whether the current thread has entered the lock in upgradeable mode.</span></span></summary>
        <value><span data-ttu-id="f409b-398">如果当前线程已进入可升级模式，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f409b-398"><see langword="true" /> if the current thread has entered upgradeable mode; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f409b-399">此属性用于断言或其他调试目的。</span><span class="sxs-lookup"><span data-stu-id="f409b-399">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="f409b-400">不要使用它来控制程序执行的流动。</span><span class="sxs-lookup"><span data-stu-id="f409b-400">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f409b-401">下面的示例演示了在当前线程已意外进入可升级模式的情况下，如何使用 <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A> 属性生成断言。</span><span class="sxs-lookup"><span data-stu-id="f409b-401">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A> property to generate an assert if the current thread has entered upgradeable mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#22)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriteLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f409b-402">获取一个值，该值指示当前线程是否已进入写入模式的锁定状态。</span><span class="sxs-lookup"><span data-stu-id="f409b-402">Gets a value that indicates whether the current thread has entered the lock in write mode.</span></span></summary>
        <value><span data-ttu-id="f409b-403">如果当前线程已进入写入模式，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f409b-403"><see langword="true" /> if the current thread has entered write mode; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f409b-404">此属性用于断言或其他调试目的。</span><span class="sxs-lookup"><span data-stu-id="f409b-404">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="f409b-405">不要使用它来控制程序执行的流动。</span><span class="sxs-lookup"><span data-stu-id="f409b-405">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f409b-406">下面的示例演示了在当前线程意外进入写入模式时，如何使用 <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A> 属性生成断言。</span><span class="sxs-lookup"><span data-stu-id="f409b-406">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A> property to generate an assert if the current thread has entered write mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#23)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursionPolicy">
      <MemberSignature Language="C#" Value="public System.Threading.LockRecursionPolicy RecursionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.LockRecursionPolicy RecursionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursionPolicy As LockRecursionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::LockRecursionPolicy RecursionPolicy { System::Threading::LockRecursionPolicy get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursionPolicy : System.Threading.LockRecursionPolicy" Usage="System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f409b-407">获取一个值，该值指示当前 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象的递归策略。</span><span class="sxs-lookup"><span data-stu-id="f409b-407">Gets a value that indicates the recursion policy for the current <see cref="T:System.Threading.ReaderWriterLockSlim" /> object.</span></span></summary>
        <value><span data-ttu-id="f409b-408">枚举值之一，用于指定锁定递归策略。</span><span class="sxs-lookup"><span data-stu-id="f409b-408">One of the enumeration values that specifies the lock recursion policy.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f409b-409">递归策略确定对多次输入锁定的线程的限制。</span><span class="sxs-lookup"><span data-stu-id="f409b-409">Recursion policy determines the restrictions on threads that enter the lock more than once.</span></span> <span data-ttu-id="f409b-410">例如，如果使用 <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> 创建了一个锁，并且某个线程已进入读取模式锁定状态，则在该线程尝试重新进入读取模式锁定状态时将引发 <xref:System.Threading.LockRecursionException>。</span><span class="sxs-lookup"><span data-stu-id="f409b-410">For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f409b-411">可升级模式的线程可以升级到写入模式或降级到读取模式，而不考虑锁定递归策略设置。</span><span class="sxs-lookup"><span data-stu-id="f409b-411">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</span></span>  
  
 <span data-ttu-id="f409b-412">不管递归策略如何，最初进入读取模式的线程都不允许升级到可升级模式或写入模式，因为这种模式产生了死锁的概率。</span><span class="sxs-lookup"><span data-stu-id="f409b-412">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span>  
  
 <span data-ttu-id="f409b-413">有关递归策略及其效果的详细信息，请参阅 <xref:System.Threading.LockRecursionPolicy> 枚举和 <xref:System.Threading.ReaderWriterLockSlim> 类。</span><span class="sxs-lookup"><span data-stu-id="f409b-413">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionException" />
      </Docs>
    </Member>
    <Member MemberName="RecursiveReadCount">
      <MemberSignature Language="C#" Value="public int RecursiveReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f409b-414">获取当前线程进入读取模式锁定状态的次数，用于指示递归。</span><span class="sxs-lookup"><span data-stu-id="f409b-414">Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.</span></span></summary>
        <value><span data-ttu-id="f409b-415">如果当前线程未进入读取模式，则为0（零）; 如果线程已进入读取模式但尚未以递归方式进入，则为 1; 如果线程*已递归进入*锁定状态，则为*n* 。</span><span class="sxs-lookup"><span data-stu-id="f409b-415">0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or *n* if the thread has entered the lock recursively *n* - 1 times.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f409b-416">此属性仅用于调试、分析和日志记录目的，而不用于控制算法的行为。</span><span class="sxs-lookup"><span data-stu-id="f409b-416">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="f409b-417">计算结果后，结果就会更改。</span><span class="sxs-lookup"><span data-stu-id="f409b-417">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="f409b-418">因此，根据此属性做出决策并不安全。</span><span class="sxs-lookup"><span data-stu-id="f409b-418">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveUpgradeCount">
      <MemberSignature Language="C#" Value="public int RecursiveUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f409b-419">获取当前线程进入可升级模式锁定状态的次数，用于指示递归。</span><span class="sxs-lookup"><span data-stu-id="f409b-419">Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.</span></span></summary>
        <value><span data-ttu-id="f409b-420">如果当前线程未进入可升级模式，则为 0; 如果线程已进入可升级模式但尚未以递归方式进入，则为 1; 如果线程已进入可升级模式，则为*n* *-1*次。</span><span class="sxs-lookup"><span data-stu-id="f409b-420">0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or *n* if the thread has entered upgradeable mode recursively *n* - 1 times.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f409b-421">此属性仅用于调试、分析和日志记录目的，而不用于控制算法的行为。</span><span class="sxs-lookup"><span data-stu-id="f409b-421">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="f409b-422">计算结果后，结果就会更改。</span><span class="sxs-lookup"><span data-stu-id="f409b-422">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="f409b-423">因此，根据此属性做出决策并不安全。</span><span class="sxs-lookup"><span data-stu-id="f409b-423">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveWriteCount">
      <MemberSignature Language="C#" Value="public int RecursiveWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f409b-424">获取当前线程进入写入模式锁定状态的次数，用于指示递归。</span><span class="sxs-lookup"><span data-stu-id="f409b-424">Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.</span></span></summary>
        <value><span data-ttu-id="f409b-425">如果当前线程未进入写入模式，则为 0; 如果线程已进入写入模式但尚未以递归方式进入写入模式，则为 1; 如果线程*已进入写入*模式，则为*n* 。</span><span class="sxs-lookup"><span data-stu-id="f409b-425">0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or *n* if the thread has entered write mode recursively *n* - 1 times.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f409b-426">此属性仅用于调试、分析和日志记录目的，而不用于控制算法的行为。</span><span class="sxs-lookup"><span data-stu-id="f409b-426">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="f409b-427">计算结果后，结果就会更改。</span><span class="sxs-lookup"><span data-stu-id="f409b-427">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="f409b-428">因此，根据此属性做出决策并不安全。</span><span class="sxs-lookup"><span data-stu-id="f409b-428">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f409b-429">尝试进入读取模式锁定状态，可以选择超时时间。</span><span class="sxs-lookup"><span data-stu-id="f409b-429">Tries to enter the lock in read mode, with an optional time-out.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="f409b-430">等待的毫秒数，或为 -1 (<see cref="F:System.Threading.Timeout.Infinite" />)，表示无限期等待。</span><span class="sxs-lookup"><span data-stu-id="f409b-430">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f409b-431">尝试进入读取模式锁定状态，可以选择整数超时时间。</span><span class="sxs-lookup"><span data-stu-id="f409b-431">Tries to enter the lock in read mode, with an optional integer time-out.</span></span></summary>
        <returns><span data-ttu-id="f409b-432">如果调用线程已进入读取模式，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f409b-432"><see langword="true" /> if the calling thread entered read mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f409b-433">如果 `millisecondsTimeout` 为0（零），则此方法将检查锁定状态，并在所需的状态不可用时立即返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="f409b-433">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="f409b-434">多个线程可以同时进入读取模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-434">Multiple threads can enter read mode at the same time.</span></span>  
  
 <span data-ttu-id="f409b-435">如果一个或多个线程正在等待进入写入模式，则调用 <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> 方法的线程将受阻，直到这些线程超时或进入写入模式，然后从其中退出，或直到调用线程自己的超时间隔到期。</span><span class="sxs-lookup"><span data-stu-id="f409b-435">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f409b-436">如果某个锁允许递归，则进入读取模式锁定状态的线程可以以递归方式进入读取模式，即使其他线程正在等待进入写入模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-436">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="f409b-437">当其他线程处于读取模式时，一个线程可以处于可升级模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-437">One thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="f409b-438">如果其他线程正在等待进入可升级模式，并且没有等待进入写入模式的线程，则调用 <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> 方法的线程会立即进入读取模式，而不会阻止。</span><span class="sxs-lookup"><span data-stu-id="f409b-438">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="f409b-439"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入锁定状态。</span><span class="sxs-lookup"><span data-stu-id="f409b-439">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="f409b-440">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f409b-440">-or-</span></span> 
<span data-ttu-id="f409b-441">递归数将超出该计数器的容量。</span><span class="sxs-lookup"><span data-stu-id="f409b-441">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="f409b-442">此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</span><span class="sxs-lookup"><span data-stu-id="f409b-442">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f409b-443"><paramref name="millisecondsTimeout" /> 的值为负，但不等于 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，这是唯一允许使用的负值。</span><span class="sxs-lookup"><span data-stu-id="f409b-443">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f409b-444"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</span><span class="sxs-lookup"><span data-stu-id="f409b-444">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="f409b-445">等待的间隔；或为 -1 毫秒，表示无限期等待。</span><span class="sxs-lookup"><span data-stu-id="f409b-445">The interval to wait, or -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f409b-446">尝试进入读取模式锁定状态，可以选择超时时间。</span><span class="sxs-lookup"><span data-stu-id="f409b-446">Tries to enter the lock in read mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="f409b-447">如果调用线程已进入读取模式，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f409b-447"><see langword="true" /> if the calling thread entered read mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f409b-448">如果 `timeout` 为0（零），则此方法将检查锁定状态，并在所需的状态不可用时立即返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="f409b-448">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="f409b-449">多个线程可以同时进入读取模式锁定状态。</span><span class="sxs-lookup"><span data-stu-id="f409b-449">Multiple threads can enter the lock in read mode at the same time.</span></span>  
  
 <span data-ttu-id="f409b-450">如果一个或多个线程排队等候进入写入模式，则调用 <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> 方法的线程将会阻塞，直到这些线程超时或进入写入模式，然后从其中退出，或直到调用线程自己的超时间隔到期。</span><span class="sxs-lookup"><span data-stu-id="f409b-450">If one or more threads are queued to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f409b-451">如果某个锁允许递归，则进入读取模式锁定状态的线程可以以递归方式进入读取模式，即使其他线程正在等待进入写入模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-451">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="f409b-452">当其他线程处于读取模式时，一个线程可以处于可升级模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-452">One thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="f409b-453">如果其他线程正在等待进入可升级模式，并且没有等待进入写入模式的线程，则调用 <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> 方法的线程会立即进入读取模式，而不会阻止。</span><span class="sxs-lookup"><span data-stu-id="f409b-453">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="f409b-454"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入锁定状态。</span><span class="sxs-lookup"><span data-stu-id="f409b-454">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="f409b-455">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f409b-455">-or-</span></span> 
<span data-ttu-id="f409b-456">递归数将超出该计数器的容量。</span><span class="sxs-lookup"><span data-stu-id="f409b-456">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="f409b-457">此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</span><span class="sxs-lookup"><span data-stu-id="f409b-457">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f409b-458"><paramref name="timeout" /> 的值为负，但不等于 -1 毫秒，这是唯一允许使用的负值。</span><span class="sxs-lookup"><span data-stu-id="f409b-458">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span></span>  
  
<span data-ttu-id="f409b-459">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f409b-459">-or-</span></span> 
<span data-ttu-id="f409b-460"><paramref name="timeout" /> 的值大于 <see cref="F:System.Int32.MaxValue" /> 毫秒。</span><span class="sxs-lookup"><span data-stu-id="f409b-460">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f409b-461"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</span><span class="sxs-lookup"><span data-stu-id="f409b-461">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterUpgradeableReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f409b-462">尝试进入可升级模式锁定状态，可以选择超时时间。</span><span class="sxs-lookup"><span data-stu-id="f409b-462">Tries to enter the lock in upgradeable mode, with an optional time-out.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="f409b-463">等待的毫秒数，或为 -1 (<see cref="F:System.Threading.Timeout.Infinite" />)，表示无限期等待。</span><span class="sxs-lookup"><span data-stu-id="f409b-463">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f409b-464">尝试进入可升级模式锁定状态，可以选择超时时间。</span><span class="sxs-lookup"><span data-stu-id="f409b-464">Tries to enter the lock in upgradeable mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="f409b-465">如果调用线程已进入可升级模式，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f409b-465"><see langword="true" /> if the calling thread entered upgradeable mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f409b-466">如果 `millisecondsTimeout` 为0（零），则此方法将检查锁定状态，并在所需的状态不可用时立即返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="f409b-466">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="f409b-467">当线程通常访问在读取模式下受 <xref:System.Threading.ReaderWriterLockSlim> 保护的资源时，请使用可升级模式，但如果满足某些条件，则可能需要进入写入模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-467">Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="f409b-468">处于可升级模式的线程可以升级到写入模式或降级到读取模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-468">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</span></span>  
  
 <span data-ttu-id="f409b-469">在任何给定时间，只有一个线程可以进入可升级模式锁定状态。</span><span class="sxs-lookup"><span data-stu-id="f409b-469">Only one thread can enter a lock in upgradeable mode at any given time.</span></span> <span data-ttu-id="f409b-470">如果某个线程处于可升级模式，并且没有等待进入写入模式的线程，则任何数量的其他线程都可以进入读取模式，即使有等待进入可升级模式的线程。</span><span class="sxs-lookup"><span data-stu-id="f409b-470">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="f409b-471">如果一个或多个线程正在等待进入写入模式，则调用 <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> 方法的线程将受阻，直到这些线程超时或进入写入模式，然后从其中退出，或直到调用线程自己的超时间隔到期。</span><span class="sxs-lookup"><span data-stu-id="f409b-471">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f409b-472">如果某个锁允许递归，则进入可升级模式锁定状态的线程可以以递归方式进入可升级模式，即使其他线程正在等待进入写入模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-472">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="f409b-473"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入锁定状态。</span><span class="sxs-lookup"><span data-stu-id="f409b-473">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="f409b-474">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f409b-474">-or-</span></span> 
<span data-ttu-id="f409b-475">初始状态下，当前线程进入读取模式锁定状态，因此尝试进入可升级模式将有可能导致死锁。</span><span class="sxs-lookup"><span data-stu-id="f409b-475">The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="f409b-476">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f409b-476">-or-</span></span> 
<span data-ttu-id="f409b-477">递归数将超出该计数器的容量。</span><span class="sxs-lookup"><span data-stu-id="f409b-477">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="f409b-478">此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</span><span class="sxs-lookup"><span data-stu-id="f409b-478">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f409b-479"><paramref name="millisecondsTimeout" /> 的值为负，但不等于 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，这是唯一允许使用的负值。</span><span class="sxs-lookup"><span data-stu-id="f409b-479">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f409b-480"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</span><span class="sxs-lookup"><span data-stu-id="f409b-480">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="f409b-481">等待的间隔；或为 -1 毫秒，表示无限期等待。</span><span class="sxs-lookup"><span data-stu-id="f409b-481">The interval to wait, or -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f409b-482">尝试进入可升级模式锁定状态，可以选择超时时间。</span><span class="sxs-lookup"><span data-stu-id="f409b-482">Tries to enter the lock in upgradeable mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="f409b-483">如果调用线程已进入可升级模式，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f409b-483"><see langword="true" /> if the calling thread entered upgradeable mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f409b-484">如果 `timeout` 为0（零），则此方法将检查锁定状态，并在所需的状态不可用时立即返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="f409b-484">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="f409b-485">当线程通常访问在读取模式下受 <xref:System.Threading.ReaderWriterLockSlim> 保护的资源时，可使用可升级模式，但如果满足某些条件，则可能需要进入写入模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-485">Use upgradeable mode when a thread usually accesses the resource protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="f409b-486">处于可升级模式的线程可以升级到写入模式或降级到读取模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-486">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</span></span>  
  
 <span data-ttu-id="f409b-487">在任何给定时间，只有一个线程可以进入可升级模式锁定状态。</span><span class="sxs-lookup"><span data-stu-id="f409b-487">Only one thread can enter a lock in upgradeable mode at any given time.</span></span> <span data-ttu-id="f409b-488">如果某个线程处于可升级模式，并且没有等待进入写入模式的线程，则任何数量的其他线程都可以进入读取模式，即使有等待进入可升级模式的线程。</span><span class="sxs-lookup"><span data-stu-id="f409b-488">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="f409b-489">如果一个或多个线程正在等待进入写入模式，则调用 <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> 方法的线程将受阻，直到这些线程超时或进入写入模式，然后从其中退出，或直到调用线程自己的超时间隔到期。</span><span class="sxs-lookup"><span data-stu-id="f409b-489">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f409b-490">如果某个锁允许递归，则进入可升级模式锁定状态的线程可以以递归方式进入可升级模式，即使其他线程正在等待进入写入模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-490">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="f409b-491"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入锁定状态。</span><span class="sxs-lookup"><span data-stu-id="f409b-491">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="f409b-492">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f409b-492">-or-</span></span> 
<span data-ttu-id="f409b-493">初始状态下，当前线程进入读取模式锁定状态，因此尝试进入可升级模式将有可能导致死锁。</span><span class="sxs-lookup"><span data-stu-id="f409b-493">The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="f409b-494">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f409b-494">-or-</span></span> 
<span data-ttu-id="f409b-495">递归数将超出该计数器的容量。</span><span class="sxs-lookup"><span data-stu-id="f409b-495">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="f409b-496">此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</span><span class="sxs-lookup"><span data-stu-id="f409b-496">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f409b-497"><paramref name="timeout" /> 的值为负，但不等于 -1 毫秒，这是唯一允许使用的负值。</span><span class="sxs-lookup"><span data-stu-id="f409b-497">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span></span>  
  
<span data-ttu-id="f409b-498">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f409b-498">-or-</span></span> 
<span data-ttu-id="f409b-499"><paramref name="timeout" /> 的值大于 <see cref="F:System.Int32.MaxValue" /> 毫秒。</span><span class="sxs-lookup"><span data-stu-id="f409b-499">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f409b-500"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</span><span class="sxs-lookup"><span data-stu-id="f409b-500">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterWriteLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f409b-501">尝试进入写入模式锁定状态，可以选择超时时间。</span><span class="sxs-lookup"><span data-stu-id="f409b-501">Tries to enter the lock in write mode, with an optional time-out.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="f409b-502">等待的毫秒数，或为 -1 (<see cref="F:System.Threading.Timeout.Infinite" />)，表示无限期等待。</span><span class="sxs-lookup"><span data-stu-id="f409b-502">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f409b-503">尝试进入写入模式锁定状态，可以选择超时时间。</span><span class="sxs-lookup"><span data-stu-id="f409b-503">Tries to enter the lock in write mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="f409b-504">如果调用线程已进入写入模式，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f409b-504"><see langword="true" /> if the calling thread entered write mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f409b-505">如果 `millisecondsTimeout` 为0（零），则此方法将检查锁定状态，并在所需的状态不可用时立即返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="f409b-505">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="f409b-506">如果其他线程已进入读取模式锁定状态，则调用 <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> 方法的线程将会阻塞，直到这些线程退出读取模式或超时间隔结束。</span><span class="sxs-lookup"><span data-stu-id="f409b-506">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</span></span> <span data-ttu-id="f409b-507">在等待进入写入模式的线程被阻止时，还会在所有等待进入写入模式的线程超时或进入写入模式之后，尝试进入读取模式或可升级模式的其他线程进入写入模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-507">While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f409b-508">如果某个锁允许递归，则进入写入模式锁定状态的线程可以以递归方式进入写入模式，即使其他线程正在等待进入写入模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-508">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f409b-509">下面的示例演示如何使用 <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> 方法进入写入模式锁定状态，超时为。示例中显示的方法将新的键/值对添加到同步的缓存中。</span><span class="sxs-lookup"><span data-stu-id="f409b-509">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to enter the lock in write mode, with a time-out. The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="f409b-510">如果在线程进入锁之前经过了指定的超时间隔，则该方法将返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="f409b-510">If the specified time-out interval elapses before the thread enters the lock, the method returns `false`.</span></span> <span data-ttu-id="f409b-511">如果添加了键/值对，则方法将返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="f409b-511">The method returns `true` if the key/value pair is added.</span></span>  
  
 <span data-ttu-id="f409b-512">如果该密钥已在缓存中，则允许由内部 <xref:System.Collections.Generic.Dictionary%602> 引发的异常终止该方法。</span><span class="sxs-lookup"><span data-stu-id="f409b-512">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="f409b-513">`finally` 块用于执行 <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> 方法，确保调用方退出锁。</span><span class="sxs-lookup"><span data-stu-id="f409b-513">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits the lock.</span></span>  
  
 <span data-ttu-id="f409b-514">此代码是为 <xref:System.Threading.ReaderWriterLockSlim> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="f409b-514">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="f409b-515"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入锁定状态。</span><span class="sxs-lookup"><span data-stu-id="f409b-515">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="f409b-516">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f409b-516">-or-</span></span> 
<span data-ttu-id="f409b-517">初始状态下，当前线程进入读取模式锁定状态，因此尝试进入写入模式将有可能导致死锁。</span><span class="sxs-lookup"><span data-stu-id="f409b-517">The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="f409b-518">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f409b-518">-or-</span></span> 
<span data-ttu-id="f409b-519">递归数将超出该计数器的容量。</span><span class="sxs-lookup"><span data-stu-id="f409b-519">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="f409b-520">此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</span><span class="sxs-lookup"><span data-stu-id="f409b-520">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f409b-521"><paramref name="millisecondsTimeout" /> 的值为负，但不等于 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，这是唯一允许使用的负值。</span><span class="sxs-lookup"><span data-stu-id="f409b-521">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f409b-522"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</span><span class="sxs-lookup"><span data-stu-id="f409b-522">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="f409b-523">等待的间隔；或为 -1 毫秒，表示无限期等待。</span><span class="sxs-lookup"><span data-stu-id="f409b-523">The interval to wait, or -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f409b-524">尝试进入写入模式锁定状态，可以选择超时时间。</span><span class="sxs-lookup"><span data-stu-id="f409b-524">Tries to enter the lock in write mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="f409b-525">如果调用线程已进入写入模式，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f409b-525"><see langword="true" /> if the calling thread entered write mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f409b-526">如果 `timeout` 为0（零），则此方法将检查锁定状态，并在所需的状态不可用时立即返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="f409b-526">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="f409b-527">如果其他线程已进入读取模式锁定状态，则调用 <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> 方法的线程将会阻塞，直到这些线程退出读取模式或超时间隔结束。</span><span class="sxs-lookup"><span data-stu-id="f409b-527">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</span></span> <span data-ttu-id="f409b-528">在等待进入写入模式的线程被阻止时，还会在所有等待进入写入模式的线程超时或进入写入模式之后，尝试进入读取模式或可升级模式的其他线程进入写入模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-528">While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f409b-529">如果某个锁允许递归，则进入写入模式锁定状态的线程可以以递归方式进入写入模式，即使其他线程正在等待进入写入模式。</span><span class="sxs-lookup"><span data-stu-id="f409b-529">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="f409b-530"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入锁定状态。</span><span class="sxs-lookup"><span data-stu-id="f409b-530">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="f409b-531">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f409b-531">-or-</span></span> 
<span data-ttu-id="f409b-532">初始状态下，当前线程进入读取模式锁定状态，因此尝试进入写入模式将有可能导致死锁。</span><span class="sxs-lookup"><span data-stu-id="f409b-532">The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="f409b-533">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f409b-533">-or-</span></span> 
<span data-ttu-id="f409b-534">递归数将超出该计数器的容量。</span><span class="sxs-lookup"><span data-stu-id="f409b-534">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="f409b-535">此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</span><span class="sxs-lookup"><span data-stu-id="f409b-535">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f409b-536"><paramref name="timeout" /> 的值为负，但不等于 -1 毫秒，这是唯一允许使用的负值。</span><span class="sxs-lookup"><span data-stu-id="f409b-536">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span></span>  
  
<span data-ttu-id="f409b-537">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f409b-537">-or-</span></span> 
<span data-ttu-id="f409b-538"><paramref name="timeout" /> 的值大于 <see cref="F:System.Int32.MaxValue" /> 毫秒。</span><span class="sxs-lookup"><span data-stu-id="f409b-538">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f409b-539"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</span><span class="sxs-lookup"><span data-stu-id="f409b-539">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitingReadCount">
      <MemberSignature Language="C#" Value="public int WaitingReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f409b-540">获取等待进入读取模式锁定状态的线程总数。</span><span class="sxs-lookup"><span data-stu-id="f409b-540">Gets the total number of threads that are waiting to enter the lock in read mode.</span></span></summary>
        <value><span data-ttu-id="f409b-541">等待进入读取模式的线程总数。</span><span class="sxs-lookup"><span data-stu-id="f409b-541">The total number of threads that are waiting to enter read mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f409b-542">此属性仅用于调试、分析和日志记录目的，而不用于控制算法的行为。</span><span class="sxs-lookup"><span data-stu-id="f409b-542">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="f409b-543">计算结果后，结果就会更改。</span><span class="sxs-lookup"><span data-stu-id="f409b-543">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="f409b-544">因此，根据此属性做出决策并不安全。</span><span class="sxs-lookup"><span data-stu-id="f409b-544">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f409b-545">下面的示例演示如何使用 <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A> 属性生成事件日志项（如果阻止进入读取模式的线程数超过阈值）。</span><span class="sxs-lookup"><span data-stu-id="f409b-545">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter read mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#31)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingUpgradeCount">
      <MemberSignature Language="C#" Value="public int WaitingUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f409b-546">获取等待进入可升级模式锁定状态的线程总数。</span><span class="sxs-lookup"><span data-stu-id="f409b-546">Gets the total number of threads that are waiting to enter the lock in upgradeable mode.</span></span></summary>
        <value><span data-ttu-id="f409b-547">等待进入可升级模式的线程总数。</span><span class="sxs-lookup"><span data-stu-id="f409b-547">The total number of threads that are waiting to enter upgradeable mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f409b-548">此属性仅用于调试、分析和日志记录目的，而不用于控制算法的行为。</span><span class="sxs-lookup"><span data-stu-id="f409b-548">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="f409b-549">计算结果后，结果就会更改。</span><span class="sxs-lookup"><span data-stu-id="f409b-549">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="f409b-550">因此，根据此属性做出决策并不安全。</span><span class="sxs-lookup"><span data-stu-id="f409b-550">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f409b-551">下面的示例演示如何使用 <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A> 属性生成事件日志项（如果阻止进入可升级模式的线程数超过阈值）。</span><span class="sxs-lookup"><span data-stu-id="f409b-551">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter upgradeable mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#33)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingWriteCount">
      <MemberSignature Language="C#" Value="public int WaitingWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f409b-552">获取等待进入写入模式锁定状态的线程总数。</span><span class="sxs-lookup"><span data-stu-id="f409b-552">Gets the total number of threads that are waiting to enter the lock in write mode.</span></span></summary>
        <value><span data-ttu-id="f409b-553">等待进入写入模式的线程总数。</span><span class="sxs-lookup"><span data-stu-id="f409b-553">The total number of threads that are waiting to enter write mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f409b-554">此属性仅用于调试、分析和日志记录目的，而不用于控制算法的行为。</span><span class="sxs-lookup"><span data-stu-id="f409b-554">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="f409b-555">计算结果后，结果就会更改。</span><span class="sxs-lookup"><span data-stu-id="f409b-555">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="f409b-556">因此，根据此属性做出决策并不安全。</span><span class="sxs-lookup"><span data-stu-id="f409b-556">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f409b-557">下面的示例演示如何使用 <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A> 属性生成事件日志项（如果阻止进入写入模式的线程数超过阈值）。</span><span class="sxs-lookup"><span data-stu-id="f409b-557">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter write mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#32)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
