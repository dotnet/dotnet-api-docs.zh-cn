<Type Name="EventWaitHandle" FullName="System.Threading.EventWaitHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f07982f459fc4e5626bd3ec5d2ca290748b32f32" /><Meta Name="ms.sourcegitcommit" Value="943c8cdbe5b47c6c296a6f4b73038bbd43da0dd2" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="02/12/2021" /><Meta Name="ms.locfileid" Value="100314335" /></Metadata><TypeSignature Language="C#" Value="public class EventWaitHandle : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventWaitHandle extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.EventWaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public Class EventWaitHandle&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventWaitHandle : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type EventWaitHandle = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Threading" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Threading" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="2fa31-101">表示一个线程同步事件。</span><span class="sxs-lookup"><span data-stu-id="2fa31-101">Represents a thread synchronization event.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fa31-102"><xref:System.Threading.EventWaitHandle>类允许线程通过发出信号互相通信。</span><span class="sxs-lookup"><span data-stu-id="2fa31-102">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling.</span></span> <span data-ttu-id="2fa31-103">通常，一个或多个线程会在上阻塞 <xref:System.Threading.EventWaitHandle> ，直到被阻止的线程调用 <xref:System.Threading.EventWaitHandle.Set%2A> 方法，释放一个或多个被阻止的线程。</span><span class="sxs-lookup"><span data-stu-id="2fa31-103">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, releasing one or more of the blocked threads.</span></span> <span data-ttu-id="2fa31-104">线程可以 <xref:System.Threading.EventWaitHandle> 通过调用 `static` `Shared` Visual Basic) 方法中的 (向发出信号，然后在其上进行阻止 <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="2fa31-104">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, by calling the `static` (`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2fa31-105"><xref:System.Threading.EventWaitHandle>类提供对已命名的系统同步事件的访问。</span><span class="sxs-lookup"><span data-stu-id="2fa31-105">The <xref:System.Threading.EventWaitHandle> class provides access to named system synchronization events.</span></span>  
  
 <span data-ttu-id="2fa31-106">已发出信号的的行为 <xref:System.Threading.EventWaitHandle> 取决于其重置模式。</span><span class="sxs-lookup"><span data-stu-id="2fa31-106">The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode.</span></span> <span data-ttu-id="2fa31-107"><xref:System.Threading.EventWaitHandle>使用标志创建的 <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> 时，在释放单个等待线程后，将自动重置。</span><span class="sxs-lookup"><span data-stu-id="2fa31-107">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="2fa31-108">在 <xref:System.Threading.EventWaitHandle.Reset%2A> 方法获得调用前，一直向使用 <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> 标志创建的 <xref:System.Threading.EventWaitHandle> 发出信号。</span><span class="sxs-lookup"><span data-stu-id="2fa31-108">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
 <span data-ttu-id="2fa31-109">自动重置事件提供对资源的独占访问权限。</span><span class="sxs-lookup"><span data-stu-id="2fa31-109">Automatic reset events provide exclusive access to a resource.</span></span> <span data-ttu-id="2fa31-110">如果向自动重置事件发出信号时没有线程正在等待，此信号会一直发出到有线程尝试在等待句柄上等待。</span><span class="sxs-lookup"><span data-stu-id="2fa31-110">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="2fa31-111">此时，事件会释放相应线程并立即重置自身，同时阻止后续线程。</span><span class="sxs-lookup"><span data-stu-id="2fa31-111">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
 <span data-ttu-id="2fa31-112">手动重置事件与入口类似。</span><span class="sxs-lookup"><span data-stu-id="2fa31-112">Manual reset events are like gates.</span></span> <span data-ttu-id="2fa31-113">如果事件未发出信号，则等待它的线程将会阻止。</span><span class="sxs-lookup"><span data-stu-id="2fa31-113">When the event is not signaled, threads that wait on it will block.</span></span> <span data-ttu-id="2fa31-114">当事件收到信号时，将释放所有正在等待的线程，并且事件将保持发出信号 (即，后续等待不会阻止) ，直到 <xref:System.Threading.EventWaitHandle.Reset%2A> 调用其方法。</span><span class="sxs-lookup"><span data-stu-id="2fa31-114">When the event is signaled, all waiting threads are released, and the event remains signaled (that is, subsequent waits do not block) until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="2fa31-115">如果一个线程必须完成某个活动，然后其他线程才能继续，则手动重置事件很有用。</span><span class="sxs-lookup"><span data-stu-id="2fa31-115">Manual reset events are useful when one thread must complete an activity before other threads can proceed.</span></span>  
  
 <span data-ttu-id="2fa31-116"><xref:System.Threading.EventWaitHandle> 对象可以与 `static` `Shared` Visual Basic) 和方法中的 (一起使用 <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="2fa31-116"><xref:System.Threading.EventWaitHandle> objects can be used with the `static`(`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="2fa31-117">有关详细信息，请参阅[同步基元概述](/dotnet/standard/threading/overview-of-synchronization-primitives)一文中的 "[线程交互" 或 "信号](/dotnet/standard/threading/overview-of-synchronization-primitives#thread-interaction-or-signaling)" 部分。</span><span class="sxs-lookup"><span data-stu-id="2fa31-117">For more information, see the [Thread interaction, or signaling](/dotnet/standard/threading/overview-of-synchronization-primitives#thread-interaction-or-signaling) section of the [Overview of synchronization primitives](/dotnet/standard/threading/overview-of-synchronization-primitives) article.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2fa31-118">下面的代码示例使用 <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> 方法重载，以允许主线程向阻止的线程发出信号，并等待线程完成任务。</span><span class="sxs-lookup"><span data-stu-id="2fa31-118">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="2fa31-119">该示例启动五个线程，并允许它们阻止 <xref:System.Threading.EventWaitHandle> 使用标志创建的 <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> ，然后在每次用户按 ENTER 键时释放一个线程。</span><span class="sxs-lookup"><span data-stu-id="2fa31-119">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="2fa31-120">然后，该示例将另一线程排队，并通过使用标志创建的所有线程释放它们 <xref:System.Threading.EventWaitHandle> <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="2fa31-120">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="2fa31-121">此类型是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="2fa31-121">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.AutoResetEvent" />
    <altmember cref="T:System.Threading.ManualResetEvent" />
    <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="2fa31-122">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="2fa31-122">Managed Threading</span></span></related>
    <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="2fa31-123">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="2fa31-123">Overview of synchronization primitives</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2fa31-124">初始化 <see cref="T:System.Threading.EventWaitHandle" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="2fa31-124">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
      </Parameters>
      <Docs>
        <param name="initialState"><span data-ttu-id="2fa31-125">如果为 <see langword="true" />，则将初始状态设置为终止；如果为 <see langword="false" />，则将初始状态设置为非终止。</span><span class="sxs-lookup"><span data-stu-id="2fa31-125"><see langword="true" /> to set the initial state to signaled; <see langword="false" /> to set it to nonsignaled.</span></span></param>
        <param name="mode"><span data-ttu-id="2fa31-126">其中一个 <see cref="T:System.Threading.EventResetMode" /> 值，它确定是自动还是手动重置事件。</span><span class="sxs-lookup"><span data-stu-id="2fa31-126">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span></span></param>
        <summary><span data-ttu-id="2fa31-127">初始化 <see cref="T:System.Threading.EventWaitHandle" /> 类的新实例，并指定等待句柄最初是否处于终止状态，以及它是自动重置还是手动重置。</span><span class="sxs-lookup"><span data-stu-id="2fa31-127">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fa31-128">如果事件的初始状态为非终止，则等待事件的线程将会阻止。</span><span class="sxs-lookup"><span data-stu-id="2fa31-128">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="2fa31-129">如果初始状态为 "已终止" 并且为 <xref:System.Threading.EventResetMode.ManualReset> 指定了标志 `mode` ，则等待事件的线程不会阻塞。</span><span class="sxs-lookup"><span data-stu-id="2fa31-129">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="2fa31-130">如果初始状态为 "已终止"，并且 `mode` 为 <xref:System.Threading.EventResetMode.AutoReset> ，则将立即释放等待事件的第一个线程，在此之后，事件将被重置，后续线程将被阻止。</span><span class="sxs-lookup"><span data-stu-id="2fa31-130">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2fa31-131">下面的代码示例使用 <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> 方法重载，以允许主线程向阻止的线程发出信号，并等待线程完成任务。</span><span class="sxs-lookup"><span data-stu-id="2fa31-131">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="2fa31-132">该示例启动五个线程，并允许它们阻止 <xref:System.Threading.EventWaitHandle> 使用标志创建的 <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> ，然后在每次用户按 ENTER 键时释放一个线程。</span><span class="sxs-lookup"><span data-stu-id="2fa31-132">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses ENTER key.</span></span> <span data-ttu-id="2fa31-133">然后，该示例将另一线程排队，并通过使用标志创建的所有线程释放它们 <xref:System.Threading.EventWaitHandle> <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="2fa31-133">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2fa31-134"><paramref name="mode" /> 枚举值超出了合法范围。</span><span class="sxs-lookup"><span data-stu-id="2fa31-134">The <paramref name="mode" /> enum value was out of legal range.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="2fa31-135">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="2fa31-135">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name)" />
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string? name);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialState"><span data-ttu-id="2fa31-136">如果将命名事件作为此调用的结果创建时将初始状态设置为通过信号通知，则为 <see langword="true" />；如果将其设置为不通过信号通知，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2fa31-136"><see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span></span></param>
        <param name="mode"><span data-ttu-id="2fa31-137">其中一个 <see cref="T:System.Threading.EventResetMode" /> 值，它确定是自动还是手动重置事件。</span><span class="sxs-lookup"><span data-stu-id="2fa31-137">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span></span></param>
        <param name="name"><span data-ttu-id="2fa31-138">如果要与其他进程共享同步对象，则为名称；否则为 <see langword="null" /> 或空字符串。</span><span class="sxs-lookup"><span data-stu-id="2fa31-138">The name, if the synchronization object is to be shared with other processes; otherwise, <see langword="null" /> or an empty string.</span></span> <span data-ttu-id="2fa31-139">该名称区分大小写。</span><span class="sxs-lookup"><span data-stu-id="2fa31-139">The name is case-sensitive.</span></span></param>
        <summary><span data-ttu-id="2fa31-140">初始化 <see cref="T:System.Threading.EventWaitHandle" /> 类的新实例，并指定在此调用后创建的等待句柄最初是否处于终止状态，它是自动重置还是手动重置，以及系统同步事件的名称。</span><span class="sxs-lookup"><span data-stu-id="2fa31-140">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fa31-141">`name`可以使用 `Global\` 或前缀 `Local\` 来指定命名空间。</span><span class="sxs-lookup"><span data-stu-id="2fa31-141">The `name` may be prefixed with `Global\` or `Local\` to specify a namespace.</span></span> <span data-ttu-id="2fa31-142">如果 `Global` 指定了命名空间，则同步对象可能与系统上的任何进程共享。</span><span class="sxs-lookup"><span data-stu-id="2fa31-142">When the `Global` namespace is specified, the synchronization object may be shared with any processes on the system.</span></span> <span data-ttu-id="2fa31-143">`Local`指定命名空间后，如果未指定命名空间，这也是默认命名空间，则同步对象可能与同一会话中的进程共享。</span><span class="sxs-lookup"><span data-stu-id="2fa31-143">When the `Local` namespace is specified, which is also the default when no namespace is specified, the synchronization object may be shared with processes in the same session.</span></span> <span data-ttu-id="2fa31-144">在 Windows 上，会话是一个登录会话，服务通常在不同的非交互式会话中运行。</span><span class="sxs-lookup"><span data-stu-id="2fa31-144">On Windows, a session is a login session, and services typically run in a different non-interactive session.</span></span> <span data-ttu-id="2fa31-145">在类似 Unix 的操作系统上，每个 shell 都有自己的会话。</span><span class="sxs-lookup"><span data-stu-id="2fa31-145">On Unix-like operating systems, each shell has its own session.</span></span> <span data-ttu-id="2fa31-146">会话本地同步对象可能适用于具有父/子关系的进程之间的同步，它们全都在同一会话中运行。</span><span class="sxs-lookup"><span data-stu-id="2fa31-146">Session-local synchronization objects may be appropriate for synchronizing between processes with a parent/child relationship where they all run in the same session.</span></span> <span data-ttu-id="2fa31-147">有关 Windows 上的 synchornization 对象名称的详细信息，请参阅 [对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。</span><span class="sxs-lookup"><span data-stu-id="2fa31-147">For more information about synchornization object names on Windows, see [Object Names](https://docs.microsoft.com/windows/win32/sync/object-names).</span></span>

 <span data-ttu-id="2fa31-148">如果提供了， `name` 并且命名空间中已存在请求类型的同步对象，则会打开现有的同步对象。</span><span class="sxs-lookup"><span data-stu-id="2fa31-148">If a `name` is provided and a synchronization object of the requested type already exists in the namespace, the existing synchronization object is opened.</span></span> <span data-ttu-id="2fa31-149">如果命名空间中已存在另一个类型的同步对象， `WaitHandleCannotBeOpenedException` 则会引发。</span><span class="sxs-lookup"><span data-stu-id="2fa31-149">If a synchronization object of a different type already exists in the namespace, a `WaitHandleCannotBeOpenedException` is thrown.</span></span> <span data-ttu-id="2fa31-150">否则，将创建一个新的同步对象。</span><span class="sxs-lookup"><span data-stu-id="2fa31-150">Otherwise, a new synchronization object is created.</span></span>
  
 <span data-ttu-id="2fa31-151">如果为参数指定了名称的系统事件 `name` 已存在，则忽略该 `initialState` 参数。</span><span class="sxs-lookup"><span data-stu-id="2fa31-151">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="2fa31-152">对已命名的系统事件使用此构造函数时，请将指定 `false` 为 `initialState` 。</span><span class="sxs-lookup"><span data-stu-id="2fa31-152">When using this constructor for named system events, specify `false` for `initialState`.</span></span> <span data-ttu-id="2fa31-153">此构造函数无法确定是否已创建已命名的系统事件，因此您无法对命名事件的状态进行任何假设。</span><span class="sxs-lookup"><span data-stu-id="2fa31-153">This constructor provides no way to determine whether a named system event was created, so you cannot make any assumptions about the state of the named event.</span></span> <span data-ttu-id="2fa31-154">若要确定是否已创建命名事件，请使用 <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> 构造函数或 <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> 构造函数。</span><span class="sxs-lookup"><span data-stu-id="2fa31-154">To determine whether a named event was created, use the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> constructor or the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> constructor.</span></span>  
  
 <span data-ttu-id="2fa31-155">如果事件的初始状态为非终止，则等待事件的线程将会阻止。</span><span class="sxs-lookup"><span data-stu-id="2fa31-155">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="2fa31-156">如果初始状态为 "已终止" 并且为 <xref:System.Threading.EventResetMode.ManualReset> 指定了标志 `mode` ，则等待事件的线程不会阻塞。</span><span class="sxs-lookup"><span data-stu-id="2fa31-156">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="2fa31-157">如果初始状态为 "已终止"，并且 `mode` 为 <xref:System.Threading.EventResetMode.AutoReset> ，则将立即释放等待事件的第一个线程，在此之后，事件将被重置，后续线程将被阻止。</span><span class="sxs-lookup"><span data-stu-id="2fa31-157">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2fa31-158"><paramref name="name" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="2fa31-158"><paramref name="name" /> is invalid.</span></span> <span data-ttu-id="2fa31-159">导致这种情况的原因有很多，包括操作系统可能会施加的一些限制，例如未知前缀或无效字符。</span><span class="sxs-lookup"><span data-stu-id="2fa31-159">This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters.</span></span> <span data-ttu-id="2fa31-160">请注意，名称和常见前缀 "Global\" 和 "Local\" 区分大小写。</span><span class="sxs-lookup"><span data-stu-id="2fa31-160">Note that the name and common prefixes "Global\" and "Local\" are case-sensitive.</span></span>

<span data-ttu-id="2fa31-161">或</span><span class="sxs-lookup"><span data-stu-id="2fa31-161">-or-</span></span>

<span data-ttu-id="2fa31-162">存在其他错误。</span><span class="sxs-lookup"><span data-stu-id="2fa31-162">There was some other error.</span></span> <span data-ttu-id="2fa31-163">`HResult` 属性可能提供更多信息。</span><span class="sxs-lookup"><span data-stu-id="2fa31-163">The `HResult` property may provide more information.</span></span></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><span data-ttu-id="2fa31-164">仅限 Windows：<paramref name="name" /> 指定了未知命名空间。</span><span class="sxs-lookup"><span data-stu-id="2fa31-164">Windows only: <paramref name="name" /> specified an unknown namespace.</span></span> <span data-ttu-id="2fa31-165">有关详细信息，请参阅[对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。</span><span class="sxs-lookup"><span data-stu-id="2fa31-165">See [Object Names](https://docs.microsoft.com/windows/win32/sync/object-names) for more information.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="2fa31-166"><paramref name="name" /> 太长。</span><span class="sxs-lookup"><span data-stu-id="2fa31-166">The <paramref name="name" /> is too long.</span></span> <span data-ttu-id="2fa31-167">长度限制可能取决于操作系统或配置。</span><span class="sxs-lookup"><span data-stu-id="2fa31-167">Length restrictions may depend on the operating system or configuration.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="2fa31-168">命名事件存在且具有访问控制安全性，但用户不具有 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />。</span><span class="sxs-lookup"><span data-stu-id="2fa31-168">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="2fa31-169">无法创建具有提供的 <paramref name="name" /> 的同步对象。</span><span class="sxs-lookup"><span data-stu-id="2fa31-169">A synchronization object with the provided <paramref name="name" /> cannot be created.</span></span> <span data-ttu-id="2fa31-170">不同类型的同步对象可能具有相同的名称。</span><span class="sxs-lookup"><span data-stu-id="2fa31-170">A synchronization object of a different type might have the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2fa31-171"><paramref name="mode" /> 枚举值超出了合法范围。</span><span class="sxs-lookup"><span data-stu-id="2fa31-171">The <paramref name="mode" /> enum value was out of legal range.</span></span>

<span data-ttu-id="2fa31-172">或</span><span class="sxs-lookup"><span data-stu-id="2fa31-172">-or-</span></span>

<span data-ttu-id="2fa31-173">仅限 .NET Framework：<paramref name="name" /> 的长度超过 MAX_PATH（260 个字符）。</span><span class="sxs-lookup"><span data-stu-id="2fa31-173">.NET Framework only: <paramref name="name" /> is longer than MAX_PATH (260 characters).</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="2fa31-174">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="2fa31-174">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string * bool -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew)" />
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string? name, out bool? createdNew);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialState"><span data-ttu-id="2fa31-175">如果将命名事件作为此调用的结果创建时将初始状态设置为通过信号通知，则为 <see langword="true" />；如果将其设置为不通过信号通知，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2fa31-175"><see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span></span></param>
        <param name="mode"><span data-ttu-id="2fa31-176">其中一个 <see cref="T:System.Threading.EventResetMode" /> 值，它确定是自动还是手动重置事件。</span><span class="sxs-lookup"><span data-stu-id="2fa31-176">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span></span></param>
        <param name="name"><span data-ttu-id="2fa31-177">如果要与其他进程共享同步对象，则为名称；否则为 <see langword="null" /> 或空字符串。</span><span class="sxs-lookup"><span data-stu-id="2fa31-177">The name, if the synchronization object is to be shared with other processes; otherwise, <see langword="null" /> or an empty string.</span></span> <span data-ttu-id="2fa31-178">该名称区分大小写。</span><span class="sxs-lookup"><span data-stu-id="2fa31-178">The name is case-sensitive.</span></span></param>
        <param name="createdNew"><span data-ttu-id="2fa31-179">在此方法返回时，如果创建了本地事件（即，如果 <paramref name="name" /> 为 <see langword="true" /> 或空字符串）或指定的命名系统事件，则包含 <see langword="null" />；如果指定的命名系统事件已存在，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2fa31-179">When this method returns, contains <see langword="true" /> if a local event was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system event was created; <see langword="false" /> if the specified named system event already existed.</span></span> <span data-ttu-id="2fa31-180">此参数未经初始化即被传递。</span><span class="sxs-lookup"><span data-stu-id="2fa31-180">This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="2fa31-181">初始化 <see cref="T:System.Threading.EventWaitHandle" /> 类的新实例，指定如果将等待句柄作为此调用的结果而创建，最初是否通过信号通知此句柄；指定是否自动或手动重置系统同步事件的名称，以及一个布尔变量，在调用后其值指示是否创建了命名的系统事件。</span><span class="sxs-lookup"><span data-stu-id="2fa31-181">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fa31-182">`name`可以使用 `Global\` 或前缀 `Local\` 来指定命名空间。</span><span class="sxs-lookup"><span data-stu-id="2fa31-182">The `name` may be prefixed with `Global\` or `Local\` to specify a namespace.</span></span> <span data-ttu-id="2fa31-183">如果 `Global` 指定了命名空间，则同步对象可能与系统上的任何进程共享。</span><span class="sxs-lookup"><span data-stu-id="2fa31-183">When the `Global` namespace is specified, the synchronization object may be shared with any processes on the system.</span></span> <span data-ttu-id="2fa31-184">`Local`指定命名空间后，如果未指定命名空间，这也是默认命名空间，则同步对象可能与同一会话中的进程共享。</span><span class="sxs-lookup"><span data-stu-id="2fa31-184">When the `Local` namespace is specified, which is also the default when no namespace is specified, the synchronization object may be shared with processes in the same session.</span></span> <span data-ttu-id="2fa31-185">在 Windows 上，会话是一个登录会话，服务通常在不同的非交互式会话中运行。</span><span class="sxs-lookup"><span data-stu-id="2fa31-185">On Windows, a session is a login session, and services typically run in a different non-interactive session.</span></span> <span data-ttu-id="2fa31-186">在类似 Unix 的操作系统上，每个 shell 都有自己的会话。</span><span class="sxs-lookup"><span data-stu-id="2fa31-186">On Unix-like operating systems, each shell has its own session.</span></span> <span data-ttu-id="2fa31-187">会话本地同步对象可能适用于具有父/子关系的进程之间的同步，它们全都在同一会话中运行。</span><span class="sxs-lookup"><span data-stu-id="2fa31-187">Session-local synchronization objects may be appropriate for synchronizing between processes with a parent/child relationship where they all run in the same session.</span></span> <span data-ttu-id="2fa31-188">有关 Windows 上的 synchornization 对象名称的详细信息，请参阅 [对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。</span><span class="sxs-lookup"><span data-stu-id="2fa31-188">For more information about synchornization object names on Windows, see [Object Names](https://docs.microsoft.com/windows/win32/sync/object-names).</span></span>

 <span data-ttu-id="2fa31-189">如果提供了， `name` 并且命名空间中已存在请求类型的同步对象，则会打开现有的同步对象。</span><span class="sxs-lookup"><span data-stu-id="2fa31-189">If a `name` is provided and a synchronization object of the requested type already exists in the namespace, the existing synchronization object is opened.</span></span> <span data-ttu-id="2fa31-190">如果命名空间中已存在另一个类型的同步对象， `WaitHandleCannotBeOpenedException` 则会引发。</span><span class="sxs-lookup"><span data-stu-id="2fa31-190">If a synchronization object of a different type already exists in the namespace, a `WaitHandleCannotBeOpenedException` is thrown.</span></span> <span data-ttu-id="2fa31-191">否则，将创建一个新的同步对象。</span><span class="sxs-lookup"><span data-stu-id="2fa31-191">Otherwise, a new synchronization object is created.</span></span>

 <span data-ttu-id="2fa31-192">如果为参数指定了名称的系统事件 `name` 已存在，则忽略该 `initialState` 参数。</span><span class="sxs-lookup"><span data-stu-id="2fa31-192">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span> <span data-ttu-id="2fa31-193">调用此构造函数后，在 Visual Basic) 中为参数 (参数指定的变量中的值， `ref` `ByRef` `createdNew` 以确定已存在还是已创建已命名的系统事件。</span><span class="sxs-lookup"><span data-stu-id="2fa31-193">After calling this constructor, use the value in the variable specified for the `ref` parameter (`ByRef` parameter in Visual Basic)`createdNew` to determine whether the named system event already existed or was created.</span></span>  
  
 <span data-ttu-id="2fa31-194">如果事件的初始状态为非终止，则等待事件的线程将会阻止。</span><span class="sxs-lookup"><span data-stu-id="2fa31-194">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="2fa31-195">如果初始状态为 "已终止" 并且为 <xref:System.Threading.EventResetMode.ManualReset> 指定了标志 `mode` ，则等待事件的线程不会阻塞。</span><span class="sxs-lookup"><span data-stu-id="2fa31-195">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="2fa31-196">如果初始状态为 "已终止"，并且 `mode` 为 <xref:System.Threading.EventResetMode.AutoReset> ，则将立即释放等待事件的第一个线程，在此之后，事件将被重置，后续线程将被阻止。</span><span class="sxs-lookup"><span data-stu-id="2fa31-196">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2fa31-197"><paramref name="name" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="2fa31-197"><paramref name="name" /> is invalid.</span></span> <span data-ttu-id="2fa31-198">导致这种情况的原因有很多，包括操作系统可能会施加的一些限制，例如未知前缀或无效字符。</span><span class="sxs-lookup"><span data-stu-id="2fa31-198">This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters.</span></span> <span data-ttu-id="2fa31-199">请注意，名称和常见前缀 "Global\" 和 "Local\" 区分大小写。</span><span class="sxs-lookup"><span data-stu-id="2fa31-199">Note that the name and common prefixes "Global\" and "Local\" are case-sensitive.</span></span>

<span data-ttu-id="2fa31-200">或</span><span class="sxs-lookup"><span data-stu-id="2fa31-200">-or-</span></span>

<span data-ttu-id="2fa31-201">存在其他错误。</span><span class="sxs-lookup"><span data-stu-id="2fa31-201">There was some other error.</span></span> <span data-ttu-id="2fa31-202">`HResult` 属性可能提供更多信息。</span><span class="sxs-lookup"><span data-stu-id="2fa31-202">The `HResult` property may provide more information.</span></span></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><span data-ttu-id="2fa31-203">仅限 Windows：<paramref name="name" /> 指定了未知命名空间。</span><span class="sxs-lookup"><span data-stu-id="2fa31-203">Windows only: <paramref name="name" /> specified an unknown namespace.</span></span> <span data-ttu-id="2fa31-204">有关详细信息，请参阅[对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。</span><span class="sxs-lookup"><span data-stu-id="2fa31-204">See [Object Names](https://docs.microsoft.com/windows/win32/sync/object-names) for more information.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="2fa31-205"><paramref name="name" /> 太长。</span><span class="sxs-lookup"><span data-stu-id="2fa31-205">The <paramref name="name" /> is too long.</span></span> <span data-ttu-id="2fa31-206">长度限制可能取决于操作系统或配置。</span><span class="sxs-lookup"><span data-stu-id="2fa31-206">Length restrictions may depend on the operating system or configuration.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="2fa31-207">命名事件存在且具有访问控制安全性，但用户不具有 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />。</span><span class="sxs-lookup"><span data-stu-id="2fa31-207">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="2fa31-208">无法创建具有提供的 <paramref name="name" /> 的同步对象。</span><span class="sxs-lookup"><span data-stu-id="2fa31-208">A synchronization object with the provided <paramref name="name" /> cannot be created.</span></span> <span data-ttu-id="2fa31-209">不同类型的同步对象可能具有相同的名称。</span><span class="sxs-lookup"><span data-stu-id="2fa31-209">A synchronization object of a different type might have the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2fa31-210"><paramref name="mode" /> 枚举值超出了合法范围。</span><span class="sxs-lookup"><span data-stu-id="2fa31-210">The <paramref name="mode" /> enum value was out of legal range.</span></span>

<span data-ttu-id="2fa31-211">或</span><span class="sxs-lookup"><span data-stu-id="2fa31-211">-or-</span></span>

<span data-ttu-id="2fa31-212">仅限 .NET Framework：<paramref name="name" /> 的长度超过 MAX_PATH（260 个字符）。</span><span class="sxs-lookup"><span data-stu-id="2fa31-212">.NET Framework only: <paramref name="name" /> is longer than MAX_PATH (260 characters).</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="2fa31-213">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="2fa31-213">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean, eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string * bool * System.Security.AccessControl.EventWaitHandleSecurity -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew, eventSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="initialState"><span data-ttu-id="2fa31-214">如果将命名事件作为此调用的结果创建时将初始状态设置为通过信号通知，则为 <see langword="true" />；如果将其设置为不通过信号通知，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2fa31-214"><see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span></span></param>
        <param name="mode"><span data-ttu-id="2fa31-215">其中一个 <see cref="T:System.Threading.EventResetMode" /> 值，它确定是自动还是手动重置事件。</span><span class="sxs-lookup"><span data-stu-id="2fa31-215">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span></span></param>
        <param name="name"><span data-ttu-id="2fa31-216">如果要与其他进程共享同步对象，则为名称；否则为 <see langword="null" /> 或空字符串。</span><span class="sxs-lookup"><span data-stu-id="2fa31-216">The name, if the synchronization object is to be shared with other processes; otherwise, <see langword="null" /> or an empty string.</span></span> <span data-ttu-id="2fa31-217">该名称区分大小写。</span><span class="sxs-lookup"><span data-stu-id="2fa31-217">The name is case-sensitive.</span></span></param>
        <param name="createdNew"><span data-ttu-id="2fa31-218">在此方法返回时，如果创建了本地事件（即，如果 <paramref name="name" /> 为 <see langword="true" /> 或空字符串）或指定的命名系统事件，则包含 <see langword="null" />；如果指定的命名系统事件已存在，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2fa31-218">When this method returns, contains <see langword="true" /> if a local event was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system event was created; <see langword="false" /> if the specified named system event already existed.</span></span> <span data-ttu-id="2fa31-219">此参数未经初始化即被传递。</span><span class="sxs-lookup"><span data-stu-id="2fa31-219">This parameter is passed uninitialized.</span></span></param>
        <param name="eventSecurity"><span data-ttu-id="2fa31-220">一个 <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> 对象，该对象表示应用到命名系统事件的访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="2fa31-220">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security to be applied to the named system event.</span></span></param>
        <summary><span data-ttu-id="2fa31-221">初始化 <see cref="T:System.Threading.EventWaitHandle" /> 类的新实例，指定如果等待句柄作为此调用的结果而创建，最初是否通过信号通知此句柄；指定是否自动或手动重置系统同步事件的名称和布尔变量，其值在该调用后将指示是否创建了已命名系统事件，以及是否将访问控制安全性应用到命名事件（如果已创建该事件）。</span><span class="sxs-lookup"><span data-stu-id="2fa31-221">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, a Boolean variable whose value after the call indicates whether the named system event was created, and the access control security to be applied to the named event if it is created.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fa31-222">使用此构造函数在创建已命名的系统事件时将其应用于该事件，从而防止其他代码控制该事件。</span><span class="sxs-lookup"><span data-stu-id="2fa31-222">Use this constructor to apply access control security to a named system event when it is created, preventing other code from taking control of the event.</span></span>  
  
 <span data-ttu-id="2fa31-223">此构造函数初始化 <xref:System.Threading.EventWaitHandle> 表示系统事件的对象。</span><span class="sxs-lookup"><span data-stu-id="2fa31-223">This constructor initializes an <xref:System.Threading.EventWaitHandle> object that represents a system event.</span></span> <span data-ttu-id="2fa31-224">可以创建多个 <xref:System.Threading.EventWaitHandle> 表示同一系统事件的对象。</span><span class="sxs-lookup"><span data-stu-id="2fa31-224">You can create multiple <xref:System.Threading.EventWaitHandle> objects that represent the same system event.</span></span>  
  
 <span data-ttu-id="2fa31-225">如果系统事件不存在，则将使用指定的访问控制安全性来创建它。</span><span class="sxs-lookup"><span data-stu-id="2fa31-225">If the system event does not exist, it is created with the specified access control security.</span></span> <span data-ttu-id="2fa31-226">如果该事件存在，则忽略指定的访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="2fa31-226">If the event exists, the specified access control security is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2fa31-227">调用方对新创建的对象拥有完全控制权， <xref:System.Threading.EventWaitHandle> 即使 `eventSecurity` 拒绝或无法向当前用户授予某些访问权限。</span><span class="sxs-lookup"><span data-stu-id="2fa31-227">The caller has full control over the newly created <xref:System.Threading.EventWaitHandle> object even if `eventSecurity` denies or fails to grant some access rights to the current user.</span></span> <span data-ttu-id="2fa31-228">但是，如果当前用户尝试 <xref:System.Threading.EventWaitHandle> 使用构造函数或方法获取表示相同命名事件的另一个对象， <xref:System.Threading.EventWaitHandle.OpenExisting%2A> 则应用 Windows 访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="2fa31-228">However, if the current user attempts to get another <xref:System.Threading.EventWaitHandle> object to represent the same named event, using either a constructor or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, Windows access control security is applied.</span></span>  
  
 <span data-ttu-id="2fa31-229">`name`可以使用 `Global\` 或前缀 `Local\` 来指定命名空间。</span><span class="sxs-lookup"><span data-stu-id="2fa31-229">The `name` may be prefixed with `Global\` or `Local\` to specify a namespace.</span></span> <span data-ttu-id="2fa31-230">如果 `Global` 指定了命名空间，则同步对象可能与系统上的任何进程共享。</span><span class="sxs-lookup"><span data-stu-id="2fa31-230">When the `Global` namespace is specified, the synchronization object may be shared with any processes on the system.</span></span> <span data-ttu-id="2fa31-231">`Local`指定命名空间后，如果未指定命名空间，这也是默认命名空间，则同步对象可能与同一会话中的进程共享。</span><span class="sxs-lookup"><span data-stu-id="2fa31-231">When the `Local` namespace is specified, which is also the default when no namespace is specified, the synchronization object may be shared with processes in the same session.</span></span> <span data-ttu-id="2fa31-232">在 Windows 上，会话是一个登录会话，服务通常在不同的非交互式会话中运行。</span><span class="sxs-lookup"><span data-stu-id="2fa31-232">On Windows, a session is a login session, and services typically run in a different non-interactive session.</span></span> <span data-ttu-id="2fa31-233">在类似 Unix 的操作系统上，每个 shell 都有自己的会话。</span><span class="sxs-lookup"><span data-stu-id="2fa31-233">On Unix-like operating systems, each shell has its own session.</span></span> <span data-ttu-id="2fa31-234">会话本地同步对象可能适用于具有父/子关系的进程之间的同步，它们全都在同一会话中运行。</span><span class="sxs-lookup"><span data-stu-id="2fa31-234">Session-local synchronization objects may be appropriate for synchronizing between processes with a parent/child relationship where they all run in the same session.</span></span> <span data-ttu-id="2fa31-235">有关 Windows 上的 synchornization 对象名称的详细信息，请参阅 [对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。</span><span class="sxs-lookup"><span data-stu-id="2fa31-235">For more information about synchornization object names on Windows, see [Object Names](https://docs.microsoft.com/windows/win32/sync/object-names).</span></span>

 <span data-ttu-id="2fa31-236">如果提供了， `name` 并且命名空间中已存在请求类型的同步对象，则会打开现有的同步对象。</span><span class="sxs-lookup"><span data-stu-id="2fa31-236">If a `name` is provided and a synchronization object of the requested type already exists in the namespace, the existing synchronization object is opened.</span></span> <span data-ttu-id="2fa31-237">如果命名空间中已存在另一个类型的同步对象， `WaitHandleCannotBeOpenedException` 则会引发。</span><span class="sxs-lookup"><span data-stu-id="2fa31-237">If a synchronization object of a different type already exists in the namespace, a `WaitHandleCannotBeOpenedException` is thrown.</span></span> <span data-ttu-id="2fa31-238">否则，将创建一个新的同步对象。</span><span class="sxs-lookup"><span data-stu-id="2fa31-238">Otherwise, a new synchronization object is created.</span></span>

 <span data-ttu-id="2fa31-239">如果为参数指定了名称的系统事件 `name` 已存在，则忽略该 `initialState` 参数。</span><span class="sxs-lookup"><span data-stu-id="2fa31-239">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span> <span data-ttu-id="2fa31-240">调用此构造函数后，在 Visual Basic) 中为参数 (参数指定的变量中的值， `ref` `ByRef` `createdNew` 以确定已存在还是已创建已命名的系统事件。</span><span class="sxs-lookup"><span data-stu-id="2fa31-240">After calling this constructor, use the value in the variable specified for the `ref` parameter (`ByRef` parameter in Visual Basic) `createdNew` to determine whether the named system event already existed or was created.</span></span>  
  
 <span data-ttu-id="2fa31-241">如果事件的初始状态为非终止，则等待事件的线程将会阻止。</span><span class="sxs-lookup"><span data-stu-id="2fa31-241">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="2fa31-242">如果初始状态为 "已终止" 并且为 <xref:System.Threading.EventResetMode.ManualReset> 指定了标志 `mode` ，则等待事件的线程不会阻塞。</span><span class="sxs-lookup"><span data-stu-id="2fa31-242">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="2fa31-243">如果初始状态为 "已终止"，并且 `mode` 为 <xref:System.Threading.EventResetMode.AutoReset> ，则将立即释放等待事件的第一个线程，在此之后，事件将被重置，后续线程将被阻止。</span><span class="sxs-lookup"><span data-stu-id="2fa31-243">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2fa31-244">下面的代码示例演示具有访问控制安全性的已命名系统事件的跨进程行为。</span><span class="sxs-lookup"><span data-stu-id="2fa31-244">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="2fa31-245">该示例使用 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> 方法重载来测试是否存在已命名的事件。</span><span class="sxs-lookup"><span data-stu-id="2fa31-245">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="2fa31-246">如果此事件不存在，则将使用初始所有权和访问控制安全性来创建该事件，拒绝当前用户使用该事件，但会授予读取和更改事件权限的权限。</span><span class="sxs-lookup"><span data-stu-id="2fa31-246">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="2fa31-247">如果从两个命令窗口运行已编译的示例，第二个副本将在调用时引发访问冲突异常 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="2fa31-247">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="2fa31-248">捕获到异常，该示例使用 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> 方法重载来等待事件，该事件具有读取和更改权限所需的权限。</span><span class="sxs-lookup"><span data-stu-id="2fa31-248">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="2fa31-249">更改权限后，将以等待事件的权限打开事件，并向其发出信号。</span><span class="sxs-lookup"><span data-stu-id="2fa31-249">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="2fa31-250">如果从第三个命令窗口运行已编译的示例，该示例将使用新的权限运行。</span><span class="sxs-lookup"><span data-stu-id="2fa31-250">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2fa31-251"><paramref name="name" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="2fa31-251"><paramref name="name" /> is invalid.</span></span> <span data-ttu-id="2fa31-252">导致这种情况的原因有很多，包括操作系统可能会施加的一些限制，例如未知前缀或无效字符。</span><span class="sxs-lookup"><span data-stu-id="2fa31-252">This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters.</span></span> <span data-ttu-id="2fa31-253">请注意，名称和常见前缀 "Global\" 和 "Local\" 区分大小写。</span><span class="sxs-lookup"><span data-stu-id="2fa31-253">Note that the name and common prefixes "Global\" and "Local\" are case-sensitive.</span></span>

<span data-ttu-id="2fa31-254">或</span><span class="sxs-lookup"><span data-stu-id="2fa31-254">-or-</span></span>

<span data-ttu-id="2fa31-255">存在其他错误。</span><span class="sxs-lookup"><span data-stu-id="2fa31-255">There was some other error.</span></span> <span data-ttu-id="2fa31-256">`HResult` 属性可能提供更多信息。</span><span class="sxs-lookup"><span data-stu-id="2fa31-256">The `HResult` property may provide more information.</span></span></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><span data-ttu-id="2fa31-257">仅限 Windows：<paramref name="name" /> 指定了未知命名空间。</span><span class="sxs-lookup"><span data-stu-id="2fa31-257">Windows only: <paramref name="name" /> specified an unknown namespace.</span></span> <span data-ttu-id="2fa31-258">有关详细信息，请参阅[对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。</span><span class="sxs-lookup"><span data-stu-id="2fa31-258">See [Object Names](https://docs.microsoft.com/windows/win32/sync/object-names) for more information.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="2fa31-259"><paramref name="name" /> 太长。</span><span class="sxs-lookup"><span data-stu-id="2fa31-259">The <paramref name="name" /> is too long.</span></span> <span data-ttu-id="2fa31-260">长度限制可能取决于操作系统或配置。</span><span class="sxs-lookup"><span data-stu-id="2fa31-260">Length restrictions may depend on the operating system or configuration.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="2fa31-261">命名事件存在且具有访问控制安全性，但用户不具有 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />。</span><span class="sxs-lookup"><span data-stu-id="2fa31-261">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="2fa31-262">无法创建具有提供的 <paramref name="name" /> 的同步对象。</span><span class="sxs-lookup"><span data-stu-id="2fa31-262">A synchronization object with the provided <paramref name="name" /> cannot be created.</span></span> <span data-ttu-id="2fa31-263">不同类型的同步对象可能具有相同的名称。</span><span class="sxs-lookup"><span data-stu-id="2fa31-263">A synchronization object of a different type might have the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2fa31-264"><paramref name="mode" /> 枚举值超出了合法范围。</span><span class="sxs-lookup"><span data-stu-id="2fa31-264">The <paramref name="mode" /> enum value was out of legal range.</span></span>

<span data-ttu-id="2fa31-265">或</span><span class="sxs-lookup"><span data-stu-id="2fa31-265">-or-</span></span>

<span data-ttu-id="2fa31-266">仅限 .NET Framework：<paramref name="name" /> 的长度超过 MAX_PATH（260 个字符）。</span><span class="sxs-lookup"><span data-stu-id="2fa31-266">.NET Framework only: <paramref name="name" /> is longer than MAX_PATH (260 characters).</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="2fa31-267">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="2fa31-267">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As EventWaitHandleSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::EventWaitHandleSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.EventWaitHandleSecurity" Usage="eventWaitHandle.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.EventWaitHandleSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2fa31-268">获取 <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> 对象，该对象表示由当前 <see cref="T:System.Threading.EventWaitHandle" /> 对象表示的已命名系统事件的访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="2fa31-268">Gets an <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security for the named system event represented by the current <see cref="T:System.Threading.EventWaitHandle" /> object.</span></span></summary>
        <returns><span data-ttu-id="2fa31-269">一个 <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> 对象，它表示已命名系统事件的访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="2fa31-269">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security for the named system event.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fa31-270"><xref:System.Threading.EventWaitHandle.GetAccessControl%2A>方法使用按位 "或" 运算) 组合 (下面的标志组合来搜索权限： <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType> 、 <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType> 和 <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="2fa31-270">The <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, and <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="2fa31-271">用户必须具有 <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> 调用此方法的权限，并且必须使用标志打开事件 <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="2fa31-271">The user must have <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> rights to call this method, and the event must have been opened with the <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> flag.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2fa31-272">下面的代码示例演示具有访问控制安全性的已命名系统事件的跨进程行为。</span><span class="sxs-lookup"><span data-stu-id="2fa31-272">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="2fa31-273">该示例使用 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> 方法重载来测试是否存在已命名的事件。</span><span class="sxs-lookup"><span data-stu-id="2fa31-273">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="2fa31-274">如果此事件不存在，则将使用初始所有权和访问控制安全性来创建该事件，拒绝当前用户使用该事件，但会授予读取和更改事件权限的权限。</span><span class="sxs-lookup"><span data-stu-id="2fa31-274">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="2fa31-275">如果从两个命令窗口运行已编译的示例，第二个副本将在调用时引发访问冲突异常 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="2fa31-275">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="2fa31-276">捕获到异常，该示例使用 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> 方法重载来等待事件，该事件具有读取和更改权限所需的权限。</span><span class="sxs-lookup"><span data-stu-id="2fa31-276">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="2fa31-277">读取权限后，使用 <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> 方法，并更改事件时，将使用等待请求并向其发出信号来打开事件。</span><span class="sxs-lookup"><span data-stu-id="2fa31-277">After the permissions have been read, using the <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> method, and changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="2fa31-278">如果从第三个命令窗口运行已编译的示例，该示例将使用新的权限运行。</span><span class="sxs-lookup"><span data-stu-id="2fa31-278">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="2fa31-279">当前的 <see cref="T:System.Threading.EventWaitHandle" /> 对象表示已命名的系统事件，且用户不具备 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />。</span><span class="sxs-lookup"><span data-stu-id="2fa31-279">The current <see cref="T:System.Threading.EventWaitHandle" /> object represents a named system event, and the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span></span>  
  
<span data-ttu-id="2fa31-280">- 或 -</span><span class="sxs-lookup"><span data-stu-id="2fa31-280">-or-</span></span> 
<span data-ttu-id="2fa31-281">当前 <see cref="T:System.Threading.EventWaitHandle" /> 对象表示一个已命名的系统事件，但它不是以 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" /> 打开的。</span><span class="sxs-lookup"><span data-stu-id="2fa31-281">The current <see cref="T:System.Threading.EventWaitHandle" /> object represents a named system event, and was not opened with <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2fa31-282">不支持 Windows 98 或 Windows Millennium Edition。</span><span class="sxs-lookup"><span data-stu-id="2fa31-282">Not supported for Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2fa31-283">之前已在此 <see cref="T:System.Threading.EventWaitHandle" /> 上调用 <see cref="M:System.Threading.WaitHandle.Close" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="2fa31-283">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="2fa31-284">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="2fa31-284">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2fa31-285">打开指定名称为同步事件（如果已经存在).</span><span class="sxs-lookup"><span data-stu-id="2fa31-285">Opens a specified named synchronization event, if it already exists.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-5.0">
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("windows")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("windows")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="2fa31-286">要打开并与其他进程共享的同步对象的名称。</span><span class="sxs-lookup"><span data-stu-id="2fa31-286">The name of the synchronization object to be opened and shared with other processes.</span></span> <span data-ttu-id="2fa31-287">该名称区分大小写。</span><span class="sxs-lookup"><span data-stu-id="2fa31-287">The name is case-sensitive.</span></span></param>
        <summary><span data-ttu-id="2fa31-288">打开指定名称为同步事件（如果已经存在）。</span><span class="sxs-lookup"><span data-stu-id="2fa31-288">Opens the specified named synchronization event, if it already exists.</span></span></summary>
        <returns><span data-ttu-id="2fa31-289">一个对象，表示已命名的系统事件。</span><span class="sxs-lookup"><span data-stu-id="2fa31-289">An  object that represents the named system event.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fa31-290">`name`可以使用 `Global\` 或前缀 `Local\` 来指定命名空间。</span><span class="sxs-lookup"><span data-stu-id="2fa31-290">The `name` may be prefixed with `Global\` or `Local\` to specify a namespace.</span></span> <span data-ttu-id="2fa31-291">如果 `Global` 指定了命名空间，则同步对象可能与系统上的任何进程共享。</span><span class="sxs-lookup"><span data-stu-id="2fa31-291">When the `Global` namespace is specified, the synchronization object may be shared with any processes on the system.</span></span> <span data-ttu-id="2fa31-292">`Local`指定命名空间后，如果未指定命名空间，这也是默认命名空间，则同步对象可能与同一会话中的进程共享。</span><span class="sxs-lookup"><span data-stu-id="2fa31-292">When the `Local` namespace is specified, which is also the default when no namespace is specified, the synchronization object may be shared with processes in the same session.</span></span> <span data-ttu-id="2fa31-293">在 Windows 上，会话是一个登录会话，服务通常在不同的非交互式会话中运行。</span><span class="sxs-lookup"><span data-stu-id="2fa31-293">On Windows, a session is a login session, and services typically run in a different non-interactive session.</span></span> <span data-ttu-id="2fa31-294">在类似 Unix 的操作系统上，每个 shell 都有自己的会话。</span><span class="sxs-lookup"><span data-stu-id="2fa31-294">On Unix-like operating systems, each shell has its own session.</span></span> <span data-ttu-id="2fa31-295">会话本地同步对象可能适用于具有父/子关系的进程之间的同步，它们全都在同一会话中运行。</span><span class="sxs-lookup"><span data-stu-id="2fa31-295">Session-local synchronization objects may be appropriate for synchronizing between processes with a parent/child relationship where they all run in the same session.</span></span> <span data-ttu-id="2fa31-296">有关 Windows 上的 synchornization 对象名称的详细信息，请参阅 [对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。</span><span class="sxs-lookup"><span data-stu-id="2fa31-296">For more information about synchornization object names on Windows, see [Object Names](https://docs.microsoft.com/windows/win32/sync/object-names).</span></span>

 <span data-ttu-id="2fa31-297">如果命名空间中存在请求类型的同步对象，则会打开现有的同步对象。</span><span class="sxs-lookup"><span data-stu-id="2fa31-297">If a synchronization object of the requested type exists in the namespace, the existing synchronization object is opened.</span></span> <span data-ttu-id="2fa31-298">如果命名空间中不存在同步对象，或者命名空间中存在其他类型的同步对象， `WaitHandleCannotBeOpenedException` 则会引发。</span><span class="sxs-lookup"><span data-stu-id="2fa31-298">If a synchronization object does not exist in the namespace, or a synchronization object of a different type exists in the namespace, a `WaitHandleCannotBeOpenedException` is thrown.</span></span>

 <span data-ttu-id="2fa31-299">此 <xref:System.Threading.EventWaitHandle.OpenExisting%2A> 方法尝试打开指定的已命名系统事件。</span><span class="sxs-lookup"><span data-stu-id="2fa31-299">The <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method tries to open the specified named system event.</span></span> <span data-ttu-id="2fa31-300">若要在不存在系统事件时创建系统事件，请使用 <xref:System.Threading.EventWaitHandle.%23ctor%2A> 具有参数的构造函数之一 `name` 。</span><span class="sxs-lookup"><span data-stu-id="2fa31-300">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>
  
 <span data-ttu-id="2fa31-301">对此方法使用相同值的多个调用 `name` 不一定会返回相同的 <xref:System.Threading.EventWaitHandle> 对象，即使返回的对象表示相同的命名系统事件也是如此。</span><span class="sxs-lookup"><span data-stu-id="2fa31-301">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 <span data-ttu-id="2fa31-302">此方法重载等效于调用 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> 方法重载，并 <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> 使用按位 "或" 运算来指定和权限。</span><span class="sxs-lookup"><span data-stu-id="2fa31-302">This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span>  
  
 <span data-ttu-id="2fa31-303">指定 <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> 标志将允许线程等待已命名的系统事件，并指定 <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> 标志允许线程调用 <xref:System.Threading.EventWaitHandle.Set%2A> 和 <xref:System.Threading.EventWaitHandle.Reset%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="2fa31-303">Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2fa31-304">下面的代码示例演示具有访问控制安全性的已命名系统事件的跨进程行为。</span><span class="sxs-lookup"><span data-stu-id="2fa31-304">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="2fa31-305">该示例使用 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> 方法重载来测试是否存在已命名的事件。</span><span class="sxs-lookup"><span data-stu-id="2fa31-305">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="2fa31-306">如果此事件不存在，则将使用初始所有权和访问控制安全性来创建该事件，拒绝当前用户使用该事件，但会授予读取和更改事件权限的权限。</span><span class="sxs-lookup"><span data-stu-id="2fa31-306">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="2fa31-307">如果从两个命令窗口运行已编译的示例，第二个副本将在调用时引发访问冲突异常 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="2fa31-307">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="2fa31-308">捕获到异常，该示例使用 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> 方法重载来等待事件，该事件具有读取和更改权限所需的权限。</span><span class="sxs-lookup"><span data-stu-id="2fa31-308">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="2fa31-309">更改权限后，将以等待事件的权限打开事件，并向其发出信号。</span><span class="sxs-lookup"><span data-stu-id="2fa31-309">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="2fa31-310">如果从第三个命令窗口运行已编译的示例，该示例将使用新的权限运行。</span><span class="sxs-lookup"><span data-stu-id="2fa31-310">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="2fa31-311">无法打开具有提供的 <paramref name="name" /> 的同步对象。</span><span class="sxs-lookup"><span data-stu-id="2fa31-311">A synchronization object with the provided <paramref name="name" /> cannot be opened.</span></span> <span data-ttu-id="2fa31-312">该对象可能不存在，或者不同类型的同步对象可能具有相同的名称。</span><span class="sxs-lookup"><span data-stu-id="2fa31-312">It may not exist, or a synchronization object of a different type might have the same name.</span></span> <span data-ttu-id="2fa31-313">在某些情况下，对于无效名称，可能会引发此异常。</span><span class="sxs-lookup"><span data-stu-id="2fa31-313">In some cases, this exception may be thrown for invalid names.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2fa31-314"><paramref name="name" /> 是一个空字符串。</span><span class="sxs-lookup"><span data-stu-id="2fa31-314"><paramref name="name" /> is an empty string.</span></span>

<span data-ttu-id="2fa31-315">或</span><span class="sxs-lookup"><span data-stu-id="2fa31-315">-or-</span></span>

<span data-ttu-id="2fa31-316">仅限 .NET Framework：<paramref name="name" /> 的长度超过 MAX_PATH（260 个字符）。</span><span class="sxs-lookup"><span data-stu-id="2fa31-316">.NET Framework only: <paramref name="name" /> is longer than MAX_PATH (260 characters).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2fa31-317"><paramref name="name" /> 上声明的默认值为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="2fa31-317"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2fa31-318"><paramref name="name" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="2fa31-318"><paramref name="name" /> is invalid.</span></span> <span data-ttu-id="2fa31-319">导致这种情况的原因有很多，包括操作系统可能会施加的一些限制，例如未知前缀或无效字符。</span><span class="sxs-lookup"><span data-stu-id="2fa31-319">This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters.</span></span> <span data-ttu-id="2fa31-320">请注意，名称和常见前缀 "Global\" 和 "Local\" 区分大小写。</span><span class="sxs-lookup"><span data-stu-id="2fa31-320">Note that the name and common prefixes "Global\" and "Local\" are case-sensitive.</span></span>

<span data-ttu-id="2fa31-321">或</span><span class="sxs-lookup"><span data-stu-id="2fa31-321">-or-</span></span>

<span data-ttu-id="2fa31-322">存在其他错误。</span><span class="sxs-lookup"><span data-stu-id="2fa31-322">There was some other error.</span></span> <span data-ttu-id="2fa31-323">`HResult` 属性可能提供更多信息。</span><span class="sxs-lookup"><span data-stu-id="2fa31-323">The `HResult` property may provide more information.</span></span></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><span data-ttu-id="2fa31-324">仅限 Windows：<paramref name="name" /> 指定了未知命名空间。</span><span class="sxs-lookup"><span data-stu-id="2fa31-324">Windows only: <paramref name="name" /> specified an unknown namespace.</span></span> <span data-ttu-id="2fa31-325">有关详细信息，请参阅[对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。</span><span class="sxs-lookup"><span data-stu-id="2fa31-325">See [Object Names](https://docs.microsoft.com/windows/win32/sync/object-names) for more information.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="2fa31-326"><paramref name="name" /> 太长。</span><span class="sxs-lookup"><span data-stu-id="2fa31-326">The <paramref name="name" /> is too long.</span></span> <span data-ttu-id="2fa31-327">长度限制可能取决于操作系统或配置。</span><span class="sxs-lookup"><span data-stu-id="2fa31-327">Length restrictions may depend on the operating system or configuration.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="2fa31-328">已命名的事件存在，但用户不具备使用它所需的安全访问权限。</span><span class="sxs-lookup"><span data-stu-id="2fa31-328">The named event exists, but the user does not have the security access required to use it.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="2fa31-329">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="2fa31-329">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As EventWaitHandleRights) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.EventWaitHandleRights -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="2fa31-330">要打开并与其他进程共享的同步对象的名称。</span><span class="sxs-lookup"><span data-stu-id="2fa31-330">The name of the synchronization object to be opened and shared with other processes.</span></span> <span data-ttu-id="2fa31-331">该名称区分大小写。</span><span class="sxs-lookup"><span data-stu-id="2fa31-331">The name is case-sensitive.</span></span></param>
        <param name="rights"><span data-ttu-id="2fa31-332">表示所需的安全访问权限的枚举值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="2fa31-332">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <summary><span data-ttu-id="2fa31-333">用安全访问权限打开指定名称为同步事件（如果已经存在）。</span><span class="sxs-lookup"><span data-stu-id="2fa31-333">Opens the specified named synchronization event, if it already exists, with the desired security access.</span></span></summary>
        <returns><span data-ttu-id="2fa31-334">一个对象，表示已命名的系统事件。</span><span class="sxs-lookup"><span data-stu-id="2fa31-334">An object that represents the named system event.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fa31-335">`name`可以使用 `Global\` 或前缀 `Local\` 来指定命名空间。</span><span class="sxs-lookup"><span data-stu-id="2fa31-335">The `name` may be prefixed with `Global\` or `Local\` to specify a namespace.</span></span> <span data-ttu-id="2fa31-336">如果 `Global` 指定了命名空间，则同步对象可能与系统上的任何进程共享。</span><span class="sxs-lookup"><span data-stu-id="2fa31-336">When the `Global` namespace is specified, the synchronization object may be shared with any processes on the system.</span></span> <span data-ttu-id="2fa31-337">`Local`指定命名空间后，如果未指定命名空间，这也是默认命名空间，则同步对象可能与同一会话中的进程共享。</span><span class="sxs-lookup"><span data-stu-id="2fa31-337">When the `Local` namespace is specified, which is also the default when no namespace is specified, the synchronization object may be shared with processes in the same session.</span></span> <span data-ttu-id="2fa31-338">在 Windows 上，会话是一个登录会话，服务通常在不同的非交互式会话中运行。</span><span class="sxs-lookup"><span data-stu-id="2fa31-338">On Windows, a session is a login session, and services typically run in a different non-interactive session.</span></span> <span data-ttu-id="2fa31-339">在类似 Unix 的操作系统上，每个 shell 都有自己的会话。</span><span class="sxs-lookup"><span data-stu-id="2fa31-339">On Unix-like operating systems, each shell has its own session.</span></span> <span data-ttu-id="2fa31-340">会话本地同步对象可能适用于具有父/子关系的进程之间的同步，它们全都在同一会话中运行。</span><span class="sxs-lookup"><span data-stu-id="2fa31-340">Session-local synchronization objects may be appropriate for synchronizing between processes with a parent/child relationship where they all run in the same session.</span></span> <span data-ttu-id="2fa31-341">有关 Windows 上的 synchornization 对象名称的详细信息，请参阅 [对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。</span><span class="sxs-lookup"><span data-stu-id="2fa31-341">For more information about synchornization object names on Windows, see [Object Names](https://docs.microsoft.com/windows/win32/sync/object-names).</span></span>

 <span data-ttu-id="2fa31-342">如果命名空间中存在请求类型的同步对象，则会打开现有的同步对象。</span><span class="sxs-lookup"><span data-stu-id="2fa31-342">If a synchronization object of the requested type exists in the namespace, the existing synchronization object is opened.</span></span> <span data-ttu-id="2fa31-343">如果命名空间中不存在同步对象，或者命名空间中存在其他类型的同步对象， `WaitHandleCannotBeOpenedException` 则会引发。</span><span class="sxs-lookup"><span data-stu-id="2fa31-343">If a synchronization object does not exist in the namespace, or a synchronization object of a different type exists in the namespace, a `WaitHandleCannotBeOpenedException` is thrown.</span></span>

 <span data-ttu-id="2fa31-344">`rights`参数必须包括 <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> 允许线程等待事件的标志，以及 <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> 允许线程调用 <xref:System.Threading.EventWaitHandle.Set%2A> 和方法的标志 <xref:System.Threading.EventWaitHandle.Reset%2A> 。</span><span class="sxs-lookup"><span data-stu-id="2fa31-344">The `rights` parameter must include the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the event, and the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="2fa31-345">此 <xref:System.Threading.EventWaitHandle.OpenExisting%2A> 方法尝试打开现有的已命名系统事件。</span><span class="sxs-lookup"><span data-stu-id="2fa31-345">The <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method tries to open an existing named system event.</span></span> <span data-ttu-id="2fa31-346">若要在不存在系统事件时创建系统事件，请使用 <xref:System.Threading.EventWaitHandle.%23ctor%2A> 具有参数的构造函数之一 `name` 。</span><span class="sxs-lookup"><span data-stu-id="2fa31-346">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="2fa31-347">对此方法使用相同值的多个调用 `name` 不一定会返回相同的 <xref:System.Threading.EventWaitHandle> 对象，即使返回的对象表示相同的命名系统事件也是如此。</span><span class="sxs-lookup"><span data-stu-id="2fa31-347">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2fa31-348">下面的代码示例演示具有访问控制安全性的已命名系统事件的跨进程行为。</span><span class="sxs-lookup"><span data-stu-id="2fa31-348">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="2fa31-349">该示例使用 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> 方法重载来测试是否存在已命名的事件。</span><span class="sxs-lookup"><span data-stu-id="2fa31-349">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="2fa31-350">如果此事件不存在，则将使用初始所有权和访问控制安全性来创建该事件，拒绝当前用户使用该事件，但会授予读取和更改事件权限的权限。</span><span class="sxs-lookup"><span data-stu-id="2fa31-350">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="2fa31-351">如果从两个命令窗口运行已编译的示例，第二个副本将在调用时引发访问冲突异常 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="2fa31-351">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="2fa31-352">捕获到异常，该示例使用 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> 方法重载来等待事件，该事件具有读取和更改权限所需的权限。</span><span class="sxs-lookup"><span data-stu-id="2fa31-352">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="2fa31-353">更改权限后，将以等待事件的权限打开事件，并向其发出信号。</span><span class="sxs-lookup"><span data-stu-id="2fa31-353">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="2fa31-354">如果从第三个命令窗口运行已编译的示例，该示例将使用新的权限运行。</span><span class="sxs-lookup"><span data-stu-id="2fa31-354">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2fa31-355"><paramref name="name" /> 是一个空字符串。</span><span class="sxs-lookup"><span data-stu-id="2fa31-355"><paramref name="name" /> is an empty string.</span></span>

<span data-ttu-id="2fa31-356">或</span><span class="sxs-lookup"><span data-stu-id="2fa31-356">-or-</span></span>

<span data-ttu-id="2fa31-357">仅限 .NET Framework：<paramref name="name" /> 的长度超过 MAX_PATH（260 个字符）。</span><span class="sxs-lookup"><span data-stu-id="2fa31-357">.NET Framework only: <paramref name="name" /> is longer than MAX_PATH (260 characters).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2fa31-358"><paramref name="name" /> 上声明的默认值为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="2fa31-358"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="2fa31-359">无法打开具有提供的 <paramref name="name" /> 的同步对象。</span><span class="sxs-lookup"><span data-stu-id="2fa31-359">A synchronization object with the provided <paramref name="name" /> cannot be opened.</span></span> <span data-ttu-id="2fa31-360">该对象可能不存在，或者不同类型的同步对象可能具有相同的名称。</span><span class="sxs-lookup"><span data-stu-id="2fa31-360">It may not exist, or a synchronization object of a different type might have the same name.</span></span> <span data-ttu-id="2fa31-361">在某些情况下，对于无效名称，可能会引发此异常。</span><span class="sxs-lookup"><span data-stu-id="2fa31-361">In some cases, this exception may be thrown for invalid names.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2fa31-362"><paramref name="name" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="2fa31-362"><paramref name="name" /> is invalid.</span></span> <span data-ttu-id="2fa31-363">导致这种情况的原因有很多，包括操作系统可能会施加的一些限制，例如未知前缀或无效字符。</span><span class="sxs-lookup"><span data-stu-id="2fa31-363">This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters.</span></span> <span data-ttu-id="2fa31-364">请注意，名称和常见前缀 "Global\" 和 "Local\" 区分大小写。</span><span class="sxs-lookup"><span data-stu-id="2fa31-364">Note that the name and common prefixes "Global\" and "Local\" are case-sensitive.</span></span>

<span data-ttu-id="2fa31-365">或</span><span class="sxs-lookup"><span data-stu-id="2fa31-365">-or-</span></span>

<span data-ttu-id="2fa31-366">存在其他错误。</span><span class="sxs-lookup"><span data-stu-id="2fa31-366">There was some other error.</span></span> <span data-ttu-id="2fa31-367">`HResult` 属性可能提供更多信息。</span><span class="sxs-lookup"><span data-stu-id="2fa31-367">The `HResult` property may provide more information.</span></span></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><span data-ttu-id="2fa31-368">仅限 Windows：<paramref name="name" /> 指定了未知命名空间。</span><span class="sxs-lookup"><span data-stu-id="2fa31-368">Windows only: <paramref name="name" /> specified an unknown namespace.</span></span> <span data-ttu-id="2fa31-369">有关详细信息，请参阅[对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。</span><span class="sxs-lookup"><span data-stu-id="2fa31-369">See [Object Names](https://docs.microsoft.com/windows/win32/sync/object-names) for more information.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="2fa31-370"><paramref name="name" /> 太长。</span><span class="sxs-lookup"><span data-stu-id="2fa31-370">The <paramref name="name" /> is too long.</span></span> <span data-ttu-id="2fa31-371">长度限制可能取决于操作系统或配置。</span><span class="sxs-lookup"><span data-stu-id="2fa31-371">Length restrictions may depend on the operating system or configuration.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="2fa31-372">命名事件存在，但用户不具有所需的安全访问权限。</span><span class="sxs-lookup"><span data-stu-id="2fa31-372">The named event exists, but the user does not have the desired security access.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="2fa31-373">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="2fa31-373">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public bool Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Function Reset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; bool" Usage="eventWaitHandle.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2fa31-374">将事件状态设置为非终止状态，导致线程阻止。</span><span class="sxs-lookup"><span data-stu-id="2fa31-374">Sets the state of the event to nonsignaled, causing threads to block.</span></span></summary>
        <returns><span data-ttu-id="2fa31-375">如果该操作成功，则为 <see langword="true" />；否则，为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2fa31-375"><see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2fa31-376">之前已在此 <see cref="T:System.Threading.EventWaitHandle" /> 上调用 <see cref="M:System.Threading.WaitHandle.Close" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="2fa31-376">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="2fa31-377">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="2fa31-377">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Set" />
      <MemberSignature Language="VB.NET" Value="Public Function Set () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set();" />
      <MemberSignature Language="F#" Value="member this.Set : unit -&gt; bool" Usage="eventWaitHandle.Set " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2fa31-378">将事件状态设置为终止状态，允许一个或多个等待线程继续。</span><span class="sxs-lookup"><span data-stu-id="2fa31-378">Sets the state of the event to signaled, allowing one or more waiting threads to proceed.</span></span></summary>
        <returns><span data-ttu-id="2fa31-379">如果该操作成功，则为 <see langword="true" />；否则，为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2fa31-379"><see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fa31-380">对于 <xref:System.Threading.EventWaitHandle> 包含 <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>) 的 (<xref:System.Threading.AutoResetEvent> ，此 <xref:System.Threading.EventWaitHandle.Set%2A> 方法将释放单个线程。</span><span class="sxs-lookup"><span data-stu-id="2fa31-380">For an <xref:System.Threading.EventWaitHandle> with <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (including <xref:System.Threading.AutoResetEvent>), the <xref:System.Threading.EventWaitHandle.Set%2A> method releases a single thread.</span></span> <span data-ttu-id="2fa31-381">如果没有等待线程，则等待句柄会保持终止状态，直到某个线程尝试等待它，或直到 <xref:System.Threading.EventWaitHandle.Reset%2A> 调用其方法为止。</span><span class="sxs-lookup"><span data-stu-id="2fa31-381">If there are no waiting threads, the wait handle remains signaled until a thread attempts to wait on it, or until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="2fa31-382">不保证每次调用方法时， <xref:System.Threading.EventWaitHandle.Set%2A> 都将从 <xref:System.Threading.EventWaitHandle> 其重置模式为的中释放线程 <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="2fa31-382">There is no guarantee that every call to the <xref:System.Threading.EventWaitHandle.Set%2A> method will release a thread from an <xref:System.Threading.EventWaitHandle> whose reset mode is <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2fa31-383">如果两次调用都过于接近，因此在释放线程之前发生第二次调用，则只释放一个线程。</span><span class="sxs-lookup"><span data-stu-id="2fa31-383">If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released.</span></span> <span data-ttu-id="2fa31-384">就好像未发生第二次调用一样。</span><span class="sxs-lookup"><span data-stu-id="2fa31-384">It is as if the second call did not happen.</span></span> <span data-ttu-id="2fa31-385">此外，如果在没有 <xref:System.Threading.EventWaitHandle.Set%2A> 等待的线程并且已 <xref:System.Threading.EventWaitHandle> 发出信号的情况下调用，则调用不起作用。</span><span class="sxs-lookup"><span data-stu-id="2fa31-385">Also, if <xref:System.Threading.EventWaitHandle.Set%2A> is called when there are no threads waiting and the <xref:System.Threading.EventWaitHandle> is already signaled, the call has no effect.</span></span>  
  
 <span data-ttu-id="2fa31-386">对于 <xref:System.Threading.EventWaitHandle> 包含 <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>) 的 (<xref:System.Threading.ManualResetEvent> ，调用 <xref:System.Threading.EventWaitHandle.Set%2A> 方法会使等待句柄处于终止状态，直到调用其 <xref:System.Threading.EventWaitHandle.Reset%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="2fa31-386">For an <xref:System.Threading.EventWaitHandle> with <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (including <xref:System.Threading.ManualResetEvent>), calling the <xref:System.Threading.EventWaitHandle.Set%2A> method leaves the wait handle in a signaled state until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2fa31-387">下面的代码示例使用 <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> 方法重载，以允许主线程向阻止的线程发出信号，并等待线程完成任务。</span><span class="sxs-lookup"><span data-stu-id="2fa31-387">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="2fa31-388">该示例启动五个线程，并允许它们阻止 <xref:System.Threading.EventWaitHandle> 使用标志创建的 <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> ，然后在每次用户按 ENTER 键时释放一个线程。</span><span class="sxs-lookup"><span data-stu-id="2fa31-388">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="2fa31-389">然后，该示例将另一线程排队，并通过使用标志创建的所有线程释放它们 <xref:System.Threading.EventWaitHandle> <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="2fa31-389">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2fa31-390">之前已在此 <see cref="T:System.Threading.EventWaitHandle" /> 上调用 <see cref="M:System.Threading.WaitHandle.Close" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="2fa31-390">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="2fa31-391">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="2fa31-391">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.EventWaitHandleSecurity -&gt; unit" Usage="eventWaitHandle.SetAccessControl eventSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="eventSecurity"><span data-ttu-id="2fa31-392">一个 <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> 对象，该对象表示应用到命名系统事件的访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="2fa31-392">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security to be applied to the named system event.</span></span></param>
        <summary><span data-ttu-id="2fa31-393">设置已命名的系统事件的访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="2fa31-393">Sets the access control security for a named system event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fa31-394">用户必须具有 <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> 调用此方法的权限，并且必须使用标志打开事件 <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="2fa31-394">The user must have <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> rights to call this method, and the event must have been opened with the <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> flag.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2fa31-395">下面的代码示例演示具有访问控制安全性的已命名系统事件的跨进程行为。</span><span class="sxs-lookup"><span data-stu-id="2fa31-395">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="2fa31-396">该示例使用 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> 方法重载来测试是否存在已命名的事件。</span><span class="sxs-lookup"><span data-stu-id="2fa31-396">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="2fa31-397">如果此事件不存在，则将使用初始所有权和访问控制安全性来创建该事件，拒绝当前用户使用该事件，但会授予读取和更改事件权限的权限。</span><span class="sxs-lookup"><span data-stu-id="2fa31-397">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="2fa31-398">如果从两个命令窗口运行已编译的示例，第二个副本将在调用时引发访问冲突异常 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="2fa31-398">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="2fa31-399">捕获到异常，该示例使用 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> 方法重载来等待事件，该事件具有读取和更改权限所需的权限。</span><span class="sxs-lookup"><span data-stu-id="2fa31-399">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="2fa31-400">更改权限后，使用 <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> 方法，将以等待事件的权限打开事件并向其发出信号。</span><span class="sxs-lookup"><span data-stu-id="2fa31-400">After the permissions are changed, using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="2fa31-401">如果从第三个命令窗口运行已编译的示例，该示例将使用新的权限运行。</span><span class="sxs-lookup"><span data-stu-id="2fa31-401">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2fa31-402"><paramref name="eventSecurity" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="2fa31-402"><paramref name="eventSecurity" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="2fa31-403">用户不具备 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />。</span><span class="sxs-lookup"><span data-stu-id="2fa31-403">The user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span></span>  
  
<span data-ttu-id="2fa31-404">- 或 -</span><span class="sxs-lookup"><span data-stu-id="2fa31-404">-or-</span></span> 
<span data-ttu-id="2fa31-405">事件不是以 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" /> 打开的。</span><span class="sxs-lookup"><span data-stu-id="2fa31-405">The event was not opened with <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span></span></exception>
        <exception cref="T:System.SystemException"><span data-ttu-id="2fa31-406">当前 <see cref="T:System.Threading.EventWaitHandle" /> 对象不表示已命名的系统事件。</span><span class="sxs-lookup"><span data-stu-id="2fa31-406">The current <see cref="T:System.Threading.EventWaitHandle" /> object does not represent a named system event.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2fa31-407">之前已对此 <see cref="M:System.Threading.WaitHandle.Close" /> 调用 <see cref="T:System.Threading.EventWaitHandle" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="2fa31-407">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives"><span data-ttu-id="2fa31-408">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="2fa31-408">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2fa31-409">打开指定名称为同步事件（如果已经存在)，并返回指示操作是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="2fa31-409">Opens a specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * EventWaitHandle -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, result)" />
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle? result);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-5.0">
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("windows")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("windows")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="2fa31-410">要打开并与其他进程共享的同步对象的名称。</span><span class="sxs-lookup"><span data-stu-id="2fa31-410">The name of the synchronization object to be opened and shared with other processes.</span></span> <span data-ttu-id="2fa31-411">该名称区分大小写。</span><span class="sxs-lookup"><span data-stu-id="2fa31-411">The name is case-sensitive.</span></span></param>
        <param name="result"><span data-ttu-id="2fa31-412">当此方法返回时，如果调用成功，则包含表示命名同步事件的 <see cref="T:System.Threading.EventWaitHandle" /> 对象；如果调用失败，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="2fa31-412">When this method returns, contains a <see cref="T:System.Threading.EventWaitHandle" /> object that represents the named synchronization event if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="2fa31-413">该参数未经初始化即被处理。</span><span class="sxs-lookup"><span data-stu-id="2fa31-413">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="2fa31-414">打开指定的命名同步事件（如果已经存在），返回指示操作是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="2fa31-414">Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="2fa31-415">如果成功打开命名同步事件，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2fa31-415"><see langword="true" /> if the named synchronization event was opened successfully; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="2fa31-416">在某些情况下，对于无效名称，可能会返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2fa31-416">In some cases, <see langword="false" /> may be returned for invalid names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fa31-417">`name`可以使用 `Global\` 或前缀 `Local\` 来指定命名空间。</span><span class="sxs-lookup"><span data-stu-id="2fa31-417">The `name` may be prefixed with `Global\` or `Local\` to specify a namespace.</span></span> <span data-ttu-id="2fa31-418">如果 `Global` 指定了命名空间，则同步对象可能与系统上的任何进程共享。</span><span class="sxs-lookup"><span data-stu-id="2fa31-418">When the `Global` namespace is specified, the synchronization object may be shared with any processes on the system.</span></span> <span data-ttu-id="2fa31-419">`Local`指定命名空间后，如果未指定命名空间，这也是默认命名空间，则同步对象可能与同一会话中的进程共享。</span><span class="sxs-lookup"><span data-stu-id="2fa31-419">When the `Local` namespace is specified, which is also the default when no namespace is specified, the synchronization object may be shared with processes in the same session.</span></span> <span data-ttu-id="2fa31-420">在 Windows 上，会话是一个登录会话，服务通常在不同的非交互式会话中运行。</span><span class="sxs-lookup"><span data-stu-id="2fa31-420">On Windows, a session is a login session, and services typically run in a different non-interactive session.</span></span> <span data-ttu-id="2fa31-421">在类似 Unix 的操作系统上，每个 shell 都有自己的会话。</span><span class="sxs-lookup"><span data-stu-id="2fa31-421">On Unix-like operating systems, each shell has its own session.</span></span> <span data-ttu-id="2fa31-422">会话本地同步对象可能适用于具有父/子关系的进程之间的同步，它们全都在同一会话中运行。</span><span class="sxs-lookup"><span data-stu-id="2fa31-422">Session-local synchronization objects may be appropriate for synchronizing between processes with a parent/child relationship where they all run in the same session.</span></span> <span data-ttu-id="2fa31-423">有关 Windows 上的 synchornization 对象名称的详细信息，请参阅 [对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。</span><span class="sxs-lookup"><span data-stu-id="2fa31-423">For more information about synchornization object names on Windows, see [Object Names](https://docs.microsoft.com/windows/win32/sync/object-names).</span></span>

 <span data-ttu-id="2fa31-424">如果命名空间中存在请求类型的同步对象，则会打开现有的同步对象。</span><span class="sxs-lookup"><span data-stu-id="2fa31-424">If a synchronization object of the requested type exists in the namespace, the existing synchronization object is opened.</span></span> <span data-ttu-id="2fa31-425">如果命名空间中不存在同步对象，或者命名空间中存在其他类型的同步对象， `false` 则返回。</span><span class="sxs-lookup"><span data-stu-id="2fa31-425">If a synchronization object does not exist in the namespace, or a synchronization object of a different type exists in the namespace, `false` is returned.</span></span>

 <span data-ttu-id="2fa31-426">若要在不存在系统事件时创建系统事件，请使用 <xref:System.Threading.EventWaitHandle.%23ctor%2A> 具有参数的构造函数之一 `name` 。</span><span class="sxs-lookup"><span data-stu-id="2fa31-426">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="2fa31-427">如果不确定是否存在已命名的同步事件，请使用此方法重载，而不是 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> 方法重载，如果同步事件不存在，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="2fa31-427">If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload, which throws an exception if the synchronization event does not exist.</span></span>  
  
 <span data-ttu-id="2fa31-428">此方法重载等效于调用 <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> 方法重载，并 <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> 使用按位 "或" 运算来指定和权限。</span><span class="sxs-lookup"><span data-stu-id="2fa31-428">This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span> <span data-ttu-id="2fa31-429">指定 <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> 标志将允许线程等待已命名的系统事件，并指定 <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> 标志允许线程调用 <xref:System.Threading.EventWaitHandle.Set%2A> 和 <xref:System.Threading.EventWaitHandle.Reset%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="2fa31-429">Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="2fa31-430">对此方法使用相同值的多个调用 `name` 不一定会返回相同的 <xref:System.Threading.EventWaitHandle> 对象，即使返回的对象表示相同的命名系统事件也是如此。</span><span class="sxs-lookup"><span data-stu-id="2fa31-430">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2fa31-431"><paramref name="name" /> 是一个空字符串。</span><span class="sxs-lookup"><span data-stu-id="2fa31-431"><paramref name="name" /> is an empty string.</span></span>

<span data-ttu-id="2fa31-432">或</span><span class="sxs-lookup"><span data-stu-id="2fa31-432">-or-</span></span>

<span data-ttu-id="2fa31-433">仅限 .NET Framework：<paramref name="name" /> 的长度超过 MAX_PATH（260 个字符）。</span><span class="sxs-lookup"><span data-stu-id="2fa31-433">.NET Framework only: <paramref name="name" /> is longer than MAX_PATH (260 characters).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2fa31-434"><paramref name="name" /> 上声明的默认值为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="2fa31-434"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2fa31-435"><paramref name="name" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="2fa31-435"><paramref name="name" /> is invalid.</span></span> <span data-ttu-id="2fa31-436">导致这种情况的原因有很多，包括操作系统可能会施加的一些限制，例如未知前缀或无效字符。</span><span class="sxs-lookup"><span data-stu-id="2fa31-436">This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters.</span></span> <span data-ttu-id="2fa31-437">请注意，名称和常见前缀 "Global\" 和 "Local\" 区分大小写。</span><span class="sxs-lookup"><span data-stu-id="2fa31-437">Note that the name and common prefixes "Global\" and "Local\" are case-sensitive.</span></span> <span data-ttu-id="2fa31-438">对于某些无效名称，该方法可能返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2fa31-438">For some invalid names, the method may return <see langword="false" /> instead.</span></span>

<span data-ttu-id="2fa31-439">或</span><span class="sxs-lookup"><span data-stu-id="2fa31-439">-or-</span></span>

<span data-ttu-id="2fa31-440">存在其他错误。</span><span class="sxs-lookup"><span data-stu-id="2fa31-440">There was some other error.</span></span> <span data-ttu-id="2fa31-441">`HResult` 属性可能提供更多信息。</span><span class="sxs-lookup"><span data-stu-id="2fa31-441">The `HResult` property may provide more information.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="2fa31-442"><paramref name="name" /> 太长。</span><span class="sxs-lookup"><span data-stu-id="2fa31-442">The <paramref name="name" /> is too long.</span></span> <span data-ttu-id="2fa31-443">长度限制可能取决于操作系统或配置。</span><span class="sxs-lookup"><span data-stu-id="2fa31-443">Length restrictions may depend on the operating system or configuration.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="2fa31-444">命名事件存在，但用户不具有所需的安全访问权限。</span><span class="sxs-lookup"><span data-stu-id="2fa31-444">The named event exists, but the user does not have the desired security access.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As EventWaitHandleRights, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.EventWaitHandleRights * EventWaitHandle -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="2fa31-445">要打开的系统同步事件的名称。</span><span class="sxs-lookup"><span data-stu-id="2fa31-445">The name of the system synchronization event to open.</span></span></param>
        <param name="rights"><span data-ttu-id="2fa31-446">表示所需的安全访问权限的枚举值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="2fa31-446">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <param name="result"><span data-ttu-id="2fa31-447">当此方法返回时，如果调用成功，则包含表示命名同步事件的 <see cref="T:System.Threading.EventWaitHandle" /> 对象；如果调用失败，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="2fa31-447">When this method returns, contains a <see cref="T:System.Threading.EventWaitHandle" /> object that represents the named synchronization event if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="2fa31-448">该参数未经初始化即被处理。</span><span class="sxs-lookup"><span data-stu-id="2fa31-448">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="2fa31-449">使用所需的安全访问权限，打开指定的命名同步事件（如果已经存在），并返回指示操作是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="2fa31-449">Opens the specified named synchronization event, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="2fa31-450">如果成功打开命名同步事件，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2fa31-450"><see langword="true" /> if the named synchronization event was opened successfully; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="2fa31-451">在某些情况下，对于无效名称，可能会返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2fa31-451">In some cases, <see langword="false" /> may be returned for invalid names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fa31-452">`name`可以使用 `Global\` 或前缀 `Local\` 来指定命名空间。</span><span class="sxs-lookup"><span data-stu-id="2fa31-452">The `name` may be prefixed with `Global\` or `Local\` to specify a namespace.</span></span> <span data-ttu-id="2fa31-453">如果 `Global` 指定了命名空间，则同步对象可能与系统上的任何进程共享。</span><span class="sxs-lookup"><span data-stu-id="2fa31-453">When the `Global` namespace is specified, the synchronization object may be shared with any processes on the system.</span></span> <span data-ttu-id="2fa31-454">`Local`指定命名空间后，如果未指定命名空间，这也是默认命名空间，则同步对象可能与同一会话中的进程共享。</span><span class="sxs-lookup"><span data-stu-id="2fa31-454">When the `Local` namespace is specified, which is also the default when no namespace is specified, the synchronization object may be shared with processes in the same session.</span></span> <span data-ttu-id="2fa31-455">在 Windows 上，会话是一个登录会话，服务通常在不同的非交互式会话中运行。</span><span class="sxs-lookup"><span data-stu-id="2fa31-455">On Windows, a session is a login session, and services typically run in a different non-interactive session.</span></span> <span data-ttu-id="2fa31-456">在类似 Unix 的操作系统上，每个 shell 都有自己的会话。</span><span class="sxs-lookup"><span data-stu-id="2fa31-456">On Unix-like operating systems, each shell has its own session.</span></span> <span data-ttu-id="2fa31-457">会话本地同步对象可能适用于具有父/子关系的进程之间的同步，它们全都在同一会话中运行。</span><span class="sxs-lookup"><span data-stu-id="2fa31-457">Session-local synchronization objects may be appropriate for synchronizing between processes with a parent/child relationship where they all run in the same session.</span></span> <span data-ttu-id="2fa31-458">有关 Windows 上的 synchornization 对象名称的详细信息，请参阅 [对象名称](https://docs.microsoft.com/windows/win32/sync/object-names)。</span><span class="sxs-lookup"><span data-stu-id="2fa31-458">For more information about synchornization object names on Windows, see [Object Names](https://docs.microsoft.com/windows/win32/sync/object-names).</span></span>

 <span data-ttu-id="2fa31-459">如果命名空间中存在请求类型的同步对象，则会打开现有的同步对象。</span><span class="sxs-lookup"><span data-stu-id="2fa31-459">If a synchronization object of the requested type exists in the namespace, the existing synchronization object is opened.</span></span> <span data-ttu-id="2fa31-460">如果命名空间中不存在同步对象，或者命名空间中存在其他类型的同步对象， `false` 则返回。</span><span class="sxs-lookup"><span data-stu-id="2fa31-460">If a synchronization object does not exist in the namespace, or a synchronization object of a different type exists in the namespace, `false` is returned.</span></span>

 <span data-ttu-id="2fa31-461">若要在不存在系统事件时创建系统事件，请使用 <xref:System.Threading.EventWaitHandle.%23ctor%2A> 具有参数的构造函数之一 `name` 。</span><span class="sxs-lookup"><span data-stu-id="2fa31-461">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="2fa31-462">如果不确定是否存在已命名的同步事件，请使用此方法重载，而不是 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> 方法重载，如果同步事件不存在，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="2fa31-462">If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload, which throws an exception if the synchronization event does not exist.</span></span>  
  
 <span data-ttu-id="2fa31-463">`rights`参数必须包括 <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> 允许线程等待事件的标志，以及 <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> 允许线程调用 <xref:System.Threading.EventWaitHandle.Set%2A> 和方法的标志 <xref:System.Threading.EventWaitHandle.Reset%2A> 。</span><span class="sxs-lookup"><span data-stu-id="2fa31-463">The `rights` parameter must include the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the event, and the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="2fa31-464">对此方法使用相同值的多个调用 `name` 不一定会返回相同的 <xref:System.Threading.EventWaitHandle> 对象，即使返回的对象表示相同的命名系统事件也是如此。</span><span class="sxs-lookup"><span data-stu-id="2fa31-464">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2fa31-465"><paramref name="name" /> 是一个空字符串。</span><span class="sxs-lookup"><span data-stu-id="2fa31-465"><paramref name="name" /> is an empty string.</span></span>

<span data-ttu-id="2fa31-466">或</span><span class="sxs-lookup"><span data-stu-id="2fa31-466">-or-</span></span>

<span data-ttu-id="2fa31-467">仅限 .NET Framework：<paramref name="name" /> 的长度超过 MAX_PATH（260 个字符）。</span><span class="sxs-lookup"><span data-stu-id="2fa31-467">.NET Framework only: <paramref name="name" /> is longer than MAX_PATH (260 characters).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2fa31-468"><paramref name="name" /> 上声明的默认值为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="2fa31-468"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2fa31-469"><paramref name="name" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="2fa31-469"><paramref name="name" /> is invalid.</span></span> <span data-ttu-id="2fa31-470">导致这种情况的原因有很多，包括操作系统可能会施加的一些限制，例如未知前缀或无效字符。</span><span class="sxs-lookup"><span data-stu-id="2fa31-470">This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters.</span></span> <span data-ttu-id="2fa31-471">请注意，名称和常见前缀 "Global\" 和 "Local\" 区分大小写。</span><span class="sxs-lookup"><span data-stu-id="2fa31-471">Note that the name and common prefixes "Global\" and "Local\" are case-sensitive.</span></span> <span data-ttu-id="2fa31-472">对于某些无效名称，该方法可能返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2fa31-472">For some invalid names, the method may return <see langword="false" /> instead.</span></span>

<span data-ttu-id="2fa31-473">或</span><span class="sxs-lookup"><span data-stu-id="2fa31-473">-or-</span></span>

<span data-ttu-id="2fa31-474">存在其他错误。</span><span class="sxs-lookup"><span data-stu-id="2fa31-474">There was some other error.</span></span> <span data-ttu-id="2fa31-475">`HResult` 属性可能提供更多信息。</span><span class="sxs-lookup"><span data-stu-id="2fa31-475">The `HResult` property may provide more information.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="2fa31-476"><paramref name="name" /> 太长。</span><span class="sxs-lookup"><span data-stu-id="2fa31-476">The <paramref name="name" /> is too long.</span></span> <span data-ttu-id="2fa31-477">长度限制可能取决于操作系统或配置。</span><span class="sxs-lookup"><span data-stu-id="2fa31-477">Length restrictions may depend on the operating system or configuration.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="2fa31-478">命名事件存在，但用户不具有所需的安全访问权限。</span><span class="sxs-lookup"><span data-stu-id="2fa31-478">The named event exists, but the user does not have the desired security access.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
