<Type Name="Semaphore" FullName="System.Threading.Semaphore">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5fcce3bd1e1e588bb4dccbd7d548cc278a0a20b4" /><Meta Name="ms.sourcegitcommit" Value="80274aaa1f2e220209486886b5cd74a54203d795" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/03/2020" /><Meta Name="ms.locfileid" Value="89418239" /></Metadata><TypeSignature Language="C#" Value="public sealed class Semaphore : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Semaphore extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Semaphore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Semaphore&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Semaphore sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Semaphore = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System" FromVersion="4.0.0.0" To="System.Threading" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Threading" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="bc736-101">限制可同时访问某一资源或资源池的线程数。</span><span class="sxs-lookup"><span data-stu-id="bc736-101">Limits the number of threads that can access a resource or pool of resources concurrently.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc736-102">使用 <xref:System.Threading.Semaphore> 类控制对资源池的访问。</span><span class="sxs-lookup"><span data-stu-id="bc736-102">Use the <xref:System.Threading.Semaphore> class to control access to a pool of resources.</span></span> <span data-ttu-id="bc736-103">线程通过调用从类继承的方法进入信号量， <xref:System.Threading.WaitHandle.WaitOne%2A> <xref:System.Threading.WaitHandle> 并通过调用方法释放信号量 <xref:System.Threading.Semaphore.Release%2A> 。</span><span class="sxs-lookup"><span data-stu-id="bc736-103">Threads enter the semaphore by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method, which is inherited from the <xref:System.Threading.WaitHandle> class, and release the semaphore by calling the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="bc736-104">每次线程进入信号量时，信号量的计数都将减少，并在线程释放信号量时递增。</span><span class="sxs-lookup"><span data-stu-id="bc736-104">The count on a semaphore is decremented each time a thread enters the semaphore, and incremented when a thread releases the semaphore.</span></span> <span data-ttu-id="bc736-105">如果计数为零，则后续请求会阻塞，直到其他线程释放信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-105">When the count is zero, subsequent requests block until other threads release the semaphore.</span></span> <span data-ttu-id="bc736-106">当所有线程都已释放信号量后，计数将达到创建信号量时指定的最大值。</span><span class="sxs-lookup"><span data-stu-id="bc736-106">When all threads have released the semaphore, the count is at the maximum value specified when the semaphore was created.</span></span>  
  
 <span data-ttu-id="bc736-107">没有保证的顺序，如 FIFO 或 LIFO，其中阻塞的线程进入信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-107">There is no guaranteed order, such as FIFO or LIFO, in which blocked threads enter the semaphore.</span></span>  
  
 <span data-ttu-id="bc736-108">通过重复调用方法，线程可以多次进入信号量 <xref:System.Threading.WaitHandle.WaitOne%2A> 。</span><span class="sxs-lookup"><span data-stu-id="bc736-108">A thread can enter the semaphore multiple times, by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method repeatedly.</span></span> <span data-ttu-id="bc736-109">若要释放部分或全部这些项，线程可以多次调用无参数 <xref:System.Threading.Semaphore.Release> 方法重载，或者可以调用 <xref:System.Threading.Semaphore.Release%28System.Int32%29> 方法重载来指定要释放的项数。</span><span class="sxs-lookup"><span data-stu-id="bc736-109">To release some or all of these entries, the thread can call the parameterless <xref:System.Threading.Semaphore.Release> method overload multiple times, or it can call the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload that specifies the number of entries to be released.</span></span>  
  
 <span data-ttu-id="bc736-110"><xref:System.Threading.Semaphore>在对或的调用中，类不强制执行线程标识 <xref:System.Threading.WaitHandle.WaitOne%2A> <xref:System.Threading.Semaphore.Release%2A> 。</span><span class="sxs-lookup"><span data-stu-id="bc736-110">The <xref:System.Threading.Semaphore> class does not enforce thread identity on calls to <xref:System.Threading.WaitHandle.WaitOne%2A> or <xref:System.Threading.Semaphore.Release%2A>.</span></span> <span data-ttu-id="bc736-111">编程人员应负责确保线程不会过多地释放信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-111">It is the programmer's responsibility to ensure that threads do not release the semaphore too many times.</span></span> <span data-ttu-id="bc736-112">例如，假定信号量的最大计数为 2 并且线程 A 和线程 B 都进入了该信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-112">For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore.</span></span> <span data-ttu-id="bc736-113">如果线程 B 中的编程错误导致其调用了 <xref:System.Threading.Semaphore.Release%2A> 两次，则两次调用都将成功。</span><span class="sxs-lookup"><span data-stu-id="bc736-113">If a programming error in thread B causes it to call <xref:System.Threading.Semaphore.Release%2A> twice, both calls succeed.</span></span> <span data-ttu-id="bc736-114">信号灯计数已满，当线程 A 最终调用 <xref:System.Threading.Semaphore.Release%2A> 时，<xref:System.Threading.SemaphoreFullException> 抛出。</span><span class="sxs-lookup"><span data-stu-id="bc736-114">The count on the semaphore is full, and when thread A eventually calls <xref:System.Threading.Semaphore.Release%2A>, a <xref:System.Threading.SemaphoreFullException> is thrown.</span></span>  
  
 <span data-ttu-id="bc736-115">信号量分为两种类型：本地信号量和命名系统信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-115">Semaphores are of two types: local semaphores and named system semaphores.</span></span> <span data-ttu-id="bc736-116">如果 <xref:System.Threading.Semaphore> 使用接受名称的构造函数创建对象，则该对象将与该名称的操作系统信号量关联。</span><span class="sxs-lookup"><span data-stu-id="bc736-116">If you create a <xref:System.Threading.Semaphore> object using a constructor that accepts a name, it is associated with an operating-system semaphore of that name.</span></span> <span data-ttu-id="bc736-117">命名系统信号量在整个操作系统中均可见，可用于同步进程的活动。</span><span class="sxs-lookup"><span data-stu-id="bc736-117">Named system semaphores are visible throughout the operating system, and can be used to synchronize the activities of processes.</span></span> <span data-ttu-id="bc736-118">可以创建多个 <xref:System.Threading.Semaphore> 表示同一命名系统信号量的对象，并且可以使用 <xref:System.Threading.Semaphore.OpenExisting%2A> 方法打开现有的已命名系统信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-118">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore, and you can use the <xref:System.Threading.Semaphore.OpenExisting%2A> method to open an existing named system semaphore.</span></span>  
  
 <span data-ttu-id="bc736-119">局部信号量仅存在于进程内。</span><span class="sxs-lookup"><span data-stu-id="bc736-119">A local semaphore exists only within your process.</span></span> <span data-ttu-id="bc736-120">进程中引用本地 <xref:System.Threading.Semaphore> 对象的所有线程都可以使用本地 mutex。</span><span class="sxs-lookup"><span data-stu-id="bc736-120">It can be used by any thread in your process that has a reference to the local <xref:System.Threading.Semaphore> object.</span></span> <span data-ttu-id="bc736-121">每个 <xref:System.Threading.Semaphore> 对象都是一个单独的本地信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-121">Each <xref:System.Threading.Semaphore> object is a separate local semaphore.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc736-122">下面的代码示例创建一个信号量，其最大计数为3，初始计数为零。</span><span class="sxs-lookup"><span data-stu-id="bc736-122">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="bc736-123">该示例启动五个线程，这会阻止等待信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-123">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="bc736-124">主线程使用 <xref:System.Threading.Semaphore.Release%28System.Int32%29> 方法重载将信号量计数增加到其最大值，从而允许三个线程进入信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-124">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="bc736-125">每个线程使用 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 方法等待一秒，以模拟工作，然后调用 <xref:System.Threading.Semaphore.Release> 方法重载以释放信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-125">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span> <span data-ttu-id="bc736-126">每次释放信号灯时，都将显示以前的信号量计数。</span><span class="sxs-lookup"><span data-stu-id="bc736-126">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="bc736-127">控制台消息跟踪信号量使用。</span><span class="sxs-lookup"><span data-stu-id="bc736-127">Console messages track semaphore use.</span></span> <span data-ttu-id="bc736-128">每个线程的模拟工作时间间隔略有增加，使输出更易于读取。</span><span class="sxs-lookup"><span data-stu-id="bc736-128">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="bc736-129">此类型是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="bc736-129">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="bc736-130">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="bc736-130">Managed Threading</span></span></related>
    <related type="Article" href="/dotnet/standard/threading/semaphore-and-semaphoreslim"><span data-ttu-id="bc736-131">Semaphore</span><span class="sxs-lookup"><span data-stu-id="bc736-131">Semaphore</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bc736-132">初始化 <see cref="T:System.Threading.Semaphore" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="bc736-132">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount"><span data-ttu-id="bc736-133">可以同时授予的信号量的初始请求数。</span><span class="sxs-lookup"><span data-stu-id="bc736-133">The initial number of requests for the semaphore that can be granted concurrently.</span></span></param>
        <param name="maximumCount"><span data-ttu-id="bc736-134">可以同时授予的信号量的最大请求数。</span><span class="sxs-lookup"><span data-stu-id="bc736-134">The maximum number of requests for the semaphore that can be granted concurrently.</span></span></param>
        <summary><span data-ttu-id="bc736-135">初始化 <see cref="T:System.Threading.Semaphore" /> 类的新实例，并指定初始入口数和最大并发入口数。</span><span class="sxs-lookup"><span data-stu-id="bc736-135">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc736-136">此构造函数初始化未命名的信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-136">This constructor initializes an unnamed semaphore.</span></span> <span data-ttu-id="bc736-137">使用此类信号量的实例的所有线程都必须具有对该实例的引用。</span><span class="sxs-lookup"><span data-stu-id="bc736-137">All threads that use an instance of such a semaphore must have references to the instance.</span></span>  
  
 <span data-ttu-id="bc736-138">如果 `initialCount` 小于，则 `maximumCount` 效果与当前线程已调用 <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` 减去 `initialCount`) 时间相同。</span><span class="sxs-lookup"><span data-stu-id="bc736-138">If `initialCount` is less than `maximumCount`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span> <span data-ttu-id="bc736-139">如果你不希望为创建信号量的线程保留任何条目，请对和使用相同的数字 `maximumCount` `initialCount` 。</span><span class="sxs-lookup"><span data-stu-id="bc736-139">If you do not want to reserve any entries for the thread that creates the semaphore, use the same number for `maximumCount` and `initialCount`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc736-140">下面的示例创建一个信号量，其最大计数为3，初始计数为零。</span><span class="sxs-lookup"><span data-stu-id="bc736-140">The following example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="bc736-141">该示例启动五个线程，这会阻止等待信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-141">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="bc736-142">主线程使用 <xref:System.Threading.Semaphore.Release%28System.Int32%29> 方法重载将信号量计数增加到其最大值，从而允许三个线程进入信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-142">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="bc736-143">每个线程使用 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 方法等待一秒，以模拟工作，然后调用 <xref:System.Threading.Semaphore.Release> 方法重载以释放信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-143">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span> <span data-ttu-id="bc736-144">每次释放信号灯时，都将显示以前的信号量计数。</span><span class="sxs-lookup"><span data-stu-id="bc736-144">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="bc736-145">控制台消息跟踪信号量使用。</span><span class="sxs-lookup"><span data-stu-id="bc736-145">Console messages track semaphore use.</span></span> <span data-ttu-id="bc736-146">每个线程的模拟工作时间间隔略有增加，使输出更易于读取。</span><span class="sxs-lookup"><span data-stu-id="bc736-146">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="bc736-147"><paramref name="initialCount" /> 大于 <paramref name="maximumCount" />。</span><span class="sxs-lookup"><span data-stu-id="bc736-147"><paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="bc736-148"><paramref name="maximumCount" /> 小于 1。</span><span class="sxs-lookup"><span data-stu-id="bc736-148"><paramref name="maximumCount" /> is less than 1.</span></span>  
  
<span data-ttu-id="bc736-149">- 或 -</span><span class="sxs-lookup"><span data-stu-id="bc736-149">-or-</span></span> 
 <span data-ttu-id="bc736-150"><paramref name="initialCount" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="bc736-150"><paramref name="initialCount" /> is less than 0.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="bc736-151">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="bc736-151">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/semaphore-and-semaphoreslim"><span data-ttu-id="bc736-152">Semaphore</span><span class="sxs-lookup"><span data-stu-id="bc736-152">Semaphore</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialCount"><span data-ttu-id="bc736-153">可以同时授予的信号量的初始请求数。</span><span class="sxs-lookup"><span data-stu-id="bc736-153">The initial number of requests for the semaphore that can be granted concurrently.</span></span></param>
        <param name="maximumCount"><span data-ttu-id="bc736-154">可以同时授予的信号量的最大请求数。</span><span class="sxs-lookup"><span data-stu-id="bc736-154">The maximum number of requests for the semaphore that can be granted concurrently.</span></span></param>
        <param name="name"><span data-ttu-id="bc736-155">信号灯的名称。</span><span class="sxs-lookup"><span data-stu-id="bc736-155">The name of the semaphore.</span></span> <span data-ttu-id="bc736-156">如果是 <see langword="null" /> 或为空，则创建一个进程本地的信号灯。</span><span class="sxs-lookup"><span data-stu-id="bc736-156">If it is <see langword="null" /> or empty, a process-local semaphore is created.</span></span> <span data-ttu-id="bc736-157">如果名称以“Global\"为前缀，则会创建一个计算机范围的信号灯（或返回的现有信号灯）。</span><span class="sxs-lookup"><span data-stu-id="bc736-157">If the name is prefixed by "Global\", a machine-wide semaphore is created (or the existing one returned).</span></span> <span data-ttu-id="bc736-158">如果以“Local\"为前缀，则会创建一个会话范围的信号灯（或返回的现有信号灯）。</span><span class="sxs-lookup"><span data-stu-id="bc736-158">If it is prefixed by "Local\", a session-wide semaphore is created (or the existing one returned).</span></span> <span data-ttu-id="bc736-159">如果名称不带任何前缀，则会创建一个会话范围的信号灯（与带前缀“Local\"时相同）。</span><span class="sxs-lookup"><span data-stu-id="bc736-159">If the name is not prefixed at all, a session-wide semaphore is created (same as prefix "Local\").</span></span> <span data-ttu-id="bc736-160">前缀和名称都区分大小写。</span><span class="sxs-lookup"><span data-stu-id="bc736-160">Both prefix and name are case-sensitive.</span></span></param>
        <summary><span data-ttu-id="bc736-161">初始化 <see cref="T:System.Threading.Semaphore" /> 类的新实例，并指定初始入口数和最大并发入口数，可以选择指定系统信号量对象的名称。</span><span class="sxs-lookup"><span data-stu-id="bc736-161">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc736-162">此构造函数初始化 <xref:System.Threading.Semaphore> 对象，该对象表示已命名的系统信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-162">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="bc736-163">可以创建多个 <xref:System.Threading.Semaphore> 表示同一命名系统信号量的对象。</span><span class="sxs-lookup"><span data-stu-id="bc736-163">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="bc736-164">如果已命名的系统信号量不存在，则将使用和指定的初始计数和最大计数来创建它 `initialCount` `maximumCount` 。</span><span class="sxs-lookup"><span data-stu-id="bc736-164">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="bc736-165">如果已命名的系统信号量已存在， `initialCount` `maximumCount` 则不使用和，尽管无效值仍然会导致异常。</span><span class="sxs-lookup"><span data-stu-id="bc736-165">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="bc736-166">如果需要确定是否创建了已命名的系统信号量，请改用 <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> 构造函数重载。</span><span class="sxs-lookup"><span data-stu-id="bc736-166">If you need to determine whether or not a named system semaphore was created, use the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> constructor overload instead.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="bc736-167">使用此构造函数重载时，建议的做法是为和指定相同的数字 `initialCount` `maximumCount` 。</span><span class="sxs-lookup"><span data-stu-id="bc736-167">When you use this constructor overload, the recommended practice is to specify the same number for `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="bc736-168">如果 `initialCount` 小于 `maximumCount` ，并且创建了已命名的系统信号量，则效果与当前线程已调用 <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` 减去 `initialCount`) 时间相同。</span><span class="sxs-lookup"><span data-stu-id="bc736-168">If `initialCount` is less than `maximumCount`, and a named system semaphore is created, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span> <span data-ttu-id="bc736-169">但是，使用此构造函数重载无法确定是否创建了已命名的系统信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-169">However, with this constructor overload there is no way to determine whether a named system semaphore was created.</span></span>  
  
 <span data-ttu-id="bc736-170">如果为指定 `null` 或空字符串，则将 `name` 创建本地信号量，就像您已调用 <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> 构造函数重载一样。</span><span class="sxs-lookup"><span data-stu-id="bc736-170">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span>  
  
 <span data-ttu-id="bc736-171">因为命名的信号量在整个操作系统中均可见，所以它们可用于跨进程边界协调资源使用。</span><span class="sxs-lookup"><span data-stu-id="bc736-171">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
 <span data-ttu-id="bc736-172">若要确定是否存在已命名的系统信号量，请使用 <xref:System.Threading.Semaphore.OpenExisting%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="bc736-172">If you want to find out whether a named system semaphore exists, use the <xref:System.Threading.Semaphore.OpenExisting%2A> method.</span></span> <span data-ttu-id="bc736-173">此 <xref:System.Threading.Semaphore.OpenExisting%2A> 方法尝试打开现有的已命名信号量，并在系统信号量不存在时引发异常。</span><span class="sxs-lookup"><span data-stu-id="bc736-173">The <xref:System.Threading.Semaphore.OpenExisting%2A> method attempts to open an existing named semaphore, and throws an exception if the system semaphore does not exist.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc736-174">下面的代码示例演示命名信号量的跨进程行为。</span><span class="sxs-lookup"><span data-stu-id="bc736-174">The following code example demonstrates the cross-process behavior of a named semaphore.</span></span> <span data-ttu-id="bc736-175">该示例创建一个名为的信号量，其最大计数为5，初始计数为5。</span><span class="sxs-lookup"><span data-stu-id="bc736-175">The example creates a named semaphore with a maximum count of five and an initial count of five.</span></span> <span data-ttu-id="bc736-176">该程序对方法进行了三次调用 <xref:System.Threading.WaitHandle.WaitOne%2A> 。</span><span class="sxs-lookup"><span data-stu-id="bc736-176">The program makes three calls to the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="bc736-177">因此，如果从两个命令窗口运行已编译的示例，则第三次调用时会阻止第二个副本 <xref:System.Threading.WaitHandle.WaitOne%2A> 。</span><span class="sxs-lookup"><span data-stu-id="bc736-177">Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="bc736-178">释放程序的第一个副本中的一个或多个项以解除阻止第二个副本。</span><span class="sxs-lookup"><span data-stu-id="bc736-178">Release one or more entries in the first copy of the program to unblock the second.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="bc736-179"><paramref name="initialCount" /> 大于 <paramref name="maximumCount" />。</span><span class="sxs-lookup"><span data-stu-id="bc736-179"><paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span></span>  
  
<span data-ttu-id="bc736-180">- 或 -</span><span class="sxs-lookup"><span data-stu-id="bc736-180">-or-</span></span> 
 <span data-ttu-id="bc736-181"><paramref name="name" /> 超过 260 个字符。</span><span class="sxs-lookup"><span data-stu-id="bc736-181"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="bc736-182"><paramref name="maximumCount" /> 小于 1。</span><span class="sxs-lookup"><span data-stu-id="bc736-182"><paramref name="maximumCount" /> is less than 1.</span></span>  
  
<span data-ttu-id="bc736-183">- 或 -</span><span class="sxs-lookup"><span data-stu-id="bc736-183">-or-</span></span> 
 <span data-ttu-id="bc736-184"><paramref name="initialCount" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="bc736-184"><paramref name="initialCount" /> is less than 0.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="bc736-185">出现 Win32 错误。</span><span class="sxs-lookup"><span data-stu-id="bc736-185">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="bc736-186">命名信号量存在且具有访问控制安全性，用户不具有 <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />。</span><span class="sxs-lookup"><span data-stu-id="bc736-186">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="bc736-187">无法创建命名信号量，可能是由于其他类型的等待句柄具有相同名称。</span><span class="sxs-lookup"><span data-stu-id="bc736-187">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="bc736-188">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="bc736-188">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/semaphore-and-semaphoreslim"><span data-ttu-id="bc736-189">Semaphore</span><span class="sxs-lookup"><span data-stu-id="bc736-189">Semaphore</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string * bool -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialCount"><span data-ttu-id="bc736-190">可以同时满足的信号量的初始请求数。</span><span class="sxs-lookup"><span data-stu-id="bc736-190">The initial number of requests for the semaphore that can be satisfied concurrently.</span></span></param>
        <param name="maximumCount"><span data-ttu-id="bc736-191">可以同时满足的信号量的最大请求数。</span><span class="sxs-lookup"><span data-stu-id="bc736-191">The maximum number of requests for the semaphore that can be satisfied concurrently.</span></span></param>
        <param name="name"><span data-ttu-id="bc736-192">信号灯的名称。</span><span class="sxs-lookup"><span data-stu-id="bc736-192">The name of the semaphore.</span></span> <span data-ttu-id="bc736-193">如果是 <see langword="null" /> 或为空，则创建一个进程本地的信号灯。</span><span class="sxs-lookup"><span data-stu-id="bc736-193">If it is <see langword="null" /> or empty, a process-local semaphore is created.</span></span> <span data-ttu-id="bc736-194">如果名称以“Global\"为前缀，则会创建一个计算机范围的信号灯（或返回的现有信号灯）。</span><span class="sxs-lookup"><span data-stu-id="bc736-194">If the name is prefixed by "Global\", a machine-wide semaphore is created (or the existing one returned).</span></span> <span data-ttu-id="bc736-195">如果以“Local\"为前缀，则会创建一个会话范围的信号灯（或返回的现有信号灯）。</span><span class="sxs-lookup"><span data-stu-id="bc736-195">If it is prefixed by "Local\", a session-wide semaphore is created (or the existing one returned).</span></span> <span data-ttu-id="bc736-196">如果名称不带任何前缀，则会创建一个会话范围的信号灯（与带前缀“Local\"时相同）。</span><span class="sxs-lookup"><span data-stu-id="bc736-196">If the name is not prefixed at all, a session-wide semaphore is created (same as prefix "Local\").</span></span> <span data-ttu-id="bc736-197">前缀和名称都区分大小写。</span><span class="sxs-lookup"><span data-stu-id="bc736-197">Both prefix and name are case-sensitive.</span></span></param>
        <param name="createdNew"><span data-ttu-id="bc736-198">在此方法返回时，如果创建了本地信号量（即，如果 <paramref name="name" /> 为 <see langword="null" /> 或空字符串）或指定的命名系统信号量，则包含 <see langword="true" />；如果指定的命名系统信号量已存在，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="bc736-198">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed.</span></span> <span data-ttu-id="bc736-199">此参数未经初始化即被传递。</span><span class="sxs-lookup"><span data-stu-id="bc736-199">This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="bc736-200">初始化 <see cref="T:System.Threading.Semaphore" /> 类的新实例，并指定初始入口数和最大并发入口数，还可以选择指定系统信号量对象的名称，以及指定一个变量来接收指示是否创建了新系统信号量的值。</span><span class="sxs-lookup"><span data-stu-id="bc736-200">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc736-201">此构造函数初始化 <xref:System.Threading.Semaphore> 对象，该对象表示已命名的系统信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-201">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="bc736-202">可以创建多个 <xref:System.Threading.Semaphore> 表示同一命名系统信号量的对象。</span><span class="sxs-lookup"><span data-stu-id="bc736-202">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="bc736-203">如果已命名的系统信号量不存在，则将使用和指定的初始计数和最大计数来创建它 `initialCount` `maximumCount` 。</span><span class="sxs-lookup"><span data-stu-id="bc736-203">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="bc736-204">如果已命名的系统信号量已存在， `initialCount` `maximumCount` 则不使用和，尽管无效值仍然会导致异常。</span><span class="sxs-lookup"><span data-stu-id="bc736-204">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="bc736-205">使用 `createdNew` 确定是否已创建系统信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-205">Use `createdNew` to determine whether the system semaphore was created.</span></span>  
  
 <span data-ttu-id="bc736-206">如果 `initialCount` 小于且 `maximumCount` `createdNew` 为 `true` ，则其效果与当前线程已调用 <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` 减去 `initialCount`) 时间相同。</span><span class="sxs-lookup"><span data-stu-id="bc736-206">If `initialCount` is less than `maximumCount`, and `createdNew` is `true`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span>  
  
 <span data-ttu-id="bc736-207">如果为指定 `null` 或空字符串，则将 `name` 创建本地信号量，就像您已调用 <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> 构造函数重载一样。</span><span class="sxs-lookup"><span data-stu-id="bc736-207">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span> <span data-ttu-id="bc736-208">在此示例中， `createdNew` 始终为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="bc736-208">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="bc736-209">因为命名的信号量在整个操作系统中均可见，所以它们可用于跨进程边界协调资源使用。</span><span class="sxs-lookup"><span data-stu-id="bc736-209">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc736-210">下面的代码示例演示命名信号量的跨进程行为。</span><span class="sxs-lookup"><span data-stu-id="bc736-210">The following code example demonstrates the cross-process behavior of a named semaphore.</span></span> <span data-ttu-id="bc736-211">该示例创建一个名为的信号量，其最大计数为5，初始计数为2。</span><span class="sxs-lookup"><span data-stu-id="bc736-211">The example creates a named semaphore with a maximum count of five and an initial count of two.</span></span> <span data-ttu-id="bc736-212">也就是说，它为调用构造函数的线程保留了三个条目。</span><span class="sxs-lookup"><span data-stu-id="bc736-212">That is, it reserves three entries for the thread that calls the constructor.</span></span> <span data-ttu-id="bc736-213">如果 `createNew` 为 `false` ，则该程序对方法进行三次调用 <xref:System.Threading.WaitHandle.WaitOne%2A> 。</span><span class="sxs-lookup"><span data-stu-id="bc736-213">If `createNew` is `false`, the program makes three calls to the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="bc736-214">因此，如果从两个命令窗口运行已编译的示例，则第三次调用时会阻止第二个副本 <xref:System.Threading.WaitHandle.WaitOne%2A> 。</span><span class="sxs-lookup"><span data-stu-id="bc736-214">Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="bc736-215">释放程序的第一个副本中的一个或多个项以解除阻止第二个副本。</span><span class="sxs-lookup"><span data-stu-id="bc736-215">Release one or more entries in the first copy of the program to unblock the second.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="bc736-216"><paramref name="initialCount" /> 大于 <paramref name="maximumCount" />。</span><span class="sxs-lookup"><span data-stu-id="bc736-216"><paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span></span>  
  
<span data-ttu-id="bc736-217">- 或 -</span><span class="sxs-lookup"><span data-stu-id="bc736-217">-or-</span></span> 
 <span data-ttu-id="bc736-218"><paramref name="name" /> 超过 260 个字符。</span><span class="sxs-lookup"><span data-stu-id="bc736-218"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="bc736-219"><paramref name="maximumCount" /> 小于 1。</span><span class="sxs-lookup"><span data-stu-id="bc736-219"><paramref name="maximumCount" /> is less than 1.</span></span>  
  
<span data-ttu-id="bc736-220">- 或 -</span><span class="sxs-lookup"><span data-stu-id="bc736-220">-or-</span></span> 
 <span data-ttu-id="bc736-221"><paramref name="initialCount" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="bc736-221"><paramref name="initialCount" /> is less than 0.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="bc736-222">出现 Win32 错误。</span><span class="sxs-lookup"><span data-stu-id="bc736-222">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="bc736-223">命名信号量存在且具有访问控制安全性，用户不具有 <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />。</span><span class="sxs-lookup"><span data-stu-id="bc736-223">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="bc736-224">无法创建命名信号量，可能是由于其他类型的等待句柄具有相同名称。</span><span class="sxs-lookup"><span data-stu-id="bc736-224">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="bc736-225">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="bc736-225">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/semaphore-and-semaphoreslim"><span data-ttu-id="bc736-226">Semaphore</span><span class="sxs-lookup"><span data-stu-id="bc736-226">Semaphore</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean, semaphoreSecurity As SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string * bool * System.Security.AccessControl.SemaphoreSecurity -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew, semaphoreSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="maximumCount" Type="System.Int32" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="initialCount"><span data-ttu-id="bc736-227">可以同时满足的信号量的初始请求数。</span><span class="sxs-lookup"><span data-stu-id="bc736-227">The initial number of requests for the semaphore that can be satisfied concurrently.</span></span></param>
        <param name="maximumCount"><span data-ttu-id="bc736-228">可以同时满足的信号量的最大请求数。</span><span class="sxs-lookup"><span data-stu-id="bc736-228">The maximum number of requests for the semaphore that can be satisfied concurrently.</span></span></param>
        <param name="name"><span data-ttu-id="bc736-229">信号灯的名称。</span><span class="sxs-lookup"><span data-stu-id="bc736-229">The name of the semaphore.</span></span> <span data-ttu-id="bc736-230">如果是 <see langword="null" /> 或为空，则创建一个进程本地的信号灯。</span><span class="sxs-lookup"><span data-stu-id="bc736-230">If it is <see langword="null" /> or empty, a process-local semaphore is created.</span></span> <span data-ttu-id="bc736-231">如果名称以“Global\"为前缀，则会创建一个计算机范围的信号灯（或返回的现有信号灯）。</span><span class="sxs-lookup"><span data-stu-id="bc736-231">If the name is prefixed by "Global\", a machine-wide semaphore is created (or the existing one returned).</span></span> <span data-ttu-id="bc736-232">如果以“Local\"为前缀，则会创建一个会话范围的信号灯（或返回的现有信号灯）。</span><span class="sxs-lookup"><span data-stu-id="bc736-232">If it is prefixed by "Local\", a session-wide semaphore is created (or the existing one returned).</span></span> <span data-ttu-id="bc736-233">如果名称不带任何前缀，则会创建一个会话范围的信号灯（与带前缀“Local\"时相同）。</span><span class="sxs-lookup"><span data-stu-id="bc736-233">If the name is not prefixed at all, a session-wide semaphore is created (same as prefix "Local\").</span></span> <span data-ttu-id="bc736-234">前缀和名称都区分大小写。</span><span class="sxs-lookup"><span data-stu-id="bc736-234">Both prefix and name are case-sensitive.</span></span></param>
        <param name="createdNew"><span data-ttu-id="bc736-235">在此方法返回时，如果创建了本地信号量（即，如果 <paramref name="name" /> 为 <see langword="null" /> 或空字符串）或指定的命名系统信号量，则包含 <see langword="true" />；如果指定的命名系统信号量已存在，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="bc736-235">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed.</span></span> <span data-ttu-id="bc736-236">此参数未经初始化即被传递。</span><span class="sxs-lookup"><span data-stu-id="bc736-236">This parameter is passed uninitialized.</span></span></param>
        <param name="semaphoreSecurity"><span data-ttu-id="bc736-237">一个 <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> 对象，表示应用于已命名的系统信号量的访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="bc736-237">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</span></span></param>
        <summary><span data-ttu-id="bc736-238">初始化 <see cref="T:System.Threading.Semaphore" /> 类的新实例，并指定初始入口数和最大并发入口数，可以选择指定系统信号量对象的名称，指定一个变量来接收指示是否创建了新系统信号量的值，以及指定系统信号量的安全访问控制。</span><span class="sxs-lookup"><span data-stu-id="bc736-238">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, specifying a variable that receives a value indicating whether a new system semaphore was created, and specifying security access control for the system semaphore.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc736-239">使用此构造函数可在创建已命名的系统信号量时对其应用访问控制安全性，从而阻止其他代码控制信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-239">Use this constructor to apply access control security to a named system semaphore when it is created, preventing other code from taking control of the semaphore.</span></span>  
  
 <span data-ttu-id="bc736-240">此构造函数初始化 <xref:System.Threading.Semaphore> 对象，该对象表示已命名的系统信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-240">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="bc736-241">可以创建多个 <xref:System.Threading.Semaphore> 表示同一命名系统信号量的对象。</span><span class="sxs-lookup"><span data-stu-id="bc736-241">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="bc736-242">如果已命名的系统信号量不存在，则将使用指定的访问控制安全性来创建它。</span><span class="sxs-lookup"><span data-stu-id="bc736-242">If the named system semaphore does not exist, it is created with the specified access control security.</span></span> <span data-ttu-id="bc736-243">如果已命名的信号量存在，则将忽略指定的访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="bc736-243">If the named semaphore exists, the specified access control security is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc736-244">调用方对新创建的对象拥有完全控制权， <xref:System.Threading.Semaphore> 即使 `semaphoreSecurity` 拒绝或无法向当前用户授予某些访问权限。</span><span class="sxs-lookup"><span data-stu-id="bc736-244">The caller has full control over the newly created <xref:System.Threading.Semaphore> object even if `semaphoreSecurity` denies or fails to grant some access rights to the current user.</span></span> <span data-ttu-id="bc736-245">但是，如果当前用户尝试 <xref:System.Threading.Semaphore> 使用构造函数或方法获取表示相同命名信号量的另一个对象， <xref:System.Threading.Semaphore.OpenExisting%2A> 则会应用 Windows 访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="bc736-245">However, if the current user attempts to get another <xref:System.Threading.Semaphore> object to represent the same named semaphore, using either a constructor or the <xref:System.Threading.Semaphore.OpenExisting%2A> method, Windows access control security is applied.</span></span>  
  
 <span data-ttu-id="bc736-246">如果已命名的系统信号量不存在，则将使用和指定的初始计数和最大计数来创建它 `initialCount` `maximumCount` 。</span><span class="sxs-lookup"><span data-stu-id="bc736-246">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="bc736-247">如果已命名的系统信号量已存在， `initialCount` `maximumCount` 则不使用和，尽管无效值仍然会导致异常。</span><span class="sxs-lookup"><span data-stu-id="bc736-247">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="bc736-248">使用 `createdNew` 参数确定系统信号量是否是由此构造函数创建的。</span><span class="sxs-lookup"><span data-stu-id="bc736-248">Use the `createdNew` parameter to determine whether the system semaphore was created by this constructor.</span></span>  
  
 <span data-ttu-id="bc736-249">如果 `initialCount` 小于且 `maximumCount` `createdNew` 为 `true` ，则其效果与当前线程已调用 <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` 减去 `initialCount`) 时间相同。</span><span class="sxs-lookup"><span data-stu-id="bc736-249">If `initialCount` is less than `maximumCount`, and `createdNew` is `true`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span>  
  
 <span data-ttu-id="bc736-250">如果为指定 `null` 或空字符串，则将 `name` 创建本地信号量，就像您已调用 <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> 构造函数重载一样。</span><span class="sxs-lookup"><span data-stu-id="bc736-250">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span> <span data-ttu-id="bc736-251">在此示例中， `createdNew` 始终为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="bc736-251">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="bc736-252">因为命名的信号量在整个操作系统中均可见，所以它们可用于跨进程边界协调资源使用。</span><span class="sxs-lookup"><span data-stu-id="bc736-252">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc736-253">下面的代码示例演示具有访问控制安全性的命名信号量的跨进程行为。</span><span class="sxs-lookup"><span data-stu-id="bc736-253">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="bc736-254">该示例使用 <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> 方法重载来测试是否存在已命名的信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-254">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span> <span data-ttu-id="bc736-255">如果该信号量不存在，则将创建该信号量的最大计数为2且具有访问控制安全性，这会拒绝当前用户使用该信号量，但会授予读取和更改信号量权限的权限。</span><span class="sxs-lookup"><span data-stu-id="bc736-255">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</span></span> <span data-ttu-id="bc736-256">如果从两个命令窗口运行已编译的示例，第二个副本将在调用方法时引发访问冲突异常 <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="bc736-256">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="bc736-257">捕获到异常，该示例使用 <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> 方法重载打开具有读取和更改权限所需权限的信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-257">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="bc736-258">更改权限后，会打开信号量，其中包含进入和释放所需的权限。</span><span class="sxs-lookup"><span data-stu-id="bc736-258">After the permissions are changed, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="bc736-259">如果从第三个命令窗口运行已编译的示例，该示例将使用新的权限运行。</span><span class="sxs-lookup"><span data-stu-id="bc736-259">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="bc736-260"><paramref name="initialCount" /> 大于 <paramref name="maximumCount" />。</span><span class="sxs-lookup"><span data-stu-id="bc736-260"><paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span></span>  
  
<span data-ttu-id="bc736-261">- 或 -</span><span class="sxs-lookup"><span data-stu-id="bc736-261">-or-</span></span> 
 <span data-ttu-id="bc736-262"><paramref name="name" /> 超过 260 个字符。</span><span class="sxs-lookup"><span data-stu-id="bc736-262"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="bc736-263"><paramref name="maximumCount" /> 小于 1。</span><span class="sxs-lookup"><span data-stu-id="bc736-263"><paramref name="maximumCount" /> is less than 1.</span></span>  
  
<span data-ttu-id="bc736-264">- 或 -</span><span class="sxs-lookup"><span data-stu-id="bc736-264">-or-</span></span> 
 <span data-ttu-id="bc736-265"><paramref name="initialCount" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="bc736-265"><paramref name="initialCount" /> is less than 0.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="bc736-266">命名信号量存在且具有访问控制安全性，用户不具有 <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />。</span><span class="sxs-lookup"><span data-stu-id="bc736-266">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="bc736-267">出现 Win32 错误。</span><span class="sxs-lookup"><span data-stu-id="bc736-267">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="bc736-268">无法创建命名信号量，可能是由于其他类型的等待句柄具有相同名称。</span><span class="sxs-lookup"><span data-stu-id="bc736-268">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="bc736-269">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="bc736-269">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/semaphore-and-semaphoreslim"><span data-ttu-id="bc736-270">Semaphore</span><span class="sxs-lookup"><span data-stu-id="bc736-270">Semaphore</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.SemaphoreSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As SemaphoreSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::SemaphoreSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.SemaphoreSecurity" Usage="semaphore.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.SemaphoreSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bc736-271">获取已命名的系统信号量的访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="bc736-271">Gets the access control security for a named system semaphore.</span></span></summary>
        <returns><span data-ttu-id="bc736-272">一个 <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> 对象，表示已命名系统信号量的访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="bc736-272">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security for the named system semaphore.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc736-273"><xref:System.Threading.Semaphore.GetAccessControl%2A>方法使用按位 "或" 运算) 组合 (下面的标志组合来搜索权限： <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType> 、 <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType> 和 <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="bc736-273">The <xref:System.Threading.Semaphore.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, and <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="bc736-274">用户必须具有 <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> 调用此方法的权限，并且必须已使用权限打开该信号量 <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="bc736-274">The user must have <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> rights to call this method, and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> rights.</span></span>  
  
 <span data-ttu-id="bc736-275">在本地信号灯上，访问控制安全性是不相关的。</span><span class="sxs-lookup"><span data-stu-id="bc736-275">On a local semaphore, access control security is irrelevant.</span></span> <span data-ttu-id="bc736-276">如果 <xref:System.Threading.Semaphore> 对象不表示已命名的系统信号量，则此方法将返回一个 <xref:System.Security.AccessControl.SemaphoreSecurity> 对象，该对象向任何用户授予所有权限。</span><span class="sxs-lookup"><span data-stu-id="bc736-276">If the <xref:System.Threading.Semaphore> object does not represent a named system semaphore, this method returns a <xref:System.Security.AccessControl.SemaphoreSecurity> object that grants all rights to any user.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc736-277">下面的代码示例演示具有访问控制安全性的命名信号量的跨进程行为。</span><span class="sxs-lookup"><span data-stu-id="bc736-277">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="bc736-278">该示例使用 <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> 方法重载来测试是否存在已命名的信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-278">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="bc736-279">如果该信号量不存在，则将创建该信号量的最大计数为2且具有访问控制安全性，这会拒绝当前用户使用该信号量，但会授予读取和更改信号量权限的权限。</span><span class="sxs-lookup"><span data-stu-id="bc736-279">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="bc736-280">如果从两个命令窗口运行已编译的示例，第二个副本将在调用方法时引发访问冲突异常 <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="bc736-280">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="bc736-281">捕获到异常，该示例使用 <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> 方法重载打开具有读取和更改权限所需权限的信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-281">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span> <span data-ttu-id="bc736-282">系统信号量的访问控制安全性是使用方法获取的 <xref:System.Threading.Semaphore.GetAccessControl%2A> 。</span><span class="sxs-lookup"><span data-stu-id="bc736-282">The access control security for the system semaphore is obtained using the <xref:System.Threading.Semaphore.GetAccessControl%2A> method.</span></span>  
  
 <span data-ttu-id="bc736-283">更改权限后，会打开信号量，其中包含进入和释放所需的权限。</span><span class="sxs-lookup"><span data-stu-id="bc736-283">After the permissions are changed, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="bc736-284">如果从第三个命令窗口运行已编译的示例，该示例将使用新的权限运行。</span><span class="sxs-lookup"><span data-stu-id="bc736-284">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="bc736-285">当前的 <see cref="T:System.Threading.Semaphore" /> 对象表示已命名的系统信号灯，且用户不具备 <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> 权限。</span><span class="sxs-lookup"><span data-stu-id="bc736-285">The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.</span></span>  
  
<span data-ttu-id="bc736-286">- 或 -</span><span class="sxs-lookup"><span data-stu-id="bc736-286">-or-</span></span> 
<span data-ttu-id="bc736-287">当前的 <see cref="T:System.Threading.Semaphore" /> 对象表示已命名的系统信号灯，且 <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> 权限不开放。</span><span class="sxs-lookup"><span data-stu-id="bc736-287">The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore and was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="bc736-288">不支持 Windows 98 或 Windows Millennium Edition。</span><span class="sxs-lookup"><span data-stu-id="bc736-288">Not supported for Windows 98 or Windows Millennium Edition.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="bc736-289">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="bc736-289">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/semaphore-and-semaphoreslim"><span data-ttu-id="bc736-290">Semaphore</span><span class="sxs-lookup"><span data-stu-id="bc736-290">Semaphore</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bc736-291">打开指定名称为信号量（如果已经存在）。</span><span class="sxs-lookup"><span data-stu-id="bc736-291">Opens a specified named semaphore, if it already exists.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0">
          <AttributeName Language="C#">[System.Runtime.Versioning.MinimumOSPlatform("windows7.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.MinimumOSPlatform("windows7.0")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="bc736-292">信号灯的名称。</span><span class="sxs-lookup"><span data-stu-id="bc736-292">The name of the semaphore.</span></span> <span data-ttu-id="bc736-293">如果名称以“Global\"为前缀，则表示计算机范围的信号灯。</span><span class="sxs-lookup"><span data-stu-id="bc736-293">If it's prefixed by "Global\", it refers to a machine-wide semaphore.</span></span> <span data-ttu-id="bc736-294">如果名称以“Local\"为前缀，或者不包含前缀，则表示会话范围的信号灯。</span><span class="sxs-lookup"><span data-stu-id="bc736-294">If it's prefixed by "Local\" or doesn't have a prefix, it refers to a session-wide semaphore.</span></span> <span data-ttu-id="bc736-295">前缀和名称都区分大小写。</span><span class="sxs-lookup"><span data-stu-id="bc736-295">Both prefix and name are case-sensitive.</span></span></param>
        <summary><span data-ttu-id="bc736-296">打开指定名称为信号量（如果已经存在）。</span><span class="sxs-lookup"><span data-stu-id="bc736-296">Opens the specified named semaphore, if it already exists.</span></span></summary>
        <returns><span data-ttu-id="bc736-297">一个对象，表示已命名的系统信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-297">An object that represents the named system semaphore.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc736-298">此 <xref:System.Threading.Semaphore.OpenExisting%2A> 方法尝试打开指定的命名信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-298">The <xref:System.Threading.Semaphore.OpenExisting%2A> method tries to open the specified named semaphore.</span></span> <span data-ttu-id="bc736-299">如果系统信号量不存在，此方法将引发异常，而不是创建系统信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-299">If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</span></span> <span data-ttu-id="bc736-300">若要在不存在系统信号量时创建它，请使用 <xref:System.Threading.Semaphore.%23ctor%2A> 具有参数的构造函数之一 `name` 。</span><span class="sxs-lookup"><span data-stu-id="bc736-300">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="bc736-301">`name` <xref:System.Threading.Semaphore> 即使返回的对象表示相同的命名系统信号量，对此方法使用与相同的值的多个调用不一定会返回相同的对象。</span><span class="sxs-lookup"><span data-stu-id="bc736-301">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="bc736-302">此方法重载等效于调用 <xref:System.Threading.Semaphore.OpenExisting%2A> 方法重载，并 <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> 使用按位 "或" 运算来指定和权限。</span><span class="sxs-lookup"><span data-stu-id="bc736-302">This method overload is equivalent to calling the <xref:System.Threading.Semaphore.OpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span>  
  
 <span data-ttu-id="bc736-303">指定标志后， <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> 线程可以进入信号量，指定 <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> 标志允许线程调用 <xref:System.Threading.Semaphore.Release%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="bc736-303">Specifying the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag allows a thread to enter the semaphore, and specifying the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc736-304">下面的代码示例演示具有访问控制安全性的命名信号量的跨进程行为。</span><span class="sxs-lookup"><span data-stu-id="bc736-304">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="bc736-305">该示例使用 <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> 方法重载来测试是否存在已命名的信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-305">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="bc736-306">如果该信号量不存在，则将创建该信号量的最大计数为2且具有访问控制安全性，这会拒绝当前用户使用该信号量，但会授予读取和更改信号量权限的权限。</span><span class="sxs-lookup"><span data-stu-id="bc736-306">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but which grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="bc736-307">如果从两个命令窗口运行已编译的示例，第二个副本将在调用方法重载时引发访问冲突异常 <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="bc736-307">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload.</span></span> <span data-ttu-id="bc736-308">捕获到异常，该示例使用 <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> 方法重载打开具有读取和更改权限所需权限的信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-308">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="bc736-309">更改权限后，将以输入和释放信号的权限打开该信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-309">After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="bc736-310">如果从第三个命令窗口运行已编译的示例，该示例将使用新的权限运行。</span><span class="sxs-lookup"><span data-stu-id="bc736-310">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="bc736-311"><paramref name="name" /> 是一个空字符串。</span><span class="sxs-lookup"><span data-stu-id="bc736-311"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="bc736-312">- 或 -</span><span class="sxs-lookup"><span data-stu-id="bc736-312">-or-</span></span> 
 <span data-ttu-id="bc736-313"><paramref name="name" /> 超过 260 个字符。</span><span class="sxs-lookup"><span data-stu-id="bc736-313"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="bc736-314"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="bc736-314"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="bc736-315">命名的信号量不存在。</span><span class="sxs-lookup"><span data-stu-id="bc736-315">The named semaphore does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="bc736-316">出现 Win32 错误。</span><span class="sxs-lookup"><span data-stu-id="bc736-316">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="bc736-317">存在该命名信号量，但用户没有使用它时所需的安全访问权限。</span><span class="sxs-lookup"><span data-stu-id="bc736-317">The named semaphore exists, but the user does not have the security access required to use it.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="bc736-318">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="bc736-318">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/semaphore-and-semaphoreslim"><span data-ttu-id="bc736-319">Semaphore</span><span class="sxs-lookup"><span data-stu-id="bc736-319">Semaphore</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As SemaphoreRights) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.SemaphoreRights -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="bc736-320">信号灯的名称。</span><span class="sxs-lookup"><span data-stu-id="bc736-320">The name of the semaphore.</span></span> <span data-ttu-id="bc736-321">如果名称以“Global\"为前缀，则表示计算机范围的信号灯。</span><span class="sxs-lookup"><span data-stu-id="bc736-321">If it's prefixed by "Global\", it refers to a machine-wide semaphore.</span></span> <span data-ttu-id="bc736-322">如果名称以“Local\"为前缀，或者不包含前缀，则表示会话范围的信号灯。</span><span class="sxs-lookup"><span data-stu-id="bc736-322">If it's prefixed by "Local\" or doesn't have a prefix, it refers to a session-wide semaphore.</span></span> <span data-ttu-id="bc736-323">前缀和名称都区分大小写。</span><span class="sxs-lookup"><span data-stu-id="bc736-323">Both prefix and name are case-sensitive.</span></span></param>
        <param name="rights"><span data-ttu-id="bc736-324">表示所需的安全访问权限的枚举值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="bc736-324">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <summary><span data-ttu-id="bc736-325">用安全访问权限打开指定名称为信号量（如果已经存在）。</span><span class="sxs-lookup"><span data-stu-id="bc736-325">Opens the specified named semaphore, if it already exists, with the desired security access.</span></span></summary>
        <returns><span data-ttu-id="bc736-326">一个对象，表示已命名的系统信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-326">An object that represents the named system semaphore.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc736-327">`rights`参数必须包括 <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> 允许线程进入信号量的标志，以及 <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> 允许线程调用方法的标志 <xref:System.Threading.Semaphore.Release%2A> 。</span><span class="sxs-lookup"><span data-stu-id="bc736-327">The `rights` parameter must include the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag to allow threads to enter the semaphore, and the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="bc736-328">此 <xref:System.Threading.Semaphore.OpenExisting%2A> 方法尝试打开现有的已命名信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-328">The <xref:System.Threading.Semaphore.OpenExisting%2A> method tries to open an existing named semaphore.</span></span> <span data-ttu-id="bc736-329">如果系统信号量不存在，此方法将引发异常，而不是创建系统信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-329">If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</span></span> <span data-ttu-id="bc736-330">若要在不存在系统信号量时创建它，请使用 <xref:System.Threading.Semaphore.%23ctor%2A> 具有参数的构造函数之一 `name` 。</span><span class="sxs-lookup"><span data-stu-id="bc736-330">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="bc736-331">`name` <xref:System.Threading.Semaphore> 即使返回的对象表示相同的命名系统信号量，对此方法使用与相同的值的多个调用不一定会返回相同的对象。</span><span class="sxs-lookup"><span data-stu-id="bc736-331">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc736-332">下面的代码示例演示具有访问控制安全性的命名信号量的跨进程行为。</span><span class="sxs-lookup"><span data-stu-id="bc736-332">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="bc736-333">该示例使用 <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> 方法重载来测试是否存在已命名的信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-333">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="bc736-334">如果该信号量不存在，则将创建该信号量的最大计数为2且具有访问控制安全性，这会拒绝当前用户使用该信号量，但会授予读取和更改信号量权限的权限。</span><span class="sxs-lookup"><span data-stu-id="bc736-334">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="bc736-335">如果从两个命令窗口运行已编译的示例，第二个副本将在调用方法时引发访问冲突异常 <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="bc736-335">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="bc736-336">捕获到异常，该示例使用 <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> 方法重载打开具有读取和更改权限所需权限的信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-336">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="bc736-337">更改权限后，将以输入和释放信号的权限打开该信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-337">After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="bc736-338">如果从第三个命令窗口运行已编译的示例，该示例将使用新的权限运行。</span><span class="sxs-lookup"><span data-stu-id="bc736-338">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="bc736-339"><paramref name="name" /> 是一个空字符串。</span><span class="sxs-lookup"><span data-stu-id="bc736-339"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="bc736-340">- 或 -</span><span class="sxs-lookup"><span data-stu-id="bc736-340">-or-</span></span> 
 <span data-ttu-id="bc736-341"><paramref name="name" /> 超过 260 个字符。</span><span class="sxs-lookup"><span data-stu-id="bc736-341"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="bc736-342"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="bc736-342"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="bc736-343">命名的信号量不存在。</span><span class="sxs-lookup"><span data-stu-id="bc736-343">The named semaphore does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="bc736-344">出现 Win32 错误。</span><span class="sxs-lookup"><span data-stu-id="bc736-344">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="bc736-345">已命名的信号量存在，但用户不具备所需的安全访问权限。</span><span class="sxs-lookup"><span data-stu-id="bc736-345">The named semaphore exists, but the user does not have the desired security access rights.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="bc736-346">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="bc736-346">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/semaphore-and-semaphoreslim"><span data-ttu-id="bc736-347">Semaphore</span><span class="sxs-lookup"><span data-stu-id="bc736-347">Semaphore</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bc736-348">退出信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-348">Exits the semaphore.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberSignature Language="F#" Value="member this.Release : unit -&gt; int" Usage="semaphore.Release " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.PrePrepareMethod]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.PrePrepareMethod&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bc736-349">退出信号量并返回前一个计数。</span><span class="sxs-lookup"><span data-stu-id="bc736-349">Exits the semaphore and returns the previous count.</span></span></summary>
        <returns><span data-ttu-id="bc736-350">调用 <see cref="Overload:System.Threading.Semaphore.Release" /> 方法前信号量的计数。</span><span class="sxs-lookup"><span data-stu-id="bc736-350">The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc736-351">线程通常使用 <xref:System.Threading.WaitHandle.WaitOne%2A> 方法进入信号量，并且通常使用此方法重载来退出。</span><span class="sxs-lookup"><span data-stu-id="bc736-351">Threads typically use the <xref:System.Threading.WaitHandle.WaitOne%2A> method to enter the semaphore, and they typically use this method overload to exit.</span></span>  
  
 <span data-ttu-id="bc736-352">如果 <xref:System.Threading.SemaphoreFullException> <xref:System.Threading.Semaphore.Release%2A> 方法引发，则不一定表示调用线程出现问题。</span><span class="sxs-lookup"><span data-stu-id="bc736-352">If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread.</span></span> <span data-ttu-id="bc736-353">其他线程中的编程错误可能导致该线程退出信号量的次数超过了输入的时间。</span><span class="sxs-lookup"><span data-stu-id="bc736-353">A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</span></span>  
  
 <span data-ttu-id="bc736-354">如果当前的 <xref:System.Threading.Semaphore> 对象表示已命名的系统信号量，则用户必须具有 <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> 权限，并且必须已使用权限打开该信号量 <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="bc736-354">If the current <xref:System.Threading.Semaphore> object represents a named system semaphore, the user must have <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc736-355">下面的代码示例创建一个信号量，其最大计数为3，初始计数为零。</span><span class="sxs-lookup"><span data-stu-id="bc736-355">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="bc736-356">该示例启动五个线程，这会阻止等待信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-356">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="bc736-357">主线程使用 <xref:System.Threading.Semaphore.Release%28System.Int32%29> 方法重载将信号量计数增加到其最大值，从而允许三个线程进入信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-357">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="bc736-358">每个线程使用 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 方法等待一秒，以模拟工作，然后调用 <xref:System.Threading.Semaphore.Release> 方法重载以释放信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-358">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span>  
  
 <span data-ttu-id="bc736-359">每次释放信号灯时，都将显示以前的信号量计数。</span><span class="sxs-lookup"><span data-stu-id="bc736-359">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="bc736-360">控制台消息跟踪信号量使用。</span><span class="sxs-lookup"><span data-stu-id="bc736-360">Console messages track semaphore use.</span></span> <span data-ttu-id="bc736-361">每个线程的模拟工作时间间隔略有增加，使输出更易于读取。</span><span class="sxs-lookup"><span data-stu-id="bc736-361">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SemaphoreFullException"><span data-ttu-id="bc736-362">信号量计数已是最大值。</span><span class="sxs-lookup"><span data-stu-id="bc736-362">The semaphore count is already at the maximum value.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="bc736-363">发生已命名信号量的 Win32 错误。</span><span class="sxs-lookup"><span data-stu-id="bc736-363">A Win32 error occurred with a named semaphore.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="bc736-364">当前信号量表示一个已命名的系统信号量，但用户不具备 <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />。</span><span class="sxs-lookup"><span data-stu-id="bc736-364">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span></span>  
  
<span data-ttu-id="bc736-365">- 或 -</span><span class="sxs-lookup"><span data-stu-id="bc736-365">-or-</span></span> 
<span data-ttu-id="bc736-366">当前信号量表示一个已命名的系统信号量，但它未用 <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> 打开。</span><span class="sxs-lookup"><span data-stu-id="bc736-366">The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="bc736-367">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="bc736-367">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/semaphore-and-semaphoreslim"><span data-ttu-id="bc736-368">Semaphore</span><span class="sxs-lookup"><span data-stu-id="bc736-368">Semaphore</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberSignature Language="F#" Value="member this.Release : int -&gt; int" Usage="semaphore.Release releaseCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount"><span data-ttu-id="bc736-369">退出信号量的次数。</span><span class="sxs-lookup"><span data-stu-id="bc736-369">The number of times to exit the semaphore.</span></span></param>
        <summary><span data-ttu-id="bc736-370">以指定的次数退出信号量并返回前一个计数。</span><span class="sxs-lookup"><span data-stu-id="bc736-370">Exits the semaphore a specified number of times and returns the previous count.</span></span></summary>
        <returns><span data-ttu-id="bc736-371">调用 <see cref="Overload:System.Threading.Semaphore.Release" /> 方法前信号量的计数。</span><span class="sxs-lookup"><span data-stu-id="bc736-371">The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc736-372">如果某个线程多次进入了信号量，此方法重载允许使用一次调用来还原整个信号量计数。</span><span class="sxs-lookup"><span data-stu-id="bc736-372">If a thread has entered the semaphore multiple times, this method overload allows the entire semaphore count to be restored with one call.</span></span>  
  
 <span data-ttu-id="bc736-373">如果 <xref:System.Threading.SemaphoreFullException> <xref:System.Threading.Semaphore.Release%2A> 方法引发，则不一定表示调用线程出现问题。</span><span class="sxs-lookup"><span data-stu-id="bc736-373">If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread.</span></span> <span data-ttu-id="bc736-374">其他线程中的编程错误可能导致该线程退出信号量的次数超过了输入的时间。</span><span class="sxs-lookup"><span data-stu-id="bc736-374">A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</span></span>  
  
 <span data-ttu-id="bc736-375">如果当前的 <xref:System.Threading.Semaphore> 对象表示已命名的系统信号量，则用户必须具有 <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> 权限，并且必须已使用权限打开该信号量 <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="bc736-375">If the current <xref:System.Threading.Semaphore> object represents a named system semaphore, the user must have <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc736-376">下面的代码示例创建一个信号量，其最大计数为3，初始计数为零。</span><span class="sxs-lookup"><span data-stu-id="bc736-376">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="bc736-377">该示例启动五个线程，这会阻止等待信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-377">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="bc736-378">主线程使用 <xref:System.Threading.Semaphore.Release%28System.Int32%29> 方法重载将信号量计数增加到其最大值，从而允许三个线程进入信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-378">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="bc736-379">每个线程使用 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 方法等待一秒，以模拟工作，然后调用 <xref:System.Threading.Semaphore.Release> 方法重载以释放信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-379">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span>  
  
 <span data-ttu-id="bc736-380">每次释放信号灯时，都将显示以前的信号量计数。</span><span class="sxs-lookup"><span data-stu-id="bc736-380">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="bc736-381">控制台消息跟踪信号量使用。</span><span class="sxs-lookup"><span data-stu-id="bc736-381">Console messages track semaphore use.</span></span> <span data-ttu-id="bc736-382">每个线程的模拟工作时间间隔略有增加，使输出更易于读取。</span><span class="sxs-lookup"><span data-stu-id="bc736-382">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="bc736-383"><paramref name="releaseCount" /> 小于 1。</span><span class="sxs-lookup"><span data-stu-id="bc736-383"><paramref name="releaseCount" /> is less than 1.</span></span></exception>
        <exception cref="T:System.Threading.SemaphoreFullException"><span data-ttu-id="bc736-384">信号量计数已是最大值。</span><span class="sxs-lookup"><span data-stu-id="bc736-384">The semaphore count is already at the maximum value.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="bc736-385">发生已命名信号量的 Win32 错误。</span><span class="sxs-lookup"><span data-stu-id="bc736-385">A Win32 error occurred with a named semaphore.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="bc736-386">当前信号量表示一个已命名的系统信号量，但用户不具备 <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> 权限。</span><span class="sxs-lookup"><span data-stu-id="bc736-386">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.</span></span>  
  
<span data-ttu-id="bc736-387">- 或 -</span><span class="sxs-lookup"><span data-stu-id="bc736-387">-or-</span></span> 
<span data-ttu-id="bc736-388">当前信号量表示一个已命名的系统信号量，但它不是以 <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> 权限打开的。</span><span class="sxs-lookup"><span data-stu-id="bc736-388">The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="bc736-389">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="bc736-389">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/semaphore-and-semaphoreslim"><span data-ttu-id="bc736-390">Semaphore</span><span class="sxs-lookup"><span data-stu-id="bc736-390">Semaphore</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (semaphoreSecurity As SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.SemaphoreSecurity -&gt; unit" Usage="semaphore.SetAccessControl semaphoreSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="semaphoreSecurity"><span data-ttu-id="bc736-391">一个 <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> 对象，表示应用于已命名的系统信号量的访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="bc736-391">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</span></span></param>
        <summary><span data-ttu-id="bc736-392">设置已命名的系统信号量的访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="bc736-392">Sets the access control security for a named system semaphore.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc736-393">只能在 <xref:System.Threading.Semaphore> 代表命名系统信号量的对象上设置访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="bc736-393">You can set access control security only on <xref:System.Threading.Semaphore> objects that represent named system semaphores.</span></span>  
  
 <span data-ttu-id="bc736-394">用户必须具有 <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> 调用此方法的权限，并且必须已使用权限打开该信号量 <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="bc736-394">The user must have <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> rights to call this method, and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc736-395">下面的代码示例演示具有访问控制安全性的命名信号量的跨进程行为。</span><span class="sxs-lookup"><span data-stu-id="bc736-395">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="bc736-396">该示例使用 <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> 方法重载来测试是否存在已命名的信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-396">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="bc736-397">如果该信号量不存在，则将创建该信号量的最大计数为2且具有访问控制安全性，这会拒绝当前用户使用该信号量，但会授予读取和更改信号量权限的权限。</span><span class="sxs-lookup"><span data-stu-id="bc736-397">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="bc736-398">如果从两个命令窗口运行已编译的示例，第二个副本将在调用方法时引发访问冲突异常 <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="bc736-398">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="bc736-399">捕获到异常，该示例使用 <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> 方法重载打开具有读取和更改权限所需权限的信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-399">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="bc736-400">更改权限后，使用 <xref:System.Threading.Semaphore.SetAccessControl%2A> 方法，将以输入和释放所需的权限打开信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-400">After the permissions are changed, using the <xref:System.Threading.Semaphore.SetAccessControl%2A> method, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="bc736-401">如果从第三个命令窗口运行已编译的示例，该示例将使用新的权限运行。</span><span class="sxs-lookup"><span data-stu-id="bc736-401">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="bc736-402"><paramref name="semaphoreSecurity" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="bc736-402"><paramref name="semaphoreSecurity" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="bc736-403">用户不具备 <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> 权限。</span><span class="sxs-lookup"><span data-stu-id="bc736-403">The user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.</span></span>  
  
<span data-ttu-id="bc736-404">- 或 -</span><span class="sxs-lookup"><span data-stu-id="bc736-404">-or-</span></span> 
<span data-ttu-id="bc736-405">信号量不是以 <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> 权限打开的。</span><span class="sxs-lookup"><span data-stu-id="bc736-405">The semaphore was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="bc736-406">当前 <see cref="T:System.Threading.Semaphore" /> 对象不表示已命名的系统信号量。</span><span class="sxs-lookup"><span data-stu-id="bc736-406">The current <see cref="T:System.Threading.Semaphore" /> object does not represent a named system semaphore.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="bc736-407">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="bc736-407">Managed Threading</span></span></related>
        <related type="Article" href="/dotnet/standard/threading/semaphore-and-semaphoreslim"><span data-ttu-id="bc736-408">Semaphore</span><span class="sxs-lookup"><span data-stu-id="bc736-408">Semaphore</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bc736-409">打开指定名称为信号量（如果已经存在)，并返回指示操作是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="bc736-409">Opens a specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * Semaphore -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, result)" />
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Semaphore? result);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0">
          <AttributeName Language="C#">[System.Runtime.Versioning.MinimumOSPlatform("windows7.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.MinimumOSPlatform("windows7.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="bc736-410">信号灯的名称。</span><span class="sxs-lookup"><span data-stu-id="bc736-410">The name of the semaphore.</span></span> <span data-ttu-id="bc736-411">如果名称以“Global\"为前缀，则表示计算机范围的信号灯。</span><span class="sxs-lookup"><span data-stu-id="bc736-411">If it's prefixed by "Global\", it refers to a machine-wide semaphore.</span></span> <span data-ttu-id="bc736-412">如果名称以“Local\"为前缀，或者不包含前缀，则表示会话范围的信号灯。</span><span class="sxs-lookup"><span data-stu-id="bc736-412">If it's prefixed by "Local\" or doesn't have a prefix, it refers to a session-wide semaphore.</span></span> <span data-ttu-id="bc736-413">前缀和名称都区分大小写。</span><span class="sxs-lookup"><span data-stu-id="bc736-413">Both prefix and name are case-sensitive.</span></span></param>
        <param name="result"><span data-ttu-id="bc736-414">当此方法返回时，如果调用成功，则包含表示命名信号的 <see cref="T:System.Threading.Semaphore" /> 对象；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="bc736-414">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="bc736-415">该参数未经初始化即被处理。</span><span class="sxs-lookup"><span data-stu-id="bc736-415">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="bc736-416">打开指定名称为信号量（如果已经存在），并返回指示操作是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="bc736-416">Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="bc736-417">如果命名信号量成功打开，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="bc736-417"><see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc736-418">如果命名信号量不存在，则此方法不会创建它。</span><span class="sxs-lookup"><span data-stu-id="bc736-418">If the named semaphore does not exist, this method does not create it.</span></span> <span data-ttu-id="bc736-419">若要在不存在系统信号量时创建它，请使用 <xref:System.Threading.Semaphore.%23ctor%2A> 具有参数的构造函数之一 `name` 。</span><span class="sxs-lookup"><span data-stu-id="bc736-419">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="bc736-420">如果不确定是否存在已命名的信号量，请使用此方法重载，而不是 <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> 方法重载，这会在信号量不存在时引发异常。</span><span class="sxs-lookup"><span data-stu-id="bc736-420">If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload, which throws an exception if the semaphore does not exist.</span></span>  
  
 <span data-ttu-id="bc736-421">此方法重载等效于调用 <xref:System.Threading.Semaphore.TryOpenExisting%2A> 方法重载，并 <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> 使用按位 "或" 运算来指定和权限。</span><span class="sxs-lookup"><span data-stu-id="bc736-421">This method overload is equivalent to calling the <xref:System.Threading.Semaphore.TryOpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span> <span data-ttu-id="bc736-422">指定标志后， <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> 线程可以进入信号量，指定   <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> 标志允许线程调用 <xref:System.Threading.Semaphore.Release%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="bc736-422">Specifying the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag allows a thread to enter the semaphore, and specifying the   <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="bc736-423"><paramref name="name" /> 是一个空字符串。</span><span class="sxs-lookup"><span data-stu-id="bc736-423"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="bc736-424">- 或 -</span><span class="sxs-lookup"><span data-stu-id="bc736-424">-or-</span></span> 
 <span data-ttu-id="bc736-425"><paramref name="name" /> 超过 260 个字符。</span><span class="sxs-lookup"><span data-stu-id="bc736-425"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="bc736-426"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="bc736-426"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="bc736-427">出现 Win32 错误。</span><span class="sxs-lookup"><span data-stu-id="bc736-427">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="bc736-428">存在该命名信号量，但用户没有使用它时所需的安全访问权限。</span><span class="sxs-lookup"><span data-stu-id="bc736-428">The named semaphore exists, but the user does not have the security access required to use it.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As SemaphoreRights, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.SemaphoreRights * Semaphore -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="bc736-429">信号灯的名称。</span><span class="sxs-lookup"><span data-stu-id="bc736-429">The name of the semaphore.</span></span> <span data-ttu-id="bc736-430">如果名称以“Global\"为前缀，则表示计算机范围的信号灯。</span><span class="sxs-lookup"><span data-stu-id="bc736-430">If it's prefixed by "Global\", it refers to a machine-wide semaphore.</span></span> <span data-ttu-id="bc736-431">如果名称以“Local\"为前缀，或者不包含前缀，则表示会话范围的信号灯。</span><span class="sxs-lookup"><span data-stu-id="bc736-431">If it's prefixed by "Local\" or doesn't have a prefix, it refers to a session-wide semaphore.</span></span> <span data-ttu-id="bc736-432">前缀和名称都区分大小写。</span><span class="sxs-lookup"><span data-stu-id="bc736-432">Both prefix and name are case-sensitive.</span></span></param>
        <param name="rights"><span data-ttu-id="bc736-433">表示所需的安全访问权限的枚举值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="bc736-433">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <param name="result"><span data-ttu-id="bc736-434">当此方法返回时，如果调用成功，则包含表示命名信号的 <see cref="T:System.Threading.Semaphore" /> 对象；否则为 <see langword="null" /> 。</span><span class="sxs-lookup"><span data-stu-id="bc736-434">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="bc736-435">该参数未经初始化即被处理。</span><span class="sxs-lookup"><span data-stu-id="bc736-435">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="bc736-436">用安全访问权限打开指定名称为信号量（如果已经存在），并返回指示操作是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="bc736-436">Opens the specified named semaphore, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="bc736-437">如果命名信号量成功打开，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="bc736-437"><see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc736-438">如果命名信号量不存在，则此方法不会创建它。</span><span class="sxs-lookup"><span data-stu-id="bc736-438">If the named semaphore does not exist, this method does not create it.</span></span> <span data-ttu-id="bc736-439">若要在不存在系统信号量时创建它，请使用 <xref:System.Threading.Semaphore.%23ctor%2A> 具有参数的构造函数之一 `name` 。</span><span class="sxs-lookup"><span data-stu-id="bc736-439">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="bc736-440">如果不确定是否存在已命名的信号量，请使用此方法重载，而不是 <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> 方法重载，这会在信号量不存在时引发异常。</span><span class="sxs-lookup"><span data-stu-id="bc736-440">If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload, which throws an exception if the semaphore does not exist.</span></span>  
  
 <span data-ttu-id="bc736-441">`rights`参数必须包括 <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> 允许线程进入信号量的标志，以及 <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> 允许线程调用方法的标志 <xref:System.Threading.Semaphore.Release%2A> 。</span><span class="sxs-lookup"><span data-stu-id="bc736-441">The `rights` parameter must include the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag to allow threads to enter the semaphore, and the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="bc736-442">`name` <xref:System.Threading.Semaphore> 即使返回的对象表示相同的命名系统信号量，对此方法使用与相同的值的多个调用不一定会返回相同的对象。</span><span class="sxs-lookup"><span data-stu-id="bc736-442">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="bc736-443"><paramref name="name" /> 是一个空字符串。</span><span class="sxs-lookup"><span data-stu-id="bc736-443"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="bc736-444">- 或 -</span><span class="sxs-lookup"><span data-stu-id="bc736-444">-or-</span></span> 
 <span data-ttu-id="bc736-445"><paramref name="name" /> 超过 260 个字符。</span><span class="sxs-lookup"><span data-stu-id="bc736-445"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="bc736-446"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="bc736-446"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="bc736-447">出现 Win32 错误。</span><span class="sxs-lookup"><span data-stu-id="bc736-447">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="bc736-448">存在该命名信号量，但用户没有使用它时所需的安全访问权限。</span><span class="sxs-lookup"><span data-stu-id="bc736-448">The named semaphore exists, but the user does not have the security access required to use it.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
