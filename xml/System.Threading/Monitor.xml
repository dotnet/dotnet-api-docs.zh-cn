<Type Name="Monitor" FullName="System.Threading.Monitor">
  <Metadata><Meta Name="ms.openlocfilehash" Value="dd73f7657ef26257f306b156e123ea8707ef03ca" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83945619" /></Metadata><TypeSignature Language="C#" Value="public static class Monitor" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Monitor extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Monitor" />
  <TypeSignature Language="VB.NET" Value="Public Class Monitor" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor abstract sealed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Monitor = class" />
  <TypeSignature Language="C#" Value="public sealed class Monitor" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Monitor extends System.Object" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Monitor" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor sealed" FrameworkAlternate="netframework-1.1" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Threading" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Threading" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="50b11-101">提供同步访问对象的机制。</span><span class="sxs-lookup"><span data-stu-id="50b11-101">Provides a mechanism that synchronizes access to objects.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50b11-102">通过使用 <xref:System.Threading.Monitor> 类，可以通过调用 <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>、<xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>和 <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> 方法，来同步对某个代码区域的访问。</span><span class="sxs-lookup"><span data-stu-id="50b11-102">The <xref:System.Threading.Monitor> class allows you to synchronize access to a region of code by taking and releasing a lock on a particular object by calling the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="50b11-103">对象锁提供了限制访问代码块的功能，通常称为临界区。</span><span class="sxs-lookup"><span data-stu-id="50b11-103">Object locks provide the ability to restrict access to a block of code, commonly called a critical section.</span></span> <span data-ttu-id="50b11-104">当线程拥有对象的锁时，任何其他线程都无法获取该锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-104">While a thread owns the lock for an object, no other thread can acquire that lock.</span></span> <span data-ttu-id="50b11-105">你还可以使用 <xref:System.Threading.Monitor> 类来确保不允许其他线程访问由锁所有者执行的应用程序代码的一部分，除非其他线程使用其他锁定对象执行代码。</span><span class="sxs-lookup"><span data-stu-id="50b11-105">You can also use the <xref:System.Threading.Monitor> class to ensure that no other thread is allowed to access a section of application code being executed by the lock owner, unless the other thread is executing the code using a different locked object.</span></span>  
  
 <span data-ttu-id="50b11-106">本文内容：</span><span class="sxs-lookup"><span data-stu-id="50b11-106">In this article:</span></span>  
  
 <span data-ttu-id="50b11-107">[Monitor 类：概述](#Overview) </span><span class="sxs-lookup"><span data-stu-id="50b11-107">[The Monitor class: An overview](#Overview) </span></span>  
 <span data-ttu-id="50b11-108">[Lock 对象](#Lock) </span><span class="sxs-lookup"><span data-stu-id="50b11-108">[The lock object](#Lock) </span></span>  
 <span data-ttu-id="50b11-109">[临界区](#CriticalSection) </span><span class="sxs-lookup"><span data-stu-id="50b11-109">[The critical section](#CriticalSection) </span></span>  
 <span data-ttu-id="50b11-110">[脉冲、system.threading.monitor.pulseall 和 Wait](#Pulse) </span><span class="sxs-lookup"><span data-stu-id="50b11-110">[Pulse, PulseAll, and Wait](#Pulse) </span></span>  
 [<span data-ttu-id="50b11-111">监视器和等待句柄</span><span class="sxs-lookup"><span data-stu-id="50b11-111">Monitors and wait handles</span></span>](#WaitHandles)  
  
<a name="Overview"></a>   
## <a name="the-monitor-class-an-overview"></a><span data-ttu-id="50b11-112">Monitor 类：概述</span><span class="sxs-lookup"><span data-stu-id="50b11-112">The Monitor class: An overview</span></span>  
 <span data-ttu-id="50b11-113"><xref:System.Threading.Monitor> 具有以下功能：</span><span class="sxs-lookup"><span data-stu-id="50b11-113"><xref:System.Threading.Monitor> has the following features:</span></span>  
  
-   <span data-ttu-id="50b11-114">它与按需的对象相关联。</span><span class="sxs-lookup"><span data-stu-id="50b11-114">It is associated with an object on demand.</span></span>  
  
-   <span data-ttu-id="50b11-115">它是未绑定的，这意味着可以从任何上下文直接调用它。</span><span class="sxs-lookup"><span data-stu-id="50b11-115">It is unbound, which means it can be called directly from any context.</span></span>  
  
-   <span data-ttu-id="50b11-116">无法创建 <xref:System.Threading.Monitor> 类的实例;<xref:System.Threading.Monitor> 类的方法都是静态的。</span><span class="sxs-lookup"><span data-stu-id="50b11-116">An instance of the <xref:System.Threading.Monitor> class cannot be created; the methods of the <xref:System.Threading.Monitor> class are all static.</span></span> <span data-ttu-id="50b11-117">每个方法都被传递控制对临界区的访问的同步对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-117">Each method is passed the synchronized object that controls access to the critical section.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="50b11-118">使用 <xref:System.Threading.Monitor> 类锁定除字符串以外的对象（即除 <xref:System.String>以外的引用类型），而不是值类型。</span><span class="sxs-lookup"><span data-stu-id="50b11-118">Use the <xref:System.Threading.Monitor> class to lock objects other than strings (that is, reference types other than <xref:System.String>), not value types.</span></span> <span data-ttu-id="50b11-119">有关详细信息，请参阅本文后面的 <xref:System.Threading.Monitor.Enter%2A> 方法的重载和[lock 对象](#Lock)部分。</span><span class="sxs-lookup"><span data-stu-id="50b11-119">For details, see the overloads of the <xref:System.Threading.Monitor.Enter%2A> method and [The lock object](#Lock) section later in this article.</span></span>  
  
 <span data-ttu-id="50b11-120">下表描述了访问同步对象的线程可以执行的操作：</span><span class="sxs-lookup"><span data-stu-id="50b11-120">The following table describes the actions that can be taken by threads that access synchronized objects:</span></span>  
  
|<span data-ttu-id="50b11-121">操作</span><span class="sxs-lookup"><span data-stu-id="50b11-121">Action</span></span>|<span data-ttu-id="50b11-122">说明</span><span class="sxs-lookup"><span data-stu-id="50b11-122">Description</span></span>|  
|------------|-----------------|  
|<span data-ttu-id="50b11-123"><xref:System.Threading.Monitor.Enter%2A>、<xref:System.Threading.Monitor.TryEnter%2A></span><span class="sxs-lookup"><span data-stu-id="50b11-123"><xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A></span></span>|<span data-ttu-id="50b11-124">获取对象的锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-124">Acquires a lock for an object.</span></span> <span data-ttu-id="50b11-125">此操作还标记关键节的开头。</span><span class="sxs-lookup"><span data-stu-id="50b11-125">This action also marks the beginning of a critical section.</span></span> <span data-ttu-id="50b11-126">其他任何线程都不能输入临界区，除非它使用不同的锁定对象执行临界区中的说明。</span><span class="sxs-lookup"><span data-stu-id="50b11-126">No other thread can enter the critical section unless it is executing the instructions in the critical section using a different locked object.</span></span>|  
|<xref:System.Threading.Monitor.Wait%2A>|<span data-ttu-id="50b11-127">释放对象的锁，以允许其他线程锁定并访问对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-127">Releases the lock on an object in order to permit other threads to lock and access the object.</span></span> <span data-ttu-id="50b11-128">调用线程会等待另一个线程访问对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-128">The calling thread waits while another thread accesses the object.</span></span> <span data-ttu-id="50b11-129">使用脉冲信号通知等待线程关于对象状态的更改。</span><span class="sxs-lookup"><span data-stu-id="50b11-129">Pulse signals are used to notify waiting threads about changes to an object's state.</span></span>|  
|<span data-ttu-id="50b11-130"><xref:System.Threading.Monitor.Pulse%2A> （信号），<xref:System.Threading.Monitor.PulseAll%2A></span><span class="sxs-lookup"><span data-stu-id="50b11-130"><xref:System.Threading.Monitor.Pulse%2A> (signal), <xref:System.Threading.Monitor.PulseAll%2A></span></span>|<span data-ttu-id="50b11-131">将信号发送到一个或多个等待线程。</span><span class="sxs-lookup"><span data-stu-id="50b11-131">Sends a signal to one or more waiting threads.</span></span> <span data-ttu-id="50b11-132">信号通知等待线程：锁定对象的状态已更改，锁的所有者已准备好释放该锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-132">The signal notifies a waiting thread that the state of the locked object has changed, and the owner of the lock is ready to release the lock.</span></span> <span data-ttu-id="50b11-133">正在等待的线程置于对象的就绪队列中，因此它可能最终接收对象的锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-133">The waiting thread is placed in the object's ready queue so that it might eventually receive the lock for the object.</span></span> <span data-ttu-id="50b11-134">线程锁定后，它可以检查对象的新状态，以查看是否已达到所需的状态。</span><span class="sxs-lookup"><span data-stu-id="50b11-134">Once the thread has the lock, it can check the new state of the object to see if the required state has been reached.</span></span>|  
|<xref:System.Threading.Monitor.Exit%2A>|<span data-ttu-id="50b11-135">释放对象的锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-135">Releases the lock on an object.</span></span> <span data-ttu-id="50b11-136">此操作还标记受锁定对象保护的临界区的结尾。</span><span class="sxs-lookup"><span data-stu-id="50b11-136">This action also marks the end of a critical section protected by the locked object.</span></span>|  
  
 <span data-ttu-id="50b11-137">从 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]开始，有两组重载用于 <xref:System.Threading.Monitor.Enter%2A> 和 <xref:System.Threading.Monitor.TryEnter%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="50b11-137">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], there are two sets of overloads for the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.TryEnter%2A> methods.</span></span> <span data-ttu-id="50b11-138">一组重载具有 `ref` （在中C#）或 `ByRef` （Visual Basic） <xref:System.Boolean> 参数，该参数在获取锁时以原子方式设置为 `true` 即使获取锁时引发了异常。</span><span class="sxs-lookup"><span data-stu-id="50b11-138">One set of overloads has a `ref` (in C#) or `ByRef` (in Visual Basic) <xref:System.Boolean> parameter that is atomically set to `true` if the lock is acquired, even if an exception is thrown when acquiring the lock.</span></span> <span data-ttu-id="50b11-139">如果在所有情况下都必须释放锁定，则使用这些重载，即使锁定所保护的资源可能不是一致的状态。</span><span class="sxs-lookup"><span data-stu-id="50b11-139">Use these overloads if it is critical to release the lock in all cases, even when the resources the lock is protecting might not be in a consistent state.</span></span>  
  
<a name="Lock"></a>   
## <a name="the-lock-object"></a><span data-ttu-id="50b11-140">Lock 对象</span><span class="sxs-lookup"><span data-stu-id="50b11-140">The lock object</span></span>  
 <span data-ttu-id="50b11-141">Monitor 类由 `static` （在中C#）或 `Shared` （在 Visual Basic）方法中，这些方法对控制对临界区的访问的对象进行操作。</span><span class="sxs-lookup"><span data-stu-id="50b11-141">The Monitor class consists of `static` (in C#) or  `Shared` (in Visual Basic) methods that operate on an object that controls access to the critical section.</span></span>  <span data-ttu-id="50b11-142">为每个同步的对象维护以下信息：</span><span class="sxs-lookup"><span data-stu-id="50b11-142">The following information is maintained for each synchronized object:</span></span>  
  
-   <span data-ttu-id="50b11-143">对当前持有锁的线程的引用。</span><span class="sxs-lookup"><span data-stu-id="50b11-143">A reference to the thread that currently holds the lock.</span></span>  
  
-   <span data-ttu-id="50b11-144">对就绪队列的引用，其中包含已准备好获取锁的线程。</span><span class="sxs-lookup"><span data-stu-id="50b11-144">A reference to a ready queue, which contains the threads that are ready to obtain the lock.</span></span>  
  
-   <span data-ttu-id="50b11-145">对等待队列的引用，其中包含等待锁定对象状态的更改通知的线程。</span><span class="sxs-lookup"><span data-stu-id="50b11-145">A reference to a waiting queue, which contains the threads that are waiting for notification of a change in the state of the locked object.</span></span>  
  
 <span data-ttu-id="50b11-146"><xref:System.Threading.Monitor> 锁定对象（即引用类型），而不是值类型。</span><span class="sxs-lookup"><span data-stu-id="50b11-146"><xref:System.Threading.Monitor> locks objects (that is, reference types), not value types.</span></span> <span data-ttu-id="50b11-147">虽然可以将值类型传递到 <xref:System.Threading.Monitor.Enter%2A> 和 <xref:System.Threading.Monitor.Exit%2A>，但对每个调用它都分别进行了装箱。</span><span class="sxs-lookup"><span data-stu-id="50b11-147">While you can pass a value type to <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A>, it is boxed separately for each call.</span></span> <span data-ttu-id="50b11-148">由于每次调用都将创建一个单独的对象，所以绝不会阻止 <xref:System.Threading.Monitor.Enter%2A> 并且它应该保护的代码不会真正同步。</span><span class="sxs-lookup"><span data-stu-id="50b11-148">Since each call creates a separate object, <xref:System.Threading.Monitor.Enter%2A> never blocks, and the code it is supposedly protecting is not really synchronized.</span></span> <span data-ttu-id="50b11-149">此外，传递到 <xref:System.Threading.Monitor.Exit%2A> 的对象不同于传递到 <xref:System.Threading.Monitor.Enter%2A> 的对象，因此 <xref:System.Threading.Monitor> 将引发 <xref:System.Threading.SynchronizationLockException> 异常并显示消息“从代码的非同步块调用了对象同步方法。”</span><span class="sxs-lookup"><span data-stu-id="50b11-149">In addition, the object passed to <xref:System.Threading.Monitor.Exit%2A> is different from the object passed to <xref:System.Threading.Monitor.Enter%2A>, so <xref:System.Threading.Monitor> throws <xref:System.Threading.SynchronizationLockException> exception with the message "Object synchronization method was called from an unsynchronized block of code."</span></span>  
  
 <span data-ttu-id="50b11-150">以下示例阐释了此问题。</span><span class="sxs-lookup"><span data-stu-id="50b11-150">The following example illustrates this problem.</span></span> <span data-ttu-id="50b11-151">它启动十个任务，其中每个任务仅休眠 250 毫秒。</span><span class="sxs-lookup"><span data-stu-id="50b11-151">It launches ten tasks, each of which just sleeps for 250 milliseconds.</span></span> <span data-ttu-id="50b11-152">然后，每个任务会更新计数器变量 `nTasks`，该变量用于计算实际启动和执行的任务数。</span><span class="sxs-lookup"><span data-stu-id="50b11-152">Each task then updates a counter variable, `nTasks`, which is intended to count the number of tasks that actually launched and executed.</span></span> <span data-ttu-id="50b11-153">因为 `nTasks` 是一个可同时被多个任务更新的全局变量，所以使用监视器防止其同时被多个任务进行修改。</span><span class="sxs-lookup"><span data-stu-id="50b11-153">Because `nTasks` is a global variable that can be updated by multiple tasks simultaneously, a monitor is used to protect it from simultaneous modification by multiple tasks.</span></span> <span data-ttu-id="50b11-154">但是，如示例输出所示，每个任务都将引发 <xref:System.Threading.SynchronizationLockException> 异常。</span><span class="sxs-lookup"><span data-stu-id="50b11-154">However, as the output from the example shows, each of the tasks throws a <xref:System.Threading.SynchronizationLockException> exception.</span></span>  
  
 [!code-csharp[Conceptual.Monitors#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)]
 [!code-vb[Conceptual.Monitors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)]  
  
 <span data-ttu-id="50b11-155">因为 `nTasks` 变量会先于对每个任务中的 <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> 方法的调用而进行装箱，所以每个任务都将引发 <xref:System.Threading.SynchronizationLockException> 异常。</span><span class="sxs-lookup"><span data-stu-id="50b11-155">Each task throws a <xref:System.Threading.SynchronizationLockException> exception because the `nTasks` variable is boxed before the call to the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method in each task.</span></span> <span data-ttu-id="50b11-156">换言之，将向每个方法调用传递一个独立于其他变量的单独变量。</span><span class="sxs-lookup"><span data-stu-id="50b11-156">In other words, each method call is passed a separate variable that is independent of the others.</span></span> <span data-ttu-id="50b11-157">`nTasks` 在对 <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> 方法的调用中会再次进行装箱。</span><span class="sxs-lookup"><span data-stu-id="50b11-157">`nTasks` is boxed again in the call to the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="50b11-158">这将再次创建 10 个新装箱的变量 `nTasks`，这些变量相互独立并且独立于在调用 <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> 方法时创建的 10 个装箱变量。</span><span class="sxs-lookup"><span data-stu-id="50b11-158">Once again, this creates ten new boxed variables, which are independent of each other, `nTasks`, and the ten boxed variables created in the call to the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="50b11-159">然后将引发异常，因为我们的代码正尝试在之前未锁定的新创建变量上释放锁定。</span><span class="sxs-lookup"><span data-stu-id="50b11-159">The exception is thrown, then, because our code is attempting to release a lock on a newly created variable that was not previously locked.</span></span>  
  
 <span data-ttu-id="50b11-160">尽管可以先装箱值类型变量，再调用 <xref:System.Threading.Monitor.Enter%2A> 和 <xref:System.Threading.Monitor.Exit%2A>（如下例所示）并且同时向这两种方法传递相同的装箱对象，但是进行该操作并没有什么好处。</span><span class="sxs-lookup"><span data-stu-id="50b11-160">Although you can box a value type variable before calling <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A>, as shown in the following example, and pass the same boxed object to both methods, there is no advantage to doing this.</span></span> <span data-ttu-id="50b11-161">对未装箱的变量所做的更改不会反映在装箱副本中，并且无法更改装箱副本的值。</span><span class="sxs-lookup"><span data-stu-id="50b11-161">Changes to the unboxed variable are not reflected in the boxed copy, and there is no way to change the value of the boxed copy.</span></span>  
  
 [!code-csharp[Conceptual.Monitors#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)]
 [!code-vb[Conceptual.Monitors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)]  
  
 <span data-ttu-id="50b11-162">选择要同步的对象时，应只锁定私有或内部对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-162">When selecting an object on which to synchronize, you should lock only on private or internal objects.</span></span> <span data-ttu-id="50b11-163">锁定外部对象可能会导致死锁，因为不相关的代码可能会出于不同目的选择要锁定的相同对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-163">Locking on external objects might result in deadlocks, because unrelated code could choose the same objects to lock on for different purposes.</span></span>  
  
 <span data-ttu-id="50b11-164">请注意，如果用于锁的对象派生自 <xref:System.MarshalByRefObject>，则可以在多个应用程序域中的对象上进行同步。</span><span class="sxs-lookup"><span data-stu-id="50b11-164">Note that you can synchronize on an object in multiple application domains if the object used for the lock derives from <xref:System.MarshalByRefObject>.</span></span>  
  
<a name="CriticalSection"></a>   
## <a name="the-critical-section"></a><span data-ttu-id="50b11-165">临界区</span><span class="sxs-lookup"><span data-stu-id="50b11-165">The critical section</span></span>  
 <span data-ttu-id="50b11-166">使用 <xref:System.Threading.Monitor.Enter%2A> 和 <xref:System.Threading.Monitor.Exit%2A> 方法来标记临界区的开头和结尾。</span><span class="sxs-lookup"><span data-stu-id="50b11-166">Use the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods to mark the beginning and end of a critical section.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="50b11-167"><xref:System.Threading.Monitor.Enter%2A> 和 <xref:System.Threading.Monitor.Exit%2A> 方法提供的功能与 Visual Basic 中的[lock](/dotnet/csharp/language-reference/keywords/lock-statement) C# [语句提供](/dotnet/visual-basic/language-reference/statements/synclock-statement)的功能相同，但 language 构造将 <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType> 方法重载和 <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> 方法括在 `try`...`finally` 中</span><span class="sxs-lookup"><span data-stu-id="50b11-167">The functionality provided by the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods is identical to that provided by the [lock](/dotnet/csharp/language-reference/keywords/lock-statement) statement in C# and the [SyncLock](/dotnet/visual-basic/language-reference/statements/synclock-statement) statement in Visual Basic, except that the language constructs wrap the <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType> method overload and the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method in a `try`…`finally`</span></span> <span data-ttu-id="50b11-168">阻止以确保已释放监视器。</span><span class="sxs-lookup"><span data-stu-id="50b11-168">block to ensure that the monitor is released.</span></span>  
  
 <span data-ttu-id="50b11-169">如果临界区是一组连续的指令，则 <xref:System.Threading.Monitor.Enter%2A> 方法获取的锁可以保证只有单个线程才能使用锁定的对象执行包含的代码。</span><span class="sxs-lookup"><span data-stu-id="50b11-169">If the critical section is a set of contiguous instructions, then the lock acquired by the <xref:System.Threading.Monitor.Enter%2A> method guarantees that only a single thread can execute the enclosed code with the locked object.</span></span> <span data-ttu-id="50b11-170">在这种情况下，我们建议将该代码放入 `try` 块中，并将对 <xref:System.Threading.Monitor.Exit%2A> 方法的调用置于 `finally` 块中。</span><span class="sxs-lookup"><span data-stu-id="50b11-170">In this case, we recommend that you place that code in a `try` block and place the call to the <xref:System.Threading.Monitor.Exit%2A> method in a `finally` block.</span></span> <span data-ttu-id="50b11-171">这可确保即使发生异常，也将释放该锁定。</span><span class="sxs-lookup"><span data-stu-id="50b11-171">This ensures that the lock is released even if an exception occurs.</span></span> <span data-ttu-id="50b11-172">下面的代码段演示了此模式。</span><span class="sxs-lookup"><span data-stu-id="50b11-172">The following code fragment illustrates this pattern.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)]
 [!code-vb[System.Threading.Monitor.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)]  
  
 <span data-ttu-id="50b11-173">此功能通常用于同步对类的静态方法或实例方法的访问。</span><span class="sxs-lookup"><span data-stu-id="50b11-173">This facility is typically used to synchronize access to a static or instance method of a class.</span></span>  
  
 <span data-ttu-id="50b11-174">如果某个关键部分涵盖了整个方法，则可以通过将 <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> 放置在方法上，并在 <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>的构造函数中指定 <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> 值来实现锁定工具。</span><span class="sxs-lookup"><span data-stu-id="50b11-174">If a critical section spans an entire method, the locking facility can be achieved by placing the <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> on the method, and specifying the <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> value in the constructor of <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>.</span></span> <span data-ttu-id="50b11-175">使用此属性时，不需要 <xref:System.Threading.Monitor.Enter%2A> 和 <xref:System.Threading.Monitor.Exit%2A> 方法调用。</span><span class="sxs-lookup"><span data-stu-id="50b11-175">When you use this attribute, the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> method calls are not needed.</span></span> <span data-ttu-id="50b11-176">下面的代码段演示了此模式：</span><span class="sxs-lookup"><span data-stu-id="50b11-176">The following code fragment illustrates this pattern:</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)]
 [!code-vb[System.Threading.Monitor.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)]  
  
 <span data-ttu-id="50b11-177">请注意，特性使当前线程保持锁定状态，直到该方法返回;如果可以更快地释放锁，请在方法中使用 <xref:System.Threading.Monitor> C#类、 [lock](/dotnet/csharp/language-reference/keywords/lock-statement)语句或 Visual Basic [SyncLock](/dotnet/visual-basic/language-reference/statements/synclock-statement)语句，而不是使用属性。</span><span class="sxs-lookup"><span data-stu-id="50b11-177">Note that the attribute causes the current thread to hold the lock until the method returns; if the lock can be released sooner, use the <xref:System.Threading.Monitor> class, the C# [lock](/dotnet/csharp/language-reference/keywords/lock-statement) statement, or the Visual Basic [SyncLock](/dotnet/visual-basic/language-reference/statements/synclock-statement) statement inside of the method instead of the attribute.</span></span>  
  
 <span data-ttu-id="50b11-178">尽管 <xref:System.Threading.Monitor.Enter%2A> 和 <xref:System.Threading.Monitor.Exit%2A> 语句可以锁定和释放给定的对象才能跨越成员或类边界，但并不推荐这样做。</span><span class="sxs-lookup"><span data-stu-id="50b11-178">While it is possible for the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> statements that lock and release a given object to cross member or class boundaries or both, this practice is not recommended.</span></span>  
  
<a name="Pulse"></a>   
## <a name="pulse-pulseall-and-wait"></a><span data-ttu-id="50b11-179">脉冲、System.threading.monitor.pulseall 和 Wait</span><span class="sxs-lookup"><span data-stu-id="50b11-179">Pulse, PulseAll, and Wait</span></span>  
 <span data-ttu-id="50b11-180">一旦某个线程拥有该锁并且进入了锁保护的临界区，它就可以调用 <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>、<xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>和 <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="50b11-180">Once a thread owns the lock and has entered the critical section that the lock protects, it can call the <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="50b11-181">当持有锁的线程 <xref:System.Threading.Monitor.Wait%2A>时，将释放锁，并将线程添加到已同步对象的等待队列。</span><span class="sxs-lookup"><span data-stu-id="50b11-181">When the thread that holds the lock calls <xref:System.Threading.Monitor.Wait%2A>, the lock is released and the thread is added to the waiting queue of the synchronized object.</span></span> <span data-ttu-id="50b11-182">就绪队列中的第一个线程（如果有）获取锁定并进入临界区。</span><span class="sxs-lookup"><span data-stu-id="50b11-182">The first thread in the ready queue, if any, acquires the lock and enters the critical section.</span></span> <span data-ttu-id="50b11-183">当 <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> 或 <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> 方法由持有锁的线程调用时，调用 <xref:System.Threading.Monitor.Wait%2A> 的线程将从等待队列移到就绪队列，而该线程必须位于等待队列的开头。）</span><span class="sxs-lookup"><span data-stu-id="50b11-183">The thread that called <xref:System.Threading.Monitor.Wait%2A> is moved from the waiting queue to the ready queue when either the <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> or the <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> method is called by the thread that holds the lock (to be moved, the thread must be at the head of the waiting queue).</span></span> <span data-ttu-id="50b11-184">当调用线程重新获取该域锁定时，<xref:System.Threading.Monitor.Wait%2A> 方法返回。</span><span class="sxs-lookup"><span data-stu-id="50b11-184">The <xref:System.Threading.Monitor.Wait%2A> method returns when the calling thread reacquires the lock.</span></span>  
  
 <span data-ttu-id="50b11-185">当持有锁的线程 <xref:System.Threading.Monitor.Pulse%2A>时，等待队列开头的线程将移到就绪队列。</span><span class="sxs-lookup"><span data-stu-id="50b11-185">When the thread that holds the lock calls <xref:System.Threading.Monitor.Pulse%2A>, the thread at the head of the waiting queue is moved to the ready queue.</span></span> <span data-ttu-id="50b11-186">调用 <xref:System.Threading.Monitor.PulseAll%2A> 方法会将等待队列中的所有线程移到就绪队列。</span><span class="sxs-lookup"><span data-stu-id="50b11-186">The call to the <xref:System.Threading.Monitor.PulseAll%2A> method moves all the threads from the waiting queue to the ready queue.</span></span>  
  
<a name="WaitHandles"></a>   
## <a name="monitors-and-wait-handles"></a><span data-ttu-id="50b11-187">监视器和等待句柄</span><span class="sxs-lookup"><span data-stu-id="50b11-187">Monitors and wait handles</span></span>  
 <span data-ttu-id="50b11-188">务必注意使用 <xref:System.Threading.Monitor> 类和 <xref:System.Threading.WaitHandle> 对象之间的区别。</span><span class="sxs-lookup"><span data-stu-id="50b11-188">It is important to note the distinction between the use of the <xref:System.Threading.Monitor> class and <xref:System.Threading.WaitHandle> objects.</span></span>  
  
-   <span data-ttu-id="50b11-189"><xref:System.Threading.Monitor> 类是纯粹托管的、完全可移植的，并且可能在操作系统资源需求方面更有效。</span><span class="sxs-lookup"><span data-stu-id="50b11-189">The <xref:System.Threading.Monitor> class is purely managed, fully portable, and might be more efficient in terms of operating-system resource requirements.</span></span>  
  
-   <span data-ttu-id="50b11-190"><xref:System.Threading.WaitHandle> 对象表示操作系统可等待对象，有助于托管和非托管代码之间进行同步，并公开一些高级操作系统功能，如同时等待多个对象的功能。</span><span class="sxs-lookup"><span data-stu-id="50b11-190"><xref:System.Threading.WaitHandle> objects represent operating-system waitable objects, are useful for synchronizing between managed and unmanaged code, and expose some advanced operating-system features like the ability to wait on many objects at once.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="50b11-191">下面的示例使用 <xref:System.Threading.Monitor> 类同步对 <xref:System.Random> 类所表示的随机数生成器的单个实例的访问。</span><span class="sxs-lookup"><span data-stu-id="50b11-191">The following example uses the <xref:System.Threading.Monitor> class to synchronize access to a single instance of a random number generator represented by the <xref:System.Random> class.</span></span> <span data-ttu-id="50b11-192">该示例创建了十个任务，每个任务都在线程池线程上以异步方式执行。</span><span class="sxs-lookup"><span data-stu-id="50b11-192">The example creates ten tasks, each of which executes asynchronously on a thread pool thread.</span></span> <span data-ttu-id="50b11-193">每个任务都生成10000个随机数字，计算其平均值，并更新两个过程级别的变量，这些变量维护生成的随机数的总数及其总和。</span><span class="sxs-lookup"><span data-stu-id="50b11-193">Each task generates 10,000 random numbers, calculates their average, and updates two procedure-level variables that maintain a running total of the number of random numbers generated and their sum.</span></span> <span data-ttu-id="50b11-194">执行完所有任务后，这两个值将用于计算总体平均值。</span><span class="sxs-lookup"><span data-stu-id="50b11-194">After all tasks have executed, these two values are then used to calculate the overall mean.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Monitor.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/example1.vb#1)]  
  
 <span data-ttu-id="50b11-195">由于可以从线程池线程上运行的任何任务进行访问，因此还必须同步对变量 `total` 和 `n` 的访问。</span><span class="sxs-lookup"><span data-stu-id="50b11-195">Because they can be accessed from any task running on a thread pool thread, access to the variables `total` and `n` must also be synchronized.</span></span> <span data-ttu-id="50b11-196"><xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> 方法用于实现此目的。</span><span class="sxs-lookup"><span data-stu-id="50b11-196">The <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> method is used for this purpose.</span></span>  
  
 <span data-ttu-id="50b11-197">下面的示例演示了 <xref:System.Threading.Monitor> 类（使用 `lock` 或 `SyncLock` 语言构造实现）、<xref:System.Threading.Interlocked> 类和 <xref:System.Threading.AutoResetEvent> 类的组合使用。</span><span class="sxs-lookup"><span data-stu-id="50b11-197">The following example demonstrates the combined use of the <xref:System.Threading.Monitor> class (implemented with the `lock` or `SyncLock` language construct), the <xref:System.Threading.Interlocked> class, and the <xref:System.Threading.AutoResetEvent> class.</span></span> <span data-ttu-id="50b11-198">它定义了两个 `internal`（在 C# 中）或 `Friend`（在 Visual Basic）类（`SyncResource` 和 `UnSyncResource`），它们分别提供对资源的同步和不同步访问。</span><span class="sxs-lookup"><span data-stu-id="50b11-198">It defines two `internal` (in C#) or `Friend` (in Visual Basic) classes, `SyncResource` and `UnSyncResource`, that respectively provide synchronized and unsynchronized access to a resource.</span></span> <span data-ttu-id="50b11-199">为了确保此示例展示同步和不同步访问的差异（如果每个方法调用快速完成，可能出现这种情况），此方法包含一次随机延迟：对于其 <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> 属性为偶数的线程，此方法调用 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 以引入 2,000 毫秒延迟。</span><span class="sxs-lookup"><span data-stu-id="50b11-199">To ensure that the example illustrates the difference between the synchronized and unsynchronized access (which could be the case if each method call completes rapidly), the method includes a random delay: for threads whose <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> property is even, the method calls <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> to introduce a delay of 2,000 milliseconds.</span></span> <span data-ttu-id="50b11-200">注意，由于 `SyncResource` 类不是公共类，因此没有客户端代码会对同步资源采用锁，内部类将自己采用锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-200">Note that, because the `SyncResource` class is not public, none of the client code takes a lock on the synchronized resource; the internal class itself takes the lock.</span></span> <span data-ttu-id="50b11-201">这可以防止恶意代码对公共对象采用锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-201">This prevents malicious code from taking a lock on a public object.</span></span>  
  
 [!code-csharp[Conceptual.Monitors#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/source.cs#1)]
 [!code-vb[Conceptual.Monitors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/source.vb#1)]  
  
 <span data-ttu-id="50b11-202">该示例定义一个变量（即 `numOps`），用于定义尝试访问资源的线程数。</span><span class="sxs-lookup"><span data-stu-id="50b11-202">The example defines a variable, `numOps`, that defines the number of threads that will attempt to access the resource.</span></span> <span data-ttu-id="50b11-203">该应用程序线程为每个同步和不同步的访问调用五次 <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="50b11-203">The application thread calls the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> method for synchronized and unsynchronized access five times each.</span></span> <span data-ttu-id="50b11-204"><xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> 方法具有一个参数，该参数是一个不接受任何参数且不返回任何值的委托。</span><span class="sxs-lookup"><span data-stu-id="50b11-204">The <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> method has a single parameter, a delegate that accepts no parameters and returns no value.</span></span> <span data-ttu-id="50b11-205">对于同步访问，它将调用 `SyncUpdateResource` 方法；对于不同步访问，它将调用 `UnSyncUpdateResource` 方法。</span><span class="sxs-lookup"><span data-stu-id="50b11-205">For synchronized access, it invokes the `SyncUpdateResource` method; for unsynchronized access, it invokes the `UnSyncUpdateResource` method.</span></span> <span data-ttu-id="50b11-206">每一组方法调用后，应用程序线程将调用[AutoResetEvent WaitOne](xref:System.Threading.WaitHandle.WaitOne*)方法，以便在 <xref:System.Threading.AutoResetEvent> 实例终止前一直阻止。</span><span class="sxs-lookup"><span data-stu-id="50b11-206">After each set of method calls, the application thread calls the [AutoResetEvent.WaitOne](xref:System.Threading.WaitHandle.WaitOne*) method so that it blocks until the <xref:System.Threading.AutoResetEvent> instance is signaled.</span></span>  
  
 <span data-ttu-id="50b11-207">每次调用 `SyncUpdateResource` 方法都会调用内部 `SyncResource.Access` 方法，然后调用 <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> 方法以递减 `numOps` 计数器。</span><span class="sxs-lookup"><span data-stu-id="50b11-207">Each call to the `SyncUpdateResource` method calls the internal `SyncResource.Access` method and then calls the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method to decrement the `numOps` counter.</span></span> <span data-ttu-id="50b11-208"><xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> 方法用于递减计数器，因为在其他情况下，如果第一个线程的递减值已存储在变量中，则不能确保第二个线程将访问该值。</span><span class="sxs-lookup"><span data-stu-id="50b11-208">The <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method Is used to decrement the counter, because otherwise you cannot be certain that a second thread will access the value before a first thread's decremented value has been stored in the variable.</span></span> <span data-ttu-id="50b11-209">当最后一个同步的工作线程将计数器递减到零时，表示所有同步线程均已完成访问该资源，`SyncUpdateResource` 方法将调用 <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> 方法，该方法指示主线程继续执行。</span><span class="sxs-lookup"><span data-stu-id="50b11-209">When the last synchronized worker thread decrements the counter to zero, indicating that all synchronized threads have completed accessing the resource, the `SyncUpdateResource` method calls the <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method, which signals the main thread to continue execution.</span></span>  
  
 <span data-ttu-id="50b11-210">每次调用 `UnSyncUpdateResource` 方法都会调用内部 `UnSyncResource.Access` 方法，然后调用 <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> 方法以递减 `numOps` 计数器。</span><span class="sxs-lookup"><span data-stu-id="50b11-210">Each call to the `UnSyncUpdateResource` method calls the internal `UnSyncResource.Access` method and then calls the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method to decrement the `numOps` counter.</span></span> <span data-ttu-id="50b11-211">同样，<xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> 方法用于递减计数器，以确保第二个线程在第一个线程的递减值分配给变量之前不会访问该值。</span><span class="sxs-lookup"><span data-stu-id="50b11-211">Once again, the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method Is used to decrement the counter to ensure that a second thread does not access the value before a first thread's decremented value has been assigned to the variable.</span></span> <span data-ttu-id="50b11-212">当最后一个同步的工作线程将计数器递减到零时，表示没有更多的不同步线程需要访问该资源，`UnSyncUpdateResource` 方法将调用 <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> 方法，该方法指示主线程继续执行。</span><span class="sxs-lookup"><span data-stu-id="50b11-212">When the last unsynchronized worker thread decrements the counter to zero, indicating that no more unsynchronized threads need to access the resource, the `UnSyncUpdateResource` method calls the <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method, which signals the main thread to continue execution.</span></span>  
  
 <span data-ttu-id="50b11-213">如示例的输出所示，同步访问可确保另一个线程必须在调用线程退出受保护的资源之后才能访问该资源；每个线程都在其前置任务上等待。</span><span class="sxs-lookup"><span data-stu-id="50b11-213">As the output from  the example shows, synchronized access ensures that the calling thread exits the protected resource before another thread can access it; each thread waits on its predecessor.</span></span> <span data-ttu-id="50b11-214">另一方面，在不采用锁的情况下，将按线程到达的顺序调用 `UnSyncResource.Access` 方法。</span><span class="sxs-lookup"><span data-stu-id="50b11-214">On the other hand, without the lock, the `UnSyncResource.Access` method is called in the order in which threads reach it.</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="50b11-215">此类型是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="50b11-215">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="50b11-216">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="50b11-216">Managed Threading</span></span></related>
    <related type="Article" href="/dotnet/standard/threading/threading-objects-and-features"><span data-ttu-id="50b11-217">线程处理对象和功能</span><span class="sxs-lookup"><span data-stu-id="50b11-217">Threading Objects and Features</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Enter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="50b11-218">获取指定对象上的排他锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-218">Acquires an exclusive lock on a specified object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Enter : obj -&gt; unit" Usage="System.Threading.Monitor.Enter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="50b11-219">在其上获取监视器锁的对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-219">The object on which to acquire the monitor lock.</span></span></param>
        <summary><span data-ttu-id="50b11-220">在指定对象上获取排他锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-220">Acquires an exclusive lock on the specified object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50b11-221">使用 `Enter` 获取作为参数传递的对象上的 <xref:System.Threading.Monitor>。</span><span class="sxs-lookup"><span data-stu-id="50b11-221">Use `Enter` to acquire the <xref:System.Threading.Monitor> on the object passed as the parameter.</span></span> <span data-ttu-id="50b11-222">如果另一个线程在对象上执行了 `Enter`，但尚未执行相应的 <xref:System.Threading.Monitor.Exit%2A>，则当前线程将被阻止，直到另一个线程释放该对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-222">If another thread has executed an `Enter` on the object but has not yet executed the corresponding <xref:System.Threading.Monitor.Exit%2A>, the current thread will block until the other thread releases the object.</span></span> <span data-ttu-id="50b11-223">同一个线程在不阻止的情况下多次调用 `Enter` 是合法的;但是，必须在等待对象的其他线程取消阻止之前调用相等数量的 `Exit` 调用。</span><span class="sxs-lookup"><span data-stu-id="50b11-223">It is legal for the same thread to invoke `Enter` more than once without it blocking; however, an equal number of `Exit` calls must be invoked before other threads waiting on the object will unblock.</span></span>  
  
 <span data-ttu-id="50b11-224">使用 <xref:System.Threading.Monitor> 锁定对象（即引用类型），而不是值类型。</span><span class="sxs-lookup"><span data-stu-id="50b11-224">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="50b11-225">将值类型变量传递给 `Enter`时，它将被装箱为对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-225">When you pass a value type variable to `Enter`, it is boxed as an object.</span></span> <span data-ttu-id="50b11-226">如果传递相同的变量以再次 `Enter`，则该变量将被装箱为单独的对象，并且不会阻止该线程。</span><span class="sxs-lookup"><span data-stu-id="50b11-226">If you pass the same variable to `Enter` again, it is boxed as a separate object, and the thread does not block.</span></span> <span data-ttu-id="50b11-227">在这种情况下，将保护 `Monitor` 的代码不受保护。</span><span class="sxs-lookup"><span data-stu-id="50b11-227">In this case, the code that `Monitor` is supposedly protecting is not protected.</span></span> <span data-ttu-id="50b11-228">此外，将变量传递到 `Exit`时，仍然会创建另一个单独的对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-228">Furthermore, when you pass the variable to `Exit`, still another separate object is created.</span></span> <span data-ttu-id="50b11-229">由于传递给 `Exit` 的对象不同于传递到 `Enter`的对象，`Monitor` 将引发 <xref:System.Threading.SynchronizationLockException>。</span><span class="sxs-lookup"><span data-stu-id="50b11-229">Because the object passed to `Exit` is different from the object passed to `Enter`, `Monitor` throws <xref:System.Threading.SynchronizationLockException>.</span></span> <span data-ttu-id="50b11-230">有关详细信息，请参阅概念主题[监视](xref:System.Threading.Monitor)。</span><span class="sxs-lookup"><span data-stu-id="50b11-230">For more information, see the conceptual topic [Monitors](xref:System.Threading.Monitor).</span></span>  
  
 <span data-ttu-id="50b11-231"><xref:System.Threading.Thread.Interrupt%2A> 可以中断等待进入对象 `Monitor` 的线程。</span><span class="sxs-lookup"><span data-stu-id="50b11-231"><xref:System.Threading.Thread.Interrupt%2A> can interrupt threads that are waiting to enter a `Monitor` on an object.</span></span> <span data-ttu-id="50b11-232">将引发 <xref:System.Threading.ThreadInterruptedException>。</span><span class="sxs-lookup"><span data-stu-id="50b11-232">A <xref:System.Threading.ThreadInterruptedException> will be thrown.</span></span>  
  
 <span data-ttu-id="50b11-233">使用C# `try`...`finally`</span><span class="sxs-lookup"><span data-stu-id="50b11-233">Use a C# `try`…`finally`</span></span> <span data-ttu-id="50b11-234">block （`Try`...`Finally`</span><span class="sxs-lookup"><span data-stu-id="50b11-234">block (`Try`…`Finally`</span></span> <span data-ttu-id="50b11-235">在 Visual Basic）中，确保释放监视器，或使用C# `lock` 语句（Visual Basic 中的`SyncLock` 语句），该语句将 <xref:System.Threading.Monitor.Enter%2A> 和 <xref:System.Threading.Monitor.Exit%2A> 方法包装在 `try`...`finally`</span><span class="sxs-lookup"><span data-stu-id="50b11-235">in Visual Basic) to ensure that you release the monitor, or use the C# `lock` statement (`SyncLock` statement in Visual Basic), which wraps the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods in a `try`…`finally`</span></span> <span data-ttu-id="50b11-236">模块.</span><span class="sxs-lookup"><span data-stu-id="50b11-236">block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="50b11-237">下面的示例演示如何使用 `Enter` 方法。</span><span class="sxs-lookup"><span data-stu-id="50b11-237">The following example demonstrates how to use the `Enter` method.</span></span>  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="50b11-238">
          <paramref name="obj" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-238">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="50b11-239">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="50b11-239">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member Enter : obj * bool -&gt; unit" Usage="System.Threading.Monitor.Enter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="50b11-240">要在其上等待的对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-240">The object on which to wait.</span></span></param>
        <param name="lockTaken"><span data-ttu-id="50b11-241">尝试获取锁的结果，通过引用传递。</span><span class="sxs-lookup"><span data-stu-id="50b11-241">The result of the attempt to acquire the lock, passed by reference.</span></span> <span data-ttu-id="50b11-242">输入必须为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-242">The input must be <see langword="false" />.</span></span> <span data-ttu-id="50b11-243">如果已获取锁，则输出为 <see langword="true" />；否则输出为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-243">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span></span> <span data-ttu-id="50b11-244">即使在尝试获取锁的过程中发生异常，也会设置输出。</span><span class="sxs-lookup"><span data-stu-id="50b11-244">The output is set even if an exception occurs during the attempt to acquire the lock.</span></span>  
  
<span data-ttu-id="50b11-245">注意   如果没有发生异常，则此方法的输出始终为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-245">Note   If no exception occurs, the output of this method is always <see langword="true" />.</span></span></param>
        <summary><span data-ttu-id="50b11-246">获取指定对象上的排他锁，并自动设置一个值，指示是否获取了该锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-246">Acquires an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50b11-247">使用 `Enter` 获取作为 `obj` 参数传递的对象的 <xref:System.Threading.Monitor>。</span><span class="sxs-lookup"><span data-stu-id="50b11-247">Use `Enter` to acquire the <xref:System.Threading.Monitor> on the object passed as the `obj` parameter.</span></span> <span data-ttu-id="50b11-248">如果另一个线程在对象上执行了 `Enter`，但尚未执行相应的 <xref:System.Threading.Monitor.Exit%2A>，则当前线程将被阻止，直到另一个线程释放该对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-248">If another thread has executed an `Enter` on the object but has not yet executed the corresponding <xref:System.Threading.Monitor.Exit%2A>, the current thread will block until the other thread releases the object.</span></span> <span data-ttu-id="50b11-249">同一个线程在不阻止的情况下多次调用 `Enter` 是合法的;但是，必须在等待对象的其他线程取消阻止之前调用相等数量的 `Exit` 调用。</span><span class="sxs-lookup"><span data-stu-id="50b11-249">It is legal for the same thread to invoke `Enter` more than once without it blocking; however, an equal number of `Exit` calls must be invoked before other threads waiting on the object will unblock.</span></span>  
  
 <span data-ttu-id="50b11-250">如果由于引发了异常而未获取锁，则在此方法结束后 `false` 为 `lockTaken` 参数指定的变量。</span><span class="sxs-lookup"><span data-stu-id="50b11-250">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="50b11-251">这使程序可以确定是否有必要释放该锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-251">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span> <span data-ttu-id="50b11-252">如果此方法返回而不引发异常，则始终 `true`为 `lockTaken` 参数指定的变量，无需对其进行测试。</span><span class="sxs-lookup"><span data-stu-id="50b11-252">If this method returns without throwing an exception, the variable specified for the `lockTaken` parameter is always `true`, and there is no need to test it.</span></span>  
  
 <span data-ttu-id="50b11-253">使用 <xref:System.Threading.Monitor> 锁定对象（即引用类型），而不是值类型。</span><span class="sxs-lookup"><span data-stu-id="50b11-253">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="50b11-254">将值类型变量传递给 `Enter`时，它将被装箱为对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-254">When you pass a value type variable to `Enter`, it is boxed as an object.</span></span> <span data-ttu-id="50b11-255">如果传递相同的变量以再次 `Enter`，则该变量将被装箱为单独的对象，并且不会阻止该线程。</span><span class="sxs-lookup"><span data-stu-id="50b11-255">If you pass the same variable to `Enter` again, it is boxed as a separate object, and the thread does not block.</span></span> <span data-ttu-id="50b11-256">在这种情况下，将保护 `Monitor` 的代码不受保护。</span><span class="sxs-lookup"><span data-stu-id="50b11-256">In this case, the code that `Monitor` is supposedly protecting is not protected.</span></span> <span data-ttu-id="50b11-257">此外，将变量传递到 `Exit`时，将创建另一个单独的对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-257">Furthermore, when you pass the variable to `Exit`, another separate object is created.</span></span> <span data-ttu-id="50b11-258">由于传递给 `Exit` 的对象不同于传递到 `Enter`的对象，`Monitor` 将引发 <xref:System.Threading.SynchronizationLockException>。</span><span class="sxs-lookup"><span data-stu-id="50b11-258">Because the object passed to `Exit` is different from the object passed to `Enter`, `Monitor` throws <xref:System.Threading.SynchronizationLockException>.</span></span> <span data-ttu-id="50b11-259">有关详细信息，请参阅概念主题[监视](xref:System.Threading.Monitor)。</span><span class="sxs-lookup"><span data-stu-id="50b11-259">For more information, see the conceptual topic [Monitors](xref:System.Threading.Monitor).</span></span>  
  
 <span data-ttu-id="50b11-260"><xref:System.Threading.Thread.Interrupt%2A> 可以中断等待进入对象 `Monitor` 的线程。</span><span class="sxs-lookup"><span data-stu-id="50b11-260"><xref:System.Threading.Thread.Interrupt%2A> can interrupt threads that are waiting to enter a `Monitor` on an object.</span></span> <span data-ttu-id="50b11-261">将引发 <xref:System.Threading.ThreadInterruptedException>。</span><span class="sxs-lookup"><span data-stu-id="50b11-261">A <xref:System.Threading.ThreadInterruptedException> will be thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="50b11-262">下面的代码演示使用 <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> 方法重载的基本模式。</span><span class="sxs-lookup"><span data-stu-id="50b11-262">The following code shows the basic pattern for using the <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> method overload.</span></span> <span data-ttu-id="50b11-263">此重载始终设置传递到 `ref` 参数的变量的值（`ByRef` Visual Basic） `lockTaken`，即使该方法引发异常，因此该变量的值是测试是否必须释放该锁的可靠方法。</span><span class="sxs-lookup"><span data-stu-id="50b11-263">This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Enter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#2)]
 [!code-vb[System.Threading.Monitor.Enter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="50b11-264"><paramref name="lockTaken" /> 的输入为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-264">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="50b11-265">
          <paramref name="obj" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-265">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Exit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Exit : obj -&gt; unit" Usage="System.Threading.Monitor.Exit obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="50b11-266">在其上释放锁的对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-266">The object on which to release the lock.</span></span></param>
        <summary><span data-ttu-id="50b11-267">释放指定对象上的排他锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-267">Releases an exclusive lock on the specified object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50b11-268">调用线程必须拥有 `obj` 参数的锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-268">The calling thread must own the lock on the `obj` parameter.</span></span> <span data-ttu-id="50b11-269">如果调用线程拥有指定对象的锁，并且已对该对象进行了相等的 `Exit` 和 <xref:System.Threading.Monitor.Enter%2A> 调用，则会释放该锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-269">If the calling thread owns the lock on the specified object, and has made an equal number of `Exit` and <xref:System.Threading.Monitor.Enter%2A> calls for the object, then the lock is released.</span></span> <span data-ttu-id="50b11-270">如果调用线程未 `Enter`调用 `Exit` 次，则不会释放该锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-270">If the calling thread has not invoked `Exit` as many times as `Enter`, the lock is not released.</span></span>  
  
 <span data-ttu-id="50b11-271">如果锁已释放并且其他线程位于对象的就绪队列中，则其中一个线程将获取该锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-271">If the lock is released and other threads are in the ready queue for the object, one of the threads acquires the lock.</span></span> <span data-ttu-id="50b11-272">如果其他线程在等待队列中等待获取锁定，则当锁的所有者调用 `Exit`时，它们不会自动移到就绪队列。</span><span class="sxs-lookup"><span data-stu-id="50b11-272">If other threads are in the waiting queue waiting to acquire the lock, they are not automatically moved to the ready queue when the owner of the lock calls `Exit`.</span></span> <span data-ttu-id="50b11-273">若要将一个或多个等待线程移入准备就绪的队列中，请在调用 `Exit`之前调用 <xref:System.Threading.Monitor.Pulse%2A> 或 <xref:System.Threading.Monitor.PulseAll%2A>。</span><span class="sxs-lookup"><span data-stu-id="50b11-273">To move one or more waiting threads into the ready queue, call <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> before invoking `Exit`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="50b11-274">下面的示例演示如何使用 `Exit` 方法。</span><span class="sxs-lookup"><span data-stu-id="50b11-274">The following example demonstrates how to use the `Exit` method.</span></span>  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="50b11-275">
          <paramref name="obj" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-275">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="50b11-276">当前线程不拥有指定对象的锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-276">The current thread does not own the lock for the specified object.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="50b11-277">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="50b11-277">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsEntered">
      <MemberSignature Language="C#" Value="public static bool IsEntered (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEntered(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.IsEntered(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEntered (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEntered(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member IsEntered : obj -&gt; bool" Usage="System.Threading.Monitor.IsEntered obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="50b11-278">要测试的对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-278">The object to test.</span></span></param>
        <summary><span data-ttu-id="50b11-279">确定当前线程是否保留指定对象上的锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-279">Determines whether the current thread holds the lock on the specified object.</span></span></summary>
        <returns><span data-ttu-id="50b11-280">如果当前线程持有 <paramref name="obj" /> 锁，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-280"><see langword="true" /> if the current thread holds the lock on <paramref name="obj" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50b11-281">此方法仅适用于使用 <xref:System.Threading.Monitor> 类的方法获取的锁，或通过使用C# `lock` 语句或使用 <xref:System.Threading.Monitor>实现的 Visual Basic `SyncLock` 语句来实现。</span><span class="sxs-lookup"><span data-stu-id="50b11-281">This method works only for locks that are acquired by using the methods of the <xref:System.Threading.Monitor> class, or by using the C# `lock` statement or the Visual Basic `SyncLock` statement, which are implemented with <xref:System.Threading.Monitor>.</span></span>  
  
 <span data-ttu-id="50b11-282">将此方法与诊断工具（如 <xref:System.Diagnostics.Debug.Assert%2A> 方法和 <xref:System.Diagnostics.Contracts.Contract> 类）结合使用，以调试涉及 <xref:System.Threading.Monitor> 类的锁定问题。</span><span class="sxs-lookup"><span data-stu-id="50b11-282">Use this method with diagnostic tools, such as the <xref:System.Diagnostics.Debug.Assert%2A> method and the <xref:System.Diagnostics.Contracts.Contract> class, to debug locking issues that involve the <xref:System.Threading.Monitor> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="50b11-283"><paramref name="obj" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-283"><paramref name="obj" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LockContentionCount">
      <MemberSignature Language="C#" Value="public static long LockContentionCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 LockContentionCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Monitor.LockContentionCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LockContentionCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long LockContentionCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LockContentionCount : int64" Usage="System.Threading.Monitor.LockContentionCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="50b11-284">获取尝试锁定监视器时出现争用的次数。</span><span class="sxs-lookup"><span data-stu-id="50b11-284">Gets the number of times there was contention when trying to take the monitor's lock.</span></span></summary>
        <value><span data-ttu-id="50b11-285">尝试获取监视器锁时存在争用的次数。</span><span class="sxs-lookup"><span data-stu-id="50b11-285">The number of times there was contention when trying to take the monitor's lock.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Pulse">
      <MemberSignature Language="C#" Value="public static void Pulse (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pulse(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Pulse(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pulse (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Pulse(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Pulse : obj -&gt; unit" Usage="System.Threading.Monitor.Pulse obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="50b11-286">线程正在等待的对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-286">The object a thread is waiting for.</span></span></param>
        <summary><span data-ttu-id="50b11-287">通知等待队列中的线程锁定对象状态的更改。</span><span class="sxs-lookup"><span data-stu-id="50b11-287">Notifies a thread in the waiting queue of a change in the locked object's state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50b11-288">只有锁定的当前所有者才能使用 `Pulse`向正在等待的对象发出信号。</span><span class="sxs-lookup"><span data-stu-id="50b11-288">Only the current owner of the lock can signal a waiting object using `Pulse`.</span></span>  
  
 <span data-ttu-id="50b11-289">当前拥有指定对象的锁的线程调用此方法，以向第一个线程发出锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-289">The thread that currently owns the lock on the specified object invokes this method to signal the next thread in line for the lock.</span></span> <span data-ttu-id="50b11-290">接收到脉冲后，等待线程会移动到就绪队列。</span><span class="sxs-lookup"><span data-stu-id="50b11-290">Upon receiving the pulse, the waiting thread is moved to the ready queue.</span></span> <span data-ttu-id="50b11-291">如果调用的线程 `Pulse` 释放该锁，则就绪队列（不一定是 pulsed 的线程）中的下一个线程将获取该锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-291">When the thread that invoked `Pulse` releases the lock, the next thread in the ready queue (which is not necessarily the thread that was pulsed) acquires the lock.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="50b11-292"><xref:System.Threading.Monitor> 类不维护指示已调用 <xref:System.Threading.Monitor.Pulse%2A> 方法的状态。</span><span class="sxs-lookup"><span data-stu-id="50b11-292">The <xref:System.Threading.Monitor> class does not maintain state indicating that the <xref:System.Threading.Monitor.Pulse%2A> method has been called.</span></span> <span data-ttu-id="50b11-293">因此，如果在没有线程等待时调用 <xref:System.Threading.Monitor.Pulse%2A>，则调用 <xref:System.Threading.Monitor.Wait%2A> 的下一个线程就像从未调用过 <xref:System.Threading.Monitor.Pulse%2A> 一样。</span><span class="sxs-lookup"><span data-stu-id="50b11-293">Thus, if you call <xref:System.Threading.Monitor.Pulse%2A> when no threads are waiting, the next thread that calls <xref:System.Threading.Monitor.Wait%2A> blocks as if <xref:System.Threading.Monitor.Pulse%2A> had never been called.</span></span> <span data-ttu-id="50b11-294">如果两个线程使用 <xref:System.Threading.Monitor.Pulse%2A> 并且 <xref:System.Threading.Monitor.Wait%2A> 交互，这可能会导致死锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-294">If two threads are using <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.Wait%2A> to interact, this could result in a deadlock.</span></span> <span data-ttu-id="50b11-295">与此 <xref:System.Threading.AutoResetEvent> 类的行为相比较：如果通过调用其 <xref:System.Threading.EventWaitHandle.Set%2A> 方法发出 <xref:System.Threading.AutoResetEvent> 信号，并且没有等待的线程，则 <xref:System.Threading.AutoResetEvent> 将保持为已终止状态，直到线程调用 <xref:System.Threading.WaitHandle.WaitOne%2A>、<xref:System.Threading.WaitHandle.WaitAny%2A>或 <xref:System.Threading.WaitHandle.WaitAll%2A>为止。</span><span class="sxs-lookup"><span data-stu-id="50b11-295">Contrast this with the behavior of the <xref:System.Threading.AutoResetEvent> class: If you signal an <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, and there are no threads waiting, the <xref:System.Threading.AutoResetEvent> remains in a signaled state until a thread calls <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.WaitAll%2A>.</span></span> <span data-ttu-id="50b11-296"><xref:System.Threading.AutoResetEvent> 将释放该线程并返回到信号状态。</span><span class="sxs-lookup"><span data-stu-id="50b11-296">The <xref:System.Threading.AutoResetEvent> releases that thread and returns to the unsignaled state.</span></span>  
  
 <span data-ttu-id="50b11-297">请注意，同步对象包含多个引用，包括对当前持有锁的线程的引用、对就绪队列的引用、包含准备好获取锁的线程的引用以及对等待队列的引用（其中包含等待对象状态更改通知的线程）。</span><span class="sxs-lookup"><span data-stu-id="50b11-297">Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="50b11-298">必须从同步的代码块内调用 `Pulse`、<xref:System.Threading.Monitor.PulseAll%2A>和 <xref:System.Threading.Monitor.Wait%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="50b11-298">The `Pulse`, <xref:System.Threading.Monitor.PulseAll%2A>, and <xref:System.Threading.Monitor.Wait%2A> methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="50b11-299">若要向多个线程发出信号，请使用 <xref:System.Threading.Monitor.PulseAll%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="50b11-299">To signal multiple threads, use the <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="50b11-300">
          <paramref name="obj" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-300">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="50b11-301">调用线程不拥有指定对象的锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-301">The calling thread does not own the lock for the specified object.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="50b11-302">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="50b11-302">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="PulseAll">
      <MemberSignature Language="C#" Value="public static void PulseAll (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PulseAll(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.PulseAll(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PulseAll (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PulseAll(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member PulseAll : obj -&gt; unit" Usage="System.Threading.Monitor.PulseAll obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="50b11-303">发送脉冲的对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-303">The object that sends the pulse.</span></span></param>
        <summary><span data-ttu-id="50b11-304">通知所有的等待线程对象状态的更改。</span><span class="sxs-lookup"><span data-stu-id="50b11-304">Notifies all waiting threads of a change in the object's state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50b11-305">当前拥有指定对象的锁的线程调用此方法，以向等待获取该对象的锁的所有线程发出信号。</span><span class="sxs-lookup"><span data-stu-id="50b11-305">The thread that currently owns the lock on the specified object invokes this method to signal all threads waiting to acquire the lock on the object.</span></span> <span data-ttu-id="50b11-306">发送信号后，等待的线程会移动到就绪队列。</span><span class="sxs-lookup"><span data-stu-id="50b11-306">After the signal is sent, the waiting threads are moved to the ready queue.</span></span> <span data-ttu-id="50b11-307">如果调用的线程 `PulseAll` 释放该锁，则就绪队列中的下一个线程将获取该锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-307">When the thread that invoked `PulseAll` releases the lock, the next thread in the ready queue acquires the lock.</span></span>  
  
 <span data-ttu-id="50b11-308">请注意，同步对象包含多个引用，包括对当前持有锁的线程的引用、对就绪队列的引用、包含准备好获取锁的线程的引用以及对等待队列的引用（其中包含等待对象状态更改通知的线程）。</span><span class="sxs-lookup"><span data-stu-id="50b11-308">Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="50b11-309">必须从同步的代码块内调用 <xref:System.Threading.Monitor.Pulse%2A>、`PulseAll`和 <xref:System.Threading.Monitor.Wait%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="50b11-309">The <xref:System.Threading.Monitor.Pulse%2A>, `PulseAll`, and <xref:System.Threading.Monitor.Wait%2A> methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="50b11-310"><xref:System.Threading.Monitor.Pulse%2A> 方法的备注说明了在没有线程等待时调用 <xref:System.Threading.Monitor.Pulse%2A> 会发生的情况。</span><span class="sxs-lookup"><span data-stu-id="50b11-310">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 <span data-ttu-id="50b11-311">若要向单个线程发出信号，请使用 `Pulse` 方法。</span><span class="sxs-lookup"><span data-stu-id="50b11-311">To signal a single thread, use the `Pulse` method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="50b11-312">
          <paramref name="obj" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-312">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="50b11-313">调用线程不拥有指定对象的锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-313">The calling thread does not own the lock for the specified object.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="50b11-314">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="50b11-314">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="50b11-315">尝试获取指定对象的排他锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-315">Attempts to acquire an exclusive lock on the specified object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj -&gt; bool" Usage="System.Threading.Monitor.TryEnter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="50b11-316">在其上获取锁的对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-316">The object on which to acquire the lock.</span></span></param>
        <summary><span data-ttu-id="50b11-317">尝试获取指定对象的排他锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-317">Attempts to acquire an exclusive lock on the specified object.</span></span></summary>
        <returns><span data-ttu-id="50b11-318">如果当前线程获取该锁，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-318"><see langword="true" /> if the current thread acquires the lock; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50b11-319">如果成功，则此方法获取对 `obj` 参数的排他锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-319">If successful, this method acquires an exclusive lock on the `obj` parameter.</span></span> <span data-ttu-id="50b11-320">此方法立即返回，无论锁是否可用。</span><span class="sxs-lookup"><span data-stu-id="50b11-320">This method returns immediately, whether or not the lock is available.</span></span>  
  
 <span data-ttu-id="50b11-321">此方法与 <xref:System.Threading.Monitor.Enter%2A>类似，但它永远不会阻止当前线程。</span><span class="sxs-lookup"><span data-stu-id="50b11-321">This method is similar to <xref:System.Threading.Monitor.Enter%2A>, but it will never block the current thread.</span></span> <span data-ttu-id="50b11-322">如果线程在不阻止的情况下不能输入，则方法将返回 `false,`。</span><span class="sxs-lookup"><span data-stu-id="50b11-322">If the thread cannot enter without blocking, the method returns `false,`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="50b11-323">使用 <xref:System.Threading.Monitor> 锁定对象（即引用类型），而不是值类型。</span><span class="sxs-lookup"><span data-stu-id="50b11-323">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="50b11-324">有关详细信息，请参阅 <xref:System.Threading.Monitor> 文章。</span><span class="sxs-lookup"><span data-stu-id="50b11-324">For details, see the <xref:System.Threading.Monitor> article.</span></span>  
  
 <span data-ttu-id="50b11-325">若要确保线程不输入临界区，应检查方法的返回值，并仅在关键部分中执行代码，前提是该方法的返回值为 `true`。</span><span class="sxs-lookup"><span data-stu-id="50b11-325">To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`.</span></span> <span data-ttu-id="50b11-326">下面的代码段显示了用于调用此方法的模式。</span><span class="sxs-lookup"><span data-stu-id="50b11-326">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="50b11-327">请注意，应在 `finally` 块中调用 <xref:System.Threading.Monitor.Exit%2A>，以确保调用线程在发生异常的情况下释放其对临界区的锁定。</span><span class="sxs-lookup"><span data-stu-id="50b11-327">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)]
 [!code-vb[System.Threading.Monitor.TryEnter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="50b11-328">下面的代码示例演示如何使用 `TryEnter` 方法。</span><span class="sxs-lookup"><span data-stu-id="50b11-328">The following code example demonstrates how to use the `TryEnter` method.</span></span>  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="50b11-329">
          <paramref name="obj" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-329">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="50b11-330">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="50b11-330">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * bool -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="50b11-331">在其上获取锁的对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-331">The object on which to acquire the lock.</span></span></param>
        <param name="lockTaken"><span data-ttu-id="50b11-332">尝试获取锁的结果，通过引用传递。</span><span class="sxs-lookup"><span data-stu-id="50b11-332">The result of the attempt to acquire the lock, passed by reference.</span></span> <span data-ttu-id="50b11-333">输入必须为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-333">The input must be <see langword="false" />.</span></span> <span data-ttu-id="50b11-334">如果已获取锁，则输出为 <see langword="true" />；否则输出为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-334">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span></span> <span data-ttu-id="50b11-335">即使在尝试获取锁的过程中发生异常，也会设置输出。</span><span class="sxs-lookup"><span data-stu-id="50b11-335">The output is set even if an exception occurs during the attempt to acquire the lock.</span></span></param>
        <summary><span data-ttu-id="50b11-336">尝试获取指定对象上的排他锁，并自动设置一个值，指示是否获取了该锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-336">Attempts to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50b11-337">如果成功，则此方法获取对 `obj` 参数的排他锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-337">If successful, this method acquires an exclusive lock on the `obj` parameter.</span></span> <span data-ttu-id="50b11-338">此方法立即返回，无论锁是否可用。</span><span class="sxs-lookup"><span data-stu-id="50b11-338">This method returns immediately, whether or not the lock is available.</span></span>  
  
 <span data-ttu-id="50b11-339">如果由于引发了异常而未获取锁，则在此方法结束后 `false` 为 `lockTaken` 参数指定的变量。</span><span class="sxs-lookup"><span data-stu-id="50b11-339">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="50b11-340">这使程序可以确定是否有必要释放该锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-340">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span>  
  
 <span data-ttu-id="50b11-341">此方法与 <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>类似，但它永远不会阻止当前线程。</span><span class="sxs-lookup"><span data-stu-id="50b11-341">This method is similar to <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, but it will never block the current thread.</span></span> <span data-ttu-id="50b11-342">如果线程在不阻止的情况下不能输入，则在该方法返回时，`lockTaken` 参数设置为 `false`。</span><span class="sxs-lookup"><span data-stu-id="50b11-342">If the thread cannot enter without blocking, the `lockTaken` argument is set to `false` when the method returns.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="50b11-343">使用 <xref:System.Threading.Monitor> 锁定对象（即引用类型），而不是值类型。</span><span class="sxs-lookup"><span data-stu-id="50b11-343">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="50b11-344">有关详细信息，请参阅<xref:System.Threading.Monitor>一文。</span><span class="sxs-lookup"><span data-stu-id="50b11-344">For more information, see the <xref:System.Threading.Monitor> article.</span></span>  
  
 <span data-ttu-id="50b11-345">若要确保线程不输入临界区，应检查 `lockTaken` 的值，并仅在临界区中执行代码，前提是 `true`其值。</span><span class="sxs-lookup"><span data-stu-id="50b11-345">To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`.</span></span> <span data-ttu-id="50b11-346">下面的代码段显示了用于调用此方法的模式。</span><span class="sxs-lookup"><span data-stu-id="50b11-346">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="50b11-347">请注意，应在 `finally` 块中调用 <xref:System.Threading.Monitor.Exit%2A>，以确保调用线程在发生异常的情况下释放其对临界区的锁定。</span><span class="sxs-lookup"><span data-stu-id="50b11-347">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)]
 [!code-vb[System.Threading.Monitor.TryEnter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="50b11-348">下面的代码演示使用 <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> 方法重载的基本模式。</span><span class="sxs-lookup"><span data-stu-id="50b11-348">The following code shows the basic pattern for using the <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> method overload.</span></span> <span data-ttu-id="50b11-349">此重载始终设置传递到 `ref` 参数的变量的值（`ByRef` Visual Basic） `lockTaken`，即使该方法引发异常，因此该变量的值是测试是否必须释放该锁的可靠方法。</span><span class="sxs-lookup"><span data-stu-id="50b11-349">This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Enter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#3)]
 [!code-vb[System.Threading.Monitor.Enter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="50b11-350"><paramref name="lockTaken" /> 的输入为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-350">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="50b11-351">
          <paramref name="obj" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-351">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="50b11-352">在其上获取锁的对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-352">The object on which to acquire the lock.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="50b11-353">等待锁所需的毫秒数。</span><span class="sxs-lookup"><span data-stu-id="50b11-353">The number of milliseconds to wait for the lock.</span></span></param>
        <summary><span data-ttu-id="50b11-354">在指定的毫秒数内尝试获取指定对象上的排他锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-354">Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.</span></span></summary>
        <returns><span data-ttu-id="50b11-355">如果当前线程获取该锁，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-355"><see langword="true" /> if the current thread acquires the lock; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50b11-356">如果 `millisecondsTimeout` 参数等于 <xref:System.Threading.Timeout.Infinite>，则此方法等效于 <xref:System.Threading.Monitor.Enter%2A>。</span><span class="sxs-lookup"><span data-stu-id="50b11-356">If the `millisecondsTimeout` parameter equals <xref:System.Threading.Timeout.Infinite>, this method is equivalent to <xref:System.Threading.Monitor.Enter%2A>.</span></span> <span data-ttu-id="50b11-357">如果 `millisecondsTimeout` 等于0，则此方法等效于 <xref:System.Threading.Monitor.TryEnter%2A>。</span><span class="sxs-lookup"><span data-stu-id="50b11-357">If `millisecondsTimeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="50b11-358">使用 <xref:System.Threading.Monitor> 锁定对象（即引用类型），而不是值类型。</span><span class="sxs-lookup"><span data-stu-id="50b11-358">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="50b11-359">有关详细信息，请参阅 <xref:System.Threading.Monitor> 文章。</span><span class="sxs-lookup"><span data-stu-id="50b11-359">For details, see the <xref:System.Threading.Monitor> article.</span></span>  
  
 <span data-ttu-id="50b11-360">若要确保线程不输入临界区，应检查方法的返回值，并仅在关键部分中执行代码，前提是该方法的返回值为 `true`。</span><span class="sxs-lookup"><span data-stu-id="50b11-360">To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`.</span></span> <span data-ttu-id="50b11-361">下面的代码段显示了用于调用此方法的模式。</span><span class="sxs-lookup"><span data-stu-id="50b11-361">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="50b11-362">请注意，应在 `finally` 块中调用 <xref:System.Threading.Monitor.Exit%2A>，以确保调用线程在发生异常的情况下释放其对临界区的锁定。</span><span class="sxs-lookup"><span data-stu-id="50b11-362">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)]
 [!code-vb[System.Threading.Monitor.TryEnter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="50b11-363">
          <paramref name="obj" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-363">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="50b11-364"><paramref name="millisecondsTimeout" /> 是负数且不等于 <see cref="F:System.Threading.Timeout.Infinite" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-364"><paramref name="millisecondsTimeout" /> is negative, and not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="50b11-365">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="50b11-365">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="50b11-366">在其上获取锁的对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-366">The object on which to acquire the lock.</span></span></param>
        <param name="timeout"><span data-ttu-id="50b11-367"><see cref="T:System.TimeSpan" />，表示等待锁所需的时间量。</span><span class="sxs-lookup"><span data-stu-id="50b11-367">A <see cref="T:System.TimeSpan" /> representing the amount of time to wait for the lock.</span></span> <span data-ttu-id="50b11-368">值为 -1 毫秒表示指定无限期等待。</span><span class="sxs-lookup"><span data-stu-id="50b11-368">A value of -1 millisecond specifies an infinite wait.</span></span></param>
        <summary><span data-ttu-id="50b11-369">在指定的时间内尝试获取指定对象上的排他锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-369">Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.</span></span></summary>
        <returns><span data-ttu-id="50b11-370">如果当前线程获取该锁，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-370"><see langword="true" /> if the current thread acquires the lock; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50b11-371">如果 `timeout` 参数的值转换为毫秒等于-1，则此方法等效于 <xref:System.Threading.Monitor.Enter%2A>。</span><span class="sxs-lookup"><span data-stu-id="50b11-371">If the value of the `timeout` parameter converted to milliseconds equals -1, this method is equivalent to <xref:System.Threading.Monitor.Enter%2A>.</span></span> <span data-ttu-id="50b11-372">如果 `timeout` 的值等于0，则此方法等效于 <xref:System.Threading.Monitor.TryEnter%2A>。</span><span class="sxs-lookup"><span data-stu-id="50b11-372">If the value of `timeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="50b11-373">使用 <xref:System.Threading.Monitor> 锁定对象（即引用类型），而不是值类型。</span><span class="sxs-lookup"><span data-stu-id="50b11-373">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="50b11-374">有关详细信息，请参阅 <xref:System.Threading.Monitor> 类主题。</span><span class="sxs-lookup"><span data-stu-id="50b11-374">For details, see the <xref:System.Threading.Monitor> class topic.</span></span>  
  
 <span data-ttu-id="50b11-375">若要确保线程不输入临界区，应检查方法的返回值，并仅在关键部分中执行代码，前提是该方法的返回值为 `true`。</span><span class="sxs-lookup"><span data-stu-id="50b11-375">To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`.</span></span> <span data-ttu-id="50b11-376">下面的代码段显示了用于调用此方法的模式。</span><span class="sxs-lookup"><span data-stu-id="50b11-376">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="50b11-377">请注意，应在 `finally` 块中调用 <xref:System.Threading.Monitor.Exit%2A>，以确保调用线程在发生异常的情况下释放其对临界区的锁定。</span><span class="sxs-lookup"><span data-stu-id="50b11-377">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)]
 [!code-vb[System.Threading.Monitor.TryEnter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="50b11-378">
          <paramref name="obj" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-378">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="50b11-379"><paramref name="timeout" /> 的值（以毫秒计）为负数且不等于 <see cref="F:System.Threading.Timeout.Infinite" />（-1 毫秒），或者大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-379">The value of <paramref name="timeout" /> in milliseconds is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="50b11-380">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="50b11-380">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, int millisecondsTimeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int * bool -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="50b11-381">在其上获取锁的对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-381">The object on which to acquire the lock.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="50b11-382">等待锁所需的毫秒数。</span><span class="sxs-lookup"><span data-stu-id="50b11-382">The number of milliseconds to wait for the lock.</span></span></param>
        <param name="lockTaken"><span data-ttu-id="50b11-383">尝试获取锁的结果，通过引用传递。</span><span class="sxs-lookup"><span data-stu-id="50b11-383">The result of the attempt to acquire the lock, passed by reference.</span></span> <span data-ttu-id="50b11-384">输入必须为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-384">The input must be <see langword="false" />.</span></span> <span data-ttu-id="50b11-385">如果已获取锁，则输出为 <see langword="true" />；否则输出为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-385">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span></span> <span data-ttu-id="50b11-386">即使在尝试获取锁的过程中发生异常，也会设置输出。</span><span class="sxs-lookup"><span data-stu-id="50b11-386">The output is set even if an exception occurs during the attempt to acquire the lock.</span></span></param>
        <summary><span data-ttu-id="50b11-387">在指定的毫秒数内尝试获取指定对象上的排他锁，并自动设置一个值，指示是否获取了该锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-387">Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50b11-388">如果 `millisecondsTimeout` 参数等于 <xref:System.Threading.Timeout.Infinite>，则此方法等效于 <xref:System.Threading.Monitor.Enter%28System.Object%29>。</span><span class="sxs-lookup"><span data-stu-id="50b11-388">If the `millisecondsTimeout` parameter equals <xref:System.Threading.Timeout.Infinite>, this method is equivalent to <xref:System.Threading.Monitor.Enter%28System.Object%29>.</span></span> <span data-ttu-id="50b11-389">如果 `millisecondsTimeout` 等于0，则此方法等效于 <xref:System.Threading.Monitor.TryEnter%28System.Object%29>。</span><span class="sxs-lookup"><span data-stu-id="50b11-389">If `millisecondsTimeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.</span></span>  
  
 <span data-ttu-id="50b11-390">如果由于引发了异常而未获取锁，则在此方法结束后 `false` 为 `lockTaken` 参数指定的变量。</span><span class="sxs-lookup"><span data-stu-id="50b11-390">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="50b11-391">这使程序可以确定是否有必要释放该锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-391">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="50b11-392">使用 <xref:System.Threading.Monitor> 锁定对象（即引用类型），而不是值类型。</span><span class="sxs-lookup"><span data-stu-id="50b11-392">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="50b11-393">有关详细信息，请参阅 <xref:System.Threading.Monitor> 类主题。</span><span class="sxs-lookup"><span data-stu-id="50b11-393">For more information, see the <xref:System.Threading.Monitor> class topic.</span></span>  
  
 <span data-ttu-id="50b11-394">若要确保线程不输入临界区，应检查 `lockTaken` 的值，并仅在临界区中执行代码，前提是 `true`其值。</span><span class="sxs-lookup"><span data-stu-id="50b11-394">To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`.</span></span> <span data-ttu-id="50b11-395">下面的代码段显示了用于调用此方法的模式。</span><span class="sxs-lookup"><span data-stu-id="50b11-395">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="50b11-396">请注意，应在 `finally` 块中调用 <xref:System.Threading.Monitor.Exit%2A>，以确保调用线程在发生异常的情况下释放其对临界区的锁定。</span><span class="sxs-lookup"><span data-stu-id="50b11-396">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)]
 [!code-vb[System.Threading.Monitor.TryEnter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)]  
  
   
  
## Examples  
 <span data-ttu-id="50b11-397">下面的代码演示使用 <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> 方法重载的基本模式。</span><span class="sxs-lookup"><span data-stu-id="50b11-397">The following code shows the basic pattern for using the <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> method overload.</span></span> <span data-ttu-id="50b11-398">此重载始终设置传递到 `ref` 参数的变量的值（`ByRef` Visual Basic） `lockTaken`，即使该方法引发异常，因此该变量的值是测试是否必须释放该锁的可靠方法。</span><span class="sxs-lookup"><span data-stu-id="50b11-398">This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Enter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#4)]
 [!code-vb[System.Threading.Monitor.Enter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="50b11-399"><paramref name="lockTaken" /> 的输入为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-399">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="50b11-400">
          <paramref name="obj" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-400">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="50b11-401"><paramref name="millisecondsTimeout" /> 是负数且不等于 <see cref="F:System.Threading.Timeout.Infinite" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-401"><paramref name="millisecondsTimeout" /> is negative, and not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, TimeSpan timeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan * bool -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, timeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="50b11-402">在其上获取锁的对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-402">The object on which to acquire the lock.</span></span></param>
        <param name="timeout"><span data-ttu-id="50b11-403">用于等待锁的时间。</span><span class="sxs-lookup"><span data-stu-id="50b11-403">The amount of time to wait for the lock.</span></span> <span data-ttu-id="50b11-404">值为 -1 毫秒表示指定无限期等待。</span><span class="sxs-lookup"><span data-stu-id="50b11-404">A value of -1 millisecond specifies an infinite wait.</span></span></param>
        <param name="lockTaken"><span data-ttu-id="50b11-405">尝试获取锁的结果，通过引用传递。</span><span class="sxs-lookup"><span data-stu-id="50b11-405">The result of the attempt to acquire the lock, passed by reference.</span></span> <span data-ttu-id="50b11-406">输入必须为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-406">The input must be <see langword="false" />.</span></span> <span data-ttu-id="50b11-407">如果已获取锁，则输出为 <see langword="true" />；否则输出为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-407">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span></span> <span data-ttu-id="50b11-408">即使在尝试获取锁的过程中发生异常，也会设置输出。</span><span class="sxs-lookup"><span data-stu-id="50b11-408">The output is set even if an exception occurs during the attempt to acquire the lock.</span></span></param>
        <summary><span data-ttu-id="50b11-409">在指定的一段时间内尝试获取指定对象上的排他锁，并自动设置一个值，指示是否获得了该锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-409">Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50b11-410">如果 `timeout` 参数的值转换为毫秒等于-1，则此方法等效于 <xref:System.Threading.Monitor.Enter%28System.Object%29>。</span><span class="sxs-lookup"><span data-stu-id="50b11-410">If the value of the `timeout` parameter converted to milliseconds equals -1, this method is equivalent to <xref:System.Threading.Monitor.Enter%28System.Object%29>.</span></span> <span data-ttu-id="50b11-411">如果 `timeout` 的值等于0，则此方法等效于 <xref:System.Threading.Monitor.TryEnter%28System.Object%29>。</span><span class="sxs-lookup"><span data-stu-id="50b11-411">If the value of `timeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.</span></span>  
  
 <span data-ttu-id="50b11-412">如果由于引发了异常而未获取锁，则在此方法结束后 `false` 为 `lockTaken` 参数指定的变量。</span><span class="sxs-lookup"><span data-stu-id="50b11-412">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="50b11-413">这使程序可以确定是否有必要释放该锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-413">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="50b11-414">使用 <xref:System.Threading.Monitor> 锁定对象（即引用类型），而不是值类型。</span><span class="sxs-lookup"><span data-stu-id="50b11-414">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="50b11-415">有关详细信息，请参阅 <xref:System.Threading.Monitor> 类主题。</span><span class="sxs-lookup"><span data-stu-id="50b11-415">For more information, see the <xref:System.Threading.Monitor> class topic.</span></span>  
  
 <span data-ttu-id="50b11-416">若要确保线程不输入临界区，应检查 `lockTaken` 的值，并仅在临界区中执行代码，前提是 `true`其值。</span><span class="sxs-lookup"><span data-stu-id="50b11-416">To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`.</span></span> <span data-ttu-id="50b11-417">下面的代码段显示了用于调用此方法的模式。</span><span class="sxs-lookup"><span data-stu-id="50b11-417">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="50b11-418">请注意，应在 `finally` 块中调用 <xref:System.Threading.Monitor.Exit%2A>，以确保调用线程在发生异常的情况下释放其对临界区的锁定。</span><span class="sxs-lookup"><span data-stu-id="50b11-418">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)]
 [!code-vb[System.Threading.Monitor.TryEnter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="50b11-419"><paramref name="lockTaken" /> 的输入为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-419">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="50b11-420">
          <paramref name="obj" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-420">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="50b11-421"><paramref name="timeout" /> 的值（以毫秒计）为负数且不等于 <see cref="F:System.Threading.Timeout.Infinite" />（-1 毫秒），或者大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-421">The value of <paramref name="timeout" /> in milliseconds is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="50b11-422">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="50b11-422">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="50b11-423">释放对象上的锁并阻止当前线程，直到它重新获取该锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-423">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Wait : obj -&gt; bool" Usage="System.Threading.Monitor.Wait obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="50b11-424">要在其上等待的对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-424">The object on which to wait.</span></span></param>
        <summary><span data-ttu-id="50b11-425">释放对象上的锁并阻止当前线程，直到它重新获取该锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-425">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span></summary>
        <returns><span data-ttu-id="50b11-426">如果调用由于调用方重新获取了指定对象的锁而返回，则为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-426"><see langword="true" /> if the call returned because the caller reacquired the lock for the specified object.</span></span> <span data-ttu-id="50b11-427">如果未重新获取该锁，则此方法不会返回。</span><span class="sxs-lookup"><span data-stu-id="50b11-427">This method does not return if the lock is not reacquired.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50b11-428">当前拥有指定对象的锁的线程调用此方法以释放该对象，以便其他线程可以访问它。</span><span class="sxs-lookup"><span data-stu-id="50b11-428">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="50b11-429">等待重新获取该锁时，调用方被阻止。</span><span class="sxs-lookup"><span data-stu-id="50b11-429">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="50b11-430">当调用方需要等待作为其他线程操作的结果而发生的状态更改时，将调用此方法。</span><span class="sxs-lookup"><span data-stu-id="50b11-430">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="50b11-431">当线程调用 `Wait`时，它会释放对象的锁，并进入该对象的等待队列。</span><span class="sxs-lookup"><span data-stu-id="50b11-431">When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue.</span></span> <span data-ttu-id="50b11-432">对象准备就绪的队列中的下一个线程（如果有）将获取该锁并独占使用该对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-432">The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</span></span> <span data-ttu-id="50b11-433">调用 `Wait` 的所有线程将保留在等待队列中，直到接收到由锁的所有者发送 <xref:System.Threading.Monitor.Pulse%2A> 或 <xref:System.Threading.Monitor.PulseAll%2A>发出的信号。</span><span class="sxs-lookup"><span data-stu-id="50b11-433">All threads that call `Wait` remain in the waiting queue until they receive a signal from <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>, sent by the owner of the lock.</span></span> <span data-ttu-id="50b11-434">如果发送 `Pulse`，则只会影响正在等待的队列头中的线程。</span><span class="sxs-lookup"><span data-stu-id="50b11-434">If `Pulse` is sent, only the thread at the head of the waiting queue is affected.</span></span> <span data-ttu-id="50b11-435">如果发送 `PulseAll`，则会影响正在等待对象的所有线程。</span><span class="sxs-lookup"><span data-stu-id="50b11-435">If `PulseAll` is sent, all threads that are waiting for the object are affected.</span></span> <span data-ttu-id="50b11-436">收到信号后，一个或多个线程将离开等待队列，并进入就绪队列。</span><span class="sxs-lookup"><span data-stu-id="50b11-436">When the signal is received, one or more threads leave the waiting queue and enter the ready queue.</span></span> <span data-ttu-id="50b11-437">允许队列中的线程重新获取该锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-437">A thread in the ready queue is permitted to reacquire the lock.</span></span>  
  
 <span data-ttu-id="50b11-438">当调用线程重新获取该域对象上的锁时，此方法返回。</span><span class="sxs-lookup"><span data-stu-id="50b11-438">This method returns when the calling thread reacquires the lock on the object.</span></span> <span data-ttu-id="50b11-439">请注意，如果锁定的持有者未调用 `Pulse` 或 `PulseAll`，则此方法会无限期阻止。</span><span class="sxs-lookup"><span data-stu-id="50b11-439">Note that this method blocks indefinitely if the holder of the lock does not call `Pulse` or `PulseAll`.</span></span>  
  
 <span data-ttu-id="50b11-440">无论为指定的对象调用了多少次 <xref:System.Threading.Monitor.Enter%2A>，调用方都将执行一次 `Wait`。</span><span class="sxs-lookup"><span data-stu-id="50b11-440">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="50b11-441">从概念上讲，`Wait` 方法存储调用方 `Enter` 对象调用的次数，并根据需要多次调用 `Exit` 以完全释放锁定的对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-441">Conceptually, the `Wait` method stores the number of times the caller invoked `Enter` on the object and invokes `Exit` as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="50b11-442">然后，调用方在等待重新获取对象时阻止。</span><span class="sxs-lookup"><span data-stu-id="50b11-442">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="50b11-443">当调用方重新获取该域锁定时，系统会根据需要多次调用 `Enter` 以还原调用方的已保存 `Enter` 计数。</span><span class="sxs-lookup"><span data-stu-id="50b11-443">When the caller reacquires the lock, the system calls `Enter` as many times as necessary to restore the saved `Enter` count for the caller.</span></span> <span data-ttu-id="50b11-444">调用 `Wait` 仅释放指定对象的锁;如果调用方是其他对象的锁的所有者，则不会释放这些锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-444">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
 <span data-ttu-id="50b11-445">请注意，同步对象包含多个引用，包括对当前持有锁的线程的引用、对就绪队列的引用、包含准备好获取锁的线程的引用以及对等待队列的引用（其中包含等待对象状态更改通知的线程）。</span><span class="sxs-lookup"><span data-stu-id="50b11-445">Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="50b11-446">必须从同步的代码块内调用 <xref:System.Threading.Monitor.Pulse%2A>、<xref:System.Threading.Monitor.PulseAll%2A>和 `Wait` 方法。</span><span class="sxs-lookup"><span data-stu-id="50b11-446">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="50b11-447"><xref:System.Threading.Monitor.Pulse%2A> 方法的备注说明了在没有线程等待时调用 <xref:System.Threading.Monitor.Pulse%2A> 会发生的情况。</span><span class="sxs-lookup"><span data-stu-id="50b11-447">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="50b11-448">
          <paramref name="obj" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-448">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="50b11-449">调用线程不拥有指定对象的锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-449">The calling thread does not own the lock for the specified object.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="50b11-450">调用 <see langword="Wait" /> 的线程稍后从等待状态中断。</span><span class="sxs-lookup"><span data-stu-id="50b11-450">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span></span> <span data-ttu-id="50b11-451">另一线程调用此线程的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法时将发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="50b11-451">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="50b11-452">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="50b11-452">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="50b11-453">要在其上等待的对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-453">The object on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="50b11-454">线程进入就绪队列之前等待的毫秒数。</span><span class="sxs-lookup"><span data-stu-id="50b11-454">The number of milliseconds to wait before the thread enters the ready queue.</span></span></param>
        <summary><span data-ttu-id="50b11-455">释放对象上的锁并阻止当前线程，直到它重新获取该锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-455">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span> <span data-ttu-id="50b11-456">如果已用指定的超时时间间隔，则线程进入就绪队列。</span><span class="sxs-lookup"><span data-stu-id="50b11-456">If the specified time-out interval elapses, the thread enters the ready queue.</span></span></summary>
        <returns><span data-ttu-id="50b11-457">如果在指定的时间过期之前重新获取该锁，则为 <see langword="true" />；如果在指定的时间过期之后重新获取该锁，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-457"><see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span></span> <span data-ttu-id="50b11-458">此方法只有在重新获取该锁后才会返回。</span><span class="sxs-lookup"><span data-stu-id="50b11-458">The method does not return until the lock is reacquired.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50b11-459">此方法不返回，直到它重新获取该域 `obj` 参数的排他锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-459">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="50b11-460">当前拥有指定对象的锁的线程调用此方法以释放该对象，以便其他线程可以访问它。</span><span class="sxs-lookup"><span data-stu-id="50b11-460">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="50b11-461">等待重新获取该锁时，调用方被阻止。</span><span class="sxs-lookup"><span data-stu-id="50b11-461">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="50b11-462">当调用方需要等待作为其他线程操作的结果而发生的状态更改时，将调用此方法。</span><span class="sxs-lookup"><span data-stu-id="50b11-462">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="50b11-463">超时可确保当另一个线程释放该锁，而不先调用 <xref:System.Threading.Monitor.Pulse%2A> 或 <xref:System.Threading.Monitor.PulseAll%2A> 方法时，当前线程不会无限期地阻止。</span><span class="sxs-lookup"><span data-stu-id="50b11-463">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="50b11-464">它还会将线程移动到就绪队列，绕过等待队列中的其他线程，以便它可以更快地重新获取锁定。</span><span class="sxs-lookup"><span data-stu-id="50b11-464">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="50b11-465">线程可以测试 <xref:System.Threading.Monitor.Wait%2A> 方法的返回值，以确定是否在超时前重新获取该锁。线程可以计算导致其进入等待状态的条件，并在必要时再次调用 <xref:System.Threading.Monitor.Wait%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="50b11-465">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="50b11-466">当线程调用 `Wait`时，它会释放对象的锁，并进入该对象的等待队列。</span><span class="sxs-lookup"><span data-stu-id="50b11-466">When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue.</span></span> <span data-ttu-id="50b11-467">对象准备就绪的队列中的下一个线程（如果有）将获取该锁并独占使用该对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-467">The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</span></span> <span data-ttu-id="50b11-468">调用 `Wait` 的线程将保留在等待队列中，直到持有锁的线程调用 <xref:System.Threading.Monitor.PulseAll%2A>，或者它是队列中的下一线程，并且持有锁的线程调用 <xref:System.Threading.Monitor.Pulse%2A>。</span><span class="sxs-lookup"><span data-stu-id="50b11-468">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="50b11-469">但是，如果在另一个线程调用此对象的 <xref:System.Threading.Monitor.Pulse%2A> 或 <xref:System.Threading.Monitor.PulseAll%2A> 方法之前 `millisecondsTimeout` 结束，则原始线程将移到就绪队列，以便重新获得锁定。</span><span class="sxs-lookup"><span data-stu-id="50b11-469">However, if `millisecondsTimeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="50b11-470">如果为 `millisecondsTimeout` 参数指定了 <xref:System.Threading.Timeout.Infinite>，则此方法会无限期阻止，除非锁的持有者调用 <xref:System.Threading.Monitor.Pulse%2A> 或 <xref:System.Threading.Monitor.PulseAll%2A>。</span><span class="sxs-lookup"><span data-stu-id="50b11-470">If <xref:System.Threading.Timeout.Infinite> is specified for the `millisecondsTimeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="50b11-471">如果 `millisecondsTimeout` 等于0，则调用 `Wait` 的线程将释放该锁，然后立即进入就绪队列以便重新获取该锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-471">If `millisecondsTimeout` equals 0, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="50b11-472">无论为指定的对象调用了多少次 <xref:System.Threading.Monitor.Enter%2A>，调用方都将执行一次 `Wait`。</span><span class="sxs-lookup"><span data-stu-id="50b11-472">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="50b11-473">从概念上讲，`Wait` 方法存储调用方 <xref:System.Threading.Monitor.Enter%2A> 对象调用的次数，并根据需要多次调用 <xref:System.Threading.Monitor.Exit%2A> 以完全释放锁定的对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-473">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="50b11-474">然后，调用方在等待重新获取对象时阻止。</span><span class="sxs-lookup"><span data-stu-id="50b11-474">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="50b11-475">当调用方重新获取该域锁定时，系统会根据需要多次调用 <xref:System.Threading.Monitor.Enter%2A> 以还原调用方的已保存 <xref:System.Threading.Monitor.Enter%2A> 计数。</span><span class="sxs-lookup"><span data-stu-id="50b11-475">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="50b11-476">调用 `Wait` 仅释放指定对象的锁;如果调用方是其他对象的锁的所有者，则不会释放这些锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-476">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="50b11-477">同步的对象包含多个引用，包括对当前持有锁的线程的引用、对就绪队列的引用、包含准备好获取锁的线程的引用以及对等待队列的引用（其中包含等待对象状态更改通知的线程）。</span><span class="sxs-lookup"><span data-stu-id="50b11-477">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="50b11-478">必须从同步的代码块内调用 <xref:System.Threading.Monitor.Pulse%2A>、<xref:System.Threading.Monitor.PulseAll%2A>和 `Wait` 方法。</span><span class="sxs-lookup"><span data-stu-id="50b11-478">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="50b11-479"><xref:System.Threading.Monitor.Pulse%2A> 方法的备注说明了在没有线程等待时调用 <xref:System.Threading.Monitor.Pulse%2A> 会发生的情况。</span><span class="sxs-lookup"><span data-stu-id="50b11-479">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="50b11-480">
          <paramref name="obj" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-480">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="50b11-481">调用线程不拥有指定对象的锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-481">The calling thread does not own the lock for the specified object.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="50b11-482">调用 <see langword="Wait" /> 的线程稍后从等待状态中断。</span><span class="sxs-lookup"><span data-stu-id="50b11-482">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span></span> <span data-ttu-id="50b11-483">另一线程调用此线程的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法时将发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="50b11-483">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="50b11-484"><paramref name="millisecondsTimeout" /> 参数值为负且不等于 <see cref="F:System.Threading.Timeout.Infinite" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-484">The value of the <paramref name="millisecondsTimeout" /> parameter is negative, and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="50b11-485">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="50b11-485">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="50b11-486">要在其上等待的对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-486">The object on which to wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="50b11-487"><see cref="T:System.TimeSpan" />，表示线程进入就绪队列之前等待的时间量。</span><span class="sxs-lookup"><span data-stu-id="50b11-487">A <see cref="T:System.TimeSpan" /> representing the amount of time to wait before the thread enters the ready queue.</span></span></param>
        <summary><span data-ttu-id="50b11-488">释放对象上的锁并阻止当前线程，直到它重新获取该锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-488">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span> <span data-ttu-id="50b11-489">如果已用指定的超时时间间隔，则线程进入就绪队列。</span><span class="sxs-lookup"><span data-stu-id="50b11-489">If the specified time-out interval elapses, the thread enters the ready queue.</span></span></summary>
        <returns><span data-ttu-id="50b11-490">如果在指定的时间过期之前重新获取该锁，则为 <see langword="true" />；如果在指定的时间过期之后重新获取该锁，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-490"><see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span></span> <span data-ttu-id="50b11-491">此方法只有在重新获取该锁后才会返回。</span><span class="sxs-lookup"><span data-stu-id="50b11-491">The method does not return until the lock is reacquired.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50b11-492">此方法不返回，直到它重新获取该域 `obj` 参数的排他锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-492">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="50b11-493">当前拥有指定对象的锁的线程调用此方法以释放该对象，以便其他线程可以访问它。</span><span class="sxs-lookup"><span data-stu-id="50b11-493">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="50b11-494">等待重新获取该锁时，调用方被阻止。</span><span class="sxs-lookup"><span data-stu-id="50b11-494">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="50b11-495">当调用方需要等待作为其他线程操作的结果而发生的状态更改时，将调用此方法。</span><span class="sxs-lookup"><span data-stu-id="50b11-495">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="50b11-496">超时可确保当另一个线程释放该锁，而不先调用 <xref:System.Threading.Monitor.Pulse%2A> 或 <xref:System.Threading.Monitor.PulseAll%2A> 方法时，当前线程不会无限期地阻止。</span><span class="sxs-lookup"><span data-stu-id="50b11-496">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="50b11-497">它还会将线程移动到就绪队列，绕过等待队列中的其他线程，以便它可以更快地重新获取锁定。</span><span class="sxs-lookup"><span data-stu-id="50b11-497">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="50b11-498">线程可以测试 <xref:System.Threading.Monitor.Wait%2A> 方法的返回值，以确定是否在超时前重新获取该锁。线程可以计算导致其进入等待状态的条件，并在必要时再次调用 <xref:System.Threading.Monitor.Wait%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="50b11-498">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="50b11-499">当线程调用 `Wait`时，它会释放对象的锁，并进入该对象的等待队列。</span><span class="sxs-lookup"><span data-stu-id="50b11-499">When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue.</span></span> <span data-ttu-id="50b11-500">对象准备就绪的队列中的下一个线程（如果有）将获取该锁并独占使用该对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-500">The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</span></span> <span data-ttu-id="50b11-501">调用 `Wait` 的线程将保留在等待队列中，直到持有锁的线程调用 <xref:System.Threading.Monitor.PulseAll%2A>，或者它是队列中的下一线程，并且持有锁的线程调用 <xref:System.Threading.Monitor.Pulse%2A>。</span><span class="sxs-lookup"><span data-stu-id="50b11-501">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="50b11-502">但是，如果在另一个线程调用此对象的 <xref:System.Threading.Monitor.Pulse%2A> 或 <xref:System.Threading.Monitor.PulseAll%2A> 方法之前 `timeout` 结束，则原始线程将移到就绪队列，以便重新获得锁定。</span><span class="sxs-lookup"><span data-stu-id="50b11-502">However, if `timeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="50b11-503">如果为 `timeout` 参数指定了表示-1 毫秒的 <xref:System.TimeSpan>，则此方法会无限期阻止，除非锁的持有者调用 <xref:System.Threading.Monitor.Pulse%2A> 或 <xref:System.Threading.Monitor.PulseAll%2A>。</span><span class="sxs-lookup"><span data-stu-id="50b11-503">If a <xref:System.TimeSpan> representing -1 millisecond is specified for the `timeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="50b11-504">如果 `timeout` 为0毫秒，则调用 `Wait` 的线程将释放该锁，然后立即进入就绪队列，以便重新获取该锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-504">If `timeout` is 0 milliseconds, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="50b11-505">无论为指定的对象调用了多少次 <xref:System.Threading.Monitor.Enter%2A>，调用方都将执行一次 `Wait`。</span><span class="sxs-lookup"><span data-stu-id="50b11-505">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="50b11-506">从概念上讲，`Wait` 方法存储调用方 <xref:System.Threading.Monitor.Enter%2A> 对象调用的次数，并根据需要多次调用 <xref:System.Threading.Monitor.Exit%2A> 以完全释放锁定的对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-506">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="50b11-507">然后，调用方在等待重新获取对象时阻止。</span><span class="sxs-lookup"><span data-stu-id="50b11-507">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="50b11-508">当调用方重新获取该域锁定时，系统会根据需要多次调用 <xref:System.Threading.Monitor.Enter%2A> 以还原调用方的已保存 <xref:System.Threading.Monitor.Enter%2A> 计数。</span><span class="sxs-lookup"><span data-stu-id="50b11-508">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="50b11-509">调用 `Wait` 仅释放指定对象的锁;如果调用方是其他对象的锁的所有者，则不会释放这些锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-509">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="50b11-510">同步的对象包含多个引用，包括对当前持有锁的线程的引用、对就绪队列的引用、包含准备好获取锁的线程的引用以及对等待队列的引用（其中包含等待对象状态更改通知的线程）。</span><span class="sxs-lookup"><span data-stu-id="50b11-510">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="50b11-511">必须从同步的代码块内调用 <xref:System.Threading.Monitor.Pulse%2A>、<xref:System.Threading.Monitor.PulseAll%2A>和 `Wait` 方法。</span><span class="sxs-lookup"><span data-stu-id="50b11-511">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="50b11-512"><xref:System.Threading.Monitor.Pulse%2A> 方法的备注说明了在没有线程等待时调用 <xref:System.Threading.Monitor.Pulse%2A> 会发生的情况。</span><span class="sxs-lookup"><span data-stu-id="50b11-512">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="50b11-513">
          <paramref name="obj" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-513">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="50b11-514">调用线程不拥有指定对象的锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-514">The calling thread does not own the lock for the specified object.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="50b11-515">调用 <see langword="Wait" /> 的线程稍后从等待状态中断。</span><span class="sxs-lookup"><span data-stu-id="50b11-515">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span></span> <span data-ttu-id="50b11-516">另一线程调用此线程的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法时将发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="50b11-516">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="50b11-517"><paramref name="timeout" /> 参数的值（以毫秒计）为负数且不表示 <see cref="F:System.Threading.Timeout.Infinite" />（-1 毫秒），或者大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-517">The value of the <paramref name="timeout" /> parameter in milliseconds is negative and does not represent <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="50b11-518">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="50b11-518">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="50b11-519">要在其上等待的对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-519">The object on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="50b11-520">线程进入就绪队列之前等待的毫秒数。</span><span class="sxs-lookup"><span data-stu-id="50b11-520">The number of milliseconds to wait before the thread enters the ready queue.</span></span></param>
        <param name="exitContext"><span data-ttu-id="50b11-521">如果在等待前退出并重新获取上下文的同步域（如果在同步上下文中），则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-521"><see langword="true" /> to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="50b11-522">释放对象上的锁并阻止当前线程，直到它重新获取该锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-522">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span> <span data-ttu-id="50b11-523">如果已用指定的超时时间间隔，则线程进入就绪队列。</span><span class="sxs-lookup"><span data-stu-id="50b11-523">If the specified time-out interval elapses, the thread enters the ready queue.</span></span> <span data-ttu-id="50b11-524">此方法还指定是否在等待之前退出上下文的同步域（如果在同步上下文中）然后重新获取该同步域。</span><span class="sxs-lookup"><span data-stu-id="50b11-524">This method also specifies whether the synchronization domain for the context (if in a synchronized context) is exited before the wait and reacquired afterward.</span></span></summary>
        <returns><span data-ttu-id="50b11-525">如果在指定的时间过期之前重新获取该锁，则为 <see langword="true" />；如果在指定的时间过期之后重新获取该锁，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-525"><see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span></span> <span data-ttu-id="50b11-526">此方法只有在重新获取该锁后才会返回。</span><span class="sxs-lookup"><span data-stu-id="50b11-526">The method does not return until the lock is reacquired.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50b11-527">此方法不返回，直到它重新获取该域 `obj` 参数的排他锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-527">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="50b11-528">当前拥有指定对象的锁的线程调用此方法以释放该对象，以便其他线程可以访问它。</span><span class="sxs-lookup"><span data-stu-id="50b11-528">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="50b11-529">等待重新获取该锁时，调用方被阻止。</span><span class="sxs-lookup"><span data-stu-id="50b11-529">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="50b11-530">当调用方需要等待作为其他线程操作的结果而发生的状态更改时，将调用此方法。</span><span class="sxs-lookup"><span data-stu-id="50b11-530">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="50b11-531">超时可确保当另一个线程释放该锁，而不先调用 <xref:System.Threading.Monitor.Pulse%2A> 或 <xref:System.Threading.Monitor.PulseAll%2A> 方法时，当前线程不会无限期地阻止。</span><span class="sxs-lookup"><span data-stu-id="50b11-531">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="50b11-532">它还会将线程移动到就绪队列，绕过等待队列中的其他线程，以便它可以更快地重新获取锁定。</span><span class="sxs-lookup"><span data-stu-id="50b11-532">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="50b11-533">线程可以测试 <xref:System.Threading.Monitor.Wait%2A> 方法的返回值，以确定是否在超时前重新获取该锁。线程可以计算导致其进入等待状态的条件，并在必要时再次调用 <xref:System.Threading.Monitor.Wait%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="50b11-533">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="50b11-534">当线程调用 `Wait`时，它会释放该锁并进入等待队列。</span><span class="sxs-lookup"><span data-stu-id="50b11-534">When a thread calls `Wait`, it releases the lock and enters the waiting queue.</span></span> <span data-ttu-id="50b11-535">此时，可以使用就绪队列中的下一个线程（如果有）来控制该锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-535">At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock.</span></span> <span data-ttu-id="50b11-536">调用 `Wait` 的线程将保留在等待队列中，直到持有锁的线程调用 <xref:System.Threading.Monitor.PulseAll%2A>，或者它是队列中的下一线程，并且持有锁的线程调用 <xref:System.Threading.Monitor.Pulse%2A>。</span><span class="sxs-lookup"><span data-stu-id="50b11-536">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="50b11-537">但是，如果在另一个线程调用此对象的 <xref:System.Threading.Monitor.Pulse%2A> 或 <xref:System.Threading.Monitor.PulseAll%2A> 方法之前 `millisecondsTimeout` 结束，则原始线程将移到就绪队列，以便重新获得锁定。</span><span class="sxs-lookup"><span data-stu-id="50b11-537">However, if `millisecondsTimeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="50b11-538">如果为 `millisecondsTimeout` 参数指定了 <xref:System.Threading.Timeout.Infinite>，则此方法会无限期阻止，除非锁的持有者调用 <xref:System.Threading.Monitor.Pulse%2A> 或 <xref:System.Threading.Monitor.PulseAll%2A>。</span><span class="sxs-lookup"><span data-stu-id="50b11-538">If <xref:System.Threading.Timeout.Infinite> is specified for the `millisecondsTimeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="50b11-539">如果 `millisecondsTimeout` 等于0，则调用 `Wait` 的线程将释放该锁，然后立即进入就绪队列以便重新获取该锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-539">If `millisecondsTimeout` equals 0, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="50b11-540">无论为指定的对象调用了多少次 <xref:System.Threading.Monitor.Enter%2A>，调用方都将执行一次 `Wait`。</span><span class="sxs-lookup"><span data-stu-id="50b11-540">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="50b11-541">从概念上讲，`Wait` 方法存储调用方 <xref:System.Threading.Monitor.Enter%2A> 对象调用的次数，并根据需要多次调用 <xref:System.Threading.Monitor.Exit%2A> 以完全释放锁定的对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-541">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="50b11-542">然后，调用方在等待重新获取对象时阻止。</span><span class="sxs-lookup"><span data-stu-id="50b11-542">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="50b11-543">当调用方重新获取该域锁定时，系统会根据需要多次调用 <xref:System.Threading.Monitor.Enter%2A> 以还原调用方的已保存 <xref:System.Threading.Monitor.Enter%2A> 计数。</span><span class="sxs-lookup"><span data-stu-id="50b11-543">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="50b11-544">调用 `Wait` 仅释放指定对象的锁;如果调用方是其他对象的锁的所有者，则不会释放这些锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-544">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="50b11-545">同步的对象包含多个引用，包括对当前持有锁的线程的引用、对就绪队列的引用、包含准备好获取锁的线程的引用以及对等待队列的引用（其中包含等待对象状态更改通知的线程）。</span><span class="sxs-lookup"><span data-stu-id="50b11-545">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="50b11-546">必须从同步的代码块内调用 <xref:System.Threading.Monitor.Pulse%2A>、<xref:System.Threading.Monitor.PulseAll%2A>和 `Wait` 方法。</span><span class="sxs-lookup"><span data-stu-id="50b11-546">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="50b11-547"><xref:System.Threading.Monitor.Pulse%2A> 方法的备注说明了在没有线程等待时调用 <xref:System.Threading.Monitor.Pulse%2A> 会发生的情况。</span><span class="sxs-lookup"><span data-stu-id="50b11-547">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="50b11-548">有关退出上下文的说明</span><span class="sxs-lookup"><span data-stu-id="50b11-548">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="50b11-549">除非从非默认托管上下文内调用 <xref:System.Threading.Monitor.Wait%2A> 方法，否则`exitContext` 参数不起作用。</span><span class="sxs-lookup"><span data-stu-id="50b11-549">The`exitContext` parameter has no effect unless the <xref:System.Threading.Monitor.Wait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="50b11-550">如果线程位于从 <xref:System.ContextBoundObject>派生的类的实例中，则会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="50b11-550">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="50b11-551">即使当前正在对不是从 <xref:System.ContextBoundObject>派生的类（如 <xref:System.String>）执行方法，如果 <xref:System.ContextBoundObject> 在当前应用程序域中的堆栈上，也可以在非默认上下文中。</span><span class="sxs-lookup"><span data-stu-id="50b11-551">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="50b11-552">当代码在非默认上下文中执行时，为 `exitContext` 指定 `true` 会导致线程在执行 <xref:System.Threading.Monitor.Wait%2A> 方法之前退出非默认托管上下文（即转换为默认上下文）。</span><span class="sxs-lookup"><span data-stu-id="50b11-552">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.Monitor.Wait%2A> method.</span></span> <span data-ttu-id="50b11-553">此方法在调用 <xref:System.Threading.Monitor.Wait%2A> 方法完成后返回到原始的非默认上下文。</span><span class="sxs-lookup"><span data-stu-id="50b11-553">It returns to the original nondefault context after the call to the <xref:System.Threading.Monitor.Wait%2A> method completes.</span></span>  
  
 <span data-ttu-id="50b11-554">当上下文绑定类应用了 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> 特性时，这会很有用。</span><span class="sxs-lookup"><span data-stu-id="50b11-554">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute applied.</span></span> <span data-ttu-id="50b11-555">在这种情况下，对类成员的所有调用都将自动同步，同步域是类的整个代码正文。</span><span class="sxs-lookup"><span data-stu-id="50b11-555">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="50b11-556">如果成员的调用堆栈中的代码调用 <xref:System.Threading.Monitor.Wait%2A> 方法并指定 `exitContext`的 `true`，则线程将退出同步域，从而允许在对对象的任何成员的调用上被阻止的线程继续。</span><span class="sxs-lookup"><span data-stu-id="50b11-556">If code in the call stack of a member calls the <xref:System.Threading.Monitor.Wait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="50b11-557">当 <xref:System.Threading.Monitor.Wait%2A> 方法返回时，进行调用的线程必须等待重新进入同步域。</span><span class="sxs-lookup"><span data-stu-id="50b11-557">When the <xref:System.Threading.Monitor.Wait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="50b11-558">
          <paramref name="obj" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-558">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="50b11-559"><see langword="Wait" /> 不是从同步的代码块中调用的。</span><span class="sxs-lookup"><span data-stu-id="50b11-559"><see langword="Wait" /> is not invoked from within a synchronized block of code.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="50b11-560">调用 <see langword="Wait" /> 的线程稍后从等待状态中断。</span><span class="sxs-lookup"><span data-stu-id="50b11-560">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span></span> <span data-ttu-id="50b11-561">另一线程调用此线程的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法时将发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="50b11-561">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="50b11-562"><paramref name="millisecondsTimeout" /> 参数值为负且不等于 <see cref="F:System.Threading.Timeout.Infinite" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-562">The value of the <paramref name="millisecondsTimeout" /> parameter is negative, and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="50b11-563">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="50b11-563">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="50b11-564">要在其上等待的对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-564">The object on which to wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="50b11-565"><see cref="T:System.TimeSpan" />，表示线程进入就绪队列之前等待的时间量。</span><span class="sxs-lookup"><span data-stu-id="50b11-565">A <see cref="T:System.TimeSpan" /> representing the amount of time to wait before the thread enters the ready queue.</span></span></param>
        <param name="exitContext"><span data-ttu-id="50b11-566">如果在等待前退出并重新获取上下文的同步域（如果在同步上下文中），则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-566"><see langword="true" /> to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="50b11-567">释放对象上的锁并阻止当前线程，直到它重新获取该锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-567">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span> <span data-ttu-id="50b11-568">如果已用指定的超时时间间隔，则线程进入就绪队列。</span><span class="sxs-lookup"><span data-stu-id="50b11-568">If the specified time-out interval elapses, the thread enters the ready queue.</span></span> <span data-ttu-id="50b11-569">可以在等待之前退出同步上下文的同步域，随后重新获取该域。</span><span class="sxs-lookup"><span data-stu-id="50b11-569">Optionally exits the synchronization domain for the synchronized context before the wait and reacquires the domain afterward.</span></span></summary>
        <returns><span data-ttu-id="50b11-570">如果在指定的时间过期之前重新获取该锁，则为 <see langword="true" />；如果在指定的时间过期之后重新获取该锁，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-570"><see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span></span> <span data-ttu-id="50b11-571">此方法只有在重新获取该锁后才会返回。</span><span class="sxs-lookup"><span data-stu-id="50b11-571">The method does not return until the lock is reacquired.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50b11-572">此方法不返回，直到它重新获取该域 `obj` 参数的排他锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-572">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="50b11-573">当前拥有指定对象的锁的线程调用此方法以释放该对象，以便其他线程可以访问它。</span><span class="sxs-lookup"><span data-stu-id="50b11-573">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="50b11-574">等待重新获取该锁时，调用方被阻止。</span><span class="sxs-lookup"><span data-stu-id="50b11-574">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="50b11-575">当调用方需要等待作为其他线程操作的结果而发生的状态更改时，将调用此方法。</span><span class="sxs-lookup"><span data-stu-id="50b11-575">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="50b11-576">超时可确保当另一个线程释放该锁，而不先调用 <xref:System.Threading.Monitor.Pulse%2A> 或 <xref:System.Threading.Monitor.PulseAll%2A> 方法时，当前线程不会无限期地阻止。</span><span class="sxs-lookup"><span data-stu-id="50b11-576">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="50b11-577">它还会将线程移动到就绪队列，绕过等待队列中的其他线程，以便它可以更快地重新获取锁定。</span><span class="sxs-lookup"><span data-stu-id="50b11-577">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="50b11-578">线程可以测试 <xref:System.Threading.Monitor.Wait%2A> 方法的返回值，以确定是否在超时前重新获取该锁。线程可以计算导致其进入等待状态的条件，并在必要时再次调用 <xref:System.Threading.Monitor.Wait%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="50b11-578">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="50b11-579">当线程调用 `Wait`时，它会释放该锁并进入等待队列。</span><span class="sxs-lookup"><span data-stu-id="50b11-579">When a thread calls `Wait`, it releases the lock and enters the waiting queue.</span></span> <span data-ttu-id="50b11-580">此时，可以使用就绪队列中的下一个线程（如果有）来控制该锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-580">At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock.</span></span> <span data-ttu-id="50b11-581">调用 `Wait` 的线程将保留在等待队列中，直到持有锁的线程调用 <xref:System.Threading.Monitor.PulseAll%2A>，或者它是队列中的下一线程，并且持有锁的线程调用 <xref:System.Threading.Monitor.Pulse%2A>。</span><span class="sxs-lookup"><span data-stu-id="50b11-581">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="50b11-582">但是，如果在另一个线程调用此对象的 <xref:System.Threading.Monitor.Pulse%2A> 或 <xref:System.Threading.Monitor.PulseAll%2A> 方法之前经过 `timeout` 毫秒，则原始线程将移到就绪队列，以便重新获得锁定。</span><span class="sxs-lookup"><span data-stu-id="50b11-582">However, if `timeout` milliseconds elapse before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="50b11-583">如果为 `timeout` 参数指定了表示-1 毫秒的 <xref:System.TimeSpan>，则此方法会无限期阻止，除非锁的持有者调用 <xref:System.Threading.Monitor.Pulse%2A> 或 <xref:System.Threading.Monitor.PulseAll%2A>。</span><span class="sxs-lookup"><span data-stu-id="50b11-583">If a <xref:System.TimeSpan> representing -1 millisecond is specified for the `timeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="50b11-584">如果 `timeout` 为0毫秒，则调用 `Wait` 的线程将释放该锁，然后立即进入就绪队列，以便重新获取该锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-584">If `timeout` is 0 milliseconds, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="50b11-585">无论为指定的对象调用了多少次 <xref:System.Threading.Monitor.Enter%2A>，调用方都将执行一次 `Wait`。</span><span class="sxs-lookup"><span data-stu-id="50b11-585">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="50b11-586">从概念上讲，`Wait` 方法存储调用方 <xref:System.Threading.Monitor.Enter%2A> 对象调用的次数，并根据需要多次调用 <xref:System.Threading.Monitor.Exit%2A> 以完全释放锁定的对象。</span><span class="sxs-lookup"><span data-stu-id="50b11-586">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="50b11-587">然后，调用方在等待重新获取对象时阻止。</span><span class="sxs-lookup"><span data-stu-id="50b11-587">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="50b11-588">当调用方重新获取该域锁定时，系统会根据需要多次调用 <xref:System.Threading.Monitor.Enter%2A> 以还原调用方的已保存 <xref:System.Threading.Monitor.Enter%2A> 计数。</span><span class="sxs-lookup"><span data-stu-id="50b11-588">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="50b11-589">调用 `Wait` 仅释放指定对象的锁;如果调用方是其他对象的锁的所有者，则不会释放这些锁。</span><span class="sxs-lookup"><span data-stu-id="50b11-589">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="50b11-590">同步的对象包含多个引用，包括对当前持有锁的线程的引用、对就绪队列的引用、包含准备好获取锁的线程的引用以及对等待队列的引用（其中包含等待对象状态更改通知的线程）。</span><span class="sxs-lookup"><span data-stu-id="50b11-590">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="50b11-591">必须从同步的代码块内调用 <xref:System.Threading.Monitor.Pulse%2A>、<xref:System.Threading.Monitor.PulseAll%2A>和 `Wait` 方法。</span><span class="sxs-lookup"><span data-stu-id="50b11-591">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="50b11-592"><xref:System.Threading.Monitor.Pulse%2A> 方法的备注说明了在没有线程等待时调用 <xref:System.Threading.Monitor.Pulse%2A> 会发生的情况。</span><span class="sxs-lookup"><span data-stu-id="50b11-592">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="50b11-593">有关退出上下文的说明</span><span class="sxs-lookup"><span data-stu-id="50b11-593">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="50b11-594">除非从非默认托管上下文内调用 <xref:System.Threading.Monitor.Wait%2A> 方法，否则`exitContext` 参数不起作用。</span><span class="sxs-lookup"><span data-stu-id="50b11-594">The`exitContext` parameter has no effect unless the <xref:System.Threading.Monitor.Wait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="50b11-595">如果线程位于从 <xref:System.ContextBoundObject>派生的类的实例中，则会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="50b11-595">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="50b11-596">即使当前正在对不是从 <xref:System.ContextBoundObject>派生的类（如 <xref:System.String>）执行方法，如果 <xref:System.ContextBoundObject> 在当前应用程序域中的堆栈上，也可以在非默认上下文中。</span><span class="sxs-lookup"><span data-stu-id="50b11-596">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="50b11-597">当代码在非默认上下文中执行时，为 `exitContext` 指定 `true` 会导致线程在执行 <xref:System.Threading.Monitor.Wait%2A> 方法之前退出非默认托管上下文（即转换为默认上下文）。</span><span class="sxs-lookup"><span data-stu-id="50b11-597">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.Monitor.Wait%2A> method.</span></span> <span data-ttu-id="50b11-598">此方法在调用 <xref:System.Threading.Monitor.Wait%2A> 方法完成后返回到原始的非默认上下文。</span><span class="sxs-lookup"><span data-stu-id="50b11-598">It returns to the original nondefault context after the call to the <xref:System.Threading.Monitor.Wait%2A> method completes.</span></span>  
  
 <span data-ttu-id="50b11-599">当上下文绑定类应用了 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> 特性时，这会很有用。</span><span class="sxs-lookup"><span data-stu-id="50b11-599">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute applied.</span></span> <span data-ttu-id="50b11-600">在这种情况下，对类成员的所有调用都将自动同步，同步域是类的整个代码正文。</span><span class="sxs-lookup"><span data-stu-id="50b11-600">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="50b11-601">如果成员的调用堆栈中的代码调用 <xref:System.Threading.Monitor.Wait%2A> 方法并指定 `exitContext`的 `true`，则线程将退出同步域，从而允许在对对象的任何成员的调用上被阻止的线程继续。</span><span class="sxs-lookup"><span data-stu-id="50b11-601">If code in the call stack of a member calls the <xref:System.Threading.Monitor.Wait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="50b11-602">当 <xref:System.Threading.Monitor.Wait%2A> 方法返回时，进行调用的线程必须等待重新进入同步域。</span><span class="sxs-lookup"><span data-stu-id="50b11-602">When the <xref:System.Threading.Monitor.Wait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="50b11-603">
          <paramref name="obj" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-603">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="50b11-604"><see langword="Wait" /> 不是从同步的代码块中调用的。</span><span class="sxs-lookup"><span data-stu-id="50b11-604"><see langword="Wait" /> is not invoked from within a synchronized block of code.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="50b11-605">调用 Wait 的线程稍后会从等待状态中中断。</span><span class="sxs-lookup"><span data-stu-id="50b11-605">The thread that invokes Wait is later interrupted from the waiting state.</span></span> <span data-ttu-id="50b11-606">另一线程调用此线程的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法时将发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="50b11-606">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="50b11-607"><paramref name="timeout" /> 参数为负数且不表示 <see cref="F:System.Threading.Timeout.Infinite" />（-1 毫秒），或者大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="50b11-607">The <paramref name="timeout" /> parameter is negative and does not represent <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="/dotnet/standard/threading/"><span data-ttu-id="50b11-608">托管线程处理</span><span class="sxs-lookup"><span data-stu-id="50b11-608">Managed Threading</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
