<Type Name="Monitor" FullName="System.Threading.Monitor">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c22cf07f46a951eb93d7524181054d408581af43" /><Meta Name="ms.sourcegitcommit" Value="9f423345753728e8cad38d4a22663a109e69ea91" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="03/04/2021" /><Meta Name="ms.locfileid" Value="102084086" /></Metadata><TypeSignature Language="C#" Value="public static class Monitor" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Monitor extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Monitor" />
  <TypeSignature Language="VB.NET" Value="Public Class Monitor" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor abstract sealed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Monitor = class" />
  <TypeSignature Language="C#" Value="public sealed class Monitor" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Monitor extends System.Object" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Monitor" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor sealed" FrameworkAlternate="netframework-1.1" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Threading" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Threading" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供同步访问对象的机制。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通过使用 <xref:System.Threading.Monitor> 类，您可以通过调用 <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> 、 <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> 和方法，来同步对某个代码区域的访问 <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> 。 对象锁提供了限制访问代码块的功能，通常称为临界区。 当线程拥有对象的锁时，任何其他线程都无法获取该锁。 你还可以使用 <xref:System.Threading.Monitor> 类来确保不允许其他线程访问由锁所有者执行的应用程序代码的一部分，除非其他线程使用其他锁定对象执行代码。  
  
 本文内容：  
  
 [Monitor 类：概述](#Overview)   
 [Lock 对象](#Lock)   
 [临界区](#CriticalSection)   
 [脉冲、System.threading.monitor.pulseall 和 Wait](#Pulse)   
 [监视器和等待句柄](#WaitHandles)  
  
<a name="Overview"></a>   
## <a name="the-monitor-class-an-overview"></a>Monitor 类：概述  
 <xref:System.Threading.Monitor> 具有以下功能：  
  
-   它与按需的对象相关联。  
  
-   它是未绑定的，这意味着可以从任何上下文直接调用它。  
  
-   <xref:System.Threading.Monitor>无法创建类的实例; 类的方法 <xref:System.Threading.Monitor> 都是静态的。 每个方法都被传递控制对临界区的访问的同步对象。  
  
> [!NOTE]
>  使用 <xref:System.Threading.Monitor> 类可锁定除字符串以外的对象 (即除) 以外的引用类型 <xref:System.String> ，而不是值类型。 有关详细信息，请参阅 <xref:System.Threading.Monitor.Enter%2A> 本文后面的方法重载和 [锁定对象](#Lock) 部分。  
  
 下表描述了访问同步对象的线程可以执行的操作：  
  
|操作|说明|  
|------------|-----------------|  
|<xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A>|获取对象的锁。 此操作还标记关键节的开头。 其他任何线程都不能输入临界区，除非它使用不同的锁定对象执行临界区中的说明。|  
|<xref:System.Threading.Monitor.Wait%2A>|释放对象的锁，以允许其他线程锁定并访问对象。 调用线程会等待另一个线程访问对象。 使用脉冲信号通知等待线程关于对象状态的更改。|  
|<xref:System.Threading.Monitor.Pulse%2A> (信号) ， <xref:System.Threading.Monitor.PulseAll%2A>|将信号发送到一个或多个等待线程。 信号通知等待线程：锁定对象的状态已更改，锁的所有者已准备好释放该锁。 正在等待的线程置于对象的就绪队列中，因此它可能最终接收对象的锁。 线程锁定后，它可以检查对象的新状态，以查看是否已达到所需的状态。|  
|<xref:System.Threading.Monitor.Exit%2A>|释放对象的锁。 此操作还标记受锁定对象保护的临界区的结尾。|  
  
 从 .NET Framework 4 开始，有两组重载用于 <xref:System.Threading.Monitor.Enter%2A> 和 <xref:System.Threading.Monitor.TryEnter%2A> 方法。 一组重载在 c # 中具有一个 `ref` () 或 `ByRef` (Visual Basic 在 <xref:System.Boolean> 获取锁时以原子方式设置为的) 参数 `true` ，即使在获取锁时引发了异常。 如果在所有情况下都必须释放锁定，则使用这些重载，即使锁定所保护的资源可能不是一致的状态。  
  
<a name="Lock"></a>   
## <a name="the-lock-object"></a>Lock 对象  
 Monitor 类包含 `static` c # 中的 () 或  `Shared` (Visual Basic 在控制对临界区的访问权限的对象上运行的) 方法。  为每个同步的对象维护以下信息：  
  
-   对当前持有锁的线程的引用。  
  
-   对就绪队列的引用，其中包含已准备好获取锁的线程。  
  
-   对等待队列的引用，其中包含等待锁定对象状态的更改通知的线程。  
  
 <xref:System.Threading.Monitor> 锁定对象（即引用类型），而不是值类型。 虽然可以将值类型传递到 <xref:System.Threading.Monitor.Enter%2A> 和 <xref:System.Threading.Monitor.Exit%2A>，但对每个调用它都分别进行了装箱。 由于每次调用都将创建一个单独的对象，所以绝不会阻止 <xref:System.Threading.Monitor.Enter%2A> 并且它应该保护的代码不会真正同步。 此外，传递到 <xref:System.Threading.Monitor.Exit%2A> 的对象不同于传递到 <xref:System.Threading.Monitor.Enter%2A> 的对象，因此 <xref:System.Threading.Monitor> 将引发 <xref:System.Threading.SynchronizationLockException> 异常并显示消息“从代码的非同步块调用了对象同步方法。”  
  
 以下示例阐释了此问题。 它启动十个任务，其中每个任务仅休眠 250 毫秒。 然后，每个任务会更新计数器变量 `nTasks`，该变量用于计算实际启动和执行的任务数。 因为 `nTasks` 是一个可同时被多个任务更新的全局变量，所以使用监视器防止其同时被多个任务进行修改。 但是，如示例输出所示，每个任务都将引发 <xref:System.Threading.SynchronizationLockException> 异常。  
  
 [!code-csharp[Conceptual.Monitors#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)]
 [!code-vb[Conceptual.Monitors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)]  
  
 因为 `nTasks` 变量会先于对每个任务中的 <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> 方法的调用而进行装箱，所以每个任务都将引发 <xref:System.Threading.SynchronizationLockException> 异常。 换言之，将向每个方法调用传递一个独立于其他变量的单独变量。 `nTasks` 在对 <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> 方法的调用中会再次进行装箱。 这将再次创建 10 个新装箱的变量 `nTasks`，这些变量相互独立并且独立于在调用 <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> 方法时创建的 10 个装箱变量。 然后将引发异常，因为我们的代码正尝试在之前未锁定的新创建变量上释放锁定。  
  
 尽管可以先装箱值类型变量，再调用 <xref:System.Threading.Monitor.Enter%2A> 和 <xref:System.Threading.Monitor.Exit%2A>（如下例所示）并且同时向这两种方法传递相同的装箱对象，但是进行该操作并没有什么好处。 对未装箱的变量所做的更改不会反映在装箱副本中，并且无法更改装箱副本的值。  
  
 [!code-csharp[Conceptual.Monitors#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)]
 [!code-vb[Conceptual.Monitors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)]  
  
 选择要同步的对象时，应只锁定私有或内部对象。 锁定外部对象可能会导致死锁，因为不相关的代码可能会出于不同目的选择要锁定的相同对象。  
  
 请注意，如果用于锁的对象派生自，则可以在多个应用程序域中的对象上进行同步 <xref:System.MarshalByRefObject> 。  
  
<a name="CriticalSection"></a>   
## <a name="the-critical-section"></a>临界区  
 使用 <xref:System.Threading.Monitor.Enter%2A> 和 <xref:System.Threading.Monitor.Exit%2A> 方法来标记临界区的开头和结尾。  
  
> [!NOTE]
>  和方法提供的功能 <xref:System.Threading.Monitor.Enter%2A> 与 <xref:System.Threading.Monitor.Exit%2A> c # 中的 [lock](/dotnet/csharp/language-reference/keywords/lock-statement) 语句提供的功能和 Visual Basic 中的 [SyncLock](/dotnet/visual-basic/language-reference/statements/synclock-statement) 语句完全相同，不同之处在于语言构造将 <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType> 方法重载和方法封装 <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> 到 `try` .。。`finally` 阻止以确保已释放监视器。  
  
 如果临界区是一组连续的指令，则方法获取的锁 <xref:System.Threading.Monitor.Enter%2A> 可保证只有单个线程才能使用锁定的对象执行包含的代码。 在这种情况下，我们建议将该代码放在 `try` 块中，并将该方法的调用放 <xref:System.Threading.Monitor.Exit%2A> 在 `finally` 块中。 这可确保即使发生异常，也将释放该锁定。 下面的代码段演示了此模式。  
  
 [!code-csharp[System.Threading.Monitor.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)]
 [!code-vb[System.Threading.Monitor.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)]  
  
 此功能通常用于同步对类的静态方法或实例方法的访问。  
  
 如果临界区跨越整个方法，则可以通过将置于 <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> 方法上，并在 <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> 的构造函数中指定值来实现锁定工具 <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> 。 使用此属性时， <xref:System.Threading.Monitor.Enter%2A> <xref:System.Threading.Monitor.Exit%2A> 不需要和方法调用。 下面的代码段演示了此模式：  
  
 [!code-csharp[System.Threading.Monitor.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)]
 [!code-vb[System.Threading.Monitor.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)]  
  
 请注意，特性使当前线程保持锁定状态，直到该方法返回;如果可以更快地释放锁，请在 <xref:System.Threading.Monitor> 方法中使用类、c # [lock](/dotnet/csharp/language-reference/keywords/lock-statement) 语句或 Visual Basic [SyncLock](/dotnet/visual-basic/language-reference/statements/synclock-statement) 语句，而不是使用属性。  
  
 虽然 <xref:System.Threading.Monitor.Enter%2A> 和 <xref:System.Threading.Monitor.Exit%2A> 语句可以锁定和释放给定的对象才能跨越成员或类边界，但并不建议这样做。  
  
<a name="Pulse"></a>   
## <a name="pulse-pulseall-and-wait"></a>脉冲、System.threading.monitor.pulseall 和 Wait  
 一旦某个线程拥有该锁并且进入了锁保护的临界区，它就可以调用 <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType> 、 <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> 和 <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> 方法。  
  
 当持有锁的线程调用时 <xref:System.Threading.Monitor.Wait%2A> ，将释放锁，并将线程添加到已同步对象的等待队列。 就绪队列中的第一个线程（如果有）获取锁定并进入临界区。 调用的线程 <xref:System.Threading.Monitor.Wait%2A> 将从等待队列移到就绪队列 <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> ，当 <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> 包含要移动的锁 (的线程调用该方法时，该线程必须处于等待队列) 的开头。 <xref:System.Threading.Monitor.Wait%2A>当调用线程重新获取该域锁定时，此方法将返回。  
  
 当持有锁的线程调用时 <xref:System.Threading.Monitor.Pulse%2A> ，等待队列开头的线程将移到就绪队列。 调用 <xref:System.Threading.Monitor.PulseAll%2A> 方法会将所有线程从等待队列移到就绪队列。  
  
<a name="WaitHandles"></a>   
## <a name="monitors-and-wait-handles"></a>监视器和等待句柄  
 请务必注意使用 <xref:System.Threading.Monitor> 类和对象之间的区别 <xref:System.Threading.WaitHandle> 。  
  
-   <xref:System.Threading.Monitor>该类是纯粹托管的完全可移植的，并且可能在操作系统资源要求方面更有效。  
  
-   <xref:System.Threading.WaitHandle> 对象表示操作系统可等待对象，有助于托管和非托管代码之间进行同步，并公开一些高级操作系统功能，如同时等待多个对象的功能。  
  
   
  
## Examples  
 下面的示例使用 <xref:System.Threading.Monitor> 类来同步对类所表示的随机数生成器的单个实例的访问 <xref:System.Random> 。 该示例创建了十个任务，每个任务都在线程池线程上以异步方式执行。 每个任务都生成10000个随机数字，计算其平均值，并更新两个过程级别的变量，这些变量维护生成的随机数的总数及其总和。 执行完所有任务后，这两个值将用于计算总体平均值。  
  
 [!code-csharp[System.Threading.Monitor.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Monitor.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/example1.vb#1)]  
  
 由于可以从线程池线程上运行的任何任务访问这些变量，因此 `total` 还必须同步对变量的访问 `n` 。 <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType>方法用于实现此目的。  
  
 下面的示例演示了使用 <xref:System.Threading.Monitor> `lock` 或 `SyncLock` 语言构造) 、 <xref:System.Threading.Interlocked> 类和类实现 (类的组合用法 <xref:System.Threading.AutoResetEvent> 。 它定义了两个 `internal`（在 C# 中）或 `Friend`（在 Visual Basic）类（`SyncResource` 和 `UnSyncResource`），它们分别提供对资源的同步和不同步访问。 为了确保此示例展示同步和不同步访问的差异（如果每个方法调用快速完成，可能出现这种情况），此方法包含一次随机延迟：对于其 <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> 属性为偶数的线程，此方法调用 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 以引入 2,000 毫秒延迟。 注意，由于 `SyncResource` 类不是公共类，因此没有客户端代码会对同步资源采用锁，内部类将自己采用锁。 这可以防止恶意代码对公共对象采用锁。  
  
 [!code-csharp[Conceptual.Monitors#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/source.cs#1)]
 [!code-vb[Conceptual.Monitors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/source.vb#1)]  
  
 该示例定义一个变量（即 `numOps`），用于定义尝试访问资源的线程数。 该应用程序线程为每个同步和不同步的访问调用五次 <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> 方法。 <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> 方法具有一个参数，该参数是一个不接受任何参数且不返回任何值的委托。 对于同步访问，它将调用 `SyncUpdateResource` 方法；对于不同步访问，它将调用 `UnSyncUpdateResource` 方法。 每组方法调用后，应用程序线程将调用 [AutoResetEvent WaitOne](xref:System.Threading.WaitHandle.WaitOne*) 方法，以便在实例终止之前一直处于阻止状态 <xref:System.Threading.AutoResetEvent> 。  
  
 每次调用 `SyncUpdateResource` 方法都会调用内部 `SyncResource.Access` 方法，然后调用 <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> 方法以递减 `numOps` 计数器。 <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType>方法用于递减计数器，因为在这种情况下，如果第一个线程的递减值已存储在变量中，则不能确保第二个线程将访问该值。 当最后一个同步的工作线程将计数器递减到零时，表示所有同步线程均已完成对资源的访问，该 `SyncUpdateResource` 方法将调用 <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> 方法，该方法指示主线程继续执行。  
  
 每次调用 `UnSyncUpdateResource` 方法都会调用内部 `UnSyncResource.Access` 方法，然后调用 <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> 方法以递减 `numOps` 计数器。 同样， <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> 方法用于递减计数器，以确保第二个线程在第一个线程的递减值分配给变量之前不会访问该值。 当最后一个同步的工作线程将计数器递减到零时，表示没有更多的不同步线程需要访问该资源，该 `UnSyncUpdateResource` 方法会调用 <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> 方法，这会向主线程发出信号，使其继续执行。  
  
 如示例的输出所示，同步访问可确保另一个线程必须在调用线程退出受保护的资源之后才能访问该资源；每个线程都在其前置任务上等待。 另一方面，在不采用锁的情况下，将按线程到达的顺序调用 `UnSyncResource.Access` 方法。  
  
 ]]></format>
    </remarks>
    <threadsafe>此类型是线程安全的。</threadsafe>
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="/dotnet/standard/threading/">托管线程处理</related>
    <related type="Article" href="/dotnet/standard/threading/threading-objects-and-features">线程处理对象和功能</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Enter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取指定对象上的排他锁。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Enter : obj -&gt; unit" Usage="System.Threading.Monitor.Enter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">在其上获取监视器锁的对象。</param>
        <summary>在指定对象上获取排他锁。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 `Enter` 获取 <xref:System.Threading.Monitor> 作为参数传递的对象上的。 如果其他线程 `Enter` 在对象上执行了，但尚未执行相应的 <xref:System.Threading.Monitor.Exit%2A> ，则当前线程将会阻塞，直到另一个线程释放该对象。 同一个线程在不阻止的情况下调用多次是合法的 `Enter` ; 但是，在 `Exit` 等待对象的其他线程解除阻止之前，必须调用相等的调用数。  
  
 用于 <xref:System.Threading.Monitor> 锁定对象 (即引用类型) ，而不是值类型。 向传递值类型变量时 `Enter` ，该变量将装箱为对象。 如果再次传递相同的变量 `Enter` ，则该变量将被装箱为单独的对象，并且不会阻止该线程。 在这种情况下，受保护的代码 `Monitor` 不受保护。 而且，在将变量传递到时 `Exit` ，仍然会创建另一个单独的对象。 由于传递给的对象 `Exit` 不同于传递到的对象，因此将 `Enter` `Monitor` 引发 <xref:System.Threading.SynchronizationLockException> 。 有关详细信息，请参阅概念主题 [监视](xref:System.Threading.Monitor)。  
  
 <xref:System.Threading.Thread.Interrupt%2A> 可以中断等待在对象上进入的线程 `Monitor` 。 <xref:System.Threading.ThreadInterruptedException>将引发。  
  
 使用 c # `try` .。。`finally` 块 (`Try` .。。`Finally` 在 Visual Basic) 以确保发布监视器，或在 Visual Basic) 中使用 c # `lock` 语句 (`SyncLock` 语句，该语句将 <xref:System.Threading.Monitor.Enter%2A> 和方法包装 <xref:System.Threading.Monitor.Exit%2A> 在 `try` .。。`finally` 模块.  
  
   
  
## Examples  
 下面的示例演示如何使用 `Enter` 方法。  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 参数为 <see langword="null" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="/dotnet/standard/threading/">托管线程处理</related>
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member Enter : obj * bool -&gt; unit" Usage="System.Threading.Monitor.Enter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">要在其上等待的对象。</param>
        <param name="lockTaken">尝试获取锁的结果，通过引用传递。 输入必须为 <see langword="false" />。 如果已获取锁，则输出为 <see langword="true" />；否则输出为 <see langword="false" />。 即使在尝试获取锁的过程中发生异常，也会设置输出。  
  
注意   如果没有发生异常，则此方法的输出始终为 <see langword="true" />。</param>
        <summary>获取指定对象上的排他锁，并自动设置一个值，指示是否获取了该锁。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 `Enter` 获取 <xref:System.Threading.Monitor> 作为参数传递的对象上的 `obj` 。 如果其他线程 `Enter` 在对象上执行了，但尚未执行相应的 <xref:System.Threading.Monitor.Exit%2A> ，则当前线程将会阻塞，直到另一个线程释放该对象。 同一个线程在不阻止的情况下调用多次是合法的 `Enter` ; 但是，在 `Exit` 等待对象的其他线程解除阻止之前，必须调用相等的调用数。  
  
 如果由于引发了异常而未获取锁，则 `lockTaken` 此方法结束后，为该参数指定的变量将 `false` 结束。 这使程序可以确定是否有必要释放该锁。 如果此方法返回而不引发异常，则为该参数指定的变量 `lockTaken` 始终是 `true` ，无需对其进行测试。  
  
 用于 <xref:System.Threading.Monitor> 锁定对象 (即引用类型) ，而不是值类型。 向传递值类型变量时 `Enter` ，该变量将装箱为对象。 如果再次传递相同的变量 `Enter` ，则该变量将被装箱为单独的对象，并且不会阻止该线程。 在这种情况下，受保护的代码 `Monitor` 不受保护。 而且，在将变量传递到时 `Exit` ，将创建另一个单独的对象。 由于传递给的对象 `Exit` 不同于传递到的对象，因此将 `Enter` `Monitor` 引发 <xref:System.Threading.SynchronizationLockException> 。 有关详细信息，请参阅概念主题 [监视](xref:System.Threading.Monitor)。  
  
 <xref:System.Threading.Thread.Interrupt%2A> 可以中断等待在对象上进入的线程 `Monitor` 。 <xref:System.Threading.ThreadInterruptedException>将引发。  
  
   
  
## Examples  
 下面的代码显示使用方法重载的基本模式 <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> 。 此重载始终设置传递到 `ref` Visual Basic) 中 (参数的变量的值 `ByRef` `lockTaken` ，即使该方法引发异常也是如此，因此该变量的值是测试是否必须释放该锁的可靠方法。  
  
 [!code-csharp[System.Threading.Monitor.Enter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#2)]
 [!code-vb[System.Threading.Monitor.Enter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="lockTaken" /> 的输入为 <see langword="true" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 参数为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Exit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Exit : obj -&gt; unit" Usage="System.Threading.Monitor.Exit obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">在其上释放锁的对象。</param>
        <summary>释放指定对象上的排他锁。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用线程必须拥有对参数的锁定 `obj` 。 如果调用线程拥有指定对象的锁，并且已对该对象进行了相等 `Exit` 和 <xref:System.Threading.Monitor.Enter%2A> 调用，则会释放该锁。 如果调用线程未调用 `Exit` 多次 `Enter` ，则不会释放该锁。  
  
 如果锁已释放并且其他线程位于对象的就绪队列中，则其中一个线程将获取该锁。 如果其他线程在等待队列中等待获取锁定，则当锁的所有者调用时，它们不会自动移到就绪队列 `Exit` 。 若要将一个或多个等待线程移入就绪队列，请 <xref:System.Threading.Monitor.Pulse%2A> 在调用之前调用或 <xref:System.Threading.Monitor.PulseAll%2A> `Exit` 。  
  
   
  
## Examples  
 下面的示例演示如何使用 `Exit` 方法。  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">当前线程不拥有指定对象的锁。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="/dotnet/standard/threading/">托管线程处理</related>
      </Docs>
    </Member>
    <Member MemberName="IsEntered">
      <MemberSignature Language="C#" Value="public static bool IsEntered (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEntered(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.IsEntered(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEntered (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEntered(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member IsEntered : obj -&gt; bool" Usage="System.Threading.Monitor.IsEntered obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">要测试的对象。</param>
        <summary>确定当前线程是否保留指定对象上的锁。</summary>
        <returns>如果当前线程持有 <paramref name="obj" /> 锁，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法仅适用于通过使用类的方法获取的锁 <xref:System.Threading.Monitor> ，或通过使用通过实现的 c # `lock` 语句或 Visual Basic 语句获取的 `SyncLock` <xref:System.Threading.Monitor> 。  
  
 将此方法与诊断工具（如 <xref:System.Diagnostics.Debug.Assert%2A> 方法和 <xref:System.Diagnostics.Contracts.Contract> 类）结合使用，以调试涉及类的锁定问题 <xref:System.Threading.Monitor> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="LockContentionCount">
      <MemberSignature Language="C#" Value="public static long LockContentionCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 LockContentionCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Monitor.LockContentionCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LockContentionCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long LockContentionCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LockContentionCount : int64" Usage="System.Threading.Monitor.LockContentionCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取尝试锁定监视器时出现争用的次数。</summary>
        <value>尝试获取监视器锁时存在争用的次数。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Pulse">
      <MemberSignature Language="C#" Value="public static void Pulse (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pulse(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Pulse(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pulse (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Pulse(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Pulse : obj -&gt; unit" Usage="System.Threading.Monitor.Pulse obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">线程正在等待的对象。</param>
        <summary>通知等待队列中的线程锁定对象状态的更改。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只有锁定的当前所有者才能使用发送正在等待的对象 `Pulse` 。  
  
 当前拥有指定对象的锁的线程调用此方法，以向第一个线程发出锁。 接收到脉冲后，等待线程会移动到就绪队列。 如果调用的线程 `Pulse` 释放锁定，则就绪队列中的下一个线程 (这不一定是 pulsed) 的线程获取该锁。  
  
> [!IMPORTANT]
>  <xref:System.Threading.Monitor>类不维护指示已调用方法的状态 <xref:System.Threading.Monitor.Pulse%2A> 。 因此，如果在 <xref:System.Threading.Monitor.Pulse%2A> 没有线程等待的情况下调用，则下一个调用 <xref:System.Threading.Monitor.Wait%2A> 块的线程就好像 <xref:System.Threading.Monitor.Pulse%2A> 从未调用过。 如果两个线程正在使用 <xref:System.Threading.Monitor.Pulse%2A> 并 <xref:System.Threading.Monitor.Wait%2A> 进行交互，这可能会导致死锁。 将此与类的行为相比较 <xref:System.Threading.AutoResetEvent> ：如果 <xref:System.Threading.AutoResetEvent> 通过调用其方法发出信号 <xref:System.Threading.EventWaitHandle.Set%2A> ，并且没有等待的线程，则会 <xref:System.Threading.AutoResetEvent> 一直保持终止状态，直到线程调用 <xref:System.Threading.WaitHandle.WaitOne%2A> 、 <xref:System.Threading.WaitHandle.WaitAny%2A> 或 <xref:System.Threading.WaitHandle.WaitAll%2A> 。 <xref:System.Threading.AutoResetEvent>线程并返回到信号状态的版本。  
  
 请注意，同步对象包含多个引用，包括对当前持有锁的线程的引用、对就绪队列的引用、包含准备好获取锁的线程的引用以及对等待队列的引用（其中包含等待对象状态更改通知的线程）。  
  
 `Pulse` <xref:System.Threading.Monitor.PulseAll%2A> <xref:System.Threading.Monitor.Wait%2A> 必须从同步的代码块中调用、和方法。  
  
 若要向多个线程发出信号，请使用 <xref:System.Threading.Monitor.PulseAll%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">调用线程不拥有指定对象的锁。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="/dotnet/standard/threading/">托管线程处理</related>
      </Docs>
    </Member>
    <Member MemberName="PulseAll">
      <MemberSignature Language="C#" Value="public static void PulseAll (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PulseAll(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.PulseAll(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PulseAll (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PulseAll(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member PulseAll : obj -&gt; unit" Usage="System.Threading.Monitor.PulseAll obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">发送脉冲的对象。</param>
        <summary>通知所有的等待线程对象状态的更改。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前拥有指定对象的锁的线程调用此方法，以向等待获取该对象的锁的所有线程发出信号。 发送信号后，等待的线程会移动到就绪队列。 如果调用的线程 `PulseAll` 释放锁定，则就绪队列中的下一个线程将获取该锁。  
  
 请注意，同步对象包含多个引用，包括对当前持有锁的线程的引用、对就绪队列的引用、包含准备好获取锁的线程的引用以及对等待队列的引用（其中包含等待对象状态更改通知的线程）。  
  
 <xref:System.Threading.Monitor.Pulse%2A> `PulseAll` <xref:System.Threading.Monitor.Wait%2A> 必须从同步的代码块中调用、和方法。  
  
 方法的备注 <xref:System.Threading.Monitor.Pulse%2A> 说明 <xref:System.Threading.Monitor.Pulse%2A> 了在没有线程等待时调用时所发生的情况。  
  
 若要向单个线程发出信号，请使用 `Pulse` 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">调用线程不拥有指定对象的锁。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="/dotnet/standard/threading/">托管线程处理</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>尝试获取指定对象的排他锁。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj -&gt; bool" Usage="System.Threading.Monitor.TryEnter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">在其上获取锁的对象。</param>
        <summary>尝试获取指定对象的排他锁。</summary>
        <returns>如果当前线程获取该锁，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果成功，则此方法获取参数上的排他锁 `obj` 。 此方法立即返回，无论锁是否可用。  
  
 此方法类似于 <xref:System.Threading.Monitor.Enter%2A> ，但它永远不会阻止当前线程。 如果线程在不阻止的情况下无法输入，则此方法将返回 `false,` 。  
  
> [!NOTE]
>  用于 <xref:System.Threading.Monitor> 锁定对象 (即引用类型) ，而不是值类型。 有关详细信息，请参阅 <xref:System.Threading.Monitor> 文章。  
  
 若要确保线程不输入临界区，应检查方法的返回值，并仅在临界区中执行代码，前提是其返回值为 `true` 。 下面的代码段显示了用于调用此方法的模式。 请注意，应 <xref:System.Threading.Monitor.Exit%2A> 在块中调用 `finally` ，以确保调用线程在发生异常的情况下释放其对临界区的锁定。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)]
 [!code-vb[System.Threading.Monitor.TryEnter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)]  
  
   
  
## Examples  
 下面的代码示例演示如何使用 `TryEnter` 方法。  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 参数为 <see langword="null" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="/dotnet/standard/threading/">托管线程处理</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * bool -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">在其上获取锁的对象。</param>
        <param name="lockTaken">尝试获取锁的结果，通过引用传递。 输入必须为 <see langword="false" />。 如果已获取锁，则输出为 <see langword="true" />；否则输出为 <see langword="false" />。 即使在尝试获取锁的过程中发生异常，也会设置输出。</param>
        <summary>尝试获取指定对象上的排他锁，并自动设置一个值，指示是否获取了该锁。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果成功，则此方法获取参数上的排他锁 `obj` 。 此方法立即返回，无论锁是否可用。  
  
 如果由于引发了异常而未获取锁，则 `lockTaken` 此方法结束后，为该参数指定的变量将 `false` 结束。 这使程序可以确定是否有必要释放该锁。  
  
 此方法类似于 <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> ，但它永远不会阻止当前线程。 如果线程在不阻止的情况下不能输入，则 `lockTaken` `false` 当该方法返回时，将参数设置为。  
  
> [!NOTE]
>  用于 <xref:System.Threading.Monitor> 锁定对象 (即引用类型) ，而不是值类型。 有关详细信息，请参阅<xref:System.Threading.Monitor>一文。  
  
 若要确保线程不输入临界区，应检查的值 `lockTaken` 并仅在临界区中执行代码，前提是它的值为 `true` 。 下面的代码段显示了用于调用此方法的模式。 请注意，应 <xref:System.Threading.Monitor.Exit%2A> 在块中调用 `finally` ，以确保调用线程在发生异常的情况下释放其对临界区的锁定。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)]
 [!code-vb[System.Threading.Monitor.TryEnter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)]  
  
   
  
## Examples  
 下面的代码显示使用方法重载的基本模式 <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> 。 此重载始终设置传递到 `ref` Visual Basic) 中 (参数的变量的值 `ByRef` `lockTaken` ，即使该方法引发异常也是如此，因此该变量的值是测试是否必须释放该锁的可靠方法。  
  
 [!code-csharp[System.Threading.Monitor.Enter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#3)]
 [!code-vb[System.Threading.Monitor.Enter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="lockTaken" /> 的输入为 <see langword="true" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 参数为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">在其上获取锁的对象。</param>
        <param name="millisecondsTimeout">等待锁所需的毫秒数。</param>
        <summary>在指定的毫秒数内尝试获取指定对象上的排他锁。</summary>
        <returns>如果当前线程获取该锁，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `millisecondsTimeout` 参数等于 <xref:System.Threading.Timeout.Infinite> ，则此方法等效于 <xref:System.Threading.Monitor.Enter%2A> 。 如果 `millisecondsTimeout` 等于0，则此方法等效于 <xref:System.Threading.Monitor.TryEnter%2A> 。  
  
> [!NOTE]
>  用于 <xref:System.Threading.Monitor> 锁定对象 (即引用类型) ，而不是值类型。 有关详细信息，请参阅 <xref:System.Threading.Monitor> 文章。  
  
 若要确保线程不输入临界区，应检查方法的返回值，并仅在临界区中执行代码，前提是其返回值为 `true` 。 下面的代码段显示了用于调用此方法的模式。 请注意，应 <xref:System.Threading.Monitor.Exit%2A> 在块中调用 `finally` ，以确保调用线程在发生异常的情况下释放其对临界区的锁定。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)]
 [!code-vb[System.Threading.Monitor.TryEnter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> 是负数且不等于 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="/dotnet/standard/threading/">托管线程处理</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">在其上获取锁的对象。</param>
        <param name="timeout"><see cref="T:System.TimeSpan" />，表示等待锁所需的时间量。 值为 -1 毫秒表示指定无限期等待。</param>
        <summary>在指定的时间内尝试获取指定对象上的排他锁。</summary>
        <returns>如果当前线程获取该锁，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `timeout` 转换为毫秒的参数值等于-1，则此方法等效于 <xref:System.Threading.Monitor.Enter%2A> 。 如果的值 `timeout` 等于0，则此方法等效于 <xref:System.Threading.Monitor.TryEnter%2A> 。  
  
> [!NOTE]
>  用于 <xref:System.Threading.Monitor> 锁定对象 (即引用类型) ，而不是值类型。 有关详细信息，请参阅 <xref:System.Threading.Monitor> 类主题。  
  
 若要确保线程不输入临界区，应检查方法的返回值，并仅在临界区中执行代码，前提是其返回值为 `true` 。 下面的代码段显示了用于调用此方法的模式。 请注意，应 <xref:System.Threading.Monitor.Exit%2A> 在块中调用 `finally` ，以确保调用线程在发生异常的情况下释放其对临界区的锁定。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)]
 [!code-vb[System.Threading.Monitor.TryEnter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> 的值（以毫秒计）为负数且不等于 <see cref="F:System.Threading.Timeout.Infinite" />（-1 毫秒），或者大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="/dotnet/standard/threading/">托管线程处理</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, int millisecondsTimeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int * bool -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">在其上获取锁的对象。</param>
        <param name="millisecondsTimeout">等待锁所需的毫秒数。</param>
        <param name="lockTaken">尝试获取锁的结果，通过引用传递。 输入必须为 <see langword="false" />。 如果已获取锁，则输出为 <see langword="true" />；否则输出为 <see langword="false" />。 即使在尝试获取锁的过程中发生异常，也会设置输出。</param>
        <summary>在指定的毫秒数内尝试获取指定对象上的排他锁，并自动设置一个值，指示是否获取了该锁。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `millisecondsTimeout` 参数等于 <xref:System.Threading.Timeout.Infinite> ，则此方法等效于 <xref:System.Threading.Monitor.Enter%28System.Object%29> 。 如果 `millisecondsTimeout` 等于0，则此方法等效于 <xref:System.Threading.Monitor.TryEnter%28System.Object%29> 。  
  
 如果由于引发了异常而未获取锁，则 `lockTaken` 此方法结束后，为该参数指定的变量将 `false` 结束。 这使程序可以确定是否有必要释放该锁。  
  
> [!NOTE]
>  用于 <xref:System.Threading.Monitor> 锁定对象 (即引用类型) ，而不是值类型。 有关详细信息，请参阅 <xref:System.Threading.Monitor> 类主题。  
  
 若要确保线程不输入临界区，应检查的值 `lockTaken` 并仅在临界区中执行代码，前提是它的值为 `true` 。 下面的代码段显示了用于调用此方法的模式。 请注意，应 <xref:System.Threading.Monitor.Exit%2A> 在块中调用 `finally` ，以确保调用线程在发生异常的情况下释放其对临界区的锁定。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)]
 [!code-vb[System.Threading.Monitor.TryEnter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)]  
  
   
  
## Examples  
 下面的代码显示使用方法重载的基本模式 <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> 。 此重载始终设置传递到 `ref` Visual Basic) 中 (参数的变量的值 `ByRef` `lockTaken` ，即使该方法引发异常也是如此，因此该变量的值是测试是否必须释放该锁的可靠方法。  
  
 [!code-csharp[System.Threading.Monitor.Enter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#4)]
 [!code-vb[System.Threading.Monitor.Enter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="lockTaken" /> 的输入为 <see langword="true" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> 是负数且不等于 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, TimeSpan timeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan * bool -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, timeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">在其上获取锁的对象。</param>
        <param name="timeout">用于等待锁的时间。 值为 -1 毫秒表示指定无限期等待。</param>
        <param name="lockTaken">尝试获取锁的结果，通过引用传递。 输入必须为 <see langword="false" />。 如果已获取锁，则输出为 <see langword="true" />；否则输出为 <see langword="false" />。 即使在尝试获取锁的过程中发生异常，也会设置输出。</param>
        <summary>在指定的一段时间内尝试获取指定对象上的排他锁，并自动设置一个值，指示是否获得了该锁。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `timeout` 转换为毫秒的参数值等于-1，则此方法等效于 <xref:System.Threading.Monitor.Enter%28System.Object%29> 。 如果的值 `timeout` 等于0，则此方法等效于 <xref:System.Threading.Monitor.TryEnter%28System.Object%29> 。  
  
 如果由于引发了异常而未获取锁，则 `lockTaken` 此方法结束后，为该参数指定的变量将 `false` 结束。 这使程序可以确定是否有必要释放该锁。  
  
> [!NOTE]
>  用于 <xref:System.Threading.Monitor> 锁定对象 (即引用类型) ，而不是值类型。 有关详细信息，请参阅 <xref:System.Threading.Monitor> 类主题。  
  
 若要确保线程不输入临界区，应检查的值 `lockTaken` 并仅在临界区中执行代码，前提是它的值为 `true` 。 下面的代码段显示了用于调用此方法的模式。 请注意，应 <xref:System.Threading.Monitor.Exit%2A> 在块中调用 `finally` ，以确保调用线程在发生异常的情况下释放其对临界区的锁定。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)]
 [!code-vb[System.Threading.Monitor.TryEnter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="lockTaken" /> 的输入为 <see langword="true" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> 的值（以毫秒计）为负数且不等于 <see cref="F:System.Threading.Timeout.Infinite" />（-1 毫秒），或者大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="/dotnet/standard/threading/">托管线程处理</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>释放对象上的锁并阻止当前线程，直到它重新获取该锁。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Wait : obj -&gt; bool" Usage="System.Threading.Monitor.Wait obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要在其上等待的对象。</param>
        <summary>释放对象上的锁并阻止当前线程，直到它重新获取该锁。</summary>
        <returns>如果调用由于调用方重新获取了指定对象的锁而返回，则为 <see langword="true" />。 如果未重新获取该锁，则此方法不会返回。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前拥有指定对象的锁的线程调用此方法以释放该对象，以便其他线程可以访问它。 等待重新获取该锁时，调用方被阻止。 当调用方需要等待作为其他线程操作的结果而发生的状态更改时，将调用此方法。  
  
 当线程调用时 `Wait` ，它会释放对象的锁，并进入该对象的等待队列。 如果有一个) 获取了该锁并且独占使用了该对象，则该对象的 "就绪" 队列中的下一个线程 (。 调用的所有线程 `Wait` 都将保留在等待队列中，直到接收到 <xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A> 由锁的所有者发送的或发出的信号。 如果 `Pulse` 发送了，则只影响处于等待队列开头的线程。 如果 `PulseAll` 发送，则会影响正在等待对象的所有线程。 收到信号后，一个或多个线程将离开等待队列，并进入就绪队列。 允许队列中的线程重新获取该锁。  
  
 当调用线程重新获取该域对象上的锁时，此方法返回。 请注意，如果锁定的持有者不调用或，则此方法会无限期阻止 `Pulse` `PulseAll` 。  
  
 `Wait`无论 <xref:System.Threading.Monitor.Enter%2A> 为指定的对象调用了多少次，调用方都将执行一次。 从概念上讲，此 `Wait` 方法存储调用方 `Enter` 在对象上调用的次数，并按 `Exit` 需多次调用以完全释放锁定的对象。 然后，调用方在等待重新获取对象时阻止。 当调用方重新获取该域锁定时，系统会根据 `Enter` 需要多次调用以还原调用方的已保存 `Enter` 计数。 调用 `Wait` 只释放指定对象的锁; 如果调用方是其他对象的锁的所有者，则不释放这些锁。  
  
 请注意，同步对象包含多个引用，包括对当前持有锁的线程的引用、对就绪队列的引用、包含准备好获取锁的线程的引用以及对等待队列的引用（其中包含等待对象状态更改通知的线程）。  
  
 <xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A> `Wait` 必须从同步的代码块中调用、和方法。  
  
 方法的备注 <xref:System.Threading.Monitor.Pulse%2A> 说明 <xref:System.Threading.Monitor.Pulse%2A> 了在没有线程等待时调用时所发生的情况。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">调用线程不拥有指定对象的锁。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">调用 <see langword="Wait" /> 的线程稍后从等待状态中断。 另一线程调用此线程的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法时将发生这种情况。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="/dotnet/standard/threading/">托管线程处理</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">要在其上等待的对象。</param>
        <param name="millisecondsTimeout">线程进入就绪队列之前等待的毫秒数。</param>
        <summary>释放对象上的锁并阻止当前线程，直到它重新获取该锁。 如果已用指定的超时时间间隔，则线程进入就绪队列。</summary>
        <returns>如果在指定的时间过期之前重新获取该锁，则为 <see langword="true" />；如果在指定的时间过期之后重新获取该锁，则为 <see langword="false" />。 此方法只有在重新获取该锁后才会返回。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法在重新获取该域参数的排他锁之前不会返回 `obj` 。  
  
 当前拥有指定对象的锁的线程调用此方法以释放该对象，以便其他线程可以访问它。 等待重新获取该锁时，调用方被阻止。 当调用方需要等待作为其他线程操作的结果而发生的状态更改时，将调用此方法。  
  
 超时可确保当另一个线程释放该锁，而不首先调用或方法时，当前线程不会无限期地阻止 <xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A> 。 它还会将线程移动到就绪队列，绕过等待队列中的其他线程，以便它可以更快地重新获取锁定。 线程可以测试方法的返回值 <xref:System.Threading.Monitor.Wait%2A> ，以确定它是否在超时前重新获取该锁。线程可以计算导致其进入等待状态的条件，并在必要时 <xref:System.Threading.Monitor.Wait%2A> 再次调用方法。  
  
 当线程调用时 `Wait` ，它会释放对象的锁，并进入该对象的等待队列。 如果有一个) 获取了该锁并且独占使用了该对象，则该对象的 "就绪" 队列中的下一个线程 (。 调用的线程将 `Wait` 保留在等待队列中，直到持有锁的线程调用 <xref:System.Threading.Monitor.PulseAll%2A> ，或者它是队列中的下一线程以及持有锁的线程调用 <xref:System.Threading.Monitor.Pulse%2A> 。 但是，如果在 `millisecondsTimeout` 另一个线程调用此对象的 <xref:System.Threading.Monitor.Pulse%2A> 或 <xref:System.Threading.Monitor.PulseAll%2A> 方法之前已过，则原始线程将移到就绪队列，以便重新获取锁定。  
  
> [!NOTE]
>  如果 <xref:System.Threading.Timeout.Infinite> 为 `millisecondsTimeout` 参数指定，则此方法会无限期地阻止，除非锁的持有方调用 <xref:System.Threading.Monitor.Pulse%2A> 或 <xref:System.Threading.Monitor.PulseAll%2A> 。 如果 `millisecondsTimeout` 等于0，则调用的线程将 `Wait` 释放该锁，然后立即进入就绪队列以便重新获取锁。  
  
 `Wait`无论 <xref:System.Threading.Monitor.Enter%2A> 为指定的对象调用了多少次，调用方都将执行一次。 从概念上讲，此 `Wait` 方法存储调用方 <xref:System.Threading.Monitor.Enter%2A> 在对象上调用的次数，并按 <xref:System.Threading.Monitor.Exit%2A> 需多次调用以完全释放锁定的对象。 然后，调用方在等待重新获取对象时阻止。 当调用方重新获取该域锁定时，系统会根据 <xref:System.Threading.Monitor.Enter%2A> 需要多次调用以还原调用方的已保存 <xref:System.Threading.Monitor.Enter%2A> 计数。 调用 `Wait` 只释放指定对象的锁; 如果调用方是其他对象的锁的所有者，则不释放这些锁。  
  
> [!NOTE]
>  同步的对象包含多个引用，包括对当前持有锁的线程的引用、对就绪队列的引用、包含准备好获取锁的线程的引用以及对等待队列的引用（其中包含等待对象状态更改通知的线程）。  
  
 <xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A> `Wait` 必须从同步的代码块中调用、和方法。  
  
 方法的备注 <xref:System.Threading.Monitor.Pulse%2A> 说明 <xref:System.Threading.Monitor.Pulse%2A> 了在没有线程等待时调用时所发生的情况。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">调用线程不拥有指定对象的锁。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">调用 <see langword="Wait" /> 的线程稍后从等待状态中断。 另一线程调用此线程的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法时将发生这种情况。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> 参数值为负且不等于 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="/dotnet/standard/threading/">托管线程处理</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">要在其上等待的对象。</param>
        <param name="timeout"><see cref="T:System.TimeSpan" />，表示线程进入就绪队列之前等待的时间量。</param>
        <summary>释放对象上的锁并阻止当前线程，直到它重新获取该锁。 如果已用指定的超时时间间隔，则线程进入就绪队列。</summary>
        <returns>如果在指定的时间过期之前重新获取该锁，则为 <see langword="true" />；如果在指定的时间过期之后重新获取该锁，则为 <see langword="false" />。 此方法只有在重新获取该锁后才会返回。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法在重新获取该域参数的排他锁之前不会返回 `obj` 。  
  
 当前拥有指定对象的锁的线程调用此方法以释放该对象，以便其他线程可以访问它。 等待重新获取该锁时，调用方被阻止。 当调用方需要等待作为其他线程操作的结果而发生的状态更改时，将调用此方法。  
  
 超时可确保当另一个线程释放该锁，而不首先调用或方法时，当前线程不会无限期地阻止 <xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A> 。 它还会将线程移动到就绪队列，绕过等待队列中的其他线程，以便它可以更快地重新获取锁定。 线程可以测试方法的返回值 <xref:System.Threading.Monitor.Wait%2A> ，以确定它是否在超时前重新获取该锁。线程可以计算导致其进入等待状态的条件，并在必要时 <xref:System.Threading.Monitor.Wait%2A> 再次调用方法。  
  
 当线程调用时 `Wait` ，它会释放对象的锁，并进入该对象的等待队列。 如果有一个) 获取了该锁并且独占使用了该对象，则该对象的 "就绪" 队列中的下一个线程 (。 调用的线程将 `Wait` 保留在等待队列中，直到持有锁的线程调用 <xref:System.Threading.Monitor.PulseAll%2A> ，或者它是队列中的下一线程以及持有锁的线程调用 <xref:System.Threading.Monitor.Pulse%2A> 。 但是，如果在 `timeout` 另一个线程调用此对象的 <xref:System.Threading.Monitor.Pulse%2A> 或 <xref:System.Threading.Monitor.PulseAll%2A> 方法之前已过，则原始线程将移到就绪队列，以便重新获取锁定。  
  
> [!NOTE]
>  如果为 <xref:System.TimeSpan> 参数指定了表示-1 毫秒的 `timeout` ，则此方法会无限期阻止，除非锁的持有方调用 <xref:System.Threading.Monitor.Pulse%2A> 或 <xref:System.Threading.Monitor.PulseAll%2A> 。 如果 `timeout` 为0毫秒，则调用的线程将 `Wait` 释放该锁，然后立即进入就绪队列以便重新获取锁。  
  
 `Wait`无论 <xref:System.Threading.Monitor.Enter%2A> 为指定的对象调用了多少次，调用方都将执行一次。 从概念上讲，此 `Wait` 方法存储调用方 <xref:System.Threading.Monitor.Enter%2A> 在对象上调用的次数，并按 <xref:System.Threading.Monitor.Exit%2A> 需多次调用以完全释放锁定的对象。 然后，调用方在等待重新获取对象时阻止。 当调用方重新获取该域锁定时，系统会根据 <xref:System.Threading.Monitor.Enter%2A> 需要多次调用以还原调用方的已保存 <xref:System.Threading.Monitor.Enter%2A> 计数。 调用 `Wait` 只释放指定对象的锁; 如果调用方是其他对象的锁的所有者，则不释放这些锁。  
  
> [!NOTE]
>  同步的对象包含多个引用，包括对当前持有锁的线程的引用、对就绪队列的引用、包含准备好获取锁的线程的引用以及对等待队列的引用（其中包含等待对象状态更改通知的线程）。  
  
 <xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A> `Wait` 必须从同步的代码块中调用、和方法。  
  
 方法的备注 <xref:System.Threading.Monitor.Pulse%2A> 说明 <xref:System.Threading.Monitor.Pulse%2A> 了在没有线程等待时调用时所发生的情况。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">调用线程不拥有指定对象的锁。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">调用 <see langword="Wait" /> 的线程稍后从等待状态中断。 另一线程调用此线程的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法时将发生这种情况。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> 参数的值（以毫秒计）为负数且不表示 <see cref="F:System.Threading.Timeout.Infinite" />（-1 毫秒），或者大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="/dotnet/standard/threading/">托管线程处理</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="obj">要在其上等待的对象。</param>
        <param name="millisecondsTimeout">线程进入就绪队列之前等待的毫秒数。</param>
        <param name="exitContext">如果在等待前退出并重新获取上下文的同步域（如果在同步上下文中），则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>释放对象上的锁并阻止当前线程，直到它重新获取该锁。 如果已用指定的超时时间间隔，则线程进入就绪队列。 此方法还指定是否在等待之前退出上下文的同步域（如果在同步上下文中）然后重新获取该同步域。</summary>
        <returns>如果在指定的时间过期之前重新获取该锁，则为 <see langword="true" />；如果在指定的时间过期之后重新获取该锁，则为 <see langword="false" />。 此方法只有在重新获取该锁后才会返回。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法在重新获取该域参数的排他锁之前不会返回 `obj` 。  
  
 当前拥有指定对象的锁的线程调用此方法以释放该对象，以便其他线程可以访问它。 等待重新获取该锁时，调用方被阻止。 当调用方需要等待作为其他线程操作的结果而发生的状态更改时，将调用此方法。  
  
 超时可确保当另一个线程释放该锁，而不首先调用或方法时，当前线程不会无限期地阻止 <xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A> 。 它还会将线程移动到就绪队列，绕过等待队列中的其他线程，以便它可以更快地重新获取锁定。 线程可以测试方法的返回值 <xref:System.Threading.Monitor.Wait%2A> ，以确定它是否在超时前重新获取该锁。线程可以计算导致其进入等待状态的条件，并在必要时 <xref:System.Threading.Monitor.Wait%2A> 再次调用方法。  
  
 当线程调用时 `Wait` ，它会释放该锁并进入等待队列。 此时，准备就绪的队列中的下一个线程 (如果允许一个) 控制该锁。 调用的线程将 `Wait` 保留在等待队列中，直到持有锁的线程调用 <xref:System.Threading.Monitor.PulseAll%2A> ，或者它是队列中的下一线程以及持有锁的线程调用 <xref:System.Threading.Monitor.Pulse%2A> 。 但是，如果在 `millisecondsTimeout` 另一个线程调用此对象的 <xref:System.Threading.Monitor.Pulse%2A> 或 <xref:System.Threading.Monitor.PulseAll%2A> 方法之前已过，则原始线程将移到就绪队列，以便重新获取锁定。  
  
> [!NOTE]
>  如果 <xref:System.Threading.Timeout.Infinite> 为 `millisecondsTimeout` 参数指定，则此方法会无限期地阻止，除非锁的持有方调用 <xref:System.Threading.Monitor.Pulse%2A> 或 <xref:System.Threading.Monitor.PulseAll%2A> 。 如果 `millisecondsTimeout` 等于0，则调用的线程将 `Wait` 释放该锁，然后立即进入就绪队列以便重新获取锁。  
  
 `Wait`无论 <xref:System.Threading.Monitor.Enter%2A> 为指定的对象调用了多少次，调用方都将执行一次。 从概念上讲，此 `Wait` 方法存储调用方 <xref:System.Threading.Monitor.Enter%2A> 在对象上调用的次数，并按 <xref:System.Threading.Monitor.Exit%2A> 需多次调用以完全释放锁定的对象。 然后，调用方在等待重新获取对象时阻止。 当调用方重新获取该域锁定时，系统会根据 <xref:System.Threading.Monitor.Enter%2A> 需要多次调用以还原调用方的已保存 <xref:System.Threading.Monitor.Enter%2A> 计数。 调用 `Wait` 只释放指定对象的锁; 如果调用方是其他对象的锁的所有者，则不释放这些锁。  
  
> [!NOTE]
>  同步的对象包含多个引用，包括对当前持有锁的线程的引用、对就绪队列的引用、包含准备好获取锁的线程的引用以及对等待队列的引用（其中包含等待对象状态更改通知的线程）。  
  
 <xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A> `Wait` 必须从同步的代码块中调用、和方法。  
  
 方法的备注 <xref:System.Threading.Monitor.Pulse%2A> 说明 <xref:System.Threading.Monitor.Pulse%2A> 了在没有线程等待时调用时所发生的情况。  
  
## <a name="notes-on-exiting-the-context"></a>有关退出上下文的说明  
 `exitContext`除非 <xref:System.Threading.Monitor.Wait%2A> 从非默认托管上下文内调用方法，否则参数不起作用。 如果你的线程在对从派生的类的实例的调用中，则可能会发生这种情况 <xref:System.ContextBoundObject> 。 即使当前正在对不是从派生的类 <xref:System.ContextBoundObject> （如）执行方法，如果在 <xref:System.String> <xref:System.ContextBoundObject> 当前应用程序域中的堆栈上，也可以在非默认上下文中执行。  
  
 当你的代码在非默认上下文中执行时，为指定将 `true` `exitContext` 导致线程退出非默认的托管上下文 (也就是说，在执行方法前转换为默认上下文) <xref:System.Threading.Monitor.Wait%2A> 。 此方法在调用方法完成后返回到原始的非默认上下文 <xref:System.Threading.Monitor.Wait%2A> 。  
  
 当上下文绑定类应用了属性时，这会很有用 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> 。 在这种情况下，对类成员的所有调用都将自动同步，同步域是类的整个代码正文。 如果成员的调用堆栈中的代码调用 <xref:System.Threading.Monitor.Wait%2A> 方法并 `true` 为指定 `exitContext` ，则线程将退出同步域，从而允许在对对象的任何成员的调用上被阻止的线程继续。 当 <xref:System.Threading.Monitor.Wait%2A> 方法返回时，进行调用的线程必须等待重新进入同步域。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><see langword="Wait" /> 不是从同步的代码块中调用的。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">调用 <see langword="Wait" /> 的线程稍后从等待状态中断。 另一线程调用此线程的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法时将发生这种情况。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> 参数值为负且不等于 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="/dotnet/standard/threading/">托管线程处理</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="obj">要在其上等待的对象。</param>
        <param name="timeout"><see cref="T:System.TimeSpan" />，表示线程进入就绪队列之前等待的时间量。</param>
        <param name="exitContext">如果在等待前退出并重新获取上下文的同步域（如果在同步上下文中），则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>释放对象上的锁并阻止当前线程，直到它重新获取该锁。 如果已用指定的超时时间间隔，则线程进入就绪队列。 可以在等待之前退出同步上下文的同步域，随后重新获取该域。</summary>
        <returns>如果在指定的时间过期之前重新获取该锁，则为 <see langword="true" />；如果在指定的时间过期之后重新获取该锁，则为 <see langword="false" />。 此方法只有在重新获取该锁后才会返回。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法在重新获取该域参数的排他锁之前不会返回 `obj` 。  
  
 当前拥有指定对象的锁的线程调用此方法以释放该对象，以便其他线程可以访问它。 等待重新获取该锁时，调用方被阻止。 当调用方需要等待作为其他线程操作的结果而发生的状态更改时，将调用此方法。  
  
 超时可确保当另一个线程释放该锁，而不首先调用或方法时，当前线程不会无限期地阻止 <xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A> 。 它还会将线程移动到就绪队列，绕过等待队列中的其他线程，以便它可以更快地重新获取锁定。 线程可以测试方法的返回值 <xref:System.Threading.Monitor.Wait%2A> ，以确定它是否在超时前重新获取该锁。线程可以计算导致其进入等待状态的条件，并在必要时 <xref:System.Threading.Monitor.Wait%2A> 再次调用方法。  
  
 当线程调用时 `Wait` ，它会释放该锁并进入等待队列。 此时，准备就绪的队列中的下一个线程 (如果允许一个) 控制该锁。 调用的线程将 `Wait` 保留在等待队列中，直到持有锁的线程调用 <xref:System.Threading.Monitor.PulseAll%2A> ，或者它是队列中的下一线程以及持有锁的线程调用 <xref:System.Threading.Monitor.Pulse%2A> 。 但是，如果 `timeout` 在另一个线程调用此对象的或方法之前经过了毫秒 <xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A> ，则原始线程将移到就绪队列，以便重新获得锁定。  
  
> [!NOTE]
>  如果为 <xref:System.TimeSpan> 参数指定了表示-1 毫秒的 `timeout` ，则此方法会无限期阻止，除非锁的持有方调用 <xref:System.Threading.Monitor.Pulse%2A> 或 <xref:System.Threading.Monitor.PulseAll%2A> 。 如果 `timeout` 为0毫秒，则调用的线程将 `Wait` 释放该锁，然后立即进入就绪队列以便重新获取锁。  
  
 `Wait`无论 <xref:System.Threading.Monitor.Enter%2A> 为指定的对象调用了多少次，调用方都将执行一次。 从概念上讲，此 `Wait` 方法存储调用方 <xref:System.Threading.Monitor.Enter%2A> 在对象上调用的次数，并按 <xref:System.Threading.Monitor.Exit%2A> 需多次调用以完全释放锁定的对象。 然后，调用方在等待重新获取对象时阻止。 当调用方重新获取该域锁定时，系统会根据 <xref:System.Threading.Monitor.Enter%2A> 需要多次调用以还原调用方的已保存 <xref:System.Threading.Monitor.Enter%2A> 计数。 调用 `Wait` 只释放指定对象的锁; 如果调用方是其他对象的锁的所有者，则不释放这些锁。  
  
> [!NOTE]
>  同步的对象包含多个引用，包括对当前持有锁的线程的引用、对就绪队列的引用、包含准备好获取锁的线程的引用以及对等待队列的引用（其中包含等待对象状态更改通知的线程）。  
  
 <xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A> `Wait` 必须从同步的代码块中调用、和方法。  
  
 方法的备注 <xref:System.Threading.Monitor.Pulse%2A> 说明 <xref:System.Threading.Monitor.Pulse%2A> 了在没有线程等待时调用时所发生的情况。  
  
## <a name="notes-on-exiting-the-context"></a>有关退出上下文的说明  
 `exitContext`除非 <xref:System.Threading.Monitor.Wait%2A> 从非默认托管上下文内调用方法，否则参数不起作用。 如果你的线程在对从派生的类的实例的调用中，则可能会发生这种情况 <xref:System.ContextBoundObject> 。 即使当前正在对不是从派生的类 <xref:System.ContextBoundObject> （如）执行方法，如果在 <xref:System.String> <xref:System.ContextBoundObject> 当前应用程序域中的堆栈上，也可以在非默认上下文中执行。  
  
 当你的代码在非默认上下文中执行时，为指定将 `true` `exitContext` 导致线程退出非默认的托管上下文 (也就是说，在执行方法前转换为默认上下文) <xref:System.Threading.Monitor.Wait%2A> 。 此方法在调用方法完成后返回到原始的非默认上下文 <xref:System.Threading.Monitor.Wait%2A> 。  
  
 当上下文绑定类应用了属性时，这会很有用 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> 。 在这种情况下，对类成员的所有调用都将自动同步，同步域是类的整个代码正文。 如果成员的调用堆栈中的代码调用 <xref:System.Threading.Monitor.Wait%2A> 方法并 `true` 为指定 `exitContext` ，则线程将退出同步域，从而允许在对对象的任何成员的调用上被阻止的线程继续。 当 <xref:System.Threading.Monitor.Wait%2A> 方法返回时，进行调用的线程必须等待重新进入同步域。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><see langword="Wait" /> 不是从同步的代码块中调用的。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">调用 Wait 的线程稍后会从等待状态中中断。 另一线程调用此线程的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法时将发生这种情况。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> 参数为负数且不表示 <see cref="F:System.Threading.Timeout.Infinite" />（-1 毫秒），或者大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="/dotnet/standard/threading/">托管线程处理</related>
      </Docs>
    </Member>
  </Members>
</Type>
