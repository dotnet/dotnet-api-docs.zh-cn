<Type Name="PEHeaders" FullName="System.Reflection.PortableExecutable.PEHeaders">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3810bbb10d14dc5984aedc04543adf452d64fafd" /><Meta Name="ms.sourcegitcommit" Value="c982ad9e10a242d90f1e631b5981570f9e5d9f34" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/10/2020" /><Meta Name="ms.locfileid" Value="89911379" /></Metadata><TypeSignature Language="C#" Value="public sealed class PEHeaders" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit PEHeaders extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.PortableExecutable.PEHeaders" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class PEHeaders" />
  <TypeSignature Language="C++ CLI" Value="public ref class PEHeaders sealed" />
  <TypeSignature Language="F#" Value="type PEHeaders = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Metadata</AssemblyName>
    <AssemblyVersion>1.0.22.0</AssemblyVersion>
    <AssemblyVersion>1.3.0.0</AssemblyVersion>
    <AssemblyVersion>1.4.1.0</AssemblyVersion>
    <AssemblyVersion>1.4.2.0</AssemblyVersion>
    <AssemblyVersion>1.4.3.0</AssemblyVersion>
    <AssemblyVersion>1.4.4.0</AssemblyVersion>
    <AssemblyVersion>1.4.5.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="9b07b-101">定义从流中读取 PE（可移植可执行文件）和 COFF（通用对象文件格式）标头。</span><span class="sxs-lookup"><span data-stu-id="9b07b-101">Defines a type that reads PE (Portable Executable) and COFF (Common Object File Format) headers from a stream.</span></span></summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PEHeaders (System.IO.Stream peStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream peStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (peStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PEHeaders(System::IO::Stream ^ peStream);" />
      <MemberSignature Language="F#" Value="new System.Reflection.PortableExecutable.PEHeaders : System.IO.Stream -&gt; System.Reflection.PortableExecutable.PEHeaders" Usage="new System.Reflection.PortableExecutable.PEHeaders peStream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.0.22.0</AssemblyVersion>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="peStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="peStream"><span data-ttu-id="9b07b-102">包含从流的当前位置开始、到流末尾结束的 PE 映像的流。</span><span class="sxs-lookup"><span data-stu-id="9b07b-102">A stream containing the PE image starting at the stream's current position and ending at the end of the stream.</span></span></param>
        <summary><span data-ttu-id="9b07b-103">实例化 <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> 类的新实例，该类从指定流中的当前位置读取 PE 头。</span><span class="sxs-lookup"><span data-stu-id="9b07b-103">Instantiates a new instance of the <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> class that reads the PE headers from the current location in the specified stream.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="9b07b-104">从流中读取的数据的格式无效。</span><span class="sxs-lookup"><span data-stu-id="9b07b-104">The data read from the stream has an invalid format.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="9b07b-105">从流中读取时出错。</span><span class="sxs-lookup"><span data-stu-id="9b07b-105">Error reading from the stream.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9b07b-106">流不支持查找操作。</span><span class="sxs-lookup"><span data-stu-id="9b07b-106">The stream does not support seek operations.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9b07b-107"><paramref name="peStream" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9b07b-107"><paramref name="peStream" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PEHeaders (System.IO.Stream peStream, int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream peStream, int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (peStream As Stream, size As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PEHeaders(System::IO::Stream ^ peStream, int size);" />
      <MemberSignature Language="F#" Value="new System.Reflection.PortableExecutable.PEHeaders : System.IO.Stream * int -&gt; System.Reflection.PortableExecutable.PEHeaders" Usage="new System.Reflection.PortableExecutable.PEHeaders (peStream, size)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.0.22.0</AssemblyVersion>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="peStream" Type="System.IO.Stream" />
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="peStream"><span data-ttu-id="9b07b-108">包含给定大小（从其当前位置开始）的 PE 映像的流。</span><span class="sxs-lookup"><span data-stu-id="9b07b-108">A stream containing PE image of the given size starting at its current position.</span></span></param>
        <param name="size"><span data-ttu-id="9b07b-109">PE 映像的大小。</span><span class="sxs-lookup"><span data-stu-id="9b07b-109">The size of the PE image.</span></span></param>
        <summary><span data-ttu-id="9b07b-110">实例化 <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> 类的新实例，该类从代表指定大小的 PE 映像的流中读取 PE 头。</span><span class="sxs-lookup"><span data-stu-id="9b07b-110">Instantiates a new instance of the <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> class that reads the PE headers from a stream that represents a PE image of a specified size.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="9b07b-111">从流中读取的数据的格式无效。</span><span class="sxs-lookup"><span data-stu-id="9b07b-111">The data read from the stream has an invalid format.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="9b07b-112">从流中读取时出错。</span><span class="sxs-lookup"><span data-stu-id="9b07b-112">Error reading from the stream.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9b07b-113">流不支持查找操作。</span><span class="sxs-lookup"><span data-stu-id="9b07b-113">The stream does not support seek operations.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9b07b-114"><paramref name="peStream" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9b07b-114"><paramref name="peStream" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9b07b-115"><paramref name="size" /> 为负或超出了流的末尾。</span><span class="sxs-lookup"><span data-stu-id="9b07b-115"><paramref name="size" /> is negative or extends past the end of the stream.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PEHeaders (System.IO.Stream peStream, int size, bool isLoadedImage);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream peStream, int32 size, bool isLoadedImage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (peStream As Stream, size As Integer, isLoadedImage As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PEHeaders(System::IO::Stream ^ peStream, int size, bool isLoadedImage);" />
      <MemberSignature Language="F#" Value="new System.Reflection.PortableExecutable.PEHeaders : System.IO.Stream * int * bool -&gt; System.Reflection.PortableExecutable.PEHeaders" Usage="new System.Reflection.PortableExecutable.PEHeaders (peStream, size, isLoadedImage)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="peStream" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="isLoadedImage" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="peStream"><span data-ttu-id="9b07b-116">包含给定大小（从其当前位置开始）的 PE 映像的流。</span><span class="sxs-lookup"><span data-stu-id="9b07b-116">The stream containing PE image of the given size starting at its current position.</span></span></param>
        <param name="size"><span data-ttu-id="9b07b-117">PE 映像的大小。</span><span class="sxs-lookup"><span data-stu-id="9b07b-117">The size of the PE image.</span></span></param>
        <param name="isLoadedImage"><span data-ttu-id="9b07b-118">如果 OS 加载程序已将 PE 映像加载到内存中，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9b07b-118"><see langword="true" /> if the PE image has been loaded into memory by the OS loader; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="9b07b-119">实例化 <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> 类的新实例，该类从代表指定大小的 PE 映像的流中读取 PE 头，并指示该 PE 映像是否已加载到内存中。</span><span class="sxs-lookup"><span data-stu-id="9b07b-119">Instantiates a new instance of the <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> class that reads the PE headers from a stream that represents a PE image of a specified size and indicates whether the PE image has been loaded into memory.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="9b07b-120">从流中读取的数据的格式无效。</span><span class="sxs-lookup"><span data-stu-id="9b07b-120">The data read from the stream has invalid format.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="9b07b-121">从流中读取时出错。</span><span class="sxs-lookup"><span data-stu-id="9b07b-121">Error reading from the stream.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9b07b-122">流不支持查找操作。</span><span class="sxs-lookup"><span data-stu-id="9b07b-122">The stream does not support seek operations.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9b07b-123"><paramref name="peStream" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9b07b-123"><paramref name="peStream" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9b07b-124"><paramref name="size" /> 为负或超出了流的末尾。</span><span class="sxs-lookup"><span data-stu-id="9b07b-124"><paramref name="size" /> is negative or extends past the end of the stream.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CoffHeader">
      <MemberSignature Language="C#" Value="public System.Reflection.PortableExecutable.CoffHeader CoffHeader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.PortableExecutable.CoffHeader CoffHeader" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeader" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CoffHeader As CoffHeader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::PortableExecutable::CoffHeader ^ CoffHeader { System::Reflection::PortableExecutable::CoffHeader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CoffHeader : System.Reflection.PortableExecutable.CoffHeader" Usage="System.Reflection.PortableExecutable.PEHeaders.CoffHeader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.0.22.0</AssemblyVersion>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PortableExecutable.CoffHeader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9b07b-125">获取映像的 COFF 标头。</span><span class="sxs-lookup"><span data-stu-id="9b07b-125">Gets the COFF header of the image.</span></span></summary>
        <value><span data-ttu-id="9b07b-126">图像的 COFF 标头。</span><span class="sxs-lookup"><span data-stu-id="9b07b-126">The COFF header of the image.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CoffHeaderStartOffset">
      <MemberSignature Language="C#" Value="public int CoffHeaderStartOffset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CoffHeaderStartOffset" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeaderStartOffset" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CoffHeaderStartOffset As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CoffHeaderStartOffset { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CoffHeaderStartOffset : int" Usage="System.Reflection.PortableExecutable.PEHeaders.CoffHeaderStartOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.0.22.0</AssemblyVersion>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9b07b-127">获取从 PE 映像的开头到 COFF 标头的开头的字节偏移量。</span><span class="sxs-lookup"><span data-stu-id="9b07b-127">Gets the byte offset from the start of the PE image to the start of the COFF header.</span></span></summary>
        <value><span data-ttu-id="9b07b-128">从 PE 映像开始到 COFF 标头开始的字节偏移量。</span><span class="sxs-lookup"><span data-stu-id="9b07b-128">The byte offset from the start of the PE image to the start of the COFF header.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CorHeader">
      <MemberSignature Language="C#" Value="public System.Reflection.PortableExecutable.CorHeader CorHeader { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.PortableExecutable.CorHeader CorHeader" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.PortableExecutable.PEHeaders.CorHeader" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CorHeader As CorHeader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::PortableExecutable::CorHeader ^ CorHeader { System::Reflection::PortableExecutable::CorHeader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CorHeader : System.Reflection.PortableExecutable.CorHeader" Usage="System.Reflection.PortableExecutable.PEHeaders.CorHeader" />
      <MemberSignature Language="C#" Value="public System.Reflection.PortableExecutable.CorHeader? CorHeader { get; }" FrameworkAlternate="net-5.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.0.22.0</AssemblyVersion>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PortableExecutable.CorHeader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9b07b-129">获取 COR 标头。</span><span class="sxs-lookup"><span data-stu-id="9b07b-129">Gets the COR header.</span></span></summary>
        <value><span data-ttu-id="9b07b-130">COR 标头; 如果图像没有该标头，则为 <see langword="null" /> 。</span><span class="sxs-lookup"><span data-stu-id="9b07b-130">The COR header, or <see langword="null" /> if the image does not have one.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CorHeaderStartOffset">
      <MemberSignature Language="C#" Value="public int CorHeaderStartOffset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CorHeaderStartOffset" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.PortableExecutable.PEHeaders.CorHeaderStartOffset" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CorHeaderStartOffset As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CorHeaderStartOffset { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CorHeaderStartOffset : int" Usage="System.Reflection.PortableExecutable.PEHeaders.CorHeaderStartOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.0.22.0</AssemblyVersion>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9b07b-131">获取从映像开头到 COR 标头的字节偏移量。</span><span class="sxs-lookup"><span data-stu-id="9b07b-131">Gets the byte offset from the start of the image to the COR header.</span></span></summary>
        <value><span data-ttu-id="9b07b-132">从图像开头到 COR 标头的字节偏移量; 如果图像没有 COR 标头，则为-1。</span><span class="sxs-lookup"><span data-stu-id="9b07b-132">The byte offset from the start of the image to the COR header, or -1 if the image does not have a COR header.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetContainingSectionIndex">
      <MemberSignature Language="C#" Value="public int GetContainingSectionIndex (int relativeVirtualAddress);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetContainingSectionIndex(int32 relativeVirtualAddress) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PortableExecutable.PEHeaders.GetContainingSectionIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContainingSectionIndex (relativeVirtualAddress As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetContainingSectionIndex(int relativeVirtualAddress);" />
      <MemberSignature Language="F#" Value="member this.GetContainingSectionIndex : int -&gt; int" Usage="pEHeaders.GetContainingSectionIndex relativeVirtualAddress" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.0.22.0</AssemblyVersion>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeVirtualAddress" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="relativeVirtualAddress"><span data-ttu-id="9b07b-133">要搜索的相对虚拟地址。</span><span class="sxs-lookup"><span data-stu-id="9b07b-133">The relative virtual address to search for.</span></span></param>
        <summary><span data-ttu-id="9b07b-134">在 PE 映像的节中搜索包含指定相对虚拟地址的节。</span><span class="sxs-lookup"><span data-stu-id="9b07b-134">Searches sections of the PE image for the section that contains the specified Relative Virtual Address.</span></span></summary>
        <returns><span data-ttu-id="9b07b-135">包含 <paramref name="relativeVirtualAddress" /> 的节的索引，或者为 -1（如果搜索不成功）。</span><span class="sxs-lookup"><span data-stu-id="9b07b-135">The index of the section that contains <paramref name="relativeVirtualAddress" />, or -1 if there the search is unsuccessful.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCoffOnly">
      <MemberSignature Language="C#" Value="public bool IsCoffOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCoffOnly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.PortableExecutable.PEHeaders.IsCoffOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCoffOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCoffOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCoffOnly : bool" Usage="System.Reflection.PortableExecutable.PEHeaders.IsCoffOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.0.22.0</AssemblyVersion>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9b07b-136">获取一个值，该值指示映像是否仅为 Coff。</span><span class="sxs-lookup"><span data-stu-id="9b07b-136">Gets a value that indicates whether the image is Coff only.</span></span></summary>
        <value><span data-ttu-id="9b07b-137"><see langword="true" /> 如果图像仅为 Coff，则为;否则为 <see langword="false" /> 。</span><span class="sxs-lookup"><span data-stu-id="9b07b-137"><see langword="true" /> if the image is Coff only; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConsoleApplication">
      <MemberSignature Language="C#" Value="public bool IsConsoleApplication { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConsoleApplication" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.PortableExecutable.PEHeaders.IsConsoleApplication" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsConsoleApplication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsConsoleApplication { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConsoleApplication : bool" Usage="System.Reflection.PortableExecutable.PEHeaders.IsConsoleApplication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.0.22.0</AssemblyVersion>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9b07b-138">获取一个值，该值指示映像是否表示 Windows 控制台应用程序。</span><span class="sxs-lookup"><span data-stu-id="9b07b-138">Gets a value that indicates whether the image represents a Windows console application.</span></span></summary>
        <value><span data-ttu-id="9b07b-139"><see langword="true" /> 如果图像是 Windows 控制台应用程序，则为;否则为 <see langword="false" /> 。</span><span class="sxs-lookup"><span data-stu-id="9b07b-139"><see langword="true" /> if the image is a Windows console applications; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDll">
      <MemberSignature Language="C#" Value="public bool IsDll { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDll" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.PortableExecutable.PEHeaders.IsDll" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDll As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDll { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDll : bool" Usage="System.Reflection.PortableExecutable.PEHeaders.IsDll" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.0.22.0</AssemblyVersion>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9b07b-140">获取一个值，该值指示映像是否表示动态链接库。</span><span class="sxs-lookup"><span data-stu-id="9b07b-140">Gets a value that indicates whether the image represents a dynamic link library.</span></span></summary>
        <value><span data-ttu-id="9b07b-141"><see langword="true" /> 如果图像是一个 DLL，则为; 否则为。否则为 <see langword="false" /> 。</span><span class="sxs-lookup"><span data-stu-id="9b07b-141"><see langword="true" /> if the image is a DLL; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExe">
      <MemberSignature Language="C#" Value="public bool IsExe { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExe" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.PortableExecutable.PEHeaders.IsExe" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExe As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExe { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExe : bool" Usage="System.Reflection.PortableExecutable.PEHeaders.IsExe" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.0.22.0</AssemblyVersion>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9b07b-142">获取一个值，该值指示映像是否表示可执行文件。</span><span class="sxs-lookup"><span data-stu-id="9b07b-142">Gets a value that indicates whether the image represents an executable.</span></span></summary>
        <value><span data-ttu-id="9b07b-143"><see langword="true" /> 如果图像是可执行文件，则为; 否则为。否则为 <see langword="false" /> 。</span><span class="sxs-lookup"><span data-stu-id="9b07b-143"><see langword="true" /> if the image is an executable; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MetadataSize">
      <MemberSignature Language="C#" Value="public int MetadataSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MetadataSize" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.PortableExecutable.PEHeaders.MetadataSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MetadataSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MetadataSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MetadataSize : int" Usage="System.Reflection.PortableExecutable.PEHeaders.MetadataSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.0.22.0</AssemblyVersion>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9b07b-144">获取 CLI 元数据的大小。</span><span class="sxs-lookup"><span data-stu-id="9b07b-144">Gets the size of the CLI metadata.</span></span></summary>
        <value><span data-ttu-id="9b07b-145">CLI 元数据的大小; 如果该图像不包含元数据，则为0。</span><span class="sxs-lookup"><span data-stu-id="9b07b-145">the size of the CLI metadata, or 0 if the image does not contain metadata.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MetadataStartOffset">
      <MemberSignature Language="C#" Value="public int MetadataStartOffset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MetadataStartOffset" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.PortableExecutable.PEHeaders.MetadataStartOffset" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MetadataStartOffset As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MetadataStartOffset { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MetadataStartOffset : int" Usage="System.Reflection.PortableExecutable.PEHeaders.MetadataStartOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.0.22.0</AssemblyVersion>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9b07b-146">获取从 PE 映像的开头到 CLI 元数据的开头的偏移量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="9b07b-146">Gets the offset (in bytes) from the start of the PE image to the start of the CLI metadata.</span></span></summary>
        <value><span data-ttu-id="9b07b-147">偏移量 (以字节为单位) 从 PE 映像的开始到 CLI 元数据的开始，或者-1 （如果该图像不包含元数据）。</span><span class="sxs-lookup"><span data-stu-id="9b07b-147">The offset (in bytes) from the start of the PE image to the start of the CLI metadata, or -1 if the image does not contain metadata.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PEHeader">
      <MemberSignature Language="C#" Value="public System.Reflection.PortableExecutable.PEHeader PEHeader { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.PortableExecutable.PEHeader PEHeader" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.PortableExecutable.PEHeaders.PEHeader" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PEHeader As PEHeader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::PortableExecutable::PEHeader ^ PEHeader { System::Reflection::PortableExecutable::PEHeader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PEHeader : System.Reflection.PortableExecutable.PEHeader" Usage="System.Reflection.PortableExecutable.PEHeaders.PEHeader" />
      <MemberSignature Language="C#" Value="public System.Reflection.PortableExecutable.PEHeader? PEHeader { get; }" FrameworkAlternate="net-5.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.0.22.0</AssemblyVersion>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PortableExecutable.PEHeader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9b07b-148">获取映像的 PE 头。</span><span class="sxs-lookup"><span data-stu-id="9b07b-148">Gets the image's PE header.</span></span></summary>
        <value><span data-ttu-id="9b07b-149">图像的 PE 标头; <see langword="null" /> 如果图像仅为 COFF，则为。</span><span class="sxs-lookup"><span data-stu-id="9b07b-149">The image's PE header, or <see langword="null" /> if the image is COFF only.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PEHeaderStartOffset">
      <MemberSignature Language="C#" Value="public int PEHeaderStartOffset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PEHeaderStartOffset" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.PortableExecutable.PEHeaders.PEHeaderStartOffset" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PEHeaderStartOffset As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PEHeaderStartOffset { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PEHeaderStartOffset : int" Usage="System.Reflection.PortableExecutable.PEHeaders.PEHeaderStartOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.0.22.0</AssemblyVersion>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9b07b-150">获取从映像开头的标头的字节偏移量。</span><span class="sxs-lookup"><span data-stu-id="9b07b-150">Gets the byte offset of the header from the start of the image.</span></span></summary>
        <value><span data-ttu-id="9b07b-151">从图像开头开始的标头的字节偏移量。</span><span class="sxs-lookup"><span data-stu-id="9b07b-151">The byte offset of the header from the start of the image.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SectionHeaders">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableArray&lt;System.Reflection.PortableExecutable.SectionHeader&gt; SectionHeaders { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;valuetype System.Reflection.PortableExecutable.SectionHeader&gt; SectionHeaders" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.PortableExecutable.PEHeaders.SectionHeaders" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SectionHeaders As ImmutableArray(Of SectionHeader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Immutable::ImmutableArray&lt;System::Reflection::PortableExecutable::SectionHeader&gt; SectionHeaders { System::Collections::Immutable::ImmutableArray&lt;System::Reflection::PortableExecutable::SectionHeader&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.SectionHeaders : System.Collections.Immutable.ImmutableArray&lt;System.Reflection.PortableExecutable.SectionHeader&gt;" Usage="System.Reflection.PortableExecutable.PEHeaders.SectionHeaders" />
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableArray&lt;System.Reflection.PortableExecutable.SectionHeader&gt;? SectionHeaders { get; }" FrameworkAlternate="net-5.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.0.22.0</AssemblyVersion>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;System.Reflection.PortableExecutable.SectionHeader&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9b07b-152">获取 PE 节标头。</span><span class="sxs-lookup"><span data-stu-id="9b07b-152">Gets the PE section headers.</span></span></summary>
        <value><span data-ttu-id="9b07b-153">包含 PE 节标头的数组。</span><span class="sxs-lookup"><span data-stu-id="9b07b-153">An array containing the PE section headers.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetDirectoryOffset">
      <MemberSignature Language="C#" Value="public bool TryGetDirectoryOffset (System.Reflection.PortableExecutable.DirectoryEntry directory, out int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetDirectoryOffset(valuetype System.Reflection.PortableExecutable.DirectoryEntry directory, [out] int32&amp; offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.PortableExecutable.PEHeaders.TryGetDirectoryOffset(System.Reflection.PortableExecutable.DirectoryEntry,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetDirectoryOffset (directory As DirectoryEntry, ByRef offset As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetDirectoryOffset(System::Reflection::PortableExecutable::DirectoryEntry directory, [Runtime::InteropServices::Out] int % offset);" />
      <MemberSignature Language="F#" Value="member this.TryGetDirectoryOffset : System.Reflection.PortableExecutable.DirectoryEntry * int -&gt; bool" Usage="pEHeaders.TryGetDirectoryOffset (directory, offset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.0.22.0</AssemblyVersion>
        <AssemblyVersion>1.3.0.0</AssemblyVersion>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.Reflection.PortableExecutable.DirectoryEntry" />
        <Parameter Name="offset" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="directory"><span data-ttu-id="9b07b-154">PE 目录项。</span><span class="sxs-lookup"><span data-stu-id="9b07b-154">The PE directory entry.</span></span></param>
        <param name="offset"><span data-ttu-id="9b07b-155">方法返回时，包含从映像开头到给定目录数据的偏移量。</span><span class="sxs-lookup"><span data-stu-id="9b07b-155">When the method returns, contains the offset from the start of the image to the given directory data.</span></span></param>
        <summary><span data-ttu-id="9b07b-156">获取从映像开头到给定目录数据的偏移量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="9b07b-156">Gets the offset (in bytes) from the start of the image to the given directory data.</span></span></summary>
        <returns><span data-ttu-id="9b07b-157">如果找到目录数据，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9b07b-157"><see langword="true" /> if the directory data is found; <see langword="false" /> otherwise.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
