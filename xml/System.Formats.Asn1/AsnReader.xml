<Type Name="AsnReader" FullName="System.Formats.Asn1.AsnReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="788ea251768408281f0c4bcd8dfb6be8a05d50d3" /><Meta Name="ms.sourcegitcommit" Value="2f78d0752398ee2d15afbf06143cb62a01dc6d71" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/14/2020" /><Meta Name="ms.locfileid" Value="88242605" /></Metadata><TypeSignature Language="C#" Value="public class AsnReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit AsnReader extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Formats.Asn1.AsnReader" />
  <TypeSignature Language="VB.NET" Value="Public Class AsnReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class AsnReader" />
  <TypeSignature Language="F#" Value="type AsnReader = class" />
  <AssemblyInfo>
    <AssemblyName>System.Formats.Asn1</AssemblyName>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>用于 BER 编码、CER 编码或 DER 编码的 ASN.1 数据的监控状态的只进读取器。</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AsnReader (ReadOnlyMemory&lt;byte&gt; data, System.Formats.Asn1.AsnEncodingRules ruleSet, System.Formats.Asn1.AsnReaderOptions options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; data, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, valuetype System.Formats.Asn1.AsnReaderOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.#ctor(System.ReadOnlyMemory{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Formats.Asn1.AsnReaderOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (data As ReadOnlyMemory(Of Byte), ruleSet As AsnEncodingRules, Optional options As AsnReaderOptions = Nothing)" />
      <MemberSignature Language="F#" Value="new System.Formats.Asn1.AsnReader : ReadOnlyMemory&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * System.Formats.Asn1.AsnReaderOptions -&gt; System.Formats.Asn1.AsnReader" Usage="new System.Formats.Asn1.AsnReader (data, ruleSet, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="data" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="options" Type="System.Formats.Asn1.AsnReaderOptions" />
      </Parameters>
      <Docs>
        <param name="data">要读取的数据。</param>
        <param name="ruleSet">对读取器的编码约束。</param>
        <param name="options">读取器的附加选项。</param>
        <summary>使用给定的规则集对 <paramref name="data" /> 构造 <see cref="T:System.Formats.Asn1.AsnReader" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

此构造函数不会计算是否 `data` 正确，任何正确性检查都作为成员方法的一部分来完成。
此构造函数不会复制 `data` 。 调用方负责确保在完成读取器之前值不会更改。

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="HasData">
      <MemberSignature Language="C#" Value="public bool HasData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasData" />
      <MemberSignature Language="DocId" Value="P:System.Formats.Asn1.AsnReader.HasData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasData As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasData { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasData : bool" Usage="System.Formats.Asn1.AsnReader.HasData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取有关读取器是否具有可供处理的剩余数据的指示。</summary>
        <value><see langword="true" /> 如果有更多数据可供读取器处理，则为;否则为 <see langword="false" /> 。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PeekContentBytes">
      <MemberSignature Language="C#" Value="public ReadOnlyMemory&lt;byte&gt; PeekContentBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; PeekContentBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.PeekContentBytes" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekContentBytes () As ReadOnlyMemory(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReadOnlyMemory&lt;System::Byte&gt; PeekContentBytes();" />
      <MemberSignature Language="F#" Value="member this.PeekContentBytes : unit -&gt; ReadOnlyMemory&lt;byte&gt;" Usage="asnReader.PeekContentBytes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取下一个编码值的内容八进制（字节）的 <see cref="T:System.ReadOnlyMemory`1" /> 视图（读取器不会前进）。</summary>
        <returns>下一个编码值的内容八进制字节。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">读取器定位在当前编码规则下的标记或长度无效的点上。</exception>
      </Docs>
    </Member>
    <Member MemberName="PeekEncodedValue">
      <MemberSignature Language="C#" Value="public ReadOnlyMemory&lt;byte&gt; PeekEncodedValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; PeekEncodedValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.PeekEncodedValue" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekEncodedValue () As ReadOnlyMemory(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReadOnlyMemory&lt;System::Byte&gt; PeekEncodedValue();" />
      <MemberSignature Language="F#" Value="member this.PeekEncodedValue : unit -&gt; ReadOnlyMemory&lt;byte&gt;" Usage="asnReader.PeekEncodedValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取下一个编码值的 <see cref="T:System.ReadOnlyMemory`1" /> 视图（读取器不会前进）。 对于不确定长度的编码，这包括内容结束标记。</summary>
        <returns>下一个编码值的字节。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">读取器定位在当前编码规则下的标记或长度无效的点上。</exception>
      </Docs>
    </Member>
    <Member MemberName="PeekTag">
      <MemberSignature Language="C#" Value="public System.Formats.Asn1.Asn1Tag PeekTag ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Formats.Asn1.Asn1Tag PeekTag() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.PeekTag" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekTag () As Asn1Tag" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Formats::Asn1::Asn1Tag PeekTag();" />
      <MemberSignature Language="F#" Value="member this.PeekTag : unit -&gt; System.Formats.Asn1.Asn1Tag" Usage="asnReader.PeekTag " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Formats.Asn1.Asn1Tag</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>读取下一个数据位置的编码标记（读取器不会前进）。</summary>
        <returns>已解码的标记值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">不能在读取器的当前位置对标记进行解码。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBitString">
      <MemberSignature Language="C#" Value="public byte[] ReadBitString (out int unusedBitCount, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ReadBitString([out] int32&amp; unusedBitCount, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadBitString(System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadBitString (ByRef unusedBitCount As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Byte()" />
      <MemberSignature Language="F#" Value="member this.ReadBitString : int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; byte[]" Usage="asnReader.ReadBitString (unusedBitCount, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unusedBitCount" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="unusedBitCount">成功时，将接收由编写器报告为“未使用”的最后一个字节中的位数。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 1）。</param>
        <summary>读取下一个值，作为带有指定标记的 BIT STRING 值，并以字节数组形式返回该值。</summary>
        <returns>一个新分配的、精确大小的数组中的值的副本。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBoolean">
      <MemberSignature Language="C#" Value="public bool ReadBoolean (System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReadBoolean(valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadBoolean(System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadBoolean (Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="member this.ReadBoolean : Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="asnReader.ReadBoolean expectedTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 1）。</param>
        <summary>读取下一个值，作为带有指定标记的布尔值。</summary>
        <returns>已解码的值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadCharacterString">
      <MemberSignature Language="C#" Value="public string ReadCharacterString (System.Formats.Asn1.UniversalTagNumber encodingType, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ReadCharacterString(valuetype System.Formats.Asn1.UniversalTagNumber encodingType, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadCharacterString(System.Formats.Asn1.UniversalTagNumber,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadCharacterString (encodingType As UniversalTagNumber, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As String" />
      <MemberSignature Language="F#" Value="member this.ReadCharacterString : System.Formats.Asn1.UniversalTagNumber * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; string" Usage="asnReader.ReadCharacterString (encodingType, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="encodingType" Type="System.Formats.Asn1.UniversalTagNumber" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="encodingType">枚举值之一，表示要处理的值类型。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为符合请求的编码类型的通用标记。</param>
        <summary>读取下一个值，作为带有指定标记和编码类型的字符串值，并以字符串形式返回该解码值。</summary>
        <returns>已解码的值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="encodingType" /> 不是一个已知的字符串类型。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。
-或- 字符串未成功解码。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 与 <paramref name="encodingType" /> 不同。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadEncodedValue">
      <MemberSignature Language="C#" Value="public ReadOnlyMemory&lt;byte&gt; ReadEncodedValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; ReadEncodedValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadEncodedValue" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadEncodedValue () As ReadOnlyMemory(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReadOnlyMemory&lt;System::Byte&gt; ReadEncodedValue();" />
      <MemberSignature Language="F#" Value="member this.ReadEncodedValue : unit -&gt; ReadOnlyMemory&lt;byte&gt;" Usage="asnReader.ReadEncodedValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取下一个编码值的 <see cref="T:System.ReadOnlyMemory`1" /> 视图，并推进已超过的读取器。 对于不确定长度的编码，这包括内容结束标记。</summary>
        <returns>下一个编码值的 <see cref="T:System.ReadOnlyMemory`1" /> 视图。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadEnumeratedBytes">
      <MemberSignature Language="C#" Value="public ReadOnlyMemory&lt;byte&gt; ReadEnumeratedBytes (System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; ReadEnumeratedBytes(valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadEnumeratedBytes(System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadEnumeratedBytes (Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As ReadOnlyMemory(Of Byte)" />
      <MemberSignature Language="F#" Value="member this.ReadEnumeratedBytes : Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; ReadOnlyMemory&lt;byte&gt;" Usage="asnReader.ReadEnumeratedBytes expectedTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 10）。</param>
        <summary>读取下一个值，作为带有指定标记的枚举值，并以原始数据的 <see cref="T:System.ReadOnlyMemory`1" /> 形式返回内容。</summary>
        <returns>带符号的 Big Endian 格式的枚举值的字节数。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadEnumeratedValue">
      <MemberSignature Language="C#" Value="public Enum ReadEnumeratedValue (Type enumType, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Enum ReadEnumeratedValue(class System.Type enumType, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadEnumeratedValue(System.Type,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadEnumeratedValue (enumType As Type, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Enum" />
      <MemberSignature Language="F#" Value="member this.ReadEnumeratedValue : Type * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; Enum" Usage="asnReader.ReadEnumeratedValue (enumType, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Enum</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="enumType">表示目标类型的类型对象。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 10）。</param>
        <summary>读取下一个值，作为带有指定标记的枚举值，并将其转换为由 <paramref name="enumType" /> 指定的非 [<see cref="T:System.FlagsAttribute" />] 枚举。</summary>
        <returns>转换为 <paramref name="enumType" /> 的枚举值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

此方法不会验证中是否定义了返回值 `enumType` 。

          ]]></format>
        </remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。
-或- 编码值太大，无法容纳 <paramref name="enumType" /> 值。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="enumType" /> 不是一个枚举类型。
-或- <paramref name="enumType" /> 是使用 <see cref="T:System.FlagsAttribute" /> 声明的。
-或- <paramref name="enumType" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="enumType" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="enumType" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadEnumeratedValue&lt;TEnum&gt;">
      <MemberSignature Language="C#" Value="public TEnum ReadEnumeratedValue&lt;TEnum&gt; (System.Formats.Asn1.Asn1Tag? expectedTag = default) where TEnum : Enum;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TEnum ReadEnumeratedValue&lt;(class System.Enum) TEnum&gt;(valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadEnumeratedValue``1(System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadEnumeratedValue(Of TEnum As Enum) (Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As TEnum" />
      <MemberSignature Language="F#" Value="member this.ReadEnumeratedValue : Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; 'Enum (requires 'Enum :&gt; Enum)" Usage="asnReader.ReadEnumeratedValue expectedTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEnum</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEnum">
          <Constraints>
            <BaseTypeName>System.Enum</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TEnum">目标枚举类型</typeparam>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 10）。</param>
        <summary>读取下一个值，作为带有指定标记的枚举值，并将其转换为由 <typeparamref name="TEnum" /> 指定的非 [<see cref="T:System.FlagsAttribute" />] 枚举。</summary>
        <returns>转换为 <typeparamref name="TEnum" /> 的枚举值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

此方法不会验证是否在 <typeparamref name = "TEnum> 中定义了返回值。

          ]]></format>
        </remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。
-或- 编码值太大，无法容纳 <typeparamref name="TEnum" /> 值。</exception>
        <exception cref="T:System.ArgumentException"><typeparamref name="TEnum" /> 不是一个枚举类型。
-或- <typeparamref name="TEnum" /> 是使用 <see cref="T:System.FlagsAttribute" /> 声明的。
-或- <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadGeneralizedTime">
      <MemberSignature Language="C#" Value="public DateTimeOffset ReadGeneralizedTime (System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset ReadGeneralizedTime(valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadGeneralizedTime(System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadGeneralizedTime (Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As DateTimeOffset" />
      <MemberSignature Language="F#" Value="member this.ReadGeneralizedTime : Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; DateTimeOffset" Usage="asnReader.ReadGeneralizedTime expectedTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 24）。</param>
        <summary>读取下一个值，作为带有指定标记的 GeneralizedTime 值。</summary>
        <returns>已解码的值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInteger">
      <MemberSignature Language="C#" Value="public System.Numerics.BigInteger ReadInteger (System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Numerics.BigInteger ReadInteger(valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadInteger(System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadInteger (Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As BigInteger" />
      <MemberSignature Language="F#" Value="member this.ReadInteger : Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; System.Numerics.BigInteger" Usage="asnReader.ReadInteger expectedTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 2）。</param>
        <summary>读取下一个值，作为带有指定标记的整数值。</summary>
        <returns>已解码的值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadIntegerBytes">
      <MemberSignature Language="C#" Value="public ReadOnlyMemory&lt;byte&gt; ReadIntegerBytes (System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; ReadIntegerBytes(valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadIntegerBytes(System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadIntegerBytes (Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As ReadOnlyMemory(Of Byte)" />
      <MemberSignature Language="F#" Value="member this.ReadIntegerBytes : Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; ReadOnlyMemory&lt;byte&gt;" Usage="asnReader.ReadIntegerBytes expectedTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 2）。</param>
        <summary>读取下一个值，作为带有指定标记的整数值，并以原始数据的 <see cref="T:System.ReadOnlyMemory`1" /> 的形式返回内容。</summary>
        <returns>带符号的 Big Endian 格式的整数值的字节数。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadNamedBitList">
      <MemberSignature Language="C#" Value="public System.Collections.BitArray ReadNamedBitList (System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.BitArray ReadNamedBitList(valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadNamedBitList(System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadNamedBitList (Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As BitArray" />
      <MemberSignature Language="F#" Value="member this.ReadNamedBitList : Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; System.Collections.BitArray" Usage="asnReader.ReadNamedBitList expectedTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.BitArray</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="expectedTag">读取前要检查的标记。</param>
        <summary>读取下一个值，作为带有指定标记的 NamedBitList 值。</summary>
        <returns>编码值的位数。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadNamedBitListValue">
      <MemberSignature Language="C#" Value="public Enum ReadNamedBitListValue (Type flagsEnumType, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Enum ReadNamedBitListValue(class System.Type flagsEnumType, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadNamedBitListValue(System.Type,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadNamedBitListValue (flagsEnumType As Type, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Enum" />
      <MemberSignature Language="F#" Value="member this.ReadNamedBitListValue : Type * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; Enum" Usage="asnReader.ReadNamedBitListValue (flagsEnumType, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Enum</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flagsEnumType" Type="System.Type" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="flagsEnumType">表示目标类型的类型对象。</param>
        <param name="expectedTag">读取前要检查的标记。</param>
        <summary>读取下一个值，作为带有指定标记的 NamedBitList 值，并将其转换为由 <paramref name="flagsEnumType" /> 指定的 [<see cref="T:System.FlagsAttribute" />] 枚举。</summary>
        <returns>转换为 <paramref name="flagsEnumType" /> 的 NamedBitList 值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。
-或- 编码值太大，无法容纳 <paramref name="flagsEnumType" /> 值。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="flagsEnumType" /> 不是一个枚举类型。
-或- 未使用 <see cref="T:System.FlagsAttribute" /> -或- <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 声明 <paramref name="flagsEnumType" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="flagsEnumType" /> 为 <see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadNamedBitListValue&lt;TFlagsEnum&gt;">
      <MemberSignature Language="C#" Value="public TFlagsEnum ReadNamedBitListValue&lt;TFlagsEnum&gt; (System.Formats.Asn1.Asn1Tag? expectedTag = default) where TFlagsEnum : Enum;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TFlagsEnum ReadNamedBitListValue&lt;(class System.Enum) TFlagsEnum&gt;(valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadNamedBitListValue``1(System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadNamedBitListValue(Of TFlagsEnum As Enum) (Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As TFlagsEnum" />
      <MemberSignature Language="F#" Value="member this.ReadNamedBitListValue : Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; 'FlagsEnum (requires 'FlagsEnum :&gt; Enum)" Usage="asnReader.ReadNamedBitListValue expectedTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TFlagsEnum</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFlagsEnum">
          <Constraints>
            <BaseTypeName>System.Enum</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFlagsEnum">目标枚举类型</typeparam>
        <param name="expectedTag">读取前要检查的标记。</param>
        <summary>读取下一个值，作为带有指定标记的 NamedBitList 值，并将其转换为由 <typeparamref name="TFlagsEnum" /> 指定的 [<see cref="T:System.FlagsAttribute" />] 枚举。</summary>
        <returns>转换为 <typeparamref name="TFlagsEnum" /> 的 NamedBitList 值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

此方法执行的位对齐是将值的第一个字节中的最高有效位解释为 <typeparamref name = "TFlagsEnum> 中的最小有效位，其中的位增加到第一个字节的最小有效位，并使用第二个字节的最高有效位，依此类推。 在此方案下，以下的类型声明和 c # 枚举可以一起使用： <code> KeyUsage ::= BIT STRING { digitalSignature   (0), nonRepudiation     (1), keyEncipherment    (2), dataEncipherment   (3), keyAgreement       (4), keyCertSign        (5), cRLSign            (6), encipherOnly       (7), decipherOnly       (8) } </code><code> [Flags] enum KeyUsage { None              = 0, DigitalSignature  = 1 &lt;&lt; (0), NonRepudiation    = 1 &lt;&lt; (1), KeyEncipherment   = 1 &lt;&lt; (2), DataEncipherment  = 1 &lt;&lt; (3), KeyAgreement      = 1 &lt;&lt; (4), KeyCertSign       = 1 &lt;&lt; (5), CrlSign           = 1 &lt;&lt; (6), EncipherOnly      = 1 &lt;&lt; (7), DecipherOnly      = 1 &lt;&lt; (8), } </code> 
请注意，本示例使用 <a href="https://tools.ietf.org/html/rfc3280#section-4.2.1.3">RFC 3280 (4.2.1.3) </a>中的密钥用法 NamedBitList，示例枚举使用的值与的值不同。

          ]]></format>
        </remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。
-或- 编码值太大，无法容纳 <typeparamref name="TFlagsEnum" /> 值。</exception>
        <exception cref="T:System.ArgumentException"><typeparamref name="TFlagsEnum" /> 不是一个枚举类型。
-或- 未使用 <see cref="T:System.FlagsAttribute" /> -或- <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 声明 <typeparamref name="TFlagsEnum" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadNull">
      <MemberSignature Language="C#" Value="public void ReadNull (System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadNull(valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadNull(System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadNull (Optional expectedTag As Nullable(Of Asn1Tag) = Nothing)" />
      <MemberSignature Language="F#" Value="member this.ReadNull : Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; unit" Usage="asnReader.ReadNull expectedTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 5）。</param>
        <summary>读取下一个值，作为带有指定标记的 NULL 值。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadObjectIdentifier">
      <MemberSignature Language="C#" Value="public string ReadObjectIdentifier (System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ReadObjectIdentifier(valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadObjectIdentifier(System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadObjectIdentifier (Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As String" />
      <MemberSignature Language="F#" Value="member this.ReadObjectIdentifier : Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; string" Usage="asnReader.ReadObjectIdentifier expectedTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 6）。</param>
        <summary>读取下一个值，作为带有指定标记的 OBJECT IDENTIFIER 值，并以用点分隔的十进制格式字符串形式返回该值。</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadOctetString">
      <MemberSignature Language="C#" Value="public byte[] ReadOctetString (System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ReadOctetString(valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadOctetString(System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadOctetString (Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Byte()" />
      <MemberSignature Language="F#" Value="member this.ReadOctetString : Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; byte[]" Usage="asnReader.ReadOctetString expectedTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 4）。</param>
        <summary>读取下一个值，作为带有通用 4 标记的 OCTET STRING 值，并以字节数组形式返回该值。</summary>
        <returns>一个新分配的、精确大小的数组中的值的副本。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSequence">
      <MemberSignature Language="C#" Value="public System.Formats.Asn1.AsnReader ReadSequence (System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Formats.Asn1.AsnReader ReadSequence(valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadSequence(System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadSequence (Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As AsnReader" />
      <MemberSignature Language="F#" Value="member this.ReadSequence : Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; System.Formats.Asn1.AsnReader" Usage="asnReader.ReadSequence expectedTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Formats.Asn1.AsnReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 16）。</param>
        <summary>读取下一个值，作为带有指定标记的 SEQUENCE 或 SEQUENCE-OF 值，并将结果作为定位在序列中的第一个值处（或带有 <see cref="P:System.Formats.Asn1.AsnReader.HasData" /> == <see langword="false" />）的一个新读取器的形式返回。</summary>
        <returns>定位在序列中的第一个值处（或带有 <see cref="P:System.Formats.Asn1.AsnReader.HasData" /> == <see langword="false" />）的新的读取器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

此方法不计算嵌套内容，并且可能包含在当前编码规则下无效的数据。

          ]]></format>
        </remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSetOf">
      <MemberSignature Language="C#" Value="public System.Formats.Asn1.AsnReader ReadSetOf (System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Formats.Asn1.AsnReader ReadSetOf(valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadSetOf(System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadSetOf (Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As AsnReader" />
      <MemberSignature Language="F#" Value="member this.ReadSetOf : Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; System.Formats.Asn1.AsnReader" Usage="asnReader.ReadSetOf expectedTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Formats.Asn1.AsnReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 17）。</param>
        <summary>读取下一个值，作为带有指定标记的 SET-OF 值，并使用来自构造函数（默认为 <see langword="false" />）的 <see cref="P:System.Formats.Asn1.AsnReaderOptions.SkipSetSortOrderVerification" /> 值将结果作为定位在 set-of 中的第一个值处（或带有 <see cref="P:System.Formats.Asn1.AsnReader.HasData" /> == <see langword="false" />）的一个新读取器返回。</summary>
        <returns>定位在 set-of 中的第一个值处（或带有 <see cref="P:System.Formats.Asn1.AsnReader.HasData" /> == <see langword="false" />）的新的读取器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

此方法不会对嵌套内容进行计算 (除了排序顺序以外，在需要时) ，还可能包含在当前编码规则下无效的数据。

          ]]></format>
        </remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSetOf">
      <MemberSignature Language="C#" Value="public System.Formats.Asn1.AsnReader ReadSetOf (bool skipSortOrderValidation, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Formats.Asn1.AsnReader ReadSetOf(bool skipSortOrderValidation, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadSetOf(System.Boolean,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadSetOf (skipSortOrderValidation As Boolean, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As AsnReader" />
      <MemberSignature Language="F#" Value="member this.ReadSetOf : bool * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; System.Formats.Asn1.AsnReader" Usage="asnReader.ReadSetOf (skipSortOrderValidation, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Formats.Asn1.AsnReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="skipSortOrderValidation" Type="System.Boolean" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="skipSortOrderValidation">如果为 <see langword="true" />，则始终按显示的顺序接受数据，如果为 <see langword="false" />，则验证在编码规则说明需要排序时是否正确地对数据进行排序（CER 和 DER）。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 17）。</param>
        <summary>读取下一个值，作为带有指定标记的 SET-OF 值，并将结果作为定位在 set-of 中的第一个值处（或带有 <see cref="P:System.Formats.Asn1.AsnReader.HasData" /> == <see langword="false" />）的一个新读取器返回。</summary>
        <returns>定位在 set-of 中的第一个值处（或带有 <see cref="P:System.Formats.Asn1.AsnReader.HasData" /> == <see langword="false" />）的新的读取器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

此方法不会对嵌套内容进行计算 (除了排序顺序以外，在需要时) ，还可能包含在当前编码规则下无效的数据。

          ]]></format>
        </remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUtcTime">
      <MemberSignature Language="C#" Value="public DateTimeOffset ReadUtcTime (System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset ReadUtcTime(valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadUtcTime(System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadUtcTime (Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As DateTimeOffset" />
      <MemberSignature Language="F#" Value="member this.ReadUtcTime : Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; DateTimeOffset" Usage="asnReader.ReadUtcTime expectedTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 23）。</param>
        <summary>读取下一个值，作为带有指定标记并使用传递给构造函数的选项中的 <see cref="P:System.Formats.Asn1.AsnReaderOptions.UtcTimeTwoDigitYearMax" /> 值（默认值为 2049）的 UTCTime 值。</summary>
        <returns>已解码的值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUtcTime">
      <MemberSignature Language="C#" Value="public DateTimeOffset ReadUtcTime (int twoDigitYearMax, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset ReadUtcTime(int32 twoDigitYearMax, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadUtcTime(System.Int32,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadUtcTime (twoDigitYearMax As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As DateTimeOffset" />
      <MemberSignature Language="F#" Value="member this.ReadUtcTime : int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; DateTimeOffset" Usage="asnReader.ReadUtcTime (twoDigitYearMax, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="twoDigitYearMax" Type="System.Int32" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="twoDigitYearMax">此值所表示的最大年份。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 23）。</param>
        <summary>读取下一个值，作为带有指定标记的 UTCTime 值。</summary>
        <returns>已解码的值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="RuleSet">
      <MemberSignature Language="C#" Value="public System.Formats.Asn1.AsnEncodingRules RuleSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Formats.Asn1.AsnEncodingRules RuleSet" />
      <MemberSignature Language="DocId" Value="P:System.Formats.Asn1.AsnReader.RuleSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RuleSet As AsnEncodingRules" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Formats::Asn1::AsnEncodingRules RuleSet { System::Formats::Asn1::AsnEncodingRules get(); };" />
      <MemberSignature Language="F#" Value="member this.RuleSet : System.Formats.Asn1.AsnEncodingRules" Usage="System.Formats.Asn1.AsnReader.RuleSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Formats.Asn1.AsnEncodingRules</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此读取器使用的编码规则。</summary>
        <value>此读取器使用的编码规则。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ThrowIfNotEmpty">
      <MemberSignature Language="C#" Value="public void ThrowIfNotEmpty ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ThrowIfNotEmpty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ThrowIfNotEmpty" />
      <MemberSignature Language="VB.NET" Value="Public Sub ThrowIfNotEmpty ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ThrowIfNotEmpty();" />
      <MemberSignature Language="F#" Value="member this.ThrowIfNotEmpty : unit -&gt; unit" Usage="asnReader.ThrowIfNotEmpty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果读取器包含剩余数据，则会引发标准化 <see cref="T:System.Formats.Asn1.AsnContentException" />，如果 <see cref="P:System.Formats.Asn1.AsnReader.HasData" /> 返回 <see langword="false" />，则不执行任何功能。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

此方法提供了标准化的目标和标准化的异常，用于读取 "已关闭" 结构，如显式标记值的嵌套内容。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadBitString">
      <MemberSignature Language="C#" Value="public bool TryReadBitString (Span&lt;byte&gt; destination, out int unusedBitCount, out int bytesWritten, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadBitString(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; unusedBitCount, [out] int32&amp; bytesWritten, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.TryReadBitString(System.Span{System.Byte},System.Int32@,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadBitString (destination As Span(Of Byte), ByRef unusedBitCount As Integer, ByRef bytesWritten As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryReadBitString : Span&lt;byte&gt; * int * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="asnReader.TryReadBitString (destination, unusedBitCount, bytesWritten, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="unusedBitCount" Type="System.Int32" RefType="out" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">要写入的缓冲区。</param>
        <param name="unusedBitCount">成功时，将接收由编写器报告为“未使用”的最后一个字节中的位数。</param>
        <param name="bytesWritten">成功后，将收到已写入 <paramref name="destination" /> 的字节数。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 1）。</param>
        <summary>读取下一个值，作为带有指定标记的 BIT STRING 值，并将该值复制到所提供的目标缓冲区。</summary>
        <returns>如果 <paramref name="destination" /> 有足够的长度来接收值，则为 <see langword="true" /> 并推进读取器，否则为 <see langword="false" />，且读取器不会前进。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadCharacterString">
      <MemberSignature Language="C#" Value="public bool TryReadCharacterString (Span&lt;char&gt; destination, System.Formats.Asn1.UniversalTagNumber encodingType, out int charsWritten, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadCharacterString(valuetype System.Span`1&lt;char&gt; destination, valuetype System.Formats.Asn1.UniversalTagNumber encodingType, [out] int32&amp; charsWritten, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.TryReadCharacterString(System.Span{System.Char},System.Formats.Asn1.UniversalTagNumber,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadCharacterString (destination As Span(Of Char), encodingType As UniversalTagNumber, ByRef charsWritten As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryReadCharacterString : Span&lt;char&gt; * System.Formats.Asn1.UniversalTagNumber * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="asnReader.TryReadCharacterString (destination, encodingType, charsWritten, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="encodingType" Type="System.Formats.Asn1.UniversalTagNumber" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">要写入的缓冲区。</param>
        <param name="encodingType">枚举值之一，表示要处理的值类型。</param>
        <param name="charsWritten">成功后，将收到已写入 <paramref name="destination" /> 的字符数。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为符合请求的编码类型的通用标记。</param>
        <summary>读取下一个值，作为带有指定标记和编码类型的字符串值，并将已解码的值复制到所提供的目标缓冲区。</summary>
        <returns>如果 <paramref name="destination" /> 有足够的长度来接收值，则为 <see langword="true" /> 并推进读取器，否则为 <see langword="false" />，且读取器不会前进。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="encodingType" /> 不是一个已知的字符串类型。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。
-或- 字符串未成功解码。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 与 <paramref name="encodingType" /> 不同。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadCharacterStringBytes">
      <MemberSignature Language="C#" Value="public bool TryReadCharacterStringBytes (Span&lt;byte&gt; destination, System.Formats.Asn1.Asn1Tag expectedTag, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadCharacterStringBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination, valuetype System.Formats.Asn1.Asn1Tag expectedTag, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.TryReadCharacterStringBytes(System.Span{System.Byte},System.Formats.Asn1.Asn1Tag,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadCharacterStringBytes (destination As Span(Of Byte), expectedTag As Asn1Tag, ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryReadCharacterStringBytes(Span&lt;System::Byte&gt; destination, System::Formats::Asn1::Asn1Tag expectedTag, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="member this.TryReadCharacterStringBytes : Span&lt;byte&gt; * System.Formats.Asn1.Asn1Tag * int -&gt; bool" Usage="asnReader.TryReadCharacterStringBytes (destination, expectedTag, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="expectedTag" Type="System.Formats.Asn1.Asn1Tag" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination">要写入的缓冲区。</param>
        <param name="expectedTag">读取前要检查的标记。</param>
        <param name="bytesWritten">成功后，将收到已写入 <paramref name="destination" /> 的字节数。</param>
        <summary>读取下一个值，作为带有指定标记的字符串值，并将未处理的字节复制到所提供的目标缓冲区。</summary>
        <returns>如果 <paramref name="destination" /> 有足够的长度来接收值，则为 <see langword="true" /> 并推进读取器，否则为 <see langword="false" />，且读取器不会前进。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

此方法不确定字符串是否只使用编码所定义的字符。

          ]]></format>
        </remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 不是字符串标记类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt32">
      <MemberSignature Language="C#" Value="public bool TryReadInt32 (out int value, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadInt32([out] int32&amp; value, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.TryReadInt32(System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadInt32 (ByRef value As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryReadInt32 : int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="asnReader.TryReadInt32 (value, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="value">成功后，将收到解码后的值。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 2）。</param>
        <summary>尝试读取下一个带有指定标记并作为有符号的 32 位值的整数值。</summary>
        <returns>如果值不在 <see cref="F:System.Int32.MinValue" /> 和 <see cref="F:System.Int32.MaxValue" />（含）之间，则为 <see langword="false" />，并且不会推进读取器；否则，将返回 <see langword="true" />，且读取器会前进。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt64">
      <MemberSignature Language="C#" Value="public bool TryReadInt64 (out long value, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadInt64([out] int64&amp; value, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.TryReadInt64(System.Int64@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadInt64 (ByRef value As Long, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryReadInt64 : int64 * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="asnReader.TryReadInt64 (value, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="value">成功后，将收到解码后的值。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 2）。</param>
        <summary>尝试读取下一个带有指定标记并作为有符号的 64 位值的整数值。</summary>
        <returns>如果值不在 <see cref="F:System.Int64.MinValue" /> 和 <see cref="F:System.Int64.MaxValue" />（含）之间，则为 <see langword="false" />，并且不会推进读取器；否则，将返回 <see langword="true" />，且读取器会前进。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadOctetString">
      <MemberSignature Language="C#" Value="public bool TryReadOctetString (Span&lt;byte&gt; destination, out int bytesWritten, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadOctetString(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.TryReadOctetString(System.Span{System.Byte},System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadOctetString (destination As Span(Of Byte), ByRef bytesWritten As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryReadOctetString : Span&lt;byte&gt; * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="asnReader.TryReadOctetString (destination, bytesWritten, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">要写入的缓冲区。</param>
        <param name="bytesWritten">成功后，将收到已写入 <paramref name="destination" /> 的字节数。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 4）。</param>
        <summary>读取下一个值，作为带有指定标记的 OCTET STRING 值，并将该值复制到所提供的目标缓冲区。</summary>
        <returns>如果 <paramref name="destination" /> 有足够的长度来接收值，则为 <see langword="true" /> 并推进读取器，否则为 <see langword="false" />，且读取器不会前进。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadPrimitiveBitString">
      <MemberSignature Language="C#" Value="public bool TryReadPrimitiveBitString (out int unusedBitCount, out ReadOnlyMemory&lt;byte&gt; value, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadPrimitiveBitString([out] int32&amp; unusedBitCount, [out] valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt;&amp; value, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.TryReadPrimitiveBitString(System.Int32@,System.ReadOnlyMemory{System.Byte}@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadPrimitiveBitString (ByRef unusedBitCount As Integer, ByRef value As ReadOnlyMemory(Of Byte), Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryReadPrimitiveBitString : int * ReadOnlyMemory * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="asnReader.TryReadPrimitiveBitString (unusedBitCount, value, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unusedBitCount" Type="System.Int32" RefType="out" />
        <Parameter Name="value" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="unusedBitCount">成功时，将接收由编写器报告为“未使用”的最后一个字节中的位数。</param>
        <param name="value">成功后，将收到与 BIT STRING 的值相对应的原始数据的 <see cref="T:System.ReadOnlyMemory`1" />。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 1）。</param>
        <summary>读取下一个值，作为带有指定标记的 BIT STRING 值，并将结果作为原始数据的 <see cref="T:System.ReadOnlyMemory`1" /> 返回。</summary>
        <returns>如果 BIT STRING 值具有基元编码，则为 <see langword="true" />，并推进读取器，否则为 <see langword="false" />，并且在读取器具有构造编码的情况下，不会推进读取器。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadPrimitiveCharacterStringBytes">
      <MemberSignature Language="C#" Value="public bool TryReadPrimitiveCharacterStringBytes (System.Formats.Asn1.Asn1Tag expectedTag, out ReadOnlyMemory&lt;byte&gt; contents);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadPrimitiveCharacterStringBytes(valuetype System.Formats.Asn1.Asn1Tag expectedTag, [out] valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt;&amp; contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.TryReadPrimitiveCharacterStringBytes(System.Formats.Asn1.Asn1Tag,System.ReadOnlyMemory{System.Byte}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadPrimitiveCharacterStringBytes (expectedTag As Asn1Tag, ByRef contents As ReadOnlyMemory(Of Byte)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryReadPrimitiveCharacterStringBytes(System::Formats::Asn1::Asn1Tag expectedTag, [Runtime::InteropServices::Out] ReadOnlyMemory&lt;System::Byte&gt; % contents);" />
      <MemberSignature Language="F#" Value="member this.TryReadPrimitiveCharacterStringBytes : System.Formats.Asn1.Asn1Tag * ReadOnlyMemory -&gt; bool" Usage="asnReader.TryReadPrimitiveCharacterStringBytes (expectedTag, contents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Formats.Asn1.Asn1Tag" />
        <Parameter Name="contents" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="expectedTag">读取前要检查的标记。</param>
        <param name="contents">成功后，将收到与字符串值相对应的原始数据的 <see cref="T:System.ReadOnlyMemory`1" />。</param>
        <summary>读取下一个值，作为带有指定标记的字符值，并将结果作为原始数据的未处理 <see cref="T:System.ReadOnlyMemory`1" /> 返回。</summary>
        <returns>如果字符串值具有基元编码，则为 <see langword="true" />，并推进读取器，否则为 <see langword="false" />，并且在读取器具有构造编码的情况下，不会推进读取器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

此方法不确定字符串是否只使用编码所定义的字符。

          ]]></format>
        </remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 不是字符串标记类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadPrimitiveOctetString">
      <MemberSignature Language="C#" Value="public bool TryReadPrimitiveOctetString (out ReadOnlyMemory&lt;byte&gt; contents, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadPrimitiveOctetString([out] valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt;&amp; contents, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.TryReadPrimitiveOctetString(System.ReadOnlyMemory{System.Byte}@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadPrimitiveOctetString (ByRef contents As ReadOnlyMemory(Of Byte), Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryReadPrimitiveOctetString : ReadOnlyMemory * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="asnReader.TryReadPrimitiveOctetString (contents, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="contents" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="contents">成功后，将收到与 OCTET STRING 的值相对应的原始数据的 <see cref="T:System.ReadOnlyMemory`1" />。</param>
        <param name="expectedTag">读取前要检查的标记。</param>
        <summary>尝试读取下一个带有指定标记，并返回原始数据的 <see cref="T:System.ReadOnlyMemory`1" /> 内容的 OCTET STRING 值。</summary>
        <returns>如果 OCTET STRING 值具有基元编码，则为 <see langword="true" />，并推进读取器，否则为 <see langword="false" />，并且在读取器具有构造编码的情况下，不会推进读取器。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt32">
      <MemberSignature Language="C#" Value="public bool TryReadUInt32 (out uint value, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadUInt32([out] unsigned int32&amp; value, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.TryReadUInt32(System.UInt32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadUInt32 (ByRef value As UInteger, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryReadUInt32 : uint32 * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="asnReader.TryReadUInt32 (value, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="value">成功后，将收到解码后的值。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 2）。</param>
        <summary>尝试读取下一个带有指定标记并作为无符号的 32 位值的整数值。</summary>
        <returns>如果值不在 <see cref="F:System.UInt32.MinValue" /> 和 <see cref="F:System.UInt32.MaxValue" />（含）之间，则为 <see langword="false" />，并且不会推进读取器；否则，将返回 <see langword="true" />，且读取器会前进。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt64">
      <MemberSignature Language="C#" Value="public bool TryReadUInt64 (out ulong value, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadUInt64([out] unsigned int64&amp; value, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.TryReadUInt64(System.UInt64@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadUInt64 (ByRef value As ULong, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryReadUInt64 : uint64 * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="asnReader.TryReadUInt64 (value, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="value">成功后，将收到解码后的值。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 2）。</param>
        <summary>尝试读取下一个带有指定标记并作为无符号的 64 位值的整数值。</summary>
        <returns>如果值不在 <see cref="F:System.UInt64.MinValue" /> 和 <see cref="F:System.UInt64.MaxValue" />（含）之间，则为 <see langword="false" />，并且不会推进读取器；否则，将返回 <see langword="true" />，且读取器会前进。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
