<Type Name="AsnDecoder" FullName="System.Formats.Asn1.AsnDecoder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="74b38ddbf070595de56b39949e5ed55e83cabbf4" /><Meta Name="ms.sourcegitcommit" Value="943c8cdbe5b47c6c296a6f4b73038bbd43da0dd2" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="02/12/2021" /><Meta Name="ms.locfileid" Value="100323145" /></Metadata><TypeSignature Language="C#" Value="public static class AsnDecoder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit AsnDecoder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Formats.Asn1.AsnDecoder" />
  <TypeSignature Language="VB.NET" Value="Public Class AsnDecoder" />
  <TypeSignature Language="C++ CLI" Value="public ref class AsnDecoder abstract sealed" />
  <TypeSignature Language="F#" Value="type AsnDecoder = class" />
  <AssemblyInfo>
    <AssemblyName>System.Formats.Asn1</AssemblyName>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>提供了一种无状态方法用于解码 BER、CER 或 DER 编码的 ASN.1 数据。</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="ReadBitString">
      <MemberSignature Language="C#" Value="public static byte[] ReadBitString (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int unusedBitCount, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] ReadBitString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; unusedBitCount, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadBitString(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadBitString (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef unusedBitCount As Integer, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Byte()" />
      <MemberSignature Language="F#" Value="static member ReadBitString : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; byte[]" Usage="System.Formats.Asn1.AsnDecoder.ReadBitString (source, ruleSet, unusedBitCount, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="unusedBitCount" Type="System.Int32" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="unusedBitCount">成功时，将接收由编写器报告为“未使用”的最后一个字节中的位数。
该参数未经初始化即被处理。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 3）。</param>
        <summary>在指定编码规则下，从带有指定标记的 <paramref name="source" /> 中读取位字符串值，以返回新数组内容。</summary>
        <returns>包含位字符串值内容的数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

由值报告为 "未使用" 的最后一个字节中的最小有效位 `unusedBitCount` 将作为未设置的位复制到返回值，而不考虑它们在编码表示形式中的值。

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBoolean">
      <MemberSignature Language="C#" Value="public static bool ReadBoolean (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReadBoolean(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadBoolean(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadBoolean (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="static member ReadBoolean : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="System.Formats.Asn1.AsnDecoder.ReadBoolean (source, ruleSet, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 1）。</param>
        <summary>在指定编码规则下，从带有指定标记的 <paramref name="source" /> 中读取布尔值。</summary>
        <returns>已解码的值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadCharacterString">
      <MemberSignature Language="C#" Value="public static string ReadCharacterString (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, System.Formats.Asn1.UniversalTagNumber encodingType, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadCharacterString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, valuetype System.Formats.Asn1.UniversalTagNumber encodingType, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadCharacterString(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Formats.Asn1.UniversalTagNumber,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadCharacterString (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, encodingType As UniversalTagNumber, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As String" />
      <MemberSignature Language="F#" Value="static member ReadCharacterString : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * System.Formats.Asn1.UniversalTagNumber * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; string" Usage="System.Formats.Asn1.AsnDecoder.ReadCharacterString (source, ruleSet, encodingType, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="encodingType" Type="System.Formats.Asn1.UniversalTagNumber" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="encodingType">枚举值之一，表示要处理的值类型。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为符合请求的编码类型的通用标记。</param>
        <summary>读取下一个值，作为带有指定标记和编码类型的字符串值，以返回解码字符串。</summary>
        <returns>已解码的值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。
-或- <paramref name="encodingType" /> 不是已知的字符串类型。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。
-或- 字符串未成功解码。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 与 <paramref name="encodingType" /> 不同。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadEncodedValue">
      <MemberSignature Language="C#" Value="public static System.Formats.Asn1.Asn1Tag ReadEncodedValue (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int contentOffset, out int contentLength, out int bytesConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Formats.Asn1.Asn1Tag ReadEncodedValue(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; contentOffset, [out] int32&amp; contentLength, [out] int32&amp; bytesConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadEncodedValue(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadEncodedValue (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef contentOffset As Integer, ByRef contentLength As Integer, ByRef bytesConsumed As Integer) As Asn1Tag" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Formats::Asn1::Asn1Tag ReadEncodedValue(ReadOnlySpan&lt;System::Byte&gt; source, System::Formats::Asn1::AsnEncodingRules ruleSet, [Runtime::InteropServices::Out] int % contentOffset, [Runtime::InteropServices::Out] int % contentLength, [Runtime::InteropServices::Out] int % bytesConsumed);" />
      <MemberSignature Language="F#" Value="static member ReadEncodedValue : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * int * int -&gt; System.Formats.Asn1.Asn1Tag" Usage="System.Formats.Asn1.AsnDecoder.ReadEncodedValue (source, ruleSet, contentOffset, contentLength, bytesConsumed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Formats.Asn1.Asn1Tag</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="contentOffset" Type="System.Int32" RefType="out" />
        <Parameter Name="contentLength" Type="System.Int32" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="contentOffset">此方法返回时，为内容有效负载相对于 <paramref name="source" /> 起始位置的偏移量。
该参数未经初始化即被处理。</param>
        <param name="contentLength">此方法返回时，为内容有效负载中的字节数（可能为 0）。
该参数未经初始化即被处理。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <summary>使用指定的编码规则在 <paramref name="source" /> 缓冲区的开头查找编码值的内容范围。</summary>
        <returns>标识内容的标记。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 此方法对内容执行非常少的验证。
如果编码值使用明确长度，则根本不检查内容。
如果编码值使用无限长度，则仅检查内容以确定相关的内容结尾标记的位置。
              

 当编码值使用无限长度时， `bytesConsumed` 值将大于和的总和， `contentOffset` `contentLength` 以考虑内容的结束标记。
              



          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException"><paramref name="source" /> 不表示在指定编码规则下编码的值。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadEnumeratedBytes">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;byte&gt; ReadEnumeratedBytes (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; ReadEnumeratedBytes(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadEnumeratedBytes(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadEnumeratedBytes (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="F#" Value="static member ReadEnumeratedBytes : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; ReadOnlySpan&lt;byte&gt;" Usage="System.Formats.Asn1.AsnDecoder.ReadEnumeratedBytes (source, ruleSet, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 10）。</param>
        <summary>在指定编码规则下，从带有指定标记的 <paramref name="source" /> 中读取枚举值，进而以缓冲区切片形式返回内容。</summary>
        <returns>缓冲区切片包含带符号的 Big Endian 格式的枚举值的字节数。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadEnumeratedValue">
      <MemberSignature Language="C#" Value="public static Enum ReadEnumeratedValue (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, Type enumType, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Enum ReadEnumeratedValue(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, class System.Type enumType, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadEnumeratedValue(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Type,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadEnumeratedValue (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, enumType As Type, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Enum" />
      <MemberSignature Language="F#" Value="static member ReadEnumeratedValue : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * Type * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; Enum" Usage="System.Formats.Asn1.AsnDecoder.ReadEnumeratedValue (source, ruleSet, enumType, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Enum</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="enumType">表示目标类型的类型对象。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 10）。</param>
        <summary>在指定编码规则下，从带有指定标记的 <paramref name="source" /> 中读取枚举，并将其转换为由 <paramref name="enumType" /> 指定的非 [<see cref="T:System.FlagsAttribute" />] 枚举。</summary>
        <returns>转换为 <paramref name="enumType" /> 的枚举值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

此方法不会验证中是否定义了返回值 `enumType` 。

          ]]></format>
        </remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。
-或- 编码值太大，无法容纳 <paramref name="enumType" /> 值。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="enumType" /> 不是一个枚举类型。
-或- <paramref name="enumType" /> 是使用 <see cref="T:System.FlagsAttribute" /> 声明的。
-或- <paramref name="enumType" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="enumType" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="enumType" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadEnumeratedValue&lt;TEnum&gt;">
      <MemberSignature Language="C#" Value="public static TEnum ReadEnumeratedValue&lt;TEnum&gt; (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default) where TEnum : Enum;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TEnum ReadEnumeratedValue&lt;(class System.Enum) TEnum&gt;(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadEnumeratedValue``1(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadEnumeratedValue(Of TEnum As Enum) (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As TEnum" />
      <MemberSignature Language="F#" Value="static member ReadEnumeratedValue : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; 'Enum (requires 'Enum :&gt; Enum)" Usage="System.Formats.Asn1.AsnDecoder.ReadEnumeratedValue (source, ruleSet, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEnum</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEnum">
          <Constraints>
            <BaseTypeName>System.Enum</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TEnum">目标枚举类型</typeparam>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 10）。</param>
        <summary>在指定编码规则下，从带有指定标记的 <paramref name="source" /> 中读取枚举，并将其转换为由 <typeparamref name="TEnum" /> 指定的非 [<see cref="T:System.FlagsAttribute" />] 枚举。</summary>
        <returns>转换为 <typeparamref name="TEnum" /> 的枚举值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

此方法不会验证是否在 <typeparamref name = "TEnum> 中定义了返回值。

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。
-或- 编码值太大，无法容纳 <typeparamref name="TEnum" /> 值。</exception>
        <exception cref="T:System.ArgumentException"><typeparamref name="TEnum" /> 不是一个枚举类型。
-或- <typeparamref name="TEnum" /> 是使用 <see cref="T:System.FlagsAttribute" /> 声明的。
-或- <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadGeneralizedTime">
      <MemberSignature Language="C#" Value="public static DateTimeOffset ReadGeneralizedTime (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTimeOffset ReadGeneralizedTime(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadGeneralizedTime(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadGeneralizedTime (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As DateTimeOffset" />
      <MemberSignature Language="F#" Value="static member ReadGeneralizedTime : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; DateTimeOffset" Usage="System.Formats.Asn1.AsnDecoder.ReadGeneralizedTime (source, ruleSet, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 24）。</param>
        <summary>在指定编码规则下，从带有指定标记的 <paramref name="source" /> 中读取 GeneralizedTime 值。</summary>
        <returns>已解码的值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInteger">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger ReadInteger (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger ReadInteger(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadInteger(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInteger (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As BigInteger" />
      <MemberSignature Language="F#" Value="static member ReadInteger : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; System.Numerics.BigInteger" Usage="System.Formats.Asn1.AsnDecoder.ReadInteger (source, ruleSet, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 2）。</param>
        <summary>在指定编码规则下，从带有指定标记的 <paramref name="source" /> 中读取整数值。</summary>
        <returns>已解码的数字值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadIntegerBytes">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;byte&gt; ReadIntegerBytes (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; ReadIntegerBytes(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadIntegerBytes(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadIntegerBytes (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="F#" Value="static member ReadIntegerBytes : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; ReadOnlySpan&lt;byte&gt;" Usage="System.Formats.Asn1.AsnDecoder.ReadIntegerBytes (source, ruleSet, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 2）。</param>
        <summary>在指定编码规则下，从带有指定标记的 <paramref name="source" /> 中读取整数值，进而以缓冲区切片形式返回内容。</summary>
        <returns>缓冲区切片包含带符号的 Big Endian 格式的整数值的字节数。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadNamedBitList">
      <MemberSignature Language="C#" Value="public static System.Collections.BitArray ReadNamedBitList (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.BitArray ReadNamedBitList(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadNamedBitList(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadNamedBitList (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As BitArray" />
      <MemberSignature Language="F#" Value="static member ReadNamedBitList : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; System.Collections.BitArray" Usage="System.Formats.Asn1.AsnDecoder.ReadNamedBitList (source, ruleSet, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.BitArray</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 3）。</param>
        <summary>在指定编码规则下，从带有指定标记的 <paramref name="source" /> 中读取 NamedBitList。</summary>
        <returns>编码值的位数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

此方法执行的位对齐是将值的第一个字节中的最高有效位解释为位0，并在第一个字节的最小有效位之间增加，并在第二个字节的最高有效位上继续，依此类推。
这意味着在 NamedBitList 结构中使用的数字是返回值中的索引。

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadNamedBitListValue">
      <MemberSignature Language="C#" Value="public static Enum ReadNamedBitListValue (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, Type flagsEnumType, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Enum ReadNamedBitListValue(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, class System.Type flagsEnumType, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadNamedBitListValue(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Type,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadNamedBitListValue (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, flagsEnumType As Type, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Enum" />
      <MemberSignature Language="F#" Value="static member ReadNamedBitListValue : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * Type * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; Enum" Usage="System.Formats.Asn1.AsnDecoder.ReadNamedBitListValue (source, ruleSet, flagsEnumType, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Enum</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="flagsEnumType" Type="System.Type" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="flagsEnumType">表示目标类型的类型对象。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 3）。</param>
        <summary>在指定编码规则下，从带有指定标记的 <paramref name="source" /> 中读取 NamedBitList，并将其转换为由 <paramref name="flagsEnumType" /> 指定的 [<see cref="T:System.FlagsAttribute" />] 枚举。</summary>
        <returns>转换为 <paramref name="flagsEnumType" /> 的 NamedBitList 值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。
-或- 编码值太大，无法容纳 <paramref name="flagsEnumType" /> 值。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="flagsEnumType" /> 不是一个枚举类型。
-或- 未使用 <see cref="T:System.FlagsAttribute" /> -或- <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 声明 <paramref name="flagsEnumType" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="flagsEnumType" /> 为 <see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadNamedBitListValue&lt;TFlagsEnum&gt;">
      <MemberSignature Language="C#" Value="public static TFlagsEnum ReadNamedBitListValue&lt;TFlagsEnum&gt; (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default) where TFlagsEnum : Enum;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TFlagsEnum ReadNamedBitListValue&lt;(class System.Enum) TFlagsEnum&gt;(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadNamedBitListValue``1(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadNamedBitListValue(Of TFlagsEnum As Enum) (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As TFlagsEnum" />
      <MemberSignature Language="F#" Value="static member ReadNamedBitListValue : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; 'FlagsEnum (requires 'FlagsEnum :&gt; Enum)" Usage="System.Formats.Asn1.AsnDecoder.ReadNamedBitListValue (source, ruleSet, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TFlagsEnum</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFlagsEnum">
          <Constraints>
            <BaseTypeName>System.Enum</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFlagsEnum">目标枚举类型</typeparam>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 3）。</param>
        <summary>在指定编码规则下，从带有指定标记的 <paramref name="source" /> 中读取 NamedBitList，并将其转换为由 <typeparamref name="TFlagsEnum" /> 指定的 [<see cref="T:System.FlagsAttribute" />] 枚举。</summary>
        <returns>转换为 <typeparamref name="TFlagsEnum" /> 的 NamedBitList 值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

此方法执行的位对齐是将值的第一个字节中的最高有效位解释为 <typeparamref name = "TFlagsEnum> 中的最小有效位，其中的位增加到第一个字节的最小有效位，并使用第二个字节的最高有效位，依此类推。 在此方案下，以下的类型声明和 c # 枚举可以一起使用： <code> KeyUsage ::= BIT STRING { digitalSignature   (0), nonRepudiation     (1), keyEncipherment    (2), dataEncipherment   (3), keyAgreement       (4), keyCertSign        (5), cRLSign            (6), encipherOnly       (7), decipherOnly       (8) } </code><code> [Flags] enum KeyUsage { None              = 0, DigitalSignature  = 1 &lt;&lt; (0), NonRepudiation    = 1 &lt;&lt; (1), KeyEncipherment   = 1 &lt;&lt; (2), DataEncipherment  = 1 &lt;&lt; (3), KeyAgreement      = 1 &lt;&lt; (4), KeyCertSign       = 1 &lt;&lt; (5), CrlSign           = 1 &lt;&lt; (6), EncipherOnly      = 1 &lt;&lt; (7), DecipherOnly      = 1 &lt;&lt; (8), } </code> 
请注意，本示例使用 <a href="https://tools.ietf.org/html/rfc3280#section-4.2.1.3">RFC 3280 (4.2.1.3) </a>中的密钥用法 NamedBitList，示例枚举使用的值与的值不同。

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。
-或- 编码值太大，无法容纳 <typeparamref name="TFlagsEnum" /> 值。</exception>
        <exception cref="T:System.ArgumentException"><typeparamref name="TFlagsEnum" /> 不是一个枚举类型。
-或- 未使用 <see cref="T:System.FlagsAttribute" /> -或- <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 声明 <typeparamref name="TFlagsEnum" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadNull">
      <MemberSignature Language="C#" Value="public static void ReadNull (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReadNull(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadNull(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReadNull (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing)" />
      <MemberSignature Language="F#" Value="static member ReadNull : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; unit" Usage="System.Formats.Asn1.AsnDecoder.ReadNull (source, ruleSet, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 5）。</param>
        <summary>在指定编码规则下，从带有指定标记的 <paramref name="source" /> 中读取 <see langword="null" /> 值。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadObjectIdentifier">
      <MemberSignature Language="C#" Value="public static string ReadObjectIdentifier (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadObjectIdentifier(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadObjectIdentifier(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadObjectIdentifier (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As String" />
      <MemberSignature Language="F#" Value="static member ReadObjectIdentifier : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; string" Usage="System.Formats.Asn1.AsnDecoder.ReadObjectIdentifier (source, ruleSet, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 6）。</param>
        <summary>在指定编码规则下，从带有指定标记的 <paramref name="source" /> 中读取对象标识符值。</summary>
        <returns>已解码的对象标识符，采用点分十进制表示法。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadOctetString">
      <MemberSignature Language="C#" Value="public static byte[] ReadOctetString (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] ReadOctetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadOctetString(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadOctetString (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Byte()" />
      <MemberSignature Language="F#" Value="static member ReadOctetString : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; byte[]" Usage="System.Formats.Asn1.AsnDecoder.ReadOctetString (source, ruleSet, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 4）。</param>
        <summary>在指定编码规则下，从带有指定标记的 <paramref name="source" /> 中读取八进制字符串值，以返回新数组内容。</summary>
        <returns>包含八进制字符串值内容的数组。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSequence">
      <MemberSignature Language="C#" Value="public static void ReadSequence (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int contentOffset, out int contentLength, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReadSequence(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; contentOffset, [out] int32&amp; contentLength, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadSequence(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Int32@,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReadSequence (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef contentOffset As Integer, ByRef contentLength As Integer, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing)" />
      <MemberSignature Language="F#" Value="static member ReadSequence : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * int * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; unit" Usage="System.Formats.Asn1.AsnDecoder.ReadSequence (source, ruleSet, contentOffset, contentLength, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="contentOffset" Type="System.Int32" RefType="out" />
        <Parameter Name="contentLength" Type="System.Int32" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="contentOffset">此方法返回时，为内容有效负载相对于 <paramref name="source" /> 起始位置的偏移量。
该参数未经初始化即被处理。</param>
        <param name="contentLength">此方法返回时，为内容有效负载中的字节数（可能为 0）。
该参数未经初始化即被处理。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 16）。</param>
        <summary>在指定编码规则下，从带有指定标记的 <paramref name="source" /> 中读取 Sequence 或 Sequence-Of 值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

此方法不会计算嵌套内容，只是最少的处理来确定内容末尾标记的位置。
因此，内容可能包含在当前编码规则下无效的数据。

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSetOf">
      <MemberSignature Language="C#" Value="public static void ReadSetOf (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int contentOffset, out int contentLength, out int bytesConsumed, bool skipSortOrderValidation = false, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReadSetOf(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; contentOffset, [out] int32&amp; contentLength, [out] int32&amp; bytesConsumed, bool skipSortOrderValidation, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadSetOf(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Int32@,System.Int32@,System.Boolean,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReadSetOf (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef contentOffset As Integer, ByRef contentLength As Integer, ByRef bytesConsumed As Integer, Optional skipSortOrderValidation As Boolean = false, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing)" />
      <MemberSignature Language="F#" Value="static member ReadSetOf : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * int * int * bool * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; unit" Usage="System.Formats.Asn1.AsnDecoder.ReadSetOf (source, ruleSet, contentOffset, contentLength, bytesConsumed, skipSortOrderValidation, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="contentOffset" Type="System.Int32" RefType="out" />
        <Parameter Name="contentLength" Type="System.Int32" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="skipSortOrderValidation" Type="System.Boolean" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="contentOffset">此方法返回时，为内容有效负载相对于 <paramref name="source" /> 起始位置的偏移量。
该参数未经初始化即被处理。</param>
        <param name="contentLength">此方法返回时，为内容有效负载中的字节数（可能为 0）。
该参数未经初始化即被处理。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <param name="skipSortOrderValidation">如果为 <see langword="true" />，则始终按显示的顺序接受数据，如果为 <see langword="false" />，则验证在编码规则说明需要排序时是否正确地对数据进行排序（CER 和 DER）。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 17）。</param>
        <summary>在指定编码规则下，从带有指定标记的 <paramref name="source" /> 中读取 Set-Of 值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

此方法不会计算嵌套内容，只是最小处理方法是确定内容结束标记的位置或内容排序顺序的验证。
因此，内容可能包含在当前编码规则下无效的数据。

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUtcTime">
      <MemberSignature Language="C#" Value="public static DateTimeOffset ReadUtcTime (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int bytesConsumed, int twoDigitYearMax = 2049, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTimeOffset ReadUtcTime(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; bytesConsumed, int32 twoDigitYearMax, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadUtcTime(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Int32,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadUtcTime (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef bytesConsumed As Integer, Optional twoDigitYearMax As Integer = 2049, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As DateTimeOffset" />
      <MemberSignature Language="F#" Value="static member ReadUtcTime : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; DateTimeOffset" Usage="System.Formats.Asn1.AsnDecoder.ReadUtcTime (source, ruleSet, bytesConsumed, twoDigitYearMax, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="twoDigitYearMax" Type="System.Int32" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <param name="twoDigitYearMax">此值所表示的最大年份。
默认值 2049 表示 x.509 证书的 1950-2049 范围。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 24）。</param>
        <summary>在指定编码规则下，从带有指定标记的 <paramref name="source" /> 中读取 UtcTime 值。</summary>
        <returns>已解码的值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。
-或- <paramref name="twoDigitYearMax" /> 不在 [99, 9999] 的范围内。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadBitString">
      <MemberSignature Language="C#" Value="public static bool TryReadBitString (ReadOnlySpan&lt;byte&gt; source, Span&lt;byte&gt; destination, System.Formats.Asn1.AsnEncodingRules ruleSet, out int unusedBitCount, out int bytesConsumed, out int bytesWritten, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadBitString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Span`1&lt;unsigned int8&gt; destination, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; unusedBitCount, [out] int32&amp; bytesConsumed, [out] int32&amp; bytesWritten, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.TryReadBitString(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Int32@,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadBitString (source As ReadOnlySpan(Of Byte), destination As Span(Of Byte), ruleSet As AsnEncodingRules, ByRef unusedBitCount As Integer, ByRef bytesConsumed As Integer, ByRef bytesWritten As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryReadBitString : ReadOnlySpan&lt;byte&gt; * Span&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * int * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="System.Formats.Asn1.AsnDecoder.TryReadBitString (source, destination, ruleSet, unusedBitCount, bytesConsumed, bytesWritten, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="unusedBitCount" Type="System.Int32" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="destination">要写入的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="unusedBitCount">成功时，将接收由编写器报告为“未使用”的最后一个字节中的位数。
该参数未经初始化即被处理。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <param name="bytesWritten">此方法返回时，为写入 <paramref name="destination" /> 的字节总数。
该参数未经初始化即被处理。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 3）。</param>
        <summary>在指定编码规则下，尝试从带有指定标记的 <paramref name="source" /> 中将位字符串值复制到 <paramref name="destination" />。</summary>
        <returns>如果 <paramref name="destination" /> 足以接收位字符串的值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

值报告为 "未使用" 的最后一个字节中的最小有效位 `unusedBitCount` 将 `destination` 作为未设置的位复制到，而不考虑它们在编码表示形式中的值。

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。
-或- <paramref name="destination" /> 与 <paramref name="source" /> 重叠。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadCharacterString">
      <MemberSignature Language="C#" Value="public static bool TryReadCharacterString (ReadOnlySpan&lt;byte&gt; source, Span&lt;char&gt; destination, System.Formats.Asn1.AsnEncodingRules ruleSet, System.Formats.Asn1.UniversalTagNumber encodingType, out int bytesConsumed, out int charsWritten, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadCharacterString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Span`1&lt;char&gt; destination, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, valuetype System.Formats.Asn1.UniversalTagNumber encodingType, [out] int32&amp; bytesConsumed, [out] int32&amp; charsWritten, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.TryReadCharacterString(System.ReadOnlySpan{System.Byte},System.Span{System.Char},System.Formats.Asn1.AsnEncodingRules,System.Formats.Asn1.UniversalTagNumber,System.Int32@,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadCharacterString (source As ReadOnlySpan(Of Byte), destination As Span(Of Char), ruleSet As AsnEncodingRules, encodingType As UniversalTagNumber, ByRef bytesConsumed As Integer, ByRef charsWritten As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryReadCharacterString : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; * System.Formats.Asn1.AsnEncodingRules * System.Formats.Asn1.UniversalTagNumber * int * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="System.Formats.Asn1.AsnDecoder.TryReadCharacterString (source, destination, ruleSet, encodingType, bytesConsumed, charsWritten, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="encodingType" Type="System.Formats.Asn1.UniversalTagNumber" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="destination">要写入的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="encodingType">枚举值之一，表示要处理的值类型。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <param name="charsWritten">此方法返回时，为写入 <paramref name="destination" /> 的字符数。
该参数未经初始化即被处理。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为符合请求的编码类型的通用标记。</param>
        <summary>在指定编码规则下，从带有指定标记的 <paramref name="source" /> 中读取字符串值，进而将已解码的字符串复制到提供的目标缓冲区。</summary>
        <returns>如果 <paramref name="destination" /> 有足够的长度来接收值，则为 <see langword="true" /> 并推进读取器，否则为 <see langword="false" />，且读取器不会前进。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。
-或- <paramref name="encodingType" /> 不是已知的字符串类型。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。
-或- 字符串未成功解码。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 与 <paramref name="encodingType" /> 不同。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadCharacterStringBytes">
      <MemberSignature Language="C#" Value="public static bool TryReadCharacterStringBytes (ReadOnlySpan&lt;byte&gt; source, Span&lt;byte&gt; destination, System.Formats.Asn1.AsnEncodingRules ruleSet, System.Formats.Asn1.Asn1Tag expectedTag, out int bytesConsumed, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadCharacterStringBytes(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Span`1&lt;unsigned int8&gt; destination, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, valuetype System.Formats.Asn1.Asn1Tag expectedTag, [out] int32&amp; bytesConsumed, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.TryReadCharacterStringBytes(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Formats.Asn1.Asn1Tag,System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadCharacterStringBytes (source As ReadOnlySpan(Of Byte), destination As Span(Of Byte), ruleSet As AsnEncodingRules, expectedTag As Asn1Tag, ByRef bytesConsumed As Integer, ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadCharacterStringBytes(ReadOnlySpan&lt;System::Byte&gt; source, Span&lt;System::Byte&gt; destination, System::Formats::Asn1::AsnEncodingRules ruleSet, System::Formats::Asn1::Asn1Tag expectedTag, [Runtime::InteropServices::Out] int % bytesConsumed, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="static member TryReadCharacterStringBytes : ReadOnlySpan&lt;byte&gt; * Span&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * System.Formats.Asn1.Asn1Tag * int * int -&gt; bool" Usage="System.Formats.Asn1.AsnDecoder.TryReadCharacterStringBytes (source, destination, ruleSet, expectedTag, bytesConsumed, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="expectedTag" Type="System.Formats.Asn1.Asn1Tag" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="destination">要写入的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="expectedTag">读取前要检查的标记。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <param name="bytesWritten">成功后，将收到已写入 <paramref name="destination" /> 的字节数。</param>
        <summary>在指定编码规则下，尝试从带有指定标记的 <paramref name="source" /> 中读取字符串值，以将未处理的字节复制到所提供的目标缓冲区。</summary>
        <returns>如果 <paramref name="destination" /> 足以接收位未处理字符串的值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

此方法不确定字符串是否只使用编码所定义的字符。

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 不是字符串标记类型。
-或- <paramref name="destination" /> 与 <paramref name="source" /> 重叠。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadEncodedValue">
      <MemberSignature Language="C#" Value="public static bool TryReadEncodedValue (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out System.Formats.Asn1.Asn1Tag tag, out int contentOffset, out int contentLength, out int bytesConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadEncodedValue(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] valuetype System.Formats.Asn1.Asn1Tag&amp; tag, [out] int32&amp; contentOffset, [out] int32&amp; contentLength, [out] int32&amp; bytesConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.TryReadEncodedValue(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Formats.Asn1.Asn1Tag@,System.Int32@,System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadEncodedValue (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef tag As Asn1Tag, ByRef contentOffset As Integer, ByRef contentLength As Integer, ByRef bytesConsumed As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadEncodedValue(ReadOnlySpan&lt;System::Byte&gt; source, System::Formats::Asn1::AsnEncodingRules ruleSet, [Runtime::InteropServices::Out] System::Formats::Asn1::Asn1Tag % tag, [Runtime::InteropServices::Out] int % contentOffset, [Runtime::InteropServices::Out] int % contentLength, [Runtime::InteropServices::Out] int % bytesConsumed);" />
      <MemberSignature Language="F#" Value="static member TryReadEncodedValue : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * Asn1Tag * int * int * int -&gt; bool" Usage="System.Formats.Asn1.AsnDecoder.TryReadEncodedValue (source, ruleSet, tag, contentOffset, contentLength, bytesConsumed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="tag" Type="System.Formats.Asn1.Asn1Tag" RefType="out" />
        <Parameter Name="contentOffset" Type="System.Int32" RefType="out" />
        <Parameter Name="contentLength" Type="System.Int32" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="tag">此方法返回时，为标识内容的标记。
该参数未经初始化即被处理。</param>
        <param name="contentOffset">此方法返回时，为内容有效负载相对于 <paramref name="source" /> 起始位置的偏移量。
该参数未经初始化即被处理。</param>
        <param name="contentLength">此方法返回时，为内容有效负载中的字节数（可能为 0）。
该参数未经初始化即被处理。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <summary>尝试使用指定编码规则查找 <paramref name="source" /> 缓冲区开头编码值的内容范围。</summary>
        <returns>如果 <paramref name="source" /> 表示指定编码规则的有效结构编码，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 此方法对内容执行非常少的验证。
如果编码值使用明确长度，则根本不检查内容。
如果编码值使用无限长度，则仅检查内容以确定相关的内容结尾标记的位置。
              

 当编码值使用无限长度时， `bytesConsumed` 值将大于和的总和， `contentOffset` `contentLength` 以考虑内容的结束标记。
              



          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt32">
      <MemberSignature Language="C#" Value="public static bool TryReadInt32 (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int value, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadInt32(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; value, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.TryReadInt32(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadInt32 (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef value As Integer, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryReadInt32 : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="System.Formats.Asn1.AsnDecoder.TryReadInt32 (source, ruleSet, value, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="value" Type="System.Int32" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="value">成功时，将收到解释的数值。
该参数未经初始化即被处理。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 2）。</param>
        <summary>在指定编码规则下，尝试从带有指定标记的 <paramref name="source" /> 中读取带符号的 32 位值形式的整数值。</summary>
        <returns>如果整数表示值介于 <see cref="F:System.Int32.MinValue" /> 和 <see cref="F:System.Int32.MaxValue" />（含）之间，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt64">
      <MemberSignature Language="C#" Value="public static bool TryReadInt64 (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out long value, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadInt64(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int64&amp; value, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.TryReadInt64(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int64@,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadInt64 (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef value As Long, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryReadInt64 : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int64 * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="System.Formats.Asn1.AsnDecoder.TryReadInt64 (source, ruleSet, value, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="value" Type="System.Int64" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="value">成功时，将收到解释的数值。
该参数未经初始化即被处理。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 2）。</param>
        <summary>在指定编码规则下，尝试从带有指定标记的 <paramref name="source" /> 中读取带符号的 64 位值形式的整数值。</summary>
        <returns>如果整数表示值介于 <see cref="F:System.Int64.MinValue" /> 和 <see cref="F:System.Int64.MaxValue" />（含）之间，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadOctetString">
      <MemberSignature Language="C#" Value="public static bool TryReadOctetString (ReadOnlySpan&lt;byte&gt; source, Span&lt;byte&gt; destination, System.Formats.Asn1.AsnEncodingRules ruleSet, out int bytesConsumed, out int bytesWritten, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadOctetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Span`1&lt;unsigned int8&gt; destination, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; bytesConsumed, [out] int32&amp; bytesWritten, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.TryReadOctetString(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadOctetString (source As ReadOnlySpan(Of Byte), destination As Span(Of Byte), ruleSet As AsnEncodingRules, ByRef bytesConsumed As Integer, ByRef bytesWritten As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryReadOctetString : ReadOnlySpan&lt;byte&gt; * Span&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="System.Formats.Asn1.AsnDecoder.TryReadOctetString (source, destination, ruleSet, bytesConsumed, bytesWritten, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="destination">要写入的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <param name="bytesWritten">此方法返回时，为写入 <paramref name="destination" /> 的字节总数。
该参数未经初始化即被处理。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 4）。</param>
        <summary>在指定编码规则下，尝试从带有指定标记的 <paramref name="source" /> 中获取八进制字符串值，以将值复制到所提供的目标缓冲区。</summary>
        <returns>如果 <paramref name="destination" /> 足以接收八进制字符串的值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。
-或- <paramref name="destination" /> 与 <paramref name="source" /> 重叠。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadPrimitiveBitString">
      <MemberSignature Language="C#" Value="public static bool TryReadPrimitiveBitString (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int unusedBitCount, out ReadOnlySpan&lt;byte&gt; value, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadPrimitiveBitString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; unusedBitCount, [out] valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt;&amp; value, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.TryReadPrimitiveBitString(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.ReadOnlySpan{System.Byte}@,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadPrimitiveBitString (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef unusedBitCount As Integer, ByRef value As ReadOnlySpan(Of Byte), ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryReadPrimitiveBitString : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * ReadOnlySpan * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="System.Formats.Asn1.AsnDecoder.TryReadPrimitiveBitString (source, ruleSet, unusedBitCount, value, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="unusedBitCount" Type="System.Int32" RefType="out" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="unusedBitCount">成功时，将接收由编写器报告为“未使用”的最后一个字节中的位数。
该参数未经初始化即被处理。</param>
        <param name="value">成功时，将接收与位字符串的值相对应的输入缓冲区的切片。
该参数未经初始化即被处理。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 3）。</param>
        <summary>如果值包含在单个（基元）编码中，则尝试在指定编码规则下，从带有指定标记的 <paramref name="source" /> 中获取位字符串值。</summary>
        <returns>如果位字符串值具有基元编码，并且所有报告为“未使用”的位均设置为 0，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadPrimitiveCharacterStringBytes">
      <MemberSignature Language="C#" Value="public static bool TryReadPrimitiveCharacterStringBytes (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, System.Formats.Asn1.Asn1Tag expectedTag, out ReadOnlySpan&lt;byte&gt; value, out int bytesConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadPrimitiveCharacterStringBytes(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, valuetype System.Formats.Asn1.Asn1Tag expectedTag, [out] valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt;&amp; value, [out] int32&amp; bytesConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.TryReadPrimitiveCharacterStringBytes(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Formats.Asn1.Asn1Tag,System.ReadOnlySpan{System.Byte}@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadPrimitiveCharacterStringBytes (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, expectedTag As Asn1Tag, ByRef value As ReadOnlySpan(Of Byte), ByRef bytesConsumed As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadPrimitiveCharacterStringBytes(ReadOnlySpan&lt;System::Byte&gt; source, System::Formats::Asn1::AsnEncodingRules ruleSet, System::Formats::Asn1::Asn1Tag expectedTag, [Runtime::InteropServices::Out] ReadOnlySpan&lt;System::Byte&gt; % value, [Runtime::InteropServices::Out] int % bytesConsumed);" />
      <MemberSignature Language="F#" Value="static member TryReadPrimitiveCharacterStringBytes : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * System.Formats.Asn1.Asn1Tag * ReadOnlySpan * int -&gt; bool" Usage="System.Formats.Asn1.AsnDecoder.TryReadPrimitiveCharacterStringBytes (source, ruleSet, expectedTag, value, bytesConsumed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="expectedTag" Type="System.Formats.Asn1.Asn1Tag" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="expectedTag">读取前要检查的标记。</param>
        <param name="value">成功时，将接收与位字符串的值相对应的输入缓冲区的切片。
该参数未经初始化即被处理。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <summary>如果值包含在单个（基元）编码中，则尝试在指定编码规则下，从带有指定标记的 <paramref name="source" /> 中获取未处理的字符串值。</summary>
        <returns>如果该字符串值具有基元编码，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

此方法不确定字符串是否只使用编码所定义的字符。

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 不是字符串标记类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadPrimitiveOctetString">
      <MemberSignature Language="C#" Value="public static bool TryReadPrimitiveOctetString (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out ReadOnlySpan&lt;byte&gt; value, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadPrimitiveOctetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt;&amp; value, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.TryReadPrimitiveOctetString(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.ReadOnlySpan{System.Byte}@,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadPrimitiveOctetString (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef value As ReadOnlySpan(Of Byte), ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryReadPrimitiveOctetString : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * ReadOnlySpan * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="System.Formats.Asn1.AsnDecoder.TryReadPrimitiveOctetString (source, ruleSet, value, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="value">成功时，将接收与八进制字符串的值相对应的输入缓冲区的切片。
该参数未经初始化即被处理。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 4）。</param>
        <summary>如果值包含在单个（基元）编码中，则尝试在指定编码规则下，从带有指定标记的 <paramref name="source" /> 中获取八进制字符串值。</summary>
        <returns>如果该八进制字符串值具有基元编码，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt32">
      <MemberSignature Language="C#" Value="public static bool TryReadUInt32 (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out uint value, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadUInt32(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] unsigned int32&amp; value, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.TryReadUInt32(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.UInt32@,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadUInt32 (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef value As UInteger, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryReadUInt32 : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * uint32 * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="System.Formats.Asn1.AsnDecoder.TryReadUInt32 (source, ruleSet, value, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="value" Type="System.UInt32" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="value">成功时，将收到解释的数值。
该参数未经初始化即被处理。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 2）。</param>
        <summary>在指定编码规则下，尝试从带有指定标记的 <paramref name="source" /> 中读取无符号 32 位值形式的整数值。</summary>
        <returns>如果整数表示值介于 <see cref="F:System.UInt32.MinValue" /> 和 <see cref="F:System.UInt32.MaxValue" />（含）之间，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt64">
      <MemberSignature Language="C#" Value="public static bool TryReadUInt64 (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out ulong value, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadUInt64(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] unsigned int64&amp; value, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.TryReadUInt64(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.UInt64@,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadUInt64 (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef value As ULong, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryReadUInt64 : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * uint64 * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="System.Formats.Asn1.AsnDecoder.TryReadUInt64 (source, ruleSet, value, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="value" Type="System.UInt64" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">包含编码数据的缓冲区。</param>
        <param name="ruleSet">解释数据时要使用的编码约束。</param>
        <param name="value">成功时，将收到解释的数值。
该参数未经初始化即被处理。</param>
        <param name="bytesConsumed">此方法返回时，为编码值的字节总数。
该参数未经初始化即被处理。</param>
        <param name="expectedTag">读取前要检查的标记，或使用 <see langword="null" /> 作为默认标记（通用 2）。</param>
        <summary>在指定编码规则下，尝试从带有指定标记的 <paramref name="source" /> 中读取无符号 64 位值形式的整数值。</summary>
        <returns>如果整数表示值介于 <see cref="F:System.UInt64.MinValue" /> 和 <see cref="F:System.UInt64.MaxValue" />（含）之间，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">未定义 <paramref name="ruleSet" />。</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">下一个值没有正确的标记。
-或- 在当前编码规则下，长度编码无效。
-或- 在当前编码规则下，内容无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> 为 <see cref="F:System.Formats.Asn1.TagClass.Universal" />，但 <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> 对于此方法而言是不正确的。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
