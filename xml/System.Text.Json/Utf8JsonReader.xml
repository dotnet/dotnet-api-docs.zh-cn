<Type Name="Utf8JsonReader" FullName="System.Text.Json.Utf8JsonReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c01c6625bbe829ad4ab0ec34634165ad33becf51" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83891477" /></Metadata><TypeSignature Language="C#" Value="public struct Utf8JsonReader" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Utf8JsonReader extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Text.Json.Utf8JsonReader" />
  <TypeSignature Language="VB.NET" Value="Public Structure Utf8JsonReader" />
  <TypeSignature Language="C++ CLI" Value="public value class Utf8JsonReader" />
  <TypeSignature Language="F#" Value="type Utf8JsonReader = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Json</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.IsByRefLike</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="d9d99-101">提供高性能的 API，以便提供对 UTF-8 编码 JSON 文本的只进和只读访问权限。</span><span class="sxs-lookup"><span data-stu-id="d9d99-101">Provides a high-performance API for forward-only, read-only access to UTF-8 encoded JSON text.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="d9d99-102">`Utf8JsonReader` 在不缓存的情况下按顺序处理文本，并且默认严格遵循[JSON RFC](https://tools.ietf.org/html/rfc8259)。</span><span class="sxs-lookup"><span data-stu-id="d9d99-102">`Utf8JsonReader` processes the text sequentially with no caching and by default adheres strictly to the [JSON RFC](https://tools.ietf.org/html/rfc8259).</span></span>

<span data-ttu-id="d9d99-103">`Utf8JsonReader` 遇到无效的 JSON 时，它会引发 <xref:System.Text.Json.JsonException>，其中包含基本错误信息，如行号和行中的字节位置。</span><span class="sxs-lookup"><span data-stu-id="d9d99-103">When `Utf8JsonReader` encounters invalid JSON, it throws a <xref:System.Text.Json.JsonException> with basic error information like line number and byte position on the line.</span></span>

<span data-ttu-id="d9d99-104">由于此类型是 ref 结构，因此不直接支持 async。</span><span class="sxs-lookup"><span data-stu-id="d9d99-104">Since this type is a ref struct, it doesn't directly support async.</span></span> <span data-ttu-id="d9d99-105">但是，它确实支持重入操作读取不完整的数据，并在显示更多数据后继续读取。</span><span class="sxs-lookup"><span data-stu-id="d9d99-105">However, it does provide support for reentrancy to read incomplete data and to continue reading once more data is presented.</span></span>

<span data-ttu-id="d9d99-106">若要能够在读取或允许跳过注释时设置最大深度，请创建 <xref:System.Text.Json.JsonReaderOptions> 的实例并将其传递给读取器。</span><span class="sxs-lookup"><span data-stu-id="d9d99-106">To be able to set max depth while reading OR allow skipping comments, create an instance of <xref:System.Text.Json.JsonReaderOptions> and pass it to the reader.</span></span>

<span data-ttu-id="d9d99-107">有关详细信息，请参阅[如何序列化和反序列化 JSON](/dotnet/standard/serialization/system-text-json-how-to#use-utf8jsonreader)。</span><span class="sxs-lookup"><span data-stu-id="d9d99-107">For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to#use-utf8jsonreader).</span></span>

 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Utf8JsonReader (System.Buffers.ReadOnlySequence&lt;byte&gt; jsonData, System.Text.Json.JsonReaderOptions options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Buffers.ReadOnlySequence`1&lt;unsigned int8&gt; jsonData, valuetype System.Text.Json.JsonReaderOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.#ctor(System.Buffers.ReadOnlySequence{System.Byte},System.Text.Json.JsonReaderOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (jsonData As ReadOnlySequence(Of Byte), Optional options As JsonReaderOptions = null)" />
      <MemberSignature Language="F#" Value="new System.Text.Json.Utf8JsonReader : System.Buffers.ReadOnlySequence&lt;byte&gt; * System.Text.Json.JsonReaderOptions -&gt; System.Text.Json.Utf8JsonReader" Usage="new System.Text.Json.Utf8JsonReader (jsonData, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="jsonData" Type="System.Buffers.ReadOnlySequence&lt;System.Byte&gt;" />
        <Parameter Name="options" Type="System.Text.Json.JsonReaderOptions" />
      </Parameters>
      <Docs>
        <param name="jsonData"><span data-ttu-id="d9d99-108">要处理的 UTF-8 编码 JSON 文本。</span><span class="sxs-lookup"><span data-stu-id="d9d99-108">The UTF-8 encoded JSON text to process.</span></span></param>
        <param name="options"><span data-ttu-id="d9d99-109">定义 <see cref="T:System.Text.Json.Utf8JsonReader" /> 的自定义行为，它不同于 JSON RFC（例如，处理注释的方式，或读取时允许的最大深度）。</span><span class="sxs-lookup"><span data-stu-id="d9d99-109">Defines customized behavior of the <see cref="T:System.Text.Json.Utf8JsonReader" /> that differs from the JSON RFC (for example how to handle comments or maximum depth allowed when reading).</span></span> <span data-ttu-id="d9d99-110">默认情况下，<see cref="T:System.Text.Json.Utf8JsonReader" /> 严格遵循 JSON RFC（JSON 中的注释无效）且最大深度为 64。</span><span class="sxs-lookup"><span data-stu-id="d9d99-110">By default, the <see cref="T:System.Text.Json.Utf8JsonReader" /> follows the JSON RFC strictly; comments within the JSON are invalid, and the maximum depth is 64.</span></span></param>
        <summary><span data-ttu-id="d9d99-111">初始化 <see cref="T:System.Text.Json.Utf8JsonReader" /> 结构的新实例，该实例使用指定选项处理 UTF-8 编码文本的只读序列。</span><span class="sxs-lookup"><span data-stu-id="d9d99-111">Initializes a new instance of the <see cref="T:System.Text.Json.Utf8JsonReader" /> structure that processes a read-only sequence of UTF-8 encoded text using the specified options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="d9d99-112">由于此类型是一个 ref 结构，因此它是一个仅堆栈类型，并且 ref 结构的所有限制都适用于它。</span><span class="sxs-lookup"><span data-stu-id="d9d99-112">Since this type is a ref struct, it is a stack-only type, and all the limitations of ref structs apply to it.</span></span>

<span data-ttu-id="d9d99-113">此构造函数假定 `jsonData`中包含整个 JSON 有效负载;它等效于 <xref:System.Text.Json.Utf8JsonReader.IsFinalBlock?displayProperty=nameWithType> = `true`。</span><span class="sxs-lookup"><span data-stu-id="d9d99-113">This constructor assumes that the entire JSON payload is contained in `jsonData`; it is equivalent to <xref:System.Text.Json.Utf8JsonReader.IsFinalBlock?displayProperty=nameWithType> = `true`.</span></span>
              
          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Utf8JsonReader (ReadOnlySpan&lt;byte&gt; jsonData, System.Text.Json.JsonReaderOptions options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; jsonData, valuetype System.Text.Json.JsonReaderOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.#ctor(System.ReadOnlySpan{System.Byte},System.Text.Json.JsonReaderOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (jsonData As ReadOnlySpan(Of Byte), Optional options As JsonReaderOptions = null)" />
      <MemberSignature Language="F#" Value="new System.Text.Json.Utf8JsonReader : ReadOnlySpan&lt;byte&gt; * System.Text.Json.JsonReaderOptions -&gt; System.Text.Json.Utf8JsonReader" Usage="new System.Text.Json.Utf8JsonReader (jsonData, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="jsonData" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="options" Type="System.Text.Json.JsonReaderOptions" />
      </Parameters>
      <Docs>
        <param name="jsonData"><span data-ttu-id="d9d99-114">要处理的 UTF-8 编码 JSON 文本。</span><span class="sxs-lookup"><span data-stu-id="d9d99-114">The UTF-8 encoded JSON text to process.</span></span></param>
        <param name="options"><span data-ttu-id="d9d99-115">定义 <see cref="T:System.Text.Json.Utf8JsonReader" /> 的自定义行为，它不同于 JSON RFC（例如，处理注释的方式，或读取时允许的最大深度）。</span><span class="sxs-lookup"><span data-stu-id="d9d99-115">Defines customized behavior of the <see cref="T:System.Text.Json.Utf8JsonReader" /> that differs from the JSON RFC (for example how to handle comments or maximum depth allowed when reading).</span></span> <span data-ttu-id="d9d99-116">默认情况下，<see cref="T:System.Text.Json.Utf8JsonReader" /> 严格遵循 JSON RFC（JSON 中的注释无效）且最大深度为 64。</span><span class="sxs-lookup"><span data-stu-id="d9d99-116">By default, the <see cref="T:System.Text.Json.Utf8JsonReader" /> follows the JSON RFC strictly; comments within the JSON are invalid, and the maximum depth is 64.</span></span></param>
        <summary><span data-ttu-id="d9d99-117">初始化 <see cref="T:System.Text.Json.Utf8JsonReader" /> 结构的新实例，该实例使用指定选项处理 UTF-8 编码文本的只读范围。</span><span class="sxs-lookup"><span data-stu-id="d9d99-117">Initializes a new instance of the <see cref="T:System.Text.Json.Utf8JsonReader" /> structure that processes a read-only span of UTF-8 encoded text using the specified options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="d9d99-118">由于此类型是一个 ref 结构，因此它是一个仅堆栈类型，并且 ref 结构的所有限制都适用于它。</span><span class="sxs-lookup"><span data-stu-id="d9d99-118">Since this type is a ref struct, it is a stack-only type, and all the limitations of ref structs apply to it.</span></span>

<span data-ttu-id="d9d99-119">此构造函数假定 `jsonData`中包含整个 JSON 有效负载;它等效于 <xref:System.Text.Json.Utf8JsonReader.IsFinalBlock?displayProperty=nameWithType> = `true`。</span><span class="sxs-lookup"><span data-stu-id="d9d99-119">This constructor assumes that the entire JSON payload is contained in `jsonData`; it is equivalent to <xref:System.Text.Json.Utf8JsonReader.IsFinalBlock?displayProperty=nameWithType> = `true`.</span></span>
              
          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Utf8JsonReader (System.Buffers.ReadOnlySequence&lt;byte&gt; jsonData, bool isFinalBlock, System.Text.Json.JsonReaderState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Buffers.ReadOnlySequence`1&lt;unsigned int8&gt; jsonData, bool isFinalBlock, valuetype System.Text.Json.JsonReaderState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.#ctor(System.Buffers.ReadOnlySequence{System.Byte},System.Boolean,System.Text.Json.JsonReaderState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (jsonData As ReadOnlySequence(Of Byte), isFinalBlock As Boolean, state As JsonReaderState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Utf8JsonReader(System::Buffers::ReadOnlySequence&lt;System::Byte&gt; jsonData, bool isFinalBlock, System::Text::Json::JsonReaderState state);" />
      <MemberSignature Language="F#" Value="new System.Text.Json.Utf8JsonReader : System.Buffers.ReadOnlySequence&lt;byte&gt; * bool * System.Text.Json.JsonReaderState -&gt; System.Text.Json.Utf8JsonReader" Usage="new System.Text.Json.Utf8JsonReader (jsonData, isFinalBlock, state)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="jsonData" Type="System.Buffers.ReadOnlySequence&lt;System.Byte&gt;" />
        <Parameter Name="isFinalBlock" Type="System.Boolean" />
        <Parameter Name="state" Type="System.Text.Json.JsonReaderState" />
      </Parameters>
      <Docs>
        <param name="jsonData"><span data-ttu-id="d9d99-120">要处理的 UTF-8 编码 JSON 文本。</span><span class="sxs-lookup"><span data-stu-id="d9d99-120">The UTF-8 encoded JSON text to process.</span></span></param>
        <param name="isFinalBlock"><span data-ttu-id="d9d99-121"><see langword="true" /> 用于表示输入序列包含要处理的全部数据；<see langword="false" /> 用于表示输入范围包含部分数据，随后还有更多数据。</span><span class="sxs-lookup"><span data-stu-id="d9d99-121"><see langword="true" /> to indicate that the input sequence contains the entire data to process; <see langword="false" /> to indicate that the input span contains partial data with more data to follow.</span></span></param>
        <param name="state"><span data-ttu-id="d9d99-122">包含读取器状态的对象。</span><span class="sxs-lookup"><span data-stu-id="d9d99-122">An object that contains the reader state.</span></span> <span data-ttu-id="d9d99-123">如果这是构造函数的第一次调用，则传递默认状态；否则，请从 <see cref="T:System.Text.Json.Utf8JsonReader" /> 的上一个实例中传递 <see cref="P:System.Text.Json.Utf8JsonReader.CurrentState" /> 属性的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-123">If this is the first call to the constructor, pass the default state; otherwise, pass the value of the <see cref="P:System.Text.Json.Utf8JsonReader.CurrentState" /> property from the previous instance of the <see cref="T:System.Text.Json.Utf8JsonReader" />.</span></span></param>
        <summary><span data-ttu-id="d9d99-124">初始化 <see cref="T:System.Text.Json.Utf8JsonReader" /> 结构的新实例，该实例用于处理 UTF-8 编码文本的只读序列，并指示输入是否包含要处理的所有文本。</span><span class="sxs-lookup"><span data-stu-id="d9d99-124">Initializes a new instance of the <see cref="T:System.Text.Json.Utf8JsonReader" /> structure that processes a read-only sequence of UTF-8 encoded text and indicates whether the input contains all the text to process.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="d9d99-125">由于此类型是一个 ref 结构，因此它是一个仅堆栈类型，并且 ref 结构的所有限制都适用于它。</span><span class="sxs-lookup"><span data-stu-id="d9d99-125">Since this type is a ref struct, it is a stack-only type, and all the limitations of ref structs apply to it.</span></span>
<span data-ttu-id="d9d99-126">这是构造函数接受 <xref:System.Text.Json.JsonReaderState>的原因。</span><span class="sxs-lookup"><span data-stu-id="d9d99-126">This is the reason why the constructor accepts a <xref:System.Text.Json.JsonReaderState>.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Utf8JsonReader (ReadOnlySpan&lt;byte&gt; jsonData, bool isFinalBlock, System.Text.Json.JsonReaderState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; jsonData, bool isFinalBlock, valuetype System.Text.Json.JsonReaderState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.#ctor(System.ReadOnlySpan{System.Byte},System.Boolean,System.Text.Json.JsonReaderState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (jsonData As ReadOnlySpan(Of Byte), isFinalBlock As Boolean, state As JsonReaderState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Utf8JsonReader(ReadOnlySpan&lt;System::Byte&gt; jsonData, bool isFinalBlock, System::Text::Json::JsonReaderState state);" />
      <MemberSignature Language="F#" Value="new System.Text.Json.Utf8JsonReader : ReadOnlySpan&lt;byte&gt; * bool * System.Text.Json.JsonReaderState -&gt; System.Text.Json.Utf8JsonReader" Usage="new System.Text.Json.Utf8JsonReader (jsonData, isFinalBlock, state)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="jsonData" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="isFinalBlock" Type="System.Boolean" />
        <Parameter Name="state" Type="System.Text.Json.JsonReaderState" />
      </Parameters>
      <Docs>
        <param name="jsonData"><span data-ttu-id="d9d99-127">要处理的 UTF-8 编码 JSON 文本。</span><span class="sxs-lookup"><span data-stu-id="d9d99-127">The UTF-8 encoded JSON text to process.</span></span></param>
        <param name="isFinalBlock"><span data-ttu-id="d9d99-128"><see langword="true" /> 用于表示输入序列包含要处理的全部数据；<see langword="false" /> 用于表示输入范围包含部分数据，随后还有更多数据。</span><span class="sxs-lookup"><span data-stu-id="d9d99-128"><see langword="true" /> to indicate that the input sequence contains the entire data to process; <see langword="false" /> to indicate that the input span contains partial data with more data to follow.</span></span></param>
        <param name="state"><span data-ttu-id="d9d99-129">包含读取器状态的对象。</span><span class="sxs-lookup"><span data-stu-id="d9d99-129">An object that contains the reader state.</span></span> <span data-ttu-id="d9d99-130">如果这是构造函数的第一次调用，则传递默认状态；否则，请从 <see cref="T:System.Text.Json.Utf8JsonReader" /> 的上一个实例中传递 <see cref="P:System.Text.Json.Utf8JsonReader.CurrentState" /> 属性的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-130">If this is the first call to the constructor, pass the default state; otherwise, pass the value of the <see cref="P:System.Text.Json.Utf8JsonReader.CurrentState" /> property from the previous instance of the <see cref="T:System.Text.Json.Utf8JsonReader" />.</span></span></param>
        <summary><span data-ttu-id="d9d99-131">初始化 <see cref="T:System.Text.Json.Utf8JsonReader" /> 结构的新实例，该实例用于处理 UTF-8 编码文本的只读范围，并指示输入是否包含要处理的所有文本。</span><span class="sxs-lookup"><span data-stu-id="d9d99-131">Initializes a new instance of the <see cref="T:System.Text.Json.Utf8JsonReader" /> structure that processes a read-only span of UTF-8 encoded text and indicates whether the input contains all the text to process.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="d9d99-132">由于此类型是一个 ref 结构，因此它是一个仅堆栈类型，并且 ref 结构的所有限制都适用于它。</span><span class="sxs-lookup"><span data-stu-id="d9d99-132">Since this type is a ref struct, it is a stack-only type, and all the limitations of ref structs apply to it.</span></span>
<span data-ttu-id="d9d99-133">这是构造函数接受 <xref:System.Text.Json.JsonReaderState>的原因。</span><span class="sxs-lookup"><span data-stu-id="d9d99-133">This is the reason why the constructor accepts a <xref:System.Text.Json.JsonReaderState>.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BytesConsumed">
      <MemberSignature Language="C#" Value="public long BytesConsumed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 BytesConsumed" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.BytesConsumed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BytesConsumed As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long BytesConsumed { long get(); };" />
      <MemberSignature Language="F#" Value="member this.BytesConsumed : int64" Usage="System.Text.Json.Utf8JsonReader.BytesConsumed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d9d99-134">获取 <see cref="T:System.Text.Json.Utf8JsonReader" /> 的此实例到目前为止使用的总字节数。</span><span class="sxs-lookup"><span data-stu-id="d9d99-134">Gets the total number of bytes consumed so far by this instance of the <see cref="T:System.Text.Json.Utf8JsonReader" />.</span></span></summary>
        <value><span data-ttu-id="d9d99-135">迄今为止使用的总字节数。</span><span class="sxs-lookup"><span data-stu-id="d9d99-135">The total number of bytes consumed so far.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentDepth">
      <MemberSignature Language="C#" Value="public int CurrentDepth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentDepth" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.CurrentDepth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentDepth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentDepth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDepth : int" Usage="System.Text.Json.Utf8JsonReader.CurrentDepth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d9d99-136">获取当前标记的深度。</span><span class="sxs-lookup"><span data-stu-id="d9d99-136">Gets the depth of the current token.</span></span></summary>
        <value><span data-ttu-id="d9d99-137">当前标记的深度。</span><span class="sxs-lookup"><span data-stu-id="d9d99-137">The depth of the current token.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="d9d99-138">`CurrentDepth` 属性跟踪到目前为止处理的 JSON 文本中的嵌套对象或数组的递归深度。</span><span class="sxs-lookup"><span data-stu-id="d9d99-138">The `CurrentDepth` property tracks the recursive depth of the nested objects or arrays within the JSON text processed so far.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentState">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonReaderState CurrentState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.Json.JsonReaderState CurrentState" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.CurrentState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentState As JsonReaderState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::JsonReaderState CurrentState { System::Text::Json::JsonReaderState get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentState : System.Text.Json.JsonReaderState" Usage="System.Text.Json.Utf8JsonReader.CurrentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonReaderState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d9d99-139">获取当前 <see cref="T:System.Text.Json.Utf8JsonReader" /> 状态，将更多数据传递到 <see cref="T:System.Text.Json.Utf8JsonReader" /> 构造函数。</span><span class="sxs-lookup"><span data-stu-id="d9d99-139">Gets the current <see cref="T:System.Text.Json.Utf8JsonReader" /> state to pass to a <see cref="T:System.Text.Json.Utf8JsonReader" /> constructor with more data.</span></span></summary>
        <value><span data-ttu-id="d9d99-140">当前读取器状态。</span><span class="sxs-lookup"><span data-stu-id="d9d99-140">The current reader state.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="d9d99-141">与作为 ref 结构的 <xref:System.Text.Json.Utf8JsonReader>不同，状态可在异步/等待边界内保留。</span><span class="sxs-lookup"><span data-stu-id="d9d99-141">Unlike the <xref:System.Text.Json.Utf8JsonReader>, which is a ref struct, the state can survive across async/await boundaries.</span></span> <span data-ttu-id="d9d99-142">此类型需要在继续使用 <xref:System.Text.Json.Utf8JsonReader>的新实例之前，为异步读取更多数据提供支持。</span><span class="sxs-lookup"><span data-stu-id="d9d99-142">This type is required to provide support for reading in more data asynchronously before continuing with a new instance of the <xref:System.Text.Json.Utf8JsonReader>.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBoolean">
      <MemberSignature Language="C#" Value="public bool GetBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetBoolean();" />
      <MemberSignature Language="F#" Value="member this.GetBoolean : unit -&gt; bool" Usage="utf8JsonReader.GetBoolean " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d9d99-143">从源中将下一个 JSON 令牌值读取为 <see cref="T:System.Boolean" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-143">Reads the next JSON token value from the source as a <see cref="T:System.Boolean" />.</span></span></summary>
        <returns><span data-ttu-id="d9d99-144">如果 <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> 为 <see cref="F:System.Text.Json.JsonTokenType.True" />，则为 <see langword="true" />；如果 <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> 为 <see cref="F:System.Text.Json.JsonTokenType.False" />，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-144"><see langword="true" /> if the <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> is <see cref="F:System.Text.Json.JsonTokenType.True" />; <see langword="false" /> if the <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> is <see cref="F:System.Text.Json.JsonTokenType.False" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-145">JSON 令牌的值不是布尔值（即 <see cref="F:System.Text.Json.JsonTokenType.True" /> 或 <see cref="F:System.Text.Json.JsonTokenType.False" />）。</span><span class="sxs-lookup"><span data-stu-id="d9d99-145">The value of the JSON token isn't a boolean value (that is, <see cref="F:System.Text.Json.JsonTokenType.True" /> or <see cref="F:System.Text.Json.JsonTokenType.False" />).</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetByte">
      <MemberSignature Language="C#" Value="public byte GetByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8 GetByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetByte" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByte () As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Byte GetByte();" />
      <MemberSignature Language="F#" Value="member this.GetByte : unit -&gt; byte" Usage="utf8JsonReader.GetByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d9d99-146">将源中的当前 JSON 令牌值分析为 <see cref="T:System.Byte" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-146">Parses the current JSON token value from the source as a <see cref="T:System.Byte" />.</span></span></summary>
        <returns><span data-ttu-id="d9d99-147">UTF-8 编码令牌的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-147">The value of the UTF-8 encoded token.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-148">JSON 令牌的值不是 <see cref="F:System.Text.Json.JsonTokenType.Number" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-148">The value of the JSON token is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="d9d99-149">JSON 令牌值的数字格式不正确（例如，它包含小数值或使用科学记数法编写）。</span><span class="sxs-lookup"><span data-stu-id="d9d99-149">The numeric format of the JSON token value is incorrect (for example, it contains a fractional value or is written in scientific notation).</span></span>
          
<span data-ttu-id="d9d99-150">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d9d99-150">-or-</span></span>

<span data-ttu-id="d9d99-151">JSON 令牌值表示小于 <see cref="F:System.Byte.MinValue" /> 或大于 <see cref="F:System.Byte.MaxValue" /> 的数字。</span><span class="sxs-lookup"><span data-stu-id="d9d99-151">The JSON token value represents a number less than <see cref="F:System.Byte.MinValue" /> or greater than <see cref="F:System.Byte.MaxValue" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetBytesFromBase64">
      <MemberSignature Language="C#" Value="public byte[] GetBytesFromBase64 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytesFromBase64() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetBytesFromBase64" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytesFromBase64 () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytesFromBase64();" />
      <MemberSignature Language="F#" Value="member this.GetBytesFromBase64 : unit -&gt; byte[]" Usage="utf8JsonReader.GetBytesFromBase64 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d9d99-152">分析源中的当前 JSON 令牌值并将 Base64 编码的 JSON 字符串解码为字节数组。</span><span class="sxs-lookup"><span data-stu-id="d9d99-152">Parses the current JSON token value from the source and decodes the Base64 encoded JSON string as a byte array.</span></span></summary>
        <returns><span data-ttu-id="d9d99-153">表示当前 JSON 令牌值的字节数组。</span><span class="sxs-lookup"><span data-stu-id="d9d99-153">The byte array that represents the current JSON token value.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-154">JSON 令牌的类型不是 <see cref="F:System.Text.Json.JsonTokenType.String" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-154">The type of the JSON token is not a <see cref="F:System.Text.Json.JsonTokenType.String" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="d9d99-155">值未编码为 base 64 文本，因此无法解码为字节。</span><span class="sxs-lookup"><span data-stu-id="d9d99-155">The value is not encoded as Base64 text, so it can't be decoded to bytes.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetComment">
      <MemberSignature Language="C#" Value="public string GetComment ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetComment() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetComment" />
      <MemberSignature Language="VB.NET" Value="Public Function GetComment () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetComment();" />
      <MemberSignature Language="F#" Value="member this.GetComment : unit -&gt; string" Usage="utf8JsonReader.GetComment " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d9d99-156">将源中的当前 JSON 令牌值分析为注释，将其转码为 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-156">Parses the current JSON token value from the source as a comment, transcoded it as a <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="d9d99-157">表示当前 JSON 令牌值的注释。</span><span class="sxs-lookup"><span data-stu-id="d9d99-157">The comment that represents the current JSON token value.</span></span></returns>
        <remarks><span data-ttu-id="d9d99-158">这仅适用于使用 <see cref="F:System.Text.Json.JsonCommentHandling.Allow" /> 选项构造读取器的情况。</span><span class="sxs-lookup"><span data-stu-id="d9d99-158">This is only applicable when the reader is constructed using the <see cref="F:System.Text.Json.JsonCommentHandling.Allow" /> option.</span></span> <span data-ttu-id="d9d99-159">否则，将永远不会 <see cref="F:System.Text.Json.JsonTokenType.Comment" /><see cref="P:System.Text.Json.Utf8JsonReader.TokenType" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-159">Otherwise, the <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> will never be <see cref="F:System.Text.Json.JsonTokenType.Comment" />.</span></span></remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-160">JSON 令牌不是注释。</span><span class="sxs-lookup"><span data-stu-id="d9d99-160">The JSON token is not a comment.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetDateTime">
      <MemberSignature Language="C#" Value="public DateTime GetDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime GetDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetDateTime" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDateTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime GetDateTime();" />
      <MemberSignature Language="F#" Value="member this.GetDateTime : unit -&gt; DateTime" Usage="utf8JsonReader.GetDateTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d9d99-161">从源中读取下一个 JSON 令牌值，并将该值解析为 <see cref="T:System.DateTime" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-161">Reads the next JSON token value from the source and parses it to a <see cref="T:System.DateTime" />.</span></span></summary>
        <returns><span data-ttu-id="d9d99-162">如果可成功解析整个 UTF-8 编码的令牌值，则为日期和时间值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-162">The date and time value, if the entire UTF-8 encoded token value can be successfully parsed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="d9d99-163">此方法仅创建符合 ISO 8601-1 扩展格式的 JSON 字符串的 <xref:System.DateTime> 表示形式（请参阅[系统中的 DateTime 和 DateTimeOffset 支持](/dotnet/standard/datetime/system-text-json-support)）。</span><span class="sxs-lookup"><span data-stu-id="d9d99-163">This method only creates a <xref:System.DateTime> representation of JSON strings that conform to the ISO 8601-1 extended format (see [DateTime and DateTimeOffset support in System.Text.Json](/dotnet/standard/datetime/system-text-json-support)).</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-164">JSON 令牌的值不是 <see cref="F:System.Text.Json.JsonTokenType.String" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-164">The value of the JSON token isn't a <see cref="F:System.Text.Json.JsonTokenType.String" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="d9d99-165">JSON 令牌值不可作为 <see cref="T:System.DateTime" /> 读取。</span><span class="sxs-lookup"><span data-stu-id="d9d99-165">The JSON token value cannot be read as a <see cref="T:System.DateTime" />.</span></span>
        
<span data-ttu-id="d9d99-166">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d9d99-166">-or-</span></span> 
<span data-ttu-id="d9d99-167">无法将整个 UTF-8 编码令牌值解析为 <see cref="T:System.DateTime" /> 值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-167">The entire UTF-8 encoded token value cannot be parsed to a <see cref="T:System.DateTime" /> value.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetDateTimeOffset">
      <MemberSignature Language="C#" Value="public DateTimeOffset GetDateTimeOffset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset GetDateTimeOffset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetDateTimeOffset" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDateTimeOffset () As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset GetDateTimeOffset();" />
      <MemberSignature Language="F#" Value="member this.GetDateTimeOffset : unit -&gt; DateTimeOffset" Usage="utf8JsonReader.GetDateTimeOffset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d9d99-168">从源中读取下一个 JSON 令牌值，并将该值解析为 <see cref="T:System.DateTimeOffset" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-168">Reads the next JSON token value from the source and parses it to a <see cref="T:System.DateTimeOffset" />.</span></span></summary>
        <returns><span data-ttu-id="d9d99-169">如果可成功解析整个 UTF-8 编码的令牌值，则为日期和时间偏移。</span><span class="sxs-lookup"><span data-stu-id="d9d99-169">The date and time offset, if the entire UTF-8 encoded token value can be successfully parsed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="d9d99-170">此方法仅创建符合 ISO 8601-1 扩展格式的 JSON 字符串的 <xref:System.DateTimeOffset> 表示形式（请参阅[系统中的 DateTime 和 DateTimeOffset 支持](/dotnet/standard/datetime/system-text-json-support)）。</span><span class="sxs-lookup"><span data-stu-id="d9d99-170">This method only creates a <xref:System.DateTimeOffset> representation of JSON strings that conform to the ISO 8601-1 extended format (see [DateTime and DateTimeOffset support in System.Text.Json](/dotnet/standard/datetime/system-text-json-support)).</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-171">JSON 令牌的值不是 <see cref="F:System.Text.Json.JsonTokenType.String" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-171">The value of the JSON token isn't a <see cref="F:System.Text.Json.JsonTokenType.String" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="d9d99-172">JSON 令牌值不可作为 <see cref="T:System.DateTimeOffset" /> 读取。</span><span class="sxs-lookup"><span data-stu-id="d9d99-172">The JSON token value cannot be read as a <see cref="T:System.DateTimeOffset" />.</span></span>

<span data-ttu-id="d9d99-173">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d9d99-173">-or-</span></span> 
<span data-ttu-id="d9d99-174">无法将整个 UTF-8 编码令牌值解析为 <see cref="T:System.DateTimeOffset" /> 值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-174">The entire UTF-8 encoded token value cannot be parsed to a <see cref="T:System.DateTimeOffset" /> value.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetDecimal">
      <MemberSignature Language="C#" Value="public decimal GetDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Decimal GetDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Decimal GetDecimal();" />
      <MemberSignature Language="F#" Value="member this.GetDecimal : unit -&gt; decimal" Usage="utf8JsonReader.GetDecimal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d9d99-175">从源中读取下一个 JSON 令牌值，并将该值解析为 <see cref="T:System.Decimal" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-175">Reads the next JSON token value from the source and parses it to a <see cref="T:System.Decimal" />.</span></span></summary>
        <returns><span data-ttu-id="d9d99-176">解析为 <see cref="T:System.Decimal" /> 的 UTF-8 编码令牌值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-176">The UTF-8 encoded token value parsed to a <see cref="T:System.Decimal" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-177">JSON 令牌值不是 <see cref="F:System.Text.Json.JsonTokenType.Number" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-177">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="d9d99-178">JSON 令牌值表示小于 <see cref="F:System.Decimal.MinValue" /> 或大于 <see cref="F:System.Decimal.MaxValue" /> 的数字。</span><span class="sxs-lookup"><span data-stu-id="d9d99-178">The JSON token value represents a number less than <see cref="F:System.Decimal.MinValue" /> or greater than <see cref="F:System.Decimal.MaxValue" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetDouble">
      <MemberSignature Language="C#" Value="public double GetDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetDouble" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetDouble();" />
      <MemberSignature Language="F#" Value="member this.GetDouble : unit -&gt; double" Usage="utf8JsonReader.GetDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d9d99-179">从源中读取下一个 JSON 令牌值，并将该值解析为 <see cref="T:System.Double" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-179">Reads the next JSON token value from the source and parses it to a <see cref="T:System.Double" />.</span></span></summary>
        <returns><span data-ttu-id="d9d99-180">解析为 <see cref="T:System.Double" /> 的 UTF-8 编码令牌值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-180">The UTF-8 encoded token value parsed to a <see cref="T:System.Double" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-181">JSON 令牌值不是 <see cref="F:System.Text.Json.JsonTokenType.Number" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-181">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="d9d99-182">JSON 令牌值表示小于 <see cref="F:System.Double.MinValue" /> 或大于 <see cref="F:System.Double.MaxValue" /> 的数字。</span><span class="sxs-lookup"><span data-stu-id="d9d99-182">The JSON token value represents a number less than <see cref="F:System.Double.MinValue" /> or greater than <see cref="F:System.Double.MaxValue" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetGuid">
      <MemberSignature Language="C#" Value="public Guid GetGuid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Guid GetGuid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetGuid" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGuid () As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Guid GetGuid();" />
      <MemberSignature Language="F#" Value="member this.GetGuid : unit -&gt; Guid" Usage="utf8JsonReader.GetGuid " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d9d99-183">从源中读取下一个 JSON 令牌值，并将该值解析为 <see cref="T:System.Guid" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-183">Reads the next JSON token value from the source and parses it to a <see cref="T:System.Guid" />.</span></span></summary>
        <returns><span data-ttu-id="d9d99-184">如果可成功解析整个 UTF-8 编码的令牌值，则为 GUID 值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-184">The GUID value, if the entire UTF-8 encoded token value can be successfully parsed.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-185">JSON 令牌的值不是 <see cref="F:System.Text.Json.JsonTokenType.String" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-185">The value of the JSON token isn't a <see cref="F:System.Text.Json.JsonTokenType.String" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="d9d99-186">Guid 不支持 JSON 令牌值的格式。</span><span class="sxs-lookup"><span data-stu-id="d9d99-186">The JSON token value is in an unsupported format for a Guid.</span></span>
        
<span data-ttu-id="d9d99-187">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d9d99-187">-or-</span></span>

<span data-ttu-id="d9d99-188">无法将整个 UTF-8 编码令牌值解析为 <see cref="T:System.Guid" /> 值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-188">The entire UTF-8 encoded token value cannot be parsed to a <see cref="T:System.Guid" /> value.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetInt16">
      <MemberSignature Language="C#" Value="public short GetInt16 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int16 GetInt16() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetInt16" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInt16 () As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; short GetInt16();" />
      <MemberSignature Language="F#" Value="member this.GetInt16 : unit -&gt; int16" Usage="utf8JsonReader.GetInt16 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d9d99-189">将源中的当前 JSON 令牌值分析为 <see cref="T:System.Int16" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-189">Parses the current JSON token value from the source as a <see cref="T:System.Int16" />.</span></span></summary>
        <returns><span data-ttu-id="d9d99-190">解析为 <see cref="T:System.Int16" /> 的 UTF-8 编码令牌值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-190">The UTF-8 encoded token value parsed to an <see cref="T:System.Int16" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-191">JSON 令牌的值不是 <see cref="F:System.Text.Json.JsonTokenType.Number" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-191">The value of the JSON token is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="d9d99-192">JSON 令牌值的数字格式不正确（例如，它包含小数值或使用科学记数法编写）。</span><span class="sxs-lookup"><span data-stu-id="d9d99-192">The numeric format of the JSON token value is incorrect (for example, it contains a fractional value or is written in scientific notation).</span></span>
          
<span data-ttu-id="d9d99-193">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d9d99-193">-or-</span></span>

<span data-ttu-id="d9d99-194">JSON 令牌值表示小于 <see cref="F:System.Int16.MinValue" /> 或大于 <see cref="F:System.Int16.MaxValue" /> 的数字。</span><span class="sxs-lookup"><span data-stu-id="d9d99-194">The JSON token value represents a number less than <see cref="F:System.Int16.MinValue" /> or greater than <see cref="F:System.Int16.MaxValue" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetInt32">
      <MemberSignature Language="C#" Value="public int GetInt32 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetInt32() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetInt32" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInt32 () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetInt32();" />
      <MemberSignature Language="F#" Value="member this.GetInt32 : unit -&gt; int" Usage="utf8JsonReader.GetInt32 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d9d99-195">从源中读取下一个 JSON 令牌值，并将该值解析为 <see cref="T:System.Int32" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-195">Reads the next JSON token value from the source and parses it to an <see cref="T:System.Int32" />.</span></span></summary>
        <returns><span data-ttu-id="d9d99-196">解析为 <see cref="T:System.Int32" /> 的 UTF-8 编码令牌值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-196">The UTF-8 encoded token value parsed to an <see cref="T:System.Int32" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-197">JSON 令牌值不是 <see cref="F:System.Text.Json.JsonTokenType.Number" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-197">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="d9d99-198">JSON 令牌值的数值格式不正确。</span><span class="sxs-lookup"><span data-stu-id="d9d99-198">The JSON token value is of the incorrect numeric format.</span></span> <span data-ttu-id="d9d99-199">例如，它包含小数或采用科学记数法编写。</span><span class="sxs-lookup"><span data-stu-id="d9d99-199">For example, it contains a decimal or is written in scientific notation.</span></span>
            
<span data-ttu-id="d9d99-200">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d9d99-200">-or-</span></span>

<span data-ttu-id="d9d99-201">JSON 令牌值表示小于 <see cref="F:System.Int32.MinValue" /> 或大于 <see cref="F:System.Int32.MaxValue" /> 的数字。</span><span class="sxs-lookup"><span data-stu-id="d9d99-201">The JSON token value represents a number less than <see cref="F:System.Int32.MinValue" /> or greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetInt64">
      <MemberSignature Language="C#" Value="public long GetInt64 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetInt64() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetInt64" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInt64 () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetInt64();" />
      <MemberSignature Language="F#" Value="member this.GetInt64 : unit -&gt; int64" Usage="utf8JsonReader.GetInt64 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d9d99-202">从源中读取下一个 JSON 令牌值，并将该值解析为 <see cref="T:System.Int64" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-202">Reads the next JSON token value from the source and parses it to an <see cref="T:System.Int64" />.</span></span></summary>
        <returns><span data-ttu-id="d9d99-203">解析为 <see cref="T:System.Int64" /> 的 UTF-8 编码令牌值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-203">The UTF-8 encoded token value parsed to an <see cref="T:System.Int64" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-204">JSON 令牌值不是 <see cref="F:System.Text.Json.JsonTokenType.Number" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-204">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="d9d99-205">JSON 令牌值的数值格式不正确。</span><span class="sxs-lookup"><span data-stu-id="d9d99-205">The JSON token value is of the incorrect numeric format.</span></span> <span data-ttu-id="d9d99-206">例如，它包含小数或采用科学记数法编写。</span><span class="sxs-lookup"><span data-stu-id="d9d99-206">For example, it contains a decimal or is written in scientific notation.</span></span>
            
<span data-ttu-id="d9d99-207">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d9d99-207">-or-</span></span>

<span data-ttu-id="d9d99-208">JSON 令牌值表示小于 <see cref="F:System.Int64.MinValue" /> 或大于 <see cref="F:System.Int64.MaxValue" /> 的数字。</span><span class="sxs-lookup"><span data-stu-id="d9d99-208">The JSON token value represents a number less than <see cref="F:System.Int64.MinValue" /> or greater than <see cref="F:System.Int64.MaxValue" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetSByte">
      <MemberSignature Language="C#" Value="public sbyte GetSByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int8 GetSByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetSByte" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSByte () As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::SByte GetSByte();" />
      <MemberSignature Language="F#" Value="member this.GetSByte : unit -&gt; sbyte" Usage="utf8JsonReader.GetSByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d9d99-209">将源中的当前 JSON 令牌值分析为 <see cref="T:System.SByte" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-209">Parses the current JSON token value from the source as an <see cref="T:System.SByte" />.</span></span></summary>
        <returns><span data-ttu-id="d9d99-210">解析为 <see cref="T:System.SByte" /> 的 UTF-8 编码令牌值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-210">The UTF-8 encoded token value parsed to an <see cref="T:System.SByte" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-211">JSON 令牌的值不是 <see cref="F:System.Text.Json.JsonTokenType.Number" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-211">The value of the JSON token is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="d9d99-212">JSON 令牌值的数字格式不正确（例如，它包含小数值或使用科学记数法编写）。</span><span class="sxs-lookup"><span data-stu-id="d9d99-212">The numeric format of the JSON token value is incorrect (for example, it contains a fractional value or is written in scientific notation).</span></span>
          
<span data-ttu-id="d9d99-213">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d9d99-213">-or-</span></span>

<span data-ttu-id="d9d99-214">JSON 令牌值表示小于 <see cref="F:System.SByte.MinValue" /> 或大于 <see cref="F:System.SByte.MaxValue" /> 的数字。</span><span class="sxs-lookup"><span data-stu-id="d9d99-214">The JSON token value represents a number less than <see cref="F:System.SByte.MinValue" /> or greater than <see cref="F:System.SByte.MaxValue" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetSingle">
      <MemberSignature Language="C#" Value="public float GetSingle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float32 GetSingle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetSingle" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSingle () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; float GetSingle();" />
      <MemberSignature Language="F#" Value="member this.GetSingle : unit -&gt; single" Usage="utf8JsonReader.GetSingle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d9d99-215">从源中读取下一个 JSON 令牌值，并将该值解析为 <see cref="T:System.Single" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-215">Reads the next JSON token value from the source and parses it to a <see cref="T:System.Single" />.</span></span></summary>
        <returns><span data-ttu-id="d9d99-216">解析为 <see cref="T:System.Single" /> 的 UTF-8 编码令牌值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-216">The UTF-8 encoded token value parsed to a <see cref="T:System.Single" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-217">JSON 令牌值不是 <see cref="F:System.Text.Json.JsonTokenType.Number" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-217">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="d9d99-218">JSON 令牌值表示小于 <see cref="F:System.Single.MinValue" /> 或大于 <see cref="F:System.Single.MaxValue" /> 的数字。</span><span class="sxs-lookup"><span data-stu-id="d9d99-218">The JSON token value represents a number less than <see cref="F:System.Single.MinValue" /> or greater than <see cref="F:System.Single.MaxValue" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetString" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString();" />
      <MemberSignature Language="F#" Value="member this.GetString : unit -&gt; string" Usage="utf8JsonReader.GetString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d9d99-219">从源中读取下一个 JSON 令牌值，并作为字符串进行反转义和转码。</span><span class="sxs-lookup"><span data-stu-id="d9d99-219">Reads the next JSON token value from the source, unescaped, and transcoded as a string.</span></span></summary>
        <returns><span data-ttu-id="d9d99-220">令牌值分析为字符串，如果 <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> 为 <see cref="F:System.Text.Json.JsonTokenType.Null" />，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-220">The token value parsed to a string, or <see langword="null" /> if <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> is <see cref="F:System.Text.Json.JsonTokenType.Null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="d9d99-221">当 <xref:System.Text.Json.Utf8JsonReader.TokenType> <xref:System.Text.Json.JsonTokenType.Null?displayProperty=nameWithType>时，返回 `null`。</span><span class="sxs-lookup"><span data-stu-id="d9d99-221">Returns `null` when <xref:System.Text.Json.Utf8JsonReader.TokenType> is <xref:System.Text.Json.JsonTokenType.Null?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-222">JSON 令牌值不是字符串（即不是 <see cref="F:System.Text.Json.JsonTokenType.String" /><see cref="F:System.Text.Json.JsonTokenType.PropertyName" /> 或 <see cref="F:System.Text.Json.JsonTokenType.Null" />）。</span><span class="sxs-lookup"><span data-stu-id="d9d99-222">The JSON token value isn't a string (that is, not a <see cref="F:System.Text.Json.JsonTokenType.String" />, <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />, or <see cref="F:System.Text.Json.JsonTokenType.Null" />).</span></span>

<span data-ttu-id="d9d99-223">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d9d99-223">-or-</span></span>

<span data-ttu-id="d9d99-224">JSON 字符串包含无效的 UTF-8 字节或无效的 UTF-16 替代项。</span><span class="sxs-lookup"><span data-stu-id="d9d99-224">The JSON string contains invalid UTF-8 bytes or invalid UTF-16 surrogates.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetUInt16">
      <MemberSignature Language="C#" Value="public ushort GetUInt16 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int16 GetUInt16() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetUInt16" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUInt16 () As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::UInt16 GetUInt16();" />
      <MemberSignature Language="F#" Value="member this.GetUInt16 : unit -&gt; uint16" Usage="utf8JsonReader.GetUInt16 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d9d99-225">将源中的当前 JSON 令牌值分析为 <see cref="T:System.UInt16" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-225">Parses the current JSON token value from the source as a <see cref="T:System.UInt16" />.</span></span></summary>
        <returns><span data-ttu-id="d9d99-226">解析为 <see cref="T:System.UInt16" /> 的 UTF-8 编码令牌值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-226">The UTF-8 encoded token value parsed to a <see cref="T:System.UInt16" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-227">JSON 令牌的值不是 <see cref="F:System.Text.Json.JsonTokenType.Number" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-227">The value of the JSON token is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="d9d99-228">JSON 令牌值的数字格式不正确（例如，它包含小数值或使用科学记数法编写）。</span><span class="sxs-lookup"><span data-stu-id="d9d99-228">The numeric format of the JSON token value is incorrect (for example, it contains a fractional value or is written in scientific notation).</span></span>
          
<span data-ttu-id="d9d99-229">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d9d99-229">-or-</span></span>

<span data-ttu-id="d9d99-230">JSON 令牌值表示小于 <see cref="F:System.UInt16.MinValue" /> 或大于 <see cref="F:System.UInt16.MaxValue" /> 的数字。</span><span class="sxs-lookup"><span data-stu-id="d9d99-230">The JSON token value represents a number less than <see cref="F:System.UInt16.MinValue" /> or greater than <see cref="F:System.UInt16.MaxValue" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetUInt32">
      <MemberSignature Language="C#" Value="public uint GetUInt32 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int32 GetUInt32() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetUInt32" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUInt32 () As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::UInt32 GetUInt32();" />
      <MemberSignature Language="F#" Value="member this.GetUInt32 : unit -&gt; uint32" Usage="utf8JsonReader.GetUInt32 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d9d99-231">从源中读取下一个 JSON 令牌值，并将该值解析为 <see cref="T:System.UInt32" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-231">Reads the next JSON token value from the source and parses it to a <see cref="T:System.UInt32" />.</span></span></summary>
        <returns><span data-ttu-id="d9d99-232">解析为 <see cref="T:System.UInt32" /> 的 UTF-8 编码令牌值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-232">The UTF-8 encoded token value parsed to a <see cref="T:System.UInt32" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-233">JSON 令牌值不是 <see cref="F:System.Text.Json.JsonTokenType.Number" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-233">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="d9d99-234">JSON 令牌值的数值格式不正确。</span><span class="sxs-lookup"><span data-stu-id="d9d99-234">The JSON token value is of the incorrect numeric format.</span></span> <span data-ttu-id="d9d99-235">例如，它包含小数或采用科学记数法编写。</span><span class="sxs-lookup"><span data-stu-id="d9d99-235">For example, it contains a decimal or is written in scientific notation.</span></span>

<span data-ttu-id="d9d99-236">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d9d99-236">-or-</span></span>

<span data-ttu-id="d9d99-237">JSON 令牌值表示小于 <see cref="F:System.UInt32.MinValue" /> 或大于 <see cref="F:System.UInt32.MaxValue" /> 的数字。</span><span class="sxs-lookup"><span data-stu-id="d9d99-237">The JSON token value represents a number less than <see cref="F:System.UInt32.MinValue" /> or greater than <see cref="F:System.UInt32.MaxValue" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetUInt64">
      <MemberSignature Language="C#" Value="public ulong GetUInt64 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int64 GetUInt64() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetUInt64" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUInt64 () As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::UInt64 GetUInt64();" />
      <MemberSignature Language="F#" Value="member this.GetUInt64 : unit -&gt; uint64" Usage="utf8JsonReader.GetUInt64 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d9d99-238">从源中读取下一个 JSON 令牌值，并将该值解析为 <see cref="T:System.UInt64" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-238">Reads the next JSON token value from the source and parses it to a <see cref="T:System.UInt64" />.</span></span></summary>
        <returns><span data-ttu-id="d9d99-239">解析为 <see cref="T:System.UInt64" /> 的 UTF-8 编码令牌值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-239">The UTF-8 encoded token value parsed to a <see cref="T:System.UInt64" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-240">JSON 令牌值不是 <see cref="F:System.Text.Json.JsonTokenType.Number" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-240">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="d9d99-241">JSON 令牌值的数值格式不正确。</span><span class="sxs-lookup"><span data-stu-id="d9d99-241">The JSON token value is of the incorrect numeric format.</span></span> <span data-ttu-id="d9d99-242">例如，它包含小数或采用科学记数法编写。</span><span class="sxs-lookup"><span data-stu-id="d9d99-242">For example, it contains a decimal or is written in scientific notation.</span></span>
            
<span data-ttu-id="d9d99-243">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d9d99-243">-or-</span></span>

<span data-ttu-id="d9d99-244">JSON 令牌值表示小于 <see cref="F:System.UInt64.MinValue" /> 或大于 <see cref="F:System.UInt64.MaxValue" /> 的数字。</span><span class="sxs-lookup"><span data-stu-id="d9d99-244">The JSON token value represents a number less than <see cref="F:System.UInt64.MinValue" /> or greater than <see cref="F:System.UInt64.MaxValue" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="HasValueSequence">
      <MemberSignature Language="C#" Value="public bool HasValueSequence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValueSequence" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.HasValueSequence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasValueSequence As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasValueSequence { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValueSequence : bool" Usage="System.Text.Json.Utf8JsonReader.HasValueSequence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.CompilerServices.IsReadOnly</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d9d99-245">获取值，该值指示要使用哪个 <c>Value</c> 属性来获取令牌值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-245">Gets a value that indicates which <c>Value</c> property to use to get the token value.</span></span></summary>
        <value><span data-ttu-id="d9d99-246"><see langword="true" /> 是否应使用 <see cref="P:System.Text.Json.Utf8JsonReader.ValueSequence" /> 来获取令牌值;如果应改为使用 <see cref="P:System.Text.Json.Utf8JsonReader.ValueSpan" /> <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-246"><see langword="true" /> if <see cref="P:System.Text.Json.Utf8JsonReader.ValueSequence" /> should be used to get the token value; <see langword="false" /> if <see cref="P:System.Text.Json.Utf8JsonReader.ValueSpan" /> should be used instead.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="d9d99-247">如果 `HasValueSequence` `false`，则 <xref:System.Text.Json.Utf8JsonReader.ValueSequence> 为空。</span><span class="sxs-lookup"><span data-stu-id="d9d99-247">If `HasValueSequence` is `false`, <xref:System.Text.Json.Utf8JsonReader.ValueSequence> is empty.</span></span> <span data-ttu-id="d9d99-248">因此，请使用 <xref:System.Text.Json.Utf8JsonReader.ValueSpan> 属性读取令牌值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-248">Therefore, read the token value using the <xref:System.Text.Json.Utf8JsonReader.ValueSpan> property.</span></span>

<span data-ttu-id="d9d99-249">对于 `ReadOnlySpan<byte>`中的输入数据，此始终返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="d9d99-249">For input data within a `ReadOnlySpan<byte>`, this always returns `false`.</span></span> <span data-ttu-id="d9d99-250">对于 `ReadOnlySequence<byte>`中的输入数据，仅当令牌值跨越多个段，因此不能表示为范围时，才会返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="d9d99-250">For input data within a `ReadOnlySequence<byte>`, this only returns `true` if the token value straddles more than a single segment and hence can't be represented as a span.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalBlock">
      <MemberSignature Language="C#" Value="public bool IsFinalBlock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFinalBlock" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.IsFinalBlock" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFinalBlock As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFinalBlock { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFinalBlock : bool" Usage="System.Text.Json.Utf8JsonReader.IsFinalBlock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d9d99-251">获取 <see cref="T:System.Text.Json.Utf8JsonReader" /> 的此实例的模式，它指示是已提供了所有 JSON 数据，还是随后会提供更多的数据。</span><span class="sxs-lookup"><span data-stu-id="d9d99-251">Gets the mode of this instance of the <see cref="T:System.Text.Json.Utf8JsonReader" /> which indicates whether all the JSON data was provided or there is more data to come.</span></span></summary>
        <value><span data-ttu-id="d9d99-252">如果读取器是通过包含要处理的整个 JSON 数据的输入范围或序列构造的，则为 <see langword="true" />;如果读取器是使用输入范围或序列构建的，则该输入范围或序列可能包含包含部分 JSON 数据的数据，并且需要遵循更多数据。 <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="d9d99-252"><see langword="true" /> if the reader was constructed with the input span or sequence containing the entire JSON data to process; <see langword="false" /> if the reader was constructed with an input span or sequence that may contain partial JSON data with more data to follow.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public SequencePosition Position { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.SequencePosition Position" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.Position" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Position As SequencePosition" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property SequencePosition Position { SequencePosition get(); };" />
      <MemberSignature Language="F#" Value="member this.Position : SequencePosition" Usage="System.Text.Json.Utf8JsonReader.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SequencePosition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d9d99-253">如果 <see cref="T:System.Text.Json.Utf8JsonReader" /> 结构使用 ReadOnlySpan&lt;byte&gt; 构造，则获取所提供的 UTF-8 编码输入 ReadOnlySequence&lt;byte&gt; 内的当前 <see cref="T:System.SequencePosition" /> 或默认的 <see cref="T:System.SequencePosition" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-253">Gets the current <see cref="T:System.SequencePosition" /> within the provided UTF-8 encoded input ReadOnlySequence&lt;byte&gt; or a default <see cref="T:System.SequencePosition" /> if the <see cref="T:System.Text.Json.Utf8JsonReader" /> struct was constructed with a ReadOnlySpan&lt;byte&gt;.</span></span></summary>
        <value><span data-ttu-id="d9d99-254">提供的 UTF-8 编码输入 ReadOnlySequence 中的当前 <see cref="T:System.SequencePosition" />&lt;byte&gt; 或默认 <see cref="T:System.SequencePosition" /> （如果 <see cref="T:System.Text.Json.Utf8JsonReader" /> 结构是使用 ReadOnlySpan&lt;byte&gt;构造的）。</span><span class="sxs-lookup"><span data-stu-id="d9d99-254">The current <see cref="T:System.SequencePosition" /> within the provided UTF-8 encoded input ReadOnlySequence&lt;byte&gt; or a default <see cref="T:System.SequencePosition" /> if the <see cref="T:System.Text.Json.Utf8JsonReader" /> struct was constructed with a ReadOnlySpan&lt;byte&gt;.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Function Read () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Read();" />
      <MemberSignature Language="F#" Value="member this.Read : unit -&gt; bool" Usage="utf8JsonReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d9d99-255">从输入源中读取下一个 JSON 令牌。</span><span class="sxs-lookup"><span data-stu-id="d9d99-255">Reads the next JSON token from the input source.</span></span></summary>
        <returns><span data-ttu-id="d9d99-256">如果已成功读取下一令牌，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-256"><see langword="true" /> if the token was read successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Text.Json.JsonException"><span data-ttu-id="d9d99-257">根据 JSON RFC，遇到无效的 JSON 令牌。</span><span class="sxs-lookup"><span data-stu-id="d9d99-257">An invalid JSON token according to the JSON RFC is encountered.</span></span>
        
<span data-ttu-id="d9d99-258">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d9d99-258">-or-</span></span>

<span data-ttu-id="d9d99-259">当前深度超过由最大深度决定的递归限值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-259">The current depth exceeds the recursive limit set by the maximum depth.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public void Skip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Skip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.Skip" />
      <MemberSignature Language="VB.NET" Value="Public Sub Skip ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Skip();" />
      <MemberSignature Language="F#" Value="member this.Skip : unit -&gt; unit" Usage="utf8JsonReader.Skip " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d9d99-260">跳过当前 JSON 令牌的子级。</span><span class="sxs-lookup"><span data-stu-id="d9d99-260">Skips the children of the current JSON token.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="d9d99-261">当 <xref:System.Text.Json.JsonTokenType.PropertyName?displayProperty=nameWithType><xref:System.Text.Json.Utf8JsonReader.TokenType> 时，读取器将首先移动到属性值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-261">When <xref:System.Text.Json.Utf8JsonReader.TokenType> is <xref:System.Text.Json.JsonTokenType.PropertyName?displayProperty=nameWithType>, the reader first moves to the property value.</span></span>

<span data-ttu-id="d9d99-262">如果 <xref:System.Text.Json.Utf8JsonReader.TokenType> （最初或前进后） <xref:System.Text.Json.JsonTokenType.StartObject?displayProperty=nameWithtype> 或 <xref:System.Text.Json.JsonTokenType.StartArray?displayProperty=nameWithType>，则读取器前进到匹配的 <xref:System.Text.Json.JsonTokenType.EndObject?displayProperty=nameWithType> 或 <xref:System.Text.Json.JsonTokenType.EndArray?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d9d99-262">When <xref:System.Text.Json.Utf8JsonReader.TokenType> (originally, or after advancing) is <xref:System.Text.Json.JsonTokenType.StartObject?displayProperty=nameWithtype> or  <xref:System.Text.Json.JsonTokenType.StartArray?displayProperty=nameWithType>, the reader advances to the matching <xref:System.Text.Json.JsonTokenType.EndObject?displayProperty=nameWithType> or <xref:System.Text.Json.JsonTokenType.EndArray?displayProperty=nameWithType>.</span></span>
            
<span data-ttu-id="d9d99-263">对于所有其他标记类型，读取器不会移动。</span><span class="sxs-lookup"><span data-stu-id="d9d99-263">For all other token types, the reader does not move.</span></span> <span data-ttu-id="d9d99-264">在下一次调用 <xref:System.Text.Json.Utf8JsonReader.Read>之后，读取器将在下一个值（在数组中时）、下一个属性名称（在对象中）或结束数组/对象标记。</span><span class="sxs-lookup"><span data-stu-id="d9d99-264">After the next call to <xref:System.Text.Json.Utf8JsonReader.Read>, the reader will be at the next value (when in an array), the next property name (when in an object), or the end array/object token.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-265">已向读取器提供了部分数据，随后会提供更多数据（即 <see cref="P:System.Text.Json.Utf8JsonReader.IsFinalBlock" /> 为 <see langword="false" />）。</span><span class="sxs-lookup"><span data-stu-id="d9d99-265">The reader was given partial data with more data to follow (that is, <see cref="P:System.Text.Json.Utf8JsonReader.IsFinalBlock" /> is <see langword="false" />).</span></span></exception>
        <exception cref="T:System.Text.Json.JsonException"><span data-ttu-id="d9d99-266">根据 JSON RFC，跳过时出现无效 JSON 令牌。</span><span class="sxs-lookup"><span data-stu-id="d9d99-266">An invalid JSON token was encountered while skipping, according to the JSON RFC.</span></span>

<span data-ttu-id="d9d99-267">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d9d99-267">-or-</span></span>

<span data-ttu-id="d9d99-268">当前深度超过由最大深度决定的递归限值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-268">The current depth exceeds the recursive limit set by the maximum depth.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TokenStartIndex">
      <MemberSignature Language="C#" Value="public long TokenStartIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 TokenStartIndex" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.TokenStartIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TokenStartIndex As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long TokenStartIndex { long get(); };" />
      <MemberSignature Language="F#" Value="member this.TokenStartIndex : int64" Usage="System.Text.Json.Utf8JsonReader.TokenStartIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.CompilerServices.IsReadOnly</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d9d99-269">获取上次处理的 JSON 令牌开始处的索引（在给定的 UTF-8 编码输入文本中），跳过所有空白。</span><span class="sxs-lookup"><span data-stu-id="d9d99-269">Gets the index that the last processed JSON token starts at (within the given UTF-8 encoded input text), skipping any white space.</span></span></summary>
        <value><span data-ttu-id="d9d99-270">给定 UTF-8 编码输入文本中最后处理的 JSON 标记的起始索引。</span><span class="sxs-lookup"><span data-stu-id="d9d99-270">The starting index of the last processed JSON token within the given UTF-8 encoded input text.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="d9d99-271">对于 JSON 字符串（包括属性名称），此值指向开始引号之前。</span><span class="sxs-lookup"><span data-stu-id="d9d99-271">For JSON strings (including property names), this value points to before the start quote.</span></span>

<span data-ttu-id="d9d99-272">对于注释，此值指向第一个注释分隔符之前（即 "/"）。</span><span class="sxs-lookup"><span data-stu-id="d9d99-272">For comments, this value points to before the first comment delimiter (that is, '/').</span></span> <span data-ttu-id="d9d99-273">这仅适用于使用 <xref:System.Text.Json.JsonCommentHandling.Allow?displayProperty=nameWithType> 选项构造读取器的情况。</span><span class="sxs-lookup"><span data-stu-id="d9d99-273">This is only applicable when the reader is constructed using the <xref:System.Text.Json.JsonCommentHandling.Allow?displayProperty=nameWithType> option.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TokenType">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonTokenType TokenType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.Json.JsonTokenType TokenType" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.TokenType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TokenType As JsonTokenType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::JsonTokenType TokenType { System::Text::Json::JsonTokenType get(); };" />
      <MemberSignature Language="F#" Value="member this.TokenType : System.Text.Json.JsonTokenType" Usage="System.Text.Json.Utf8JsonReader.TokenType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonTokenType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d9d99-274">获取 UTF-8 编码 JSON 文本中最后一个处理的 JSON 令牌的类型。</span><span class="sxs-lookup"><span data-stu-id="d9d99-274">Gets the type of the last processed JSON token in the UTF-8 encoded JSON text.</span></span></summary>
        <value><span data-ttu-id="d9d99-275">上次处理的 JSON 令牌的类型。</span><span class="sxs-lookup"><span data-stu-id="d9d99-275">The type of the last processed JSON token.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetByte">
      <MemberSignature Language="C#" Value="public bool TryGetByte (out byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetByte([out] unsigned int8&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetByte(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetByte (ByRef value As Byte) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetByte([Runtime::InteropServices::Out] System::Byte % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetByte : byte -&gt; bool" Usage="utf8JsonReader.TryGetByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="d9d99-276">在此方法返回时，包含已解析的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-276">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="d9d99-277">尝试将源中的当前 JSON 令牌值分析为 <see cref="T:System.Byte" />，并返回一个指示操作是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-277">Tries to parse the current JSON token value from the source as a <see cref="T:System.Byte" /> and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="d9d99-278">如果可以将整个 UTF-8 编码令牌值成功解析为 <see cref="T:System.Byte" /> 值，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-278"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.Byte" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-279">JSON 令牌值不是 <see cref="F:System.Text.Json.JsonTokenType.Number" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-279">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetBytesFromBase64">
      <MemberSignature Language="C#" Value="public bool TryGetBytesFromBase64 (out byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetBytesFromBase64([out] unsigned int8[]&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetBytesFromBase64(System.Byte[]@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetBytesFromBase64 (ByRef value As Byte()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetBytesFromBase64([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetBytesFromBase64 : Byte[] -&gt; bool" Usage="utf8JsonReader.TryGetBytesFromBase64 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" RefType="out">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName>System.Diagnostics.CodeAnalysis.NotNullWhen(true)</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="d9d99-280">如果该方法返回，则包含 base 64 文本的已解码二进制表示形式。</span><span class="sxs-lookup"><span data-stu-id="d9d99-280">When this method returns, contains the decoded binary representation of the Base64 text.</span></span></param>
        <summary><span data-ttu-id="d9d99-281">尝试分析源中的当前 JSON 令牌值，将 Base64 编码 JSON 字符串解码为字节数组，并返回一个指示操作是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-281">Tries to parse the current JSON token value from the source and decodes the Base64 encoded JSON string as a byte array and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="d9d99-282">如果整个标记值编码为有效 base 64 文本并且可以成功解码为字节，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-282"><see langword="true" /> if the entire token value is encoded as valid Base64 text and can be successfully decoded to bytes; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-283">JSON 令牌不是 <see cref="F:System.Text.Json.JsonTokenType.String" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-283">The JSON token is not a <see cref="F:System.Text.Json.JsonTokenType.String" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetDateTime">
      <MemberSignature Language="C#" Value="public bool TryGetDateTime (out DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetDateTime([out] valuetype System.DateTime&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetDateTime(System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetDateTime (ByRef value As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetDateTime([Runtime::InteropServices::Out] DateTime % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetDateTime : DateTime -&gt; bool" Usage="utf8JsonReader.TryGetDateTime value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="d9d99-284">在此方法返回时，包含已解析的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-284">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="d9d99-285">尝试将源中的当前 JSON 令牌值分析为 <see cref="T:System.DateTime" />，并返回一个指示操作是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-285">Tries to parse the current JSON token value from the source as a <see cref="T:System.DateTime" /> and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="d9d99-286">如果可以将整个 UTF-8 编码令牌值成功解析为 <see cref="T:System.DateTime" /> 值，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-286"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.DateTime" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="d9d99-287">此方法仅创建符合 ISO 8601-1 扩展格式的 JSON 字符串的 <xref:System.DateTime> 表示形式（请参阅[系统中的 DateTime 和 DateTimeOffset 支持](/dotnet/standard/datetime/system-text-json-support)）。</span><span class="sxs-lookup"><span data-stu-id="d9d99-287">This method only creates a <xref:System.DateTime> representation of JSON strings that conform to the ISO 8601-1 extended format (see [DateTime and DateTimeOffset support in System.Text.Json](/dotnet/standard/datetime/system-text-json-support)).</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-288">JSON 令牌的值不是 <see cref="F:System.Text.Json.JsonTokenType.String" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-288">The value of the JSON token isn't a <see cref="F:System.Text.Json.JsonTokenType.String" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetDateTimeOffset">
      <MemberSignature Language="C#" Value="public bool TryGetDateTimeOffset (out DateTimeOffset value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetDateTimeOffset([out] valuetype System.DateTimeOffset&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetDateTimeOffset(System.DateTimeOffset@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetDateTimeOffset (ByRef value As DateTimeOffset) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetDateTimeOffset([Runtime::InteropServices::Out] DateTimeOffset % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetDateTimeOffset : DateTimeOffset -&gt; bool" Usage="utf8JsonReader.TryGetDateTimeOffset value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTimeOffset" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="d9d99-289">在此方法返回时，包含已解析的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-289">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="d9d99-290">尝试将源中的当前 JSON 令牌值分析为 <see cref="T:System.DateTimeOffset" />，并返回一个指示操作是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-290">Tries to parse the current JSON token value from the source as a <see cref="T:System.DateTimeOffset" /> and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="d9d99-291">如果可以将整个 UTF-8 编码令牌值成功解析为 <see cref="T:System.DateTimeOffset" /> 值，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-291"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.DateTimeOffset" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="d9d99-292">此方法仅创建符合 ISO 8601-1 扩展格式的 JSON 字符串的 <xref:System.DateTimeOffset> 表示形式（请参阅[系统中的 DateTime 和 DateTimeOffset 支持](/dotnet/standard/datetime/system-text-json-support)）。</span><span class="sxs-lookup"><span data-stu-id="d9d99-292">This method only creates a <xref:System.DateTimeOffset> representation of JSON strings that conform to the ISO 8601-1 extended format (see [DateTime and DateTimeOffset support in System.Text.Json](/dotnet/standard/datetime/system-text-json-support)).</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-293">JSON 令牌的值不是 <see cref="F:System.Text.Json.JsonTokenType.String" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-293">The value of the JSON token isn't a <see cref="F:System.Text.Json.JsonTokenType.String" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetDecimal">
      <MemberSignature Language="C#" Value="public bool TryGetDecimal (out decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetDecimal([out] valuetype System.Decimal&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetDecimal(System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetDecimal (ByRef value As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetDecimal([Runtime::InteropServices::Out] System::Decimal % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetDecimal : decimal -&gt; bool" Usage="utf8JsonReader.TryGetDecimal value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="d9d99-294">在此方法返回时，包含已解析的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-294">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="d9d99-295">尝试将源中的当前 JSON 令牌值分析为 <see cref="T:System.Decimal" />，并返回一个指示操作是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-295">Tries to parse the current JSON token value from the source as a <see cref="T:System.Decimal" /> and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="d9d99-296">如果可以将整个 UTF-8 编码令牌值成功解析为 <see cref="T:System.Decimal" /> 值，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-296"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.Decimal" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-297">JSON 令牌值不是 <see cref="F:System.Text.Json.JsonTokenType.Number" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-297">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetDouble">
      <MemberSignature Language="C#" Value="public bool TryGetDouble (out double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetDouble([out] float64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetDouble(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetDouble (ByRef value As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetDouble([Runtime::InteropServices::Out] double % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetDouble : double -&gt; bool" Usage="utf8JsonReader.TryGetDouble value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="d9d99-298">在此方法返回时，包含已解析的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-298">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="d9d99-299">尝试将源中的当前 JSON 令牌值分析为 <see cref="T:System.Double" />，并返回一个指示操作是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-299">Tries to parse the current JSON token value from the source as a <see cref="T:System.Double" /> and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="d9d99-300">如果可以将整个 UTF-8 编码令牌值成功解析为 <see cref="T:System.Double" /> 值，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-300"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.Double" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-301">JSON 令牌值不是 <see cref="F:System.Text.Json.JsonTokenType.Number" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-301">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetGuid">
      <MemberSignature Language="C#" Value="public bool TryGetGuid (out Guid value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetGuid([out] valuetype System.Guid&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetGuid(System.Guid@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetGuid (ByRef value As Guid) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetGuid([Runtime::InteropServices::Out] Guid % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetGuid : Guid -&gt; bool" Usage="utf8JsonReader.TryGetGuid value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Guid" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="d9d99-302">在此方法返回时，包含已解析的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-302">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="d9d99-303">尝试将源中的当前 JSON 令牌值分析为 <see cref="T:System.Guid" />，并返回一个指示操作是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-303">Tries to parse the current JSON token value from the source as a <see cref="T:System.Guid" /> and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="d9d99-304">如果可以将整个 UTF-8 编码令牌值成功解析为 <see cref="T:System.Guid" /> 值，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-304"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.Guid" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="d9d99-305">此方法仅分析带有连字符的 <xref:System.Guid> 值，而不分析任何周围的修饰。</span><span class="sxs-lookup"><span data-stu-id="d9d99-305">This method only parses <xref:System.Guid> values with hyphens and without any surrounding decorations.</span></span> 

         ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-306">JSON 令牌的值不是 <see cref="F:System.Text.Json.JsonTokenType.String" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-306">The value of the JSON token isn't a <see cref="F:System.Text.Json.JsonTokenType.String" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetInt16">
      <MemberSignature Language="C#" Value="public bool TryGetInt16 (out short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetInt16([out] int16&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetInt16(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetInt16 (ByRef value As Short) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetInt16([Runtime::InteropServices::Out] short % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetInt16 : int16 -&gt; bool" Usage="utf8JsonReader.TryGetInt16 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="d9d99-307">在此方法返回时，包含已解析的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-307">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="d9d99-308">尝试将源中的当前 JSON 令牌值分析为 <see cref="T:System.Int16" />，并返回一个指示操作是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-308">Tries to parse the current JSON token value from the source as an <see cref="T:System.Int16" /> and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="d9d99-309">如果可以将整个 UTF-8 编码令牌值成功解析为 <see cref="T:System.Int16" /> 值，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-309"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.Int16" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-310">JSON 令牌值不是 <see cref="F:System.Text.Json.JsonTokenType.Number" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-310">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetInt32">
      <MemberSignature Language="C#" Value="public bool TryGetInt32 (out int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetInt32([out] int32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetInt32(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetInt32 (ByRef value As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetInt32([Runtime::InteropServices::Out] int % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetInt32 : int -&gt; bool" Usage="utf8JsonReader.TryGetInt32 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="d9d99-311">在此方法返回时，包含已解析的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-311">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="d9d99-312">尝试将源中的当前 JSON 令牌值分析为 <see cref="T:System.Int32" />，并返回一个指示操作是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-312">Tries to parse the current JSON token value from the source as an <see cref="T:System.Int32" /> and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="d9d99-313">如果可以将整个 UTF-8 编码令牌值成功解析为 <see cref="T:System.Int32" /> 值，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-313"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to an <see cref="T:System.Int32" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-314">JSON 令牌值不是 <see cref="F:System.Text.Json.JsonTokenType.Number" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-314">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetInt64">
      <MemberSignature Language="C#" Value="public bool TryGetInt64 (out long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetInt64([out] int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetInt64(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetInt64 (ByRef value As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetInt64([Runtime::InteropServices::Out] long % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetInt64 : int64 -&gt; bool" Usage="utf8JsonReader.TryGetInt64 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="d9d99-315">在此方法返回时，包含已解析的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-315">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="d9d99-316">尝试将源中的当前 JSON 令牌值分析为 <see cref="T:System.Int64" />，并返回一个指示操作是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-316">Tries to parse the current JSON token value from the source as an <see cref="T:System.Int64" /> and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="d9d99-317">如果可以将整个 UTF-8 编码令牌值成功解析为 <see cref="T:System.Int64" /> 值，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-317"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to an <see cref="T:System.Int64" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-318">JSON 令牌值不是 <see cref="F:System.Text.Json.JsonTokenType.Number" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-318">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetSByte">
      <MemberSignature Language="C#" Value="public bool TryGetSByte (out sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetSByte([out] int8&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetSByte(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetSByte (ByRef value As SByte) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetSByte([Runtime::InteropServices::Out] System::SByte % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetSByte : sbyte -&gt; bool" Usage="utf8JsonReader.TryGetSByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="d9d99-319">在此方法返回时，包含已解析的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-319">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="d9d99-320">尝试将源中的当前 JSON 令牌值分析为 <see cref="T:System.SByte" />，并返回一个指示操作是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-320">Tries to parse the current JSON token value from the source as an <see cref="T:System.SByte" /> and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="d9d99-321">如果可以将整个 UTF-8 编码令牌值成功解析为 <see cref="T:System.SByte" /> 值，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-321"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to an <see cref="T:System.SByte" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-322">JSON 令牌值不是 <see cref="F:System.Text.Json.JsonTokenType.Number" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-322">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetSingle">
      <MemberSignature Language="C#" Value="public bool TryGetSingle (out float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetSingle([out] float32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetSingle(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetSingle (ByRef value As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetSingle([Runtime::InteropServices::Out] float % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetSingle : single -&gt; bool" Usage="utf8JsonReader.TryGetSingle value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="d9d99-323">在此方法返回时，包含已解析的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-323">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="d9d99-324">尝试将源中的当前 JSON 令牌值分析为 <see cref="T:System.Single" />，并返回一个指示操作是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-324">Tries to parse the current JSON token value from the source as a <see cref="T:System.Single" /> and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="d9d99-325">如果可以将整个 UTF-8 编码令牌值成功解析为 <see cref="T:System.Single" /> 值，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-325"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to an <see cref="T:System.Single" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-326">JSON 令牌值不是 <see cref="F:System.Text.Json.JsonTokenType.Number" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-326">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetUInt16">
      <MemberSignature Language="C#" Value="public bool TryGetUInt16 (out ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetUInt16([out] unsigned int16&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetUInt16(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetUInt16 (ByRef value As UShort) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetUInt16([Runtime::InteropServices::Out] System::UInt16 % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetUInt16 : uint16 -&gt; bool" Usage="utf8JsonReader.TryGetUInt16 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="d9d99-327">在此方法返回时，包含已解析的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-327">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="d9d99-328">尝试将源中的当前 JSON 令牌值分析为 <see cref="T:System.UInt16" />，并返回一个指示操作是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-328">Tries to parse the current JSON token value from the source as a <see cref="T:System.UInt16" /> and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="d9d99-329">如果可以将整个 UTF-8 编码令牌值成功解析为 <see cref="T:System.UInt16" /> 值，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-329"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.UInt16" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-330">JSON 令牌值不是 <see cref="F:System.Text.Json.JsonTokenType.Number" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-330">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetUInt32">
      <MemberSignature Language="C#" Value="public bool TryGetUInt32 (out uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetUInt32([out] unsigned int32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetUInt32(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetUInt32 (ByRef value As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetUInt32([Runtime::InteropServices::Out] System::UInt32 % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetUInt32 : uint32 -&gt; bool" Usage="utf8JsonReader.TryGetUInt32 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="d9d99-331">在此方法返回时，包含已解析的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-331">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="d9d99-332">尝试将源中的当前 JSON 令牌值分析为 <see cref="T:System.UInt32" />，并返回一个指示操作是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-332">Tries to parse the current JSON token value from the source as a <see cref="T:System.UInt32" /> and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="d9d99-333">如果可以将整个 UTF-8 编码令牌值成功解析为 <see cref="T:System.UInt32" /> 值，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-333"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.UInt32" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-334">JSON 令牌值不是 <see cref="F:System.Text.Json.JsonTokenType.Number" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-334">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetUInt64">
      <MemberSignature Language="C#" Value="public bool TryGetUInt64 (out ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetUInt64([out] unsigned int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetUInt64(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetUInt64 (ByRef value As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetUInt64([Runtime::InteropServices::Out] System::UInt64 % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetUInt64 : uint64 -&gt; bool" Usage="utf8JsonReader.TryGetUInt64 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="d9d99-335">在此方法返回时，包含已解析的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-335">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="d9d99-336">尝试将源中的当前 JSON 令牌值分析为 <see cref="T:System.UInt64" />，并返回一个指示操作是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-336">Tries to parse the current JSON token value from the source as a <see cref="T:System.UInt64" /> and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="d9d99-337">如果可以将整个 UTF-8 编码令牌值成功解析为 <see cref="T:System.UInt64" /> 值，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-337"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.UInt64" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-338">JSON 令牌值不是 <see cref="F:System.Text.Json.JsonTokenType.Number" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-338">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TrySkip">
      <MemberSignature Language="C#" Value="public bool TrySkip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySkip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TrySkip" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySkip () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySkip();" />
      <MemberSignature Language="F#" Value="member this.TrySkip : unit -&gt; bool" Usage="utf8JsonReader.TrySkip " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d9d99-339">尝试跳过当前 JSON 令牌的子级。</span><span class="sxs-lookup"><span data-stu-id="d9d99-339">Tries to skip the children of the current JSON token.</span></span></summary>
        <returns><span data-ttu-id="d9d99-340">如果已成功跳过子项的足够数据，则为 <see langword="true" />否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-340"><see langword="true" /> if there was enough data for the children to be skipped successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="d9d99-341">如果读取器没有足够的数据来完全跳过当前令牌的子级，则会将其重置为在调用方法之前所处的状态。</span><span class="sxs-lookup"><span data-stu-id="d9d99-341">If the reader did not have enough data to completely skip the children of the current token, it will be reset to the state it was in before the method was called.</span></span>
              
<span data-ttu-id="d9d99-342">当 <xref:System.Text.Json.JsonTokenType.PropertyName?displayProperty=nameWithType><xref:System.Text.Json.Utf8JsonReader.TokenType> 时，读取器将首先移动到属性值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-342">When <xref:System.Text.Json.Utf8JsonReader.TokenType> is <xref:System.Text.Json.JsonTokenType.PropertyName?displayProperty=nameWithType>, the reader first moves to the property value.</span></span>

<span data-ttu-id="d9d99-343">如果 <xref:System.Text.Json.Utf8JsonReader.TokenType> （最初或前进后） <xref:System.Text.Json.JsonTokenType.StartObject?displayProperty=nameWithType> 或 <xref:System.Text.Json.JsonTokenType.StartArray?displayProperty=nameWithType>，则读取器前进到匹配的 <xref:System.Text.Json.JsonTokenType.EndObject?displayProperty=nameWithType> 或 <xref:System.Text.Json.JsonTokenType.EndArray?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d9d99-343">When <xref:System.Text.Json.Utf8JsonReader.TokenType> (originally, or after advancing) is <xref:System.Text.Json.JsonTokenType.StartObject?displayProperty=nameWithType> or <xref:System.Text.Json.JsonTokenType.StartArray?displayProperty=nameWithType>, the reader advances to the matching <xref:System.Text.Json.JsonTokenType.EndObject?displayProperty=nameWithType> or <xref:System.Text.Json.JsonTokenType.EndArray?displayProperty=nameWithType>.</span></span>
            
<span data-ttu-id="d9d99-344">对于所有其他标记类型，读取器不会移动。</span><span class="sxs-lookup"><span data-stu-id="d9d99-344">For all other token types, the reader does not move.</span></span> <span data-ttu-id="d9d99-345">在下一次调用 <xref:System.Text.Json.Utf8JsonReader.Read>之后，读取器将在下一个值（在数组中时）、下一个属性名称（在对象中）或结束数组/对象标记。</span><span class="sxs-lookup"><span data-stu-id="d9d99-345">After the next call to <xref:System.Text.Json.Utf8JsonReader.Read>, the reader will be at the next value (when in an array), the next property name (when in an object), or the end array/object token.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.Text.Json.JsonException"><span data-ttu-id="d9d99-346">根据 JSON RFC，跳过时出现无效 JSON 令牌。</span><span class="sxs-lookup"><span data-stu-id="d9d99-346">An invalid JSON token was encountered while skipping, according to the JSON RFC.</span></span>
          
<span data-ttu-id="d9d99-347">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d9d99-347">-or -</span></span>

<span data-ttu-id="d9d99-348">当前深度超过由最大深度决定的递归限值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-348">The current depth exceeds the recursive limit set by the maximum depth.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ValueSequence">
      <MemberSignature Language="C#" Value="public System.Buffers.ReadOnlySequence&lt;byte&gt; ValueSequence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Buffers.ReadOnlySequence`1&lt;unsigned int8&gt; ValueSequence" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.ValueSequence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSequence As ReadOnlySequence(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Buffers::ReadOnlySequence&lt;System::Byte&gt; ValueSequence { System::Buffers::ReadOnlySequence&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSequence : System.Buffers.ReadOnlySequence&lt;byte&gt;" Usage="System.Text.Json.Utf8JsonReader.ValueSequence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.CompilerServices.IsReadOnly</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Buffers.ReadOnlySequence&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d9d99-349">仅当令牌包含在多个段内时，获取上次处理的令牌的原始值作为输入有效负载的 ReadOnlySequence&lt;byte&gt; 切片。</span><span class="sxs-lookup"><span data-stu-id="d9d99-349">Gets the raw value of the last processed token as a ReadOnlySequence&lt;byte&gt; slice of the input payload, only if the token is contained within multiple segments.</span></span></summary>
        <value><span data-ttu-id="d9d99-350">一个字节的只读序列。</span><span class="sxs-lookup"><span data-stu-id="d9d99-350">A byte read-only sequence.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="d9d99-351">如果在 ReadOnlySequence&lt;byte&gt; 内提供 JSON，并且表示令牌值的切片适合单个段，则 <xref:System.Text.Json.Utf8JsonReader.ValueSpan> 包含切分的值，因为它可以表示为一个范围。</span><span class="sxs-lookup"><span data-stu-id="d9d99-351">If the JSON is provided within a ReadOnlySequence&lt;byte&gt; and the slice that represents the token value fits in a single segment, then <xref:System.Text.Json.Utf8JsonReader.ValueSpan> contains the sliced value since it can be represented as a span.</span></span> <span data-ttu-id="d9d99-352">否则 `ValueSequence` 包含令牌值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-352">Otherwise, `ValueSequence` contains the token value.</span></span>

<span data-ttu-id="d9d99-353">如果 <xref:System.Text.Json.Utf8JsonReader.HasValueSequence> `false`，则 `ValueSequence` 为空。</span><span class="sxs-lookup"><span data-stu-id="d9d99-353">If <xref:System.Text.Json.Utf8JsonReader.HasValueSequence> is `false`, `ValueSequence` is empty.</span></span> <span data-ttu-id="d9d99-354">因此，仅当 <xref:System.Text.Json.Utf8JsonReader.HasValueSequence> `true`时，才 `ValueSequence` 访问。</span><span class="sxs-lookup"><span data-stu-id="d9d99-354">Therefore, only access `ValueSequence` if <xref:System.Text.Json.Utf8JsonReader.HasValueSequence> is `true`.</span></span>
<span data-ttu-id="d9d99-355">否则，必须从 <xref:System.Text.Json.Utf8JsonReader.ValueSpan>访问标记值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-355">Otherwise, the token value must be accessed from <xref:System.Text.Json.Utf8JsonReader.ValueSpan>.</span></span>

<span data-ttu-id="d9d99-356">不保证此属性将始终包含格式正确的数据。</span><span class="sxs-lookup"><span data-stu-id="d9d99-356">There is no guarantee that this property will always contain well-formed data.</span></span> <span data-ttu-id="d9d99-357">如果传递到 `Utf8JsonReader` 的输入 JSON 包含 JSON 字符串令牌中的无效 UTF-8 字节，则此属性将返回这些无效的 UTF-8 字节。</span><span class="sxs-lookup"><span data-stu-id="d9d99-357">If the input JSON passed in to the `Utf8JsonReader` contains invalid UTF-8 bytes within JSON string tokens, this property will return back those invalid UTF-8 bytes as is.</span></span>
<span data-ttu-id="d9d99-358">因此，如果输入不受信任或未经验证，则调用 <xref:System.Text.Json.Utf8JsonReader.GetString> 以获取 JSON 字符串标记。</span><span class="sxs-lookup"><span data-stu-id="d9d99-358">Therefore, if the input is untrusted or not previously validated, call <xref:System.Text.Json.Utf8JsonReader.GetString> to get the JSON string token.</span></span>

<span data-ttu-id="d9d99-359">由于此属性返回原始字节，因此应避免将其用于文本比较。</span><span class="sxs-lookup"><span data-stu-id="d9d99-359">Since this property returns the raw bytes, avoid using it for text comparison.</span></span> <span data-ttu-id="d9d99-360">改为调用 <xref:System.Text.Json.Utf8JsonReader.ValueTextEquals%2A>，如有必要，unescapes 文本。</span><span class="sxs-lookup"><span data-stu-id="d9d99-360">Instead call <xref:System.Text.Json.Utf8JsonReader.ValueTextEquals%2A>, which unescapes the text if necessary.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSpan">
      <MemberSignature Language="C#" Value="public ReadOnlySpan&lt;byte&gt; ValueSpan { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; ValueSpan" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.ValueSpan" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSpan As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ReadOnlySpan&lt;System::Byte&gt; ValueSpan { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSpan : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.Json.Utf8JsonReader.ValueSpan" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.CompilerServices.IsReadOnly</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d9d99-361">如果令牌适合单个段，或者如果读取器是使用 ReadOnlySpan&lt;byte&gt; 中包含的 JSON 有效负载构造的，则获取上次处理的令牌的原始值作为输入有效负载的 ReadOnlySpan&lt;byte&gt; 切片。</span><span class="sxs-lookup"><span data-stu-id="d9d99-361">Gets the raw value of the last processed token as a ReadOnlySpan&lt;byte&gt; slice of the input payload, if the token fits in a single segment or if the reader was constructed with a JSON payload contained in a ReadOnlySpan&lt;byte&gt;.</span></span></summary>
        <value><span data-ttu-id="d9d99-362">字节的只读范围。</span><span class="sxs-lookup"><span data-stu-id="d9d99-362">A read-only span of bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="d9d99-363">如果在 ReadOnlySequence&lt;byte&gt; 内提供 JSON，并且表示令牌值的切片适合单个段，则 `ValueSpan` 包含切分的值，因为它可以表示为一个范围。</span><span class="sxs-lookup"><span data-stu-id="d9d99-363">If the JSON is provided within a ReadOnlySequence&lt;byte&gt; and the slice that represents the token value fits in a single segment, then `ValueSpan` contains the sliced value since it can be represented as a span.</span></span> <span data-ttu-id="d9d99-364">否则 <xref:System.Text.Json.Utf8JsonReader.ValueSequence> 包含令牌值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-364">Otherwise, <xref:System.Text.Json.Utf8JsonReader.ValueSequence> contains the token value.</span></span>

<span data-ttu-id="d9d99-365">如果 <xref:System.Text.Json.Utf8JsonReader.HasValueSequence> `true`，则 `ValueSpan` 为空。</span><span class="sxs-lookup"><span data-stu-id="d9d99-365">If <xref:System.Text.Json.Utf8JsonReader.HasValueSequence> is `true`, `ValueSpan` is empty.</span></span> <span data-ttu-id="d9d99-366">因此，仅当 <xref:System.Text.Json.Utf8JsonReader.HasValueSequence> `false`时，才 `ValueSpan` 访问。</span><span class="sxs-lookup"><span data-stu-id="d9d99-366">Therefore, only access `ValueSpan` if <xref:System.Text.Json.Utf8JsonReader.HasValueSequence> is `false`.</span></span>
<span data-ttu-id="d9d99-367">否则，必须从 <xref:System.Text.Json.Utf8JsonReader.ValueSequence>访问标记值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-367">Otherwise, the token value must be accessed from <xref:System.Text.Json.Utf8JsonReader.ValueSequence>.</span></span>

<span data-ttu-id="d9d99-368">不保证此属性将始终包含格式正确的数据。</span><span class="sxs-lookup"><span data-stu-id="d9d99-368">There is no guarantee that this property will always contain well-formed data.</span></span> <span data-ttu-id="d9d99-369">如果传递到 `Utf8JsonReader` 的输入 JSON 包含 JSON 字符串令牌中的无效 UTF-8 字节，则此属性将返回这些无效的 UTF-8 字节。</span><span class="sxs-lookup"><span data-stu-id="d9d99-369">If the input JSON passed in to the `Utf8JsonReader` contains invalid UTF-8 bytes within JSON string tokens, this property will return back those invalid UTF-8 bytes as is.</span></span>
<span data-ttu-id="d9d99-370">因此，如果输入不受信任或未经验证，则调用 <xref:System.Text.Json.Utf8JsonReader.GetString> 以获取 JSON 字符串标记。</span><span class="sxs-lookup"><span data-stu-id="d9d99-370">Therefore, if the input is untrusted or not previously validated, call <xref:System.Text.Json.Utf8JsonReader.GetString> to get the JSON string token.</span></span>

<span data-ttu-id="d9d99-371">由于此属性返回原始字节，因此应避免将其用于文本比较。</span><span class="sxs-lookup"><span data-stu-id="d9d99-371">Since this property returns the raw bytes, avoid using it for text comparison.</span></span> <span data-ttu-id="d9d99-372">如果需要，请改为调用 unescapes 文本的 <xref:System.Text.Json.Utf8JsonReader.ValueTextEquals%2A>。</span><span class="sxs-lookup"><span data-stu-id="d9d99-372">Instead call <xref:System.Text.Json.Utf8JsonReader.ValueTextEquals%2A> which unescapes the text if necessary.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueTextEquals">
      <MemberSignature Language="C#" Value="public bool ValueTextEquals (ReadOnlySpan&lt;byte&gt; utf8Text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ValueTextEquals(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.ValueTextEquals(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function ValueTextEquals (utf8Text As ReadOnlySpan(Of Byte)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ValueTextEquals(ReadOnlySpan&lt;System::Byte&gt; utf8Text);" />
      <MemberSignature Language="F#" Value="member this.ValueTextEquals : ReadOnlySpan&lt;byte&gt; -&gt; bool" Usage="utf8JsonReader.ValueTextEquals utf8Text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Text" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="utf8Text"><span data-ttu-id="d9d99-373">要进行比较的 UTF-8 编码文本。</span><span class="sxs-lookup"><span data-stu-id="d9d99-373">The UTF-8 encoded text to compare against.</span></span></param>
        <summary><span data-ttu-id="d9d99-374">比较只读字节范围中 UTF-8 编码文本与源中未转义的 JSON 令牌值，返回指示其是否匹配的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-374">Compares the UTF-8 encoded text in a read-only byte span to the unescaped JSON token value in the source and returns a value that indicates whether they match.</span></span></summary>
        <returns><span data-ttu-id="d9d99-375">如果源中的 JSON 令牌值与 UTF-8 编码查找文本匹配，则 <see langword="true" />；否则 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-375"><see langword="true" /> if the JSON token value in the source matches the UTF-8 encoded lookup text; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="d9d99-376">查找文本必须为有效的 UTF-8 文本。</span><span class="sxs-lookup"><span data-stu-id="d9d99-376">The lookup text must be valid UTF-8 text.</span></span> <span data-ttu-id="d9d99-377">否则，如果源具有包含与匹配的无效 UTF-8 文本的字符串标记，则此方法可能会返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="d9d99-377">Otherwise, this method could return `true` if the source has a string token containing invalid UTF-8 text that matches.</span></span>
              
<span data-ttu-id="d9d99-378">在源中的 JSON 标记值和查找文本的比较是在需要时通过首先取消转义源中的 JSON 值来完成的。</span><span class="sxs-lookup"><span data-stu-id="d9d99-378">The comparison of the JSON token value in the source and the lookup text is done by first unescaping the JSON value in source, if required.</span></span> <span data-ttu-id="d9d99-379">查找文本将按原样匹配，而不会对其进行任何修改。</span><span class="sxs-lookup"><span data-stu-id="d9d99-379">The lookup text is matched as is, without any modifications to it.</span></span>
              
          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-380">JSON 令牌不是 JSON 字符串（即不是 <see cref="F:System.Text.Json.JsonTokenType.String" /> 或 <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />）。</span><span class="sxs-lookup"><span data-stu-id="d9d99-380">The JSON token is not a JSON string (that is, it is not <see cref="F:System.Text.Json.JsonTokenType.String" /> or <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ValueTextEquals">
      <MemberSignature Language="C#" Value="public bool ValueTextEquals (ReadOnlySpan&lt;char&gt; text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ValueTextEquals(valuetype System.ReadOnlySpan`1&lt;char&gt; text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.ValueTextEquals(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function ValueTextEquals (text As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ValueTextEquals(ReadOnlySpan&lt;char&gt; text);" />
      <MemberSignature Language="F#" Value="member this.ValueTextEquals : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="utf8JsonReader.ValueTextEquals text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="d9d99-381">要针对其进行比较的文本。</span><span class="sxs-lookup"><span data-stu-id="d9d99-381">The text to compare against.</span></span></param>
        <summary><span data-ttu-id="d9d99-382">比较只读字符范围中文本与源中未转义的 JSON 令牌值，返回指示其是否匹配的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-382">Compares the text in a read-only character span to the unescaped JSON token value in the source and returns a value that indicates whether they match.</span></span></summary>
        <returns><span data-ttu-id="d9d99-383">如果源中的 JSON 令牌值与查找文本匹配，则 <see langword="true" />；否则 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-383"><see langword="true" /> if the JSON token value in the source matches the lookup text; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="d9d99-384">如果查找文本无效或不完整的 UTF-16 文本（即不成对的代理项），该方法将返回 `false` 因为 JSON 有效负载中不能有无效的 UTF-16。</span><span class="sxs-lookup"><span data-stu-id="d9d99-384">If the lookup text is invalid or incomplete UTF-16 text (that is, unpaired surrogates), the method returns `false` since you can't have invalid UTF-16 within the JSON payload.</span></span>
              
<span data-ttu-id="d9d99-385">在源中的 JSON 标记值和查找文本的比较是在需要时通过首先取消转义源中的 JSON 值来完成的。</span><span class="sxs-lookup"><span data-stu-id="d9d99-385">The comparison of the JSON token value in the source and the lookup text is done by first unescaping the JSON value in source, if required.</span></span> <span data-ttu-id="d9d99-386">查找文本将按原样匹配，而不会对其进行任何修改。</span><span class="sxs-lookup"><span data-stu-id="d9d99-386">The lookup text is matched as is, without any modifications to it.</span></span>
              
          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-387">JSON 令牌不是 JSON 字符串（即不是 <see cref="F:System.Text.Json.JsonTokenType.String" /> 或 <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />）。</span><span class="sxs-lookup"><span data-stu-id="d9d99-387">The JSON token is not a JSON string (that is, it is not <see cref="F:System.Text.Json.JsonTokenType.String" /> or <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ValueTextEquals">
      <MemberSignature Language="C#" Value="public bool ValueTextEquals (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ValueTextEquals(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.ValueTextEquals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ValueTextEquals (text As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ValueTextEquals(System::String ^ text);" />
      <MemberSignature Language="F#" Value="member this.ValueTextEquals : string -&gt; bool" Usage="utf8JsonReader.ValueTextEquals text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="d9d99-388">要针对其进行比较的文本。</span><span class="sxs-lookup"><span data-stu-id="d9d99-388">The text to compare against.</span></span></param>
        <summary><span data-ttu-id="d9d99-389">比较字符串文本与源中未转义的 JSON 令牌值，返回指示其是否匹配的值。</span><span class="sxs-lookup"><span data-stu-id="d9d99-389">Compares the string text to the unescaped JSON token value in the source and returns a value that indicates whether they match.</span></span></summary>
        <returns><span data-ttu-id="d9d99-390">如果源中的 JSON 令牌值与查找文本匹配，则 <see langword="true" />；否则 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d9d99-390"><see langword="true" /> if the JSON token value in the source matches the lookup text; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="d9d99-391">如果查找文本无效或不完整的 UTF-16 文本（即不成对的代理项），该方法将返回 `false` 因为 JSON 有效负载中不能有无效的 UTF-16。</span><span class="sxs-lookup"><span data-stu-id="d9d99-391">If the lookup text is invalid or incomplete UTF-16 text (that is, unpaired surrogates), the method returns `false` since you can't have invalid UTF-16 within the JSON payload.</span></span>
              
<span data-ttu-id="d9d99-392">在源中的 JSON 标记值和查找文本的比较是在需要时通过首先取消转义源中的 JSON 值来完成的。</span><span class="sxs-lookup"><span data-stu-id="d9d99-392">The comparison of the JSON token value in the source and the lookup text is done by first unescaping the JSON value in source, if required.</span></span> <span data-ttu-id="d9d99-393">查找文本将按原样匹配，而不会对其进行任何修改。</span><span class="sxs-lookup"><span data-stu-id="d9d99-393">The lookup text is matched as is, without any modifications to it.</span></span>
              
          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d9d99-394">JSON 令牌不是 JSON 字符串（即不是 <see cref="F:System.Text.Json.JsonTokenType.String" /> 或 <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />）。</span><span class="sxs-lookup"><span data-stu-id="d9d99-394">The JSON token is not a JSON string (that is, it is not <see cref="F:System.Text.Json.JsonTokenType.String" /> or <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />).</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
