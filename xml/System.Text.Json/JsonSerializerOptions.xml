<Type Name="JsonSerializerOptions" FullName="System.Text.Json.JsonSerializerOptions">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7d0163a512952ceef0f44b245d831eb2fae90bb1" /><Meta Name="ms.sourcegitcommit" Value="11306e8bb61e44463a969897211724e18107ac96" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/12/2020" /><Meta Name="ms.locfileid" Value="88137735" /></Metadata><TypeSignature Language="C#" Value="public sealed class JsonSerializerOptions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit JsonSerializerOptions extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Text.Json.JsonSerializerOptions" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class JsonSerializerOptions" />
  <TypeSignature Language="C++ CLI" Value="public ref class JsonSerializerOptions sealed" />
  <TypeSignature Language="F#" Value="type JsonSerializerOptions = class" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Json</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="b52b8-101">提供与 <see cref="T:System.Text.Json.JsonSerializer" /> 一起使用的选项。</span><span class="sxs-lookup"><span data-stu-id="b52b8-101">Provides options to be used with <see cref="T:System.Text.Json.JsonSerializer" />.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="b52b8-102">有关详细信息，请参阅 [如何序列化和反序列化 JSON](/dotnet/standard/serialization/system-text-json-how-to)。</span><span class="sxs-lookup"><span data-stu-id="b52b8-102">For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to).</span></span>

 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public JsonSerializerOptions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializerOptions.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; JsonSerializerOptions();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b52b8-103">初始化 <see cref="T:System.Text.Json.JsonSerializerOptions" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="b52b8-103">Initializes a new instance of the <see cref="T:System.Text.Json.JsonSerializerOptions" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public JsonSerializerOptions (System.Text.Json.JsonSerializerDefaults defaults);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Text.Json.JsonSerializerDefaults defaults) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializerOptions.#ctor(System.Text.Json.JsonSerializerDefaults)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaults As JsonSerializerDefaults)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; JsonSerializerOptions(System::Text::Json::JsonSerializerDefaults defaults);" />
      <MemberSignature Language="F#" Value="new System.Text.Json.JsonSerializerOptions : System.Text.Json.JsonSerializerDefaults -&gt; System.Text.Json.JsonSerializerOptions" Usage="new System.Text.Json.JsonSerializerOptions defaults" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaults" Type="System.Text.Json.JsonSerializerDefaults" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="defaults"><span data-ttu-id="b52b8-104">要考虑原因的 <see cref="T:System.Text.Json.JsonSerializerDefaults" />。</span><span class="sxs-lookup"><span data-stu-id="b52b8-104">The <see cref="T:System.Text.Json.JsonSerializerDefaults" /> to reason about.</span></span></param>
        <summary><span data-ttu-id="b52b8-105">使用由指定的 <see cref="T:System.Text.Json.JsonSerializerDefaults" /> 确定的一组预定义选项构造新的 <see cref="T:System.Text.Json.JsonSerializerOptions" /> 实例。</span><span class="sxs-lookup"><span data-stu-id="b52b8-105">Constructs a new <see cref="T:System.Text.Json.JsonSerializerOptions" /> instance with a predefined set of options determined by the specified <see cref="T:System.Text.Json.JsonSerializerDefaults" />.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public JsonSerializerOptions (System.Text.Json.JsonSerializerOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializerOptions.#ctor(System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (options As JsonSerializerOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; JsonSerializerOptions(System::Text::Json::JsonSerializerOptions ^ options);" />
      <MemberSignature Language="F#" Value="new System.Text.Json.JsonSerializerOptions : System.Text.Json.JsonSerializerOptions -&gt; System.Text.Json.JsonSerializerOptions" Usage="new System.Text.Json.JsonSerializerOptions options" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="options"><span data-ttu-id="b52b8-106">要从中复制选项的选项实例。</span><span class="sxs-lookup"><span data-stu-id="b52b8-106">The options instance to copy options from.</span></span></param>
        <summary><span data-ttu-id="b52b8-107">将 <see cref="T:System.Text.Json.JsonSerializerOptions" /> 实例的选项复制到新实例。</span><span class="sxs-lookup"><span data-stu-id="b52b8-107">Copies the options from a <see cref="T:System.Text.Json.JsonSerializerOptions" /> instance to a new instance.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b52b8-108"><paramref name="options" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b52b8-108"><paramref name="options" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AllowTrailingCommas">
      <MemberSignature Language="C#" Value="public bool AllowTrailingCommas { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowTrailingCommas" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.AllowTrailingCommas" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowTrailingCommas As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowTrailingCommas { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowTrailingCommas : bool with get, set" Usage="System.Text.Json.JsonSerializerOptions.AllowTrailingCommas" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b52b8-109">获取或设置一个值，该值指示要反序列化的 JSON 有效负载中是否允许（和忽略）对象或数组中 JSON 值的列表末尾多余的逗号。</span><span class="sxs-lookup"><span data-stu-id="b52b8-109">Get or sets a value that indicates whether an extra comma at the end of a list of JSON values in an object or array is allowed (and ignored) within the JSON payload being deserialized.</span></span></summary>
        <value><span data-ttu-id="b52b8-110"><see langword="true" /> 如果允许在对象或数组中的 JSON 值列表末尾使用额外逗号，则 (并忽略) ; <see langword="false" /> 否则为。</span><span class="sxs-lookup"><span data-stu-id="b52b8-110"><see langword="true" /> if an extra comma at the end of a list of JSON values in an object or array is allowed (and ignored); <see langword="false" /> otherwise.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="b52b8-111">默认情况下， `AllowTrailingCommas` 设置为 `false` ，并在 <xref:System.Text.Json.JsonException> 反序列化过程中如果遇到尾部逗号，则会引发。</span><span class="sxs-lookup"><span data-stu-id="b52b8-111">By default, `AllowTrailingCommas` is set to `false`, and a <xref:System.Text.Json.JsonException> is thrown during deserialization if a trailing comma is encountered.</span></span>

<span data-ttu-id="b52b8-112">有关详细信息，请参阅 [如何序列化和反序列化 JSON](/dotnet/standard/serialization/system-text-json-how-to#allow-comments-and-trailing-commas)。</span><span class="sxs-lookup"><span data-stu-id="b52b8-112">For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to#allow-comments-and-trailing-commas).</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b52b8-113">此属性在序列化或反序列化发生后设置。</span><span class="sxs-lookup"><span data-stu-id="b52b8-113">This property was set after serialization or deserialization has occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Converters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Text.Json.Serialization.JsonConverter&gt;? Converters { get; }" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Text.Json.Serialization.JsonConverter&gt; Converters" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.Converters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Converters As IList(Of JsonConverter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Text::Json::Serialization::JsonConverter ^&gt; ^ Converters { System::Collections::Generic::IList&lt;System::Text::Json::Serialization::JsonConverter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Converters : System.Collections.Generic.IList&lt;System.Text.Json.Serialization.JsonConverter&gt;" Usage="System.Text.Json.JsonSerializerOptions.Converters" />
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Text.Json.Serialization.JsonConverter&gt; Converters { get; }" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Text.Json.Serialization.JsonConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b52b8-114">获取已注册的用户定义的转换器的列表。</span><span class="sxs-lookup"><span data-stu-id="b52b8-114">Gets the list of user-defined converters that were registered.</span></span></summary>
        <value><span data-ttu-id="b52b8-115">自定义转换器的列表。</span><span class="sxs-lookup"><span data-stu-id="b52b8-115">The list of custom converters.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="b52b8-116">进行序列化或反序列化后，不能修改该列表。</span><span class="sxs-lookup"><span data-stu-id="b52b8-116">Once serialization or deserialization occurs, the list cannot be modified.</span></span>

<span data-ttu-id="b52b8-117">有关详细信息，请参阅[如何编写自定义转换器](/dotnet/standard/serialization/system-text-json-converters-how-to#registration-sample---converters-collection)。</span><span class="sxs-lookup"><span data-stu-id="b52b8-117">For more information, see [How to write custom converters](/dotnet/standard/serialization/system-text-json-converters-how-to#registration-sample---converters-collection).</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultBufferSize">
      <MemberSignature Language="C#" Value="public int DefaultBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DefaultBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.DefaultBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DefaultBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBufferSize : int with get, set" Usage="System.Text.Json.JsonSerializerOptions.DefaultBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b52b8-118">获取或设置创建临时缓冲区时要使用的默认缓冲区大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="b52b8-118">Gets or sets the default buffer size, in bytes, to use when creating temporary buffers.</span></span></summary>
        <value><span data-ttu-id="b52b8-119">默认缓冲区大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="b52b8-119">The default buffer size in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="b52b8-120">默认缓冲区大小（以字节为单位）为16384。</span><span class="sxs-lookup"><span data-stu-id="b52b8-120">The default buffer size, in bytes, is 16,384.</span></span>
<span data-ttu-id="b52b8-121">对于大多数工作负荷，默认大小是在从流中读取或写入流时要缓冲的合理数量的 JSON。</span><span class="sxs-lookup"><span data-stu-id="b52b8-121">For most workloads, the default size is a reasonable amount of JSON to buffer while reading from a stream or writing to a stream.</span></span>
<span data-ttu-id="b52b8-122">也就是说，如果不在大型对象堆上为垃圾回收器 (GC) 进行跟踪，则会很好地执行。在非流式处理方案中，增加默认缓冲区大小可以提高大型 JSON 字符串或 UTF-8 字节数组的性能。</span><span class="sxs-lookup"><span data-stu-id="b52b8-122">That is, it performs well without creating objects on the Large Object Heap for the Garbage Collector (GC) to track. In non-streaming scenarios, increasing the default buffer size could improve performance for large JSON strings or UTF-8 byte arrays.</span></span>
<span data-ttu-id="b52b8-123">建议将此值保持不变，除非对其进行更改以使性能明显不同。</span><span class="sxs-lookup"><span data-stu-id="b52b8-123">We recommend that you leave this value unchanged unless changing it makes an observable difference in performance.</span></span>


          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b52b8-124">缓冲区大小小于 1。</span><span class="sxs-lookup"><span data-stu-id="b52b8-124">The buffer size is less than 1.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b52b8-125">此属性在序列化或反序列化发生后设置。</span><span class="sxs-lookup"><span data-stu-id="b52b8-125">This property was set after serialization or deserialization has occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultIgnoreCondition">
      <MemberSignature Language="C#" Value="public System.Text.Json.Serialization.JsonIgnoreCondition DefaultIgnoreCondition { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.Json.Serialization.JsonIgnoreCondition DefaultIgnoreCondition" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.DefaultIgnoreCondition" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultIgnoreCondition As JsonIgnoreCondition" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::Serialization::JsonIgnoreCondition DefaultIgnoreCondition { System::Text::Json::Serialization::JsonIgnoreCondition get(); void set(System::Text::Json::Serialization::JsonIgnoreCondition value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultIgnoreCondition : System.Text.Json.Serialization.JsonIgnoreCondition with get, set" Usage="System.Text.Json.JsonSerializerOptions.DefaultIgnoreCondition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonIgnoreCondition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b52b8-126">指定一个条件，用于确定何时在序列化或反序列化过程中忽略具有默认值的属性。</span><span class="sxs-lookup"><span data-stu-id="b52b8-126">Specifies a condition to determine when properties with default values are ignored during serialization or deserialization.</span></span>
<span data-ttu-id="b52b8-127">默认值为 <see cref="F:System.Text.Json.Serialization.JsonIgnoreCondition.Never" />。</span><span class="sxs-lookup"><span data-stu-id="b52b8-127">The default value is <see cref="F:System.Text.Json.Serialization.JsonIgnoreCondition.Never" />.</span></span></summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DictionaryKeyPolicy">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonNamingPolicy DictionaryKeyPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Json.JsonNamingPolicy DictionaryKeyPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.DictionaryKeyPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property DictionaryKeyPolicy As JsonNamingPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::JsonNamingPolicy ^ DictionaryKeyPolicy { System::Text::Json::JsonNamingPolicy ^ get(); void set(System::Text::Json::JsonNamingPolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DictionaryKeyPolicy : System.Text.Json.JsonNamingPolicy with get, set" Usage="System.Text.Json.JsonSerializerOptions.DictionaryKeyPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonNamingPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b52b8-128">获取或设置用于将 <see cref="T:System.Collections.IDictionary" /> 密钥名称转换为其他格式（如 camel 大小写）的策略。</span><span class="sxs-lookup"><span data-stu-id="b52b8-128">Gets or sets the policy used to convert a <see cref="T:System.Collections.IDictionary" /> key's name to another format, such as camel-casing.</span></span></summary>
        <value><span data-ttu-id="b52b8-129">用于将 <see cref="T:System.Collections.IDictionary" /> 密钥名称转换为另一种格式的策略。</span><span class="sxs-lookup"><span data-stu-id="b52b8-129">The policy used to convert a <see cref="T:System.Collections.IDictionary" /> key's name to another format.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="b52b8-130">此属性可设置为 <xref:System.Text.Json.JsonNamingPolicy.CamelCase?displayProperty=nameWithType> ，以指定大小写大小的策略。</span><span class="sxs-lookup"><span data-stu-id="b52b8-130">This property can be set to <xref:System.Text.Json.JsonNamingPolicy.CamelCase?displayProperty=nameWithType> to specify a camel-casing policy.</span></span>

<span data-ttu-id="b52b8-131">此属性可设置为 <xref:System.Text.Json.JsonNamingPolicy.CamelCase> ，以指定大小写大小的策略。</span><span class="sxs-lookup"><span data-stu-id="b52b8-131">This property can be set to <xref:System.Text.Json.JsonNamingPolicy.CamelCase> to specify a camel-casing policy.</span></span>

<span data-ttu-id="b52b8-132">反序列化时，不使用此方法。</span><span class="sxs-lookup"><span data-stu-id="b52b8-132">It is not used when deserializing.</span></span>

<span data-ttu-id="b52b8-133">有关详细信息，请参阅 [如何序列化和反序列化 JSON](/dotnet/standard/serialization/system-text-json-how-to#camel-case-dictionary-keys)。</span><span class="sxs-lookup"><span data-stu-id="b52b8-133">For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to#camel-case-dictionary-keys).</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Encoder">
      <MemberSignature Language="C#" Value="public System.Text.Encodings.Web.JavaScriptEncoder Encoder { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encodings.Web.JavaScriptEncoder Encoder" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.Encoder" />
      <MemberSignature Language="VB.NET" Value="Public Property Encoder As JavaScriptEncoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encodings::Web::JavaScriptEncoder ^ Encoder { System::Text::Encodings::Web::JavaScriptEncoder ^ get(); void set(System::Text::Encodings::Web::JavaScriptEncoder ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Encoder : System.Text.Encodings.Web.JavaScriptEncoder with get, set" Usage="System.Text.Json.JsonSerializerOptions.Encoder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encodings.Web.JavaScriptEncoder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b52b8-134">获取或设置要在转义字符串时使用的编码器，或为 <see langword="null" />（要使用默认编码器的话）。</span><span class="sxs-lookup"><span data-stu-id="b52b8-134">Gets or sets the encoder to use when escaping strings, or <see langword="null" /> to use the default encoder.</span></span></summary>
        <value><span data-ttu-id="b52b8-135">JavaScript 字符编码。</span><span class="sxs-lookup"><span data-stu-id="b52b8-135">The JavaScript character encoding.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="b52b8-136">有关详细信息，请参阅 [如何序列化和反序列化 JSON](/dotnet/standard/serialization/system-text-json-how-to#customize-character-encoding)。</span><span class="sxs-lookup"><span data-stu-id="b52b8-136">For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to#customize-character-encoding).</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public System.Text.Json.Serialization.JsonConverter GetConverter (Type typeToConvert);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.Json.Serialization.JsonConverter GetConverter(class System.Type typeToConvert) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializerOptions.GetConverter(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConverter (typeToConvert As Type) As JsonConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::Json::Serialization::JsonConverter ^ GetConverter(Type ^ typeToConvert);" />
      <MemberSignature Language="F#" Value="member this.GetConverter : Type -&gt; System.Text.Json.Serialization.JsonConverter" Usage="jsonSerializerOptions.GetConverter typeToConvert" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeToConvert" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="typeToConvert"><span data-ttu-id="b52b8-137">要为其返回转换器的类型。</span><span class="sxs-lookup"><span data-stu-id="b52b8-137">The type to return a converter for.</span></span></param>
        <summary><span data-ttu-id="b52b8-138">返回指定类型的转换器。</span><span class="sxs-lookup"><span data-stu-id="b52b8-138">Returns the converter for the specified type.</span></span></summary>
        <returns><span data-ttu-id="b52b8-139">支持给定类型的第一个转换器，如果没有转换器，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b52b8-139">The first converter that supports the given type, or <see langword="null" /> if there is no converter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="b52b8-140">有关详细信息，请参阅 [如何序列化和反序列化 JSON](/dotnet/standard/serialization/system-text-json-how-to#sample-factory-pattern-converter)。</span><span class="sxs-lookup"><span data-stu-id="b52b8-140">For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to#sample-factory-pattern-converter).</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b52b8-141">为 <paramref name="typeToConvert" /> 配置的 <see cref="System.Text.Json.Serialization.JsonConverter" /> 返回了无效的转换器。</span><span class="sxs-lookup"><span data-stu-id="b52b8-141">The configured <see cref="System.Text.Json.Serialization.JsonConverter" /> for <paramref name="typeToConvert" /> returned an invalid converter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="b52b8-142"><paramref name="typeToConvert" /> 或其可序列化成员没有兼容的 <see cref="System.Text.Json.Serialization.JsonConverter" />。</span><span class="sxs-lookup"><span data-stu-id="b52b8-142">There is no compatible <see cref="System.Text.Json.Serialization.JsonConverter" /> for <paramref name="typeToConvert" /> or its serializable members.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IgnoreNullValues">
      <MemberSignature Language="C#" Value="public bool IgnoreNullValues { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreNullValues" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.IgnoreNullValues" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreNullValues As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreNullValues { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreNullValues : bool with get, set" Usage="System.Text.Json.JsonSerializerOptions.IgnoreNullValues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b52b8-143">获取或设置一个值，该值确定序列化和反序列化过程中是否忽略 <see langword="null" /> 值。</span><span class="sxs-lookup"><span data-stu-id="b52b8-143">Gets or sets a value that determines whether <see langword="null" /> values are ignored during serialization and deserialization.</span></span> <span data-ttu-id="b52b8-144">默认值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b52b8-144">The default value is <see langword="false" />.</span></span></summary>
        <value><span data-ttu-id="b52b8-145"><see langword="true" /> 若为，则在序列化和反序列化期间忽略 null 值;否则，请参阅 langword = "false"/ &gt; 。</span><span class="sxs-lookup"><span data-stu-id="b52b8-145"><see langword="true" /> to ignore null values during serialization and deserialization; otherwise, see langword="false" /&gt;.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="b52b8-146">有关详细信息，请参阅 [排除所有 null 值属性](/dotnet/standard/serialization/system-text-json-how-to#exclude-all-null-value-properties) 并 [在反序列化时忽略 null](/dotnet/standard/serialization/system-text-json-how-to#ignore-null-when-deserializing)值。</span><span class="sxs-lookup"><span data-stu-id="b52b8-146">For more information, see [Exclude all null value properties](/dotnet/standard/serialization/system-text-json-how-to#exclude-all-null-value-properties) and [Ignore null when deserializing](/dotnet/standard/serialization/system-text-json-how-to#ignore-null-when-deserializing).</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b52b8-147">此属性在序列化或反序列化发生后设置。</span><span class="sxs-lookup"><span data-stu-id="b52b8-147">This property was set after serialization or deserialization has occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IgnoreReadOnlyProperties">
      <MemberSignature Language="C#" Value="public bool IgnoreReadOnlyProperties { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreReadOnlyProperties" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.IgnoreReadOnlyProperties" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreReadOnlyProperties As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreReadOnlyProperties { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreReadOnlyProperties : bool with get, set" Usage="System.Text.Json.JsonSerializerOptions.IgnoreReadOnlyProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b52b8-148">获取一个值，该值确定序列化过程中是否忽略只读属性。</span><span class="sxs-lookup"><span data-stu-id="b52b8-148">Gets a value that determines whether read-only properties are ignored during serialization.</span></span> <span data-ttu-id="b52b8-149">默认值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b52b8-149">The default value is <see langword="false" />.</span></span></summary>
        <value><span data-ttu-id="b52b8-150"><see langword="true" /> 如果在序列化过程中忽略只读属性，则为;否则为 <see langword="false" /> 。</span><span class="sxs-lookup"><span data-stu-id="b52b8-150"><see langword="true" /> to ignore read-only properties during serialization; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="b52b8-151">如果属性包含公共 getter 而不是公共 setter，则属性为只读。</span><span class="sxs-lookup"><span data-stu-id="b52b8-151">A property is read-only if it contains a public getter but not a public setter.</span></span> 

<span data-ttu-id="b52b8-152">无论此设置如何，只读属性都不会反序列化。</span><span class="sxs-lookup"><span data-stu-id="b52b8-152">Read-only properties are not deserialized regardless of this setting.</span></span>

<span data-ttu-id="b52b8-153">有关详细信息，请参阅 [如何序列化和反序列化 JSON](/dotnet/standard/serialization/system-text-json-how-to#exclude-all-read-only-properties)。</span><span class="sxs-lookup"><span data-stu-id="b52b8-153">For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to#exclude-all-read-only-properties).</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b52b8-154">此属性在序列化或反序列化发生后设置。</span><span class="sxs-lookup"><span data-stu-id="b52b8-154">This property was set after serialization or deserialization has occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MaxDepth">
      <MemberSignature Language="C#" Value="public int MaxDepth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxDepth" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.MaxDepth" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxDepth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxDepth { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxDepth : int with get, set" Usage="System.Text.Json.JsonSerializerOptions.MaxDepth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b52b8-155">获取或设置序列化或反序列化 JSON 时允许的最大深度，默认值 0 表示最大深度为 64。</span><span class="sxs-lookup"><span data-stu-id="b52b8-155">Gets or sets the maximum depth allowed when serializing or deserializing JSON, with the default value of 0 indicating a maximum depth of 64.</span></span></summary>
        <value><span data-ttu-id="b52b8-156">序列化或反序列化 JSON 时允许的最大深度。</span><span class="sxs-lookup"><span data-stu-id="b52b8-156">The maximum depth allowed when serializing or deserializing JSON.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="b52b8-157">超过此深度将引发 <xref:System.Text.Json.JsonException> 。</span><span class="sxs-lookup"><span data-stu-id="b52b8-157">Going past this depth throws a <xref:System.Text.Json.JsonException>.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b52b8-158">此属性在序列化或反序列化发生后设置。</span><span class="sxs-lookup"><span data-stu-id="b52b8-158">This property was set after serialization or deserialization has occurred.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b52b8-159">最大深度设置为负值。</span><span class="sxs-lookup"><span data-stu-id="b52b8-159">The max depth is set to a negative value.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="PropertyNameCaseInsensitive">
      <MemberSignature Language="C#" Value="public bool PropertyNameCaseInsensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PropertyNameCaseInsensitive" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.PropertyNameCaseInsensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyNameCaseInsensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PropertyNameCaseInsensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PropertyNameCaseInsensitive : bool with get, set" Usage="System.Text.Json.JsonSerializerOptions.PropertyNameCaseInsensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b52b8-160">获取或设置一个值，该值确定在反序列化过程中属性名称是否使用不区分大小写的比较。</span><span class="sxs-lookup"><span data-stu-id="b52b8-160">Gets or sets a value that determines whether a property's name uses a case-insensitive comparison during deserialization.</span></span> <span data-ttu-id="b52b8-161">默认值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b52b8-161">The default value is <see langword="false" />.</span></span></summary>
        <value><span data-ttu-id="b52b8-162"><see langword="true" /> 使用不区分大小写的比较比较属性名称;否则为 <see langword="false" /> 。</span><span class="sxs-lookup"><span data-stu-id="b52b8-162"><see langword="true" /> to compare property names using case-insensitive comparison; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="b52b8-163">) 时，存在与不区分大小写的比较 (相关联的性能 `PropertyNameCaseInsensitive` 开销 `true` 。</span><span class="sxs-lookup"><span data-stu-id="b52b8-163">There is a performance cost associated with case-insensitive comparison (that is, when `PropertyNameCaseInsensitive` is `true`).</span></span>

<span data-ttu-id="b52b8-164">有关详细信息，请参阅 [如何序列化和反序列化 JSON](/dotnet/standard/serialization/system-text-json-how-to#case-insensitive-property-matching)。</span><span class="sxs-lookup"><span data-stu-id="b52b8-164">For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to#case-insensitive-property-matching).</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyNamingPolicy">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonNamingPolicy PropertyNamingPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Json.JsonNamingPolicy PropertyNamingPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.PropertyNamingPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyNamingPolicy As JsonNamingPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::JsonNamingPolicy ^ PropertyNamingPolicy { System::Text::Json::JsonNamingPolicy ^ get(); void set(System::Text::Json::JsonNamingPolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PropertyNamingPolicy : System.Text.Json.JsonNamingPolicy with get, set" Usage="System.Text.Json.JsonSerializerOptions.PropertyNamingPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonNamingPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b52b8-165">获取或设置一个值，该值指定用于将对象的属性名称转换为其他格式（例如 camel 大小写）的策略；若为 <see langword="null" />，则保持属性名称不变。</span><span class="sxs-lookup"><span data-stu-id="b52b8-165">Gets or sets a value that specifies the policy used to convert a property's name on an object to another format, such as camel-casing, or <see langword="null" /> to leave property names unchanged.</span></span></summary>
        <value><span data-ttu-id="b52b8-166">属性命名策略，或 <see langword="null" /> 保留属性名称不变。</span><span class="sxs-lookup"><span data-stu-id="b52b8-166">A property naming policy, or <see langword="null" /> to leave property names unchanged.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="b52b8-167">在反序列化过程中，生成的属性名称应与 JSON 有效负载匹配，并将在序列化过程中写入属性名称时使用。</span><span class="sxs-lookup"><span data-stu-id="b52b8-167">The resulting property name is expected to match the JSON payload during deserialization, and will be used when writing the property name during serialization.</span></span>

<span data-ttu-id="b52b8-168">此策略不用于已应用的属性 <xref:System.Text.Json.Serialization.JsonPropertyNameAttribute> 。</span><span class="sxs-lookup"><span data-stu-id="b52b8-168">The policy is not used for properties that have a <xref:System.Text.Json.Serialization.JsonPropertyNameAttribute> applied.</span></span>

<span data-ttu-id="b52b8-169">此属性可设置为 <xref:System.Text.Json.JsonNamingPolicy.CamelCase?displayProperty=nameWithType> ，以指定大小写大小的策略。</span><span class="sxs-lookup"><span data-stu-id="b52b8-169">This property can be set to <xref:System.Text.Json.JsonNamingPolicy.CamelCase?displayProperty=nameWithType> to specify a camel-casing policy.</span></span>

<span data-ttu-id="b52b8-170">有关详细信息，请参阅 [如何序列化和反序列化 JSON](/dotnet/standard/serialization/system-text-json-how-to#customize-json-names-and-values)。</span><span class="sxs-lookup"><span data-stu-id="b52b8-170">For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to#customize-json-names-and-values).</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadCommentHandling">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonCommentHandling ReadCommentHandling { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.Json.JsonCommentHandling ReadCommentHandling" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.ReadCommentHandling" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadCommentHandling As JsonCommentHandling" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::JsonCommentHandling ReadCommentHandling { System::Text::Json::JsonCommentHandling get(); void set(System::Text::Json::JsonCommentHandling value); };" />
      <MemberSignature Language="F#" Value="member this.ReadCommentHandling : System.Text.Json.JsonCommentHandling with get, set" Usage="System.Text.Json.JsonSerializerOptions.ReadCommentHandling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonCommentHandling</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b52b8-171">获取或设置一个值，该值定义反序列化过程中如何处理注释。</span><span class="sxs-lookup"><span data-stu-id="b52b8-171">Gets or sets a value that defines how comments are handled during deserialization.</span></span></summary>
        <value><span data-ttu-id="b52b8-172">一个值，该值指示是否允许、不允许或跳过注释。</span><span class="sxs-lookup"><span data-stu-id="b52b8-172">A value that indicates whether comments are allowed, disallowed, or skipped.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="b52b8-173">默认情况下， <xref:System.Text.Json.JsonException> 如果遇到注释，则会在反序列化过程中引发。</span><span class="sxs-lookup"><span data-stu-id="b52b8-173">By default, a <xref:System.Text.Json.JsonException> is thrown during deserialization if a comment is encountered.</span></span>

<span data-ttu-id="b52b8-174">有关详细信息，请参阅 [如何序列化和反序列化 JSON](/dotnet/standard/serialization/system-text-json-how-to#allow-comments-and-trailing-commas)。</span><span class="sxs-lookup"><span data-stu-id="b52b8-174">For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to#allow-comments-and-trailing-commas).</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b52b8-175">此属性在序列化或反序列化发生后设置。</span><span class="sxs-lookup"><span data-stu-id="b52b8-175">This property was set after serialization or deserialization has occurred.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b52b8-176">注释处理枚举设置为不受支持的值（或不在 <see cref="T:System.Text.Json.JsonCommentHandling" /> 枚举范围内）。</span><span class="sxs-lookup"><span data-stu-id="b52b8-176">The comment handling enum is set to a value that is not supported (or not within the <see cref="T:System.Text.Json.JsonCommentHandling" /> enum range).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReferenceHandler">
      <MemberSignature Language="C#" Value="public System.Text.Json.Serialization.ReferenceHandler ReferenceHandler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Json.Serialization.ReferenceHandler ReferenceHandler" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.ReferenceHandler" />
      <MemberSignature Language="VB.NET" Value="Public Property ReferenceHandler As ReferenceHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::Serialization::ReferenceHandler ^ ReferenceHandler { System::Text::Json::Serialization::ReferenceHandler ^ get(); void set(System::Text::Json::Serialization::ReferenceHandler ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ReferenceHandler : System.Text.Json.Serialization.ReferenceHandler with get, set" Usage="System.Text.Json.JsonSerializerOptions.ReferenceHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.ReferenceHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b52b8-177">配置在读取和写入 JSON 时如何处理对象引用。</span><span class="sxs-lookup"><span data-stu-id="b52b8-177">Configures how object references are handled when reading and writing JSON.</span></span></summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="b52b8-178">默认情况下，序列化不支持具有循环的对象，并且不保留重复引用。</span><span class="sxs-lookup"><span data-stu-id="b52b8-178">By default, serialization does not support objects with cycles and does not preserve duplicate references.</span></span> <span data-ttu-id="b52b8-179">在对引用类型进行序列化时，元数据属性将不会写入，并将在反序列化时被视为常规属性。</span><span class="sxs-lookup"><span data-stu-id="b52b8-179">Metadata properties will not be written when serializing reference types and will be treated as regular properties on deserialize.</span></span>
 
* <span data-ttu-id="b52b8-180">序列化时：</span><span class="sxs-lookup"><span data-stu-id="b52b8-180">On Serialize:</span></span>

  * <span data-ttu-id="b52b8-181">将重复的对象引用视为唯一的，并写入它们的所有属性。</span><span class="sxs-lookup"><span data-stu-id="b52b8-181">Treats duplicate object references as if they were unique and writes all their properties.</span></span>
  * <span data-ttu-id="b52b8-182">如果对象包含循环，则序列化程序将引发 <xref:System.Text.Json.JsonException> 。</span><span class="sxs-lookup"><span data-stu-id="b52b8-182">The serializer throws a <xref:System.Text.Json.JsonException> if an object contains a cycle.</span></span>

* <span data-ttu-id="b52b8-183">反序列化时：</span><span class="sxs-lookup"><span data-stu-id="b52b8-183">On Deserialize:</span></span>

  * <span data-ttu-id="b52b8-184">不会使用元数据属性 (`$id` 、 `$values` 和 `$ref`) ，因此将被视为常规的 JSON 属性。</span><span class="sxs-lookup"><span data-stu-id="b52b8-184">Metadata properties (`$id`, `$values`, and `$ref`) will not be consumed and therefore will be treated as regular JSON properties.</span></span>
  * <span data-ttu-id="b52b8-185">如果属性名称匹配或将添加到溢出字典（如果存在），则元数据属性可以映射到返回的对象上的实际属性 <xref:System.Text.Json.Serialization.JsonExtensionDataAttribute> ; 否则，将忽略它们。</span><span class="sxs-lookup"><span data-stu-id="b52b8-185">The metadata properties can map to a real property on the returned object if the property names match, or will be added to the <xref:System.Text.Json.Serialization.JsonExtensionDataAttribute> overflow dictionary, if one exists; otherwise, they are ignored.</span></span>

<span data-ttu-id="b52b8-186">用于 <xref:System.Text.Json.Serialization.ReferenceHandler.Preserve> 启用序列化和元数据使用的唯一对象引用保留，以读取反序列化的保留引用。</span><span class="sxs-lookup"><span data-stu-id="b52b8-186">Use <xref:System.Text.Json.Serialization.ReferenceHandler.Preserve> to enable unique object reference preservation on serialization and metadata consumption to read preserved references on deserialization.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteIndented">
      <MemberSignature Language="C#" Value="public bool WriteIndented { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool WriteIndented" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.WriteIndented" />
      <MemberSignature Language="VB.NET" Value="Public Property WriteIndented As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool WriteIndented { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.WriteIndented : bool with get, set" Usage="System.Text.Json.JsonSerializerOptions.WriteIndented" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b52b8-187">获取或设置一个值，该值定义 JSON 是否应使用整齐打印。</span><span class="sxs-lookup"><span data-stu-id="b52b8-187">Gets or sets a value that defines whether JSON should use pretty printing.</span></span> <span data-ttu-id="b52b8-188">默认情况下，不使用任何额外的空白来序列化 JSON。</span><span class="sxs-lookup"><span data-stu-id="b52b8-188">By default, JSON is serialized without any extra white space.</span></span></summary>
        <value><span data-ttu-id="b52b8-189"><see langword="true" /> 如果 JSON 应该在序列化时进行整齐打印，则为;否则为 <see langword="false" /> 。</span><span class="sxs-lookup"><span data-stu-id="b52b8-189"><see langword="true" /> if JSON should pretty print on serialization; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="b52b8-190">默认值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b52b8-190">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="b52b8-191">整齐打印包括：</span><span class="sxs-lookup"><span data-stu-id="b52b8-191">Pretty printing includes:</span></span> 

- <span data-ttu-id="b52b8-192">缩进嵌套的 JSON 标记。</span><span class="sxs-lookup"><span data-stu-id="b52b8-192">Indenting nested JSON tokens.</span></span>
- <span data-ttu-id="b52b8-193">添加新行</span><span class="sxs-lookup"><span data-stu-id="b52b8-193">Adding new lines</span></span>
- <span data-ttu-id="b52b8-194">在属性名称和值之间添加空格。</span><span class="sxs-lookup"><span data-stu-id="b52b8-194">Adding white space between property names and values.</span></span> 

<span data-ttu-id="b52b8-195">有关详细信息，请参阅 [如何序列化和反序列化 JSON](/dotnet/standard/serialization/system-text-json-how-to#serialize-to-formatted-json)。</span><span class="sxs-lookup"><span data-stu-id="b52b8-195">For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to#serialize-to-formatted-json).</span></span>

         ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b52b8-196">此属性在序列化或反序列化发生后设置。</span><span class="sxs-lookup"><span data-stu-id="b52b8-196">This property was set after serialization or deserialization has occurred.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
