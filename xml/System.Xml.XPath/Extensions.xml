<Type Name="Extensions" FullName="System.Xml.XPath.Extensions">
  <Metadata><Meta Name="ms.openlocfilehash" Value="06ce619bf4d12d434150020d0fa01a6574c0e852" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86604368" /></Metadata><TypeSignature Language="C#" Value="public static class Extensions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Extensions extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XPath.Extensions" />
  <TypeSignature Language="VB.NET" Value="Public Module Extensions" />
  <TypeSignature Language="C++ CLI" Value="public ref class Extensions abstract sealed" />
  <TypeSignature Language="F#" Value="type Extensions = class" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Xml.XPath.XDocument" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="9e906-101">此类包含 LINQ to XML 扩展方法，可以使用这些方法计算 XPath 表达式。</span><span class="sxs-lookup"><span data-stu-id="9e906-101">This class contains the LINQ to XML extension methods that enable you to evaluate XPath expressions.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9e906-102">使用这些方法会降低性能。</span><span class="sxs-lookup"><span data-stu-id="9e906-102">There is some performance penalty for using these methods.</span></span> <span data-ttu-id="9e906-103">使用 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] 查询会获得更好的性能。</span><span class="sxs-lookup"><span data-stu-id="9e906-103">Using [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] queries yields better performance.</span></span>  
  
 <span data-ttu-id="9e906-104">虽然未在 XML XPath 语言1.0 建议中指定返回集合的顺序，但此扩展方法以文档顺序返回节点。</span><span class="sxs-lookup"><span data-stu-id="9e906-104">Although the ordering of returned collections is not specified in the XML XPath Language 1.0 Recommendation, this extension method returns nodes in document order.</span></span>  
  
 <span data-ttu-id="9e906-105">请注意，即使使用反向轴（如或），也会以文档顺序返回 `preceding-sibling` 节点 `ancestor-or-self` 。</span><span class="sxs-lookup"><span data-stu-id="9e906-105">Note that nodes are returned in document order even when you use a reverse axis, such as `preceding-sibling` or `ancestor-or-self`.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateNavigator">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9e906-106">为 <see cref="T:System.Xml.XPath.XPathNavigator" /> 创建一个 <see cref="T:System.Xml.Linq.XNode" />。</span><span class="sxs-lookup"><span data-stu-id="9e906-106">Creates an <see cref="T:System.Xml.XPath.XPathNavigator" /> for an <see cref="T:System.Xml.Linq.XNode" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9e906-107">不能使用 <xref:System.Xml.XPath.XPathNavigator> 此方法返回的来编辑 XML 树。</span><span class="sxs-lookup"><span data-stu-id="9e906-107">You cannot edit the XML tree by using the <xref:System.Xml.XPath.XPathNavigator> that is returned by this method.</span></span> <span data-ttu-id="9e906-108"><xref:System.Xml.XPath.XPathNavigator.CanEdit%2A> 属性返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="9e906-108">The <xref:System.Xml.XPath.XPathNavigator.CanEdit%2A> property returns `false`.</span></span>  
  
 <span data-ttu-id="9e906-109">不能 <xref:System.Xml.XPath.XPathNavigator> 为 <xref:System.Xml.Linq.XDocumentType> 节点创建。</span><span class="sxs-lookup"><span data-stu-id="9e906-109">You cannot create an <xref:System.Xml.XPath.XPathNavigator> for a <xref:System.Xml.Linq.XDocumentType> node.</span></span> <span data-ttu-id="9e906-110">文档类型不参与 XPath 数据模型。</span><span class="sxs-lookup"><span data-stu-id="9e906-110">Document types do not participate in the XPath data model.</span></span>  
  
 <span data-ttu-id="9e906-111">命名空间声明按从左到右的报告。</span><span class="sxs-lookup"><span data-stu-id="9e906-111">Namespace declarations are reported from left to right.</span></span> <span data-ttu-id="9e906-112">相反，对于 <xref:System.Xml.XmlDocument> 命名空间，从右到左进行报告。</span><span class="sxs-lookup"><span data-stu-id="9e906-112">In contrast, for <xref:System.Xml.XmlDocument> namespaces are reported from right to left.</span></span> <span data-ttu-id="9e906-113">这是一致的行为，因为在 XPath 数据模型中没有对命名空间声明进行排序。</span><span class="sxs-lookup"><span data-stu-id="9e906-113">This is conformant behavior because namespace declarations are not ordered in the XPath data model.</span></span>  
  
 <span data-ttu-id="9e906-114"><xref:System.Xml.XPath.XPathNavigator.MoveToId%2A>此方法返回的导航器不支持此方法。</span><span class="sxs-lookup"><span data-stu-id="9e906-114">The method <xref:System.Xml.XPath.XPathNavigator.MoveToId%2A> is not supported for navigators that are returned by this method.</span></span>  
  
 <span data-ttu-id="9e906-115">可以使用此方法执行 XSLT 转换。</span><span class="sxs-lookup"><span data-stu-id="9e906-115">You can use this method to perform an XSLT transformation.</span></span> <span data-ttu-id="9e906-116">您可以创建一个 XML 树， <xref:System.Xml.XPath.XPathNavigator> 从 XML 树创建一个，创建一个新文档，然后创建一个 <xref:System.Xml.XmlWriter> 将写入到新文档中的。</span><span class="sxs-lookup"><span data-stu-id="9e906-116">You can create an XML tree, create an <xref:System.Xml.XPath.XPathNavigator> from the XML tree, create a new document, and create a <xref:System.Xml.XmlWriter> that will write into the new document.</span></span> <span data-ttu-id="9e906-117">然后，您可以调用 XSLT 转换，并可以将 <xref:System.Xml.XPath.XPathNavigator> 和 <xref:System.Xml.XmlWriter> 传递到转换中。</span><span class="sxs-lookup"><span data-stu-id="9e906-117">Then, you can invoke the XSLT transformation, passing the <xref:System.Xml.XPath.XPathNavigator> and <xref:System.Xml.XmlWriter> to the transformation.</span></span> <span data-ttu-id="9e906-118">在转换成功完成后，使用转换的结果，填充新的 XML 树。</span><span class="sxs-lookup"><span data-stu-id="9e906-118">After the transformation successfully completes, the new XML tree is populated with the results of the transformation.</span></span>  
  
 <span data-ttu-id="9e906-119">若要执行 XSLT 转换，可以使用 <xref:System.Xml.XmlReader> 或 <xref:System.Xml.XPath.XPathNavigator> 。</span><span class="sxs-lookup"><span data-stu-id="9e906-119">To perform an XSLT transformation, you can use either an <xref:System.Xml.XmlReader> or an <xref:System.Xml.XPath.XPathNavigator>.</span></span> <span data-ttu-id="9e906-120">这两种方法具有不同的性能特征。</span><span class="sxs-lookup"><span data-stu-id="9e906-120">The two approaches have different performance characteristics.</span></span> <span data-ttu-id="9e906-121">当使用时，某些转换的执行速度更快 <xref:System.Xml.XmlReader> ，而另一些转换在使用时的执行速度更快 <xref:System.Xml.XPath.XPathNavigator> 。</span><span class="sxs-lookup"><span data-stu-id="9e906-121">Some transformations will execute faster when using an <xref:System.Xml.XmlReader>, and others will execute faster when using a <xref:System.Xml.XPath.XPathNavigator>.</span></span> <span data-ttu-id="9e906-122">如果需要考虑性能问题，我们建议您试验每种方法，以确定哪种方法在您的情况下性能更佳。</span><span class="sxs-lookup"><span data-stu-id="9e906-122">If performance is a concern, we recommend that you experiment with each approach to determine which will perform better in your circumstances.</span></span>  
  
```csharp  
  
            string xslMarkup = @"<?xml version='1.0'?>  
<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
    <xsl:template match='/Parent'>  
        <Root>  
            <C1><xsl:value-of select='Child1'/></C1>  
            <C2><xsl:value-of select='Child2'/></C2>  
        </Root>  
    </xsl:template>  
</xsl:stylesheet>";  
  
XDocument xmlTree = new XDocument(  
    new XElement("Parent",  
        new XElement("Child1", "Child1 data"),  
        new XElement("Child2", "Child2 data")  
    )  
);  
  
XDocument newTree = new XDocument();  
using (XmlWriter writer = newTree.CreateWriter()) {  
    // Load the style sheet.  
    XslCompiledTransform xslt = new XslCompiledTransform();  
    xslt.Load(XmlReader.Create(new StringReader(xslMarkup)));  
  
    // Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateNavigator(), writer);  
}  
  
Console.WriteLine(newTree);  
```  
  
```vb  
  
            Dim xslMarkup As XDocument = <?xml version='1.0'?>  
                             <xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
                                 <xsl:template match='/Parent'>  
                                     <Root>  
                                         <C1><xsl:value-of select='Child1'/></C1>  
                                         <C2><xsl:value-of select='Child2'/></C2>  
                                     </Root>  
                                 </xsl:template>  
                             </xsl:stylesheet>  
  
Dim xmlTree As XDocument = <?xml version='1.0'?>  
                           <Parent>  
                               <Child1>Child1 data</Child1>  
                               <Child2>Child2 data</Child2>  
                           </Parent>  
  
Dim newTree As XDocument = New XDocument()  
  
Using writer As XmlWriter = newTree.CreateWriter()  
    ' Load the style sheet.  
    Dim xslt As XslCompiledTransform = _  
        New XslCompiledTransform()  
    xslt.Load(xslMarkup.CreateReader())  
  
    ' Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateNavigator(), writer)  
End Using  
  
Console.WriteLine(newTree)  
```  
  
 <span data-ttu-id="9e906-123">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="9e906-123">This example produces the following output:</span></span>  
  
```xml  
  
            <Root>  
  <C1>Child1 data</C1>  
  <C2>Child2 data</C2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="public static System.Xml.XPath.XPathNavigator CreateNavigator (this System.Xml.Linq.XNode node);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XPath.XPathNavigator CreateNavigator(class System.Xml.Linq.XNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.CreateNavigator(System.Xml.Linq.XNode)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateNavigator (node As XNode) As XPathNavigator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Xml::XPath::XPathNavigator ^ CreateNavigator(System::Xml::Linq::XNode ^ node);" />
      <MemberSignature Language="F#" Value="static member CreateNavigator : System.Xml.Linq.XNode -&gt; System.Xml.XPath.XPathNavigator" Usage="System.Xml.XPath.Extensions.CreateNavigator node" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
      </Parameters>
      <Docs>
        <param name="node"><span data-ttu-id="9e906-124">一个可以处理 XPath 查询的 <see cref="T:System.Xml.Linq.XNode" />。</span><span class="sxs-lookup"><span data-stu-id="9e906-124">An <see cref="T:System.Xml.Linq.XNode" /> that can process XPath queries.</span></span></param>
        <summary><span data-ttu-id="9e906-125">为 <see cref="T:System.Xml.XPath.XPathNavigator" /> 创建一个 <see cref="T:System.Xml.Linq.XNode" />。</span><span class="sxs-lookup"><span data-stu-id="9e906-125">Creates an <see cref="T:System.Xml.XPath.XPathNavigator" /> for an <see cref="T:System.Xml.Linq.XNode" />.</span></span></summary>
        <returns><span data-ttu-id="9e906-126">一个可以处理 XPath 查询的 <see cref="T:System.Xml.XPath.XPathNavigator" />。</span><span class="sxs-lookup"><span data-stu-id="9e906-126">An <see cref="T:System.Xml.XPath.XPathNavigator" /> that can process XPath queries.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9e906-127">不能使用 <xref:System.Xml.XPath.XPathNavigator> 此方法返回的来编辑 XML 树。</span><span class="sxs-lookup"><span data-stu-id="9e906-127">You cannot edit the XML tree by using the <xref:System.Xml.XPath.XPathNavigator> that is returned by this method.</span></span> <span data-ttu-id="9e906-128"><xref:System.Xml.XPath.XPathNavigator.CanEdit%2A> 属性返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="9e906-128">The <xref:System.Xml.XPath.XPathNavigator.CanEdit%2A> property returns `false`.</span></span>  
  
 <span data-ttu-id="9e906-129">不能 <xref:System.Xml.XPath.XPathNavigator> 为 <xref:System.Xml.Linq.XDocumentType> 节点创建。</span><span class="sxs-lookup"><span data-stu-id="9e906-129">You cannot create an <xref:System.Xml.XPath.XPathNavigator> for a <xref:System.Xml.Linq.XDocumentType> node.</span></span> <span data-ttu-id="9e906-130">文档类型不参与 XPath 数据模型。</span><span class="sxs-lookup"><span data-stu-id="9e906-130">Document types do not participate in the XPath data model.</span></span>  
  
 <span data-ttu-id="9e906-131">命名空间声明按从左到右的报告。</span><span class="sxs-lookup"><span data-stu-id="9e906-131">Namespace declarations are reported from left to right.</span></span> <span data-ttu-id="9e906-132">相反，对于 <xref:System.Xml.XmlDocument> 命名空间，从右到左进行报告。</span><span class="sxs-lookup"><span data-stu-id="9e906-132">In contrast, for <xref:System.Xml.XmlDocument> namespaces are reported from right to left.</span></span> <span data-ttu-id="9e906-133">这是一致的行为，因为在 XPath 数据模型中没有对命名空间声明进行排序。</span><span class="sxs-lookup"><span data-stu-id="9e906-133">This is conformant behavior because namespace declarations are not ordered in the XPath data model.</span></span>  
  
 <span data-ttu-id="9e906-134"><xref:System.Xml.XPath.XPathNavigator.MoveToId%2A>此方法返回的导航器不支持此方法。</span><span class="sxs-lookup"><span data-stu-id="9e906-134">The method <xref:System.Xml.XPath.XPathNavigator.MoveToId%2A> is not supported for navigators that are returned by this method.</span></span>  
  
 <span data-ttu-id="9e906-135">可以使用此方法执行 XSLT 转换。</span><span class="sxs-lookup"><span data-stu-id="9e906-135">You can use this method to perform an XSLT transformation.</span></span> <span data-ttu-id="9e906-136">您可以创建一个 XML 树， <xref:System.Xml.XPath.XPathNavigator> 从 XML 树创建一个，创建一个新文档，然后创建一个 <xref:System.Xml.XmlWriter> 将写入到新文档中的。</span><span class="sxs-lookup"><span data-stu-id="9e906-136">You can create an XML tree, create an <xref:System.Xml.XPath.XPathNavigator> from the XML tree, create a new document, and create a <xref:System.Xml.XmlWriter> that will write into the new document.</span></span> <span data-ttu-id="9e906-137">然后，可以调用 XSLT 转换，并将和传递 <xref:System.Xml.XPath.XPathNavigator> <xref:System.Xml.XmlWriter> 到转换。</span><span class="sxs-lookup"><span data-stu-id="9e906-137">Then, you can invoke the XSLT transformation, passing the <xref:System.Xml.XPath.XPathNavigator> and <xref:System.Xml.XmlWriter> to the transform.</span></span> <span data-ttu-id="9e906-138">在转换成功完成后，使用转换的结果，填充新的 XML 树。</span><span class="sxs-lookup"><span data-stu-id="9e906-138">After the transformation successfully completes, the new XML tree is populated with the results of the transformation.</span></span>  
  
 <span data-ttu-id="9e906-139">若要执行 XSLT 转换，可以使用 <xref:System.Xml.XmlReader> 或 <xref:System.Xml.XPath.XPathNavigator> 。</span><span class="sxs-lookup"><span data-stu-id="9e906-139">To perform an XSLT transformation, you can use either an <xref:System.Xml.XmlReader> or an <xref:System.Xml.XPath.XPathNavigator>.</span></span> <span data-ttu-id="9e906-140">这两种方法具有不同的性能特征。</span><span class="sxs-lookup"><span data-stu-id="9e906-140">The two approaches have different performance characteristics.</span></span> <span data-ttu-id="9e906-141">当使用时，某些转换的执行速度更快 <xref:System.Xml.XmlReader> ，而另一些转换在使用时的执行速度更快 <xref:System.Xml.XPath.XPathNavigator> 。</span><span class="sxs-lookup"><span data-stu-id="9e906-141">Some transformations will execute faster when using an <xref:System.Xml.XmlReader>, and others will execute faster when using a <xref:System.Xml.XPath.XPathNavigator>.</span></span> <span data-ttu-id="9e906-142">如果需要考虑性能问题，我们建议您试验每种方法，以确定哪种方法在您的情况下性能更佳。</span><span class="sxs-lookup"><span data-stu-id="9e906-142">If performance is a concern, we recommend that you experiment with each approach to determine which will perform better in your circumstances.</span></span>  
  
   
  
## Examples  
  
```csharp  
  
                string xslMarkup = @"<?xml version='1.0'?>  
<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
    <xsl:template match='/Parent'>  
        <Root>  
            <C1><xsl:value-of select='Child1'/></C1>  
            <C2><xsl:value-of select='Child2'/></C2>  
        </Root>  
    </xsl:template>  
</xsl:stylesheet>";  
  
XDocument xmlTree = new XDocument(  
    new XElement("Parent",  
        new XElement("Child1", "Child1 data"),  
        new XElement("Child2", "Child2 data")  
    )  
);  
  
XDocument newTree = new XDocument();  
using (XmlWriter writer = newTree.CreateWriter()) {  
    // Load the style sheet.  
    XslCompiledTransform xslt = new XslCompiledTransform();  
    xslt.Load(XmlReader.Create(new StringReader(xslMarkup)));  
  
    // Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateNavigator(), writer);  
}  
  
Console.WriteLine(newTree);  
```  
  
```vb  
  
                Dim xslMarkup As XDocument = _  
    <?xml version='1.0'?>  
    <xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
        <xsl:template match='/Parent'>  
            <Root>  
                <C1><xsl:value-of select='Child1'/></C1>  
                <C2><xsl:value-of select='Child2'/></C2>  
            </Root>  
        </xsl:template>  
    </xsl:stylesheet>  
  
Dim xmlTree As XDocument = _  
    <?xml version='1.0'?>  
    <Parent>  
        <Child1>Child1 data</Child1>  
        <Child2>Child2 data</Child2>  
    </Parent>  
  
Dim newTree As XDocument = New XDocument()  
  
Using writer As XmlWriter = newTree.CreateWriter()  
    ' Load the style sheet.  
    Dim xslt As XslCompiledTransform = _  
        New XslCompiledTransform()  
    xslt.Load(xslMarkup.CreateReader())  
  
    ' Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateNavigator(), writer)  
End Using  
  
Console.WriteLine(newTree)  
```  
  
 <span data-ttu-id="9e906-143">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="9e906-143">This example produces the following output:</span></span>  
  
```xml  
  
                <Root>  
  <C1>Child1 data</C1>  
  <C2>Child2 data</C2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="public static System.Xml.XPath.XPathNavigator CreateNavigator (this System.Xml.Linq.XNode node, System.Xml.XmlNameTable nameTable);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XPath.XPathNavigator CreateNavigator(class System.Xml.Linq.XNode node, class System.Xml.XmlNameTable nameTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.CreateNavigator(System.Xml.Linq.XNode,System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateNavigator (node As XNode, nameTable As XmlNameTable) As XPathNavigator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Xml::XPath::XPathNavigator ^ CreateNavigator(System::Xml::Linq::XNode ^ node, System::Xml::XmlNameTable ^ nameTable);" />
      <MemberSignature Language="F#" Value="static member CreateNavigator : System.Xml.Linq.XNode * System.Xml.XmlNameTable -&gt; System.Xml.XPath.XPathNavigator" Usage="System.Xml.XPath.Extensions.CreateNavigator (node, nameTable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
        <Parameter Name="nameTable" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="node"><span data-ttu-id="9e906-144">一个可以处理 XPath 查询的 <see cref="T:System.Xml.Linq.XNode" />。</span><span class="sxs-lookup"><span data-stu-id="9e906-144">An <see cref="T:System.Xml.Linq.XNode" /> that can process an XPath query.</span></span></param>
        <param name="nameTable"><span data-ttu-id="9e906-145">一个将由 <see cref="T:System.Xml.XmlNameTable" /> 使用的 <see cref="T:System.Xml.XPath.XPathNavigator" />。</span><span class="sxs-lookup"><span data-stu-id="9e906-145">A <see cref="T:System.Xml.XmlNameTable" /> to be used by <see cref="T:System.Xml.XPath.XPathNavigator" />.</span></span></param>
        <summary><span data-ttu-id="9e906-146">为 <see cref="T:System.Xml.XPath.XPathNavigator" /> 创建一个 <see cref="T:System.Xml.Linq.XNode" />。</span><span class="sxs-lookup"><span data-stu-id="9e906-146">Creates an <see cref="T:System.Xml.XPath.XPathNavigator" /> for an <see cref="T:System.Xml.Linq.XNode" />.</span></span> <span data-ttu-id="9e906-147"><see cref="T:System.Xml.XmlNameTable" /> 可以使 XPath 表达式的处理变得更高效。</span><span class="sxs-lookup"><span data-stu-id="9e906-147">The <see cref="T:System.Xml.XmlNameTable" /> enables more efficient XPath expression processing.</span></span></summary>
        <returns><span data-ttu-id="9e906-148">一个可以处理 XPath 查询的 <see cref="T:System.Xml.XPath.XPathNavigator" />。</span><span class="sxs-lookup"><span data-stu-id="9e906-148">An <see cref="T:System.Xml.XPath.XPathNavigator" /> that can process XPath queries.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9e906-149">不能使用 <xref:System.Xml.XPath.XPathNavigator> 此方法返回的来编辑 XML 树。</span><span class="sxs-lookup"><span data-stu-id="9e906-149">You cannot edit the XML tree using the <xref:System.Xml.XPath.XPathNavigator> that is returned by this method.</span></span> <span data-ttu-id="9e906-150"><xref:System.Xml.XPath.XPathNavigator.CanEdit%2A> 属性返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="9e906-150">The <xref:System.Xml.XPath.XPathNavigator.CanEdit%2A> property returns `false`.</span></span>  
  
 <span data-ttu-id="9e906-151">不能 <xref:System.Xml.XPath.XPathNavigator> 为 <xref:System.Xml.Linq.XDocumentType> 节点创建。</span><span class="sxs-lookup"><span data-stu-id="9e906-151">You cannot create an <xref:System.Xml.XPath.XPathNavigator> for a <xref:System.Xml.Linq.XDocumentType> node.</span></span> <span data-ttu-id="9e906-152">文档类型不参与 XPath 数据模型。</span><span class="sxs-lookup"><span data-stu-id="9e906-152">Document types do not participate in the XPath data model.</span></span>  
  
 <span data-ttu-id="9e906-153">命名空间声明按从左到右的报告。</span><span class="sxs-lookup"><span data-stu-id="9e906-153">Namespace declarations are reported from left to right.</span></span> <span data-ttu-id="9e906-154">相反，对于 <xref:System.Xml.XmlDocument> 命名空间，从右到左进行报告。</span><span class="sxs-lookup"><span data-stu-id="9e906-154">In contrast, for <xref:System.Xml.XmlDocument> namespaces are reported from right to left.</span></span> <span data-ttu-id="9e906-155">这是一致的行为，因为在 XPath 数据模型中没有对命名空间声明进行排序。</span><span class="sxs-lookup"><span data-stu-id="9e906-155">This is conformant behavior because namespace declarations are not ordered in the XPath data model.</span></span>  
  
 <span data-ttu-id="9e906-156"><xref:System.Xml.XPath.XPathNavigator.MoveToId%2A>此方法返回的导航器不支持此方法。</span><span class="sxs-lookup"><span data-stu-id="9e906-156">The method <xref:System.Xml.XPath.XPathNavigator.MoveToId%2A> is not supported for navigators that are returned by this method.</span></span>  
  
 <span data-ttu-id="9e906-157">如果你将 <xref:System.Xml.XmlNameTable> 与此方法一起使用来创建 <xref:System.Xml.XPath.XPathNavigator> ，则在评估 XPath 表达式时，你将获得更好的性能。</span><span class="sxs-lookup"><span data-stu-id="9e906-157">If you use an <xref:System.Xml.XmlNameTable> with this method to create the <xref:System.Xml.XPath.XPathNavigator>, you will get better performance when evaluating XPath expressions.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="XPathEvaluate">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9e906-158">计算 XPath 表达式。</span><span class="sxs-lookup"><span data-stu-id="9e906-158">Evaluates an XPath expression.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9e906-159">虽然未在 XML XPath 语言1.0 建议中指定返回集合的顺序，但此扩展方法以文档顺序返回节点。</span><span class="sxs-lookup"><span data-stu-id="9e906-159">Although the ordering of returned collections is not specified in the XML XPath Language 1.0 Recommendation, this extension method returns nodes in document order.</span></span>  
  
 <span data-ttu-id="9e906-160">请注意，即使使用反向轴（如或），也会以文档顺序返回 `preceding-sibling` 节点 `ancestor-or-self` 。</span><span class="sxs-lookup"><span data-stu-id="9e906-160">Note that nodes are returned in document order even when you use a reverse axis, such as `preceding-sibling` or `ancestor-or-self`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="XPathEvaluate">
      <MemberSignature Language="C#" Value="public static object XPathEvaluate (this System.Xml.Linq.XNode node, string expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object XPathEvaluate(class System.Xml.Linq.XNode node, string expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.XPathEvaluate(System.Xml.Linq.XNode,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function XPathEvaluate (node As XNode, expression As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Object ^ XPathEvaluate(System::Xml::Linq::XNode ^ node, System::String ^ expression);" />
      <MemberSignature Language="F#" Value="static member XPathEvaluate : System.Xml.Linq.XNode * string -&gt; obj" Usage="System.Xml.XPath.Extensions.XPathEvaluate (node, expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
        <Parameter Name="expression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="node"><span data-ttu-id="9e906-161">一个 <see cref="T:System.Xml.Linq.XNode" />，XPath 表达式将在其上计算。</span><span class="sxs-lookup"><span data-stu-id="9e906-161">The <see cref="T:System.Xml.Linq.XNode" /> on which to evaluate the XPath expression.</span></span></param>
        <param name="expression"><span data-ttu-id="9e906-162">一个包含 XPath 表达式的 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="9e906-162">A <see cref="T:System.String" /> that contains an XPath expression.</span></span></param>
        <summary><span data-ttu-id="9e906-163">计算 XPath 表达式。</span><span class="sxs-lookup"><span data-stu-id="9e906-163">Evaluates an XPath expression.</span></span></summary>
        <returns><span data-ttu-id="9e906-164">一个可以包含 <see langword="bool" />、<see langword="double" />、<see langword="string" /> 或 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的对象。</span><span class="sxs-lookup"><span data-stu-id="9e906-164">An object that can contain a <see langword="bool" />, a <see langword="double" />, a <see langword="string" />, or an <see cref="T:System.Collections.Generic.IEnumerable`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9e906-165">如果集合是元素或属性的枚举，则可以使用 `Cast` 运算符来获取或的集合 <xref:System.Xml.Linq.XElement> <xref:System.Xml.Linq.XAttribute> 。</span><span class="sxs-lookup"><span data-stu-id="9e906-165">If the collection is an enumeration of elements or attributes, you can use the `Cast` operator to get a collection of <xref:System.Xml.Linq.XElement> or <xref:System.Xml.Linq.XAttribute>.</span></span>  
  
 <span data-ttu-id="9e906-166">虽然未在 XML XPath 语言1.0 建议中指定返回集合的顺序，但此扩展方法以文档顺序返回节点。</span><span class="sxs-lookup"><span data-stu-id="9e906-166">Although the ordering of returned collections is not specified in the XML XPath Language 1.0 Recommendation, this extension method returns nodes in document order.</span></span>  
  
 <span data-ttu-id="9e906-167">请注意，即使使用反向轴（如或），也会以文档顺序返回 `preceding-sibling` 节点 `ancestor-or-self` 。</span><span class="sxs-lookup"><span data-stu-id="9e906-167">Note that nodes are returned in document order even when you use a reverse axis, such as `preceding-sibling` or `ancestor-or-self`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9e906-168">下面的示例创建一个包含特性的小型 XML 树，然后使用 <xref:System.Xml.XPath.Extensions.XPathEvaluate%2A> 方法检索特性。</span><span class="sxs-lookup"><span data-stu-id="9e906-168">The following example creates a small XML tree with an attribute, then uses the <xref:System.Xml.XPath.Extensions.XPathEvaluate%2A> method to retrieve the attribute.</span></span>  
  
```csharp  
  
                String xml = "<root a='value'/>";  
XDocument d = XDocument.Parse(xml);  
IEnumerable att = (IEnumerable)d.XPathEvaluate("/root/@a");  
Console.WriteLine(att.Cast<XAttribute>().FirstOrDefault());  
```  
  
```vb  
  
                Dim d As XDocument = _  
    <?xml version='1.0'?>  
    <root a='value'/>  
Dim att As IEnumerable = CType(d.XPathEvaluate("/root/@a"), IEnumerable)  
Console.WriteLine(att.Cast(Of XAttribute)().FirstOrDefault())  
```  
  
 <span data-ttu-id="9e906-169">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="9e906-169">This example produces the following output:</span></span>  
  
```  
a="value"  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="XPathEvaluate">
      <MemberSignature Language="C#" Value="public static object XPathEvaluate (this System.Xml.Linq.XNode node, string expression, System.Xml.IXmlNamespaceResolver resolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object XPathEvaluate(class System.Xml.Linq.XNode node, string expression, class System.Xml.IXmlNamespaceResolver resolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.XPathEvaluate(System.Xml.Linq.XNode,System.String,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function XPathEvaluate (node As XNode, expression As String, resolver As IXmlNamespaceResolver) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Object ^ XPathEvaluate(System::Xml::Linq::XNode ^ node, System::String ^ expression, System::Xml::IXmlNamespaceResolver ^ resolver);" />
      <MemberSignature Language="F#" Value="static member XPathEvaluate : System.Xml.Linq.XNode * string * System.Xml.IXmlNamespaceResolver -&gt; obj" Usage="System.Xml.XPath.Extensions.XPathEvaluate (node, expression, resolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="resolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="node"><span data-ttu-id="9e906-170">一个 <see cref="T:System.Xml.Linq.XNode" />，XPath 表达式将在其上计算。</span><span class="sxs-lookup"><span data-stu-id="9e906-170">The <see cref="T:System.Xml.Linq.XNode" /> on which to evaluate the XPath expression.</span></span></param>
        <param name="expression"><span data-ttu-id="9e906-171">一个包含 XPath 表达式的 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="9e906-171">A <see cref="T:System.String" /> that contains an XPath expression.</span></span></param>
        <param name="resolver"><span data-ttu-id="9e906-172">一个用于解析 XPath 表达式中命名空间前缀的 <see cref="T:System.Xml.IXmlNamespaceResolver" />。</span><span class="sxs-lookup"><span data-stu-id="9e906-172">A <see cref="T:System.Xml.IXmlNamespaceResolver" /> for the namespace prefixes in the XPath expression.</span></span></param>
        <summary><span data-ttu-id="9e906-173">计算 XPath 表达式，使用指定的 <see cref="T:System.Xml.IXmlNamespaceResolver" /> 解析命名空间前缀。</span><span class="sxs-lookup"><span data-stu-id="9e906-173">Evaluates an XPath expression, resolving namespace prefixes using the specified <see cref="T:System.Xml.IXmlNamespaceResolver" />.</span></span></summary>
        <returns><span data-ttu-id="9e906-174">一个包含表达式计算结果的对象。</span><span class="sxs-lookup"><span data-stu-id="9e906-174">An object that contains the result of evaluating the expression.</span></span> <span data-ttu-id="9e906-175">该对象可以为 <see langword="bool" />、<see langword="double" />、<see langword="string" /> 或 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</span><span class="sxs-lookup"><span data-stu-id="9e906-175">The object can be a <see langword="bool" />, a <see langword="double" />, a <see langword="string" />, or an <see cref="T:System.Collections.Generic.IEnumerable`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9e906-176">您可以使用此方法来计算包含命名空间前缀的 XPath 表达式。</span><span class="sxs-lookup"><span data-stu-id="9e906-176">You can use this method to evaluate XPath expressions that contain namespace prefixes.</span></span>  
  
 <span data-ttu-id="9e906-177">虽然未在 XML XPath 语言1.0 建议中指定返回集合的顺序，但此扩展方法以文档顺序返回节点。</span><span class="sxs-lookup"><span data-stu-id="9e906-177">Although the ordering of returned collections is not specified in the XML XPath Language 1.0 Recommendation, this extension method returns nodes in document order.</span></span>  
  
 <span data-ttu-id="9e906-178">请注意，即使使用反向轴（如或），也会以文档顺序返回 `preceding-sibling` 节点 `ancestor-or-self` 。</span><span class="sxs-lookup"><span data-stu-id="9e906-178">Note that nodes are returned in document order even when you use a reverse axis, such as `preceding-sibling` or `ancestor-or-self`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9e906-179">下面的示例创建一个包含命名空间的 XML 树。</span><span class="sxs-lookup"><span data-stu-id="9e906-179">The following example creates an XML tree that contains a namespace.</span></span> <span data-ttu-id="9e906-180">它使用 <xref:System.Xml.XmlReader> 来读取 XML 文档。</span><span class="sxs-lookup"><span data-stu-id="9e906-180">It uses an <xref:System.Xml.XmlReader> to read the XML document.</span></span> <span data-ttu-id="9e906-181">然后获取 <xref:System.Xml.XmlNameTable> 中的 <xref:System.Xml.XmlReader> 和 <xref:System.Xml.XmlNamespaceManager> 中的 <xref:System.Xml.XmlNameTable>。</span><span class="sxs-lookup"><span data-stu-id="9e906-181">It then gets an <xref:System.Xml.XmlNameTable> from the <xref:System.Xml.XmlReader>, and an <xref:System.Xml.XmlNamespaceManager> from the <xref:System.Xml.XmlNameTable>.</span></span> <span data-ttu-id="9e906-182">它 <xref:System.Xml.XmlNamespaceManager> 在选择元素时使用。</span><span class="sxs-lookup"><span data-stu-id="9e906-182">It uses the <xref:System.Xml.XmlNamespaceManager> when selecting an element.</span></span>  
  
```csharp  
  
                string markup =  
@"<aw:Root xmlns:aw='http://www.adventure-works.com'>  
    <aw:Child1 aw:Att='attdata'>child one data 1</aw:Child1>  
</aw:Root>";  
XmlReader reader = XmlReader.Create(new StringReader(markup));  
XElement root = XElement.Load(reader);  
XmlNameTable nameTable = reader.NameTable;  
XmlNamespaceManager namespaceManager = new XmlNamespaceManager(nameTable);  
namespaceManager.AddNamespace("aw", "http://www.adventure-works.com");  
IEnumerable atts = (IEnumerable)root.XPathEvaluate("./aw:Child1/@aw:Att", namespaceManager);  
IEnumerable<XAttribute> attList = atts.Cast<XAttribute>();  
XAttribute att = attList.First();  
Console.WriteLine(att);  
```  
  
```vb  
  
                Dim markup As XElement = _  
    <aw:Root xmlns:aw='http://www.adventure-works.com'>  
        <aw:Child1 aw:Att='attdata'>child one data 1</aw:Child1>  
    </aw:Root>  
Dim reader As XmlReader = markup.CreateReader  
Dim nameTable As XmlNameTable = reader.NameTable  
Dim namespaceManager As XmlNamespaceManager = New XmlNamespaceManager(nameTable)  
namespaceManager.AddNamespace("aw", "http://www.adventure-works.com")  
Dim atts As IEnumerable = CType(markup.XPathEvaluate("./aw:Child1/@aw:Att", namespaceManager), IEnumerable)  
Dim attList As IEnumerable(Of XAttribute) = atts.Cast(Of XAttribute)()  
Dim att As XAttribute = attList.First()  
Console.WriteLine(att)  
```  
  
 <span data-ttu-id="9e906-183">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="9e906-183">This example produces the following output:</span></span>  
  
```  
aw:Att="attdata"  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="XPathSelectElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9e906-184">使用 XPath 表达式选择 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="9e906-184">Selects an <see cref="T:System.Xml.Linq.XElement" /> using a XPath expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="XPathSelectElement">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement XPathSelectElement (this System.Xml.Linq.XNode node, string expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement XPathSelectElement(class System.Xml.Linq.XNode node, string expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.XPathSelectElement(System.Xml.Linq.XNode,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function XPathSelectElement (node As XNode, expression As String) As XElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Xml::Linq::XElement ^ XPathSelectElement(System::Xml::Linq::XNode ^ node, System::String ^ expression);" />
      <MemberSignature Language="F#" Value="static member XPathSelectElement : System.Xml.Linq.XNode * string -&gt; System.Xml.Linq.XElement" Usage="System.Xml.XPath.Extensions.XPathSelectElement (node, expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
        <Parameter Name="expression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="node"><span data-ttu-id="9e906-185">一个 <see cref="T:System.Xml.Linq.XNode" />，XPath 表达式将在其上计算。</span><span class="sxs-lookup"><span data-stu-id="9e906-185">The <see cref="T:System.Xml.Linq.XNode" /> on which to evaluate the XPath expression.</span></span></param>
        <param name="expression"><span data-ttu-id="9e906-186">一个包含 XPath 表达式的 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="9e906-186">A <see cref="T:System.String" /> that contains an XPath expression.</span></span></param>
        <summary><span data-ttu-id="9e906-187">使用 XPath 表达式选择 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="9e906-187">Selects an <see cref="T:System.Xml.Linq.XElement" /> using a XPath expression.</span></span></summary>
        <returns><span data-ttu-id="9e906-188">一个 <see cref="T:System.Xml.Linq.XElement" />，或者 null。</span><span class="sxs-lookup"><span data-stu-id="9e906-188">An <see cref="T:System.Xml.Linq.XElement" />, or null.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="9e906-189">下面的示例创建一个小型 XML 树，并使用 <xref:System.Xml.XPath.Extensions.XPathSelectElement%2A> 来选择单个元素。</span><span class="sxs-lookup"><span data-stu-id="9e906-189">The following example creates a small XML tree and uses <xref:System.Xml.XPath.Extensions.XPathSelectElement%2A> to select a single element.</span></span>  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5),  
    new XElement("Child6", 6)  
);  
XElement el = root.XPathSelectElement("./Child4");  
Console.WriteLine(el);  
```  
  
```vb  
  
                Dim root As XElement = _  
    <Root>  
        <Child1>1</Child1>  
        <Child2>2</Child2>  
        <Child3>3</Child3>  
        <Child4>4</Child4>  
        <Child5>5</Child5>  
        <Child6>6</Child6>  
    </Root>  
Dim el As XElement = root.XPathSelectElement("./Child4")  
Console.WriteLine(el)  
```  
  
 <span data-ttu-id="9e906-190">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="9e906-190">This example produces the following output:</span></span>  
  
```xml  
<Child4>4</Child4>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="XPathSelectElement">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement XPathSelectElement (this System.Xml.Linq.XNode node, string expression, System.Xml.IXmlNamespaceResolver resolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement XPathSelectElement(class System.Xml.Linq.XNode node, string expression, class System.Xml.IXmlNamespaceResolver resolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.XPathSelectElement(System.Xml.Linq.XNode,System.String,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function XPathSelectElement (node As XNode, expression As String, resolver As IXmlNamespaceResolver) As XElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Xml::Linq::XElement ^ XPathSelectElement(System::Xml::Linq::XNode ^ node, System::String ^ expression, System::Xml::IXmlNamespaceResolver ^ resolver);" />
      <MemberSignature Language="F#" Value="static member XPathSelectElement : System.Xml.Linq.XNode * string * System.Xml.IXmlNamespaceResolver -&gt; System.Xml.Linq.XElement" Usage="System.Xml.XPath.Extensions.XPathSelectElement (node, expression, resolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="resolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="node"><span data-ttu-id="9e906-191">一个 <see cref="T:System.Xml.Linq.XNode" />，XPath 表达式将在其上计算。</span><span class="sxs-lookup"><span data-stu-id="9e906-191">The <see cref="T:System.Xml.Linq.XNode" /> on which to evaluate the XPath expression.</span></span></param>
        <param name="expression"><span data-ttu-id="9e906-192">一个包含 XPath 表达式的 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="9e906-192">A <see cref="T:System.String" /> that contains an XPath expression.</span></span></param>
        <param name="resolver"><span data-ttu-id="9e906-193">一个用于解析 XPath 表达式中命名空间前缀的 <see cref="T:System.Xml.IXmlNamespaceResolver" />。</span><span class="sxs-lookup"><span data-stu-id="9e906-193">An <see cref="T:System.Xml.IXmlNamespaceResolver" /> for the namespace prefixes in the XPath expression.</span></span></param>
        <summary><span data-ttu-id="9e906-194">使用 XPath 表达式选择 <see cref="T:System.Xml.Linq.XElement" />，并使用指定的 <see cref="T:System.Xml.IXmlNamespaceResolver" /> 解析命名空间前缀。</span><span class="sxs-lookup"><span data-stu-id="9e906-194">Selects an <see cref="T:System.Xml.Linq.XElement" /> using a XPath expression, resolving namespace prefixes using the specified <see cref="T:System.Xml.IXmlNamespaceResolver" />.</span></span></summary>
        <returns><span data-ttu-id="9e906-195">一个 <see cref="T:System.Xml.Linq.XElement" />，或者 null。</span><span class="sxs-lookup"><span data-stu-id="9e906-195">An <see cref="T:System.Xml.Linq.XElement" />, or null.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9e906-196">您可以使用此方法来计算包含命名空间前缀的 XPath 表达式。</span><span class="sxs-lookup"><span data-stu-id="9e906-196">You can use this method to evaluate XPath expressions that contain namespace prefixes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9e906-197">下面的示例创建一个包含命名空间的 XML 树。</span><span class="sxs-lookup"><span data-stu-id="9e906-197">The following example creates an XML tree that contains a namespace.</span></span> <span data-ttu-id="9e906-198">它使用 <xref:System.Xml.XmlReader> 来读取 XML 文档。</span><span class="sxs-lookup"><span data-stu-id="9e906-198">It uses an <xref:System.Xml.XmlReader> to read the XML document.</span></span> <span data-ttu-id="9e906-199">然后获取 <xref:System.Xml.XmlNameTable> 中的 <xref:System.Xml.XmlReader> 和 <xref:System.Xml.XmlNamespaceManager> 中的 <xref:System.Xml.XmlNameTable>。</span><span class="sxs-lookup"><span data-stu-id="9e906-199">It then gets an <xref:System.Xml.XmlNameTable> from the <xref:System.Xml.XmlReader>, and an <xref:System.Xml.XmlNamespaceManager> from the <xref:System.Xml.XmlNameTable>.</span></span> <span data-ttu-id="9e906-200">它 <xref:System.Xml.XmlNamespaceManager> 在选择元素时使用。</span><span class="sxs-lookup"><span data-stu-id="9e906-200">It uses the <xref:System.Xml.XmlNamespaceManager> when selecting an element.</span></span>  
  
```csharp  
  
                string markup = @"  
<aw:Root xmlns:aw='http://www.adventure-works.com'>  
    <aw:Child1>child one data</aw:Child1>  
    <aw:Child2>child two data</aw:Child2>  
</aw:Root>";  
XmlReader reader = XmlReader.Create(new StringReader(markup));  
XElement root = XElement.Load(reader);  
XmlNameTable nameTable = reader.NameTable;  
XmlNamespaceManager namespaceManager = new XmlNamespaceManager(nameTable);  
namespaceManager.AddNamespace("aw", "http://www.adventure-works.com");  
XElement child1 = root.XPathSelectElement("./aw:Child1", namespaceManager);  
Console.WriteLine(child1);  
```  
  
```vb  
  
                Dim markup As XElement = _  
    <aw:Root xmlns:aw='http://www.adventure-works.com'>  
        <aw:Child1>child one data</aw:Child1>  
        <aw:Child2>child two data</aw:Child2>  
    </aw:Root>  
Dim reader As XmlReader = markup.CreateReader  
Dim nameTable As XmlNameTable = reader.NameTable  
Dim namespaceManager As XmlNamespaceManager = New XmlNamespaceManager(nameTable)  
namespaceManager.AddNamespace("aw", "http://www.adventure-works.com")  
Dim child1 As XElement = markup.XPathSelectElement("./aw:Child1", namespaceManager)  
Console.WriteLine(child1)  
```  
  
 <span data-ttu-id="9e906-201">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="9e906-201">This example produces the following output:</span></span>  
  
```  
<aw:Child1 xmlns:aw="http://www.adventure-works.com">child one data</aw:Child1>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="XPathSelectElements">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9e906-202">使用 XPath 表达式选择一个元素集合。</span><span class="sxs-lookup"><span data-stu-id="9e906-202">Selects a collection of elements using an XPath expression.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9e906-203">虽然未在 XML XPath 语言1.0 建议中指定返回集合的顺序，但此扩展方法以文档顺序返回节点。</span><span class="sxs-lookup"><span data-stu-id="9e906-203">Although the ordering of returned collections is not specified in the XML XPath Language 1.0 Recommendation, this extension method returns nodes in document order.</span></span>  
  
 <span data-ttu-id="9e906-204">请注意，即使使用反向轴（如或），也会以文档顺序返回 `preceding-sibling` 节点 `ancestor-or-self` 。</span><span class="sxs-lookup"><span data-stu-id="9e906-204">Note that nodes are returned in document order even when you use a reverse axis, such as `preceding-sibling` or `ancestor-or-self`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="XPathSelectElements">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; XPathSelectElements (this System.Xml.Linq.XNode node, string expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; XPathSelectElements(class System.Xml.Linq.XNode node, string expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.XPathSelectElements(System.Xml.Linq.XNode,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function XPathSelectElements (node As XNode, expression As String) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ XPathSelectElements(System::Xml::Linq::XNode ^ node, System::String ^ expression);" />
      <MemberSignature Language="F#" Value="static member XPathSelectElements : System.Xml.Linq.XNode * string -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="System.Xml.XPath.Extensions.XPathSelectElements (node, expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
        <Parameter Name="expression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="node"><span data-ttu-id="9e906-205">一个 <see cref="T:System.Xml.Linq.XNode" />，XPath 表达式将在其上计算。</span><span class="sxs-lookup"><span data-stu-id="9e906-205">The <see cref="T:System.Xml.Linq.XNode" /> on which to evaluate the XPath expression.</span></span></param>
        <param name="expression"><span data-ttu-id="9e906-206">一个包含 XPath 表达式的 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="9e906-206">A <see cref="T:System.String" /> that contains an XPath expression.</span></span></param>
        <summary><span data-ttu-id="9e906-207">使用 XPath 表达式选择一个元素集合。</span><span class="sxs-lookup"><span data-stu-id="9e906-207">Selects a collection of elements using an XPath expression.</span></span></summary>
        <returns><span data-ttu-id="9e906-208">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的 <see cref="T:System.Xml.Linq.XElement" />，它包含选定元素。</span><span class="sxs-lookup"><span data-stu-id="9e906-208">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> that contains the selected elements.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9e906-209">虽然未在 XML XPath 语言1.0 建议中指定返回集合的顺序，但此扩展方法以文档顺序返回节点。</span><span class="sxs-lookup"><span data-stu-id="9e906-209">Although the ordering of returned collections is not specified in the XML XPath Language 1.0 Recommendation, this extension method returns nodes in document order.</span></span>  
  
 <span data-ttu-id="9e906-210">请注意，即使使用反向轴（如或），也会以文档顺序返回 `preceding-sibling` 节点 `ancestor-or-self` 。</span><span class="sxs-lookup"><span data-stu-id="9e906-210">Note that nodes are returned in document order even when you use a reverse axis, such as `preceding-sibling` or `ancestor-or-self`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9e906-211">下面的示例创建一个小型 XML 树，并使用 <xref:System.Xml.XPath.Extensions.XPathSelectElements%2A> 选择一组元素。</span><span class="sxs-lookup"><span data-stu-id="9e906-211">The following example creates a small XML tree and uses <xref:System.Xml.XPath.Extensions.XPathSelectElements%2A> to select a set of elements.</span></span>  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child1", 2),  
    new XElement("Child1", 3),  
    new XElement("Child2", 4),  
    new XElement("Child2", 5),  
    new XElement("Child2", 6)  
);  
IEnumerable<XElement> list = root.XPathSelectElements("./Child2");  
foreach (XElement el in list)  
    Console.WriteLine(el);  
```  
  
```vb  
  
                Dim root As XElement = _  
    <Root>  
        <Child1>1</Child1>  
        <Child1>2</Child1>  
        <Child1>3</Child1>  
        <Child2>4</Child2>  
        <Child2>5</Child2>  
        <Child2>6</Child2>  
    </Root>  
Dim list As IEnumerable(Of XElement) = root.XPathSelectElements("./Child2")  
For Each el As XElement In list  
    Console.WriteLine(el)  
Next  
```  
  
 <span data-ttu-id="9e906-212">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="9e906-212">This example produces the following output:</span></span>  
  
```xml  
<Child2>4</Child2>  
<Child2>5</Child2>  
<Child2>6</Child2>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="XPathSelectElements">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; XPathSelectElements (this System.Xml.Linq.XNode node, string expression, System.Xml.IXmlNamespaceResolver resolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; XPathSelectElements(class System.Xml.Linq.XNode node, string expression, class System.Xml.IXmlNamespaceResolver resolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.XPathSelectElements(System.Xml.Linq.XNode,System.String,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function XPathSelectElements (node As XNode, expression As String, resolver As IXmlNamespaceResolver) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ XPathSelectElements(System::Xml::Linq::XNode ^ node, System::String ^ expression, System::Xml::IXmlNamespaceResolver ^ resolver);" />
      <MemberSignature Language="F#" Value="static member XPathSelectElements : System.Xml.Linq.XNode * string * System.Xml.IXmlNamespaceResolver -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="System.Xml.XPath.Extensions.XPathSelectElements (node, expression, resolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="resolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="node"><span data-ttu-id="9e906-213">一个 <see cref="T:System.Xml.Linq.XNode" />，XPath 表达式将在其上计算。</span><span class="sxs-lookup"><span data-stu-id="9e906-213">The <see cref="T:System.Xml.Linq.XNode" /> on which to evaluate the XPath expression.</span></span></param>
        <param name="expression"><span data-ttu-id="9e906-214">一个包含 XPath 表达式的 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="9e906-214">A <see cref="T:System.String" /> that contains an XPath expression.</span></span></param>
        <param name="resolver"><span data-ttu-id="9e906-215">一个用于解析 XPath 表达式中命名空间前缀的 <see cref="T:System.Xml.IXmlNamespaceResolver" />。</span><span class="sxs-lookup"><span data-stu-id="9e906-215">A <see cref="T:System.Xml.IXmlNamespaceResolver" /> for the namespace prefixes in the XPath expression.</span></span></param>
        <summary><span data-ttu-id="9e906-216">使用 XPath 表达式选择一个元素集合，并使用指定的 <see cref="T:System.Xml.IXmlNamespaceResolver" /> 解析命名空间前缀。</span><span class="sxs-lookup"><span data-stu-id="9e906-216">Selects a collection of elements using an XPath expression, resolving namespace prefixes using the specified <see cref="T:System.Xml.IXmlNamespaceResolver" />.</span></span></summary>
        <returns><span data-ttu-id="9e906-217">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的 <see cref="T:System.Xml.Linq.XElement" />，它包含选定元素。</span><span class="sxs-lookup"><span data-stu-id="9e906-217">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> that contains the selected elements.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9e906-218">您可以使用此方法来计算包含命名空间前缀的 XPath 表达式。</span><span class="sxs-lookup"><span data-stu-id="9e906-218">You can use this method to evaluate XPath expressions that contain namespace prefixes.</span></span>  
  
 <span data-ttu-id="9e906-219">虽然未在 XML XPath 语言1.0 建议中指定返回集合的顺序，但此扩展方法以文档顺序返回节点。</span><span class="sxs-lookup"><span data-stu-id="9e906-219">Although the ordering of returned collections is not specified in the XML XPath Language 1.0 Recommendation, this extension method returns nodes in document order.</span></span>  
  
 <span data-ttu-id="9e906-220">请注意，即使使用反向轴（如或），也会以文档顺序返回 `preceding-sibling` 节点 `ancestor-or-self` 。</span><span class="sxs-lookup"><span data-stu-id="9e906-220">Note that nodes are returned in document order even when you use a reverse axis, such as `preceding-sibling` or `ancestor-or-self`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9e906-221">此示例将创建一个包含命名空间的 XML 树。</span><span class="sxs-lookup"><span data-stu-id="9e906-221">This example creates an XML tree that contains a namespace.</span></span> <span data-ttu-id="9e906-222">它使用 <xref:System.Xml.XmlReader> 来读取 XML 文档。</span><span class="sxs-lookup"><span data-stu-id="9e906-222">It uses an <xref:System.Xml.XmlReader> to read the XML document.</span></span> <span data-ttu-id="9e906-223">然后获取 <xref:System.Xml.XmlNameTable> 中的 <xref:System.Xml.XmlReader> 和 <xref:System.Xml.XmlNamespaceManager> 中的 <xref:System.Xml.XmlNameTable>。</span><span class="sxs-lookup"><span data-stu-id="9e906-223">It then gets an <xref:System.Xml.XmlNameTable> from the <xref:System.Xml.XmlReader>, and an <xref:System.Xml.XmlNamespaceManager> from the <xref:System.Xml.XmlNameTable>.</span></span> <span data-ttu-id="9e906-224">它在 <xref:System.Xml.XmlNamespaceManager> 选择元素列表时使用。</span><span class="sxs-lookup"><span data-stu-id="9e906-224">It uses the <xref:System.Xml.XmlNamespaceManager> when selecting the list of elements.</span></span>  
  
```csharp  
  
                string markup = @"  
<aw:Root xmlns:aw='http://www.adventure-works.com'>  
    <aw:Child1>child one data 1</aw:Child1>  
    <aw:Child1>child one data 2</aw:Child1>  
    <aw:Child1>child one data 3</aw:Child1>  
    <aw:Child2>child two data 4</aw:Child2>  
    <aw:Child2>child two data 5</aw:Child2>  
    <aw:Child2>child two data 6</aw:Child2>  
</aw:Root>";  
XmlReader reader = XmlReader.Create(new StringReader(markup));  
XElement root = XElement.Load(reader);  
XmlNameTable nameTable = reader.NameTable;  
XmlNamespaceManager namespaceManager = new XmlNamespaceManager(nameTable);  
namespaceManager.AddNamespace("aw", "http://www.adventure-works.com");  
IEnumerable<XElement> elements = root.XPathSelectElements("./aw:Child1", namespaceManager);  
foreach (XElement el in elements)  
    Console.WriteLine(el);  
```  
  
```vb  
  
                Dim markup As XElement = _  
<aw:Root xmlns:aw="http://www.adventure-works.com">  
    <aw:Child1>child one data 1</aw:Child1>  
    <aw:Child1>child one data 2</aw:Child1>  
    <aw:Child1>child one data 3</aw:Child1>  
    <aw:Child2>child two data 4</aw:Child2>  
    <aw:Child2>child two data 5</aw:Child2>  
    <aw:Child2>child two data 6</aw:Child2>  
</aw:Root>  
Dim reader As XmlReader = markup.CreateReader  
Dim nameTable As XmlNameTable = reader.NameTable  
Dim namespaceManager As XmlNamespaceManager = New XmlNamespaceManager(nameTable)  
namespaceManager.AddNamespace("aw", "http://www.adventure-works.com")  
Dim elements As IEnumerable(Of XElement) = markup.XPathSelectElements("./aw:Child1", namespaceManager)  
For Each el As XElement In elements  
    Console.WriteLine(el)  
Next  
```  
  
 <span data-ttu-id="9e906-225">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="9e906-225">This example produces the following output:</span></span>  
  
```xml  
<aw:Child1 xmlns:aw="http://www.adventure-works.com">child one data 1</aw:Child1>  
<aw:Child1 xmlns:aw="http://www.adventure-works.com">child one data 2</aw:Child1>  
<aw:Child1 xmlns:aw="http://www.adventure-works.com">child one data 3</aw:Child1>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
