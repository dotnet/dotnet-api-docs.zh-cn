<Type Name="Interaction" FullName="Microsoft.VisualBasic.Interaction">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9e9ba0548c86abc96d8c1797f85c3c8fbd95022f" /><Meta Name="ms.sourcegitcommit" Value="c573d537afba2d4c1463538f1095f2f155025464" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="10/16/2019" /><Meta Name="ms.locfileid" Value="72404702" /></Metadata><TypeSignature Language="C#" Value="public sealed class Interaction" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Interaction extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.Interaction" />
  <TypeSignature Language="VB.NET" Value="Public Module Interaction" />
  <TypeSignature Language="C++ CLI" Value="public ref class Interaction sealed" />
  <TypeSignature Language="F#" Value="type Interaction = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
    <AssemblyVersion>10.0.4.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><see langword="Interaction" /> 模块包含用于与对象、应用程序和系统交互的过程。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此模块支持运行其他程序、调用方法或属性、从计算机发出嘟嘟声的 Visual Basic 语言关键字和运行时库成员、提供命令行字符串、操作 COM 对象和控制对话框。  
  
## Examples  
 下面的示例使用 `Shell` 函数运行用户指定的应用程序。 指定 <xref:Microsoft.VisualBasic.AppWinStyle.NormalFocus?displayProperty=nameWithType> 作为第二个参数将以正常大小打开应用程序，并为其提供焦点。  
  
```vb  
Dim procID As Integer  
' Run calculator.  
procID = Shell("C:\Windows\system32\calc.exe", AppWinStyle.NormalFocus)  
```  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/information-and-interaction-summary.md">信息和交互摘要</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/index.md">关键字 (Visual Basic)</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Visual Basic 运行时库成员</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="AppActivate">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>激活已经正在运行的应用程序。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppActivate">
      <MemberSignature Language="C#" Value="public static void AppActivate (int ProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppActivate(int32 ProcessId) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.AppActivate(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppActivate (ProcessId As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppActivate(int ProcessId);" />
      <MemberSignature Language="F#" Value="static member AppActivate : int -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.AppActivate ProcessId" />
      <MemberSignature Language="ILAsm" Value=".method public static void AppActivate(int32 ProcessId) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProcessId" Type="System.Int32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="ProcessId"><see langword="Integer" />，指定分配给该进程的 Win32 进程 ID 号。 可以使用 <see cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" /> 返回的 ID，前提是该 ID 不为零。</param>
        <summary>激活已经正在运行的应用程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 `AppActivate` 使应用程序的活动窗口处于焦点状态。 您可能没有活动窗口的句柄或引用，甚至知道哪个窗口在给定时刻处于活动状态。 在这种情况下，不能使用 <xref:System.Windows.Forms.Control.Focus%2A> 方法。  
  
 @No__t 的函数会将焦点更改为命名应用程序或窗口，但不会影响它是最大化还是最小化。 当用户执行某个操作来更改焦点或关闭窗口时，焦点将离开激活的应用程序窗口。 您可以使用 `Shell` 函数启动应用程序并设置窗口样式。  
  
 如果使用 @no__t 参数，`AppActivate` 将使用不区分大小写的比较，否则要求与标题栏的内容完全匹配。 它首先查找顶级窗口，然后遍历子窗口。 如果找不到匹配项，则会引发 <xref:System.ArgumentException>。  
  
 只能将 `AppActivate` 用于拥有 windows 的进程。 大多数控制台应用程序不拥有窗口，这意味着它们不显示在 @no__t 0 搜索的进程列表中。 在控制台应用程序中运行时，系统会创建一个单独的进程来运行应用程序，并将输出返回到控制台进程。 因此，当你请求当前进程 ID 时，将获取此单独进程的进程 ID，而不是控制台应用程序的进程 ID。  
  
 在运行时，`AppActivate` 函数会激活任何正在运行的应用程序，其标题与 @no__t 或与 `ProcessId` 匹配的进程 ID 匹配。 如果没有完全匹配项，则会激活其标题字符串以 `Title` 结尾的任何应用程序。 如果有多个名为 `Title` 的应用程序，`AppActivate` 函数将随意选择一个应用程序来激活。  
  
> [!NOTE]
>  @No__t 0 函数要求在 <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> 级别 `UIPermission`，这可能会影响在部分信任情况下的执行。 有关更多信息，请参见<xref:System.Security.Permissions.UIPermission>。  
  
   
  
## Examples  
 此示例说明了 `AppActivate` 函数激活应用程序窗口的各种用法。 如果记事本进程未运行，则该示例会引发 <xref:System.ArgumentException>。 @No__t 的过程假定应用程序位于指定的路径中。  
  
 [!code-vb[VbVbalrCatRef#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="AppActivate">
      <MemberSignature Language="C#" Value="public static void AppActivate (string Title);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppActivate(string Title) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.AppActivate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppActivate (Title As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppActivate(System::String ^ Title);" />
      <MemberSignature Language="F#" Value="static member AppActivate : string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.AppActivate Title" />
      <MemberSignature Language="ILAsm" Value=".method public static void AppActivate(string Title) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Title" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="Title"><see langword="String" /> 表达式，用于指定要激活的应用程序的标题栏中的标题。 可以使用启动应用程序后分配给该应用程序的标题。</param>
        <summary>激活已经正在运行的应用程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 `AppActivate` 使应用程序的活动窗口处于焦点状态。 您可能没有活动窗口的句柄或引用，甚至知道哪个窗口在给定时刻处于活动状态。 在这种情况下，不能使用 <xref:System.Windows.Forms.Control.Focus%2A> 方法。  
  
 @No__t 的函数会将焦点更改为命名应用程序或窗口，但不会影响它是最大化还是最小化。 当用户执行某个操作来更改焦点或关闭窗口时，焦点将离开激活的应用程序窗口。 您可以使用 `Shell` 函数启动应用程序并设置窗口样式。  
  
 如果使用 @no__t 参数，`AppActivate` 将使用不区分大小写的比较，否则要求与标题栏的内容完全匹配。 它首先查找顶级窗口，然后遍历子窗口。 如果找不到匹配项，则会引发 <xref:System.ArgumentException>。  
  
 只能将 `AppActivate` 用于拥有 windows 的进程。 大多数控制台应用程序不拥有窗口，这意味着它们不显示在 @no__t 0 搜索的进程列表中。 在控制台应用程序中运行时，系统会创建一个单独的进程来运行应用程序，并将输出返回到控制台进程。 因此，当你请求当前进程 ID 时，将获取此单独进程的进程 ID，而不是控制台应用程序的进程 ID。  
  
 在运行时，`AppActivate` 函数会激活任何正在运行的应用程序，其标题与 @no__t 或与 `ProcessId` 匹配的进程 ID 匹配。 如果没有完全匹配项，则会激活其标题字符串以 `Title` 结尾的任何应用程序。 如果有多个名为 `Title` 的应用程序，`AppActivate` 函数将随意选择一个应用程序来激活。  
  
> [!NOTE]
>  @No__t 0 函数要求在 <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> 级别 `UIPermission`，这可能会影响在部分信任情况下的执行。 有关更多信息，请参见<xref:System.Security.Permissions.UIPermission>。  
  
   
  
## Examples  
 此示例说明了 `AppActivate` 函数激活应用程序窗口的各种用法。 如果记事本进程未运行，则该示例会引发 <xref:System.ArgumentException>。 @No__t 的过程假定应用程序位于指定的路径中。  
  
 [!code-vb[VbVbalrCatRef#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Beep() cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Beep" />
      <MemberSignature Language="VB.NET" Value="Public Sub Beep ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Beep();" />
      <MemberSignature Language="F#" Value="static member Beep : unit -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.Beep " />
      <MemberSignature Language="ILAsm" Value=".method public static void Beep() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通过计算机扬声器提示音。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 嘟嘟声的音调和持续时间取决于您的硬件和系统软件，因此在不同的计算机之间有所不同。  
  
> [!NOTE]
>  @No__t 0 函数要求在 <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> 级别 `UIPermission`，这可能会影响在部分信任情况下的执行。 有关详细信息，请参阅 <xref:System.Security.Permissions.UIPermission>。  
  
   
  
## Examples  
 此示例使用 `Beep` 函数通过计算机的扬声器发出音调。  
  
 [!code-vb[VbVbalrCatRef#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Visual Basic 运行时库成员</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/computer-resources/playing-sounds.md">播放声音</related>
      </Docs>
    </Member>
    <Member MemberName="CallByName">
      <MemberSignature Language="C#" Value="public static object CallByName (object ObjectRef, string ProcName, Microsoft.VisualBasic.CallType UseCallType, params object[] Args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CallByName(object ObjectRef, string ProcName, valuetype Microsoft.VisualBasic.CallType UseCallType, object[] Args) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.CallByName(System.Object,System.String,Microsoft.VisualBasic.CallType,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CallByName (ObjectRef As Object, ProcName As String, UseCallType As CallType, ParamArray Args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CallByName(System::Object ^ ObjectRef, System::String ^ ProcName, Microsoft::VisualBasic::CallType UseCallType, ... cli::array &lt;System::Object ^&gt; ^ Args);" />
      <MemberSignature Language="F#" Value="static member CallByName : obj * string * Microsoft.VisualBasic.CallType * obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.CallByName (ObjectRef, ProcName, UseCallType, Args)" />
      <MemberSignature Language="ILAsm" Value=".method public static object CallByName(object ObjectRef, string ProcName, valuetype Microsoft.VisualBasic.CallType UseCallType, object[] Args) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ObjectRef" Type="System.Object" />
        <Parameter Name="ProcName" Type="System.String" />
        <Parameter Name="UseCallType" Type="Microsoft.VisualBasic.CallType" />
        <Parameter Name="Args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="ObjectRef">必需。 <see langword="Object" />。 一个指向公开属性或方法的对象的指针。</param>
        <param name="ProcName">必需。 <see langword="String" />。 一个字符串表达式，包含对象的属性或方法的名称。</param>
        <param name="UseCallType">必需。 类型 <see cref="T:Microsoft.VisualBasic.CallType" /> 的一个枚举成员，它表示正在被调用的过程的类型。 <see langword="CallType" /> 的值可以是 <see langword="Method" />、<see langword="Get" /> 或 <see langword="Set" />。</param>
        <param name="Args">可选。 <see langword="ParamArray" />。 一个形参数组，包含要传递给正在调用的属性或方法的实参。</param>
        <summary>执行对象的方法，或者设置或返回对象的属性。</summary>
        <returns>执行对象的方法，或者设置或返回对象的属性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在运行时使用 @no__t 0 函数获取属性、设置属性或调用方法。  
  
   
  
## Examples  
 在下面的示例中，第一行使用 `CallByName` 来设置文本框的 @no__t 属性，第二行检索 `Text` 属性的值，第三行调用 `Move` 方法以移动文本框。  
  
 [!code-vb[VbVbalrFunctions#99](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#99)]  
  
 [!code-vb[VbVbalrFunctions#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#20)]  
  
 下一个示例使用 `CallByName` 函数调用集合对象的 @no__t 和 @no__t 方法。  
  
 [!code-vb[VbVbalrFunctions#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">无效 <paramref name="UseCallType" /> 值；必须为 <see langword="Method" />、<see langword="Get" /> 或 <see langword="Set" />。</exception>
        <altmember cref="T:Microsoft.VisualBasic.CallType" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/procedures/parameter-arrays.md">参数数组</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/early-late-binding/calling-a-property-or-method-using-a-string-name.md">使用字符串名调用属性或方法</related>
      </Docs>
    </Member>
    <Member MemberName="Choose">
      <MemberSignature Language="C#" Value="public static object Choose (double Index, params object[] Choice);" />
      <MemberSignature Language="ILAsm" Value=".method public static object Choose(float64 Index, object[] Choice) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Choose (Index As Double, ParamArray Choice As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Choose(double Index, ... cli::array &lt;System::Object ^&gt; ^ Choice);" />
      <MemberSignature Language="F#" Value="static member Choose : double * obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.Choose (Index, Choice)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Double" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Choice" Type="System.Object[]" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="Index">必需。 <see langword="Double" />。 数值表达式，它得出的值在 1 和 <paramref name="Choice" /> 参数中传递的元素数量之间。</param>
        <param name="Choice">必需。 <see langword="Object" /> 参数数组。 可以为以逗号分隔的 <see langword="Object" /> 变量或表达式列表或一维 <see langword="Object" /> 元素数组提供计算为 <see langword="Object" /> 数据类型的单个变量或表达式。</param>
        <summary>从参数列表中选择和返回一个值。</summary>
        <returns>从参数列表中选择和返回一个值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 @No__t-0 函数根据 @no__t 的值返回 @no__t 中传递的列表的成员。 @No__t-0 为1时，将选择列表的第一个成员。 当 @no__t `UBound` （`Choice()`）时，将选择列表的最后一个成员。 如果 `Index` 超出了这些限制，`Choose` 返回 `Nothing`。  
  
 如果 `Index` 不是整数，则在计算之前，将舍入为最接近的整数。  
  
 您可以使用 `Choose` 在可能的列表中查找值。  
  
> [!NOTE]
>  自变量列表中的表达式可以包含函数调用。 作为 `Choose` 调用的参数列表的一部分，Visual Basic 编译器将调用每个表达式中的每个函数。 这意味着，如果 `Index` 选择了不同的表达式，则不能依赖于未调用的特定函数。  
  
   
  
## Examples  
 此示例使用 `Choose` 函数来显示名称，以响应传递到 @no__t 参数的过程中的索引。  
  
 [!code-vb[VbVbalrFunctions#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/select-case-statement.md">Select...Case 语句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Command">
      <MemberSignature Language="C#" Value="public static string Command ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Command() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Command" />
      <MemberSignature Language="VB.NET" Value="Public Function Command () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Command();" />
      <MemberSignature Language="F#" Value="static member Command : unit -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Command " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回命令行的参数部分，该命令行用于启动 Visual Basic 或启动使用 Visual Basic 开发的可执行程序。 <see langword="My" /> 功能可以提供比 <see langword="Command" /> 函数更高的效率和更好的性能。 有关详细信息，请参阅 <see cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />。</summary>
        <returns>命令行的参数部分，该命令行用于启动 Visual Basic 或启动使用 Visual Basic 开发的可执行程序。  
  
<see langword="My" /> 功能可以提供比 <see langword="Command" /> 函数更高的效率和更好的性能。 有关详细信息，请参阅 <see cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回参数后，可以搜索常用分隔符（如空格、向后或正斜杠、连字符或引号），以拆分或搜索单独参数的字符串。  
  
 对于使用 Visual Basic 开发并编译为 .exe 文件的应用程序，@no__t 的函数返回命令行上应用程序名称后出现的所有参数，格式为： `MyApp(cmdlineargs)`。  
  
   
  
## Examples  
 此示例使用 `Command` 函数返回包含数组的对象中的命令行参数。  
  
 [!code-vb[VbVbalrCatRef#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#58)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />
        <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Visual Basic 运行时库成员</related>
        <related type="Article" href="~/docs/visual-basic/reference/command-line-compiler/index.md">Visual Basic 命令行编译器</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/program-structure/structure-of-a-visual-basic-program.md">Visual Basic 程序的结构</related>
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public static object CreateObject (string ProgId, string ServerName = &quot;&quot;);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateObject(string ProgId, string ServerName) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.CreateObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject (ProgId As String, Optional ServerName As String = &quot;&quot;) As Object" />
      <MemberSignature Language="F#" Value="static member CreateObject : string * string -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.CreateObject (ProgId, ServerName)" />
      <MemberSignature Language="ILAsm" Value=".method public static object CreateObject(string ProgId, string ServerName) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="ServerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="ProgId">必需。 <see langword="String" />。 要创建的对象的程序 ID。</param>
        <param name="ServerName">可选。 <see langword="String" />。 要在其上创建对象的网络服务器的名称。 如果 <paramref name="ServerName" /> 是空字符串 ("")，则使用本地计算机。</param>
        <summary>创建并返回对 COM 对象的引用。 不能在 Visual Basic 中使用 <see langword="CreateObject" /> 创建这些类的实例，除非将类显式公开为 COM 组件。</summary>
        <returns>创建并返回对 COM 对象的引用。 不能在 Visual Basic 中使用 <see langword="CreateObject" /> 创建这些类的实例，除非将类显式公开为 COM 组件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要创建 COM 组件的实例，请将 @no__t 返回的对象分配给对象变量：  
  
```vb  
Sub CreateADODB()  
   Dim adoApp As Object  
   adoApp = CreateObject("ADODB.Connection")  
End Sub  
```  
  
 用于存储返回对象的对象变量的类型可能会影响应用程序的性能。 使用 `As Object` 子句声明对象变量将创建一个变量，该变量可包含对任何类型的对象的引用。 但是，通过该变量对对象的访问是*后期绑定*的，也就是说，在程序运行时将进行绑定。 应避免后期绑定的原因有很多，包括应用程序性能下降。  
  
 你可以创建一个生成早期绑定的对象变量，即在编译程序时进行绑定。 为此，请从 "**项目**" 菜单上的 "**添加引用**" 对话框的 " **COM** " 选项卡中为你的对象添加对类型库的引用。 然后声明对象的特定类型的对象变量。 在大多数情况下，使用 `Dim` 语句和主互操作程序集来创建对象比使用 `CreateObject` 函数更有效。  
  
## <a name="interacting-with-unmanaged-code"></a>与非托管代码交互  
 另一个问题是，COM 对象使用非托管代码，而不是公共语言运行时的优点。 将 Visual Basic 的托管代码与 COM 中的非托管代码混合使用会产生相当大的复杂性。 添加对 COM 对象的引用时，Visual Basic 会搜索该库的主互操作程序集（PIA）;如果找到一个，则使用它。 如果未找到 PIA，则会创建一个互操作性程序集，该程序集包含 COM 库中每个类的本地互操作性类。 有关详细信息，请参阅[.NET Framework 应用程序中的 COM 互操作性](~/docs/visual-basic/programming-guide/com-interop/com-interoperability-in-net-framework-applications.md)。  
  
 通常应尽可能使用强绑定对象和主互操作程序集。 下面的示例将 `CreateObject` 函数与 Microsoft Office 对象结合使用，以便仅用于演示目的。 但是，在与相应的主互操作程序集一起使用时，这些对象更易于使用且更可靠。  
  
## <a name="creating-an-object-on-a-remote-computer"></a>在远程计算机上创建对象  
 您可以通过将计算机名称传递给 `CreateObject` 函数的 @no__t 参数，在远程网络计算机上创建对象。 该名称与共享名称的计算机名称部分相同：对于名为 "\\ \ MyServer\Public" 的共享，`ServerName` 为 "MyServer"。  
  
> [!NOTE]
>  有关使应用程序在远程联网计算机上可访问的其他信息，请参阅 COM 文档（请参阅 Microsoft 开发人员网络）。 可能需要为应用程序添加注册表项。  
  
 下面的代码返回在名为 `MyServer` 的远程计算机上运行的 Excel 实例的版本号：  
  
```vb  
Sub CreateRemoteExcelObj()  
    Dim xlApp As Object  
    ' Replace string "\\MyServer" with name of the remote computer.  
    xlApp = CreateObject("Excel.Application", "\\MyServer")  
    MsgBox(xlApp.Version)  
End Sub  
```  
  
 如果远程服务器名称不正确或不可用，则会发生运行时错误。  
  
> [!NOTE]
>  如果没有对象的当前实例，请使用 `CreateObject`。 如果对象实例已在运行，则将启动一个新实例，并创建一个指定类型的对象。 若要使用当前实例，或要启动应用程序并将文件加载，请使用 `GetObject` 函数。 如果对象已将自身注册为单实例对象，则只会创建对象的一个实例，无论执行了多少次 `CreateObject`。  
  
## <a name="creating-framework-objects"></a>创建框架对象  
 只能使用 `CreateObject` 函数来创建 COM 对象。 尽管没有用于创建 .NET Framework 对象的完全等效机制，<xref:System> 命名空间中的 @no__t 包含创建本地或远程对象的方法。 具体而言，<xref:System.Activator.CreateInstance%2A> 方法或 @no__t 方法可能会很有用。  
  
> [!IMPORTANT]
>  @No__t-0 函数需要非托管代码权限，这可能会影响在部分信任情况下的执行。 有关详细信息，请参阅 <xref:System.Security.Permissions.SecurityPermission> 和[代码访问权限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
   
  
## Examples  
 下面的示例使用 `CreateObject` 函数创建 Microsoft Excel 工作表，并将该工作表保存到文件。 若要使用此示例，必须将 Excel 安装在运行此程序的计算机上。 此外，你必须从 "**项目**" 菜单上的 "**添加引用**" 对话框的 " **COM** " 选项卡中添加对类型库的引用。 类型库的名称因计算机上安装的 Excel 的版本而异。 例如，Microsoft Excel 2002 的类型库命名为 " **Microsoft excel 10.0 对象库**"。  
  
 [!code-vb[VbVbalrExcelObject#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">服务器不可用。</exception>
        <exception cref="T:System.IO.FileNotFoundException">不存在指定类型的对象。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetObject(System.String,System.String)" />
        <altmember cref="T:System.Exception" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.Activator" />
        <altmember cref="Overload:System.Activator.CreateInstance" />
        <altmember cref="Overload:System.Activator.CreateInstanceFrom" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/dim-statement.md">Dim 语句 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/declare-statement.md">Declare Statement</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/com-interop/com-interoperability-in-net-framework-applications.md">.NET Framework 应用程序中的 COM 互操作性</related>
        <related type="Article" href="~/docs/framework/interop/index.md">与非托管代码交互操作</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteSetting">
      <MemberSignature Language="C#" Value="public static void DeleteSetting (string AppName, string Section = null, string Key = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteSetting(string AppName, string Section, string Key) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSetting (AppName As String, Optional Section As String = null, Optional Key As String = null)" />
      <MemberSignature Language="F#" Value="static member DeleteSetting : string * string * string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.DeleteSetting (AppName, Section, Key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Section" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Key" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="AppName">必需。 <see langword="String" /> 表达式，包含应用节或项设置的应用程序或项目的名称。</param>
        <param name="Section">必需。 <see langword="String" /> 表达式，包含要从中删除项设置的节的名称。 如果仅提供了 <paramref name="AppName" /> 和 <paramref name="Section" />，则将删除指定的节以及所有相关的项设置。</param>
        <param name="Key">可选。 <see langword="String" /> 表达式，包含要删除的项设置的名称。</param>
        <summary>从 Windows 注册表中某个应用程序的项中删除一个节或一个项设置。 与 <see langword="DeleteSetting" /> 函数相比，<see langword="My" /> 功能在注册表操作方面可为你提供更高的效率和更好的性能。 有关更多信息，请参见<see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果提供所有参数，则将删除指定的设置。 如果尝试对不存在的节或键设置使用 @no__t，则会发生运行时错误。  
  
 `DeleteSetting` 要求用户登录，因为它在用户以交互方式登录之前处于不活动状态的 `HKEY_LOCAL_USER` 注册表项下运行。  
  
 要从非交互式进程（如 Mtx.exe）访问的注册表设置应存储在 `HKEY_LOCAL_MACHINE\Software\` 或 `HKEY_USER\DEFAULT\Software` 注册表项下。  
  
   
  
## Examples  
 下面的示例首先使用 `SaveSetting` 过程在 Windows 注册表中为 @no__t 1 应用程序生成条目，然后使用第 2 @no__t 函数将其删除。 由于未指定 @no__t 0 的参数，因此将删除整个 @no__t 的部分，包括节名称及其所有键。  
  
 [!code-vb[VbVbalrCatRef#45](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">用户没有登录。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Environ">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回与操作系统环境变量关联的字符串。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Environ">
      <MemberSignature Language="C#" Value="public static string Environ (int Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Environ(int32 Expression) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Environ(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Environ (Expression As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Environ(int Expression);" />
      <MemberSignature Language="F#" Value="static member Environ : int -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Environ Expression" />
      <MemberSignature Language="ILAsm" Value=".method public static string Environ(int32 Expression) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Int32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="Expression">必需。 此表达式用于计算包含环境变量名称的字符串，或对应于环境字符串表中环境字符串的数字顺序的整数。</param>
        <summary>返回与操作系统环境变量关联的字符串。</summary>
        <returns>与操作系统环境变量关联的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `Expression` 包含一个字符串，则 <xref:Microsoft.VisualBasic.Interaction.Environ%2A> 函数将返回分配给指定环境字符串的文本，即该环境变量的环境字符串表中等号（=）后的文本。 如果在环境字符串表中找不到 `Expression` 中的字符串，则返回长度为零的字符串（""）。  
  
 如果 `Expression` 包含一个整数，则会返回占用环境字符串表中该数值位置的字符串。 在这种情况下，<xref:Microsoft.VisualBasic.Interaction.Environ%2A> 返回所有文本，包括环境变量的名称。 如果指定位置没有环境字符串，<xref:Microsoft.VisualBasic.Interaction.Environ%2A> 返回一个长度为零的字符串。  
  
> [!IMPORTANT]
>  @No__t-0 函数需要环境权限，这可能会影响在部分信任情况下的执行。 有关详细信息，请参阅 <xref:System.Security.Permissions.SecurityPermission> 和[代码访问权限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
   
  
## Examples  
 此示例使用 <xref:Microsoft.VisualBasic.Interaction.Environ%2A> 函数提供环境字符串表中的 @no__t 1 语句的输入编号和长度。  
  
 [!code-vb[VbVbalrCatRef#28](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">缺少 <paramref name="Expression" />。</exception>
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Visual Basic 运行时库成员</related>
      </Docs>
    </Member>
    <Member MemberName="Environ">
      <MemberSignature Language="C#" Value="public static string Environ (string Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Environ(string Expression) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Environ(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Environ (Expression As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Environ(System::String ^ Expression);" />
      <MemberSignature Language="F#" Value="static member Environ : string -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Environ Expression" />
      <MemberSignature Language="ILAsm" Value=".method public static string Environ(string Expression) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="Expression">必需。 此表达式用于计算包含环境变量名称的字符串，或对应于环境字符串表中环境字符串的数字顺序的整数。</param>
        <summary>返回与操作系统环境变量关联的字符串。</summary>
        <returns>与操作系统环境变量关联的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `Expression` 包含一个字符串，则 <xref:Microsoft.VisualBasic.Interaction.Environ%2A> 函数将返回分配给指定环境字符串的文本，即该环境变量的环境字符串表中等号（=）后的文本。 如果在环境字符串表中找不到 `Expression` 中的字符串，则返回长度为零的字符串（""）。  
  
 如果 `Expression` 包含一个整数，则会返回占用环境字符串表中该数值位置的字符串。 在这种情况下，<xref:Microsoft.VisualBasic.Interaction.Environ%2A> 返回所有文本，包括环境变量的名称。 如果指定位置没有环境字符串，<xref:Microsoft.VisualBasic.Interaction.Environ%2A> 返回一个长度为零的字符串。  
  
> [!IMPORTANT]
>  @No__t-0 函数需要环境权限，这可能会影响在部分信任情况下的执行。 有关详细信息，请参阅 <xref:System.Security.Permissions.SecurityPermission> 和[代码访问权限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
   
  
## Examples  
 此示例使用 <xref:Microsoft.VisualBasic.Interaction.Environ%2A> 函数提供环境字符串表中的 @no__t 1 语句的输入编号和长度。  
  
 [!code-vb[VbVbalrCatRef#28](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">缺少 <paramref name="Expression" />。</exception>
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Visual Basic 运行时库成员</related>
      </Docs>
    </Member>
    <Member MemberName="GetAllSettings">
      <MemberSignature Language="C#" Value="public static string[,] GetAllSettings (string AppName, string Section);" />
      <MemberSignature Language="ILAsm" Value=".method public static string[,] GetAllSettings(string AppName, string Section) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllSettings (AppName As String, Section As String) As String(,)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^, 2&gt; ^ GetAllSettings(System::String ^ AppName, System::String ^ Section);" />
      <MemberSignature Language="F#" Value="static member GetAllSettings : string * string -&gt; string[,]" Usage="Microsoft.VisualBasic.Interaction.GetAllSettings (AppName, Section)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[,]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Section" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="AppName">必需。 <see langword="String" /> 表达式，包含请求其项设置的应用程序或项目的名称。</param>
        <param name="Section">必需。 一个 <see langword="String" /> 表达式，其中包含请求其关键设置的节的名称。 <see langword="GetAllSettings" /> 返回一个包含二维字符串数组的对象。 这些字符串包含指定节中的所有项设置及其相应的值。</param>
        <summary>从 Windows 注册表中某个应用程序的项返回项设置及其各自的值（最初通过 <see langword="SaveSetting" /> 创建）的列表。 与 <see langword="My" /> 相比，<see langword="GetAllSettings" /> 功能在注册表操作方面可为您提供更高的效率和更好的性能。 有关详细信息，请参阅 <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />。</summary>
        <returns>Windows 注册表中某个应用程序的项中的项设置及其各自的值（最初通过 <see langword="SaveSetting" /> 创建）的列表。  
  
与 <see langword="My" /> 相比，<see langword="GetAllSettings" /> 功能在注册表操作方面可为您提供更高的效率和更好的性能。 有关详细信息，请参阅 <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 @no__t @no__t 不存在，则 `GetAllSettings` 返回未初始化的 `Object`。  
  
 由于它在用户以交互方式登录之前处于不活动状态的 `HKEY_LOCAL_USER` 注册表项下运行，因此 `GetAllSettings` 需要用户登录。  
  
 要从非交互式进程（如 Mtx.exe）访问的注册表设置应存储在 `HKEY_LOCAL_MACHINE\Software\` 或 `HKEY_USER\DEFAULT\Software` 注册表项下。  
  
   
  
## Examples  
 此示例首先使用 `SaveSetting` 函数为指定为 @no__t 的应用程序的 Windows 注册表中的条目，然后使用 `GetAllSettings` 函数显示设置。 请注意，不能在 `GetAllSettings` 的情况下检索应用程序名称和 @no__t 的名称。 最后，`DeleteSetting` 函数会删除应用程序的条目。  
  
 [!code-vb[VbVbalrCatRef#68](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">用户没有登录。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/computer-resources/reading-from-and-writing-to-the-registry.md">读取和写入注册表 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (string PathName = null, string Class = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static object GetObject(string PathName, string Class) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetObject (Optional PathName As String = null, Optional Class As String = null) As Object" />
      <MemberSignature Language="F#" Value="static member GetObject : string * string -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.GetObject (PathName, Class)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Class" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="PathName">可选。 <see langword="String" />。 包含要检索的对象的文件的完整路径和名称。 如果省略了 <paramref name="PathName" />，则 <paramref name="Class" /> 为必选。</param>
        <param name="Class">如果未提供 <paramref name="PathName" />，则为必选。 <see langword="String" />。 表示对象的类的字符串。 <paramref name="Class" /> 参数具有以下语法和部分： 
 <c>appname</c><c>.</c><c>objecttype</c>  
  
[1|1] 参数 
[1|2]“描述” 
[2|1] <c>appname</c>  
  
[2|2]“所需的”。 <see langword="String" />。 提供对象的应用程序的名称。  
  
[3|1] <c>objecttype</c>  
  
[3|2]“所需的”。 <see langword="String" />。 要创建的对象的类型或类。</param>
        <summary>返回对 COM 组件提供的对象的引用。</summary>
        <returns>对 COM 组件提供的对象的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 `GetObject` 函数从文件中加载 COM 组件的实例。 下面的示例阐释了这一点。  
  
```vb  
Dim CADObject As Object  
CADObject = GetObject("C:\CAD\schema.cad")  
```  
  
 此代码运行时，将启动与指定 `PathName` 关联的应用程序，并激活指定文件中的对象。  
  
## <a name="default-cases"></a>默认情况  
 如果 @no__t 为零长度字符串（@no__t 为-1），则 `GetObject` 返回指定类类型的新对象实例。 如果省略 @no__t 参数，`GetObject` 返回 `Class` 中指定的类类型的当前活动对象。 如果不存在指定类型的对象，则会发生错误。  
  
## <a name="accessing-a-subobject"></a>访问子对象  
 某些应用程序允许你激活与文件关联的子对象。 为此，请将感叹号（`!`）添加到文件名的末尾，并在文件名后跟一个字符串，该字符串标识要激活的文件部分。 有关如何创建此字符串的信息，请参阅创建对象的应用程序的文档。  
  
 例如，在绘图应用程序中，可能有多个层用于存储在文件中的绘图。 你可以使用以下代码在名为 `schema.cad` 的绘图中激活层。  
  
```vb  
layerObject = GetObject("C:\CAD\schema.cad!Layer3")  
```  
  
## <a name="specifying-a-class"></a>指定类  
 如果未指定对象的 `Class`，则自动化将根据你提供的文件名确定要启动的应用程序和要激活的对象。 但是，某些文件可以支持多个对象类。 例如，绘制可能支持三种不同类型的对象： @no__t 0 对象、@no__t 1 对象和 `Toolbar` 对象，这些对象都属于同一文件。 若要指定要激活的文件中的哪个对象，请使用可选的 `Class` 参数。 下面的示例阐释了这一点。  
  
```vb  
Dim drawObj As Object  
drawObj = GetObject("C:\Drawings\sample.drw", "Figment.Drawing")  
```  
  
 在前面的示例中，@no__t 为绘图应用程序的名称，`Drawing` 是它支持的对象类型之一。  
  
## <a name="using-the-object"></a>使用对象  
 激活某个对象后，可以使用声明的对象变量在代码中引用该对象。 在前面的示例中，使用对象变量 `drawObj` 访问新对象的属性和方法。 下面的示例阐释了这一点。  
  
```vb  
drawObj.Line(9, 90)  
drawObj.InsertText(9, 100, "Hello, world.")  
drawObj.SaveAs("C:\Drawings\sample.drw")  
```  
  
> [!NOTE]
>  当存在对象的当前实例时，或者如果要使用加载的文件创建对象，请使用 `GetObject` 函数。 如果没有当前实例，并且你不希望在加载文件时启动对象，请使用 @no__t 的函数。  
>   
>  如果对象已将自身注册为 ActiveX 单实例对象，则仅创建对象的一个实例，无论调用多少次 `CreateObject`。 对于单实例对象，`GetObject` 在使用零长度字符串（`""`）语法调用时始终返回相同的实例，如果省略 `PathName` 参数，则会导致错误。 不能使用 @no__t 获取对使用 Visual Basic 创建的类的引用。  
  
> [!IMPORTANT]
>  @No__t-0 函数需要非托管代码权限，这可能会影响在部分信任情况下的执行。 有关详细信息，请参阅 <xref:System.Security.Permissions.SecurityPermission> 和[代码访问权限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
   
  
## Examples  
 下面的示例使用 `GetObject` 函数获取对特定 Microsoft Excel 工作表的引用（@no__t 为-1）。 它使用工作表的 `Application` 属性使 Excel 可见，将其关闭，然后执行其他操作。 使用两个 API 调用时，@no__t 的过程将查找 Excel，如果正在运行，则将其输入到正在运行的对象表中。 如果 Excel 尚未运行，则第一次调用 `GetObject` 会导致错误，在此示例中，会将 @no__t 标志设置为 `True`。 对 @no__t 的第二次调用指定要打开的文件。 如果 Excel 尚未运行，则第二次调用将启动它并返回对由指定的文件（`test.xls`）表示的工作表的引用。 文件必须存在于指定的位置;否则，Visual Basic 将引发 @no__t 为0。 接下来，示例代码使 Excel 和包含指定工作表的窗口可见。  
  
 此示例需要 `Option Strict Off`，因为它使用后期绑定，其中对象分配给类型 @no__t 为的变量。 如果从 Visual Studio 的 "**项目**" 菜单的 "**添加引用**" 对话框的 " **COM** " 选项卡中添加对 Excel 类型库的引用，则可以指定 @no__t 0 并声明特定对象类型的对象。  
  
 [!code-vb[VbVbalrExcelObject#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#2)]  
  
 [!code-vb[VbVbalrExcelObject#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#4)]  
  
 [!code-vb[VbVbalrExcelObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#5)]  
  
 调用 `getExcel` 函数时，会进行检查以查看 Excel 是否已在运行。 如果不是，则创建实例。  
  
> [!IMPORTANT]
>  为简单起见，前面的示例假定名为 @no__t 的任何窗口都属于 Microsoft Excel 的实例。 如果另一个对象（可能由非法篡改来启动）使用该名称创建了一个窗口，则它将接收你打算用于 Excel 的所有消息。 在要用于生产的应用程序中，应包括一些更严格的测试，以验证 `XLMAIN` 确实属于 Excel。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">不存在指定类类型的对象。</exception>
        <exception cref="T:System.IO.FileNotFoundException">不存在具有指定路径和文件名的对象。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.CreateObject(System.String,System.String)" />
        <altmember cref="T:System.Exception" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/declare-statement.md">Declare Statement</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/option-strict-statement.md">Option Strict Statement</related>
      </Docs>
    </Member>
    <Member MemberName="GetSetting">
      <MemberSignature Language="C#" Value="public static string GetSetting (string AppName, string Section, string Key, string Default = &quot;&quot;);" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetSetting(string AppName, string Section, string Key, string Default) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSetting (AppName As String, Section As String, Key As String, Optional Default As String = &quot;&quot;) As String" />
      <MemberSignature Language="F#" Value="static member GetSetting : string * string * string * string -&gt; string" Usage="Microsoft.VisualBasic.Interaction.GetSetting (AppName, Section, Key, Default)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Section" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Key" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Default" Type="System.String" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="AppName">必需。 <see langword="String" /> 表达式，包含请求其项设置的应用程序或项目的名称。</param>
        <param name="Section">必需。 <see langword="String" /> 表达式，包含在其中找到项设置的节的名称。</param>
        <param name="Key">必需。 <see langword="String" /> 表达式，包含要返回的项设置的名称。</param>
        <param name="Default">可选。 包含要返回的值的表达式（如果没有在 <paramref name="Key" /> 设置中设置值）。 如果省略，则假定 <paramref name="Default" /> 为零长度字符串 ("")。</param>
        <summary>从 Windows 注册表中应用程序的项返回项设置值。 与 <see langword="My" /> 相比，<see langword="GetAllSettings" /> 功能在注册表操作方面可为您提供更高的效率和更好的性能。 有关详细信息，请参阅 <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />。</summary>
        <returns>Windows 注册表中某个应用程序的项中的项设置值。  
  
与 <see langword="My" /> 相比，<see langword="GetAllSettings" /> 功能在注册表操作方面可为您提供更高的效率和更好的性能。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `GetSetting` 参数中命名的任何项不存在，`GetSetting` 返回值 `Default`。  
  
 由于它在用户以交互方式登录之前处于不活动状态的 `HKEY_LOCAL_USER` 注册表项下运行，因此 `GetSetting` 需要用户登录。  
  
 要从非交互式进程（如 Mtx.exe）访问的注册表设置应存储在 `HKEY_LOCAL_MACHINE\Software\` 或 `HKEY_USER\DEFAULT\Software` 注册表项下。  
  
 `GetSetting` 需要 `Read` @ no__t。  
  
   
  
## Examples  
 此示例首先使用 `SaveSetting` 函数为指定为 @no__t 的应用程序的 Windows 注册表中的条目，然后使用 `GetSetting` 函数显示其中一项设置。 因为指定了 @no__t 0 参数，所以保证返回某些值。 请注意，不能检索 `Section` @no__t 的名称。 最后，`DeleteSetting` 函数将删除应用程序的所有条目。  
  
 [!code-vb[VbVbalrCatRef#61](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#61)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个参数不是 <see langword="String" /> 表达式，或用户没有登录。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.Security.Permissions.RegistryPermission" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/computer-resources/reading-from-and-writing-to-the-registry.md">读取和写入注册表 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="IIf">
      <MemberSignature Language="C#" Value="public static object IIf (bool Expression, object TruePart, object FalsePart);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object IIf(bool Expression, object TruePart, object FalsePart) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IIf (Expression As Boolean, TruePart As Object, FalsePart As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ IIf(bool Expression, System::Object ^ TruePart, System::Object ^ FalsePart);" />
      <MemberSignature Language="F#" Value="static member IIf : bool * obj * obj -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.IIf (Expression, TruePart, FalsePart)" />
      <MemberSignature Language="ILAsm" Value=".method public static object IIf(bool Expression, object TruePart, object FalsePart) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Boolean" />
        <Parameter Name="TruePart" Type="System.Object" />
        <Parameter Name="FalsePart" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Expression">必需。 <see langword="Boolean" />。 要计算的表达式。</param>
        <param name="TruePart">必需。 <see langword="Object" />。 当 <paramref name="Expression" /> 计算结果为 <see langword="True" /> 时返回。</param>
        <param name="FalsePart">必需。 <see langword="Object" />。 当 <paramref name="Expression" /> 计算结果为 <see langword="False" /> 时返回。</param>
        <summary>根据表达式的计算，返回两个对象中的一个。</summary>
        <returns>根据表达式的计算，返回两个对象中的一个。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 @No__t-0 函数为 Visual C++中的三元[条件运算符：？：](https://msdn.microsoft.com/library/88643ee8-7100-4f86-880a-705ec22b6271)提供对应项。  
  
   
  
## Examples  
 此示例使用 `IIf` 函数来计算 `checkIt` 过程的 @no__t 参数，如果该数量大于1000，则返回 "大" 一词。否则，它将返回 "Small" 一词。  
  
 [!code-vb[VbVbalrFunctions#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#33)]  
  
 请注意，如果 `Option Strict` @no__t 为-1，则必须使用 `CStr` 关键字将返回从 `Object` 显式转换为 @no__t。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/option-strict-statement.md">Option Strict Statement</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/functions/type-conversion-functions.md">Type Conversion Functions</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/if-then-else-statement.md">If...Then...Else 语句 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/select-case-statement.md">Select...Case 语句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="InputBox">
      <MemberSignature Language="C#" Value="public static string InputBox (string Prompt, string Title = &quot;&quot;, string DefaultResponse = &quot;&quot;, int XPos = -1, int YPos = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputBox(string Prompt, string Title, string DefaultResponse, int32 XPos, int32 YPos) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.InputBox(System.String,System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputBox (Prompt As String, Optional Title As String = &quot;&quot;, Optional DefaultResponse As String = &quot;&quot;, Optional XPos As Integer = -1, Optional YPos As Integer = -1) As String" />
      <MemberSignature Language="F#" Value="static member InputBox : string * string * string * int * int -&gt; string" Usage="Microsoft.VisualBasic.Interaction.InputBox (Prompt, Title, DefaultResponse, XPos, YPos)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Prompt" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Title" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="DefaultResponse" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="XPos" Type="System.Int32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="YPos" Type="System.Int32" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="Prompt">必选的 <see langword="String" /> 表达式，作为消息显示在对话框中。 <paramref name="Prompt" /> 的最大长度大约为 1024 个字符，具体取决于所用字符的宽度。 如果 <paramref name="Prompt" /> 包含多行，可以使用回车符 (<see langword="Chr(" />13<see langword=")" />) 或换行符 (<see langword="Chr(" />10<see langword=")" />)，或组合使用回车符/换行符 (<see langword="Chr(" />13<see langword=")" /> &amp; <see langword="Chr(" />10<see langword=")" />) 来分隔每行。</param>
        <param name="Title">可选。 显示在对话框标题栏中的 <see langword="String" /> 表达式。 如果省略 <paramref name="Title" />，则标题栏中显示应用程序名称。</param>
        <param name="DefaultResponse">可选。 <see langword="String" /> 表达式。如果未提供其他输入，则作为默认响应显示在文本框中。 如果省略 <paramref name="DefaultResponse" />，则显示的文本框为空。</param>
        <param name="XPos">可选。 数值表达式，指定屏幕左边缘与对话框左边缘之间的距离（以缇为单位）。 如果省略 <paramref name="XPos" />，则对话框水平居中。</param>
        <param name="YPos">可选。 数值表达式，指定屏幕顶部与对话框上边缘之间的距离（以缇为单位）。 如果省略 <paramref name="YPos" />，则对话框垂直定位在屏幕向下大约三分之一处。</param>
        <summary>在对话框中显示提示，等待用户输入文本或单击按钮，然后返回包含文本框内容的字符串。</summary>
        <returns>在对话框中显示提示，等待用户输入文本或单击按钮，然后返回包含文本框内容的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果用户单击 "**取消**"，则返回一个长度为零的字符串。  
  
 若要指定除第一个参数以外的其他参数，必须在表达式中使用 `InputBox` 函数。 如果省略任何位置参数，则必须保留相应的逗号分隔符。  
  
> [!NOTE]
>  @No__t 0 函数要求在 <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> 级别 `UIPermission`，这可能会影响在部分信任情况下的执行。 有关详细信息，请参阅[请求权限](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/yd267cce(v%3dvs.100))和 <xref:System.Security.Permissions.UIPermission>。  
  
   
  
## Examples  
 此示例显示使用 `InputBox` 函数提示用户输入值的各种方式。 如果省略 x 和 y 位置，则对话框将自动居中放置在各自的轴上。 如果用户单击 "确定" 或按 ENTER 键，则变量 `MyValue` 包含用户输入的值。  
  
 [!code-vb[VbVbalrCatRef#67](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#67)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MsgBox">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.MsgBoxResult MsgBox (object Prompt, Microsoft.VisualBasic.MsgBoxStyle Buttons = Microsoft.VisualBasic.MsgBoxStyle.ApplicationModal, object Title = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.MsgBoxResult MsgBox(object Prompt, valuetype Microsoft.VisualBasic.MsgBoxStyle Buttons, object Title) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function MsgBox (Prompt As Object, Optional Buttons As MsgBoxStyle = Microsoft.VisualBasic.MsgBoxStyle.ApplicationModal, Optional Title As Object = null) As MsgBoxResult" />
      <MemberSignature Language="F#" Value="static member MsgBox : obj * Microsoft.VisualBasic.MsgBoxStyle * obj -&gt; Microsoft.VisualBasic.MsgBoxResult" Usage="Microsoft.VisualBasic.Interaction.MsgBox (Prompt, Buttons, Title)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.MsgBoxResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Prompt" Type="System.Object" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Buttons" Type="Microsoft.VisualBasic.MsgBoxStyle" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Title" Type="System.Object" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="Prompt">必需。 作为消息显示在对话框中的 <see langword="String" /> 表达式。 <paramref name="Prompt" /> 的最大长度大约为 1024 个字符，具体取决于所用字符的宽度。 如果 <paramref name="Prompt" /> 包含多行，可以使用回车符 (<see langword="Chr(" />13<see langword=")" />) 或换行符 (<see langword="Chr(" />10<see langword=")" />)，或组合使用回车符/换行符 (<see langword="Chr(" />13<see langword=")" /> &amp; <see langword="Chr(" />10<see langword=")" />) 来分隔每行。</param>
        <param name="Buttons">可选。 数值表达式，它是值的总和，指定显示的按钮数目及按钮类型，使用的图标样式，默认按钮的标识以及消息框的样式等。 如果省略 <paramref name="Buttons" />，则默认值为 0。</param>
        <param name="Title">可选。 显示在对话框标题栏中的 <see langword="String" /> 表达式。 如果省略 <paramref name="Title" />，则标题栏中显示应用程序名称。</param>
        <summary>在对话框中显示消息，等待用户单击按钮，然后返回一个整数，该整数指示用户单击的按钮。</summary>
        <returns><list type="table">
            <item>
              <term> 返回的常量 
 </term>
              <description> 值 
 </description>
            </item>
            <item>
              <term>
                <see langword="OK" />
              </term>
              <description> 1 
 </description>
            </item>
            <item>
              <term>
                <see langword="Cancel" />
              </term>
              <description> 2 
 </description>
            </item>
            <item>
              <term>
                <see langword="Abort" />
              </term>
              <description> 3 
 </description>
            </item>
            <item>
              <term>
                <see langword="Retry" />
              </term>
              <description> 4 
 </description>
            </item>
            <item>
              <term>
                <see langword="Ignore" />
              </term>
              <description> 5 
 </description>
            </item>
            <item>
              <term>
                <see langword="Yes" />
              </term>
              <description> 6 
 </description>
            </item>
            <item>
              <term>
                <see langword="No" />
              </term>
              <description> 7 
 </description>
            </item>
          </list>
。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果省略任何位置参数，则必须保留相应的逗号分隔符。  
  
 如果对话框显示 "**取消**" 按钮，则按 ESC 键具有与单击 "**取消**" 相同的效果  
  
 如果对话框包含 "**帮助**" 按钮，则会为该对话框提供上下文相关帮助。 但是，在关闭其他任一按钮前，不会返回任何值。 在 Windows 窗体应用程序中，选择 "**帮助**" 按钮将为窗体执行 <xref:System.Windows.Forms.Control.HelpRequested> 事件。  
  
> [!NOTE]
>  @No__t 0 函数要求在 <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> 级别 `UIPermission`，这可能会影响在部分信任情况下的执行。 有关详细信息，请参阅 <xref:System.Security.Permissions.UIPermission>。  
  
 下表列出了 `MsgBoxStyle` 枚举值。  
  
|成员|值|说明|  
|-|-|-|  
|成员|值|说明|  
|`OKOnly`|0|仅显示 "确定" 按钮。|  
|`OKCancel`|1|显示 "确定" 和 "取消" 按钮。|  
|`AbortRetryIgnore`|2|显示 "中止"、"重试" 和 "忽略" 按钮。|  
|`YesNoCancel`|3|显示 "是"、"否" 和 "取消" 按钮。|  
|`YesNo`|4|显示 "是" 和 "否" 按钮。|  
|`RetryCancel`|5|显示 "重试" 和 "取消" 按钮。|  
|`Critical`|16|显示关键消息图标。|  
|`Question`|32|显示警告查询图标。|  
|`Exclamation`|48|显示警告消息图标。|  
|`Information`|64|显示信息消息图标。|  
|`DefaultButton1`|0|第一个按钮是默认值。|  
|`DefaultButton2`|256|第二个按钮是默认值。|  
|`DefaultButton3`|512|第三个按钮是默认值。|  
|`ApplicationModal`|0|应用程序是模式的。 在当前应用程序中继续工作之前，用户必须响应该消息框。|  
|`SystemModal`|4096|系统是模式的。 所有应用程序都将挂起，直到用户响应消息框。|  
|`MsgBoxSetForeground`|65536|指定消息框窗口作为前台窗口。|  
|`MsgBoxRight`|524288|文本右对齐。|  
|`MsgBoxRtlReading`|1048576|指定文本在希伯来语和阿拉伯语系统中应显示为从右到左阅读。|  
  
 第一组值（0-5）描述对话框中显示的按钮的数量和类型。 第二组（16，32，48，64）描述了图标样式。 第三组（0，256，512）确定默认的按钮。 第四组（0，4096）确定消息框的模态，第五组指定消息框窗口是否为前景窗口，以及文本的对齐方式和方向。 在添加数字以为 `Buttons` 参数创建最终值时，每个组只使用一个编号。  
  
   
  
## Examples  
 此示例使用 `MsgBox` 函数在包含 "是" 和 "否" 按钮的对话框中显示严重错误消息。 "否" 按钮指定为默认响应。 这是通过将 `MsgBox` 常数值组合成一个数值表达式来完成的。 在这种情况下，将添加4（是/否按钮组合）和16（"**关键消息**" 窗口）和 "256" （第二个按钮作为默认按钮），总共为276。 @No__t-0 函数返回的值取决于用户选择的按钮：Yes 返回值 6;No 返回值7。  
  
 [!code-vb[VbVbalrCatRef#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Prompt" /> 不是一个 <see langword="String" /> 表达式，或者 <paramref name="Title" /> 无效。</exception>
        <exception cref="T:System.InvalidOperationException">进程不是以 User Interactive 模式运行。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">一个或多个参数，而不是 <see langword="MsgBoxResult" /> 或 <see langword="MsgBoxStyle" /> 枚举的成员。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.InputBox(System.String,System.String,System.String,System.Int32,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.MessageBox.Show(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Partition">
      <MemberSignature Language="C#" Value="public static string Partition (long Number, long Start, long Stop, long Interval);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Partition(int64 Number, int64 Start, int64 Stop, int64 Interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Partition(System.Int64,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Partition (Number As Long, Start As Long, Stop As Long, Interval As Long) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Partition(long Number, long Start, long Stop, long Interval);" />
      <MemberSignature Language="F#" Value="static member Partition : int64 * int64 * int64 * int64 -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Partition (Number, Start, Stop, Interval)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Number" Type="System.Int64" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Start" Type="System.Int64" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Stop" Type="System.Int64" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Interval" Type="System.Int64" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="Number">必需。 <see langword="Long" />。 要在一个计算范围中找到的整数。</param>
        <param name="Start">必需。 <see langword="Long" />。 一个整数，指示计算出的范围集的开始值。 <paramref name="Start" /> 不能小于 0。</param>
        <param name="Stop">必需。 <see langword="Long" />。 一个整数，指示计算出的范围集的结束值。 <paramref name="Stop" /> 不能小于或等于 <paramref name="Start" />。</param>
        <param name="Interval">必需。 <see langword="Long" />。 一个整数，指示在 <paramref name="Start" /> 和 <paramref name="Stop" /> 之间计算的每个范围大小。 <paramref name="Interval" /> 不能小于 1。</param>
        <summary>返回一个字符串，该字符串表示包含某个数字的计算范围。</summary>
        <returns>一个字符串，该字符串表示包含某个数字的计算范围。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 @No__t-0 函数计算一组数值范围，其中每个数值范围包含 @no__t 指定的值的数目。 第一个范围从 @no__t 开始，最后一个范围以 `Stop` 结束。 然后 `Partition` 函数标识包含 @no__t 为1的范围，并返回描述该范围的字符串。 范围在字符串中表示为 "*lowervalue*：*uppervalue*"，其中范围的低端（*lowervalue*）通过冒号（:) 与高端（*uppervalue*）隔开。  
  
 如有必要，`Partition` 函数将在*lowervalue*和*uppervalue*之前插入前导空格，以便它们具有与值的字符串表示形式相同的字符数（`Stop` + 1）。 这可以确保如果你使用 @no__t 为-1 的几个值的 `Partition` 函数的输出，则将在任何后续排序操作过程中正确处理生成的文本。  
  
 下表显示了使用三组 `Start`、`Stop` 和 `Interval` 来计算的范围的示例字符串。 如果 "第一个范围" 和 "最后一个范围" 列的值为 `Start` 并 @no__t 为-1，则这些列将显示可能的最小和最大范围。 "第一个范围之前" 和 "最后一范围之后" 列显示为 `Number` 小于 `Start` 且大于 `Stop` 的值返回的字符串。  
  
|`Start`|`Stop`|`Interval`|在第一个范围之前|第一个范围|最后一个范围|最后一个范围之后|  
|-|-|-|-|-|-|-|  
|0|99|5|"   : -1"|04|"95：99 "|"100："|  
|20|199|10|"   :19|0.25|"190:199"|"200："|  
|100|1010|20|"    :99 "|"100：119 "|"1000:1010"|"1011："|  
  
 在上表中，第三行显示 `Start` 时的结果，`Stop` 定义一组不能按 @no__t 2 平均分割的数字。 最后一个范围的结束时间为 `Stop`，即使 `Interval` 为20，也只会使它的长度超过11个数字。  
  
 如果 `Interval` 为1，则该范围为 "`Number`： `Number`"，与 @no__t 3 和 @no__t 参数无关。 例如，如果 @no__t 为267，`Stop` 为1000，`Interval` 为1，则 `Partition` 返回 "267：267 "。  
  
 构造数据库查询时，@no__t 0 会很有用。 您可以创建一个选择查询，用于显示在各种值范围内发生的订单数，例如，发票值介于1到1000、1001到2000等。  
  
   
  
## Examples  
 下面的示例设置从1950到2049的数十系列范围。 它在适当范围内查找 @no__t 值0的值，并返回显示该范围的 @no__t 1 值。 如果 `year` 的值为1984，例如，`Partition` 返回 "1980:1989"。  
  
 [!code-vb[VbVbalrFunctions#45](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Start" /> &lt; 0、<paramref name="Stop" /> &lt;= <paramref name="Start" /> 或 <paramref name="Interval" /> &lt; 1。</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveSetting">
      <MemberSignature Language="C#" Value="public static void SaveSetting (string AppName, string Section, string Key, string Setting);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SaveSetting(string AppName, string Section, string Key, string Setting) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveSetting (AppName As String, Section As String, Key As String, Setting As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SaveSetting(System::String ^ AppName, System::String ^ Section, System::String ^ Key, System::String ^ Setting);" />
      <MemberSignature Language="F#" Value="static member SaveSetting : string * string * string * string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.SaveSetting (AppName, Section, Key, Setting)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Section" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Key" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Setting" Type="System.String" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="AppName">必需。 <see langword="String" /> 表达式，包含应用该设置的应用程序或项目的名称。</param>
        <param name="Section">必需。 <see langword="String" /> 表达式，包含在其中保存项设置的节的名称。</param>
        <param name="Key">必需。 <see langword="String" /> 表达式，包含将保存的项设置的名称。</param>
        <param name="Setting">必需。 包含值的表达式，<paramref name="Key" /> 将被设置为该值。</param>
        <summary>在 Windows 注册表中保存或创建应用程序项。 与 <see langword="My" /> 相比，<see langword="SaveSetting" /> 功能在注册表操作方面可为您提供更高的效率和更好的性能。 有关详细信息，请参阅 <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 @No__t 的函数将键添加到 @no__t。  
  
 如果由于任何原因而无法保存密钥设置，则会发生错误。  
  
 `SaveSetting` 要求用户登录，因为它在用户以交互方式登录之前处于不活动状态的 `HKEY_LOCAL_USER` 注册表项下运行。  
  
 要从非交互式进程（如 Mtx.exe）访问的注册表设置应存储在 `HKEY_LOCAL_MACHINE\Software\` 或 `HKEY_USER\DEFAULT\Software` 注册表项下。  
  
 `SaveSetting` 需要 `Write`，`Create` @ no__t。  
  
   
  
## Examples  
 下面的示例首先使用 `SaveSetting` 函数为 @no__t 1 应用程序的 Windows 注册表中的条目，然后使用第 2 @no__t 函数将其删除。  
  
 [!code-vb[VbVbalrCatRef#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#56)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">未能创建注册表项，或用户没有登录。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.Security.Permissions.RegistryPermission" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/computer-resources/reading-from-and-writing-to-the-registry.md">读取和写入注册表 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Shell">
      <MemberSignature Language="C#" Value="public static int Shell (string Pathname, Microsoft.VisualBasic.AppWinStyle Style = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, bool Wait = false, int Timeout = -1);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Shell(string Pathname, valuetype Microsoft.VisualBasic.AppWinStyle Style, bool Wait, int32 Timeout) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Shell (Pathname As String, Optional Style As AppWinStyle = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, Optional Wait As Boolean = false, Optional Timeout As Integer = -1) As Integer" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="static member Shell : string * Microsoft.VisualBasic.AppWinStyle * bool * int -&gt; int" Usage="Microsoft.VisualBasic.Interaction.Shell (Pathname, Style, Wait, Timeout)" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C#" Value="public static int Shell (string PathName, Microsoft.VisualBasic.AppWinStyle Style = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, bool Wait = false, int Timeout = -1);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Shell(string PathName, valuetype Microsoft.VisualBasic.AppWinStyle Style, bool Wait, int32 Timeout) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Function Shell (PathName As String, Optional Style As AppWinStyle = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, Optional Wait As Boolean = false, Optional Timeout As Integer = -1) As Integer" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="static member Shell : string * Microsoft.VisualBasic.AppWinStyle * bool * int -&gt; int" Usage="Microsoft.VisualBasic.Interaction.Shell (PathName, Style, Wait, Timeout)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Pathname" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Style" Type="Microsoft.VisualBasic.AppWinStyle" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Wait" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Timeout" Type="System.Int32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="Pathname">必需。 <see langword="String" />。 要执行的程序的名称，以及所有必需的参数和命令行开关。 <paramref name="PathName" /> 也可以包含驱动器和目录路径或文件夹。
如果不知道程序的路径，则可以使用 <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" /> 进行定位。 例如，你可以调用 <c>My.Computer.FileSystem.GetFiles("C:\", True, "testFile.txt")</c>，这将返回驱动器 C:\\ 上任意位置每个名为 <c>testFile.txt</c> 的文件的完整路径。</param>
        <param name="PathName">必需。 <see langword="String" />。 要执行的程序的名称，以及所有必需的参数和命令行开关。 <paramref name="PathName" /> 也可以包含驱动器和目录路径或文件夹。  
 如果不知道程序的路径，则可以使用 <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" /> 进行定位。 例如，你可以调用 <c>My.Computer.FileSystem.GetFiles("C:\", True, "testFile.txt")</c>，这将返回驱动器 C:\\ 上任意位置每个名为 <c>testFile.txt</c> 的文件的完整路径。</param>
        <param name="Style">可选。 <see langword="AppWinStyle" />。 从 <see cref="T:Microsoft.VisualBasic.AppWinStyle" /> 中选择的一个值，该值指定将要在其中运行程序的窗口的样式。 如果省略 <paramref name="Style" />，<see langword="Shell" /> 将使用 <see langword="AppWinStyle.MinimizedFocus" /> 以最小化方式启动该程序并获得焦点。</param>
        <param name="Wait">可选。 <see langword="Boolean" />。 一个指示 <see langword="Shell" /> 函数是否应等待程序完成的值。 如果省略 <paramref name="Wait" />，则 <see langword="Shell" /> 将使用 <see langword="False" />。</param>
        <param name="Timeout">可选。 <see langword="Integer" />。 如果 <paramref name="Wait" /> 为 <see langword="True" />，则为等待完成的毫秒数。 如果省略 <paramref name="Timeout" />，则 <see langword="Shell" /> 使用 -1，表示没有超时设置并且 <see langword="Shell" /> 到程序结束时才返回。 因此，如果省略 <paramref name="Timeout" /> 或将其设置为 -1，则 <see langword="Shell" /> 可能永远不会将控制返回给您的程序。</param>
        <summary>运行一个可执行程序，并且如果该程序仍在运行则返回一个包含该程序的进程 ID 的整数。</summary>
        <returns>一个整数，包含该程序仍在运行时的进程 ID。 如果该程序已完成执行，则为 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 @No__t-0 函数的返回值取决于在 `Shell` 返回时是否仍在执行 @no__t 中指定的程序。 如果将 `Wait` 设置为 `True`，并且程序在超时过期之前完成，则 `Shell` 返回零。 如果超时时间已到，或者省略 @no__t 0 或将其设置为 `False`，`Shell` 返回程序的进程 ID。 进程 ID 是一个唯一的编号，用于标识正在运行的程序。  
  
## <a name="failure-to-start"></a>未能启动  
 如果 `Shell` 函数无法启动命名程序，则会发生 <xref:System.IO.FileNotFoundException> 错误。 例如，当你尝试从使用 <xref:System.Windows.Forms?displayProperty=nameWithType> 的应用程序运行16位程序（例如 `command.com`）时，可能会发生这种情况。 为解决此问题，你可以运行一个调用所需的16位程序的32位程序。 在 `command.com` 的情况下，你可以将 @no__t 作为替代方法来运行。  
  
## <a name="waiting-for-completion"></a>等待完成  
 默认情况下，`Shell` 函数以异步方式运行程序。 这意味着在执行 `Shell` 函数之后的语句之前，使用 `Shell` 函数启动的程序可能无法完成执行。 如果希望在继续操作之前等待程序完成，请将 `Wait` 设置为 `True`。  
  
## <a name="determining-the-exit-code"></a>确定退出代码  
 进程在终止时可以返回*退出代码*。 但是，你不能使用 `Shell` 来检索此退出代码，因为 @no__t 如果在等待终止的情况下返回零，还会在 `Shell` 的不同对象中运行该进程。  
  
 若要从进程中检索退出代码，你必须编写自己的代码来启动进程并等待终止。 下面的示例演示如何启动进程，等待它终止，并检索其退出代码。  
  
```vb  
Dim procID As Integer  
Dim newProc As Diagnostics.Process  
newProc = Diagnostics.Process.Start("C:\WINDOWS\NOTEPAD.EXE")  
procID = newProc.Id  
newProc.WaitForExit()  
Dim procEC As Integer = -1  
If newProc.HasExited Then  
    procEC = newProc.ExitCode  
End If  
MsgBox("Process with ID " & CStr(ProcID) & _  
    " terminated with exit code " & CStr(procEC))  
```  
  
## <a name="protecting-the-file-specification"></a>保护文件规范  
 应始终将整个路径和文件规范括在引号中，如下面的示例所示。  
  
```vb  
ID = Shell("""C:\Program Files\display.exe"" -a -q", , True, 100000)  
```  
  
 字符串文本中的每对相邻双引号（`" "`）被解释为字符串中的一个双引号字符。 因此，前面的示例向 `Shell` 函数提供以下字符串：  
  
```console  
"C:\Program Files\display.exe" -a -q  
```  
  
 如果没有用引号引起来的路径，Windows 将在 C：\ 中查找名为 `Program.exe` 的文件目录，而不是在 C:\Program Files 目录中 `display.exe`。  
  
> [!IMPORTANT]
>  如果未将路径和文件规范括在引号中，则如果文件名或路径节点包含空格，则会产生安全风险。 在前面的示例中，路径节点 `\Program Files` 包括空格。 如果规范不在引号内并且已在 C： \\ 中安装了名为 `Program.exe` 的程序，例如，违法篡改，则 Windows 将执行它，而不是 `display.exe`。  
  
> [!IMPORTANT]
>  @No__t-0 函数需要非托管代码权限，这可能会影响在部分信任情况下的执行。 有关详细信息，请参阅 <xref:System.Security.Permissions.SecurityPermission> 和[代码访问权限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
   
  
## Examples  
 下面的示例使用 `Shell` 函数运行用户指定的应用程序。 指定 <xref:Microsoft.VisualBasic.AppWinStyle.NormalFocus?displayProperty=nameWithType> 作为第二个参数将以正常大小打开应用程序，并为其提供焦点。  
  
 [!code-vb[VbVbalrFunctions#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Style" /> 不在 0 到 9（包含 0 和 9）范围内。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><see langword="Shell" /> 找不到 <paramref name="PathName" /> 文件。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="PathName" /> 为 <see langword="Nothing" />。</exception>
        <altmember cref="T:Microsoft.VisualBasic.AppWinStyle" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.NullReferenceException" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" />
        <altmember cref="Overload:Microsoft.VisualBasic.Interaction.AppActivate" />
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static object Switch (params object[] VarExpr);" />
      <MemberSignature Language="ILAsm" Value=".method public static object Switch(object[] VarExpr) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Switch (ParamArray VarExpr As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Switch(... cli::array &lt;System::Object ^&gt; ^ VarExpr);" />
      <MemberSignature Language="F#" Value="static member Switch : obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.Switch VarExpr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="VarExpr" Type="System.Object[]" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="VarExpr">必需。 <see langword="Object" /> 参数数组。 必须具有偶数个元素。 可以提供以逗号分隔的 <see langword="Object" /> 变量或表达式的列表，或一维 <see langword="Object" /> 元素数组。</param>
        <summary>计算表达式列表，并返回与列表中第一个为 <see langword="Object" /> 的表达式对应的 <see langword="True" /> 值。</summary>
        <returns>计算表达式列表，并返回与列表中第一个为 <see langword="Object" /> 的表达式对应的 <see langword="True" /> 值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为 @no__t 提供的参数由成对的表达式和值组成。 @No__t-0 函数在 `VarExpr` 中从最低到最高索引计算奇数表达式，并返回与计算结果为 `True` 的第一个表达式关联的偶数值。 例如，如果 `VarExpr(0)` @no__t 为-1，`Switch` 返回 `VarExpr(1)`，但 @no__t 为 `VarExpr(2)`，`Switch` 将返回 `VarExpr(3)`，依此类推。  
  
 如果未提供 `VarExpr` 参数，`Switch` 返回 `Nothing`。  
  
> [!NOTE]
>  自变量列表中的表达式可以包含函数调用。 作为 `Switch` 调用的参数列表的一部分，Visual Basic 编译器将调用每个表达式中的每个函数。 这意味着，如果参数列表中前面的表达式 `True`，则不能依赖于未调用的特定函数。  
  
   
  
## Examples  
 下面的示例使用 `Switch` 函数返回与 city 名称匹配的语言名称。 它要求 `Option Strict` @no__t 为-1。  
  
 [!code-vb[VbVbalrFunctions#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#48)]  
  
 由于 @no__t 的命名空间还包含名为 @no__t 的类，因此必须使用 <xref:Microsoft.VisualBasic> 命名空间限定对 `Switch` 函数的调用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">参数数目为奇数。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/select-case-statement.md">Select...Case 语句 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/procedures/parameter-arrays.md">参数数组</related>
      </Docs>
    </Member>
  </Members>
</Type>
