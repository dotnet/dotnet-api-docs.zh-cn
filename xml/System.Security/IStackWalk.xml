<Type Name="IStackWalk" FullName="System.Security.IStackWalk">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3e6233b8c576453e76b9b76c40cfb723247251ed" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83950208" /></Metadata><TypeSignature Language="C#" Value="public interface IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IStackWalk" />
  <TypeSignature Language="DocId" Value="T:System.Security.IStackWalk" />
  <TypeSignature Language="VB.NET" Value="Public Interface IStackWalk" />
  <TypeSignature Language="C++ CLI" Value="public interface class IStackWalk" />
  <TypeSignature Language="F#" Value="type IStackWalk = interface" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System.Security.Permissions" FromVersion="4.0.2.0" To="System.Runtime.Extensions" ToVersion="4.2.1.0" FrameworkAlternate="dotnet-plat-ext-3.0;netcore-3.0" />
    <TypeForwarding From="System.Security.Permissions" FromVersion="4.0.3.0" To="System.Runtime.Extensions" ToVersion="4.2.2.0" FrameworkAlternate="dotnet-plat-ext-3.1" />
    <TypeForwarding From="System.Security.Permissions" FromVersion="5.0.0.0" To="System.Runtime.Extensions" ToVersion="4.2.1.0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0" />
    <TypeForwarding From="System.Runtime.Extensions" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Security.Permissions" FromVersion="4.0.3.0" To="System.Runtime.Extensions" ToVersion="4.2.1.0" FrameworkAlternate="netcore-3.1" />
  </TypeForwardingChain>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>用于管理堆栈遍历，此堆栈遍历可确定调用堆栈中的所有调用函数是否具有访问受保护资源的所需权限。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 部分受信任的代码始终会带来安全风险。 有时，可以对其进行操作，以代表不具有访问资源权限的恶意代码执行操作。 这样，恶意代码就可以获得比允许的安全性更高的安全性访问。  
  
 公共语言运行时通过对所有调用运行堆栈遍历来帮助保护托管代码免受这些攻击。 堆栈审核要求调用堆栈中的所有代码都有权访问受保护的资源。 由于尝试攻击的代码始终在调用堆栈中的某个位置，因此它将无法超过其自己的安全权限。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Assert" />
      <MemberSignature Language="VB.NET" Value="Public Sub Assert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Assert();" />
      <MemberSignature Language="F#" Value="abstract member Assert : unit -&gt; unit" Usage="iStackWalk.Assert " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>断言调用代码可以访问当前权限对象所标识的资源，即使尚未对堆栈中的高级调用方授予访问该资源的权限。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用 <xref:System.Security.IStackWalk.Assert%2A> 将停止对调用堆栈中的调用方的权限检查。 因此，即使这些调用方没有必需的权限，它们仍可访问资源。 仅当调用 <xref:System.Security.IStackWalk.Assert%2A> 的代码为它断言的权限传递安全检查时，断言才有效。  
  
 在调用代码返回到调用方之前，或在对 <xref:System.Security.IStackWalk.Assert%2A> 的后续调用呈现以前的断言无效之前，对 <xref:System.Security.IStackWalk.Assert%2A> 的调用将有效。 此外，<xref:System.Security.CodeAccessPermission.RevertAssert%2A> 或 <xref:System.Security.CodeAccessPermission.RevertAll%2A> 会删除挂起的 <xref:System.Security.IStackWalk.Assert%2A>。  
  
 对于未授予的权限，将忽略 <xref:System.Security.IStackWalk.Assert%2A>，因为对该权限的请求将不会成功。 但是，如果调用堆栈上的代码越低，就会为该权限调用 <xref:System.Security.IStackWalk.Demand%2A>，当堆栈遍历到达尝试调用 <xref:System.Security.IStackWalk.Assert%2A>的代码时，将引发 <xref:System.Security.SecurityException>。 发生这种情况的原因是，未授予调用 <xref:System.Security.IStackWalk.Assert%2A> 的代码的权限，即使它尝试 <xref:System.Security.IStackWalk.Assert%2A> 它也是如此。  
  
> [!CAUTION]
>  由于调用 <xref:System.Security.IStackWalk.Assert%2A> 会消除调用链中的所有代码都必须被授予访问指定资源的权限的要求，因此，如果使用不当或不当，则可能会导致安全漏洞。 因此，使用它时要格外小心。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用代码没有 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />。</exception>
        <related type="Article" href="/dotnet/framework/misc/using-the-assert-method">使用 Assert 方法</related>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Demand();" />
      <MemberSignature Language="F#" Value="abstract member Demand : unit -&gt; unit" Usage="iStackWalk.Demand " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在运行时确定调用堆栈中的所有调用方是否已被授予当前权限对象所指定的权限。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法通常由安全库用于确保调用方有权访问资源。 例如，在执行调用方请求的文件操作之前，安全类库中的文件类将为必要的 <xref:System.Security.Permissions.FileIOPermission> 调用 <xref:System.Security.IStackWalk.Demand%2A>。  
  
 不检查调用此方法的代码的权限;该检查从该代码的直接调用方开始，并沿堆栈向上进行。 仅当未引发 <xref:System.Security.SecurityException> 时，<xref:System.Security.IStackWalk.Demand%2A> 才会成功。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用堆栈中处于较高位置的调用方不具有当前权限对象所指定的权限。  
  
- 或 - 
调用堆栈中的调用方已经对当前权限对象调用了 <see cref="M:System.Security.IStackWalk.Deny" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Deny" />
      <MemberSignature Language="VB.NET" Value="Public Sub Deny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Deny();" />
      <MemberSignature Language="F#" Value="abstract member Deny : unit -&gt; unit" Usage="iStackWalk.Deny " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将导致通过调用代码传递的当前对象的每个 <see cref="M:System.Security.IStackWalk.Demand" /> 失败。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法阻止调用堆栈中较高位置的调用方通过调用此方法的代码访问受保护的资源，即使这些调用方已被授予访问该方法的权限。 调用堆栈通常表示为向下增长，因此调用堆栈中较高位置的方法调用堆栈中较低的调用方法。  
  
 <xref:System.Security.IStackWalk.Deny%2A> 可以限制程序员的责任，或帮助防止意外的安全漏洞，因为这样有助于防止调用 <xref:System.Security.IStackWalk.Deny%2A> 的方法访问由拒绝的权限保护的资源。 如果方法对权限调用 <xref:System.Security.IStackWalk.Deny%2A>，并且调用堆栈中的调用方调用了该权限的 <xref:System.Security.IStackWalk.Demand%2A>，则该安全检查在到达 <xref:System.Security.IStackWalk.Deny%2A>时将失败。  
  
 对于未授予的权限，将忽略 <xref:System.Security.IStackWalk.Deny%2A>，因为对该权限的请求将不会成功。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>不能重写此方法。</para></block>
      </Docs>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub PermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PermitOnly();" />
      <MemberSignature Language="F#" Value="abstract member PermitOnly : unit -&gt; unit" Usage="iStackWalk.PermitOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>导致所有对象的每个 <see cref="M:System.Security.IStackWalk.Demand" />（除了通过调用代码的当前一个）失败，即使调用堆栈中较高级别的代码已被授予访问其他资源的权限。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.IStackWalk.PermitOnly%2A> 类似于 <xref:System.Security.IStackWalk.Deny%2A>，因为在这两个情况下，堆栈遍历将会失败。 不同之处在于 <xref:System.Security.IStackWalk.Deny%2A> 指定将导致堆栈遍历失败的权限，但 <xref:System.Security.IStackWalk.PermitOnly%2A> 指定不会导致堆栈遍历失败的唯一权限。 调用此方法以确保你的代码只能用于访问指定的资源。  
  
 对于未授予的权限，将忽略 <xref:System.Security.IStackWalk.PermitOnly%2A>，因为对该权限的请求将不会成功。 但是，如果调用堆栈上的代码越小，稍后将对该权限调用 <xref:System.Security.IStackWalk.Demand%2A>，当堆栈遍历到达尝试调用 <xref:System.Security.IStackWalk.PermitOnly%2A>的代码时，将引发 <xref:System.Security.SecurityException>。 这是因为未授予调用 <xref:System.Security.IStackWalk.PermitOnly%2A> 的代码的权限，即使该代码为该权限调用了 <xref:System.Security.IStackWalk.PermitOnly%2A>。 调用堆栈通常表示为向下增长，因此调用堆栈中较高位置的方法调用堆栈中较低的调用方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
