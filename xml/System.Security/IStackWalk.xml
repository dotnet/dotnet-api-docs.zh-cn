<Type Name="IStackWalk" FullName="System.Security.IStackWalk">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3467eb5bddd9c43943d4069eeb6745b49d719ec2" /><Meta Name="ms.sourcegitcommit" Value="a8ca33e500a87229bed50d12e09b1347df519648" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="10/09/2020" /><Meta Name="ms.locfileid" Value="91902723" /></Metadata><TypeSignature Language="C#" Value="public interface IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IStackWalk" />
  <TypeSignature Language="DocId" Value="T:System.Security.IStackWalk" />
  <TypeSignature Language="VB.NET" Value="Public Interface IStackWalk" />
  <TypeSignature Language="C++ CLI" Value="public interface class IStackWalk" />
  <TypeSignature Language="F#" Value="type IStackWalk = interface" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System.Security.Permissions" FromVersion="4.0.2.0" To="System.Runtime.Extensions" ToVersion="4.2.1.0" FrameworkAlternate="dotnet-plat-ext-3.0;netcore-3.0" />
    <TypeForwarding From="System.Security.Permissions" FromVersion="4.0.3.0" To="System.Runtime.Extensions" ToVersion="4.2.2.0" FrameworkAlternate="dotnet-plat-ext-3.1" />
    <TypeForwarding From="System.Security.Permissions" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0" />
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Runtime.Extensions" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Security.Permissions" FromVersion="4.0.3.0" To="System.Runtime.Extensions" ToVersion="4.2.1.0" FrameworkAlternate="netcore-3.1" />
  </TypeForwardingChain>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0">
      <AttributeName Language="C#">[System.Obsolete("Code Access Security is not supported or honored by the runtime.", DiagnosticId="SYSLIB0003", UrlFormat="https://aka.ms/dotnet-warnings/{0}")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Obsolete("Code Access Security is not supported or honored by the runtime.", DiagnosticId="SYSLIB0003", UrlFormat="https://aka.ms/dotnet-warnings/{0}")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="fcfc8-101">用于管理堆栈遍历，此堆栈遍历可确定调用堆栈中的所有调用函数是否具有访问受保护资源的所需权限。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-101">Manages the stack walk that determines whether all callers in the call stack have the required permissions to access a protected resource.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fcfc8-102">部分受信任的代码始终会带来安全风险。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-102">Partially trusted code always presents a security risk.</span></span> <span data-ttu-id="fcfc8-103">有时，可以对其进行操作，以代表不具有访问资源权限的恶意代码执行操作。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-103">It can sometimes be manipulated to perform actions on behalf of malicious code that does not have permission to access a resource.</span></span> <span data-ttu-id="fcfc8-104">这样，恶意代码就可以获得比允许的安全性更高的安全性访问。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-104">In this way, malicious code can achieve higher security access than it should be allowed.</span></span>  
  
 <span data-ttu-id="fcfc8-105">公共语言运行时通过对所有调用运行堆栈遍历来帮助保护托管代码免受这些攻击。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-105">The common language runtime helps protect managed code from these attacks by running a stack walk on all calls.</span></span> <span data-ttu-id="fcfc8-106">堆栈审核要求调用堆栈中的所有代码都有权访问受保护的资源。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-106">The stack walk requires that all code in the call stack has permission to access a protected resource.</span></span> <span data-ttu-id="fcfc8-107">由于尝试攻击的代码始终在调用堆栈中的某个位置，因此它将无法超过其自己的安全权限。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-107">Because the code attempting the attack will always be somewhere in the call stack, it will be unable to exceed its own security permissions.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Assert" />
      <MemberSignature Language="VB.NET" Value="Public Sub Assert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Assert();" />
      <MemberSignature Language="F#" Value="abstract member Assert : unit -&gt; unit" Usage="iStackWalk.Assert " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fcfc8-108">断言调用代码可以访问当前权限对象所标识的资源，即使尚未对堆栈中的高级调用方授予访问该资源的权限。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-108">Asserts that the calling code can access the resource identified by the current permission object, even if callers higher in the stack have not been granted permission to access the resource.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fcfc8-109">调用 <xref:System.Security.IStackWalk.Assert%2A> 将停止对调用堆栈中的调用方的权限检查。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-109">Calling <xref:System.Security.IStackWalk.Assert%2A> stops the permission check on callers higher in the call stack.</span></span> <span data-ttu-id="fcfc8-110">因此，即使这些调用方没有必需的权限，它们仍可访问资源。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-110">Therefore, even if these callers do not have the requisite permissions, they can still access resources.</span></span> <span data-ttu-id="fcfc8-111">仅当调用的代码 <xref:System.Security.IStackWalk.Assert%2A> 为其断言的权限传递安全检查时，断言才有效。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-111">An assertion is effective only if the code that calls <xref:System.Security.IStackWalk.Assert%2A> passes the security check for the permission that it is asserting.</span></span>  
  
 <span data-ttu-id="fcfc8-112">在 <xref:System.Security.IStackWalk.Assert%2A> 调用代码返回到调用方的调用方之前，或在随后调用以 <xref:System.Security.IStackWalk.Assert%2A> 呈现上一个断言失效之前，对的调用是有效的。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-112">A call to <xref:System.Security.IStackWalk.Assert%2A> is effective until the calling code returns to its caller or until a subsequent call to <xref:System.Security.IStackWalk.Assert%2A> renders the previous assertion ineffective.</span></span> <span data-ttu-id="fcfc8-113">另外， <xref:System.Security.CodeAccessPermission.RevertAssert%2A> 或 <xref:System.Security.CodeAccessPermission.RevertAll%2A> 删除挂起的 <xref:System.Security.IStackWalk.Assert%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-113">Also, <xref:System.Security.CodeAccessPermission.RevertAssert%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> removes a pending <xref:System.Security.IStackWalk.Assert%2A>.</span></span>  
  
 <span data-ttu-id="fcfc8-114"><xref:System.Security.IStackWalk.Assert%2A> 对于未授予的权限，将忽略，因为对该权限的请求将不会成功。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-114"><xref:System.Security.IStackWalk.Assert%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span> <span data-ttu-id="fcfc8-115">但是，如果调用堆栈上的代码越低就 <xref:System.Security.IStackWalk.Demand%2A> 会调用该权限，则 <xref:System.Security.SecurityException> 当堆栈遍历到达尝试调用的代码时，将引发 <xref:System.Security.IStackWalk.Assert%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-115">However, if code lower on the call stack calls <xref:System.Security.IStackWalk.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call <xref:System.Security.IStackWalk.Assert%2A>.</span></span> <span data-ttu-id="fcfc8-116">发生这种情况是因为调用的代码 <xref:System.Security.IStackWalk.Assert%2A> 未被授予权限，即使它尝试了该权限 <xref:System.Security.IStackWalk.Assert%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-116">This happens because the code that called <xref:System.Security.IStackWalk.Assert%2A> has not been granted the permission, even though it tried to <xref:System.Security.IStackWalk.Assert%2A> it.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="fcfc8-117">因为调用 <xref:System.Security.IStackWalk.Assert%2A> 消除了调用链中的所有代码都必须被授予访问指定资源的权限的要求，所以如果使用不当或不当，则可能会打开安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-117">Because calling <xref:System.Security.IStackWalk.Assert%2A> removes the requirement that all code in the call chain must be granted permission to access the specified resource, it can open up security vulnerabilities if used incorrectly or inappropriately.</span></span> <span data-ttu-id="fcfc8-118">因此，使用它时要格外小心。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-118">Therefore, it should be used with great caution.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="fcfc8-119">调用代码没有 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-119">The calling code does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</span></span></exception>
        <related type="Article" href="/dotnet/framework/misc/using-the-assert-method"><span data-ttu-id="fcfc8-120">使用 Assert 方法</span><span class="sxs-lookup"><span data-stu-id="fcfc8-120">Using the Assert Method</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Demand();" />
      <MemberSignature Language="F#" Value="abstract member Demand : unit -&gt; unit" Usage="iStackWalk.Demand " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fcfc8-121">在运行时确定调用堆栈中的所有调用方是否已被授予当前权限对象所指定的权限。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-121">Determines at run time whether all callers in the call stack have been granted the permission specified by the current permission object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fcfc8-122">此方法通常由安全库用于确保调用方有权访问资源。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-122">This method is typically used by secure libraries to ensure that callers have permission to access a resource.</span></span> <span data-ttu-id="fcfc8-123">例如，在 <xref:System.Security.IStackWalk.Demand%2A> <xref:System.Security.Permissions.FileIOPermission> 执行调用方请求的文件操作之前，安全类库中的文件类会调用所需的。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-123">For example, a file class in a secure class library calls <xref:System.Security.IStackWalk.Demand%2A> for the necessary <xref:System.Security.Permissions.FileIOPermission> before performing a file operation requested by the caller.</span></span>  
  
 <span data-ttu-id="fcfc8-124">不检查调用此方法的代码的权限;该检查从该代码的直接调用方开始，并沿堆栈向上进行。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-124">The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack.</span></span> <span data-ttu-id="fcfc8-125"><xref:System.Security.IStackWalk.Demand%2A> 仅当未 <xref:System.Security.SecurityException> 引发时才成功。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-125"><xref:System.Security.IStackWalk.Demand%2A> succeeds only if no <xref:System.Security.SecurityException> is raised.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="fcfc8-126">调用堆栈中处于较高位置的调用方不具有当前权限对象所指定的权限。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-126">A caller higher in the call stack does not have the permission specified by the current permission object.</span></span>  
  
<span data-ttu-id="fcfc8-127">- 或 -</span><span class="sxs-lookup"><span data-stu-id="fcfc8-127">-or-</span></span> 
<span data-ttu-id="fcfc8-128">调用堆栈中的调用方已经对当前权限对象调用了 <see cref="M:System.Security.IStackWalk.Deny" />。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-128">A caller in the call stack has called <see cref="M:System.Security.IStackWalk.Deny" /> on the current permission object.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Deny" />
      <MemberSignature Language="VB.NET" Value="Public Sub Deny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Deny();" />
      <MemberSignature Language="F#" Value="abstract member Deny : unit -&gt; unit" Usage="iStackWalk.Deny " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fcfc8-129">将导致通过调用代码传递的当前对象的每个 <see cref="M:System.Security.IStackWalk.Demand" /> 失败。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-129">Causes every <see cref="M:System.Security.IStackWalk.Demand" /> for the current object that passes through the calling code to fail.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fcfc8-130">此方法阻止调用堆栈中较高位置的调用方通过调用此方法的代码访问受保护的资源，即使这些调用方已被授予访问该方法的权限。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-130">This method prevents callers higher in the call stack from accessing the protected resource through the code that calls this method, even if those callers have been granted permission to access it.</span></span> <span data-ttu-id="fcfc8-131">调用堆栈通常表示为向下增长，因此调用堆栈中较高位置的方法调用堆栈中较低的调用方法。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-131">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 <span data-ttu-id="fcfc8-132"><xref:System.Security.IStackWalk.Deny%2A> 可以限制程序员的责任，或帮助防止意外的安全漏洞，因为这样有助于防止调用的方法 <xref:System.Security.IStackWalk.Deny%2A> 访问由拒绝的权限保护的资源。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-132"><xref:System.Security.IStackWalk.Deny%2A> can limit the liability of the programmer or help prevent accidental security vulnerabilities because it helps prevent the method that calls <xref:System.Security.IStackWalk.Deny%2A> from being used to access the resource protected by the denied permission.</span></span> <span data-ttu-id="fcfc8-133">如果方法对 <xref:System.Security.IStackWalk.Deny%2A> 权限进行调用，并且 <xref:System.Security.IStackWalk.Demand%2A> 调用堆栈中的调用方调用了某个权限，则该安全检查到达时将失败 <xref:System.Security.IStackWalk.Deny%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-133">If a method calls <xref:System.Security.IStackWalk.Deny%2A> on a permission, and if a <xref:System.Security.IStackWalk.Demand%2A> for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the <xref:System.Security.IStackWalk.Deny%2A>.</span></span>  
  
 <span data-ttu-id="fcfc8-134"><xref:System.Security.IStackWalk.Deny%2A> 对于未授予的权限，将忽略，因为对该权限的请求将不会成功。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-134"><xref:System.Security.IStackWalk.Deny%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="fcfc8-135">不能重写此方法。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-135">You cannot override this method.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub PermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PermitOnly();" />
      <MemberSignature Language="F#" Value="abstract member PermitOnly : unit -&gt; unit" Usage="iStackWalk.PermitOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fcfc8-136">导致所有对象的每个 <see cref="M:System.Security.IStackWalk.Demand" />（除了通过调用代码的当前一个）失败，即使调用堆栈中较高级别的代码已被授予访问其他资源的权限。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-136">Causes every <see cref="M:System.Security.IStackWalk.Demand" /> for all objects except the current one that passes through the calling code to fail, even if code higher in the call stack has been granted permission to access other resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fcfc8-137"><xref:System.Security.IStackWalk.PermitOnly%2A> 类似于 <xref:System.Security.IStackWalk.Deny%2A> ，在这两个情况下，堆栈遍历将会失败，否则将会成功。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-137"><xref:System.Security.IStackWalk.PermitOnly%2A> is similar to <xref:System.Security.IStackWalk.Deny%2A>, in that both cause stack walks to fail when they would otherwise succeed.</span></span> <span data-ttu-id="fcfc8-138">不同之处在于 <xref:System.Security.IStackWalk.Deny%2A> 指定将导致堆栈遍历失败的权限，但 <xref:System.Security.IStackWalk.PermitOnly%2A> 指定不会导致堆栈遍历失败的唯一权限。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-138">The difference is that <xref:System.Security.IStackWalk.Deny%2A> specifies permissions that will cause the stack walk to fail, but <xref:System.Security.IStackWalk.PermitOnly%2A> specifies the only permissions that do not cause the stack walk to fail.</span></span> <span data-ttu-id="fcfc8-139">调用此方法以确保你的代码只能用于访问指定的资源。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-139">Call this method to ensure that your code can be used to access only the specified resources.</span></span>  
  
 <span data-ttu-id="fcfc8-140"><xref:System.Security.IStackWalk.PermitOnly%2A> 对于未授予的权限，将忽略，因为对该权限的请求将不会成功。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-140"><xref:System.Security.IStackWalk.PermitOnly%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span> <span data-ttu-id="fcfc8-141">但是，如果调用堆栈上较低的代码以后调用 <xref:System.Security.IStackWalk.Demand%2A> 了该权限，则 <xref:System.Security.SecurityException> 当堆栈遍历到达尝试调用的代码时，将引发 <xref:System.Security.IStackWalk.PermitOnly%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-141">However, if code lower on the call stack later calls <xref:System.Security.IStackWalk.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call <xref:System.Security.IStackWalk.PermitOnly%2A>.</span></span> <span data-ttu-id="fcfc8-142">这是因为调用的代码 <xref:System.Security.IStackWalk.PermitOnly%2A> 没有获得权限，即使它是 <xref:System.Security.IStackWalk.PermitOnly%2A> 为该权限调用的。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-142">This is because the code that called <xref:System.Security.IStackWalk.PermitOnly%2A> has not been granted the permission, even though it called <xref:System.Security.IStackWalk.PermitOnly%2A> for that permission.</span></span> <span data-ttu-id="fcfc8-143">调用堆栈通常表示为向下增长，因此调用堆栈中较高位置的方法调用堆栈中较低的调用方法。</span><span class="sxs-lookup"><span data-stu-id="fcfc8-143">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
