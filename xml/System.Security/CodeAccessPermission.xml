<Type Name="CodeAccessPermission" FullName="System.Security.CodeAccessPermission">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d2d8806fbc324968a1dfe3cc31a04013dea05df7" /><Meta Name="ms.sourcegitcommit" Value="c982ad9e10a242d90f1e631b5981570f9e5d9f34" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/10/2020" /><Meta Name="ms.locfileid" Value="89901135" /></Metadata><TypeSignature Language="C#" Value="public abstract class CodeAccessPermission : System.Security.IPermission, System.Security.IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CodeAccessPermission extends System.Object implements class System.Security.IPermission, class System.Security.ISecurityEncodable, class System.Security.IStackWalk" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="DocId" Value="T:System.Security.CodeAccessPermission" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CodeAccessPermission&#xA;Implements IPermission, IStackWalk" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeAccessPermission abstract : System::Security::IPermission, System::Security::IStackWalk" />
  <TypeSignature Language="F#" Value="type CodeAccessPermission = class&#xA;    interface IPermission&#xA;    interface ISecurityEncodable&#xA;    interface IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit CodeAccessPermission extends System.Object implements class System.Security.IPermission, class System.Security.ISecurityEncodable, class System.Security.IStackWalk" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Security.IPermission</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.ISecurityEncodable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IStackWalk</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="1965e-101">定义所有代码访问权限的基础结构。</span><span class="sxs-lookup"><span data-stu-id="1965e-101">Defines the underlying structure of all code access permissions.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1965e-102">代码访问权限使用堆栈审核来确保已为代码的所有调用方授予了权限。</span><span class="sxs-lookup"><span data-stu-id="1965e-102">Code access permissions use a stack walk to ensure that all callers of the code have been granted a permission.</span></span> <span data-ttu-id="1965e-103">如果权限对象为 `null` ，则该对象的处理方式与状态相同 <xref:System.Security.Permissions.PermissionState.None?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="1965e-103">If a permission object is `null`, it is handled the same as a permission object with the state <xref:System.Security.Permissions.PermissionState.None?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="1965e-104">调用堆栈通常表示为向下增长，因此调用堆栈中较高位置的方法调用堆栈中较低的调用方法。</span><span class="sxs-lookup"><span data-stu-id="1965e-104">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 <span data-ttu-id="1965e-105">必须向类的继承者 <xref:System.Security.CodeAccessPermission> 授予完全信任，才能作为权限扩展安全基础结构。</span><span class="sxs-lookup"><span data-stu-id="1965e-105">Inheritors of the <xref:System.Security.CodeAccessPermission> class must be granted full trust to function correctly as permissions extending the security infrastructure.</span></span> <span data-ttu-id="1965e-106">若要确定继承方是完全受信任的，请 <xref:System.Security.CodeAccessPermission> <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> 为 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence>  =  `true` 和发出 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy>  =  `true` 。</span><span class="sxs-lookup"><span data-stu-id="1965e-106">To determine that the inheritors are fully trusted, <xref:System.Security.CodeAccessPermission> issues an <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> for <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence> = `true` and <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy> = `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1965e-107">下面的代码示例演示一个派生自类的权限 <xref:System.Security.CodeAccessPermission> 。</span><span class="sxs-lookup"><span data-stu-id="1965e-107">The following code example shows a permission derived from the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#1)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#1)]
 [!code-vb[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para><span data-ttu-id="1965e-108">当从继承时 <see cref="T:System.Security.CodeAccessPermission" /> ，还必须实现 <see cref="T:System.Security.Permissions.IUnrestrictedPermission" /> 接口。</span><span class="sxs-lookup"><span data-stu-id="1965e-108">When you inherit from <see cref="T:System.Security.CodeAccessPermission" />, you must also implement the <see cref="T:System.Security.Permissions.IUnrestrictedPermission" /> interface.</span></span>  
  
<span data-ttu-id="1965e-109"><see cref="T:System.Security.CodeAccessPermission" />必须重写以下成员： <see cref="M:System.Security.CodeAccessPermission.Copy" /> 、 <see cref="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" /> 、 <see cref="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" /> 、 <see cref="M:System.Security.CodeAccessPermission.ToXml" /> 、 <see cref="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" /> 和 <see cref="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" /> 。</span><span class="sxs-lookup"><span data-stu-id="1965e-109">The following <see cref="T:System.Security.CodeAccessPermission" /> members must be overridden: <see cref="M:System.Security.CodeAccessPermission.Copy" />, <see cref="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.ToXml" />, <see cref="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" />, and <see cref="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" />.</span></span>  
  
<span data-ttu-id="1965e-110">还必须定义一个采用作为唯一的参数的构造函数 <see cref="T:System.Security.Permissions.PermissionState" /> 。</span><span class="sxs-lookup"><span data-stu-id="1965e-110">You must also define a constructor that takes a <see cref="T:System.Security.Permissions.PermissionState" /> as its only parameter.</span></span>  
  
<span data-ttu-id="1965e-111">您必须将特性应用于 <see cref="T:System.SerializableAttribute" /> 从继承的类 <see cref="T:System.Security.CodeAccessPermission" /> 。</span><span class="sxs-lookup"><span data-stu-id="1965e-111">You must apply the <see cref="T:System.SerializableAttribute" /> attribute to a class that inherits from <see cref="T:System.Security.CodeAccessPermission" />.</span></span></para></block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CodeAccessPermission ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CodeAccessPermission();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1965e-112">初始化 <see cref="T:System.Security.CodeAccessPermission" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="1965e-112">Initializes a new instance of the <see cref="T:System.Security.CodeAccessPermission" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1965e-113">每当创建派生类的实例时，都将调用此构造函数来初始化类型中的状态。</span><span class="sxs-lookup"><span data-stu-id="1965e-113">This constructor is called to initialize state in the type whenever an instance of the derived class is created.</span></span> <span data-ttu-id="1965e-114">尽管可以在派生类构造函数的构造函数声明中显式调用此构造函数，但这通常是不必要的;大多数编译器会自动为你生成调用。</span><span class="sxs-lookup"><span data-stu-id="1965e-114">Although you can explicitly call this constructor in the constructor declaration of the derived class constructor, this is not usually necessary; most compilers will automatically generate the call for you.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Assert" />
      <MemberSignature Language="VB.NET" Value="Public Sub Assert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Assert();" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Assert : unit -&gt; unit&#xA;override this.Assert : unit -&gt; unit" Usage="codeAccessPermission.Assert " FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Assert() cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Assert();" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.Assert : unit -&gt; unit" Usage="codeAccessPermission.Assert " FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">M:System.Security.IStackWalk.Assert</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName Language="C#">[System.Diagnostics.Conditional("FEATURE_MONO_CAS")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.Conditional("FEATURE_MONO_CAS")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1965e-115">声明调用代码能够通过调用此方法的代码，访问受权限请求保护的资源，即使未对堆栈中处于较高位置的调用方授予访问该资源的权限。</span><span class="sxs-lookup"><span data-stu-id="1965e-115">Declares that the calling code can access the resource protected by a permission demand through the code that calls this method, even if callers higher in the stack have not been granted permission to access the resource.</span></span> <span data-ttu-id="1965e-116">使用 <see cref="M:System.Security.CodeAccessPermission.Assert" /> 会引起安全问题。</span><span class="sxs-lookup"><span data-stu-id="1965e-116">Using <see cref="M:System.Security.CodeAccessPermission.Assert" /> can create security issues.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1965e-117">调用堆栈通常表示为向下增长，因此调用堆栈中较高位置的方法调用堆栈中较低的调用方法。</span><span class="sxs-lookup"><span data-stu-id="1965e-117">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span> <span data-ttu-id="1965e-118">调用 <xref:System.Security.CodeAccessPermission.Assert%2A> 可防止调用堆栈中的堆栈遍历在调用堆栈之外的堆栈遍历超出调用此方法的代码的范围。</span><span class="sxs-lookup"><span data-stu-id="1965e-118">Calling <xref:System.Security.CodeAccessPermission.Assert%2A> prevents a stack walk originating lower in the call stack from proceeding up the call stack beyond the code that calls this method.</span></span> <span data-ttu-id="1965e-119">因此，即使调用堆栈中较高位置的调用方没有访问资源所需的权限，它们仍可以通过对所需权限调用此方法的代码来访问它。</span><span class="sxs-lookup"><span data-stu-id="1965e-119">Therefore, even if callers higher on the call stack do not have the requisite permissions to access a resource, they can still access it through the code that calls this method on the necessary permission.</span></span> <span data-ttu-id="1965e-120">仅当调用的代码 <xref:System.Security.CodeAccessPermission.Assert%2A> 为其断言的权限传递安全检查时，断言才有效。</span><span class="sxs-lookup"><span data-stu-id="1965e-120">An assertion is effective only if the code that calls <xref:System.Security.CodeAccessPermission.Assert%2A> passes the security check for the permission that it is asserting.</span></span>  
  
 <span data-ttu-id="1965e-121">在 <xref:System.Security.CodeAccessPermission.Assert%2A> 调用代码返回到其调用方之前，对的调用将有效。</span><span class="sxs-lookup"><span data-stu-id="1965e-121">The call to <xref:System.Security.CodeAccessPermission.Assert%2A> is effective until the calling code returns to its caller.</span></span> <span data-ttu-id="1965e-122">帧上只能有一个 <xref:System.Security.CodeAccessPermission.Assert%2A> 处于活动状态。</span><span class="sxs-lookup"><span data-stu-id="1965e-122">Only one <xref:System.Security.CodeAccessPermission.Assert%2A> can be active on a frame.</span></span> <span data-ttu-id="1965e-123"><xref:System.Security.CodeAccessPermission.Assert%2A>如果在帧上存在活动时尝试调用，则会 <xref:System.Security.CodeAccessPermission.Assert%2A> 生成一个 <xref:System.Security.SecurityException> 。</span><span class="sxs-lookup"><span data-stu-id="1965e-123">An attempt to call <xref:System.Security.CodeAccessPermission.Assert%2A> when an active <xref:System.Security.CodeAccessPermission.Assert%2A> exists on the frame results in a <xref:System.Security.SecurityException>.</span></span> <span data-ttu-id="1965e-124">调用 <xref:System.Security.CodeAccessPermission.RevertAssert%2A> 或 <xref:System.Security.CodeAccessPermission.RevertAll%2A> 删除活动 <xref:System.Security.CodeAccessPermission.Assert%2A> 。</span><span class="sxs-lookup"><span data-stu-id="1965e-124">Call <xref:System.Security.CodeAccessPermission.RevertAssert%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> to remove an active <xref:System.Security.CodeAccessPermission.Assert%2A>.</span></span>  
  
 <span data-ttu-id="1965e-125"><xref:System.Security.CodeAccessPermission.Assert%2A> 对于未授予的权限，将忽略，因为对该权限的请求将不会成功。</span><span class="sxs-lookup"><span data-stu-id="1965e-125"><xref:System.Security.CodeAccessPermission.Assert%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span> <span data-ttu-id="1965e-126">但是，如果调用堆栈上的代码越低就 <xref:System.Security.CodeAccessPermission.Demand%2A> 会调用该权限，则 <xref:System.Security.SecurityException> 当堆栈遍历到达尝试调用的代码时，将引发 <xref:System.Security.CodeAccessPermission.Assert%2A> 。</span><span class="sxs-lookup"><span data-stu-id="1965e-126">However, if code lower on the call stack calls <xref:System.Security.CodeAccessPermission.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call <xref:System.Security.CodeAccessPermission.Assert%2A>.</span></span> <span data-ttu-id="1965e-127">发生这种情况是因为调用的代码 <xref:System.Security.CodeAccessPermission.Assert%2A> 未被授予权限，即使它尝试了该权限 <xref:System.Security.CodeAccessPermission.Assert%2A> 。</span><span class="sxs-lookup"><span data-stu-id="1965e-127">This happens because the code that called <xref:System.Security.CodeAccessPermission.Assert%2A> has not been granted the permission, even though it tried to <xref:System.Security.CodeAccessPermission.Assert%2A> it.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="1965e-128">因为调用 <xref:System.Security.CodeAccessPermission.Assert%2A> 消除了调用链中的所有代码都必须被授予访问指定资源的权限的要求，所以如果使用不当或不当，则会导致安全问题。</span><span class="sxs-lookup"><span data-stu-id="1965e-128">Because calling <xref:System.Security.CodeAccessPermission.Assert%2A> removes the requirement that all code in the call chain must be granted permission to access the specified resource, it can open up security issues if used incorrectly or inappropriately.</span></span> <span data-ttu-id="1965e-129">因此，使用它时要格外小心。</span><span class="sxs-lookup"><span data-stu-id="1965e-129">Therefore, it should be used with great caution.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="1965e-130">调用代码没有 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />。</span><span class="sxs-lookup"><span data-stu-id="1965e-130">The calling code does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</span></span>  
  
<span data-ttu-id="1965e-131">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1965e-131">-or-</span></span> 
<span data-ttu-id="1965e-132">已存在一个用于当前帧的活动的 <see cref="M:System.Security.CodeAccessPermission.Assert" />。</span><span class="sxs-lookup"><span data-stu-id="1965e-132">There is already an active <see cref="M:System.Security.CodeAccessPermission.Assert" /> for the current frame.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="1965e-133">不能重写此方法。</span><span class="sxs-lookup"><span data-stu-id="1965e-133">You cannot override this method.</span></span></para></block>
        <related type="Article" href="/dotnet/framework/misc/using-the-assert-method"><span data-ttu-id="1965e-134">使用 Assert 方法</span><span class="sxs-lookup"><span data-stu-id="1965e-134">Using the Assert Method</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public abstract System.Security.IPermission Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Copy" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Copy () As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::IPermission ^ Copy();" />
      <MemberSignature Language="F#" Value="abstract member Copy : unit -&gt; System.Security.IPermission" Usage="codeAccessPermission.Copy " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Copy</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1965e-135">由派生类实现时，创建并返回当前权限对象的相同副本。</span><span class="sxs-lookup"><span data-stu-id="1965e-135">When implemented by a derived class, creates and returns an identical copy of the current permission object.</span></span></summary>
        <returns><span data-ttu-id="1965e-136">当前权限对象的副本。</span><span class="sxs-lookup"><span data-stu-id="1965e-136">A copy of the current permission object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1965e-137">权限对象的副本表示与原始权限对象相同的资源访问权限。</span><span class="sxs-lookup"><span data-stu-id="1965e-137">A copy of a permission object represents the same access to resources as the original permission object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1965e-138">下面的代码示例演示如何重写 <xref:System.Security.CodeAccessPermission.Copy%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1965e-138">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.Copy%2A> method.</span></span> <span data-ttu-id="1965e-139">此代码示例是为类提供的更大示例的一部分 <xref:System.Security.CodeAccessPermission> 。</span><span class="sxs-lookup"><span data-stu-id="1965e-139">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#2)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#2)]
 [!code-vb[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="1965e-140">必须在派生类中重写此方法。</span><span class="sxs-lookup"><span data-stu-id="1965e-140">You must override this method in a derived class.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Demand();" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Demand : unit -&gt; unit&#xA;override this.Demand : unit -&gt; unit" Usage="codeAccessPermission.Demand " FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Demand() cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Demand();" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.Demand : unit -&gt; unit" Usage="codeAccessPermission.Demand " FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">M:System.Security.IPermission.Demand</InterfaceMember>
        <InterfaceMember FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">M:System.Security.IStackWalk.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName Language="C#">[System.Diagnostics.Conditional("FEATURE_MONO_CAS")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.Conditional("FEATURE_MONO_CAS")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1965e-141">如果未对调用堆栈中处于较高位置的所有调用方授予当前实例所指定的权限，则在运行时强制 <see cref="T:System.Security.SecurityException" />。</span><span class="sxs-lookup"><span data-stu-id="1965e-141">Forces a <see cref="T:System.Security.SecurityException" /> at run time if all callers higher in the call stack have not been granted the permission specified by the current instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1965e-142">此方法通常由安全库用于确保调用方有权访问资源。</span><span class="sxs-lookup"><span data-stu-id="1965e-142">This method is typically used by secure libraries to ensure that callers have permission to access a resource.</span></span> <span data-ttu-id="1965e-143">例如，在 <xref:System.Security.CodeAccessPermission.Demand%2A> <xref:System.Security.Permissions.FileIOPermission> 执行调用方请求的文件操作之前，安全类库中的文件类会调用所需的。</span><span class="sxs-lookup"><span data-stu-id="1965e-143">For example, a file class in a secure class library calls <xref:System.Security.CodeAccessPermission.Demand%2A> for the necessary <xref:System.Security.Permissions.FileIOPermission> before performing a file operation requested by the caller.</span></span>  
  
 <span data-ttu-id="1965e-144">不检查调用此方法的代码的权限;该检查从该代码的直接调用方开始，并沿堆栈向上进行。</span><span class="sxs-lookup"><span data-stu-id="1965e-144">The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack.</span></span> <span data-ttu-id="1965e-145">调用堆栈通常表示为向下增长，因此调用堆栈中较高位置的方法调用堆栈中较低的调用方法。</span><span class="sxs-lookup"><span data-stu-id="1965e-145">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span> <span data-ttu-id="1965e-146"><xref:System.Security.CodeAccessPermission.Demand%2A> 仅当未 <xref:System.Security.SecurityException> 引发时才成功。</span><span class="sxs-lookup"><span data-stu-id="1965e-146"><xref:System.Security.CodeAccessPermission.Demand%2A> succeeds only if no <xref:System.Security.SecurityException> is raised.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="1965e-147">调用堆栈中处于较高位置的调用方不具有当前实例所指定的权限。</span><span class="sxs-lookup"><span data-stu-id="1965e-147">A caller higher in the call stack does not have the permission specified by the current instance.</span></span>  
  
<span data-ttu-id="1965e-148">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1965e-148">-or-</span></span> 
<span data-ttu-id="1965e-149">调用堆栈中处于较高位置的调用方已经对当前权限对象调用了 <see cref="M:System.Security.CodeAccessPermission.Deny" />。</span><span class="sxs-lookup"><span data-stu-id="1965e-149">A caller higher in the call stack has called <see cref="M:System.Security.CodeAccessPermission.Deny" /> on the current permission object.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="1965e-150">不能重写此方法。</span><span class="sxs-lookup"><span data-stu-id="1965e-150">You cannot override this method.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Deny" />
      <MemberSignature Language="VB.NET" Value="Public Sub Deny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Deny();" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Deny : unit -&gt; unit&#xA;override this.Deny : unit -&gt; unit" Usage="codeAccessPermission.Deny " FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Deny() cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Deny();" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.Deny : unit -&gt; unit" Usage="codeAccessPermission.Deny " FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">M:System.Security.IStackWalk.Deny</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1">
          <AttributeName Language="C#">[System.Obsolete]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Obsolete("Deny is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Deny is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName Language="C#">[System.Diagnostics.Conditional("FEATURE_MONO_CAS")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.Conditional("FEATURE_MONO_CAS")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1965e-151">防止处于调用堆栈较高位置的调用函数使用可以调用此方法来访问当前实例指定资源的代码。</span><span class="sxs-lookup"><span data-stu-id="1965e-151">Prevents callers higher in the call stack from using the code that calls this method to access the resource specified by the current instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="1965e-152">此 <xref:System.Security.CodeAccessPermission.Deny%2A> 方法应仅用于防止完全受信任的代码意外访问资源。</span><span class="sxs-lookup"><span data-stu-id="1965e-152">The <xref:System.Security.CodeAccessPermission.Deny%2A> method should be used only to protect resources from accidental access by fully trusted code.</span></span> <span data-ttu-id="1965e-153">不应使用它来防止不受信任的代码有意滥用资源。</span><span class="sxs-lookup"><span data-stu-id="1965e-153">It should not be used to protect resources from intentional misuse by untrusted code.</span></span> <span data-ttu-id="1965e-154">例如，如果方法发出权限的，然后 `A` <xref:System.Security.CodeAccessPermission.Deny%2A> 调用方法 `B` ，则方法 `B` 可以通过发出来 overtly 重写 <xref:System.Security.CodeAccessPermission.Deny%2A> <xref:System.Security.CodeAccessPermission.Assert%2A> 。</span><span class="sxs-lookup"><span data-stu-id="1965e-154">For example, if method `A` issues a <xref:System.Security.CodeAccessPermission.Deny%2A> for a permission and then calls method `B`, method `B` can overtly override the <xref:System.Security.CodeAccessPermission.Deny%2A> by issuing an <xref:System.Security.CodeAccessPermission.Assert%2A>.</span></span> <span data-ttu-id="1965e-155">调用的方法在堆栈中始终更高。</span><span class="sxs-lookup"><span data-stu-id="1965e-155">The called method is always higher in the stack.</span></span> <span data-ttu-id="1965e-156">因此，如果方法 `B` 尝试访问受保护的资源，则安全系统会开始检查其权限，因为方法 `B` 是直接调用方，然后向下遍历堆栈以确认 <xref:System.Security.CodeAccessPermission.Deny%2A> <xref:System.Security.CodeAccessPermission.PermitOnly%2A> 堆栈中没有或更低。</span><span class="sxs-lookup"><span data-stu-id="1965e-156">Therefore, if method `B` tries to access a protected resource, the security system begins checking for permissions with it because method `B` is the immediate caller, and then walks down the stack to confirm that there is no <xref:System.Security.CodeAccessPermission.Deny%2A> or <xref:System.Security.CodeAccessPermission.PermitOnly%2A> lower in the stack.</span></span> <span data-ttu-id="1965e-157">`B`尝试访问资源的方法可以使用方法立即停止堆栈遍历 <xref:System.Security.CodeAccessPermission.Assert%2A> 。</span><span class="sxs-lookup"><span data-stu-id="1965e-157">Method `B`, which is trying to access the resource, can stop the stack walk immediately by using the <xref:System.Security.CodeAccessPermission.Assert%2A> method.</span></span> <span data-ttu-id="1965e-158">在这种情况下， <xref:System.Security.CodeAccessPermission.Deny%2A> `A` 从不会发现 (调用方法) 放置在堆栈上。</span><span class="sxs-lookup"><span data-stu-id="1965e-158">In that case, the <xref:System.Security.CodeAccessPermission.Deny%2A> placed on the stack by method `A` (the calling method) is never discovered.</span></span>  
  
 <span data-ttu-id="1965e-159">此方法阻止调用堆栈中较高位置的调用方通过调用此方法的代码访问受保护的资源，即使这些调用方已被授予访问该方法的权限。</span><span class="sxs-lookup"><span data-stu-id="1965e-159">This method prevents callers higher in the call stack from accessing the protected resource through the code that calls this method, even if those callers have been granted permission to access it.</span></span> <span data-ttu-id="1965e-160">调用堆栈通常表示为向下增长，因此调用堆栈中较高位置的方法调用堆栈中较低的调用方法。</span><span class="sxs-lookup"><span data-stu-id="1965e-160">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 <span data-ttu-id="1965e-161"><xref:System.Security.CodeAccessPermission.Deny%2A> 可以限制程序员的责任，或帮助防止意外的安全问题，因为它有助于防止调用的方法 <xref:System.Security.CodeAccessPermission.Deny%2A> 访问由拒绝的权限保护的资源。</span><span class="sxs-lookup"><span data-stu-id="1965e-161"><xref:System.Security.CodeAccessPermission.Deny%2A> can limit the liability of the programmer or help prevent accidental security issues because it helps prevent the method that calls <xref:System.Security.CodeAccessPermission.Deny%2A> from being used to access the resource protected by the denied permission.</span></span> <span data-ttu-id="1965e-162">如果方法对 <xref:System.Security.CodeAccessPermission.Deny%2A> 权限进行调用，并且 <xref:System.Security.CodeAccessPermission.Demand%2A> 调用堆栈中的调用方调用了某个权限，则该安全检查到达时将失败 <xref:System.Security.CodeAccessPermission.Deny%2A> 。</span><span class="sxs-lookup"><span data-stu-id="1965e-162">If a method calls <xref:System.Security.CodeAccessPermission.Deny%2A> on a permission, and if a <xref:System.Security.CodeAccessPermission.Demand%2A> for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the <xref:System.Security.CodeAccessPermission.Deny%2A>.</span></span>  
  
 <span data-ttu-id="1965e-163">在 <xref:System.Security.CodeAccessPermission.Deny%2A> 调用代码返回到其调用方之前，对的调用将有效。</span><span class="sxs-lookup"><span data-stu-id="1965e-163">The call to <xref:System.Security.CodeAccessPermission.Deny%2A> is effective until the calling code returns to its caller.</span></span> <span data-ttu-id="1965e-164">帧上只能有一个 <xref:System.Security.CodeAccessPermission.Deny%2A> 处于活动状态。</span><span class="sxs-lookup"><span data-stu-id="1965e-164">Only one <xref:System.Security.CodeAccessPermission.Deny%2A> can be active on a frame.</span></span> <span data-ttu-id="1965e-165"><xref:System.Security.CodeAccessPermission.Deny%2A>如果在帧上存在活动时尝试调用，则会 <xref:System.Security.CodeAccessPermission.Deny%2A> 生成一个 <xref:System.Security.SecurityException> 。</span><span class="sxs-lookup"><span data-stu-id="1965e-165">An attempt to call <xref:System.Security.CodeAccessPermission.Deny%2A> when an active <xref:System.Security.CodeAccessPermission.Deny%2A> exists on the frame results in a <xref:System.Security.SecurityException>.</span></span> <span data-ttu-id="1965e-166">调用 <xref:System.Security.CodeAccessPermission.RevertDeny%2A> 或 <xref:System.Security.CodeAccessPermission.RevertAll%2A> 删除活动 <xref:System.Security.CodeAccessPermission.Deny%2A> 。</span><span class="sxs-lookup"><span data-stu-id="1965e-166">Call <xref:System.Security.CodeAccessPermission.RevertDeny%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> to remove an active <xref:System.Security.CodeAccessPermission.Deny%2A>.</span></span> <span data-ttu-id="1965e-167"><xref:System.Security.CodeAccessPermission.Deny%2A> 对于未授予的权限，将忽略，因为对该权限的请求将不会成功。</span><span class="sxs-lookup"><span data-stu-id="1965e-167"><xref:System.Security.CodeAccessPermission.Deny%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="1965e-168">已存在一个用于当前帧的活动的 <see cref="M:System.Security.CodeAccessPermission.Deny" />。</span><span class="sxs-lookup"><span data-stu-id="1965e-168">There is already an active <see cref="M:System.Security.CodeAccessPermission.Deny" /> for the current frame.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="1965e-169">不能重写此方法。</span><span class="sxs-lookup"><span data-stu-id="1965e-169">You cannot override this method.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="codeAccessPermission.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="1965e-170">要与当前的 <see cref="T:System.Security.CodeAccessPermission" /> 比较的 <see cref="T:System.Security.CodeAccessPermission" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="1965e-170">The <see cref="T:System.Security.CodeAccessPermission" /> object to compare with the current <see cref="T:System.Security.CodeAccessPermission" />.</span></span></param>
        <summary><span data-ttu-id="1965e-171">确定指定的 <see cref="T:System.Security.CodeAccessPermission" /> 对象是否等于当前的 <see cref="T:System.Security.CodeAccessPermission" />。</span><span class="sxs-lookup"><span data-stu-id="1965e-171">Determines whether the specified <see cref="T:System.Security.CodeAccessPermission" /> object is equal to the current <see cref="T:System.Security.CodeAccessPermission" />.</span></span></summary>
        <returns><span data-ttu-id="1965e-172">如果指定的 <see cref="T:System.Security.CodeAccessPermission" /> 对象等于当前的 <see cref="T:System.Security.CodeAccessPermission" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1965e-172"><see langword="true" /> if the specified <see cref="T:System.Security.CodeAccessPermission" /> object is equal to the current <see cref="T:System.Security.CodeAccessPermission" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1965e-173">有关详细信息，请参阅 <xref:System.Object.Equals%2A>。</span><span class="sxs-lookup"><span data-stu-id="1965e-173">For more information, see <xref:System.Object.Equals%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromXml">
      <MemberSignature Language="C#" Value="public abstract void FromXml (System.Security.SecurityElement elem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FromXml(class System.Security.SecurityElement elem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub FromXml (elem As SecurityElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void FromXml(System::Security::SecurityElement ^ elem);" />
      <MemberSignature Language="F#" Value="abstract member FromXml : System.Security.SecurityElement -&gt; unit" Usage="codeAccessPermission.FromXml elem" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.ISecurityEncodable.FromXml(System.Security.SecurityElement)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elem" Type="System.Security.SecurityElement" />
      </Parameters>
      <Docs>
        <param name="elem"><span data-ttu-id="1965e-174">用于重新构造安全对象的 XML 编码。</span><span class="sxs-lookup"><span data-stu-id="1965e-174">The XML encoding to use to reconstruct the security object.</span></span></param>
        <summary><span data-ttu-id="1965e-175">当在派生类中替代时，用 XML 编码重新构造具有指定状态的安全对象。</span><span class="sxs-lookup"><span data-stu-id="1965e-175">When overridden in a derived class, reconstructs a security object with a specified state from an XML encoding.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1965e-176">扩展安全对象的自定义代码需要实现 <xref:System.Security.CodeAccessPermission.ToXml%2A> 和 <xref:System.Security.CodeAccessPermission.FromXml%2A> 方法，以使对象安全 encodable。</span><span class="sxs-lookup"><span data-stu-id="1965e-176">Custom code that extends security objects needs to implement the <xref:System.Security.CodeAccessPermission.ToXml%2A> and <xref:System.Security.CodeAccessPermission.FromXml%2A> methods to make the objects security-encodable.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1965e-177">下面的代码示例演示如何重写 <xref:System.Security.CodeAccessPermission.FromXml%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1965e-177">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.FromXml%2A> method.</span></span> <span data-ttu-id="1965e-178">此代码示例是为类提供的更大示例的一部分 <xref:System.Security.CodeAccessPermission> 。</span><span class="sxs-lookup"><span data-stu-id="1965e-178">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#10)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#10)]
 [!code-vb[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1965e-179"><paramref name="elem" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1965e-179">The <paramref name="elem" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1965e-180"><paramref name="elem" /> 参数不包含与当前实例类型相同的实例的 XML 编码。</span><span class="sxs-lookup"><span data-stu-id="1965e-180">The <paramref name="elem" /> parameter does not contain the XML encoding for an instance of the same type as the current instance.</span></span>  
  
<span data-ttu-id="1965e-181">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1965e-181">-or-</span></span> 
<span data-ttu-id="1965e-182">不支持 <paramref name="elem" /> 参数的版本号。</span><span class="sxs-lookup"><span data-stu-id="1965e-182">The version number of the <paramref name="elem" /> parameter is not supported.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="1965e-183">必须在派生类中重写此方法。</span><span class="sxs-lookup"><span data-stu-id="1965e-183">You must override this method in a derived class.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="codeAccessPermission.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1965e-184">获取 <see cref="T:System.Security.CodeAccessPermission" /> 对象的哈希代码，此代码适合在哈希算法和数据结构（例如哈希表）中使用。</span><span class="sxs-lookup"><span data-stu-id="1965e-184">Gets a hash code for the <see cref="T:System.Security.CodeAccessPermission" /> object that is suitable for use in hashing algorithms and data structures such as a hash table.</span></span></summary>
        <returns><span data-ttu-id="1965e-185">当前 <see cref="T:System.Security.CodeAccessPermission" /> 对象的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="1965e-185">A hash code for the current <see cref="T:System.Security.CodeAccessPermission" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1965e-186">同一权限的两个实例的哈希代码可能不同，因此，不应使用哈希代码来比较两个 <xref:System.Security.CodeAccessPermission> 对象。</span><span class="sxs-lookup"><span data-stu-id="1965e-186">The hash code for two instances of the same permission might be different, hence a hash code should not be used to compare two <xref:System.Security.CodeAccessPermission> objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public abstract System.Security.IPermission Intersect (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Intersect(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Intersect (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::IPermission ^ Intersect(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member Intersect : System.Security.IPermission -&gt; System.Security.IPermission" Usage="codeAccessPermission.Intersect target" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Intersect(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="1965e-187">要与当前权限相交的权限。</span><span class="sxs-lookup"><span data-stu-id="1965e-187">A permission to intersect with the current permission.</span></span> <span data-ttu-id="1965e-188">它必须与当前权限属于同一类型。</span><span class="sxs-lookup"><span data-stu-id="1965e-188">It must be of the same type as the current permission.</span></span></param>
        <summary><span data-ttu-id="1965e-189">通过派生类实现时，创建和返回是当前权限和指定权限的交集的权限。</span><span class="sxs-lookup"><span data-stu-id="1965e-189">When implemented by a derived class, creates and returns a permission that is the intersection of the current permission and the specified permission.</span></span></summary>
        <returns><span data-ttu-id="1965e-190">表示当前权限和指定权限的交集的一个新权限。</span><span class="sxs-lookup"><span data-stu-id="1965e-190">A new permission that represents the intersection of the current permission and the specified permission.</span></span> <span data-ttu-id="1965e-191">如果交集为空，则此新权限为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1965e-191">This new permission is <see langword="null" /> if the intersection is empty.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1965e-192">两个权限的交集是描述它们共同描述的一组操作的权限。</span><span class="sxs-lookup"><span data-stu-id="1965e-192">The intersection of two permissions is a permission that describes the set of operations they both describe in common.</span></span> <span data-ttu-id="1965e-193">只有同时传递两个原始权限的请求才会传递交集。</span><span class="sxs-lookup"><span data-stu-id="1965e-193">Only a demand that passes both original permissions will pass the intersection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1965e-194">下面的代码示例演示如何重写 <xref:System.Security.CodeAccessPermission.Intersect%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1965e-194">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.Intersect%2A> method.</span></span> <span data-ttu-id="1965e-195">此代码示例是为类提供的更大示例的一部分 <xref:System.Security.CodeAccessPermission> 。</span><span class="sxs-lookup"><span data-stu-id="1965e-195">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#5)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#5)]
 [!code-vb[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1965e-196"><paramref name="target" /> 参数不为 <see langword="null" />，并且是与当前权限不属于同一类的实例。</span><span class="sxs-lookup"><span data-stu-id="1965e-196">The <paramref name="target" /> parameter is not <see langword="null" /> and is not an instance of the same class as the current permission.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="1965e-197">必须在派生类中重写此方法。</span><span class="sxs-lookup"><span data-stu-id="1965e-197">You must override this method in a derived class.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public abstract bool IsSubsetOf (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function IsSubsetOf (target As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool IsSubsetOf(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member IsSubsetOf : System.Security.IPermission -&gt; bool" Usage="codeAccessPermission.IsSubsetOf target" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="1965e-198">将要测试子集关系的权限。</span><span class="sxs-lookup"><span data-stu-id="1965e-198">A permission that is to be tested for the subset relationship.</span></span> <span data-ttu-id="1965e-199">此权限必须与当前权限属于同一类型。</span><span class="sxs-lookup"><span data-stu-id="1965e-199">This permission must be of the same type as the current permission.</span></span></param>
        <summary><span data-ttu-id="1965e-200">通过派生类实现时，确定当前权限是否为指定权限的子集。</span><span class="sxs-lookup"><span data-stu-id="1965e-200">When implemented by a derived class, determines whether the current permission is a subset of the specified permission.</span></span></summary>
        <returns><span data-ttu-id="1965e-201">如果当前权限是指定权限的子集，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1965e-201"><see langword="true" /> if the current permission is a subset of the specified permission; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1965e-202">如果当前权限指定的一组操作完全包含在指定权限中，则当前权限是指定权限的子集。</span><span class="sxs-lookup"><span data-stu-id="1965e-202">The current permission is a subset of the specified permission if the current permission specifies a set of operations that is wholly contained by the specified permission.</span></span> <span data-ttu-id="1965e-203">例如，表示对 C:\example.txt 的访问权限的权限是表示 C：访问权限的权限的子集 \\ 。</span><span class="sxs-lookup"><span data-stu-id="1965e-203">For example, a permission that represents access to C:\example.txt is a subset of a permission that represents access to C:\\.</span></span> <span data-ttu-id="1965e-204">如果此方法返回 `true` ，则当前权限表示对受保护资源的访问权限比指定权限更多。</span><span class="sxs-lookup"><span data-stu-id="1965e-204">If this method returns `true`, the current permission represents no more access to the protected resource than does the specified permission.</span></span>  
  
 <span data-ttu-id="1965e-205">以下语句 `true` 对于方法的所有重写都是必需的 <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> 。</span><span class="sxs-lookup"><span data-stu-id="1965e-205">The following statements are required to be `true` for all overrides of the <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> method.</span></span> <span data-ttu-id="1965e-206">*X*、 *Y*和 *Z* 表示自定义代码访问权限对象，这些权限对象不是空引用， *U* 表示不受限制的代码访问权限，而 *N* 表示为的空权限 <xref:System.Security.Permissions.PermissionState> <xref:System.Security.Permissions.PermissionState.None> 。</span><span class="sxs-lookup"><span data-stu-id="1965e-206">*X*, *Y*, and *Z* represent custom code access permission objects that are not null references, *U* represents an unrestricted code access permission, and *N* represents an empty permission with a <xref:System.Security.Permissions.PermissionState> of <xref:System.Security.Permissions.PermissionState.None>.</span></span>  
  
-   <span data-ttu-id="1965e-207">*X*。IsSubsetOf (*X*) 返回 `true` 。</span><span class="sxs-lookup"><span data-stu-id="1965e-207">*X*.IsSubsetOf(*X*) returns `true`.</span></span>  
  
-   <span data-ttu-id="1965e-208">*X*。IsSubsetOf (*y*) 返回与*Y*相同的值。当且仅当*x*和*Y*表示相同权限集时，IsSubsetOf (*X*) 。</span><span class="sxs-lookup"><span data-stu-id="1965e-208">*X*.IsSubsetOf(*Y*) returns the same value as *Y*.IsSubsetOf(*X*) if and only if *X* and *Y* represent the same set of permissions.</span></span>  
  
-   <span data-ttu-id="1965e-209">如果为 *X*IsSubsetOf (*y*) 和 *y*。IsSubsetOf (*Z*) 均返回 `true` *X*。IsSubsetOf (*Z*) 返回 `true` 。</span><span class="sxs-lookup"><span data-stu-id="1965e-209">If *X*.IsSubsetOf(*Y*) and *Y*.IsSubsetOf(*Z*) both return `true`, *X*.IsSubsetOf(*Z*) returns `true`.</span></span>  
  
-   <span data-ttu-id="1965e-210">*X*。IsSubsetOf (*U*) 返回 `true` 。</span><span class="sxs-lookup"><span data-stu-id="1965e-210">*X*.IsSubsetOf(*U*) returns `true`.</span></span>  
  
-   <span data-ttu-id="1965e-211">*X*。IsSubsetOf (*N*) 返回 `false` 。</span><span class="sxs-lookup"><span data-stu-id="1965e-211">*X*.IsSubsetOf(*N*) returns `false`.</span></span>  
  
-   <span data-ttu-id="1965e-212">*N*。IsSubsetOf (*X*) 返回 `true` 。</span><span class="sxs-lookup"><span data-stu-id="1965e-212">*N*.IsSubsetOf(*X*) returns `true`.</span></span>  
  
 <span data-ttu-id="1965e-213">如果 *x* 和 *Y* 表示自定义代码访问权限对象，这些权限对象为空引用 *X*。IsSubsetOf (*Y*) 返回 `true` 。</span><span class="sxs-lookup"><span data-stu-id="1965e-213">If *X* and *Y* represent custom code access permission objects that are null references, *X*.IsSubsetOf(*Y*) returns `true`.</span></span> <span data-ttu-id="1965e-214">如果 *Z* 也为 null，则为复合集运算 *X*。联合 (*Y*) 。IsSubsetOf (*Z*) 也返回， `true` 因为两个 null 权限的联合是 null 权限。</span><span class="sxs-lookup"><span data-stu-id="1965e-214">If *Z* is also null, the compound set operation *X*.Union(*Y*).IsSubsetOf(*Z*) also returns `true` because the union of two null permissions is a null permission.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1965e-215">下面的代码示例演示如何重写 <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1965e-215">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> method.</span></span> <span data-ttu-id="1965e-216">此代码示例是为类提供的更大示例的一部分 <xref:System.Security.CodeAccessPermission> 。</span><span class="sxs-lookup"><span data-stu-id="1965e-216">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#4)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#4)]
 [!code-vb[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1965e-217"><paramref name="target" /> 参数不为 <see langword="null" />，并且与当前权限不属于同一类型。</span><span class="sxs-lookup"><span data-stu-id="1965e-217">The <paramref name="target" /> parameter is not <see langword="null" /> and is not of the same type as the current permission.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="1965e-218">必须在派生类中重写此方法。</span><span class="sxs-lookup"><span data-stu-id="1965e-218">You must override this method in a derived class.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub PermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void PermitOnly();" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member PermitOnly : unit -&gt; unit&#xA;override this.PermitOnly : unit -&gt; unit" Usage="codeAccessPermission.PermitOnly " FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PermitOnly() cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PermitOnly();" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.PermitOnly : unit -&gt; unit" Usage="codeAccessPermission.PermitOnly " FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">M:System.Security.IStackWalk.PermitOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName Language="C#">[System.Diagnostics.Conditional("FEATURE_MONO_CAS")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.Conditional("FEATURE_MONO_CAS")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1965e-219">防止处于调用堆栈较高位置的调用函数使用此代码，此代码将调用此方法来访问除当前实例指定的资源以外的所有资源。</span><span class="sxs-lookup"><span data-stu-id="1965e-219">Prevents callers higher in the call stack from using the code that calls this method to access all resources except for the resource specified by the current instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="1965e-220">此 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> 方法应仅用于防止完全受信任的代码意外访问资源。</span><span class="sxs-lookup"><span data-stu-id="1965e-220">The <xref:System.Security.CodeAccessPermission.PermitOnly%2A> method should be used only to protect resources from accidental access by fully trusted code.</span></span> <span data-ttu-id="1965e-221">不应使用它来防止不受信任的代码有意滥用资源。</span><span class="sxs-lookup"><span data-stu-id="1965e-221">It should not be used to protect resources from intentional misuse by untrusted code.</span></span> <span data-ttu-id="1965e-222">例如，如果方法发出权限的，然后 `A` <xref:System.Security.CodeAccessPermission.PermitOnly%2A> 调用方法 `B` ，则方法 `B` 可以通过发出来 overtly 重写 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> <xref:System.Security.CodeAccessPermission.Assert%2A> 。</span><span class="sxs-lookup"><span data-stu-id="1965e-222">For example, if method `A` issues a <xref:System.Security.CodeAccessPermission.PermitOnly%2A> for a permission and then calls method `B`, method `B` can overtly override the <xref:System.Security.CodeAccessPermission.PermitOnly%2A> by issuing an <xref:System.Security.CodeAccessPermission.Assert%2A>.</span></span> <span data-ttu-id="1965e-223">调用的方法在堆栈中始终更高。</span><span class="sxs-lookup"><span data-stu-id="1965e-223">The called method is always higher in the stack.</span></span> <span data-ttu-id="1965e-224">因此，如果方法 `B` 尝试访问受保护的资源，则安全系统会开始检查其权限，因为方法 `B` 是直接调用方，然后向下遍历堆栈以确认 <xref:System.Security.CodeAccessPermission.Deny%2A> <xref:System.Security.CodeAccessPermission.PermitOnly%2A> 堆栈中没有或更低。</span><span class="sxs-lookup"><span data-stu-id="1965e-224">Therefore, if method `B` tries to access a protected resource, the security system begins checking for permissions with it because method `B` is the immediate caller, and then walks down the stack to confirm that there is no <xref:System.Security.CodeAccessPermission.Deny%2A> or <xref:System.Security.CodeAccessPermission.PermitOnly%2A> lower in the stack.</span></span> <span data-ttu-id="1965e-225">`B`尝试访问资源的方法可以使用方法立即停止堆栈遍历 <xref:System.Security.CodeAccessPermission.Assert%2A> 。</span><span class="sxs-lookup"><span data-stu-id="1965e-225">Method `B`, which is trying to access the resource, can stop the stack walk immediately by using the <xref:System.Security.CodeAccessPermission.Assert%2A> method.</span></span> <span data-ttu-id="1965e-226">在这种情况下， <xref:System.Security.CodeAccessPermission.PermitOnly%2A> `A` 从不会发现 (调用方法) 放置在堆栈上。</span><span class="sxs-lookup"><span data-stu-id="1965e-226">In that case, the <xref:System.Security.CodeAccessPermission.PermitOnly%2A> placed on the stack by method `A` (the calling method) is never discovered.</span></span>  
  
 <span data-ttu-id="1965e-227"><xref:System.Security.CodeAccessPermission.PermitOnly%2A> 类似于 <xref:System.Security.CodeAccessPermission.Deny%2A> ，在这两个情况下，堆栈遍历将会失败，否则将会成功。</span><span class="sxs-lookup"><span data-stu-id="1965e-227"><xref:System.Security.CodeAccessPermission.PermitOnly%2A> is similar to <xref:System.Security.CodeAccessPermission.Deny%2A>, in that both cause stack walks to fail when they would otherwise succeed.</span></span> <span data-ttu-id="1965e-228">不同之处在于 <xref:System.Security.CodeAccessPermission.Deny%2A> 指定将导致堆栈遍历失败的权限，但 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> 指定不会导致堆栈遍历失败的唯一权限。</span><span class="sxs-lookup"><span data-stu-id="1965e-228">The difference is that <xref:System.Security.CodeAccessPermission.Deny%2A> specifies permissions that will cause the stack walk to fail, but <xref:System.Security.CodeAccessPermission.PermitOnly%2A> specifies the only permissions that do not cause the stack walk to fail.</span></span>  
  
 <span data-ttu-id="1965e-229">调用此方法以确保你的代码只能用于访问指定的资源。</span><span class="sxs-lookup"><span data-stu-id="1965e-229">Call this method to ensure that your code can be used to access only the specified resources.</span></span> <span data-ttu-id="1965e-230">在 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> 调用代码返回到其调用方之前，对的调用将有效。</span><span class="sxs-lookup"><span data-stu-id="1965e-230">The call to <xref:System.Security.CodeAccessPermission.PermitOnly%2A> is effective until the calling code returns to its caller.</span></span> <span data-ttu-id="1965e-231">帧上只能有一个 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> 处于活动状态。</span><span class="sxs-lookup"><span data-stu-id="1965e-231">Only one <xref:System.Security.CodeAccessPermission.PermitOnly%2A> can be active on a frame.</span></span> <span data-ttu-id="1965e-232"><xref:System.Security.CodeAccessPermission.PermitOnly%2A>如果在帧上存在活动时尝试调用，则会 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> 生成一个 <xref:System.Security.SecurityException> 。</span><span class="sxs-lookup"><span data-stu-id="1965e-232">An attempt to call <xref:System.Security.CodeAccessPermission.PermitOnly%2A> when an active <xref:System.Security.CodeAccessPermission.PermitOnly%2A> exists on the frame results in a <xref:System.Security.SecurityException>.</span></span> <span data-ttu-id="1965e-233">调用 <xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A> 或 <xref:System.Security.CodeAccessPermission.RevertAll%2A> 删除活动 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> 。</span><span class="sxs-lookup"><span data-stu-id="1965e-233">Call <xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> to remove an active <xref:System.Security.CodeAccessPermission.PermitOnly%2A>.</span></span>  
  
 <span data-ttu-id="1965e-234"><xref:System.Security.CodeAccessPermission.PermitOnly%2A> 对于未授予的权限，将忽略，因为对该权限的请求将不会成功。</span><span class="sxs-lookup"><span data-stu-id="1965e-234"><xref:System.Security.CodeAccessPermission.PermitOnly%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span> <span data-ttu-id="1965e-235">但是，如果调用堆栈上较低的代码以后调用 <xref:System.Security.CodeAccessPermission.Demand%2A> 了该权限，则 <xref:System.Security.SecurityException> 当堆栈遍历到达尝试调用的代码时，将引发 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> 。</span><span class="sxs-lookup"><span data-stu-id="1965e-235">However, if code lower on the call stack later calls <xref:System.Security.CodeAccessPermission.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call <xref:System.Security.CodeAccessPermission.PermitOnly%2A>.</span></span> <span data-ttu-id="1965e-236">这是因为调用的代码 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> 没有获得权限，即使它是 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> 为该权限调用的。</span><span class="sxs-lookup"><span data-stu-id="1965e-236">This is because the code that called <xref:System.Security.CodeAccessPermission.PermitOnly%2A> has not been granted the permission, even though it called <xref:System.Security.CodeAccessPermission.PermitOnly%2A> for that permission.</span></span> <span data-ttu-id="1965e-237">调用堆栈通常表示为向下增长，因此调用堆栈中较高位置的方法调用堆栈中较低的调用方法。</span><span class="sxs-lookup"><span data-stu-id="1965e-237">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="1965e-238">已存在一个用于当前帧的活动的 <see cref="M:System.Security.CodeAccessPermission.PermitOnly" />。</span><span class="sxs-lookup"><span data-stu-id="1965e-238">There is already an active <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="1965e-239">不能重写此方法。</span><span class="sxs-lookup"><span data-stu-id="1965e-239">You cannot override this method.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="RevertAll">
      <MemberSignature Language="C#" Value="public static void RevertAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertAll() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertAll" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertAll ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertAll();" />
      <MemberSignature Language="F#" Value="static member RevertAll : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertAll " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName Language="C#">[System.Diagnostics.Conditional("FEATURE_MONO_CAS")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.Conditional("FEATURE_MONO_CAS")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1965e-240">导致当前帧以前所有的重写被删除且不再有效。</span><span class="sxs-lookup"><span data-stu-id="1965e-240">Causes all previous overrides for the current frame to be removed and no longer in effect.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1965e-241">如果 <xref:System.Security.CodeAccessPermission.Assert%2A> 当前帧 (、或) 没有替代， <xref:System.Security.CodeAccessPermission.Deny%2A> <xref:System.Security.CodeAccessPermission.PermitOnly%2A> <xref:System.ExecutionEngineException> 则会引发。</span><span class="sxs-lookup"><span data-stu-id="1965e-241">If there are no overrides (<xref:System.Security.CodeAccessPermission.Assert%2A>, <xref:System.Security.CodeAccessPermission.Deny%2A>, or <xref:System.Security.CodeAccessPermission.PermitOnly%2A>) for the current frame, an <xref:System.ExecutionEngineException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1965e-242">此当前帧没有以前的 <see cref="M:System.Security.CodeAccessPermission.Assert" />、<see cref="M:System.Security.CodeAccessPermission.Deny" /> 或 <see cref="M:System.Security.CodeAccessPermission.PermitOnly" />。</span><span class="sxs-lookup"><span data-stu-id="1965e-242">There is no previous <see cref="M:System.Security.CodeAccessPermission.Assert" />, <see cref="M:System.Security.CodeAccessPermission.Deny" />, or <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RevertAssert">
      <MemberSignature Language="C#" Value="public static void RevertAssert ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertAssert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertAssert" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertAssert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertAssert();" />
      <MemberSignature Language="F#" Value="static member RevertAssert : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertAssert " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName Language="C#">[System.Diagnostics.Conditional("FEATURE_MONO_CAS")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.Conditional("FEATURE_MONO_CAS")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1965e-243">导致当前帧以前所有的 <see cref="M:System.Security.CodeAccessPermission.Assert" /> 被删除且不再有效。</span><span class="sxs-lookup"><span data-stu-id="1965e-243">Causes any previous <see cref="M:System.Security.CodeAccessPermission.Assert" /> for the current frame to be removed and no longer in effect.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1965e-244">如果 <xref:System.Security.CodeAccessPermission.Assert%2A> 当前帧没有， <xref:System.ExecutionEngineException> 则会引发。</span><span class="sxs-lookup"><span data-stu-id="1965e-244">If there is no <xref:System.Security.CodeAccessPermission.Assert%2A> for the current frame, an <xref:System.ExecutionEngineException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1965e-245">当前帧不再具有以前的 <see cref="M:System.Security.CodeAccessPermission.Assert" />。</span><span class="sxs-lookup"><span data-stu-id="1965e-245">There is no previous <see cref="M:System.Security.CodeAccessPermission.Assert" /> for the current frame.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RevertDeny">
      <MemberSignature Language="C#" Value="public static void RevertDeny ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertDeny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertDeny" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertDeny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertDeny();" />
      <MemberSignature Language="F#" Value="static member RevertDeny : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertDeny " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1">
          <AttributeName Language="C#">[System.Obsolete]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Obsolete("Deny is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Deny is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName Language="C#">[System.Diagnostics.Conditional("FEATURE_MONO_CAS")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.Conditional("FEATURE_MONO_CAS")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1965e-246">导致当前帧以前所有的 <see cref="M:System.Security.CodeAccessPermission.Deny" /> 被删除且不再有效。</span><span class="sxs-lookup"><span data-stu-id="1965e-246">Causes any previous <see cref="M:System.Security.CodeAccessPermission.Deny" /> for the current frame to be removed and no longer in effect.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1965e-247">如果 <xref:System.Security.CodeAccessPermission.Deny%2A> 当前帧没有， <xref:System.ExecutionEngineException> 则会引发。</span><span class="sxs-lookup"><span data-stu-id="1965e-247">If there is no <xref:System.Security.CodeAccessPermission.Deny%2A> for the current frame, an <xref:System.ExecutionEngineException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1965e-248">当前帧不再具有以前的 <see cref="M:System.Security.CodeAccessPermission.Deny" />。</span><span class="sxs-lookup"><span data-stu-id="1965e-248">There is no previous <see cref="M:System.Security.CodeAccessPermission.Deny" /> for the current frame.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RevertPermitOnly">
      <MemberSignature Language="C#" Value="public static void RevertPermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertPermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertPermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertPermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertPermitOnly();" />
      <MemberSignature Language="F#" Value="static member RevertPermitOnly : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertPermitOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName Language="C#">[System.Diagnostics.Conditional("FEATURE_MONO_CAS")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.Conditional("FEATURE_MONO_CAS")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1965e-249">导致当前帧以前所有的 <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> 被删除且不再有效。</span><span class="sxs-lookup"><span data-stu-id="1965e-249">Causes any previous <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame to be removed and no longer in effect.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1965e-250">如果 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> 当前帧没有， <xref:System.ExecutionEngineException> 则会引发。</span><span class="sxs-lookup"><span data-stu-id="1965e-250">If there is no <xref:System.Security.CodeAccessPermission.PermitOnly%2A> for the current frame, an <xref:System.ExecutionEngineException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1965e-251">当前帧不再具有以前的 <see cref="M:System.Security.CodeAccessPermission.PermitOnly" />。</span><span class="sxs-lookup"><span data-stu-id="1965e-251">There is no previous <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IPermission.Demand">
      <MemberSignature Language="C#" Value="void IPermission.Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IPermission.Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IPermission#Demand" />
      <MemberSignature Language="VB.NET" Value="Sub Demand () Implements IPermission.Demand" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IPermission.Demand() = System::Security::IPermission::Demand;" />
      <MemberSignature Language="F#" Value="abstract member System.Security.IPermission.Demand : unit -&gt; unit&#xA;override this.System.Security.IPermission.Demand : unit -&gt; unit" Usage="codeAccessPermission.System.Security.IPermission.Demand " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1965e-252">如果不满足安全要求，则会在运行时引发 <see cref="T:System.Security.SecurityException" />。</span><span class="sxs-lookup"><span data-stu-id="1965e-252">Throws a <see cref="T:System.Security.SecurityException" /> at run time if the security requirement is not met.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="1965e-253">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="1965e-253">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="1965e-254">它只能在 <xref:System.Security.CodeAccessPermission> 实例被强制转换为 <xref:System.Security.IPermission> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="1965e-254">It can be used only when the <xref:System.Security.CodeAccessPermission> instance is cast to an <xref:System.Security.IPermission> interface.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="1965e-255">不符合安全要求。</span><span class="sxs-lookup"><span data-stu-id="1965e-255">The security requirement is not met.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Assert">
      <MemberSignature Language="C#" Value="void IStackWalk.Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Assert" />
      <MemberSignature Language="VB.NET" Value="Sub Assert () Implements IStackWalk.Assert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Assert() = System::Security::IStackWalk::Assert;" />
      <MemberSignature Language="F#" Value="abstract member System.Security.IStackWalk.Assert : unit -&gt; unit&#xA;override this.System.Security.IStackWalk.Assert : unit -&gt; unit" Usage="codeAccessPermission.System.Security.IStackWalk.Assert " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Assert</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1965e-256">断言调用代码可以访问当前权限对象所标识的资源，即使尚未对堆栈中的高级调用方授予访问该资源的权限。</span><span class="sxs-lookup"><span data-stu-id="1965e-256">Asserts that the calling code can access the resource identified by the current permission object, even if callers higher in the stack have not been granted permission to access the resource.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="1965e-257">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="1965e-257">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="1965e-258">它只能在 <xref:System.Security.CodeAccessPermission> 实例被强制转换为 <xref:System.Security.IStackWalk> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="1965e-258">It can be used only when the <xref:System.Security.CodeAccessPermission> instance is cast to an <xref:System.Security.IStackWalk> interface.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Demand">
      <MemberSignature Language="C#" Value="void IStackWalk.Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Demand" />
      <MemberSignature Language="VB.NET" Value="Sub Demand () Implements IStackWalk.Demand" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Demand() = System::Security::IStackWalk::Demand;" />
      <MemberSignature Language="F#" Value="abstract member System.Security.IStackWalk.Demand : unit -&gt; unit&#xA;override this.System.Security.IStackWalk.Demand : unit -&gt; unit" Usage="codeAccessPermission.System.Security.IStackWalk.Demand " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1965e-259">在运行时确定调用堆栈中的所有调用方是否已被授予当前权限对象所指定的权限。</span><span class="sxs-lookup"><span data-stu-id="1965e-259">Determines at run time whether all callers in the call stack have been granted the permission specified by the current permission object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="1965e-260">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="1965e-260">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="1965e-261">它只能在 <xref:System.Security.CodeAccessPermission> 实例被强制转换为 <xref:System.Security.IStackWalk> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="1965e-261">It can be used only when the <xref:System.Security.CodeAccessPermission> instance is cast to an <xref:System.Security.IStackWalk> interface.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Deny">
      <MemberSignature Language="C#" Value="void IStackWalk.Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Deny" />
      <MemberSignature Language="VB.NET" Value="Sub Deny () Implements IStackWalk.Deny" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Deny() = System::Security::IStackWalk::Deny;" />
      <MemberSignature Language="F#" Value="abstract member System.Security.IStackWalk.Deny : unit -&gt; unit&#xA;override this.System.Security.IStackWalk.Deny : unit -&gt; unit" Usage="codeAccessPermission.System.Security.IStackWalk.Deny " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Deny</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1965e-262">将导致通过调用代码传递的当前对象的每个 <see cref="M:System.Security.IStackWalk.Demand" /> 失败。</span><span class="sxs-lookup"><span data-stu-id="1965e-262">Causes every <see cref="M:System.Security.IStackWalk.Demand" /> for the current object that passes through the calling code to fail.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="1965e-263">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="1965e-263">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="1965e-264">它只能在 <xref:System.Security.CodeAccessPermission> 实例被强制转换为 <xref:System.Security.IStackWalk> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="1965e-264">It can be used only when the <xref:System.Security.CodeAccessPermission> instance is cast to an <xref:System.Security.IStackWalk> interface.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.PermitOnly">
      <MemberSignature Language="C#" Value="void IStackWalk.PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Sub PermitOnly () Implements IStackWalk.PermitOnly" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.PermitOnly() = System::Security::IStackWalk::PermitOnly;" />
      <MemberSignature Language="F#" Value="abstract member System.Security.IStackWalk.PermitOnly : unit -&gt; unit&#xA;override this.System.Security.IStackWalk.PermitOnly : unit -&gt; unit" Usage="codeAccessPermission.System.Security.IStackWalk.PermitOnly " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.PermitOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1965e-265">导致所有对象的每个 <see cref="M:System.Security.IStackWalk.Demand" />（除了通过调用代码的当前那个）失败，即使调用堆栈中较高级别的代码已被授予访问其他资源的权限也是如此。</span><span class="sxs-lookup"><span data-stu-id="1965e-265">Causes every <see cref="M:System.Security.IStackWalk.Demand" /> for all objects except the current one that pass through the calling code to fail, even if code higher in the call stack has been granted permission to access other resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="1965e-266">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="1965e-266">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="1965e-267">它只能在 <xref:System.Security.CodeAccessPermission> 实例被强制转换为 <xref:System.Security.IStackWalk> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="1965e-267">It can be used only when the <xref:System.Security.CodeAccessPermission> instance is cast to an <xref:System.Security.IStackWalk> interface.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="codeAccessPermission.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1965e-268">创建并返回当前权限对象的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="1965e-268">Creates and returns a string representation of the current permission object.</span></span></summary>
        <returns><span data-ttu-id="1965e-269">当前权限对象的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="1965e-269">A string representation of the current permission object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1965e-270">当你需要以字符串形式显示权限时，此方法可用于调试。</span><span class="sxs-lookup"><span data-stu-id="1965e-270">This method is useful in debugging when you need to display the permission as a string.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToXml">
      <MemberSignature Language="C#" Value="public abstract System.Security.SecurityElement ToXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.SecurityElement ToXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.ToXml" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ToXml () As SecurityElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::SecurityElement ^ ToXml();" />
      <MemberSignature Language="F#" Value="abstract member ToXml : unit -&gt; System.Security.SecurityElement" Usage="codeAccessPermission.ToXml " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.ISecurityEncodable.ToXml</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1965e-271">当在派生类中重写时，创建安全对象及其当前状态的 XML 编码。</span><span class="sxs-lookup"><span data-stu-id="1965e-271">When overridden in a derived class, creates an XML encoding of the security object and its current state.</span></span></summary>
        <returns><span data-ttu-id="1965e-272">安全对象的 XML 编码，包括任何状态信息。</span><span class="sxs-lookup"><span data-stu-id="1965e-272">An XML encoding of the security object, including any state information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1965e-273">扩展安全对象的自定义代码需要实现 <xref:System.Security.CodeAccessPermission.ToXml%2A> 和 <xref:System.Security.CodeAccessPermission.FromXml%2A> 方法，以使对象安全 encodable。</span><span class="sxs-lookup"><span data-stu-id="1965e-273">Custom code that extends security objects needs to implement the <xref:System.Security.CodeAccessPermission.ToXml%2A> and <xref:System.Security.CodeAccessPermission.FromXml%2A> methods to make the objects security-encodable.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1965e-274">下面的代码示例演示如何重写 <xref:System.Security.CodeAccessPermission.ToXml%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1965e-274">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.ToXml%2A> method.</span></span> <span data-ttu-id="1965e-275">此代码示例是为类提供的更大示例的一部分 <xref:System.Security.CodeAccessPermission> 。</span><span class="sxs-lookup"><span data-stu-id="1965e-275">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#11)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#11)]
 [!code-vb[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#11)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="1965e-276">必须在派生类中重写此方法。</span><span class="sxs-lookup"><span data-stu-id="1965e-276">You must override this method in a derived class.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public virtual System.Security.IPermission Union (System.Security.IPermission other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Union(class System.Security.IPermission other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Union (other As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::IPermission ^ Union(System::Security::IPermission ^ other);" />
      <MemberSignature Language="F#" Value="abstract member Union : System.Security.IPermission -&gt; System.Security.IPermission&#xA;override this.Union : System.Security.IPermission -&gt; System.Security.IPermission" Usage="codeAccessPermission.Union other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Union(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="1965e-277">与当前权限合并的权限。</span><span class="sxs-lookup"><span data-stu-id="1965e-277">A permission to combine with the current permission.</span></span> <span data-ttu-id="1965e-278">它必须与当前权限属于同一类型。</span><span class="sxs-lookup"><span data-stu-id="1965e-278">It must be of the same type as the current permission.</span></span></param>
        <summary><span data-ttu-id="1965e-279">当在派生类中重写时，则创建属于当前权限与指定权限的并集的权限。</span><span class="sxs-lookup"><span data-stu-id="1965e-279">When overridden in a derived class, creates a permission that is the union of the current permission and the specified permission.</span></span></summary>
        <returns><span data-ttu-id="1965e-280">表示同时兼具当前权限和指定权限的新权限。</span><span class="sxs-lookup"><span data-stu-id="1965e-280">A new permission that represents the union of the current permission and the specified permission.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1965e-281">调用的结果 <xref:System.Security.CodeAccessPermission.Union%2A> 是一个权限，它表示当前权限和指定权限所表示的所有操作。</span><span class="sxs-lookup"><span data-stu-id="1965e-281">The result of a call to <xref:System.Security.CodeAccessPermission.Union%2A> is a permission that represents all the operations represented by both the current permission and the specified permission.</span></span> <span data-ttu-id="1965e-282">任何传递任意权限的需求都将传递其联合。</span><span class="sxs-lookup"><span data-stu-id="1965e-282">Any demand that passes either permission passes their union.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1965e-283">下面的代码示例演示如何重写 <xref:System.Security.CodeAccessPermission.Union%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1965e-283">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.Union%2A> method.</span></span> <span data-ttu-id="1965e-284">此代码示例是为类提供的更大示例的一部分 <xref:System.Security.CodeAccessPermission> 。</span><span class="sxs-lookup"><span data-stu-id="1965e-284">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#12)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#12)]
 [!code-vb[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1965e-285"><paramref name="other" /> 参数不是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1965e-285">The <paramref name="other" /> parameter is not <see langword="null" />.</span></span> <span data-ttu-id="1965e-286">当传递 <see langword="null" /> 时，此方法仅在此级别受支持。</span><span class="sxs-lookup"><span data-stu-id="1965e-286">This method is only supported at this level when passed <see langword="null" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="1965e-287">必须在派生类中重写此方法。</span><span class="sxs-lookup"><span data-stu-id="1965e-287">You must override this method in a derived class.</span></span> <span data-ttu-id="1965e-288">如果参数的值为，则应返回权限的副本 <paramref name="other" /> <see langword="null" /> 。</span><span class="sxs-lookup"><span data-stu-id="1965e-288">You should return a copy of the permission if the value of the <paramref name="other" /> parameter is <see langword="null" />.</span></span></para></block>
      </Docs>
    </Member>
  </Members>
</Type>
