<Type Name="NavigationService" FullName="System.Windows.Navigation.NavigationService">
  <Metadata><Meta Name="ms.openlocfilehash" Value="81ec9da45db956dc042091e179e1232845928c1b" /><Meta Name="ms.sourcegitcommit" Value="c982ad9e10a242d90f1e631b5981570f9e5d9f34" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/10/2020" /><Meta Name="ms.locfileid" Value="89849549" /></Metadata><TypeSignature Language="C#" Value="public sealed class NavigationService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit NavigationService extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Navigation.NavigationService" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class NavigationService" />
  <TypeSignature Language="C++ CLI" Value="public ref class NavigationService sealed" />
  <TypeSignature Language="F#" Value="type NavigationService = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>包含支持导航的各种方法、属性和事件。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService> 封装在浏览器样式的导航上下文内下载内容的功能。  
  
 内容可以是任何类型的 .NET Framework 对象和 HTML 文件。 但一般情况下，页面是打包内容以进行导航的首选方式 (参阅 <xref:System.Windows.Controls.Page>) 。  
  
 可以通过提供对象的实例并调用接受对象的方法的重载，来导航到内容 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> ：  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Object%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Object%2CSystem.Object%29?displayProperty=nameWithType>  
  
 或者，通过将相对或绝对 URI 传递到接受 URI 的方法重载之一，可以导航到内容 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> ：  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%2CSystem.Object%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%2CSystem.Object%2CSystem.Boolean%29?displayProperty=nameWithType>  
  
 当内容通过 URI 导航到时， <xref:System.Windows.Navigation.NavigationService> 将返回包含内容的对象。  
  
 导航的生存期可通过以下事件进行跟踪：  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigating>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigated>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationProgress>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationFailed>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationStopped>  
  
-   <xref:System.Windows.Navigation.NavigationService.LoadCompleted>  
  
-   <xref:System.Windows.Navigation.NavigationService.FragmentNavigation>.  
  
 并非每次发生导航时都会引发所有事件;引发的事件集由 (内容或内容片段) 的导航类型确定，以及导航如何完成 (取消、停止或失败) 。  
  
 下图说明了引发这些事件的顺序：  
  
 ![页面导航流程图](~/add/media/navigationoverviewfigure11.png "页面导航流程图")  
  
 在导航过程中或导航后， <xref:System.Windows.Navigation.NavigationService> 提供有关要导航到的内容的信息，包括要导航到的内容的 uri (<xref:System.Windows.Navigation.NavigationService.Source%2A>) 、当前内容 () 的 uri <xref:System.Windows.Navigation.NavigationService.CurrentSource%2A> 以及包含导航到 () 的内容的对象 <xref:System.Windows.Navigation.NavigationService.Content%2A> 。  
  
 导航到内容时，会 <xref:System.Windows.Navigation.NavigationService> 将导航记录为导航历史记录中的条目。 当出现新的导航时，通过调用 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 方法或通过在前进导航历史记录中通过调用导航到某个条目来向后导航历史记录中添加一个条目 <xref:System.Windows.Navigation.NavigationService.GoForward%2A> 。 通过在后退导航历史记录中通过调用来向后导航历史记录中添加一个条目 <xref:System.Windows.Navigation.NavigationService.GoBack%2A> 。 <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A> 和 <xref:System.Windows.Navigation.NavigationService.CanGoForward%2A> 报告后退和前进导航历史记录中是否存在条目。 此外，可以通过调用删除后退导航历史记录中的最新条目 <xref:System.Windows.Navigation.NavigationService.RemoveBackEntry%2A> 。  
  
 默认情况下，不 <xref:System.Windows.Navigation.NavigationService> 会在导航历史记录中存储内容对象的实例。 相反， <xref:System.Windows.Navigation.NavigationService> 每次使用导航历史记录导航到内容对象时，都将创建该对象的新实例。 此行为旨在避免在将大量内容导航到时消耗过多的内存。 因此，不会从一个导航到下一个导航来记住内容的状态。 不过，WPF 提供了多种方法，通过这些方法，你可以在导航历史记录中存储一段内容的状态。  
  
 使用 <xref:System.Windows.Navigation.NavigationService.AddBackEntry%2A> ，还可以记住单个页面实例的多个状态集。  
  
 <xref:System.Windows.Navigation.NavigationService> 是一个 `sealed` 类，因此不能被实例化，而是 <xref:System.Windows.Navigation.NavigationService> 由导航器用于启用导航。 在 WPF 中，有两个导航器： <xref:System.Windows.Navigation.NavigationWindow> 和 <xref:System.Windows.Controls.Frame> 。  
  
 直观地 [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] 使用 [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] 作为导航器来提供集成的用户体验。 但 [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] 实际上，实际使用 <xref:System.Windows.Navigation.NavigationWindow> 作为导航器; <xref:System.Windows.Application.MainWindow%2A> 在中运行的的属性 [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] 将返回对的引用 <xref:System.Windows.Navigation.NavigationWindow> ，并且由管理的导航历史记录 <xref:System.Windows.Navigation.NavigationWindow> 与通过以下方式管理的导航历史记录集成 [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] ：  
  
-   在导航到内容时，通过 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> <xref:System.Windows.Navigation.NavigationService.GoBack%2A> 从中调用、和， <xref:System.Windows.Navigation.NavigationService.GoForward%2A> [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] 还会将相关导航历史记录项中的添加到 [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] 导航历史记录中。  
  
-   如果选择了导航中的条目 [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] ，则 [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] 会导致 <xref:System.Windows.Navigation.NavigationService> 向后导航到与这些条目关联的内容。  
  
> [!NOTE]
>  <xref:System.Windows.Controls.Frame>可以提供自己的导航历史记录，也可以使用托管它的导航器的导航历史记录。 如果 <xref:System.Windows.Controls.Frame> 提供了自己的导航历史记录，则可以显示其自己 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 的导航以导航到导航历史记录中的条目; 这些条目不会添加到 "主机导航器" 的导航历史记录中 (<xref:System.Windows.Navigation.NavigationWindow> ，) ， <xref:System.Windows.Controls.Frame> [!INCLUDE[TLA2#tla_iegeneric](~/includes/tla2sharptla-iegeneric-md.md)] 因此，无法从每个 (的导航导航到它，因此请 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 参阅 <xref:System.Windows.Controls.Frame.JournalOwnership%2A>) 。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddBackEntry">
      <MemberSignature Language="C#" Value="public void AddBackEntry (System.Windows.Navigation.CustomContentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBackEntry(class System.Windows.Navigation.CustomContentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.AddBackEntry(System.Windows.Navigation.CustomContentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBackEntry (state As CustomContentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBackEntry(System::Windows::Navigation::CustomContentState ^ state);" />
      <MemberSignature Language="F#" Value="member this.AddBackEntry : System.Windows.Navigation.CustomContentState -&gt; unit" Usage="navigationService.AddBackEntry state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Navigation.CustomContentState" />
      </Parameters>
      <Docs>
        <param name="state">一个 <see cref="T:System.Windows.Navigation.CustomContentState" /> 对象，该对象表示与特定内容片段关联的应用程序定义的状态。</param>
        <summary>向包含 <see cref="T:System.Windows.Navigation.CustomContentState" /> 对象的后退导航历史记录中添加一个条目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.AddBackEntry%2A>、 <xref:System.Windows.Navigation.CustomContentState> 和可 <xref:System.Windows.Navigation.IProvideCustomContentState> 用于帮助记住当前内容的多个状态集。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="state" /> 为 <see langword="null" />，并且 <see cref="T:System.Windows.Navigation.CustomContentState" /> 对象不是从 <see cref="M:System.Windows.Navigation.IProvideCustomContentState.GetContentState" /> 返回的对象。</exception>
        <altmember cref="M:System.Windows.Navigation.NavigationService.RemoveBackEntry" />
      </Docs>
    </Member>
    <Member MemberName="CanGoBack">
      <MemberSignature Language="C#" Value="public bool CanGoBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoBack" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CanGoBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoBack { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanGoBack : bool" Usage="System.Windows.Navigation.NavigationService.CanGoBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示后退导航历史记录中是否至少有一个条目。</summary>
        <value>如果后退导航历史记录中至少具有一个条目，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A> 若要确定后退导航历史记录中是否至少有一个条目。 此属性应在调用之前进行检查 <xref:System.Windows.Navigation.NavigationService.GoBack%2A> ; 如果 <xref:System.Windows.Navigation.NavigationService.GoBack%2A> 调用了并且后退导航历史记录中没有任何项， <xref:System.InvalidOperationException> 则会引发。  
  
> [!NOTE]
>  如果导航历史记录由多个导航器共享 (<xref:System.Windows.Navigation.NavigationWindow> ， <xref:System.Windows.Controls.Frame>) ，则 <xref:System.Windows.Navigation.NavigationService> 当前导航器中可能尚未添加后退导航历史记录中的最新条目。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoForward" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoForward" />
      </Docs>
    </Member>
    <Member MemberName="CanGoForward">
      <MemberSignature Language="C#" Value="public bool CanGoForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CanGoForward" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoForward As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoForward { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanGoForward : bool" Usage="System.Windows.Navigation.NavigationService.CanGoForward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示前进导航历史记录中是否至少有一个条目。</summary>
        <value>如果前进导航历史记录中至少具有一个条目，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.CanGoForward%2A> 确定前进导航历史记录中是否至少有一个条目。 此属性应在调用之前进行检查 <xref:System.Windows.Navigation.NavigationService.GoForward%2A> ; 如果 <xref:System.Windows.Navigation.NavigationService.GoForward%2A> 调用了并且前进导航历史记录中没有任何项， <xref:System.InvalidOperationException> 则会引发。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoBack" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoBack" />
      </Docs>
    </Member>
    <Member MemberName="Content">
      <MemberSignature Language="C#" Value="public object Content { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Content" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.Content" />
      <MemberSignature Language="VB.NET" Value="Public Property Content As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Content { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Content : obj with get, set" Usage="System.Windows.Navigation.NavigationService.Content" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置对包含当前内容的对象的引用。</summary>
        <value>一个对象，它是对包含当前内容的对象的引用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以通过以下两种方式之一设置内容：  
  
-   直接将它设置为对对象的引用。  
  
-   间接调用 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 、 <xref:System.Windows.Navigation.NavigationService.GoBack%2A> 或 <xref:System.Windows.Navigation.NavigationService.GoForward%2A> 。  
  
 设置将 <xref:System.Windows.Navigation.NavigationService> 启动新导航; 因为导航是异步的，因此， <xref:System.Windows.Navigation.NavigationService.Content%2A> 如果在设置后立即检查，则不会返回值。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Navigation.NavigationService.Navigate" />
      </Docs>
    </Member>
    <Member MemberName="CurrentSource">
      <MemberSignature Language="C#" Value="public Uri CurrentSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri CurrentSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CurrentSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentSource As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ CurrentSource { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentSource : Uri" Usage="System.Windows.Navigation.NavigationService.CurrentSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取上次导航到的内容的 URI。</summary>
        <value><see cref="T:System.Uri" />如果是通过使用 URI 导航到，则为上次导航到的内容的; 否则为 <see langword="null" /> 。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 <xref:System.Windows.Navigation.NavigationService.CurrentSource%2A> 成功完成导航到不同的 URI 之前，不会更改属性的值。  
  
 <xref:System.Windows.Navigation.NavigationService.CurrentSource%2A> 可以使用仅分段 URI 进行设置。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FragmentNavigation As FragmentNavigationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberSignature Language="F#" Value="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " Usage="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当开始导航到某个内容片段时发生，如果所需片段位于当前内容中，它会立即发生；或者，如果所需片段位于不同内容中，它会在加载了源 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 内容之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，内容片段是一个名为的内容，其 <xref:System.Windows.UIElement> <xref:System.Windows.UIElement> <xref:System.Windows.FrameworkElement.Name%2A> 属性已设置为，例如：  
  
```  
<TextBlock Name="FragmentName">...</TextBlock>  
```  
  
 可以 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 通过提供具有以下格式的后缀的 URI 导航到片段：  
  
 \#*FragmentName*  
  
 下面显示了引用内容片段的 URI 示例：  
  
 `http://www.microsoft.com/targetpage.xaml#FragmentName`  
  
 源页面加载后 (<xref:System.Windows.Navigation.NavigationService.LoadCompleted> 引发事件后) ，段导航开始， <xref:System.Windows.Navigation.NavigationService> 尝试查找 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 片段。 如果 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 找到了片段，则 <xref:System.Windows.Navigation.NavigationService> 指示内容导航器 (<xref:System.Windows.Navigation.NavigationWindow> ， <xref:System.Windows.Controls.Frame>) 以显示片段。 如果需要更改此行为，您可以处理 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 以提供您自己的片段导航行为。 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 向传递了一个 <xref:System.Windows.Navigation.FragmentNavigationEventArgs> 参数，该参数公开用于此目的的属性，包括：  
  
-   拥有此导航服务的导航器 (<xref:System.Windows.Navigation.NavigationWindow> ， <xref:System.Windows.Controls.Frame>) 。  
  
-   片段名称。  
  
 您可以 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 通过处理来用您自己的自定义实现来重写默认的 WPF 片段实现。 如果这样做，则需要将设置 <xref:System.Windows.Navigation.FragmentNavigationEventArgs.Handled%2A> 为 `true` ; 否则，将应用默认的 WPF 片断处理行为。  
  
 应避免直接在 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 事件处理程序中启动导航。 由于 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 是在现有导航过程中引发的，因此从事件处理程序启动新导航会 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 创建一个嵌套的导航，从而导致 <xref:System.ExecutionEngineException> 引发。 相反，你可以通过使用创建异步工作项来间接启动导航 <xref:System.Windows.Threading.Dispatcher> 。  
  
> [!NOTE]
>  <xref:System.Windows.Navigation.NavigationService>引发时 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> ，它还会引发 <xref:System.Windows.Application.FragmentNavigation?displayProperty=nameWithType> 对象上的事件 <xref:System.Windows.Application> 。  
  
> [!IMPORTANT]
>  在以下情况下，不支持片段导航 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] (仅标记 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] `Page` 为根元素) 的松散页面：  
>   
>  •导航到松散页面中的片段时 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 。  
>   
>  •从松散 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 页面导航到其他松散页面中的片段时 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 。  
>   
>  但松散 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 页可以导航到其自己的片段。  
  
   
  
## Examples  
 下面的示例演示如何处理 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 以提供自定义片段导航行为。 在这种情况下， [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 如果找不到源页中的片段，该示例将打开错误页 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowFragmentNavigationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowfragmentnavigationcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowFragmentNavigationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowfragmentnavigationcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetNavigationService">
      <MemberSignature Language="C#" Value="public static System.Windows.Navigation.NavigationService GetNavigationService (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Navigation.NavigationService GetNavigationService(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GetNavigationService(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNavigationService (dependencyObject As DependencyObject) As NavigationService" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Navigation::NavigationService ^ GetNavigationService(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="static member GetNavigationService : System.Windows.DependencyObject -&gt; System.Windows.Navigation.NavigationService" Usage="System.Windows.Navigation.NavigationService.GetNavigationService dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationService</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">由导航器承载的内容中的 <see cref="T:System.Windows.DependencyObject" />。</param>
        <summary>获取对导航器的 <see cref="T:System.Windows.Navigation.NavigationService" /> 的引用，该导航器的内容中包含指定的 <see cref="T:System.Windows.DependencyObject" />。</summary>
        <returns>对导航器（该导航器的内容中包含指定的 <see cref="T:System.Windows.DependencyObject" />）的 <see cref="T:System.Windows.Navigation.NavigationService" /> 的引用在某些情况下可以为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 导航器具有 <xref:System.Windows.Navigation.NavigationService> 处理内容导航的。 WPF 有两个导航器： <xref:System.Windows.Navigation.NavigationWindow> 和 <xref:System.Windows.Controls.Frame> 。 为了处理导航请求和管理导航生存期，导航器使用 WPF 导航服务，该服务以类的形式实现 <xref:System.Windows.Navigation.NavigationService> 。 导航器承载的内容可以通过调用方法获取对导航器的引用 <xref:System.Windows.Navigation.NavigationService> <xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A> 。  
  
 <xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A>`null`当以下情况时返回 `dependencyObject` ：  
  
-   是 <xref:System.Windows.Navigation.NavigationWindow> 。  
  
-   是 <xref:System.Windows.Controls.Frame> ：  
  
    1.  由另一导航器承载。  
  
    2.  将其 <xref:System.Windows.Controls.Frame.JournalOwnership%2A> 属性设置为 <xref:System.Windows.Navigation.JournalOwnership.UsesParentJournal> 。  
  
-   不是由导航器承载的内容的一部分。  
  
 WPF 提供了两个快捷方式用于获取对的引用 <xref:System.Windows.Navigation.NavigationService> ：  
  
-   <xref:System.Windows.Navigation.NavigationService>处理到的导航的 <xref:System.Windows.Controls.Page> 可以 <xref:System.Windows.Controls.Page> 通过获取其属性的值来访问 <xref:System.Windows.Controls.Page.NavigationService%2A?displayProperty=nameWithType> 。  
  
-   <xref:System.Windows.Navigation.NavigationService> <xref:System.Windows.Controls.Frame> 可以通过获取属性的值来访问用于处理导航的 <xref:System.Windows.Controls.Frame.NavigationService%2A> 。  
  
   
  
## Examples  
 下面的示例演示如何 <xref:System.Windows.Controls.UserControl> 通过调用来检索导航服务 <xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A> 。  
  
 [!code-csharp[NSGetNavigationServiceSnippets#GetNavigationServiceCODE1](~/samples/snippets/csharp/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/CSharp/ContentUserControl.xaml.cs#getnavigationservicecode1)]
 [!code-vb[NSGetNavigationServiceSnippets#GetNavigationServiceCODE1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/visualbasic/contentusercontrol.xaml.vb#getnavigationservicecode1)]  
[!code-csharp[NSGetNavigationServiceSnippets#GetNavigationServiceCODE2](~/samples/snippets/csharp/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/CSharp/ContentUserControl.xaml.cs#getnavigationservicecode2)]
[!code-vb[NSGetNavigationServiceSnippets#GetNavigationServiceCODE2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/visualbasic/contentusercontrol.xaml.vb#getnavigationservicecode2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dependencyObject" /> 参数为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GoBack">
      <MemberSignature Language="C#" Value="public void GoBack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoBack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GoBack" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoBack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoBack();" />
      <MemberSignature Language="F#" Value="member this.GoBack : unit -&gt; unit" Usage="navigationService.GoBack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>导航到后退导航历史记录中的最新条目（如果有）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用之前 <xref:System.Windows.Navigation.NavigationService.GoBack%2A> ， <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A> 可以检查属性以确定后退导航历史记录中是否存在条目。  
  
   
  
## Examples  
 下面的示例导航到后退导航历史记录中的最新条目（如果有）。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowBackCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowbackcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowBackCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowbackcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在调用 <see cref="M:System.Windows.Navigation.NavigationService.GoBack" /> 时后退导航历史记录中没有条目。</exception>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoForward" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoForward" />
      </Docs>
    </Member>
    <Member MemberName="GoForward">
      <MemberSignature Language="C#" Value="public void GoForward ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoForward() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GoForward" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoForward ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoForward();" />
      <MemberSignature Language="F#" Value="member this.GoForward : unit -&gt; unit" Usage="navigationService.GoForward " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>导航到前进导航历史记录中的最新条目（如果有）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用之前 <xref:System.Windows.Navigation.NavigationService.GoForward%2A> ， <xref:System.Windows.Navigation.NavigationService.CanGoForward%2A> 可以检查属性以确定前进导航历史记录中是否存在条目。  
  
   
  
## Examples  
 下面的示例导航到前进导航历史记录中的最新条目（如果有）。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowForwardCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowforwardcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowForwardCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowforwardcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">如果前进导航历史记录中没有任何条目，则调用 <see cref="M:System.Windows.Navigation.NavigationService.GoForward" />。</exception>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoBack" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoBack" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LoadCompleted As LoadCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " Usage="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当已加载、分析并开始呈现目标导航内容时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.LoadCompleted>如果需要在加载完成时发现有关导航请求的相关信息，请处理。 此信息可从 <xref:System.Windows.Navigation.NavigationEventArgs> 传递给事件处理程序的对象中获得 <xref:System.Windows.Navigation.NavigationService.LoadCompleted> ，其中包括：  
  
-   内容及其 URI。  
  
-   导航器 (<xref:System.Windows.Navigation.NavigationWindow> ， <xref:System.Windows.Controls.Frame>) 。  
  
-   如果导航是通过调用或启动的，则为附加数据 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 。  
  
-   使用对象)  (的响应详细信息 <xref:System.Net.WebResponse> 。  
  
 <xref:System.Windows.Navigation.NavigationService.LoadCompleted> 当找不到或无法加载源页面时，不会引发，在这种情况下 <xref:System.Windows.Navigation.NavigationService.NavigationFailed> 会引发。  
  
> [!NOTE]
>  <xref:System.Windows.Navigation.NavigationService>引发时 <xref:System.Windows.Navigation.NavigationService.LoadCompleted> ，它还会引发 <xref:System.Windows.Application.LoadCompleted?displayProperty=nameWithType> 对象上的事件 <xref:System.Windows.Application> 。  
  
   
  
## Examples  
 下面的示例演示如何处理 <xref:System.Windows.Navigation.NavigationService.LoadCompleted> 。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowLoadCompletedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowloadcompletedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowLoadCompletedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowloadcompletedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Navigate">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>异步导航到指定的源内容。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (object root);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(object root) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (root As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(System::Object ^ root);" />
      <MemberSignature Language="F#" Value="member this.Navigate : obj -&gt; bool" Usage="navigationService.Navigate root" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="root">一个包含目标导航内容的对象。</param>
        <summary>异步导航到某个对象中包含的内容。</summary>
        <returns>如果未取消导航，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.Navigate%2A><xref:System.Object>如果满足以下条件，则将导航到指定的 `root` ：  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigating>事件未被取消。  
  
-    (的 web 请求，请参阅 <xref:System.Windows.Navigation.NavigationService.Navigating> 可以创建) 。  
  
 如果 `root` 为 `null` ，则清除现有内容 (<xref:System.Windows.Navigation.NavigationService.Content%2A>) 。  
  
> [!NOTE]
>  下载 Web 内容时，可能会收到 Web 异常 (例如，404：) 找不到文件。 你可以从处理此类异常 <xref:System.Windows.Navigation.NavigationService.NavigationFailed> 。  
  
   
  
## Examples  
 下面的示例演示如何导航到 <xref:System.Windows.Controls.Page> 包含源内容树的对象。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigateObjectCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigateobjectcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigateObjectCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigateobjectcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri -&gt; bool" Usage="navigationService.Navigate source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="source">使用所需内容的 URI 初始化的 <see cref="T:System.Uri" /> 对象。</param>
        <summary>异步导航到由 URI 指定的内容。</summary>
        <returns>如果未取消导航，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的值 `source` 可以是 Web [!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)] 或有效的 pack URI (参阅 [WPF 中的 pack uri](/dotnet/framework/wpf/app-development/pack-uris-in-wpf)) 。  
  
 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 如果满足以下条件，则将导航到指定的 URI `source` ：  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigating>事件未被取消。  
  
-    (的 web 请求，请参阅 <xref:System.Windows.Navigation.NavigationService.Navigating> 可以创建) 。  
  
 如果 `source` 为 `null` ，则清除现有内容 (<xref:System.Windows.Navigation.NavigationService.Content%2A>) 。  
  
> [!NOTE]
>  下载 Web 内容时，可能会收到 Web 异常 (例如，404：) 找不到文件。 你可以从处理此类异常 <xref:System.Windows.Navigation.NavigationService.NavigationFailed> 。  
  
 可以使用 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 导航到内容片段。 如果由 URI 标识的内容是当前内容，则不会再次下载。  
  
   
  
## Examples  
 下面的示例演示如何导航到 URI。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigateCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatecode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigateCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatecode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (object root, object navigationState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(object root, object navigationState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (root As Object, navigationState As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(System::Object ^ root, System::Object ^ navigationState);" />
      <MemberSignature Language="F#" Value="member this.Navigate : obj * obj -&gt; bool" Usage="navigationService.Navigate (root, navigationState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Object" />
        <Parameter Name="navigationState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="root">一个包含目标导航内容的对象。</param>
        <param name="navigationState">一个包含要在导航过程中进行处理的数据的对象。</param>
        <summary>异步导航某个对象包含的内容，并传递一个对象，其中包含要在导航过程中进行处理的数据。</summary>
        <returns>如果未取消导航，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>尽管传递对象而不是 URI，但此方法的行为与相同。  
  
   
  
## Examples  
 下面的示例演示如何导航到 <xref:System.Windows.Controls.Page> 包含源内容的对象和传递导航状态。  
  
 [!code-csharp[NavigationServiceNavigateObjectStateSnippets#MainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceNavigateObjectStateSnippets/CSharp/MainWindow.xaml.cs#mainwindowcode)]
 [!code-vb[NavigationServiceNavigateObjectStateSnippets#MainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceNavigateObjectStateSnippets/visualbasic/mainwindow.xaml.vb#mainwindowcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source, object navigationState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source, object navigationState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri, navigationState As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source, System::Object ^ navigationState);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri * obj -&gt; bool" Usage="navigationService.Navigate (source, navigationState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
        <Parameter Name="navigationState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">使用所需内容的 URI 初始化的 <see cref="T:System.Uri" /> 对象。</param>
        <param name="navigationState">一个包含要在导航过程中进行处理的数据的对象。</param>
        <summary>异步导航到位于某个 URI 中的源内容，并传递一个对象，其中包含要在导航过程中进行处理的数据。</summary>
        <returns>如果未取消导航，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由于导航是异步的，因此可以同时在多个导航中进行。 例如，如果一个页面上有两个子框架，则可以导航两个框架。 在这种情况下，可能会多次引发由引发的各种导航事件 <xref:System.Windows.Navigation.NavigationService> ，其中一个是正在导航到的每个内容片段，而不必按顺序请求。 因此，如果特定导航请求需要处理特定于单个请求的数据，则它不能使用可用于所有导航请求的数据。 相反，你可以使用 `navigationState` 来传递数据，以进行特定于一个导航请求的导航处理。  
  
 以下事件参数提供对导航状态的访问权限：  
  
-   <xref:System.Windows.Navigation.NavigatingCancelEventArgs.ExtraData%2A> (传递到 <xref:System.Windows.Navigation.NavigationService.Navigating> 事件) 。  
  
-   <xref:System.Windows.Navigation.NavigationEventArgs.ExtraData%2A> (传递到 <xref:System.Windows.Navigation.NavigationService.Navigated> ， <xref:System.Windows.Navigation.NavigationService.NavigationStopped> <xref:System.Windows.Navigation.NavigationService.LoadCompleted> 事件处理程序) 。  
  
   
  
## Examples  
 下面的示例演示了导航到 URI 和传递导航状态。  
  
 [!code-csharp[NavigationServiceNavigateUriStateSnippets#MainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceNavigateUriStateSnippets/CSharp/MainWindow.xaml.cs#mainwindowcode)]
 [!code-vb[NavigationServiceNavigateUriStateSnippets#MainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceNavigateUriStateSnippets/visualbasic/mainwindow.xaml.vb#mainwindowcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source, object navigationState, bool sandboxExternalContent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source, object navigationState, bool sandboxExternalContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri, navigationState As Object, sandboxExternalContent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source, System::Object ^ navigationState, bool sandboxExternalContent);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri * obj * bool -&gt; bool" Usage="navigationService.Navigate (source, navigationState, sandboxExternalContent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
        <Parameter Name="navigationState" Type="System.Object" />
        <Parameter Name="sandboxExternalContent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">使用所需内容的 URI 初始化的 <see cref="T:System.Uri" /> 对象。</param>
        <param name="navigationState">一个包含要在导航过程中进行处理的数据的对象。</param>
        <param name="sandboxExternalContent">将内容下载到部分信任的安全沙盒中（如果为 <see langword="true" />，则具有默认的 Internet 区域权限集）。 默认值为 <see langword="false" />。</param>
        <summary>异步导航到位于某个 URI 中的源内容，传递一个对象（其中包含在导航过程中进行处理的导航状态），并沙盒处理内容。</summary>
        <returns>如果未取消导航，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法仅适用于独立应用程序和 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 内容。  
  
 此方法的行为与相同 <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType> ，并通过确保正在下载的内容被置于默认 Internet 区域权限集的部分信任安全沙箱 (中来进行扩展，请参阅 [WPF 部分信任安全性](/dotnet/framework/wpf/wpf-partial-trust-security)) 。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigated As NavigatedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberSignature Language="F#" Value="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " Usage="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>找到导航的目标内容且可通过 <see cref="P:System.Windows.Navigation.NavigationService.Content" /> 属性得到这些内容时发生，即使尚未加载完毕也是如此。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.Navigated>如果需要在下载时发现有关导航请求的相关信息，可以处理。 此信息可从 <xref:System.Windows.Navigation.NavigationEventArgs> 传递给事件处理程序的对象中获得 <xref:System.Windows.Navigation.NavigationService.Navigated> ，其中包括：  
  
-   源页。 当 <xref:System.Windows.Navigation.NavigationService.Navigated> 引发时，至少已经分析了源页树的一部分 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] ，并将其附加到目标内容控件。  
  
-   请求的 URI。  
  
-   导航器 (<xref:System.Windows.Navigation.NavigationWindow> ， <xref:System.Windows.Controls.Frame>) 。  
  
-   如果导航是通过调用或启动的，则为附加数据 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 。  
  
-   使用对象)  (的响应详细信息 <xref:System.Net.WebResponse> 。  
  
 <xref:System.Windows.Navigation.NavigationService.Navigated> 当找不到或无法加载源页面时，不会引发，在这种情况下 <xref:System.Windows.Navigation.NavigationService.NavigationFailed> 会引发。  
  
> [!NOTE]
>  <xref:System.Windows.Navigation.NavigationService>引发时 <xref:System.Windows.Navigation.NavigationService.NavigationFailed> ，它还会引发 <xref:System.Windows.Application.NavigationFailed?displayProperty=nameWithType> 对象上的事件 <xref:System.Windows.Application> 。  
  
   
  
## Examples  
 下面的示例演示如何处理 <xref:System.Windows.Navigation.NavigationService.Navigated> 。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigatedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigatedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigating As NavigatingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberSignature Language="F#" Value="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " Usage="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>请求新导航时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.Navigating> 请求新导航时，但在请求源内容之前引发，包括：  
  
-   调用 <xref:System.Windows.Navigation.NavigationService.Navigate%2A>。  
  
-   <xref:System.Windows.Navigation.NavigationService.GoBack%2A> 或 <xref:System.Windows.Navigation.NavigationService.GoForward%2A> (调用或从导航) 中选择一个条目 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 。  
  
-   导航到内容片段。  
  
 <xref:System.Windows.Navigation.NavigationService.Navigating>如果需要在导航开始之前发现有关导航请求的相关信息，可以处理。 此信息可从 <xref:System.Windows.Navigation.NavigatingCancelEventArgs> 传递给事件处理程序的对象获取 <xref:System.Windows.Navigation.NavigationService.Navigating> 。  
  
 将 <xref:System.Net.WebRequest> 从参数创建和提供用于导航的对象 <xref:System.Windows.Navigation.NavigatingCancelEventArgs> ; 因为此时尚未发出实际请求，所以，如有必要，你可以重新配置该 <xref:System.Net.WebRequest> 对象。  
  
 <xref:System.Windows.Navigation.NavigatingCancelEventArgs>如果需要，还可以通过将设置为 true 来处理取消导航 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> 。 如果取消导航，则不会引发任何其他导航事件。  
  
> [!NOTE]
>  如果你的应用程序承载于浏览器中，则无法通过取消该事件阻止用户离开你的应用程序 <xref:System.Windows.Navigation.NavigationService.Navigating> 。  
  
 导航器导航到第一段内容后 (<xref:System.Windows.Navigation.NavigationWindow> ， <xref:System.Windows.Controls.Frame>) ，导航到的每个内容段都将添加到导航历史记录中。 如果需要保存有关要离开的内容的状态信息，可以通过设置对象将状态添加到该内容的日记条目 <xref:System.Windows.Navigation.NavigatingCancelEventArgs.ContentStateToSave%2A> <xref:System.Windows.Navigation.CustomContentState> 。  
  
> [!NOTE]
>  <xref:System.Windows.Navigation.NavigationService>引发时 <xref:System.Windows.Navigation.NavigationService.Navigating> ，它还会引发 <xref:System.Windows.Application.Navigating?displayProperty=nameWithType> 对象上的事件 <xref:System.Windows.Application> 。  
  
   
  
## Examples  
 下面的示例演示如何处理 <xref:System.Windows.Navigation.NavigationService.Navigating> 以检测是否发出了用于刷新静态内容的请求，如果是，则取消该请求。  
  
 <xref:System.Windows.Navigation.NavigationService.Navigating>.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigatingCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatingcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigatingCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatingcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationFailed As NavigationFailedEventHandler " FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberSignature Language="F#" Value="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " Usage="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationFailed As NavigationFailedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在导航到所请求内容出错时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在 <xref:System.Net.WebException> <xref:System.IO.IOException> 导航过程中引发了或，则会 <xref:System.Windows.Navigation.NavigationService.NavigationFailed> 引发事件。 <xref:System.Windows.Navigation.NavigationService.NavigationFailed> 传递了一个 <xref:System.Windows.Navigation.NavigationFailedEventArgs> ，它封装了有关异常的信息以及导致异常的导航的详细信息。  
  
 如果导航失败导致异常，且未处理，则会按列出的顺序引发以下事件：  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>.  
  
-   <xref:System.Windows.Controls.Frame.NavigationFailed?displayProperty=nameWithType> 或 <xref:System.Windows.Navigation.NavigationWindow.NavigationFailed?displayProperty=nameWithType>。  
  
-   <xref:System.Windows.Application.NavigationFailed?displayProperty=nameWithType>.  
  
-   <xref:System.Windows.Application.DispatcherUnhandledException>.  
  
 如果导航器 (<xref:System.Windows.Navigation.NavigationWindow> ， <xref:System.Windows.Controls.Frame>) 由一个或多个导航器承载， `NavigationFailed` 则不会对任何一个导航器引发。  
  
   
  
## Examples  
 下面的示例演示如何处理 <xref:System.Windows.Navigation.NavigationService.NavigationFailed> 。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationFailedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationfailedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationFailedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationfailedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationProgress As NavigationProgressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberSignature Language="F#" Value="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " Usage="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在下载过程中定期发生，用于提供定位进度信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> 传递了一个， <xref:System.Windows.Navigation.NavigationProgressEventArgs> 它公开了以下进度信息：  
  
-   到目前为止下载的字节数 (<xref:System.Windows.Navigation.NavigationProgressEventArgs.BytesRead%2A>) 。  
  
-   )  (下载的总字节数 <xref:System.Windows.Navigation.NavigationProgressEventArgs.MaxBytes%2A> 。  
  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> 对于下载的每个1024字节，将引发一次，如果剩余字节数不到1024字节，则会引发一次。 出于此原因，处理 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> 提供了一种有效的方法来跟踪和显示当前下载的进度。  
  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> 在某些情况下（例如，导航到相同的内容片段），或在当前加载的内容中导航到内容片段时，不会引发 (也就是说，属性的值 <xref:System.Windows.Navigation.NavigationService.Content%2A>) 。  
  
 导航到已编译的 XAML 资源时， <xref:System.Windows.Navigation.NavigationService.NavigationProgress> 可能不会引发最终事件。 这意味着，在下载结束时，最后报告的 <xref:System.Windows.Navigation.NavigationProgressEventArgs.BytesRead%2A> 值可能不等于 <xref:System.Windows.Navigation.NavigationProgressEventArgs.MaxBytes%2A> 值。 处理 <xref:System.Windows.Navigation.NavigationService.LoadCompleted> 导航完成后要通知的事件。  
  
> [!NOTE]
>  <xref:System.Windows.Navigation.NavigationService>引发时 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> ，它还会引发 <xref:System.Windows.Application.NavigationProgress?displayProperty=nameWithType> 对象上的事件 <xref:System.Windows.Application> 。  
  
   
  
## Examples  
 下面的示例演示如何处理 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> 。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationProgressCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationprogresscode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationProgressCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationprogresscode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationStopped As NavigationStoppedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberSignature Language="F#" Value="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " Usage="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在调用 <see cref="M:System.Windows.Navigation.NavigationService.StopLoading" /> 方法时发生，或者在当前导航正处于进行过程中时又请求一个新导航时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.NavigationStopped>如果需要在下载停止时发现有关导航请求的相关信息，可以处理。 此信息可从 <xref:System.Windows.Navigation.NavigationEventArgs> 传递给事件处理程序的对象中获得 <xref:System.Windows.Navigation.NavigationService.NavigationStopped> ，其中包括：  
  
-   请求的 URI。  
  
-   导航器 (<xref:System.Windows.Navigation.NavigationWindow> ， <xref:System.Windows.Controls.Frame>) 。  
  
-   如果导航是通过调用或启动的，则为附加数据 <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType> <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType> 。  
  
> [!NOTE]
>  <xref:System.Windows.Navigation.NavigationService>引发时 <xref:System.Windows.Navigation.NavigationService.NavigationStopped> ，它还会引发 <xref:System.Windows.Application.NavigationStopped?displayProperty=nameWithType> 对象上的事件 <xref:System.Windows.Application> 。  
  
   
  
## Examples  
 下面的示例演示如何处理 <xref:System.Windows.Navigation.NavigationService.NavigationStopped> 。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationStoppedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationstoppedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationStoppedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationstoppedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="navigationService.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>重新加载当前内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果) 的属性值指定的当前内容 (<xref:System.Windows.Navigation.NavigationService.Source%2A> 再次导航到，则 <xref:System.Windows.Navigation.NavigationService> 不会再次下载内容。 若要强制 <xref:System.Windows.Navigation.NavigationService> 重新导航到内容，请调用 <xref:System.Windows.Navigation.NavigationService.Refresh%2A> 。  
  
 请注意，如果再次导航到当前内容，无论是通过调用 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 还是 <xref:System.Windows.Navigation.NavigationService.Refresh%2A> ，都不会在导航历史记录中添加新条目。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
      </Docs>
    </Member>
    <Member MemberName="RemoveBackEntry">
      <MemberSignature Language="C#" Value="public System.Windows.Navigation.JournalEntry RemoveBackEntry ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Navigation.JournalEntry RemoveBackEntry() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.RemoveBackEntry" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveBackEntry () As JournalEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Navigation::JournalEntry ^ RemoveBackEntry();" />
      <MemberSignature Language="F#" Value="member this.RemoveBackEntry : unit -&gt; System.Windows.Navigation.JournalEntry" Usage="navigationService.RemoveBackEntry " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.JournalEntry</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>移除后退历史记录中的最新日记条目。</summary>
        <returns>后退导航历史记录中的最新 <see cref="T:System.Windows.Navigation.JournalEntry" />（如果有）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果两个或更多导航器 (<xref:System.Windows.Navigation.NavigationWindow> ， <xref:System.Windows.Controls.Frame>) 共享相同的导航历史记录，一个导航器可以使用该导航器 <xref:System.Windows.Navigation.NavigationService.RemoveBackEntry%2A> 来检索在另一个导航器中发生的导航的后退导航历史记录条目。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.AddBackEntry(System.Windows.Navigation.CustomContentState)" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public Uri Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Source { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : Uri with get, set" Usage="System.Windows.Navigation.NavigationService.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前内容的 URI，或当前正在导航到的新内容的 URI。</summary>
        <value>一个 <see cref="T:System.Uri" /> ，其中包含当前内容的 URI 或当前正在导航到的内容。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果将此属性设置为与当前所显示的 URI 不同的 URI，导航器 (<xref:System.Windows.Navigation.NavigationWindow> ， <xref:System.Windows.Controls.Frame>) 导航到指定的 uri。  
  
 <xref:System.Windows.Navigation.NavigationService.Source%2A> 设置为从导航到的 URI 加载的内容，除非取消导航。  
  
 <xref:System.Windows.Navigation.NavigationService.Source%2A> 可以使用仅分段 URI 进行设置，并且可以设置为 `null` 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StopLoading">
      <MemberSignature Language="C#" Value="public void StopLoading ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StopLoading() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.StopLoading" />
      <MemberSignature Language="VB.NET" Value="Public Sub StopLoading ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StopLoading();" />
      <MemberSignature Language="F#" Value="member this.StopLoading : unit -&gt; unit" Usage="navigationService.StopLoading " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>停止为当前导航请求下载更多内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.StopLoading%2A> 可在返回后立即调用 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> ，并停止正在子框架中进行的导航。  
  
 (<xref:System.Windows.Controls.Frame>).  
  
 调用 <xref:System.Windows.Navigation.NavigationService.StopLoading%2A> 方法会引发 <xref:System.Windows.Navigation.NavigationService.NavigationStopped> 事件。  
  
> [!NOTE]
>  <xref:System.Windows.Navigation.NavigationService.StopLoading%2A> 必须在启动导航的同一线程上调用。  
  
   
  
## Examples  
 下面的示例演示如何停止加载。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowStopLoadingCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowstoploadingcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowStopLoadingCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowstoploadingcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Navigation.NavigationService.Navigate" />
      </Docs>
    </Member>
  </Members>
</Type>
