<Type Name="NavigationService" FullName="System.Windows.Navigation.NavigationService">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c96aad543497c6bf57528ffde3a297cfa354eec6" /><Meta Name="ms.sourcegitcommit" Value="b6b9d5f3f9c7eb43f14a8a1a68d044603cb8ed73" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/18/2020" /><Meta Name="ms.locfileid" Value="83521631" /></Metadata><TypeSignature Language="C#" Value="public sealed class NavigationService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit NavigationService extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Navigation.NavigationService" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class NavigationService" />
  <TypeSignature Language="C++ CLI" Value="public ref class NavigationService sealed" />
  <TypeSignature Language="F#" Value="type NavigationService = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>包含支持导航的各种方法、属性和事件。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService> 封装了在浏览器样式的导航上下文内下载内容的功能。  
  
 内容可以是任何类型的 .NET Framework 对象和 HTML 文件。 但一般情况下，页面是为导航导航内容而首选的方式（请参阅 <xref:System.Windows.Controls.Page>）。  
  
 可以通过提供对象的实例并调用接受对象的 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 方法的重载来导航内容：  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Object%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Object%2CSystem.Object%29?displayProperty=nameWithType>  
  
 或者，通过将相对或绝对 URI 传递到接受 URI 的 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 方法重载之一，可以导航到内容：  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%2CSystem.Object%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%2CSystem.Object%2CSystem.Boolean%29?displayProperty=nameWithType>  
  
 按 URI 导航到内容后，<xref:System.Windows.Navigation.NavigationService> 将返回包含内容的对象。  
  
 导航的生存期可通过以下事件进行跟踪：  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigating>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigated>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationProgress>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationFailed>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationStopped>  
  
-   <xref:System.Windows.Navigation.NavigationService.LoadCompleted>  
  
-   <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 列中的一个值匹配。  
  
 并非每次发生导航时都会引发所有事件;引发的事件集由发生的导航类型（内容或内容片段）以及导航完成方式（取消、停止或失败）决定。  
  
 下图说明了引发这些事件的顺序：  
  
 ![页面导航流程图](~/add/media/navigationoverviewfigure11.png "页面导航流程图")  
  
 导航期间或之后 <xref:System.Windows.Navigation.NavigationService> 提供有关要导航到的内容的信息，包括要导航到的内容的 URI （<xref:System.Windows.Navigation.NavigationService.Source%2A>）、当前内容的 URI （<xref:System.Windows.Navigation.NavigationService.CurrentSource%2A>）以及包含导航到的内容的对象（<xref:System.Windows.Navigation.NavigationService.Content%2A>）。  
  
 导航至内容时，<xref:System.Windows.Navigation.NavigationService> 会将导航记录为导航历史记录中的条目。 当出现新的导航时，通过调用 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 方法，或者通过调用 <xref:System.Windows.Navigation.NavigationService.GoForward%2A>导航到前进导航历史记录中的条目，可以将条目添加到后退导航历史记录中。 通过导航到后退导航历史记录中的条目（通过调用 <xref:System.Windows.Navigation.NavigationService.GoBack%2A>），将条目添加到前进导航历史记录中。 <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A> 和 <xref:System.Windows.Navigation.NavigationService.CanGoForward%2A> 报告后退和前进导航历史记录中是否分别存在条目。 此外，可以通过调用 <xref:System.Windows.Navigation.NavigationService.RemoveBackEntry%2A>来删除后退导航历史记录中的最新条目。  
  
 默认情况下，<xref:System.Windows.Navigation.NavigationService> 不会在导航历史记录中存储内容对象的实例。 相反，每次使用导航历史记录导航到内容对象时，<xref:System.Windows.Navigation.NavigationService> 都将创建该对象的新实例。 此行为旨在避免在将大量内容导航到时消耗过多的内存。 因此，不会从一个导航到下一个导航来记住内容的状态。 不过，WPF 提供了多种方法，通过这些方法，你可以在导航历史记录中存储一段内容的状态。  
  
 使用 <xref:System.Windows.Navigation.NavigationService.AddBackEntry%2A>，还可以记住单个页面实例的多个状态集。  
  
 <xref:System.Windows.Navigation.NavigationService> 是 `sealed` 类，因此不能进行实例化;相反，导航器使用 <xref:System.Windows.Navigation.NavigationService> 来启用导航。 在 WPF 中，有两个导航器： <xref:System.Windows.Navigation.NavigationWindow> 和 <xref:System.Windows.Controls.Frame>。  
  
 直观地 [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] 使用 [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] 导航器来提供集成的用户体验。 然而，实际上 [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] 将 <xref:System.Windows.Navigation.NavigationWindow> 用作导航器;在 [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] 中运行的 [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] 的 <xref:System.Windows.Application.MainWindow%2A> 属性将返回对 <xref:System.Windows.Navigation.NavigationWindow>的引用，并且由 <xref:System.Windows.Navigation.NavigationWindow> 管理的导航历史记录与通过以下方式管理的导航历史记录集成：[!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)]  
  
-   通过从 [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] 中调用 <xref:System.Windows.Navigation.NavigationService.Navigate%2A>、<xref:System.Windows.Navigation.NavigationService.GoBack%2A>和 <xref:System.Windows.Navigation.NavigationService.GoForward%2A> 导航到内容时，还会将相关导航历史记录项添加到 [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] 导航历史记录中。  
  
-   选择 [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] 导航 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 中的项时，[!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] 会使 <xref:System.Windows.Navigation.NavigationService> 向后导航到与这些项关联的内容。  
  
> [!NOTE]
>  <xref:System.Windows.Controls.Frame> 可以提供自己的导航历史记录，也可以使用托管它的导航器的导航历史记录。 如果 <xref:System.Windows.Controls.Frame> 提供其自己的导航历史记录，则可以在导航历史记录中的条目中显示其自己的导航 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)];这些项不会添加到宿主导航器的导航历史记录（<xref:System.Windows.Navigation.NavigationWindow>、<xref:System.Windows.Controls.Frame>、[!INCLUDE[TLA2#tla_iegeneric](~/includes/tla2sharptla-iegeneric-md.md)]），因此，无法从每个项的导航 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 中导航到它们（请参阅 <xref:System.Windows.Controls.Frame.JournalOwnership%2A>）。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddBackEntry">
      <MemberSignature Language="C#" Value="public void AddBackEntry (System.Windows.Navigation.CustomContentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBackEntry(class System.Windows.Navigation.CustomContentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.AddBackEntry(System.Windows.Navigation.CustomContentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBackEntry (state As CustomContentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBackEntry(System::Windows::Navigation::CustomContentState ^ state);" />
      <MemberSignature Language="F#" Value="member this.AddBackEntry : System.Windows.Navigation.CustomContentState -&gt; unit" Usage="navigationService.AddBackEntry state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Navigation.CustomContentState" />
      </Parameters>
      <Docs>
        <param name="state">一个 <see cref="T:System.Windows.Navigation.CustomContentState" /> 对象，该对象表示与特定内容片段关联的应用程序定义的状态。</param>
        <summary>向包含 <see cref="T:System.Windows.Navigation.CustomContentState" /> 对象的后退导航历史记录中添加一个条目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.AddBackEntry%2A>、<xref:System.Windows.Navigation.CustomContentState>和 <xref:System.Windows.Navigation.IProvideCustomContentState> 可用于帮助记住当前内容的多个状态集。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="state" /> 为 <see langword="null" />，并且 <see cref="T:System.Windows.Navigation.CustomContentState" /> 对象不是从 <see cref="M:System.Windows.Navigation.IProvideCustomContentState.GetContentState" /> 返回的对象。</exception>
        <altmember cref="M:System.Windows.Navigation.NavigationService.RemoveBackEntry" />
      </Docs>
    </Member>
    <Member MemberName="CanGoBack">
      <MemberSignature Language="C#" Value="public bool CanGoBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoBack" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CanGoBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoBack { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanGoBack : bool" Usage="System.Windows.Navigation.NavigationService.CanGoBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示后退导航历史记录中是否至少有一个条目。</summary>
        <value>如果后退导航历史记录中至少具有一个条目，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A> 确定后退导航历史记录中是否至少有一个条目。 调用 <xref:System.Windows.Navigation.NavigationService.GoBack%2A>之前应对此属性进行检查;如果调用 <xref:System.Windows.Navigation.NavigationService.GoBack%2A> 并且后退导航历史记录中没有任何条目，则会引发 <xref:System.InvalidOperationException>。  
  
> [!NOTE]
>  如果导航历史记录由多个导航器共享（<xref:System.Windows.Navigation.NavigationWindow>、<xref:System.Windows.Controls.Frame>），则当前导航器的 <xref:System.Windows.Navigation.NavigationService> 可能未添加后退导航历史记录中的最新条目。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoForward" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoForward" />
      </Docs>
    </Member>
    <Member MemberName="CanGoForward">
      <MemberSignature Language="C#" Value="public bool CanGoForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CanGoForward" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoForward As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoForward { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanGoForward : bool" Usage="System.Windows.Navigation.NavigationService.CanGoForward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示前进导航历史记录中是否至少有一个条目。</summary>
        <value>如果前进导航历史记录中至少具有一个条目，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.CanGoForward%2A> 确定前进导航历史记录中是否至少有一个条目。 调用 <xref:System.Windows.Navigation.NavigationService.GoForward%2A>之前应对此属性进行检查;如果调用 <xref:System.Windows.Navigation.NavigationService.GoForward%2A> 且前进导航历史记录中没有任何条目，则会引发 <xref:System.InvalidOperationException>。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoBack" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoBack" />
      </Docs>
    </Member>
    <Member MemberName="Content">
      <MemberSignature Language="C#" Value="public object Content { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Content" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.Content" />
      <MemberSignature Language="VB.NET" Value="Public Property Content As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Content { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Content : obj with get, set" Usage="System.Windows.Navigation.NavigationService.Content" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置对包含当前内容的对象的引用。</summary>
        <value>一个对象，它是对包含当前内容的对象的引用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以通过以下两种方式之一设置内容：  
  
-   直接将它设置为对对象的引用。  
  
-   通过调用 <xref:System.Windows.Navigation.NavigationService.Navigate%2A>、<xref:System.Windows.Navigation.NavigationService.GoBack%2A>或 <xref:System.Windows.Navigation.NavigationService.GoForward%2A>，间接调用。  
  
 设置 <xref:System.Windows.Navigation.NavigationService> 会启动新导航;由于导航是异步的，因此如果在设置后立即检查，<xref:System.Windows.Navigation.NavigationService.Content%2A> 不会返回值。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Navigation.NavigationService.Navigate" />
      </Docs>
    </Member>
    <Member MemberName="CurrentSource">
      <MemberSignature Language="C#" Value="public Uri CurrentSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri CurrentSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CurrentSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentSource As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ CurrentSource { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentSource : Uri" Usage="System.Windows.Navigation.NavigationService.CurrentSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取上次导航到的内容的 URI。</summary>
        <value>如果使用 URI 导航到，则为上次导航到的内容的 <see cref="T:System.Uri" />;否则，<see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在成功完成导航到不同的 URI 之前，不会更改 <xref:System.Windows.Navigation.NavigationService.CurrentSource%2A> 属性的值。  
  
 可以使用只包含片段的 URI 设置 <xref:System.Windows.Navigation.NavigationService.CurrentSource%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FragmentNavigation As FragmentNavigationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberSignature Language="F#" Value="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " Usage="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当开始导航到某个内容片段时发生，如果所需片段位于当前内容中，它会立即发生；或者，如果所需片段位于不同内容中，它会在加载了源 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 内容之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，内容片段是命名 <xref:System.Windows.UIElement>包含的内容，该名称是设置 <xref:System.Windows.FrameworkElement.Name%2A> 属性的 <xref:System.Windows.UIElement>，例如：  
  
```  
<TextBlock Name="FragmentName">...</TextBlock>  
```  
  
 通过提供具有以下格式的后缀的 URI 导航到 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 片段：  
  
 \#*FragmentName*  
  
 下面显示了引用内容片段的 URI 示例：  
  
 `http://www.microsoft.com/targetpage.xaml#FragmentName`  
  
 加载源页面后（引发 <xref:System.Windows.Navigation.NavigationService.LoadCompleted> 事件之后），片段导航开始，<xref:System.Windows.Navigation.NavigationService> 尝试查找 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 片段。 如果找到 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 片段，则 <xref:System.Windows.Navigation.NavigationService> 指示内容导航器（<xref:System.Windows.Navigation.NavigationWindow>，<xref:System.Windows.Controls.Frame>）显示片段。 如果需要更改此行为，您可以处理 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 以提供您自己的片段导航行为。 向 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 传递了一个 <xref:System.Windows.Navigation.FragmentNavigationEventArgs> 参数，该参数将公开有助于此目的的属性，包括：  
  
-   拥有此导航服务的导航器（<xref:System.Windows.Navigation.NavigationWindow>、<xref:System.Windows.Controls.Frame>）。  
  
-   片段名称。  
  
 您可以处理 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 以通过您自己的自定义实现来重写默认的 WPF 片段实现。 如果这样做，则需要将 <xref:System.Windows.Navigation.FragmentNavigationEventArgs.Handled%2A> 设置为 `true`;否则，将应用默认的 WPF 片断处理行为。  
  
 应避免直接从 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 事件处理程序中启动导航。 由于 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 是在现有导航期间引发的，因此从 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 事件处理程序启动新导航会创建一个嵌套的导航，从而导致 <xref:System.ExecutionEngineException> 引发。 相反，你可以通过使用 <xref:System.Windows.Threading.Dispatcher>创建异步工作项来间接启动导航。  
  
> [!NOTE]
>  当 <xref:System.Windows.Navigation.NavigationService> 引发 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation>时，它还会引发 <xref:System.Windows.Application> 对象上 <xref:System.Windows.Application.FragmentNavigation?displayProperty=nameWithType> 事件。  
  
> [!IMPORTANT]
>  在以下情况下，不支持片段导航 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 页面（带有 `Page` 作为根元素的仅标记 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 文件）：  
>   
>  •导航到松散 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 页面中的片段。  
>   
>  •从松散 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 页面导航到另一个松散 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 页面中的片段。  
>   
>  但是，松 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 页面可以导航到其自己的片段。  
  
   
  
## Examples  
 下面的示例演示如何处理 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 以提供自定义片段导航行为。 在这种情况下，如果找不到 "源 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]" 页中的片段，该示例将 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 页打开错误。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowFragmentNavigationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowfragmentnavigationcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowFragmentNavigationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowfragmentnavigationcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetNavigationService">
      <MemberSignature Language="C#" Value="public static System.Windows.Navigation.NavigationService GetNavigationService (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Navigation.NavigationService GetNavigationService(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GetNavigationService(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNavigationService (dependencyObject As DependencyObject) As NavigationService" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Navigation::NavigationService ^ GetNavigationService(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="static member GetNavigationService : System.Windows.DependencyObject -&gt; System.Windows.Navigation.NavigationService" Usage="System.Windows.Navigation.NavigationService.GetNavigationService dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationService</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">由导航器承载的内容中的 <see cref="T:System.Windows.DependencyObject" />。</param>
        <summary>获取对导航器的 <see cref="T:System.Windows.Navigation.NavigationService" /> 的引用，该导航器的内容中包含指定的 <see cref="T:System.Windows.DependencyObject" />。</summary>
        <returns>对导航器（该导航器的内容中包含指定的 <see cref="T:System.Windows.DependencyObject" />）的 <see cref="T:System.Windows.Navigation.NavigationService" /> 的引用在某些情况下可以为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 导航器具有处理内容导航的 <xref:System.Windows.Navigation.NavigationService>。 WPF 有两个导航器： <xref:System.Windows.Navigation.NavigationWindow> 和 <xref:System.Windows.Controls.Frame>。 为了处理导航请求和管理导航生存期，导航器使用 WPF 导航服务，该服务作为 <xref:System.Windows.Navigation.NavigationService> 类实现。 导航器承载的内容可以通过调用 <xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A> 方法来获取对导航器的 <xref:System.Windows.Navigation.NavigationService> 的引用。  
  
 `dependencyObject`时，<xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A> 返回 `null`：  
  
-   是 <xref:System.Windows.Navigation.NavigationWindow>。  
  
-   <xref:System.Windows.Controls.Frame>：  
  
    1.  由另一导航器承载。  
  
    2.  <xref:System.Windows.Controls.Frame.JournalOwnership%2A> 属性设置为 <xref:System.Windows.Navigation.JournalOwnership.UsesParentJournal>。  
  
-   不是由导航器承载的内容的一部分。  
  
 WPF 提供了两个快捷方式，用于获取对 <xref:System.Windows.Navigation.NavigationService>的引用：  
  
-   处理到 <xref:System.Windows.Controls.Page> 的导航的 <xref:System.Windows.Navigation.NavigationService> 可以通过获取其 <xref:System.Windows.Controls.Page.NavigationService%2A?displayProperty=nameWithType> 属性的值从 <xref:System.Windows.Controls.Page> 本身进行访问。  
  
-   可以通过获取 <xref:System.Windows.Controls.Frame.NavigationService%2A> 属性的值来访问用于处理导航的 <xref:System.Windows.Controls.Frame> 的 <xref:System.Windows.Navigation.NavigationService>。  
  
   
  
## Examples  
 下面的示例演示如何通过调用 <xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A>来检索导航服务 <xref:System.Windows.Controls.UserControl>。  
  
 [!code-csharp[NSGetNavigationServiceSnippets#GetNavigationServiceCODE1](~/samples/snippets/csharp/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/CSharp/ContentUserControl.xaml.cs#getnavigationservicecode1)]
 [!code-vb[NSGetNavigationServiceSnippets#GetNavigationServiceCODE1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/visualbasic/contentusercontrol.xaml.vb#getnavigationservicecode1)]  
[!code-csharp[NSGetNavigationServiceSnippets#GetNavigationServiceCODE2](~/samples/snippets/csharp/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/CSharp/ContentUserControl.xaml.cs#getnavigationservicecode2)]
[!code-vb[NSGetNavigationServiceSnippets#GetNavigationServiceCODE2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/visualbasic/contentusercontrol.xaml.vb#getnavigationservicecode2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dependencyObject" /> 参数为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GoBack">
      <MemberSignature Language="C#" Value="public void GoBack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoBack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GoBack" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoBack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoBack();" />
      <MemberSignature Language="F#" Value="member this.GoBack : unit -&gt; unit" Usage="navigationService.GoBack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>导航到后退导航历史记录中的最新条目（如果有）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用 <xref:System.Windows.Navigation.NavigationService.GoBack%2A>之前，可以检查 <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A> 属性，以确定后退导航历史记录中是否存在条目。  
  
   
  
## Examples  
 下面的示例导航到后退导航历史记录中的最新条目（如果有）。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowBackCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowbackcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowBackCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowbackcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在调用 <see cref="M:System.Windows.Navigation.NavigationService.GoBack" /> 时后退导航历史记录中没有条目。</exception>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoForward" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoForward" />
      </Docs>
    </Member>
    <Member MemberName="GoForward">
      <MemberSignature Language="C#" Value="public void GoForward ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoForward() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GoForward" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoForward ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoForward();" />
      <MemberSignature Language="F#" Value="member this.GoForward : unit -&gt; unit" Usage="navigationService.GoForward " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>导航到前进导航历史记录中的最新条目（如果有）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用 <xref:System.Windows.Navigation.NavigationService.GoForward%2A>之前，可以检查 <xref:System.Windows.Navigation.NavigationService.CanGoForward%2A> 属性，以确定前进导航历史记录中是否存在条目。  
  
   
  
## Examples  
 下面的示例导航到前进导航历史记录中的最新条目（如果有）。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowForwardCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowforwardcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowForwardCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowforwardcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">如果前进导航历史记录中没有任何条目，则调用 <see cref="M:System.Windows.Navigation.NavigationService.GoForward" />。</exception>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoBack" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoBack" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LoadCompleted As LoadCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " Usage="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当已加载、分析并开始呈现目标导航内容时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果需要在加载完成时发现有关导航请求的相关信息，请处理 <xref:System.Windows.Navigation.NavigationService.LoadCompleted>。 此信息可从传递到 <xref:System.Windows.Navigation.NavigationService.LoadCompleted> 事件处理程序的 <xref:System.Windows.Navigation.NavigationEventArgs> 对象中获得，其中包括：  
  
-   内容及其 URI。  
  
-   导航器（<xref:System.Windows.Navigation.NavigationWindow><xref:System.Windows.Controls.Frame>）。  
  
-   如果通过调用 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 或 <xref:System.Windows.Navigation.NavigationService.Navigate%2A>启动导航，则为附加数据。  
  
-   响应详细信息（使用 <xref:System.Net.WebResponse> 对象）。  
  
 当未能找到或加载源页面时，不会引发 <xref:System.Windows.Navigation.NavigationService.LoadCompleted>，在这种情况下，会引发 <xref:System.Windows.Navigation.NavigationService.NavigationFailed>。  
  
> [!NOTE]
>  当 <xref:System.Windows.Navigation.NavigationService> 引发 <xref:System.Windows.Navigation.NavigationService.LoadCompleted>时，它还会引发 <xref:System.Windows.Application> 对象上 <xref:System.Windows.Application.LoadCompleted?displayProperty=nameWithType> 事件。  
  
   
  
## Examples  
 下面的示例演示如何处理 <xref:System.Windows.Navigation.NavigationService.LoadCompleted>。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowLoadCompletedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowloadcompletedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowLoadCompletedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowloadcompletedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Navigate">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>异步导航到指定的源内容。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (object root);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(object root) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (root As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(System::Object ^ root);" />
      <MemberSignature Language="F#" Value="member this.Navigate : obj -&gt; bool" Usage="navigationService.Navigate root" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="root">一个包含目标导航内容的对象。</param>
        <summary>异步导航到某个对象中包含的内容。</summary>
        <returns>如果未取消导航，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果满足以下条件，<xref:System.Windows.Navigation.NavigationService.Navigate%2A> 将导航到 `root` 指定的 <xref:System.Object>：  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigating> 事件未取消。  
  
-   可以创建 web 请求（请参阅 <xref:System.Windows.Navigation.NavigationService.Navigating>）。  
  
 如果 `null``root`，则会清除现有内容（<xref:System.Windows.Navigation.NavigationService.Content%2A>）。  
  
> [!NOTE]
>  下载 Web 内容时，可能会收到 Web 异常（例如，404：找不到文件）。 可以从 <xref:System.Windows.Navigation.NavigationService.NavigationFailed>处理此类异常。  
  
   
  
## Examples  
 下面的示例演示如何导航到包含源内容树的 <xref:System.Windows.Controls.Page> 对象。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigateObjectCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigateobjectcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigateObjectCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigateobjectcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri -&gt; bool" Usage="navigationService.Navigate source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="source">使用所需内容的 URI 初始化的 <see cref="T:System.Uri" /> 对象。</param>
        <summary>异步导航到由 URI 指定的内容。</summary>
        <returns>如果未取消导航，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `source` 的值可以是 Web [!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)] 或有效的 pack URI （请参阅[WPF 中的 Pack uri](~/docs/framework/wpf/app-development/pack-uris-in-wpf.md)）。  
  
 如果满足以下条件，<xref:System.Windows.Navigation.NavigationService.Navigate%2A> 将导航到 `source` 指定的 URI：  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigating> 事件未取消。  
  
-   可以创建 web 请求（请参阅 <xref:System.Windows.Navigation.NavigationService.Navigating>）。  
  
 如果 `null``source`，则会清除现有内容（<xref:System.Windows.Navigation.NavigationService.Content%2A>）。  
  
> [!NOTE]
>  下载 Web 内容时，可能会收到 Web 异常（例如，404：找不到文件）。 可以从 <xref:System.Windows.Navigation.NavigationService.NavigationFailed>处理此类异常。  
  
 您可以使用 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 导航到内容片段。 如果由 URI 标识的内容是当前内容，则不会再次下载。  
  
   
  
## Examples  
 下面的示例演示如何导航到 URI。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigateCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatecode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigateCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatecode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (object root, object navigationState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(object root, object navigationState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (root As Object, navigationState As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(System::Object ^ root, System::Object ^ navigationState);" />
      <MemberSignature Language="F#" Value="member this.Navigate : obj * obj -&gt; bool" Usage="navigationService.Navigate (root, navigationState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Object" />
        <Parameter Name="navigationState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="root">一个包含目标导航内容的对象。</param>
        <param name="navigationState">一个包含要在导航过程中进行处理的数据的对象。</param>
        <summary>异步导航某个对象包含的内容，并传递一个对象，其中包含要在导航过程中进行处理的数据。</summary>
        <returns>如果未取消导航，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管传递对象而不是 URI，此方法与 <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>具有相同的行为。  
  
   
  
## Examples  
 下面的示例演示如何导航到包含源内容并传递导航状态的 <xref:System.Windows.Controls.Page> 对象。  
  
 [!code-csharp[NavigationServiceNavigateObjectStateSnippets#MainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceNavigateObjectStateSnippets/CSharp/MainWindow.xaml.cs#mainwindowcode)]
 [!code-vb[NavigationServiceNavigateObjectStateSnippets#MainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceNavigateObjectStateSnippets/visualbasic/mainwindow.xaml.vb#mainwindowcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source, object navigationState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source, object navigationState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri, navigationState As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source, System::Object ^ navigationState);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri * obj -&gt; bool" Usage="navigationService.Navigate (source, navigationState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
        <Parameter Name="navigationState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">使用所需内容的 URI 初始化的 <see cref="T:System.Uri" /> 对象。</param>
        <param name="navigationState">一个包含要在导航过程中进行处理的数据的对象。</param>
        <summary>异步导航到位于某个 URI 中的源内容，并传递一个对象，其中包含要在导航过程中进行处理的数据。</summary>
        <returns>如果未取消导航，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由于导航是异步的，因此可以同时在多个导航中进行。 例如，如果一个页面上有两个子框架，则可以导航两个框架。 在这种情况下，可能会多次引发 <xref:System.Windows.Navigation.NavigationService> 引发的各种导航事件，每个导航事件对应于要导航到的每个内容片段，而不必按顺序请求导航。 因此，如果特定导航请求需要处理特定于单个请求的数据，则它不能使用可用于所有导航请求的数据。 相反，你可以使用 `navigationState` 来传递数据，以进行特定于一个导航请求的导航处理。  
  
 以下事件参数提供对导航状态的访问权限：  
  
-   <xref:System.Windows.Navigation.NavigatingCancelEventArgs.ExtraData%2A> （传递到 <xref:System.Windows.Navigation.NavigationService.Navigating> 事件）。  
  
-   <xref:System.Windows.Navigation.NavigationEventArgs.ExtraData%2A> （传递到 <xref:System.Windows.Navigation.NavigationService.Navigated>、<xref:System.Windows.Navigation.NavigationService.NavigationStopped><xref:System.Windows.Navigation.NavigationService.LoadCompleted> 事件处理程序）。  
  
   
  
## Examples  
 下面的示例演示了导航到 URI 和传递导航状态。  
  
 [!code-csharp[NavigationServiceNavigateUriStateSnippets#MainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceNavigateUriStateSnippets/CSharp/MainWindow.xaml.cs#mainwindowcode)]
 [!code-vb[NavigationServiceNavigateUriStateSnippets#MainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceNavigateUriStateSnippets/visualbasic/mainwindow.xaml.vb#mainwindowcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source, object navigationState, bool sandboxExternalContent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source, object navigationState, bool sandboxExternalContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri, navigationState As Object, sandboxExternalContent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source, System::Object ^ navigationState, bool sandboxExternalContent);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri * obj * bool -&gt; bool" Usage="navigationService.Navigate (source, navigationState, sandboxExternalContent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
        <Parameter Name="navigationState" Type="System.Object" />
        <Parameter Name="sandboxExternalContent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">使用所需内容的 URI 初始化的 <see cref="T:System.Uri" /> 对象。</param>
        <param name="navigationState">一个包含要在导航过程中进行处理的数据的对象。</param>
        <param name="sandboxExternalContent">将内容下载到部分信任的安全沙盒中（如果为 <see langword="true" />，则具有默认的 Internet 区域权限集）。 默认为 <see langword="false" />。</param>
        <summary>异步导航到位于某个 URI 中的源内容，传递一个对象（其中包含在导航过程中进行处理的导航状态），并沙盒处理内容。</summary>
        <returns>如果未取消导航，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法仅适用于独立应用程序和 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 内容。  
  
 此方法与 <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>的行为相同，并通过确保正在下载的内容放入部分信任的安全沙盒（具有默认的 Internet 区域权限集，请参阅[WPF 部分信任安全性](~/docs/framework/wpf/wpf-partial-trust-security.md)）来扩展此方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigated As NavigatedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberSignature Language="F#" Value="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " Usage="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>找到导航的目标内容且可通过 <see cref="P:System.Windows.Navigation.NavigationService.Content" /> 属性得到这些内容时发生，即使尚未加载完毕也是如此。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果需要在下载时发现有关导航请求的相关信息，请处理 <xref:System.Windows.Navigation.NavigationService.Navigated>。 此信息可从传递到 <xref:System.Windows.Navigation.NavigationService.Navigated> 事件处理程序的 <xref:System.Windows.Navigation.NavigationEventArgs> 对象中获得，其中包括：  
  
-   源页。 如果 <xref:System.Windows.Navigation.NavigationService.Navigated> 引发，则至少已分析源页的 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 树的一部分，并将其附加到目标内容控件。  
  
-   请求的 URI。  
  
-   导航器（<xref:System.Windows.Navigation.NavigationWindow><xref:System.Windows.Controls.Frame>）。  
  
-   如果通过调用 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 或 <xref:System.Windows.Navigation.NavigationService.Navigate%2A>启动导航，则为附加数据。  
  
-   响应详细信息（使用 <xref:System.Net.WebResponse> 对象）。  
  
 当未能找到或加载源页面时，不会引发 <xref:System.Windows.Navigation.NavigationService.Navigated>，在这种情况下，会引发 <xref:System.Windows.Navigation.NavigationService.NavigationFailed>。  
  
> [!NOTE]
>  当 <xref:System.Windows.Navigation.NavigationService> 引发 <xref:System.Windows.Navigation.NavigationService.NavigationFailed>时，它还会引发 <xref:System.Windows.Application> 对象上 <xref:System.Windows.Application.NavigationFailed?displayProperty=nameWithType> 事件。  
  
   
  
## Examples  
 下面的示例演示如何处理 <xref:System.Windows.Navigation.NavigationService.Navigated>。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigatedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigatedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigating As NavigatingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberSignature Language="F#" Value="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " Usage="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>请求新导航时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请求新导航时，但在请求源内容之前，将会引发 <xref:System.Windows.Navigation.NavigationService.Navigating>，包括：  
  
-   调用 <xref:System.Windows.Navigation.NavigationService.Navigate%2A>。  
  
-   调用 <xref:System.Windows.Navigation.NavigationService.GoBack%2A> 或 <xref:System.Windows.Navigation.NavigationService.GoForward%2A> （或从导航 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]中选择一个条目）。  
  
-   导航到内容片段。  
  
 如果需要在导航开始之前发现有关导航请求的相关信息，请处理 <xref:System.Windows.Navigation.NavigationService.Navigating>。 传递到 <xref:System.Windows.Navigation.NavigationService.Navigating> 事件处理程序的 <xref:System.Windows.Navigation.NavigatingCancelEventArgs> 对象中提供了此信息。  
  
 将从 <xref:System.Windows.Navigation.NavigatingCancelEventArgs> 参数创建并提供导航的 <xref:System.Net.WebRequest> 对象;由于此时尚未发出实际请求，因此可以根据需要重新配置 <xref:System.Net.WebRequest> 对象。  
  
 如果需要，还可以通过将 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> 设置为 true 来处理 <xref:System.Windows.Navigation.NavigatingCancelEventArgs> 取消导航。 如果取消导航，则不会引发任何其他导航事件。  
  
> [!NOTE]
>  如果你的应用程序承载于浏览器中，则无法通过取消 <xref:System.Windows.Navigation.NavigationService.Navigating> 事件阻止用户离开你的应用程序。  
  
 导航器导航到第一条内容（<xref:System.Windows.Navigation.NavigationWindow>、<xref:System.Windows.Controls.Frame>）后，导航到的每个内容将添加到导航历史记录中。 如果需要保存有关要离开的内容的状态信息，可以通过将 <xref:System.Windows.Navigation.NavigatingCancelEventArgs.ContentStateToSave%2A> 设置为 <xref:System.Windows.Navigation.CustomContentState> 对象，将状态添加到该内容的日记条目。  
  
> [!NOTE]
>  当 <xref:System.Windows.Navigation.NavigationService> 引发 <xref:System.Windows.Navigation.NavigationService.Navigating>时，它还会引发 <xref:System.Windows.Application> 对象上 <xref:System.Windows.Application.Navigating?displayProperty=nameWithType> 事件。  
  
   
  
## Examples  
 下面的示例演示如何处理 <xref:System.Windows.Navigation.NavigationService.Navigating> 以检测是否发出了用于刷新静态内容的请求，如果是，则取消请求。  
  
 <xref:System.Windows.Navigation.NavigationService.Navigating> 列中的一个值匹配。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigatingCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatingcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigatingCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatingcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationFailed As NavigationFailedEventHandler " FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberSignature Language="F#" Value="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " Usage="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationFailed As NavigationFailedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在导航到所请求内容出错时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在导航过程中引发 <xref:System.Net.WebException> 或 <xref:System.IO.IOException> 时，将引发 <xref:System.Windows.Navigation.NavigationService.NavigationFailed> 事件。 向 <xref:System.Windows.Navigation.NavigationService.NavigationFailed> 传递了一个 <xref:System.Windows.Navigation.NavigationFailedEventArgs>，它封装有关引发异常的异常和导航的详细信息。  
  
 如果导航失败导致异常，且未处理，则会按列出的顺序引发以下事件：  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType> 列中的一个值匹配。  
  
-   <xref:System.Windows.Controls.Frame.NavigationFailed?displayProperty=nameWithType> 或 <xref:System.Windows.Navigation.NavigationWindow.NavigationFailed?displayProperty=nameWithType>。  
  
-   <xref:System.Windows.Application.NavigationFailed?displayProperty=nameWithType> 列中的一个值匹配。  
  
-   <xref:System.Windows.Application.DispatcherUnhandledException> 列中的一个值匹配。  
  
 如果导航器（<xref:System.Windows.Navigation.NavigationWindow>、<xref:System.Windows.Controls.Frame>）由一个或多个导航器承载，则不会对任何导航器引发 `NavigationFailed`。  
  
   
  
## Examples  
 下面的示例演示如何处理 <xref:System.Windows.Navigation.NavigationService.NavigationFailed>。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationFailedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationfailedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationFailedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationfailedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationProgress As NavigationProgressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberSignature Language="F#" Value="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " Usage="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在下载过程中定期发生，用于提供定位进度信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 向 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> 传递的 <xref:System.Windows.Navigation.NavigationProgressEventArgs> 会公开以下进度信息：  
  
-   到目前为止下载的字节数（<xref:System.Windows.Navigation.NavigationProgressEventArgs.BytesRead%2A>）。  
  
-   要下载的总字节数（<xref:System.Windows.Navigation.NavigationProgressEventArgs.MaxBytes%2A>）。  
  
 每1024字节的下载内容会引发一次 <xref:System.Windows.Navigation.NavigationService.NavigationProgress>，并在剩余字节数不到1024字节后引发一次。 出于此原因，处理 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> 提供了一种有效的方法来跟踪和显示当前下载的进度。  
  
 某些情况下不会引发 <xref:System.Windows.Navigation.NavigationService.NavigationProgress>，例如，导航到相同的内容片段，或在导航到当前加载的内容（即 <xref:System.Windows.Navigation.NavigationService.Content%2A> 属性的值）的内容片段。  
  
 导航到已编译的 XAML 资源时，可能不会引发最终的 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> 事件。 这意味着，在下载结束时，最后报告的 <xref:System.Windows.Navigation.NavigationProgressEventArgs.BytesRead%2A> 值可能不等于 <xref:System.Windows.Navigation.NavigationProgressEventArgs.MaxBytes%2A> 值。 处理导航完成后要通知的 <xref:System.Windows.Navigation.NavigationService.LoadCompleted> 事件。  
  
> [!NOTE]
>  当 <xref:System.Windows.Navigation.NavigationService> 引发 <xref:System.Windows.Navigation.NavigationService.NavigationProgress>时，它还会引发 <xref:System.Windows.Application> 对象上 <xref:System.Windows.Application.NavigationProgress?displayProperty=nameWithType> 事件。  
  
   
  
## Examples  
 下面的示例演示如何处理 <xref:System.Windows.Navigation.NavigationService.NavigationProgress>。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationProgressCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationprogresscode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationProgressCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationprogresscode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationStopped As NavigationStoppedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberSignature Language="F#" Value="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " Usage="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在调用 <see cref="M:System.Windows.Navigation.NavigationService.StopLoading" /> 方法时发生，或者在当前导航正处于进行过程中时又请求一个新导航时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果需要在下载停止时发现有关导航请求的相关信息，请处理 <xref:System.Windows.Navigation.NavigationService.NavigationStopped>。 此信息可从传递到 <xref:System.Windows.Navigation.NavigationService.NavigationStopped> 事件处理程序的 <xref:System.Windows.Navigation.NavigationEventArgs> 对象中获得，其中包括：  
  
-   请求的 URI。  
  
-   导航器（<xref:System.Windows.Navigation.NavigationWindow><xref:System.Windows.Controls.Frame>）。  
  
-   如果通过调用 <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType> 或 <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>启动导航，则为附加数据。  
  
> [!NOTE]
>  当 <xref:System.Windows.Navigation.NavigationService> 引发 <xref:System.Windows.Navigation.NavigationService.NavigationStopped>时，它还会引发 <xref:System.Windows.Application> 对象上 <xref:System.Windows.Application.NavigationStopped?displayProperty=nameWithType> 事件。  
  
   
  
## Examples  
 下面的示例演示如何处理 <xref:System.Windows.Navigation.NavigationService.NavigationStopped>。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationStoppedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationstoppedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationStoppedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationstoppedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="navigationService.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>重新加载当前内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果再次导航到当前内容（由 <xref:System.Windows.Navigation.NavigationService.Source%2A> 属性的值指定），<xref:System.Windows.Navigation.NavigationService> 不会再次下载内容。 若要强制 <xref:System.Windows.Navigation.NavigationService> 重新导航到内容，请调用 <xref:System.Windows.Navigation.NavigationService.Refresh%2A>。  
  
 请注意，如果再次导航到当前内容，无论是通过调用 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 还是 <xref:System.Windows.Navigation.NavigationService.Refresh%2A>，都不会在导航历史记录中添加新条目。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
      </Docs>
    </Member>
    <Member MemberName="RemoveBackEntry">
      <MemberSignature Language="C#" Value="public System.Windows.Navigation.JournalEntry RemoveBackEntry ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Navigation.JournalEntry RemoveBackEntry() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.RemoveBackEntry" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveBackEntry () As JournalEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Navigation::JournalEntry ^ RemoveBackEntry();" />
      <MemberSignature Language="F#" Value="member this.RemoveBackEntry : unit -&gt; System.Windows.Navigation.JournalEntry" Usage="navigationService.RemoveBackEntry " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.JournalEntry</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>移除后退历史记录中的最新日记条目。</summary>
        <returns>后退导航历史记录中的最新 <see cref="T:System.Windows.Navigation.JournalEntry" />（如果有）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果两个或更多导航器（<xref:System.Windows.Navigation.NavigationWindow>、<xref:System.Windows.Controls.Frame>）共享相同的导航历史记录，则一个导航器可以使用 <xref:System.Windows.Navigation.NavigationService.RemoveBackEntry%2A> 检索在另一个导航器中发生的导航的后退导航历史记录项。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.AddBackEntry(System.Windows.Navigation.CustomContentState)" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public Uri Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Source { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : Uri with get, set" Usage="System.Windows.Navigation.NavigationService.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前内容的 URI，或当前正在导航到的新内容的 URI。</summary>
        <value>一个 <see cref="T:System.Uri" />，其中包含当前内容的 URI 或当前正在导航到的内容。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果将此属性设置为与当前所显示的 URI 不同的 URI，导航器（<xref:System.Windows.Navigation.NavigationWindow>、<xref:System.Windows.Controls.Frame>）将导航到指定的 URI。  
  
 如果取消了导航，则将 <xref:System.Windows.Navigation.NavigationService.Source%2A> 设置为从导航到的 URI 加载的内容。  
  
 可以使用只包含片段的 URI 设置 <xref:System.Windows.Navigation.NavigationService.Source%2A>，并且可以将其设置为 `null`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StopLoading">
      <MemberSignature Language="C#" Value="public void StopLoading ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StopLoading() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.StopLoading" />
      <MemberSignature Language="VB.NET" Value="Public Sub StopLoading ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StopLoading();" />
      <MemberSignature Language="F#" Value="member this.StopLoading : unit -&gt; unit" Usage="navigationService.StopLoading " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>停止为当前导航请求下载更多内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.StopLoading%2A> 可以在 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 返回时立即调用，并停止正在子框架中进行的导航。  
  
 (<xref:System.Windows.Controls.Frame>)。  
  
 调用 <xref:System.Windows.Navigation.NavigationService.StopLoading%2A> 方法将引发 <xref:System.Windows.Navigation.NavigationService.NavigationStopped> 事件。  
  
> [!NOTE]
>  必须在启动导航的同一线程上调用 <xref:System.Windows.Navigation.NavigationService.StopLoading%2A>。  
  
   
  
## Examples  
 下面的示例演示如何停止加载。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowStopLoadingCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowstoploadingcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowStopLoadingCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowstoploadingcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Navigation.NavigationService.Navigate" />
      </Docs>
    </Member>
  </Members>
</Type>
