<Type Name="ControlAdapter" FullName="System.Web.UI.Adapters.ControlAdapter">
  <Metadata><Meta Name="ms.openlocfilehash" Value="334cd4a62e09ef550979c8f6ba97ee4e1b2a601c" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86665741" /></Metadata><TypeSignature Language="C#" Value="public abstract class ControlAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ControlAdapter extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Adapters.ControlAdapter" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ControlAdapter" />
  <TypeSignature Language="C++ CLI" Value="public ref class ControlAdapter abstract" />
  <TypeSignature Language="F#" Value="type ControlAdapter = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>自定义附加了适配器的派生控件的呈现，以修改特定浏览器的默认标记或行为，是所有控件适配器都可以继承的基类。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 控件适配器是重写 <xref:System.Web.UI.Control> 其执行生命周期中的某些类方法和事件以允许浏览器或特定于标记的处理的组件。 .NET Framework 将单个派生控件适配器映射到 <xref:System.Web.UI.Control> 每个客户端请求的对象。  
  
 适配器会修改特定浏览器或浏览器类的控件，或者充当某些功能的任意筛选器。 通常，适配器由浏览器使用的标记语言（例如 XHTML 或 HTML 3.2) ）定义 (。 呈现行为中的大部分适应性都可以封装在派生自类的专用类中 <xref:System.Web.UI.HtmlTextWriter> 。 因此，可以将单个适配器用于许多浏览器类行为，或在类中包含适应性，这可能导致 <xref:System.Web.UI.HtmlTextWriter> 不必要地使用控件适配器。  
  
 控件类的适配器适用于继承自该类的所有控件，除非存在更多的专用适配器。 例如，类的适配器 <xref:System.Web.UI.WebControls.BaseValidator> 可用于所有 `Validator` 对象。  
  
 适配器通常不直接从 <xref:System.Web.UI.Adapters.ControlAdapter> 类继承，而是从特定于目标的适配器基类之一，这些基类提供特定于控件类型和目标浏览器或所需的特定呈现的附加功能。  
  
 控件本身不一定需要适配器。 如果控件是通过组合扩展的，则通常子控件适配器就够了。  
  
 每个控件都通过 .browser 定义文件显式映射到适配器。 因此，对属性的任何访问都 <xref:System.Web.UI.Control.Adapter%2A?displayProperty=nameWithType> 使用 <xref:System.Web.HttpBrowserCapabilities> 从浏览器定义文件中提取的对象来执行要控制的适配器映射。  
  
 在处理过程中，.NET Framework 会截获对可能特定于目标的控件的可重写方法的调用。 如果附加了控件适配器，.NET Framework 将调用关联的适配器方法。  
  
 适配器通过方法为控件执行呈现 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> 。 如果重写，则 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> 可能不应调用基类实现，因为这会在方法上执行回调 <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> 。 这可能会导致呈现发生两次，一次由适配器和控件一次。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>基方法回调 <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> 控件的方法。 因此，如果你重写 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> ，则不应调用基类实现，除非你实现的呈现除了由控件提供的 <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> 。  
  
 必须确保 .NET Framework 为子控件的适配器执行侦听。 为此，可以调用 <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> 基方法，该方法 <xref:System.Web.UI.Control.RenderChildren%2A?displayProperty=nameWithType> 从重写调用控件的方法 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> 。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>和 <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> 方法由控件在) 控件调用方法之前和之后 (分别调用 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> 。 如果预呈现和后期呈现是必需的特定于浏览器的处理任务，则使用 <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> 和 <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> 可能会使其不需要重写 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> 。 和方法的默认行为 <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> 是调用的对应方法 <xref:System.Web.UI.HtmlTextWriter> 。  
  
 为了维护其自己的状态信息，控件适配器可以重写 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> 、 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> 、 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> 和 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> 方法。 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A><xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> 分别保存和加载专用控件和视图状态时，将调用、、和。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>、 <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> 、 <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> 和 <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> 基方法回调相应的 <xref:System.Web.UI.Control> 类方法。 因此，重写的这些方法中的任何一种 <xref:System.Web.UI.Adapters.ControlAdapter> 都必须调用它们的基方法; 否则， <xref:System.Web.UI.Control> 将不会引发与类方法关联的事件。  
  
 控件和适配器可选择实现 <xref:System.Web.UI.IPostBackDataHandler> 和 <xref:System.Web.UI.IPostBackEventHandler> 接口。 .NET Framework 确定适配器是否存在以及适配器是否实现这些接口。 如果是这样，则适配器应 <xref:System.Web.UI.IPostBackDataHandler.LoadPostData%2A> 根据需要重写、 <xref:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent%2A> 和 <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> 方法。 如果在适配器中未识别回发数据，则必须回调控件才能处理回发数据。 后续事件处理程序还必须回调控件。  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>从类继承时 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> ，需要常规适配器功能的控件应具有相应的适配器基类，该基类在模式 <paramref name="ControlType" /> <see langword="Adapter" /> (例如 <see langword="TextBoxAdapter" />) 。 适配器应最少通过其属性返回控件的强类型实例 <see cref="P:System.Web.UI.Adapters.ControlAdapter.Control" /> 。  
  
1.  给定控件类型和标记语言的控件适配器应以模式命名 <paramref name="MarkupControlType" /> <see langword="Adapter" /> (例如 <see langword="XhtmlTextBoxAdapter" />) 。 控件的适配器应在 subnamespace 中实现 <see langword="Adapters" /> 。  
  
控件适配器应从适当的基类继承，并遵循与控件相同的继承模型。 例如，从基类继承的控件的适配器 <see cref="T:System.Web.UI.Control" /> 应继承自 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> 类或相关 <paramref name="ControlType" /> <see langword="Adapter" /> 类。  
  
应为配置 .browser 文件中所有设备节点下的专用控件定义专用适配器。  
  
正确实现的控件不应假定附加了适配器，或者附加的适配器实现了特定的接口。 相反，应在调用之前检查它们。  
  
可以模拟在控件中重写受保护的事件方法，如的 <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> 方法 <see cref="T:System.Web.UI.WebControls.LinkButton" /> 。 首先，使用 <c>OnClick</c> 方法创建适配器类。 然后，创建一个从派生的新控件 <see cref="T:System.Web.UI.WebControls.LinkButton" /> ，并重写 <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> 方法。 重写的 <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> 方法调用适配器的 <c>OnClick</c> 方法。 适配器对象通过类的 protected 属性提供 <see cref="P:System.Web.UI.Control.Adapter" /> <see cref="T:System.Web.UI.Control" /> 。 <see cref="P:System.Web.UI.Control.Adapter" />当没有关联的适配器时，控件的属性为 <see langword="null" /> ，因此任何代码都应在调用适配器的方法之前检查该条件。</para></block>
    <altmember cref="T:System.Web.UI.Control" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ControlAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ControlAdapter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 在创建相应的对象时在内部构造此适配器 <xref:System.Web.UI.Control> 。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="BeginRender">
      <MemberSignature Language="C#" Value="protected internal virtual void BeginRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void BeginRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub BeginRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void BeginRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.BeginRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">包含可呈现特定于目标的输出的方法的 <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <summary>在呈现控件前调用。 在派生的 adapter 类中，生成特定目标需要但 HTML 浏览器不需要的开始标记。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>方法在方法之前调用 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> ，用于在呈现控件之前执行目标特定的预处理。  
  
 将 <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> 方法与方法结合使用 <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> ，以确保打开和关闭标记一致性。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>当从类继承时 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> ， <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> 基方法会调用 <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> 方法。 因此，方法的重写 <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> 只应在其处理不是方法（而不是方法）的情况下调用基方法 <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> 。</para></block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="protected System.Web.HttpBrowserCapabilities Browser { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Browser As HttpBrowserCapabilities" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::HttpBrowserCapabilities ^ Browser { System::Web::HttpBrowserCapabilities ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Browser : System.Web.HttpBrowserCapabilities" Usage="System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对发出当前 HTTP 请求的客户端的浏览器功能的引用。</summary>
        <value>一个 <see cref="T:System.Web.HttpBrowserCapabilities" />，指定客户端浏览器和标记功能。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter>对象从属性返回的对象确定客户端浏览器功能 <xref:System.Web.HttpBrowserCapabilities> <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> 。 这使 <xref:System.Web.UI.Adapters.ControlAdapter> 对象能够呈现特定于浏览器的标记，或修改的行为 <xref:System.Web.UI.Control> 。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> 属性访问请求浏览器的详细信息。 在此示例中，代码将进行检查以确定浏览器是否与 JavaScript 兼容，并允许开发人员在这种情况下呈现自定义的输出。  
  
 [!code-cpp[ControlAdapter_Browser#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_Browser/CPP/controladapter_browser.cpp#1)]
 [!code-csharp[ControlAdapter_Browser#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_Browser/CS/controladapter_browser.cs#1)]
 [!code-vb[ControlAdapter_Browser#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_Browser/VB/controladapter_browser.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="T:System.Web.Configuration.HttpCapabilitiesBase" />
      </Docs>
    </Member>
    <Member MemberName="Control">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Control Control { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Control" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Control As Control" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Control ^ Control { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Control : System.Web.UI.Control" Usage="System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对附加了此控件适配器的控件的引用。</summary>
        <value>附加此 <see cref="T:System.Web.UI.Control" /> 的 <see cref="T:System.Web.UI.Adapters.ControlAdapter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当派生控件适配器附加到控件时，.NET Framework 将调用某些适配器成员而不是控件成员。  
  
   
  
## Examples  
 下面的代码示例演示如何从类派生自定义控件 <xref:System.Web.UI.Control> ，然后创建一个从类继承的相应适配器 <xref:System.Web.UI.Adapters.ControlAdapter> 。 适配器将重写 <xref:System.Web.UI.Adapters.ControlAdapter.Control%2A> 属性，并返回对控件的强类型引用。  
  
 [!code-cpp[ControlAdapter.Control#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter.Control/CPP/controladapter.control.cpp#1)]
 [!code-csharp[ControlAdapter.Control#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter.Control/CS/controladapter.control.cs#1)]
 [!code-vb[ControlAdapter.Control#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter.Control/VB/controladapter.control.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在从类继承时 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> ，至少应实现 <see langword="Control" /> 属性以返回控件的强类型实例，如 "示例" 部分所示。</para></block>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected internal virtual void CreateChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CreateChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CreateChildControls();" />
      <MemberSignature Language="F#" Value="abstract member CreateChildControls : unit -&gt; unit&#xA;override this.CreateChildControls : unit -&gt; unit" Usage="controlAdapter.CreateChildControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为复合控件创建特定于目标的子控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果有一个附加到对象的派生控件适配器 <xref:System.Web.UI.Control> 并且 <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> 方法被重写，则会调用替代方法，而不是 <xref:System.Web.UI.Control.CreateChildControls%2A?displayProperty=nameWithType> 方法。 因此， <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> 可用于创建特定于目标的子控件集。  
  
 有关组合控件以创建新控件的详细信息，请参阅 [复合控件](https://msdn.microsoft.com/library/fb174677-d845-467c-8bf3-cc096b2490b0)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>如果创建继承类并重写 <see cref="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" /> 方法，请不要调用基方法，除非你想要将控件添加到基方法所创建的控件。 否则，你可以创建两组子控件。</para></block>
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="EndRender">
      <MemberSignature Language="C#" Value="protected internal virtual void EndRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void EndRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub EndRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void EndRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member EndRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.EndRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.EndRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">包含可呈现特定于目标的输出的方法的 <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <summary>在呈现控件后调用。 在派生的 adapter 类中，生成特定目标需要但 HTML 浏览器不需要的结束标记。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>方法在方法之后立即调用 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> ，用于在呈现控件后执行目标特定后处理。  
  
 将 <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> 方法与方法结合使用 <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> ，以确保打开和关闭标记一致性。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>当从类继承时 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> ， <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> 基方法会调用 <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> 方法。 因此，方法的重写 <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> 只应在其处理不是方法（而不是方法）的情况下调用基方法 <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> 。</para></block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.EndRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterControlState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterControlState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterControlState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterControlState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterControlState : obj -&gt; unit&#xA;override this.LoadAdapterControlState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterControlState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">一个 <see cref="T:System.Object" />，其中包含适配器的控件状态信息作为 <see cref="T:System.Web.UI.StateBag" />。</param>
        <summary>加载适配器控件状态信息，该信息由 <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" /> 在以前请求与此控件适配器关联的控件所驻留的页时保存。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 即使禁用了视图状态，控件状态也是必要的必要状态信息。 当适配器需要维护其自己的控件状态信息时，它可以重写 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> 和 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> 方法。  
  
 如果某些功能需要跨请求维护状态，则适配器可能需要维护控制状态信息，这与关联控件的状态无关。 例如，由大文本显示和一组控件组成的复合控件 <xref:System.Web.UI.WebControls.RadioButton> 可能在台式计算机浏览器上呈现为单一视图。 在其他浏览器中，它可能会拆分其呈现-一个视图用于文本显示，另一个用于单选按钮组。 适配器需要维护其自己的特定于目标的有关当前活动视图的信息。  
  
 方法在 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> <xref:System.Web.UI.Control.LoadControlState%2A?displayProperty=nameWithType> `LoadState` 生命周期阶段的方法之后立即调用。 适配器控件状态是独立的，以及控件的控件状态。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterViewState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterViewState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterViewState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterViewState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterViewState : obj -&gt; unit&#xA;override this.LoadAdapterViewState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterViewState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">一个 <see cref="T:System.Object" />，其中包含适配器视图的状态信息作为 <see cref="T:System.Web.UI.StateBag" />。</param>
        <summary>加载适配器视图状态信息，该信息由 <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" /> 在以前请求与此控件适配器关联的控件所驻留的页时保存。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当适配器需要维护其自己的视图状态信息时，它可以重写 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> 和 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> 方法。  
  
 当存在必须跨请求维护的数据时，适配器需要维护视图状态信息，这与关联控件的视图状态无关。 例如，台式计算机浏览器上的网格控件可能呈现为行和值列的单个视图。 在其他浏览器中，它可能会将其呈现拆分为多个单独的视图，例如行列表和单个行的详细信息。 适配器需要维护当前在视图状态中处于非活动状态的视图的数据。  
  
 在 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> <xref:System.Web.UI.Control.LoadViewState%2A?displayProperty=nameWithType> 生命周期阶段的方法之前立即调用方法 `LoadState` 。 适配器视图状态与控件的视图状态不同。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal virtual void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInit : EventArgs -&gt; unit&#xA;override this.OnInit : EventArgs -&gt; unit" Usage="controlAdapter.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>重写关联控件的 <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> 方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果有一个适配器附加到 <xref:System.Web.UI.Control> 对象并且该 <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> 方法被重写，则调用重写方法而不是 <xref:System.Web.UI.Control.OnInit%2A?displayProperty=nameWithType> 方法。  
  
 重写 <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> 以在 `Initialize` 控制生命周期的阶段执行特定于目标的处理。 通常，这些是在创建控件时执行的函数。  
  
   
  
## Examples  
 下面的代码示例从类派生自定义控件适配器 <xref:System.Web.UI.Adapters.ControlAdapter> 。 然后，它会重写 <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> 方法以设置关联控件上的属性，并调用基方法来完成控件初始化。  
  
 [!code-cpp[ControlAdapter_OnInit#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_OnInit/CPP/controladapter_oninit.cpp#1)]
 [!code-csharp[ControlAdapter_OnInit#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_OnInit/CS/controladapter_oninit.cs#1)]
 [!code-vb[ControlAdapter_OnInit#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_OnInit/VB/controladapter_oninit.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>当从 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> 类继承并且适配器重写 <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" /> 方法时，适配器必须调用相应的基类方法，该方法又调用 <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> 方法。 如果 <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> 未调用方法，则不会 <see cref="E:System.Web.UI.Control.Init" /> 引发事件。</para></block>
        <altmember cref="E:System.Web.UI.Control.Init" />
        <altmember cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoad : EventArgs -&gt; unit&#xA;override this.OnLoad : EventArgs -&gt; unit" Usage="controlAdapter.OnLoad e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>重写关联控件的 <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> 方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果有一个适配器附加到 <xref:System.Web.UI.Control> 对象并且该 <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> 方法被重写，则调用重写方法而不是 <xref:System.Web.UI.Control.OnLoad%2A?displayProperty=nameWithType> 方法。  
  
 重写 <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> 方法以在控件生命周期的阶段执行特定于目标的处理 `Load` 。 通常，这些是应为每个客户端请求执行的函数。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>当从 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> 类继承并且适配器重写 <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" /> 方法时，适配器必须调用相应的基类方法，该方法又调用 <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> 方法。 如果 <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> 未调用，则 <see cref="E:System.Web.UI.Control.Load" /> 不会引发事件。</para></block>
        <altmember cref="E:System.Web.UI.Control.Load" />
        <altmember cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreRender : EventArgs -&gt; unit&#xA;override this.OnPreRender : EventArgs -&gt; unit" Usage="controlAdapter.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>重写关联控件的 <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> 方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果有一个适配器附加到 <xref:System.Web.UI.Control> 对象并且该 <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> 方法被重写，则调用重写方法而不是 <xref:System.Web.UI.Control.OnPreRender%2A?displayProperty=nameWithType> 方法。  
  
 重写 <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> 方法以在控件生命周期的阶段执行特定于目标的处理 `PreRender` 。 通常，这些都是在控件输出之前立即呈现的函数。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>当从 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> 类继承并且适配器重写 <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" /> 方法时，适配器必须调用相应的基类方法，该方法又调用 <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> 方法。 如果 <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> 未调用方法，则不会 <see cref="E:System.Web.UI.Control.PreRender" /> 引发事件。</para></block>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
        <altmember cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal virtual void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnload : EventArgs -&gt; unit&#xA;override this.OnUnload : EventArgs -&gt; unit" Usage="controlAdapter.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>重写关联控件的 <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> 方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果有一个适配器附加到 <xref:System.Web.UI.Control> 对象并且该 <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> 方法被重写，则调用重写方法而不是 <xref:System.Web.UI.Control.OnUnload%2A?displayProperty=nameWithType> 方法。  
  
 重写 <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> 方法以在控件生命周期的阶段执行特定于目标的处理 `Unload` 。 通常，这些是在处置控件之前的清理函数。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>当从 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> 类继承并且适配器重写 <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" /> 方法时，适配器必须调用相应的基类方法，该方法又调用 <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> 方法。 如果 <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> 未调用，则 <see cref="E:System.Web.UI.Control.Unload" /> 不会引发事件。</para></block>
        <altmember cref="E:System.Web.UI.Control.Unload" />
        <altmember cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Page Page { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Page As Page" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Page ^ Page { System::Web::UI::Page ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Page : System.Web.UI.Page" Usage="System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对与此适配器关联的控件所驻留的页的引用。</summary>
        <value>一个 <see cref="T:System.Web.UI.Page" />，可提供对关联控件所在的页实例的访问权限。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter.Page%2A>属性提供对控件所在的 <xref:System.Web.UI.Page?displayProperty=nameWithType> 对象的访问。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="PageAdapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.PageAdapter PageAdapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.PageAdapter PageAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property PageAdapter As PageAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Adapters::PageAdapter ^ PageAdapter { System::Web::UI::Adapters::PageAdapter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageAdapter : System.Web.UI.Adapters.PageAdapter" Usage="System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.PageAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对关联控件所驻留的页的页适配器的引用。</summary>
        <value>用于与当前 <see cref="T:System.Web.UI.Adapters.PageAdapter" /> 关联的控件所在的页的 <see cref="T:System.Web.UI.Adapters.ControlAdapter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A>属性为 <xref:System.Web.UI.Adapters.PageAdapter?displayProperty=nameWithType> <xref:System.Web.UI.Page> <xref:System.Web.UI.Control> 与当前对象关联的对象 <xref:System.Web.UI.Adapters.ControlAdapter> 所在的对象提供对对象的访问。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A>属性可用于访问页适配器级别的其他项，例如，可应用于页面上几个控件类型的常见特定于目标的函数。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Adapters.PageAdapter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal virtual void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member Render : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">用于呈现特定于目标的输出的 <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <summary>为附加了控件适配器的控件生成目标特定的标记。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重写 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> 方法以生成要发送到客户端浏览器的目标特定标记。 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> 如果将 <xref:System.Web.UI.Adapters.ControlAdapter> 对象附加到对象，则调用方法来替代方法 <xref:System.Web.UI.Control> 。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>当从类继承时 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> ， <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> 基方法会调用 <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> 方法。 因此，方法的重写 <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> 只应在其处理不是方法（而不是方法）的情况下调用基方法 <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> 。  
  
对于复合控件，适配器开发人员必须确保呈现子控件。 如果 <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> 方法导致呈现子控件，但不生成标记，则可能适合 <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> 方法调用其基方法。 如果需要特定于目标的子控件呈现，则适配器应实现 <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> 方法并 <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> 从方法中调用方法 <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> 。</para></block>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RenderChildren (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RenderChildren(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.RenderChildren writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">用于呈现特定于目标的输出的 <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <summary>为附加了控件适配器的复合控件中的子控件生成特定于目标的标记。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A>当需要为复合控件的子控件集生成特定于目标的标记，而不是单独的子控件的标记时，重写方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>当从类继承时 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> ，对于复合控件，适配器开发人员必须确保呈现子控件。 如果适配器重写 <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> 方法，则它应 <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> 从方法的重写调用方法 <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> 。  
  
如果 <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> 方法导致呈现子控件，但其本身不生成标记，则可能适合 <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> 方法调用其基方法（该方法调用 <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> 方法），而不是实现方法的重写 <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> 。</para></block>
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterControlState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterControlState : unit -&gt; obj&#xA;override this.SaveAdapterControlState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>保存控件适配器的控件状态信息。</summary>
        <returns>一个 <see cref="T:System.Object" />，其中包含适配器的控件状态信息作为 <see cref="T:System.Web.UI.StateBag" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 即使禁用了视图状态，控件状态也是必要的必要状态信息。 当适配器需要维护其自己的控件状态信息时，它可以重写 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> 和 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> 方法。  
  
 如果某些功能需要跨请求维护状态，则适配器可能需要维护控制状态信息，这与关联控件的状态无关。 例如，由大文本显示和一组控件组成的复合控件 <xref:System.Web.UI.WebControls.RadioButton> 可能在台式计算机浏览器上呈现为单一视图。 在其他浏览器中，它可能会拆分其呈现-一个视图用于文本显示，另一个用于单选按钮组。 适配器需要维护其自己的特定于目标的有关当前活动视图的信息。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>方法会在 <xref:System.Web.UI.Control.SaveControlState%2A?displayProperty=nameWithType> 生命周期阶段中的方法之后立即调用 `SaveState` 。 适配器控件状态是独立的，以及控件的控件状态。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterViewState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterViewState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterViewState : unit -&gt; obj&#xA;override this.SaveAdapterViewState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>保存控件适配器的视图状态信息。</summary>
        <returns>一个 <see cref="T:System.Object" />，其中包含适配器视图的状态信息作为 <see cref="T:System.Web.UI.StateBag" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当适配器需要维护其自己的视图状态信息时，它可以重写 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> 和 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> 方法。  
  
 当存在必须跨请求维护的数据时，适配器需要维护视图状态信息，这与控件的关联视图状态无关。 例如，台式计算机浏览器上的网格控件可能呈现为行和值列的单个视图。 在其他浏览器中，它可能会将其呈现拆分为多个单独的视图，例如行列表和单个行的详细信息。 适配器需要维护当前在视图状态中处于非活动状态的视图的数据。  
  
 在 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> <xref:System.Web.UI.Control.SaveViewState%2A?displayProperty=nameWithType> 生命周期阶段的方法之前立即调用方法 `SaveState` 。 适配器视图状态与控件的视图状态不同。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
  </Members>
</Type>
