<Type Name="DynamicMethod" FullName="System.Reflection.Emit.DynamicMethod">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a988c84369d4dc759af9ae31724a43792c97edfa" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83964708" /></Metadata><TypeSignature Language="C#" Value="public sealed class DynamicMethod : System.Reflection.MethodInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DynamicMethod extends System.Reflection.MethodInfo" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.DynamicMethod" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DynamicMethod&#xA;Inherits MethodInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicMethod sealed : System::Reflection::MethodInfo" />
  <TypeSignature Language="F#" Value="type DynamicMethod = class&#xA;    inherit MethodInfo" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit DynamicMethod extends System.Reflection.MethodInfo" FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Reflection.Emit.Lightweight" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Reflection.MethodInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>定义并表示可以编译、执行和丢弃的一种动态方法。 丢弃的方法可用于垃圾回收。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用 <xref:System.Reflection.Emit.DynamicMethod> 类，在运行时生成和执行方法，而不必生成动态程序集和动态类型来包含该方法。 回收 <xref:System.Reflection.Emit.DynamicMethod> 对象时，由实时（JIT）编译器创建的可执行代码将被回收。 动态方法是生成和执行少量代码的最有效方法。  
  
 动态方法可以是匿名承载的，也可以逻辑上与模块或类型相关联。  
  
-   如果动态方法是匿名承载的，则该方法位于系统提供的程序集中，因此与其他代码隔离。 默认情况下，它无权访问任何非公共数据。 如果已使用 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 标志授予 <xref:System.Security.Permissions.ReflectionPermission>，则匿名托管的动态方法可以具有跳过 JIT 编译器的可见性检查的受限能力。 动态方法访问其非公共成员的程序集的信任级别必须等于发出动态方法的调用堆栈的信任级别（或的子集）。 有关匿名承载的动态方法的详细信息，请参阅[演练：在部分信任方案中发出代码](/dotnet/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios)。  
  
-   如果动态方法与指定的模块相关联，动态方法将在该模块中有效地成为全局方法。 它可以访问模块中的所有类型以及这些类型的所有 `internal` （`Friend` 在 Visual Basic）成员中。 无论是否已创建模块，都可以将动态方法与任何模块相关联，前提是包含代码的调用堆栈可以满足对具有 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> 标志 <xref:System.Security.Permissions.ReflectionPermission> 的需求。 如果 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 标志包含在 grant 中，则动态方法可以跳过 JIT 编译器的可见性检查并访问在该模块中声明的所有类型或任何程序集中的任何其他模块中声明的所有类型的私有数据。  
  
    > [!NOTE]
    >  指定与动态方法关联的模块时，该模块不得位于系统提供的程序集中，该程序集用于匿名托管。  
  
-   如果动态方法与指定的类型相关联，则它有权访问该类型的所有成员，而不考虑访问级别。 此外，还可以跳过 JIT 可见性检查。 这为动态方法提供对在同一模块中或在任何程序集中的任何其他模块中声明的其他类型的私有数据的访问。 可以将动态方法与任何类型相关联，但必须使用 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> 和 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess> 标志授予你的代码 <xref:System.Security.Permissions.ReflectionPermission>。  
  
 下表显示了匿名托管的动态方法可访问的类型和成员（带有和不带 JIT 可见性检查），具体取决于是否授予 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> 标志 <xref:System.Security.Permissions.ReflectionPermission>。  
  
||不带 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|通过 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|  
|-|-|-|  
|不跳过 JIT 可见性检查|任何程序集中公共类型的公共成员。|任何程序集中公共类型的公共成员。|  
|跳过 JIT 可见性检查，但有限制|任何程序集中公共类型的公共成员。|所有类型的所有成员，仅在其信任级别等于或小于发出动态方法的程序集的信任级别的程序集中。|  
  
> [!NOTE]
>  在 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]之前，发出所需的代码 <xref:System.Security.Permissions.ReflectionPermission> 带有 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 标志。 默认情况下，此权限包含在 FullTrust 和 LocalIntranet 命名权限集中，而不是在 Internet 权限集中。 因此，在的早期版本中 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 库只能与 Internet 权限一起使用，前提是它具有 <xref:System.Security.SecurityCriticalAttribute> 属性并同时执行 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>的 <xref:System.Security.PermissionSet.Assert%2A>。 这种库需要进行仔细的安全检查，因为编码错误可能会导致安全漏洞。 [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)] 允许以部分信任形式发出代码而无需发出任何安全请求，因为生成代码本身不是一项特权操作。 也就是说，生成的代码不会具有比发出它的程序集更多的权限。 这使得发出代码的库是安全透明的，且不再需要断言 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>，这简化了编写安全库任务。 若要使用此功能，应用程序应面向 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 下表显示了与模块或模块中的类型相关联的动态方法可以访问的类型和成员。  
  
||与模块关联|与类型关联|  
|-|-|-|  
|不跳过 JIT 可见性检查|模块中公共类型、内部类型和私有类型的公共和内部成员。<br /><br /> 任何程序集中公共类型的公共成员。|关联类型的所有成员。 模块中所有其他类型的公共和内部成员。<br /><br /> 任何程序集中公共类型的公共成员。|  
|跳过 JIT 可见性检查|所有程序集中的所有类型的所有成员。|所有程序集中的所有类型的所有成员。|  
  
 与模块关联的动态方法具有该模块的权限。 与某一类型关联的动态方法具有包含该类型的模块的权限。  
  
 动态方法及其参数无需命名，但你可以指定名称来帮助进行调试。 动态方法或其参数不支持自定义属性。  
  
 尽管动态方法是 `static` 方法（`Shared` Visual Basic 中的方法），但在 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] 中引入的委托绑定的宽松规则允许将动态方法绑定到对象，以便在使用该委托实例调用时，它的作用类似于实例方法。 此示例演示了如何为 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> 方法重载提供此方法。  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]中，动态方法不支持符号信息，即本地变量名称和行号映射。 在将来的版本中可能会删除此限制。 你可以在开发过程中使用 <xref:System.Reflection.Emit.AssemblyBuilder> 来简化生成的 Microsoft 中间语言（MSIL）的调试，然后在最终部署过程中切换到动态方法，因为在这两种情况下，<xref:System.Reflection.Emit.ILGenerator> 调用都是相同的。  
  
## <a name="verification"></a>验证  
 下面的列表汇总了动态方法可包含无法验证的代码的情况。 （例如，如果动态方法的 <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A> 属性设置为 `false`，则无法对其进行验证。）  
  
-   与安全关键程序集关联的动态方法也是安全关键的，可跳过验证。 例如，如果程序集不具有作为桌面应用程序运行的安全属性，则运行时将其视为安全关键。 如果将动态方法与程序集相关联，则动态方法可能包含不可验证的代码。  
  
-   如果包含不可验证代码的动态方法与具有级别1透明度的程序集相关联，则实时（JIT）编译器将注入安全要求。 仅当动态方法由完全受信任的代码执行时，请求才会成功。 请参阅[安全透明代码，级别 1](/dotnet/framework/misc/security-transparent-code-level-1)。  
  
-   如果包含不可验证代码的动态方法与具有2级透明度（如 mscorlib.dll）的程序集相关联，则它会引发异常（由 JIT 编译器注入），而不是发出安全要求。 请参阅[安全透明代码，级别 2](/dotnet/framework/misc/security-transparent-code-level-2)。  
  
-   包含不可验证的代码的匿名托管动态方法始终引发异常。 即使它是由完全受信任的代码创建和执行的，它也永远不会跳过验证。  
  
 对于不可验证的代码引发的异常会根据动态方法的调用方式而有所不同。 如果使用从 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> 方法返回的委托调用动态方法，则将引发 <xref:System.Security.VerificationException>。 如果通过使用 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 方法调用动态方法，则将使用内部 <xref:System.Security.VerificationException>引发 <xref:System.Reflection.TargetInvocationException>。  
  
   
  
## Examples  
 下面的代码示例创建一个带有两个参数的动态方法。 该示例发出一个简单的函数体，将第一个参数输出到控制台，该示例使用第二个参数作为方法的返回值。 该示例通过创建委托来完成方法，使用不同的参数调用委托，最后使用 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 方法调用动态方法。  
  
 [!code-cpp[Reflection.DynamicMethod.All#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.All#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.All#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods">如何：定义和执行动态方法</related>
    <related type="Article" href="/dotnet/framework/reflection-and-codedom/security-issues-in-reflection-emit">反射发出中的安全问题</related>
    <related type="Article" href="/dotnet/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios">演练：在部分信任应用场景中发出代码</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建动态方法。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">动态方法的名称。 它可以是长度为零的字符串，但不能为 <see langword="null" />。</param>
        <param name="returnType">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" />。</param>
        <param name="parameterTypes">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" />。</param>
        <summary>初始化匿名托管的动态方法，指定方法名称、返回类型和参数类型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数创建的动态方法与匿名程序集相关联，而不是与现有类型或模块关联。 匿名程序集的存在只是为了为动态方法提供沙盒环境，即，将它们与其他代码隔离开来。 此环境使动态方法可由部分受信任的代码发出并执行。  
  
 此构造函数指定将对动态方法的 Microsoft 中间语言（MSIL）强制执行实时（JIT）可见性检查。 也就是说，动态方法中的代码可以访问公共类的公共方法。 如果方法尝试访问 `private`、`protected`或 `internal` 的类型或成员（在 Visual Basic 中`Friend`），则会引发异常。 若要创建具有跳过 JIT 可见性检查的受限能力的动态方法，请使用 <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29> 构造函数。  
  
 构造匿名托管的动态方法时，将包含发出程序集的调用堆栈。 调用方法时，将使用发出程序集的权限，而不是实际调用方的权限。 因此，动态方法无法以比发出它的程序集更高的特权级别执行，即使该方法传递到并且由具有较高信任级别的程序集执行。  
  
 此构造函数指定 <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> 和 <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>方法特性，并 <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>调用约定。  
  
> [!NOTE]
>  此构造函数是在 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本中引入的。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> 是一种 <see cref="P:System.Type.IsByRef" /> 为其返回 <see langword="true" /> 的类型。</exception>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods">如何：定义和执行动态方法</related>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/security-issues-in-reflection-emit">反射发出中的安全问题</related>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios">演练：在部分信任应用场景中发出代码</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, bool restrictedSkipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), restrictedSkipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, restrictedSkipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="restrictedSkipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">动态方法的名称。 它可以是长度为零的字符串，但不能为 <see langword="null" />。</param>
        <param name="returnType">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" />。</param>
        <param name="parameterTypes">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" />。</param>
        <param name="restrictedSkipVisibility">如果为 <see langword="true" />，则跳过针对动态方法的 MSIL 访问的类型和成员进行的 JIT 可见性检查，含此限制：包含这些类型和成员的程序集的信任级别必须等于或小于发出动态方法的调用堆栈的信任级别；否则为 <see langword="false" />。</param>
        <summary>初始化匿名托管的动态方法，同时指定方法名称、返回类型、参数类型并指定是否应针对动态方法的 Microsoft 中间语言 (MSIL) 访问的类型和成员跳过实时 (JIT) 可见性检查。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数创建的动态方法与匿名程序集相关联，而不是与现有类型或模块关联。 匿名程序集的存在只是为了为动态方法提供沙盒环境，即，将它们与其他代码隔离开来。 此环境使动态方法可由部分受信任的代码发出并执行。  
  
 匿名托管的动态方法不能自动访问 `private`、`protected`或 `internal` 的任何类型或成员（Visual Basic 中的`Friend`）。 这不同于与现有类型或模块关联的动态方法，这些方法可以访问其关联范围内的隐藏成员。  
  
 如果动态方法必须访问 `private`、`protected`或 `internal`的类型或成员，则为 `restrictedSkipVisibility` 指定 `true`。 这为动态方法授予了对这些成员的有限访问权限。 也就是说，仅当满足以下条件时，才能访问成员：  
  
-   目标成员属于具有等于或小于发出动态方法的调用堆栈的信任级别的程序集。  
  
-   向发出动态方法的调用堆栈授予 <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 标志。 在完全信任的情况下执行代码时，这始终为 true。 对于部分受信任的代码，仅当主机显式授予权限时才为 true。  
  
    > [!IMPORTANT]
    >  如果尚未授予该权限，则在调用 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> 或调用动态方法时，而不是在调用此构造函数时，将引发安全异常。 发出动态方法不需要任何特殊权限。  
  
 例如，如果已向调用堆栈授予受限成员访问权限，则使用 `restrictedSkipVisibility` 设置为 `true` 创建的动态方法可以访问调用堆栈上的任何程序集的私有成员。 如果动态方法是使用调用堆栈上部分受信任的代码创建的，则它无法访问 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 程序集中的类型的私有成员，因为此类程序集是完全受信任的。  
  
 如果 `false``restrictedSkipVisibility`，则强制执行 JIT 可见性检查。 动态方法中的代码可以访问公共类的公共方法，如果尝试访问 `private`、`protected`或 `internal`的类型或成员，则会引发异常。  
  
 构造匿名托管的动态方法时，将包含发出程序集的调用堆栈。 调用方法时，将使用发出调用堆栈的权限，而不是实际调用方的权限。 因此，动态方法无法以比发出它的程序集更高的特权级别执行，即使该方法传递到并且由具有较高信任级别的程序集执行。  
  
 此构造函数指定 <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> 和 <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>方法特性，并 <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>调用约定。  
  
> [!NOTE]
>  此构造函数是在 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本中引入的。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> 是一种 <see cref="P:System.Type.IsByRef" /> 为其返回 <see langword="true" /> 的类型。</exception>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods">如何：定义和执行动态方法</related>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/security-issues-in-reflection-emit">反射发出中的安全问题</related>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios">演练：在部分信任应用场景中发出代码</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="name">动态方法的名称。 它可以是长度为零的字符串，但不能为 <see langword="null" />。</param>
        <param name="returnType">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" />。</param>
        <param name="parameterTypes">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" />。</param>
        <param name="m">一个 <see cref="T:System.Reflection.Module" />，表示动态方法将与之逻辑关联的模块。</param>
        <summary>创建一个对模块全局有效的动态方法，指定方法名称、返回类型、参数类型和模块。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数指定 <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> 和 <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>的方法属性、调用约定 <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>，而不会跳过实时（JIT）可见性检查。  
  
 使用此构造函数创建的动态方法具有访问模块 `m`中包含的所有类型的公共和 `internal``Friend` （Visual Basic）成员的权限。  
  
> [!NOTE]
>  为实现向后兼容性，如果满足以下条件，则此构造函数要求使用 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> 标志 <xref:System.Security.Permissions.SecurityPermission>： `m` 是调用模块以外的模块，并且 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 标志对 <xref:System.Security.Permissions.ReflectionPermission> 的需求失败。 如果 <xref:System.Security.Permissions.SecurityPermission> 的请求成功，则允许该操作。  
  
> [!NOTE]
>  从 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]开始，此成员不再需要带有 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.ReflectionPermission>。 （请参阅[反射发出中的安全问题](/dotnet/framework/reflection-and-codedom/security-issues-in-reflection-emit)。）若要使用此功能，应用程序应面向 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
   
  
## Examples  
 下面的代码示例创建一个带有两个参数的动态方法。 该示例发出一个简单的函数体，将第一个参数输出到控制台，该示例使用第二个参数作为方法的返回值。 该示例通过创建委托来完成方法，使用不同的参数调用委托，最后使用 <xref:System.Reflection.Emit.DynamicMethod.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> 方法调用动态方法。  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。  
  
-或- 
 <paramref name="m" /> 是为动态方法提供匿名承载的模块。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="m" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> 是一种 <see cref="P:System.Type.IsByRef" /> 为其返回 <see langword="true" /> 的类型。</exception>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods">如何：定义和执行动态方法</related>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/security-issues-in-reflection-emit">反射发出中的安全问题</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">动态方法的名称。 它可以是长度为零的字符串，但不能为 <see langword="null" />。</param>
        <param name="returnType">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" />。</param>
        <param name="parameterTypes">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" />。</param>
        <param name="owner">动态方法与之在逻辑上相关联的 <see cref="T:System.Type" />。 动态方法有权访问此类型的所有成员。</param>
        <summary>创建动态方法，并指定方法的名称、返回类型、参数类型和此动态方法与之在逻辑上相关联的类型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此构造函数创建的动态方法具有对该类型 `owner`的所有成员的访问权限，以及对包含 `owner`的模块中所有其他类型的公共和 `internal` （`Friend` Visual Basic）成员的访问。  
  
 此构造函数指定 <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> 和 <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>的方法属性、调用约定 <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>，而不会跳过实时（JIT）可见性检查。  
  
> [!NOTE]
>  为实现向后兼容性，如果满足以下条件，则此构造函数要求使用 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> 标志 <xref:System.Security.Permissions.SecurityPermission>： `owner` 位于调用模块以外的模块中，且 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 标志对 <xref:System.Security.Permissions.ReflectionPermission> 的需求失败。 如果 <xref:System.Security.Permissions.SecurityPermission> 的请求成功，则允许该操作。  
  
> [!NOTE]
>  从 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]开始，此成员不再需要带有 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.ReflectionPermission>。 （请参阅[反射发出中的安全问题](/dotnet/framework/reflection-and-codedom/security-issues-in-reflection-emit)。）若要使用此功能，应用程序应面向 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
   
  
## Examples  
 下面的代码示例创建一个与类型逻辑上关联的 <xref:System.Reflection.Emit.DynamicMethod>。 此关联使其能够访问该类型的私有成员。  
  
 此代码示例定义了一个名为 `Example` 的类，该类具有一个私有字段、一个名为 `DerivedFromExample` 的类，该类派生自第一个类、一个名为 `UseLikeStatic` 的委托类型，该类型返回 <xref:System.Int32> 并包含 `Example` 和 <xref:System.Int32>类型的参数，以及一个名为 `UseLikeInstance` 的委托类型，该委托类型返回 <xref:System.Int32> 并且具有一个类型 <xref:System.Int32>的参数。  
  
 然后，示例代码创建一个 <xref:System.Reflection.Emit.DynamicMethod>，该更改 `Example` 实例的私有字段，并返回以前的值。  
  
> [!NOTE]
>  通常，更改类的内部字段并不是面向对象的适当编码做法。  
  
 示例代码创建 `Example` 的实例，然后创建两个委托。 第一种类型为 `UseLikeStatic`，它具有与动态方法相同的参数。 第二种类型的类型为 `UseLikeInstance`，缺少第一个参数（类型 `Example`）。 此委托是使用 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> 方法重载创建的;此方法重载的第二个参数是 `Example`实例，在本例中为刚创建的实例，该实例绑定到新创建的委托。 只要调用该委托，动态方法就会在 `Example`的绑定实例上操作。  
  
> [!NOTE]
>  这是 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]中引入的委托绑定的宽松规则的示例，以及 <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> 方法的新重载。 有关详细信息，请参阅 <xref:System.Delegate> 类。  
  
 调用 `UseLikeStatic` 委托，并传入绑定到 `UseLikeInstance` 委托的 `Example` 的实例。 然后调用 `UseLikeInstance` 委托，使这两个委托作用于 `Example`的同一实例。 在每次调用后，将显示内部字段的值中的更改。 最后，`UseLikeInstance` 委托绑定到 `DerivedFromExample`的实例，并且委托调用重复。  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。  
  
-或- 
 <paramref name="owner" /> 是一个接口、数组、开放式泛型类型，或者是泛型类型或方法的类型参数。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="owner" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> 是 <see langword="null" />，或 <see cref="P:System.Type.IsByRef" /> 为其返回 <see langword="true" /> 的类型。</exception>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods">如何：定义和执行动态方法</related>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/security-issues-in-reflection-emit">反射发出中的安全问题</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">动态方法的名称。 它可以是长度为零的字符串，但不能为 <see langword="null" />。</param>
        <param name="returnType">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" />。</param>
        <param name="parameterTypes">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" />。</param>
        <param name="m">一个 <see cref="T:System.Reflection.Module" />，表示动态方法将与之逻辑关联的模块。</param>
        <param name="skipVisibility">若要跳过对动态方法的 MSIL 访问的类型和成员的 JIT 可见性检查，则为 <see langword="true" />。</param>
        <summary>创建一个对模块全局有效的动态方法，指定方法名称、返回类型、参数类型和模块，并指定动态方法的 Microsoft 中间语言 (MSIL) 访问的类型和成员是否应跳过实时 (JIT) 可见性检查。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数指定 <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> 和 <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>并调用约定 <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>的方法特性。  
  
 使用此构造函数创建的动态方法有权访问包含模块 `m`中所有类型的公共和 `internal``Friend` （Visual Basic）成员。 通过跳过 JIT 编译器的可见性检查，动态方法还可以访问所有其他类型的私有和受保护成员。 例如，在编写代码以序列化对象时，这很有用。  
  
> [!NOTE]
>  为实现向后兼容性，如果满足以下条件，则此构造函数要求使用 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> 标志 <xref:System.Security.Permissions.SecurityPermission>： `m` 是调用模块以外的模块，并且 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 标志对 <xref:System.Security.Permissions.ReflectionPermission> 的需求失败。 如果 <xref:System.Security.Permissions.SecurityPermission> 的请求成功，则允许该操作。  
  
> [!NOTE]
>  从 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]开始，此成员不再需要带有 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.ReflectionPermission>。 （请参阅[反射发出中的安全问题](/dotnet/framework/reflection-and-codedom/security-issues-in-reflection-emit)。）若要使用此功能，应用程序应面向 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。  
  
-或- 
 <paramref name="m" /> 是为动态方法提供匿名承载的模块。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="m" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> 是一种 <see cref="P:System.Type.IsByRef" /> 为其返回 <see langword="true" /> 的类型。</exception>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods">如何：定义和执行动态方法</related>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/security-issues-in-reflection-emit">反射发出中的安全问题</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">动态方法的名称。 它可以是长度为零的字符串，但不能为 <see langword="null" />。</param>
        <param name="returnType">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" />。</param>
        <param name="parameterTypes">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" />。</param>
        <param name="owner">动态方法与之在逻辑上相关联的 <see cref="T:System.Type" />。 动态方法有权访问此类型的所有成员。</param>
        <param name="skipVisibility">若要跳过对动态方法的 MSIL 访问的类型和成员的 JIT 可见性检查，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>创建一个动态方法，指定方法名称、返回类型、参数类型，以及与该动态方法逻辑上相关联的类型，并指定动态方法的 Microsoft 中间语言 (MSIL) 访问的类型和成员是否应跳过实时 (JIT) 可见性检查。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此构造函数创建的动态方法具有对该类型 `owner`的所有成员的访问权限，以及对包含 `owner`的模块中所有其他类型的公共和 `internal` （`Friend` Visual Basic）成员的访问。 通过跳过 JIT 编译器的可见性检查，动态方法还可以访问所有其他类型的私有和受保护成员。 例如，在编写代码以序列化对象时，这很有用。  
  
 此构造函数指定 <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> 和 <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>并调用约定 <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>的方法特性。  
  
> [!NOTE]
>  为实现向后兼容性，如果满足以下条件，则此构造函数要求使用 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> 标志 <xref:System.Security.Permissions.SecurityPermission>： `owner` 位于调用模块以外的模块中，且 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 标志对 <xref:System.Security.Permissions.ReflectionPermission> 的需求失败。 如果 <xref:System.Security.Permissions.SecurityPermission> 的请求成功，则允许该操作。  
  
> [!NOTE]
>  从 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]开始，此成员不再需要带有 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.ReflectionPermission>。 （请参阅[反射发出中的安全问题](/dotnet/framework/reflection-and-codedom/security-issues-in-reflection-emit)。）若要使用此功能，应用程序应面向 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。  
  
-或- 
 <paramref name="owner" /> 是一个接口、数组、开放式泛型类型，或者是泛型类型或方法的类型参数。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="owner" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> 是 <see langword="null" />，或 <see cref="P:System.Type.IsByRef" /> 为其返回 <see langword="true" /> 的类型。</exception>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods">如何：定义和执行动态方法</related>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/security-issues-in-reflection-emit">反射发出中的安全问题</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">动态方法的名称。 它可以是长度为零的字符串，但不能为 <see langword="null" />。</param>
        <param name="attributes">用于指定动态方法属性的 <see cref="T:System.Reflection.MethodAttributes" /> 值的按位组合。 允许的唯一组合为 <see cref="F:System.Reflection.MethodAttributes.Public" /> 和 <see cref="F:System.Reflection.MethodAttributes.Static" />。</param>
        <param name="callingConvention">动态方法的调用约定。 必须是 <see cref="F:System.Reflection.CallingConventions.Standard" />。</param>
        <param name="returnType">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" />。</param>
        <param name="parameterTypes">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" />。</param>
        <param name="m">一个 <see cref="T:System.Reflection.Module" />，表示动态方法将与之逻辑关联的模块。</param>
        <param name="skipVisibility">若要跳过对动态方法的 MSIL 访问的类型和成员的 JIT 可见性检查，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>创建一个对模块全局有效的动态方法，指定方法名称、属性、调用约定、返回类型、参数类型和模块，并指定动态方法的 Microsoft 中间语言 (MSIL) 访问的类型和成员是否应跳过实时 (JIT) 可见性检查。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此构造函数创建的动态方法可以访问模块 `m`中包含的所有公共和内部类型的公共和 `internal` （`Friend` 在 Visual Basic）成员中。  
  
 通过跳过 JIT 编译器的可见性检查，动态方法可以访问模块和所有其他程序集中的所有其他类型的私有和受保护成员。 例如，在编写代码以序列化对象时，这很有用。  
  
> [!NOTE]
>  为实现向后兼容性，如果满足以下条件，则此构造函数要求使用 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> 标志 <xref:System.Security.Permissions.SecurityPermission>： `m` 是调用模块以外的模块，并且 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 标志对 <xref:System.Security.Permissions.ReflectionPermission> 的需求失败。 如果 <xref:System.Security.Permissions.SecurityPermission> 的请求成功，则允许该操作。  
  
> [!NOTE]
>  从 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]开始，此成员不再需要带有 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.ReflectionPermission>。 （请参阅[反射发出中的安全问题](/dotnet/framework/reflection-and-codedom/security-issues-in-reflection-emit)。）若要使用此功能，应用程序应面向 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。  
  
-或- 
 <paramref name="m" /> 是为动态方法提供匿名承载的模块。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="m" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="attributes" /> 是标志的组合，而不是 <see cref="F:System.Reflection.MethodAttributes.Public" /> 和 <see cref="F:System.Reflection.MethodAttributes.Static" /> 的组合。  
  
-或- 
 <paramref name="callingConvention" /> 不是 <see cref="F:System.Reflection.CallingConventions.Standard" />。  
  
-或- 
 <paramref name="returnType" /> 是一种 <see cref="P:System.Type.IsByRef" /> 为其返回 <see langword="true" /> 的类型。</exception>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods">如何：定义和执行动态方法</related>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/security-issues-in-reflection-emit">反射发出中的安全问题</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">动态方法的名称。 它可以是长度为零的字符串，但不能为 <see langword="null" />。</param>
        <param name="attributes">用于指定动态方法属性的 <see cref="T:System.Reflection.MethodAttributes" /> 值的按位组合。 允许的唯一组合为 <see cref="F:System.Reflection.MethodAttributes.Public" /> 和 <see cref="F:System.Reflection.MethodAttributes.Static" />。</param>
        <param name="callingConvention">动态方法的调用约定。 必须是 <see cref="F:System.Reflection.CallingConventions.Standard" />。</param>
        <param name="returnType">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" />。</param>
        <param name="parameterTypes">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" />。</param>
        <param name="owner">动态方法与之在逻辑上相关联的 <see cref="T:System.Type" />。 动态方法有权访问此类型的所有成员。</param>
        <param name="skipVisibility">若要跳过对动态方法的 MSIL 访问的类型和成员的 JIT 可见性检查，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>创建一个动态方法，指定方法名称、属性、调用约定、返回类型、参数类型，以及与该动态方法逻辑上相关联的类型，并指定动态方法的 Microsoft 中间语言 (MSIL) 访问的类型和成员是否应跳过实时 (JIT) 可见性检查。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 动态方法对于包含 `owner`类型的模块是全局方法。 它可以访问 `owner`类型的所有成员。  
  
 使用此构造函数创建的动态方法具有对该类型 `owner`的所有成员的访问权限，以及对包含 `owner`的模块中包含的所有类型的公共和 `internal` （`Friend` Visual Basic）成员的访问。 通过跳过 JIT 编译器的可见性检查，动态方法还可以访问所有其他类型的私有和受保护成员。 例如，在编写代码以序列化对象时，这很有用。  
  
> [!NOTE]
>  为实现向后兼容性，如果满足以下条件，则此构造函数要求使用 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> 标志 <xref:System.Security.Permissions.SecurityPermission>： `owner` 位于调用模块以外的模块中，且 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 标志对 <xref:System.Security.Permissions.ReflectionPermission> 的需求失败。 如果 <xref:System.Security.Permissions.SecurityPermission> 的请求成功，则允许该操作。  
  
> [!NOTE]
>  从 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]开始，此成员不再需要带有 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.ReflectionPermission>。 （请参阅[反射发出中的安全问题](/dotnet/framework/reflection-and-codedom/security-issues-in-reflection-emit)。）若要使用此功能，应用程序应面向 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。  
  
-或- 
 <paramref name="owner" /> 是一个接口、数组、开放式泛型类型，或者是泛型类型或方法的类型参数。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="owner" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="attributes" /> 是标志的组合，而不是 <see cref="F:System.Reflection.MethodAttributes.Public" /> 和 <see cref="F:System.Reflection.MethodAttributes.Static" /> 的组合。  
  
-或- 
 <paramref name="callingConvention" /> 不是 <see cref="F:System.Reflection.CallingConventions.Standard" />。  
  
-或- 
 <paramref name="returnType" /> 是一种 <see cref="P:System.Type.IsByRef" /> 为其返回 <see langword="true" /> 的类型。</exception>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods">如何：定义和执行动态方法</related>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/security-issues-in-reflection-emit">反射发出中的安全问题</related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.MethodAttributes" Usage="System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>创建动态方法后获取指定的属性。</summary>
        <value>表示此方法的属性的 <see cref="T:System.Reflection.MethodAttributes" /> 的值的按位组合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前，动态方法的方法属性始终 <xref:System.Reflection.MethodAttributes.Public> 和 <xref:System.Reflection.MethodAttributes.Static>。  
  
   
  
## Examples  
 下面的代码示例显示动态方法的方法特性。 此代码示例是为 <xref:System.Reflection.Emit.DynamicMethod> 类提供的更大示例的一部分。  
  
 [!code-cpp[Reflection.DynamicMethod.All#21](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#21)]
 [!code-csharp[Reflection.DynamicMethod.All#21](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#21)]
 [!code-vb[Reflection.DynamicMethod.All#21](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public override System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberSignature Language="F#" Value="member this.CallingConvention : System.Reflection.CallingConventions" Usage="System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>创建动态方法后获取指定的调用约定。</summary>
        <value>表示此方法的调用约定的一个 <see cref="T:System.Reflection.CallingConventions" /> 的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前，动态方法的调用约定始终 <xref:System.Reflection.CallingConventions.Standard>。  
  
   
  
## Examples  
 下面的代码示例显示动态方法的调用约定。 此代码示例是为 <xref:System.Reflection.Emit.DynamicMethod> 类提供的更大示例的一部分。  
  
 [!code-cpp[Reflection.DynamicMethod.All#22](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#22)]
 [!code-csharp[Reflection.DynamicMethod.All#22](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#22)]
 [!code-vb[Reflection.DynamicMethod.All#22](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>完成动态方法并创建一个可执行此方法的委托。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType);" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType) cil managed" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type) As Delegate" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType);" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type -&gt; Delegate" Usage="dynamicMethod.CreateDelegate delegateType" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public Delegate CreateDelegate (Type delegateType);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Delegate CreateDelegate(class System.Type delegateType) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDelegate (delegateType As Type) As Delegate" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Delegate ^ CreateDelegate(Type ^ delegateType);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="F#" Value="member this.CreateDelegate : Type -&gt; Delegate" Usage="dynamicMethod.CreateDelegate delegateType" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="delegateType">其签名与动态方法匹配的委托类型。</param>
        <summary>完成动态方法并创建一个可执行此方法的委托。</summary>
        <returns>可用于执行此动态方法的指定类型的委托。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> 方法或 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 方法完成动态方法。 将忽略更改动态方法的任何进一步尝试，如修改参数定义或发出更多 Microsoft 中间语言（MSIL）;不引发异常。  
  
 若要在有自己的 MSIL 生成器时为动态方法创建方法体，请调用 <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A> 方法获取 <xref:System.Reflection.Emit.DynamicILInfo> 对象。 如果没有自己的 MSIL 生成器，请调用 <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A> 方法来获取可用于生成方法体的 <xref:System.Reflection.Emit.ILGenerator> 对象。  
  
   
  
## Examples  
 下面的代码示例创建一个带有两个参数的动态方法。 该示例发出一个简单的函数体，将第一个参数输出到控制台，该示例使用第二个参数作为方法的返回值。 该示例通过创建委托来完成方法，使用不同的参数调用委托，最后使用 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 方法调用动态方法。  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">动态方法没有方法体。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="delegateType" /> 的参数数量或参数类型不正确。</exception>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods">如何：定义和执行动态方法</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType, object target);" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType, object target) cil managed" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type, target As Object) As Delegate" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType, System::Object ^ target);" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type * obj -&gt; Delegate" Usage="dynamicMethod.CreateDelegate (delegateType, target)" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public Delegate CreateDelegate (Type delegateType, object target);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Delegate CreateDelegate(class System.Type delegateType, object target) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDelegate (delegateType As Type, target As Object) As Delegate" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Delegate ^ CreateDelegate(Type ^ delegateType, System::Object ^ target);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="F#" Value="member this.CreateDelegate : Type * obj -&gt; Delegate" Usage="dynamicMethod.CreateDelegate (delegateType, target)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="delegateType">一个签名与动态方法的签名匹配的委托类型，不包括第一个参数。</param>
        <param name="target">委托绑定到的对象。 其类型必须与动态方法的第一个参数的类型相同。</param>
        <summary>完成动态方法并创建一个可用于执行该方法的委托，指定委托类型和委托绑定到的对象。</summary>
        <returns>一个指定类型的委托，可用于对指定的目标对象执行动态方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重载创建绑定到特定对象的委托。 此类委托被称为通过其第一个参数关闭。 尽管该方法是静态的，但它的作用就像是实例方法;实例 `target`。  
  
 此方法重载要求 `target` 的类型与动态方法的第一个参数的类型相同，或可分配给该类型（例如，派生类）。  `delegateType` 的签名包含除第一个以外的动态方法的所有参数。 例如，如果动态方法具有参数 <xref:System.String>、<xref:System.Int32>和 <xref:System.Byte>，则 `delegateType` 具有参数 <xref:System.Int32> 和 <xref:System.Byte>;`target` 的类型 <xref:System.String>。  
  
 调用 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> 方法或 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 方法完成动态方法。 将忽略更改动态方法的任何进一步尝试，如修改参数定义或发出更多 Microsoft 中间语言（MSIL）;不引发异常。  
  
 若要在有自己的 MSIL 生成器时为动态方法创建方法体，请调用 <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A> 方法获取 <xref:System.Reflection.Emit.DynamicILInfo> 对象。 如果没有自己的 MSIL 生成器，请调用 <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A> 方法来获取可用于生成方法体的 <xref:System.Reflection.Emit.ILGenerator> 对象。  
  
   
  
## Examples  
 下面的代码示例创建委托，该委托将 <xref:System.Reflection.Emit.DynamicMethod> 绑定到类型的实例，以便在每次调用该方法时，该方法都在同一实例上操作。  
  
 此代码示例定义了一个名为 `Example` 的类，该类具有一个私有字段、一个名为 `DerivedFromExample` 的类，该类派生自第一个类、一个名为 `UseLikeStatic` 的委托类型，该类型返回 <xref:System.Int32> 并包含 `Example` 和 <xref:System.Int32>类型的参数，以及一个名为 `UseLikeInstance` 的委托类型，该委托类型返回 <xref:System.Int32> 并且具有一个类型 <xref:System.Int32>的参数。  
  
 然后，示例代码创建一个 <xref:System.Reflection.Emit.DynamicMethod>，该更改 `Example` 实例的私有字段，并返回以前的值。  
  
> [!NOTE]
>  通常，更改类的内部字段并不是面向对象的适当编码做法。  
  
 示例代码创建 `Example` 的实例，然后创建两个委托。 第一种类型为 `UseLikeStatic`，它具有与动态方法相同的参数。 第二种类型的类型为 `UseLikeInstance`，缺少第一个参数（类型 `Example`）。 此委托是使用 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> 方法重载创建的;此方法重载的第二个参数是 `Example`实例，在本例中为刚创建的实例，该实例绑定到新创建的委托。 只要调用该委托，动态方法就会在 `Example`的绑定实例上操作。  
  
> [!NOTE]
>  这是 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]中引入的委托绑定的宽松规则的示例，以及 <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> 方法的新重载。 有关详细信息，请参阅 <xref:System.Delegate> 类。  
  
 调用 `UseLikeStatic` 委托，并传入绑定到 `UseLikeInstance` 委托的 `Example` 的实例。 然后调用 `UseLikeInstance` 委托，使这两个委托作用于 `Example`的同一实例。 在每次调用后，将显示内部字段的值中的更改。 最后，`UseLikeInstance` 委托绑定到 `DerivedFromExample`的实例，并且委托调用重复。  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">动态方法没有方法体。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> 的类型与动态方法的第一个参数的类型不同，不能赋值给该类型。  
  
-或- 
 <paramref name="delegateType" /> 的参数数量或参数类型不正确。</exception>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取声明方法的类型，对于动态方法，此类型始终为 <see langword="null" />。</summary>
        <value>始终为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性始终为动态方法返回 `null`。 即使动态方法与类型在逻辑上相关联，它也不是由类型声明的。  
  
   
  
## Examples  
 下面的代码示例显示动态方法的声明类型。 此代码示例是为 <xref:System.Reflection.Emit.DynamicMethod> 类提供的更大示例的一部分。  
  
 [!code-cpp[Reflection.DynamicMethod.All#23](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#23)]
 [!code-csharp[Reflection.DynamicMethod.All#23](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#23)]
 [!code-vb[Reflection.DynamicMethod.All#23](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ParameterBuilder DefineParameter(int32 position, valuetype System.Reflection.ParameterAttributes attributes, string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineParameter (position As Integer, attributes As ParameterAttributes, parameterName As String) As ParameterBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ParameterBuilder ^ DefineParameter(int position, System::Reflection::ParameterAttributes attributes, System::String ^ parameterName);" />
      <MemberSignature Language="F#" Value="member this.DefineParameter : int * System.Reflection.ParameterAttributes * string -&gt; System.Reflection.Emit.ParameterBuilder" Usage="dynamicMethod.DefineParameter (position, attributes, parameterName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="parameterName" Type="System.String" Index="2" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="position">参数在参数列表中的位置。 通过第一个参数以数字 1 开头对参数编制索引。</param>
        <param name="attributes">用于指定参数属性的 <see cref="T:System.Reflection.ParameterAttributes" /> 值的按位组合。</param>
        <param name="parameterName">参数的名称。 名称可以是长度为零的字符串。</param>
        <summary>定义动态方法的参数。</summary>
        <returns>始终返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `position` 为0，则 <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> 方法将引用返回值。 设置参数信息不会影响返回值。  
  
 如果已通过调用 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> 或 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 方法完成了动态方法，则 <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> 方法不起作用。 不引发异常。  
  
   
  
## Examples  
 下面的代码示例演示如何定义动态方法的参数信息。 此代码示例是为 <xref:System.Reflection.Emit.DynamicMethod> 类提供的更大示例的一部分。  
  
 [!code-cpp[Reflection.DynamicMethod.All#33](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#33)]
 [!code-csharp[Reflection.DynamicMethod.All#33](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#33)]
 [!code-vb[Reflection.DynamicMethod.All#33](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">此方法没有参数。  
  
-或- 
 <paramref name="position" /> 小于 0。  
  
-或- 
 <paramref name="position" /> 大于此方法的参数数目。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetBaseDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="dynamicMethod.GetBaseDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回方法的基实现。</summary>
        <returns>方法的基实现。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法始终返回当前的 `DynamicMethod` 对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回应用于此方法的自定义属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="inherit">如果为 <see langword="true" />，则搜索方法的继承链以查找自定义属性；如果为 <see langword="false" />，则仅检查当前方法。</param>
        <summary>返回为该方法定义的所有自定义属性。</summary>
        <returns>一个对象数组，这些对象表示此方法的所有自定义属性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于动态方法，为 `inherit` 指定 `true` 不起作用，因为方法未在类型中声明。  
  
> [!NOTE]
>  动态方法当前不支持自定义特性。 返回的唯一属性是 <xref:System.Runtime.CompilerServices.MethodImplAttribute>;使用 <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A> 方法可以更轻松地获取方法实现标志。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="attributeType">表示要返回的自定义属性的类型的 <see cref="T:System.Type" />。</param>
        <param name="inherit">如果为 <see langword="true" />，则搜索方法的继承链以查找自定义属性；如果为 <see langword="false" />，则仅检查当前方法。</param>
        <summary>返回已应用到此方法的指定类型的自定义属性。</summary>
        <returns>对象的数组，其中的对象表示方法的类型为 <paramref name="attributeType" /> 的属性，或从类型 <paramref name="attributeType" /> 派生的属性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于动态方法，为 `inherit` 指定 `true` 不起作用，因为方法未在类型中声明。  
  
> [!NOTE]
>  动态方法当前不支持自定义特性。 返回的唯一属性是 <xref:System.Runtime.CompilerServices.MethodImplAttribute>;使用 <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A> 方法可以更轻松地获取方法实现标志。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="attributeType" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetDynamicILInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.DynamicILInfo GetDynamicILInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.DynamicILInfo GetDynamicILInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDynamicILInfo () As DynamicILInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::DynamicILInfo ^ GetDynamicILInfo();" />
      <MemberSignature Language="F#" Value="member this.GetDynamicILInfo : unit -&gt; System.Reflection.Emit.DynamicILInfo" Usage="dynamicMethod.GetDynamicILInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.DynamicILInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回 <see cref="T:System.Reflection.Emit.DynamicILInfo" /> 对象，该对象可以用于从元数据标记、范围和 Microsoft 中间语言 (MSIL) 流中生成方法主体。</summary>
        <returns>可以用于从元数据标记、范围和 MSIL 流中生成方法主体的 <see cref="T:System.Reflection.Emit.DynamicILInfo" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供 <xref:System.Reflection.Emit.DynamicILInfo> 类以支持非托管代码生成。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Emit.DynamicILInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetILGenerator">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回可用于发出动态方法的主体的 MSIL 生成器。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator () As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator();" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : unit -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为具有默认 64 字节 Microsoft 中间语言 (MSIL) 流大小的方法返回 MSIL 生成器。</summary>
        <returns>该方法的 <see cref="T:System.Reflection.Emit.ILGenerator" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 动态方法完成后，通过调用 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> 或 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 方法，将忽略添加 MSIL 的任何进一步尝试。 不引发异常。  
  
> [!NOTE]
>  对于动态方法中的不可验证代码，即使在某些完全信任的情况下也存在限制。 请参阅“验证”部分中的 <xref:System.Reflection.Emit.DynamicMethod> 注释。  
  
   
  
## Examples  
 下面的代码示例创建一个带有两个参数的动态方法。 该示例发出一个简单的函数体，将第一个参数输出到控制台，该示例使用第二个参数作为方法的返回值。 该示例通过创建委托来完成方法，使用不同的参数调用委托，最后使用 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 方法调用动态方法。  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods">如何：定义和执行动态方法</related>
      </Docs>
    </Member>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator (int streamSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator(int32 streamSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator (streamSize As Integer) As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator(int streamSize);" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : int -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator streamSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="streamSize">MSIL 流的大小（以字节为单位）。</param>
        <summary>为方法返回一个具有指定 MSIL 流大小的 Microsoft 中间语言 (MSIL) 生成器。</summary>
        <returns>方法的 <see cref="T:System.Reflection.Emit.ILGenerator" /> 对象，具有指定的 MSIL 流大小。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 动态方法完成后，通过调用 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> 或 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 方法，将忽略添加 MSIL 的任何进一步尝试。 不引发异常。  
  
> [!NOTE]
>  对于动态方法中的不可验证代码，即使在某些完全信任的情况下也存在限制。 请参阅“验证”部分中的 <xref:System.Reflection.Emit.DynamicMethod> 注释。  
  
   
  
## Examples  
 下面的代码示例演示了此方法重载。 此代码示例是为 <xref:System.Reflection.Emit.DynamicMethod> 类提供的更大示例的一部分。  
  
 [!code-cpp[Reflection.DynamicMethod.All#2](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#2)]
 [!code-csharp[Reflection.DynamicMethod.All#2](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#2)]
 [!code-vb[Reflection.DynamicMethod.All#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods">如何：定义和执行动态方法</related>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberSignature Language="F#" Value="override this.GetMethodImplementationFlags : unit -&gt; System.Reflection.MethodImplAttributes" Usage="dynamicMethod.GetMethodImplementationFlags " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为此方法返回实现标志。</summary>
        <returns>表示此方法的实现标志的 <see cref="T:System.Reflection.MethodImplAttributes" /> 值的按位组合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前，动态方法的方法实现属性始终 <xref:System.Reflection.MethodImplAttributes.IL> 和 <xref:System.Reflection.MethodImplAttributes.NoInlining>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberSignature Language="F#" Value="override this.GetParameters : unit -&gt; System.Reflection.ParameterInfo[]" Usage="dynamicMethod.GetParameters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回动态方法的参数。</summary>
        <returns>表示动态方法的参数的 <see cref="T:System.Reflection.ParameterInfo" /> 对象数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回的 <xref:System.Reflection.ParameterInfo> 对象仅用于信息。 使用 <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> 方法可设置或更改参数的特征。  
  
   
  
## Examples  
 下面的代码示例显示动态方法的参数。 此代码示例是为 <xref:System.Reflection.Emit.DynamicMethod> 类提供的更大示例的一部分。  
  
 [!code-cpp[Reflection.DynamicMethod.All#34](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#34)]
 [!code-csharp[Reflection.DynamicMethod.All#34](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#34)]
 [!code-vb[Reflection.DynamicMethod.All#34](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#34)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="InitLocals">
      <MemberSignature Language="C#" Value="public bool InitLocals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InitLocals" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberSignature Language="VB.NET" Value="Public Property InitLocals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InitLocals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.InitLocals : bool with get, set" Usage="System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示方法中的本地变量是否初始化为零。</summary>
        <value>如果该方法中的本地变量初始化为零，则为 <see langword="true" />；否则为 <see langword="false" />。 默认为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果将此属性设置为 `true`，则发出的 Microsoft 中间语言（MSIL）包括初始化局部变量。 如果将其设置为 `false`，则不会初始化局部变量，并且无法验证所生成的代码。  
  
   
  
## Examples  
 下面的代码示例显示动态方法的 <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A> 属性。 此代码示例是为 <xref:System.Reflection.Emit.DynamicMethod> 类提供的更大示例的一部分。  
  
 [!code-cpp[Reflection.DynamicMethod.All#24](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#24)]
 [!code-csharp[Reflection.DynamicMethod.All#24](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#24)]
 [!code-vb[Reflection.DynamicMethod.All#24](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Invoke (obj As Object, invokeAttr As BindingFlags, binder As Binder, parameters As Object(), culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="override this.Invoke : obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="dynamicMethod.Invoke (obj, invokeAttr, binder, parameters, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Object[]" Index="3" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="4" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">对动态方法忽略此参数，因为它们是静态的。 指定 <see langword="null" />。</param>
        <param name="invokeAttr"><see cref="T:System.Reflection.BindingFlags" /> 值的按位组合。</param>
        <param name="binder">一个 <see cref="T:System.Reflection.Binder" /> 对象，用于启用绑定、对参数类型的强制、对成员的调用，以及通过反射对 <see cref="T:System.Reflection.MemberInfo" /> 对象的检索。 如果 <paramref name="binder" /> 为 <see langword="null" />，则使用默认联编程序。 如需了解详情，请访问 <see cref="T:System.Reflection.Binder" />。</param>
        <param name="parameters">自变量列表。 此自变量数组在数量、顺序和类型方面与要调用的方法的参数相同。 如果不存在任何参数，则此参数应为 <see langword="null" />。</param>
        <param name="culture">用于控制类型强制的 <see cref="T:System.Globalization.CultureInfo" /> 的实例。 如果这是 <see langword="null" />，则使用当前线程的 <see cref="T:System.Globalization.CultureInfo" />。 例如，需要此信息将表示 1000 的 <see cref="T:System.String" /> 正确转换为 <see cref="T:System.Double" /> 值，因为不同的区域性以不同的方式表示 1000。</param>
        <summary>在指定的活页夹的约束下，用指定的区域性信息，使用指定的参数调用动态方法。</summary>
        <returns>一个 <see cref="T:System.Object" />，它包含被调用的方法的返回值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 除了列出的异常，调用代码还应准备好捕获动态方法引发的任何异常。  
  
 使用 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> 方法创建的委托执行动态方法比使用 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 方法执行动态方法更有效。  
  
 调用 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 方法或 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> 方法完成动态方法。 将忽略更改动态方法的任何进一步尝试，如修改参数定义或发出更多 Microsoft 中间语言（MSIL）;不引发异常。  
  
 所有动态方法都是静态的，因此 `obj` 参数始终被忽略。 若要将动态方法视为实例方法，请使用采用对象实例的 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> 重载。  
  
 如果动态方法不具有任何参数，则应 `null``parameters` 的值。 否则，参数数组中元素的数量、类型和顺序应与动态方法的参数的数量、类型和顺序相同。  
  
> [!NOTE]
>  此方法重载由继承自 <xref:System.Reflection.MethodBase> 类的 <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Object%5B%5D%29> 方法重载调用，因此上述备注适用于这两个重载。  
  
 此方法不直接要求权限，但调用动态方法可能会导致安全要求，具体取决于方法。 例如，对于通过将 `restrictedSkipVisibility` 参数设置为 `false`创建的匿名托管动态方法，不会产生任何要求。 另一方面，如果你创建了一个 `restrictedSkipVisibility` 设置为 `true` 的方法，以便它能够访问目标程序集的隐藏成员，则该方法将导致要求目标程序集的权限，并 <xref:System.Security.Permissions.ReflectionPermission> 与 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 标志一起使用。  
  
> [!NOTE]
>  在 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]之前，此方法需要与 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess> 标记 <xref:System.Security.Permissions.ReflectionPermission>。  
  
   
  
## Examples  
 下面的代码示例使用美国英语区域性调用具有完全绑定的动态方法。 此代码示例是为 <xref:System.Reflection.Emit.DynamicMethod> 类提供的更大示例的一部分。  
  
 [!code-cpp[Reflection.DynamicMethod.All#4](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#4)]
 [!code-csharp[Reflection.DynamicMethod.All#4](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#4)]
 [!code-vb[Reflection.DynamicMethod.All#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">不支持 <see cref="F:System.Reflection.CallingConventions.VarArgs" /> 调用约定。</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException"><paramref name="parameters" /> 中的元素数与动态方法中的参数数目不匹配。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="parameters" /> 的一个或多个元素的类型与动态方法的相应参数的类型不匹配。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">动态方法与模块关联、未以匿名方式托管，并且在 <paramref name="skipVisibility" /> 设置为 <see langword="false" /> 的情况下构造，但动态方法访问不是 <see langword="public" /> 或 <see langword="internal" />（Visual Basic 中的 <see langword="Friend" />）的成员。  
  
-或- 
动态方法被以匿名方式托管，并在 <paramref name="skipVisibility" /> 设置为 <see langword="false" /> 的情况下构造，但是它访问不是 <see langword="public" /> 的成员。  
  
-或- 
动态方法包含无法验证的代码。 请参阅“验证”部分中的 <see cref="T:System.Reflection.Emit.DynamicMethod" /> 注释。</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="dynamicMethod.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="attributeType">表示要搜索的自定义属性的类型的 <see cref="T:System.Type" />。</param>
        <param name="inherit">如果为 <see langword="true" />，则搜索方法的继承链以查找自定义属性；如果为 <see langword="false" />，则仅检查当前方法。</param>
        <summary>表示是否定义了指定的自定义属性类型。</summary>
        <returns>如果定义了指定的自定义属性类型，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于动态方法，为 `inherit` 指定 `true` 不起作用。 动态方法没有继承链。  
  
> [!NOTE]
>  动态方法当前不支持自定义特性。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前的动态方法是否为安全关键或安全可靠关键，以执行关键操作。</summary>
        <value>如果当前的动态方法是安全关键或安全可靠关键，则为 <see langword="true" />；如果它是透明的，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>、<xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>和 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> 属性报告由公共语言运行时（CLR）确定的动态方法的透明度级别。 下表显示了这些属性的组合：  
  
|安全级别|IsSecurityCritical|IsSecurityCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|严重|`true`|`false`|`false`|  
|安全关键|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 使用这些属性比检查程序集及其类型的安全批注、检查当前的信任级别，以及尝试复制运行时的规则要简单得多。  
  
 动态方法的透明度取决于它所关联的模块。 如果动态方法与类型而不是模块相关联，则其透明度取决于包含类型的模块。 动态方法没有安全批注，因此它们被分配了关联模块的默认透明度。  
  
-   匿名托管的动态方法始终是透明的，因为系统提供的包含它们的模块是透明的。  
  
-   下表描述了与受信任的程序集（即，全局程序集缓存中安装的强名称程序集）关联的动态方法的透明度。  
  
    |程序集批注|1级透明度|2级透明度|  
    |-------------------------|--------------------------|--------------------------|  
    |完全透明|透明|透明|  
    |完全关键|严重|严重|  
    |混合透明度|透明|透明|  
    |不可知安全|安全-关键|严重|  
  
     例如，如果将动态方法与包含第2级混合透明度的 mscorlib.dll 类型相关联，则动态方法是透明的，不能执行关键代码。 有关透明度级别的信息，请参阅[安全透明代码，级别 1](/dotnet/framework/misc/security-transparent-code-level-1)和[安全透明代码，级别 2](/dotnet/framework/misc/security-transparent-code-level-2)。  
  
    > [!NOTE]
    >  将动态方法与受信任的第1级程序集（如 System.object）中的模块关联不允许提升信任。 如果调用动态方法的代码的授予集不包括 System .dll 的授予集（即完全信任），则在调用动态方法时会引发 <xref:System.Security.SecurityException>。  
  
-   与部分受信任的程序集关联的动态方法的透明度取决于程序集的加载方式。 如果程序集在部分信任的情况下（例如，在沙盒应用程序域中）加载，则运行时将忽略程序集的安全注释。 程序集及其所有类型和成员（包括动态方法）都被视为透明的。 只有在完全信任的情况下（例如，在桌面应用程序的默认应用程序域中）加载部分信任程序集时，运行时才会注意到安全注释。 在这种情况下，运行时将根据程序集的批注为方法分配默认透明度。  
  
 有关反射发出和透明度的详细信息，请参阅[反射发出中的安全问题](/dotnet/framework/reflection-and-codedom/security-issues-in-reflection-emit)。 有关透明度的信息，请参阅[安全更改](/dotnet/framework/security/security-changes)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">动态方法没有方法体。</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/security-issues-in-reflection-emit">反射发出中的安全问题</related>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection">反射的安全注意事项</related>
        <related type="Article" href="/dotnet/framework/security/security-changes">.NET Framework 4.0 版中的安全性更改</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">安全透明代码，级别1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">安全性透明代码，级别 2</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前动态方法在当前信任级别上是否是安全可靠关键的；即它是否可以执行关键操作并可以由透明代码访问。</summary>
        <value>如果当前动态方法在当前信任级别上是安全可靠关键的，则为 <see langword="true" />；如果它是安全关键的或透明的，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>、<xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>和 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> 属性报告由公共语言运行时（CLR）确定的动态方法的透明度级别。 下表显示了这些属性的组合：  
  
|安全级别|IsSecurityCritical|IsSecurityCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|严重|`true`|`false`|`false`|  
|安全关键|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 使用这些属性比检查程序集及其类型的安全批注、检查当前的信任级别，以及尝试复制运行时的规则要简单得多。  
  
 动态方法的透明度取决于它所关联的模块。 如果动态方法与类型而不是模块相关联，则其透明度取决于包含类型的模块。 动态方法没有安全批注，因此它们被分配了关联模块的默认透明度。  
  
-   匿名托管的动态方法始终是透明的，因为系统提供的包含它们的模块是透明的。  
  
-   下表描述了与受信任的程序集（即，全局程序集缓存中安装的强名称程序集）关联的动态方法的透明度。  
  
    |程序集批注|1级透明度|2级透明度|  
    |-------------------------|--------------------------|--------------------------|  
    |完全透明|透明|透明|  
    |完全关键|严重|严重|  
    |混合透明度|透明|透明|  
    |不可知安全|安全-关键|严重|  
  
     例如，如果将动态方法与包含第2级混合透明度的 mscorlib.dll 类型相关联，则动态方法是透明的，不能执行关键代码。 有关透明度级别的信息，请参阅[安全透明代码，级别 1](/dotnet/framework/misc/security-transparent-code-level-1)和[安全透明代码，级别 2](/dotnet/framework/misc/security-transparent-code-level-2)。  
  
    > [!NOTE]
    >  将动态方法与受信任的第1级程序集（如 System.object）中的模块关联不允许提升信任。 如果调用动态方法的代码的授予集不包括 System .dll 的授予集（即完全信任），则在调用动态方法时会引发 <xref:System.Security.SecurityException>。  
  
-   与部分受信任的程序集关联的动态方法的透明度取决于程序集的加载方式。 如果程序集在部分信任的情况下（例如，在沙盒应用程序域中）加载，则运行时将忽略程序集的安全注释。 程序集及其所有类型和成员（包括动态方法）都被视为透明的。 只有在完全信任的情况下（例如，在桌面应用程序的默认应用程序域中）加载部分信任程序集时，运行时才会注意到安全注释。 在这种情况下，运行时将根据程序集的批注为方法分配默认透明度。  
  
 有关反射发出和透明度的详细信息，请参阅[反射发出中的安全问题](/dotnet/framework/reflection-and-codedom/security-issues-in-reflection-emit)。 有关透明度的信息，请参阅[安全更改](/dotnet/framework/security/security-changes)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">动态方法没有方法体。</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/security-issues-in-reflection-emit">反射发出中的安全问题</related>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection">反射的安全注意事项</related>
        <related type="Article" href="/dotnet/framework/security/security-changes">.NET Framework 4.0 版中的安全性更改</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">安全透明代码，级别1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">安全性透明代码，级别 2</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前的动态方法是否在当前的信任级别是透明的，并因此无法执行关键操作。</summary>
        <value>如果动态方法在当前的信任级为安全透明的，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>、<xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>和 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> 属性报告由公共语言运行时（CLR）确定的动态方法的透明度级别。 下表显示了这些属性的组合：  
  
|安全级别|IsSecurityCritical|IsSecurityCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|严重|`true`|`false`|`false`|  
|安全关键|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 使用这些属性比检查程序集及其类型的安全批注、检查当前的信任级别，以及尝试复制运行时的规则要简单得多。  
  
 动态方法的透明度取决于它所关联的模块。 如果动态方法与类型而不是模块相关联，则其透明度取决于包含类型的模块。 动态方法没有安全批注，因此它们被分配了关联模块的默认透明度。  
  
-   匿名托管的动态方法始终是透明的，因为系统提供的包含它们的模块是透明的。  
  
-   下表描述了与受信任的程序集（即，全局程序集缓存中安装的强名称程序集）关联的动态方法的透明度。  
  
    |程序集批注|1级透明度|2级透明度|  
    |-------------------------|--------------------------|--------------------------|  
    |完全透明|透明|透明|  
    |完全关键|严重|严重|  
    |混合透明度|透明|透明|  
    |不可知安全|安全-关键|严重|  
  
     例如，如果将动态方法与包含第2级混合透明度的 mscorlib.dll 类型相关联，则动态方法是透明的，不能执行关键代码。 有关透明度级别的信息，请参阅[安全透明代码，级别 1](/dotnet/framework/misc/security-transparent-code-level-1)和[安全透明代码，级别 2](/dotnet/framework/misc/security-transparent-code-level-2)。  
  
    > [!NOTE]
    >  将动态方法与受信任的第1级程序集（如 System.object）中的模块关联不允许提升信任。 如果调用动态方法的代码的授予集不包括 System .dll 的授予集（即完全信任），则在调用动态方法时会引发 <xref:System.Security.SecurityException>。  
  
-   与部分受信任的程序集关联的动态方法的透明度取决于程序集的加载方式。 如果程序集在部分信任的情况下（例如，在沙盒应用程序域中）加载，则运行时将忽略程序集的安全注释。 程序集及其所有类型和成员（包括动态方法）都被视为透明的。 只有在完全信任的情况下（例如，在桌面应用程序的默认应用程序域中）加载部分信任程序集时，运行时才会注意到安全注释。 在这种情况下，运行时将根据程序集的批注为方法分配默认透明度。  
  
 有关反射发出和透明度的详细信息，请参阅[反射发出中的安全问题](/dotnet/framework/reflection-and-codedom/security-issues-in-reflection-emit)。 有关透明度的信息，请参阅[安全更改](/dotnet/framework/security/security-changes)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">动态方法没有方法体。</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/security-issues-in-reflection-emit">反射发出中的安全问题</related>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection">反射的安全注意事项</related>
        <related type="Article" href="/dotnet/framework/security/security-changes">.NET Framework 4.0 版中的安全性更改</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">安全透明代码，级别1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">安全性透明代码，级别 2</related>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public override RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodHandle : RuntimeMethodHandle" Usage="System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>不支持动态方法。</summary>
        <value>不支持动态方法。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">不允许动态方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodImplementationFlags : System.Reflection.MethodImplAttributes" Usage="System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.Emit.DynamicMethod.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取动态方法与之在逻辑上相关联的模块。</summary>
        <value>当前动态方法与之相关联的 <see cref="T:System.Reflection.Module" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在创建动态方法时指定了模块，则此属性将返回该模块。 如果在创建动态方法时指定了类型作为所有者，则此属性将返回包含该类型的模块。  
  
   
  
## Examples  
 下面的代码示例显示动态方法的 <xref:System.Reflection.Emit.DynamicMethod.Module%2A> 属性。 此代码示例是为 <xref:System.Reflection.Emit.DynamicMethod> 类提供的更大示例的一部分。  
  
 [!code-cpp[Reflection.DynamicMethod.All#26](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#26)]
 [!code-csharp[Reflection.DynamicMethod.All#26](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#26)]
 [!code-vb[Reflection.DynamicMethod.All#26](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.DynamicMethod.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取动态方法的名称。</summary>
        <value>方法的简单名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  不需要命名动态方法。  
  
   
  
## Examples  
 下面的代码示例显示动态方法的名称。 此代码示例是为 <xref:System.Reflection.Emit.DynamicMethod> 类提供的更大示例的一部分。  
  
 [!code-cpp[Reflection.DynamicMethod.All#27](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#27)]
 [!code-csharp[Reflection.DynamicMethod.All#27](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#27)]
 [!code-vb[Reflection.DynamicMethod.All#27](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在反射中用于获取该方法的类。</summary>
        <value>始终为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性始终为动态方法返回 `null`。  
  
   
  
## Examples  
 下面的代码示例显示动态方法的反射类型。 此代码示例是为 <xref:System.Reflection.Emit.DynamicMethod> 类提供的更大示例的一部分。  
  
 [!code-cpp[Reflection.DynamicMethod.All#28](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#28)]
 [!code-csharp[Reflection.DynamicMethod.All#28](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#28)]
 [!code-vb[Reflection.DynamicMethod.All#28](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnParameter : System.Reflection.ParameterInfo" Usage="System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取动态方法的返回参数。</summary>
        <value>始终为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性始终为动态方法返回 `null`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public override Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取动态方法的返回值的类型。</summary>
        <value>一个 <see cref="T:System.Type" />，表示当前方法的返回值的类型；如果该方法没有返回类型，则为 <see cref="T:System.Void" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在创建动态方法时为返回类型指定了 `null`，则此属性将返回 <xref:System.Void?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的代码示例显示动态方法的返回类型。 此代码示例是为 <xref:System.Reflection.Emit.DynamicMethod> 类提供的更大示例的一部分。  
  
 [!code-cpp[Reflection.DynamicMethod.All#30](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#30)]
 [!code-csharp[Reflection.DynamicMethod.All#30](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#30)]
 [!code-vb[Reflection.DynamicMethod.All#30](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnTypeCustomAttributes : System.Reflection.ICustomAttributeProvider" Usage="System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取动态方法的返回类型的自定义属性。</summary>
        <value>表示动态方法的返回类型的自定义属性的 <see cref="T:System.Reflection.ICustomAttributeProvider" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 动态方法的返回类型不支持自定义特性，因此 <xref:System.Reflection.ICustomAttributeProvider.GetCustomAttributes%2A> 方法返回的自定义特性的数组始终为空。  
  
   
  
## Examples  
 下面的代码示例演示如何显示动态方法的返回类型的自定义特性。 此代码示例是为 <xref:System.Reflection.Emit.DynamicMethod> 类提供的更大示例的一部分。  
  
 [!code-cpp[Reflection.DynamicMethod.All#31](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#31)]
 [!code-csharp[Reflection.DynamicMethod.All#31](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#31)]
 [!code-vb[Reflection.DynamicMethod.All#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#31)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dynamicMethod.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示为字符串的方法的签名。</summary>
        <returns>一个表示方法签名的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 签名仅包括类型和方法名称（如果有）。 不包含参数名称。  
  
   
  
## Examples  
 下面的代码示例显示动态方法的 <xref:System.Reflection.Emit.DynamicMethod.ToString%2A> 方法。 此代码示例是为 <xref:System.Reflection.Emit.DynamicMethod> 类提供的更大示例的一部分。  
  
 [!code-cpp[Reflection.DynamicMethod.All#32](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#32)]
 [!code-csharp[Reflection.DynamicMethod.All#32](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#32)]
 [!code-vb[Reflection.DynamicMethod.All#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
