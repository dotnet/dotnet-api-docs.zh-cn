<Type Name="ILGenerator" FullName="System.Reflection.Emit.ILGenerator">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cda9982cd602231918485936f066516317ad8698" /><Meta Name="ms.sourcegitcommit" Value="c982ad9e10a242d90f1e631b5981570f9e5d9f34" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/10/2020" /><Meta Name="ms.locfileid" Value="89757888" /></Metadata><TypeSignature Language="C#" Value="public class ILGenerator" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1;xamarinios-10.8" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ILGenerator extends System.Object" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1;xamarinios-10.8" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.ILGenerator" />
  <TypeSignature Language="VB.NET" Value="Public Class ILGenerator" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1;xamarinios-10.8" />
  <TypeSignature Language="C++ CLI" Value="public ref class ILGenerator" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1;xamarinios-10.8" />
  <TypeSignature Language="F#" Value="type ILGenerator = class" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1;xamarinios-10.8" />
  <TypeSignature Language="C#" Value="public class ILGenerator : System.Runtime.InteropServices._ILGenerator" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ILGenerator extends System.Object implements class System.Runtime.InteropServices._ILGenerator" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="VB.NET" Value="Public Class ILGenerator&#xA;Implements _ILGenerator" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class ILGenerator : System::Runtime::InteropServices::_ILGenerator" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type ILGenerator = class&#xA;    interface _ILGenerator" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi beforefieldinit ILGenerator extends System.Object implements class System.Runtime.InteropServices._ILGenerator" FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Reflection.Emit.ILGeneration" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0">
      <InterfaceName>System.Runtime.InteropServices._ILGenerator</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._ILGenerator))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._ILGenerator))&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>生成 Microsoft 中间语言 (MSIL) 指令。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.ILGenerator> 用于生成动态程序集中的方法和构造函数的方法体 (由 <xref:System.Reflection.Emit.MethodBuilder> 和类表示， <xref:System.Reflection.Emit.ConstructorBuilder>) 以及类) 表示的独立动态方法 (<xref:System.Reflection.Emit.DynamicMethod> 。 若要获取 <xref:System.Reflection.Emit.ILGenerator> ，请使用 <xref:System.Reflection.Emit.ConstructorBuilder.GetILGenerator%2A?displayProperty=nameWithType> 、 <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A?displayProperty=nameWithType> 和 <xref:System.Reflection.Emit.MethodBuilder.GetILGenerator%2A?displayProperty=nameWithType> 方法。  
  
 MSIL 用作实时 (JIT) 编译器的输入。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="BeginCatchBlock">
      <MemberSignature Language="C#" Value="public virtual void BeginCatchBlock (Type exceptionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginCatchBlock(class System.Type exceptionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginCatchBlock(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginCatchBlock (exceptionType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginCatchBlock(Type ^ exceptionType);" />
      <MemberSignature Language="F#" Value="abstract member BeginCatchBlock : Type -&gt; unit&#xA;override this.BeginCatchBlock : Type -&gt; unit" Usage="iLGenerator.BeginCatchBlock exceptionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exceptionType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="exceptionType">表示异常的 <see cref="T:System.Type" /> 对象。</param>
        <summary>开始 Catch 块。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 向当前异常块的末尾发出分支指令。  
  
> [!NOTE]
>  如果筛选器异常块返回 `constant exception_execute_handler` (请参阅) 的公共语言基础结构指令集的文档，则 `BeginCatchBlock` 不会检查的参数。  
  
   
  
## Examples  
 下面的代码示例演示方法的上下文用法 `BeginCatchBlock` 。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Catch 块在已筛选的异常中。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="exceptionType" /> 为 <see langword="null" />，并且异常筛选器块没有返回一个值，该值指示在找到此 Catch 块之前应一直运行 Finally 块。</exception>
        <exception cref="T:System.NotSupportedException">要生成的 Microsoft 中间语言 (MSIL) 当前不在异常块中。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginExceptFilterBlock">
      <MemberSignature Language="C#" Value="public virtual void BeginExceptFilterBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginExceptFilterBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginExceptFilterBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginExceptFilterBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginExceptFilterBlock();" />
      <MemberSignature Language="F#" Value="abstract member BeginExceptFilterBlock : unit -&gt; unit&#xA;override this.BeginExceptFilterBlock : unit -&gt; unit" Usage="iLGenerator.BeginExceptFilterBlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>开始已筛选异常的异常块。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 向当前异常块的末尾发出分支指令。  
  
 如果当前与 <xref:System.Reflection.Emit.ILGenerator> <xref:System.Reflection.Emit.DynamicMethod> 对象关联，则不支持发出筛选的异常块。 <xref:System.Reflection.Emit.DynamicILInfo> 可用于构造使用筛选的异常块的动态方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">要生成的 Microsoft 中间语言 (MSIL) 当前不在异常块中。  
  
- 或 - 
此 <see cref="T:System.Reflection.Emit.ILGenerator" /> 属于某个 <see cref="T:System.Reflection.Emit.DynamicMethod" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginExceptionBlock">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Emit.Label BeginExceptionBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.Emit.Label BeginExceptionBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginExceptionBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginExceptionBlock () As Label" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::Label BeginExceptionBlock();" />
      <MemberSignature Language="F#" Value="abstract member BeginExceptionBlock : unit -&gt; System.Reflection.Emit.Label&#xA;override this.BeginExceptionBlock : unit -&gt; System.Reflection.Emit.Label" Usage="iLGenerator.BeginExceptionBlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.Label</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>开始非筛选异常的异常块。</summary>
        <returns>块结尾的标签。 这将使你停在正确的位置以执行 Finally 块或完成 Try 块。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 创建异常块会记录某些信息，但实际上不会将任何 Microsoft 中间语言 (MSIL) 发送到流中。  
  
   
  
## Examples  
 下面的代码示例演示方法的上下文用法 `BeginExceptionBlock` 。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginFaultBlock">
      <MemberSignature Language="C#" Value="public virtual void BeginFaultBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginFaultBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginFaultBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginFaultBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginFaultBlock();" />
      <MemberSignature Language="F#" Value="abstract member BeginFaultBlock : unit -&gt; unit&#xA;override this.BeginFaultBlock : unit -&gt; unit" Usage="iLGenerator.BeginFaultBlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在 Microsoft 中间语言 (MSIL) 流中开始一个异常错误块。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前与 <xref:System.Reflection.Emit.ILGenerator> <xref:System.Reflection.Emit.DynamicMethod> 对象关联，则不支持发出异常错误块。 <xref:System.Reflection.Emit.DynamicILInfo> 可用于构造使用异常错误块的动态方法。  
  
   
  
## Examples  
 下面的代码示例阐释了的用法 `BeginFaultBlock` 。  
  
 [!code-cpp[ILGenerator_BeginFaultBlock#1](~/samples/snippets/cpp/VS_Snippets_CLR/ILGenerator_BeginFaultBlock/CPP/ilgenerator_beginfaultblock.cpp#1)]
 [!code-csharp[ILGenerator_BeginFaultBlock#1](~/samples/snippets/csharp/VS_Snippets_CLR/ILGenerator_BeginFaultBlock/CS/ilgenerator_beginfaultblock.cs#1)]
 [!code-vb[ILGenerator_BeginFaultBlock#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ILGenerator_BeginFaultBlock/VB/ilgenerator_beginfaultblock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">生成的 MSIL 当前不在异常块中。  
  
- 或 - 
此 <see cref="T:System.Reflection.Emit.ILGenerator" /> 属于某个 <see cref="T:System.Reflection.Emit.DynamicMethod" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFinallyBlock">
      <MemberSignature Language="C#" Value="public virtual void BeginFinallyBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginFinallyBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginFinallyBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginFinallyBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginFinallyBlock();" />
      <MemberSignature Language="F#" Value="abstract member BeginFinallyBlock : unit -&gt; unit&#xA;override this.BeginFinallyBlock : unit -&gt; unit" Usage="iLGenerator.BeginFinallyBlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在 Microsoft 中间语言 (MSIL) 指令流中开始一个 Finally 块。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例阐释了的用法 `BeginFinallyBlock` 。  
  
 [!code-cpp[ILGenerator_BeginFinallyBlock_2#2](~/samples/snippets/cpp/VS_Snippets_CLR/ILGenerator_BeginFinallyBlock_2/CPP/ILGenerator_BeginFinallyBlock_2.cpp#2)]
 [!code-csharp[ILGenerator_BeginFinallyBlock_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/ILGenerator_BeginFinallyBlock_2/CS/ilgenerator_beginfinallyblock_2.cs#2)]
 [!code-vb[ILGenerator_BeginFinallyBlock_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ILGenerator_BeginFinallyBlock_2/VB/ilgenerator_beginfinallyblock_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">生成的 MSIL 当前不在异常块中。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginScope">
      <MemberSignature Language="C#" Value="public virtual void BeginScope ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginScope" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginScope ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginScope();" />
      <MemberSignature Language="F#" Value="abstract member BeginScope : unit -&gt; unit&#xA;override this.BeginScope : unit -&gt; unit" Usage="iLGenerator.BeginScope " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>开始词法范围。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于发出符号信息。 在中声明的局部变量的 <xref:System.Reflection.Emit.ILGenerator.BeginScope%2A> 作用域直到调用了相应的 <xref:System.Reflection.Emit.ILGenerator.EndScope%2A> 。  
  
 如果当前与 <xref:System.Reflection.Emit.ILGenerator> 某个对象相关联 <xref:System.Reflection.Emit.DynamicMethod> ，则它不支持符号信息。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 `BeginScope` 和 `EndScope` 。  
  
 [!code-cpp[ILGenerator_Begin_EndScope#2](~/samples/snippets/cpp/VS_Snippets_CLR/ILGenerator_Begin_EndScope/CPP/ilgenerator_begin_endscope.cpp#2)]
 [!code-csharp[ILGenerator_Begin_EndScope#2](~/samples/snippets/csharp/VS_Snippets_CLR/ILGenerator_Begin_EndScope/CS/ilgenerator_begin_endscope.cs#2)]
 [!code-vb[ILGenerator_Begin_EndScope#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ILGenerator_Begin_EndScope/VB/ilgenerator_begin_endscope.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">此 <see cref="T:System.Reflection.Emit.ILGenerator" /> 属于某个 <see cref="T:System.Reflection.Emit.DynamicMethod" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeclareLocal">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>声明局部变量。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeclareLocal">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Emit.LocalBuilder DeclareLocal (Type localType);" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.LocalBuilder DeclareLocal(class System.Type localType) cil managed" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.DeclareLocal(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeclareLocal (localType As Type) As LocalBuilder" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::LocalBuilder ^ DeclareLocal(Type ^ localType);" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member DeclareLocal : Type -&gt; System.Reflection.Emit.LocalBuilder&#xA;override this.DeclareLocal : Type -&gt; System.Reflection.Emit.LocalBuilder" Usage="iLGenerator.DeclareLocal localType" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.LocalBuilder DeclareLocal (Type localType);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.LocalBuilder DeclareLocal(class System.Type localType) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Function DeclareLocal (localType As Type) As LocalBuilder" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::LocalBuilder ^ DeclareLocal(Type ^ localType);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="member this.DeclareLocal : Type -&gt; System.Reflection.Emit.LocalBuilder" Usage="iLGenerator.DeclareLocal localType" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.LocalBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="localType">一个 <see cref="T:System.Type" /> 对象，表示局部变量的类型。</param>
        <summary>声明指定类型的局部变量。</summary>
        <returns>已声明的局部变量。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在当前词法范围内创建本地变量;例如，如果代码在 `for` Visual Basic) 的循环中发出 (`For` 循环，则该变量的作用域为循环。  
  
 使用此重载创建的局部变量未固定。 若要创建用于非托管指针的固定变量，请使用 <xref:System.Reflection.Emit.ILGenerator.DeclareLocal%28System.Type%2CSystem.Boolean%29> 方法重载。  
  
   
  
## Examples  
 下面的代码示例演示方法的用法 `DeclareLocal` 。 此代码是该类的较大代码示例的一部分 <xref:System.Reflection.Emit.LocalBuilder> 。  
  
 [!code-cpp[LocalBuilder_Sample_SetLocalSymInfo#2](~/samples/snippets/cpp/VS_Snippets_CLR/LocalBuilder_Sample_SetLocalSymInfo/CPP/localbuilder_sample_4.cpp#2)]
 [!code-csharp[LocalBuilder_Sample_SetLocalSymInfo#2](~/samples/snippets/csharp/VS_Snippets_CLR/LocalBuilder_Sample_SetLocalSymInfo/CS/localbuilder_sample_4.cs#2)]
 [!code-vb[LocalBuilder_Sample_SetLocalSymInfo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/LocalBuilder_Sample_SetLocalSymInfo/VB/localbuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="localType" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">包含类型已由 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 方法创建。</exception>
      </Docs>
    </Member>
    <Member MemberName="DeclareLocal">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Emit.LocalBuilder DeclareLocal (Type localType, bool pinned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.LocalBuilder DeclareLocal(class System.Type localType, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.DeclareLocal(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeclareLocal (localType As Type, pinned As Boolean) As LocalBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::LocalBuilder ^ DeclareLocal(Type ^ localType, bool pinned);" />
      <MemberSignature Language="F#" Value="abstract member DeclareLocal : Type * bool -&gt; System.Reflection.Emit.LocalBuilder&#xA;override this.DeclareLocal : Type * bool -&gt; System.Reflection.Emit.LocalBuilder" Usage="iLGenerator.DeclareLocal (localType, pinned)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.LocalBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localType" Type="System.Type" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pinned" Type="System.Boolean" Index="1" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localType">一个 <see cref="T:System.Type" /> 对象，表示局部变量的类型。</param>
        <param name="pinned">如果要将对象固定在内存中，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>声明指定类型的局部变量，还可以选择固定该变量所引用的对象。</summary>
        <returns>一个 <see cref="T:System.Reflection.Emit.LocalBuilder" /> 对象，表示局部变量。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在当前词法范围内创建本地变量;例如，如果代码在 `for` Visual Basic) 的循环中发出 (`For` 循环，则该变量的作用域为循环。  
  
 在不安全代码中，必须先固定对象，然后才能通过非托管指针引用该对象。 当被引用的对象固定时，它无法通过垃圾回收进行移动。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="localType" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">包含类型已由 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 方法创建。  
  
- 或 - 
封闭方法的方法体已由 <see cref="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)" /> 方法创建。</exception>
        <exception cref="T:System.NotSupportedException">与此 <see cref="T:System.Reflection.Emit.ILGenerator" /> 关联的方法不由 <see cref="T:System.Reflection.Emit.MethodBuilder" /> 来表示。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineLabel">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Emit.Label DefineLabel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.Emit.Label DefineLabel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.DefineLabel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DefineLabel () As Label" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::Label DefineLabel();" />
      <MemberSignature Language="F#" Value="abstract member DefineLabel : unit -&gt; System.Reflection.Emit.Label&#xA;override this.DefineLabel : unit -&gt; System.Reflection.Emit.Label" Usage="iLGenerator.DefineLabel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.Label</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>声明新标签。</summary>
        <returns>可用作分支令牌的新标签。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要设置标签在流中的位置，必须调用 <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A> 。 如果不这样做，将导致 <xref:System.ArgumentException> <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> 调用时。
  
 这只是一个令牌，并不表示流中的任何特定位置。  
  
   
  
## Examples  
 下面的代码示例演示方法的上下文用法 `DefineLabel` 。  
  
 [!code-cpp[System.Reflection.Emit.Label Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.Label Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.Label Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.Label Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.Label Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.Label Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Emit">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将指令放到实时 (JIT) 编译器的 Microsoft 中间语言 (MSIL) 流上。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Emit (opcode As OpCode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode -&gt; unit" Usage="iLGenerator.Emit opcode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="opcode">要放到流上的 Microsoft 中间语言 (MSIL) 指令。</param>
        <summary>将指定的指令放到指令流上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `opcode` 参数需要参数，则调用方必须确保参数长度与已声明参数的长度匹配。 否则，结果将是不可预知的。 例如，如果发出指令需要2字节操作数，并且调用方提供4字节操作数，则运行时将向指令流发出两个额外的字节。 这些额外的字节将是 <xref:System.Reflection.Emit.OpCodes.Nop> 说明。  
  
 中定义了说明值 <xref:System.Reflection.Emit.OpCodes> 。  
  
   
  
## Examples  
 下面的代码示例演示 `Emit` 如何使用通过实例生成 MSIL 输出 <xref:System.Reflection.Emit.ILGenerator> 。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, byte arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, unsigned int8 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Emit (opcode As OpCode, arg As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Byte arg);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * byte -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * byte -&gt; unit" Usage="iLGenerator.Emit (opcode, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="opcode">要放到流上的 MSIL 指令。</param>
        <param name="arg">紧接着该指令推到流中的字符参数。</param>
        <summary>将指定的指令和字符参数放到 Microsoft 中间语言 (MSIL) 指令流上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 说明值是在枚举中定义的 `OpCodes` 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, double arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, float64 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Emit (opcode As OpCode, arg As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, double arg);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * double -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * double -&gt; unit" Usage="iLGenerator.Emit (opcode, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="opcode">要放到流上的 MSIL 指令。 在 <see langword="OpCodes" /> 枚举中定义。</param>
        <param name="arg">紧接着该指令推到流中的数字参数。</param>
        <summary>将指定的指令和数值参数放到 Microsoft 中间语言 (MSIL) 指令流上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 说明值是在枚举中定义的 `OpCodes` 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, short arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, int16 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Emit (opcode As OpCode, arg As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, short arg);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * int16 -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * int16 -&gt; unit" Usage="iLGenerator.Emit (opcode, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="opcode">要发出到流的 MSIL 指令。</param>
        <param name="arg">紧接着该指令推到流中的 <see langword="Int" /> 参数。</param>
        <summary>将指定的指令和数值参数放到 Microsoft 中间语言 (MSIL) 指令流上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 说明值是在枚举中定义的 `OpCodes` 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, int arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, int32 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Emit (opcode As OpCode, arg As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, int arg);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * int -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * int -&gt; unit" Usage="iLGenerator.Emit (opcode, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="opcode">要放到流上的 MSIL 指令。</param>
        <param name="arg">紧接着该指令推到流中的数字参数。</param>
        <summary>将指定的指令和数值参数放到 Microsoft 中间语言 (MSIL) 指令流上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 说明值是在枚举中定义的 `OpCodes` 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, long arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, int64 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Emit (opcode As OpCode, arg As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, long arg);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * int64 -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * int64 -&gt; unit" Usage="iLGenerator.Emit (opcode, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="opcode">要放到流上的 MSIL 指令。</param>
        <param name="arg">紧接着该指令推到流中的数字参数。</param>
        <summary>将指定的指令和数值参数放到 Microsoft 中间语言 (MSIL) 指令流上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 说明值是在枚举中定义的 `OpCodes` 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.ConstructorInfo con);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.ConstructorInfo con) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Emit (opcode As OpCode, con As ConstructorInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::ConstructorInfo ^ con);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * System.Reflection.ConstructorInfo -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * System.Reflection.ConstructorInfo -&gt; unit" Usage="iLGenerator.Emit (opcode, con)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="opcode">要发出到流的 MSIL 指令。</param>
        <param name="con">表示构造函数的 <see langword="ConstructorInfo" />。</param>
        <summary>将指定构造函数的指定指令和元数据令牌放到 Microsoft 中间语言 (MSIL) 指令流上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 说明值是在枚举中定义的 `OpCodes` 。  
  
 记录的位置，以便在将 `con` 模块保存到可移植的可执行文件 (PE) 文件时，可以对指令流进行修补（如果需要）。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="con" /> 为 <see langword="null" />。 此异常是 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 中新出现的。</exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.Label label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Reflection.Emit.Label label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Emit (opcode As OpCode, label As Label)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::Emit::Label label);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.Label -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.Label -&gt; unit" Usage="iLGenerator.Emit (opcode, label)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="label" Type="System.Reflection.Emit.Label" />
      </Parameters>
      <Docs>
        <param name="opcode">要发出到流的 MSIL 指令。</param>
        <param name="label">从此位置分支到的标签。</param>
        <summary>将指定的指令放到 Microsoft 中间语言 (MSIL) 流上，并留出在完成修正时加上标签所需的空白。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 说明值是在枚举中定义的 `OpCodes` 。  
  
 标签是使用创建的 <xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A> ，其在流中的位置是使用固定的 <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A> 。 如果使用单字节指令，则标签最多可以表示流中最多127个字节。 `opcode` 必须表示分支指令。 由于分支是相对说明，因此在 `label` 修复过程中将替换为分支的正确偏移量。  
  
   
  
## Examples  
 下面的代码示例演示如何使用跳转表创建动态方法。 跳转表是使用数组生成的 <xref:System.Reflection.Emit.Label> 。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.Label[] labels);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Reflection.Emit.Label[] labels) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Emit (opcode As OpCode, labels As Label())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, cli::array &lt;System::Reflection::Emit::Label&gt; ^ labels);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.Label[] -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.Label[] -&gt; unit" Usage="iLGenerator.Emit (opcode, labels)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="labels" Type="System.Reflection.Emit.Label[]" />
      </Parameters>
      <Docs>
        <param name="opcode">要发出到流的 MSIL 指令。</param>
        <param name="labels">从此位置分支到的标签对象的数组。 将使用所有标签。</param>
        <summary>将指定的指令放到 Microsoft 中间语言 (MSIL) 流上，并留出在完成修正时加上标签所需的空白。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 发出切换表。  
  
 说明值是在枚举中定义的 `OpCodes` 。  
  
 标签是使用创建的 <xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A> ，其在流中的位置是使用固定的 <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A> 。 如果使用单字节指令，则标签最多可以表示流中最多127个字节。 `opcode` 必须表示分支指令。 由于分支是相对说明，因此在 `label` 修复过程中将替换为分支的正确偏移量。  
  
   
  
## Examples  
 下面的代码示例演示如何使用跳转表创建动态方法。 跳转表是使用数组生成的 <xref:System.Reflection.Emit.Label> 。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="con" /> 为 <see langword="null" />。 此异常是 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 中新出现的。</exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.LocalBuilder local);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.Emit.LocalBuilder local) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.LocalBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Emit (opcode As OpCode, local As LocalBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::Emit::LocalBuilder ^ local);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.LocalBuilder -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.LocalBuilder -&gt; unit" Usage="iLGenerator.Emit (opcode, local)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="local" Type="System.Reflection.Emit.LocalBuilder" />
      </Parameters>
      <Docs>
        <param name="opcode">要发出到流的 MSIL 指令。</param>
        <param name="local">局部变量。</param>
        <summary>将指定的指令放到 Microsoft 中间语言 (MSIL) 流上，后跟给定局部变量的索引。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 说明值是在枚举中定义的 `OpCodes` 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="local" /> 参数的父方法与此 <see cref="T:System.Reflection.Emit.ILGenerator" /> 关联的方法不匹配。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="local" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="opcode" /> 是单字节指令，并且 <paramref name="local" /> 表示索引大于 <see langword="Byte.MaxValue" /> 的局部变量。</exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.SignatureHelper signature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.Emit.SignatureHelper signature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.SignatureHelper)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Emit (opcode As OpCode, signature As SignatureHelper)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::Emit::SignatureHelper ^ signature);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.SignatureHelper -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.SignatureHelper -&gt; unit" Usage="iLGenerator.Emit (opcode, signature)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="signature" Type="System.Reflection.Emit.SignatureHelper" />
      </Parameters>
      <Docs>
        <param name="opcode">要发出到流的 MSIL 指令。</param>
        <param name="signature">用于构造签名令牌的帮助程序。</param>
        <summary>将指定的指令和签名令牌放到 Microsoft 中间语言 (MSIL) 指令流上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 说明值是在枚举中定义的 `OpCodes` 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="signature" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.FieldInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Emit (opcode As OpCode, field As FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::FieldInfo ^ field);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * System.Reflection.FieldInfo -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * System.Reflection.FieldInfo -&gt; unit" Usage="iLGenerator.Emit (opcode, field)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="opcode">要发出到流的 MSIL 指令。</param>
        <param name="field">表示字段的 <see langword="FieldInfo" />。</param>
        <summary>将指定字段的指定指令和元数据令牌放到 Microsoft 中间语言 (MSIL) 指令流上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 说明值是在枚举中定义的 `OpCodes` 。 记录的位置，以便在将 `field` 模块保存到可移植的可执行文件 (PE) 文件时，可以对指令流进行修补（如果需要）。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.MethodInfo meth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.MethodInfo meth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Emit (opcode As OpCode, meth As MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::MethodInfo ^ meth);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * System.Reflection.MethodInfo -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * System.Reflection.MethodInfo -&gt; unit" Usage="iLGenerator.Emit (opcode, meth)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="meth" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="opcode">要发出到流的 MSIL 指令。</param>
        <param name="meth">表示方法的 <see langword="MethodInfo" />。</param>
        <summary>将指定的指令放到 Microsoft 中间语言 (MSIL) 流上，后跟给定方法的元数据令牌。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 说明值是在枚举中定义的 `OpCodes` 。  
  
 记录的位置，以便在将 `meth` 模块保存到可移植的可执行文件 (PE) 文件时，可以对指令流进行修补（如果需要）。  
  
 如果 `meth` 表示泛型方法，则它必须是泛型方法定义。 也就是说，其 [IsGenericMethodDefinition](xref:System.Reflection.MethodBase.IsGenericMethodDefinition) 属性必须是 `true` 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="meth" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="meth" /> 为泛型方法，其 <see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" /> 属性为 <see langword="false" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public void Emit (System.Reflection.Emit.OpCode opcode, sbyte arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, int8 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Emit (opcode As OpCode, arg As SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Emit(System::Reflection::Emit::OpCode opcode, System::SByte arg);" />
      <MemberSignature Language="F#" Value="member this.Emit : System.Reflection.Emit.OpCode * sbyte -&gt; unit" Usage="iLGenerator.Emit (opcode, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="opcode">要放到流上的 MSIL 指令。</param>
        <param name="arg">紧接着该指令推到流中的字符参数。</param>
        <summary>将指定的指令和字符参数放到 Microsoft 中间语言 (MSIL) 指令流上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 说明值是在枚举中定义的 `OpCodes` 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, float arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, float32 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Emit (opcode As OpCode, arg As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, float arg);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * single -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * single -&gt; unit" Usage="iLGenerator.Emit (opcode, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="opcode">要放到流上的 MSIL 指令。</param>
        <param name="arg">紧接着该指令推到流中的 <see cref="T:System.Single" /> 参数。</param>
        <summary>将指定的指令和数值参数放到 Microsoft 中间语言 (MSIL) 指令流上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 说明值是在枚举中定义的 `OpCodes` 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, string str);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Emit (opcode As OpCode, str As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::String ^ str);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * string -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * string -&gt; unit" Usage="iLGenerator.Emit (opcode, str)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="opcode">要发出到流的 MSIL 指令。</param>
        <param name="str">要发出的 <see langword="String" />。</param>
        <summary>将指定的指令放到 Microsoft 中间语言 (MSIL) 流上，后跟给定字符串的元数据令牌。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 说明值是在枚举中定义的 `OpCodes` 。 `str`如果模块保存到可移植的可执行文件 (PE) 文件中，则会记录的位置以供将来修正。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, Type cls);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Type cls) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Emit (opcode As OpCode, cls As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, Type ^ cls);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * Type -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * Type -&gt; unit" Usage="iLGenerator.Emit (opcode, cls)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="cls" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="opcode">要放到流上的 MSIL 指令。</param>
        <param name="cls"><see langword="Type" />。</param>
        <summary>将指定的指令放到 Microsoft 中间语言 (MSIL) 流上，后跟给定类型的元数据令牌。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 说明值是在枚举中定义的 `OpCodes` 。 记录的位置，以便在将 `cls` 模块保存到可移植的可执行文件 (PE) 文件时，可以对令牌进行修补。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="cls" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="EmitCall">
      <MemberSignature Language="C#" Value="public virtual void EmitCall (System.Reflection.Emit.OpCode opcode, System.Reflection.MethodInfo methodInfo, Type[]? optionalParameterTypes);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitCall(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.MethodInfo methodInfo, class System.Type[] optionalParameterTypes) cil managed" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitCall(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EmitCall (opcode As OpCode, methodInfo As MethodInfo, optionalParameterTypes As Type())" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitCall(System::Reflection::Emit::OpCode opcode, System::Reflection::MethodInfo ^ methodInfo, cli::array &lt;Type ^&gt; ^ optionalParameterTypes);" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member EmitCall : System.Reflection.Emit.OpCode * System.Reflection.MethodInfo * Type[] -&gt; unit&#xA;override this.EmitCall : System.Reflection.Emit.OpCode * System.Reflection.MethodInfo * Type[] -&gt; unit" Usage="iLGenerator.EmitCall (opcode, methodInfo, optionalParameterTypes)" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public virtual void EmitCall (System.Reflection.Emit.OpCode opcode, System.Reflection.MethodInfo methodInfo, Type[] optionalParameterTypes);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public void EmitCall (System.Reflection.Emit.OpCode opcode, System.Reflection.MethodInfo methodInfo, Type[] optionalParameterTypes);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EmitCall(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.MethodInfo methodInfo, class System.Type[] optionalParameterTypes) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Sub EmitCall (opcode As OpCode, methodInfo As MethodInfo, optionalParameterTypes As Type())" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EmitCall(System::Reflection::Emit::OpCode opcode, System::Reflection::MethodInfo ^ methodInfo, cli::array &lt;Type ^&gt; ^ optionalParameterTypes);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="member this.EmitCall : System.Reflection.Emit.OpCode * System.Reflection.MethodInfo * Type[] -&gt; unit" Usage="iLGenerator.EmitCall (opcode, methodInfo, optionalParameterTypes)" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="optionalParameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="opcode">要发出到流的 MSIL 指令。 必须为 <see cref="F:System.Reflection.Emit.OpCodes.Call" />、<see cref="F:System.Reflection.Emit.OpCodes.Callvirt" /> 或 <see cref="F:System.Reflection.Emit.OpCodes.Newobj" />。</param>
        <param name="methodInfo">要调用的 <see langword="varargs" /> 方法。</param>
        <param name="optionalParameterTypes">如果方法是 <see langword="varargs" /> 方法，则为可选参数的类型；否则为 <see langword="null" />。</param>
        <summary>将 <see langword="call" /> 或 <see langword="callvirt" /> 指令置于 Microsoft 中间语言 (MSIL) 流，以调用 <see langword="varargs" /> 方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A>方法用于发出对方法的调用， `varargs` 因为没有方法的重载来 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 指定变量参数的参数类型。  
  
 若要发出对不使用调用约定的方法的调用 <xref:System.Reflection.CallingConventions.VarArgs> ，请使用 <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%29> 方法重载。  
  
## <a name="version-information"></a>版本信息  
 从 .NET Framework 版本2.0 开始，如果为 <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> 非的方法指定了可选参数类型，则该方法不会引发异常 `varargs` 。 <xref:System.InvalidProgramException> 执行调用时引发。  
  
   
  
## Examples  
 下面的代码示例发出两个方法，即一个 `varargs` 方法和一个调用方法的方法 `varargs` 。 `EmitCall`方法用于发出对方法的调用 `varargs` 。  
  
 [!code-cpp[Emit.ArgIterator#1](~/samples/snippets/cpp/VS_Snippets_CLR/Emit.ArgIterator/cpp/source.cpp#1)]
 [!code-csharp[Emit.ArgIterator#1](~/samples/snippets/csharp/VS_Snippets_CLR/Emit.ArgIterator/cs/source.cs#1)]
 [!code-vb[Emit.ArgIterator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Emit.ArgIterator/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="opcode" /> 未指定方法调用。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="methodInfo" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">该方法的调用约定不是 <see langword="varargs" />，但提供可选的参数类型。 .NET Framework 版本 1.0 和 1.1 中会引发此异常，后续版本中不会引发异常。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EmitCalli">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将 <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> 指令放到 Microsoft 中间语言 (MSIL) 流上。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EmitCalli">
      <MemberSignature Language="C#" Value="public virtual void EmitCalli (System.Reflection.Emit.OpCode opcode, System.Runtime.InteropServices.CallingConvention unmanagedCallConv, Type returnType, Type[]? parameterTypes);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitCalli(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Runtime.InteropServices.CallingConvention unmanagedCallConv, class System.Type returnType, class System.Type[] parameterTypes) cil managed" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitCalli(System.Reflection.Emit.OpCode,System.Runtime.InteropServices.CallingConvention,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EmitCalli (opcode As OpCode, unmanagedCallConv As CallingConvention, returnType As Type, parameterTypes As Type())" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitCalli(System::Reflection::Emit::OpCode opcode, System::Runtime::InteropServices::CallingConvention unmanagedCallConv, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member EmitCalli : System.Reflection.Emit.OpCode * System.Runtime.InteropServices.CallingConvention * Type * Type[] -&gt; unit&#xA;override this.EmitCalli : System.Reflection.Emit.OpCode * System.Runtime.InteropServices.CallingConvention * Type * Type[] -&gt; unit" Usage="iLGenerator.EmitCalli (opcode, unmanagedCallConv, returnType, parameterTypes)" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public virtual void EmitCalli (System.Reflection.Emit.OpCode opcode, System.Runtime.InteropServices.CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes);" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public void EmitCalli (System.Reflection.Emit.OpCode opcode, System.Runtime.InteropServices.CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EmitCalli(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Runtime.InteropServices.CallingConvention unmanagedCallConv, class System.Type returnType, class System.Type[] parameterTypes) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Sub EmitCalli (opcode As OpCode, unmanagedCallConv As CallingConvention, returnType As Type, parameterTypes As Type())" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EmitCalli(System::Reflection::Emit::OpCode opcode, System::Runtime::InteropServices::CallingConvention unmanagedCallConv, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="member this.EmitCalli : System.Reflection.Emit.OpCode * System.Runtime.InteropServices.CallingConvention * Type * Type[] -&gt; unit" Usage="iLGenerator.EmitCalli (opcode, unmanagedCallConv, returnType, parameterTypes)" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" Index="0" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="unmanagedCallConv" Type="System.Runtime.InteropServices.CallingConvention" Index="1" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="returnType" Type="System.Type" Index="2" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="parameterTypes" Type="System.Type[]" Index="3" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="opcode">要发出到流的 MSIL 指令。 必须是 <see cref="F:System.Reflection.Emit.OpCodes.Calli" />。</param>
        <param name="unmanagedCallConv">要使用的非托管调用约定。</param>
        <param name="returnType">结果的 <see cref="T:System.Type" />。</param>
        <param name="parameterTypes">指令的必选参数的类型。</param>
        <summary>将 <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> 指令放到 Microsoft 中间语言 (MSIL) 流，并指定间接调用的非托管调用约定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用将 <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> 指令置于 <xref:System.Reflection.Emit.OpCodes.Calli> 流中。 请勿使用 <xref:System.Reflection.Emit.ILGenerator.Emit%2A>。  
  
   
  
## Examples  
 下面的代码示例演示方法的上下文用法 <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> ，以调用动态类外部的非托管类型方法。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.EmitCalli Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.EmitCalli Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.EmitCalli Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.EmitCalli Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.EmitCalli Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.EmitCalli Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmitCalli">
      <MemberSignature Language="C#" Value="public virtual void EmitCalli (System.Reflection.Emit.OpCode opcode, System.Reflection.CallingConventions callingConvention, Type returnType, Type[]? parameterTypes, Type[]? optionalParameterTypes);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitCalli(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Type[] optionalParameterTypes) cil managed" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitCalli(System.Reflection.Emit.OpCode,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EmitCalli (opcode As OpCode, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), optionalParameterTypes As Type())" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitCalli(System::Reflection::Emit::OpCode opcode, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;Type ^&gt; ^ optionalParameterTypes);" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member EmitCalli : System.Reflection.Emit.OpCode * System.Reflection.CallingConventions * Type * Type[] * Type[] -&gt; unit&#xA;override this.EmitCalli : System.Reflection.Emit.OpCode * System.Reflection.CallingConventions * Type * Type[] * Type[] -&gt; unit" Usage="iLGenerator.EmitCalli (opcode, callingConvention, returnType, parameterTypes, optionalParameterTypes)" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public virtual void EmitCalli (System.Reflection.Emit.OpCode opcode, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public void EmitCalli (System.Reflection.Emit.OpCode opcode, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EmitCalli(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Type[] optionalParameterTypes) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Sub EmitCalli (opcode As OpCode, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), optionalParameterTypes As Type())" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EmitCalli(System::Reflection::Emit::OpCode opcode, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;Type ^&gt; ^ optionalParameterTypes);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="member this.EmitCalli : System.Reflection.Emit.OpCode * System.Reflection.CallingConventions * Type * Type[] * Type[] -&gt; unit" Usage="iLGenerator.EmitCalli (opcode, callingConvention, returnType, parameterTypes, optionalParameterTypes)" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="optionalParameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="opcode">要发出到流的 MSIL 指令。 必须是 <see cref="F:System.Reflection.Emit.OpCodes.Calli" />。</param>
        <param name="callingConvention">要使用的托管调用约定。</param>
        <param name="returnType">结果的 <see cref="T:System.Type" />。</param>
        <param name="parameterTypes">指令的必选参数的类型。</param>
        <param name="optionalParameterTypes"><see langword="varargs" /> 调用的可选参数的类型。</param>
        <summary>将 <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> 指令放到 Microsoft 中间语言 (MSIL) 流，并指定间接调用的托管调用约定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用将 <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> 指令置于 <xref:System.Reflection.Emit.OpCodes.Calli> 流中。 请勿使用 <xref:System.Reflection.Emit.ILGenerator.Emit%2A>。  
  
 如果 `optionalParameterTypes` 指定可选参数，则 `callingConvention` 必须包含 <xref:System.Reflection.CallingConventions.VarArgs?displayProperty=nameWithType> 标志。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="optionalParameterTypes" /> 不为 <see langword="null" />，但 <paramref name="callingConvention" /> 不包括 <see cref="F:System.Reflection.CallingConventions.VarArgs" /> 标志。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EmitWriteLine">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用不同类型的值发出对 <see cref="M:System.Console.WriteLine" /> 的调用的 Helper 函数。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EmitWriteLine">
      <MemberSignature Language="C#" Value="public virtual void EmitWriteLine (System.Reflection.Emit.LocalBuilder localBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitWriteLine(class System.Reflection.Emit.LocalBuilder localBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitWriteLine(System.Reflection.Emit.LocalBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EmitWriteLine (localBuilder As LocalBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitWriteLine(System::Reflection::Emit::LocalBuilder ^ localBuilder);" />
      <MemberSignature Language="F#" Value="abstract member EmitWriteLine : System.Reflection.Emit.LocalBuilder -&gt; unit&#xA;override this.EmitWriteLine : System.Reflection.Emit.LocalBuilder -&gt; unit" Usage="iLGenerator.EmitWriteLine localBuilder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localBuilder" Type="System.Reflection.Emit.LocalBuilder" />
      </Parameters>
      <Docs>
        <param name="localBuilder">其值将写入控制台的本地变量。</param>
        <summary>发出使用给定本地变量调用 <see cref="Overload:System.Console.WriteLine" /> 时必需的 Microsoft 中间语言 (MSIL)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的类型 `localBuilder` 必须与方法的重载的参数类型相匹配 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 。  
  
   
  
## Examples  
 下面的代码示例演示了方法的上下文用法 <xref:System.Reflection.Emit.ILGenerator.EmitWriteLine%2A> ，以动态方法将字符串写入控制台。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="localBuilder" /> 的类型是不受支持的 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 或 <see cref="T:System.Reflection.Emit.EnumBuilder" />。  
  
- 或 - 
没有 <see cref="Overload:System.Console.WriteLine" /> 的重载接受 <paramref name="localBuilder" /> 的类型。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="localBuilder" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="EmitWriteLine">
      <MemberSignature Language="C#" Value="public virtual void EmitWriteLine (System.Reflection.FieldInfo fld);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitWriteLine(class System.Reflection.FieldInfo fld) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitWriteLine(System.Reflection.FieldInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EmitWriteLine (fld As FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitWriteLine(System::Reflection::FieldInfo ^ fld);" />
      <MemberSignature Language="F#" Value="abstract member EmitWriteLine : System.Reflection.FieldInfo -&gt; unit&#xA;override this.EmitWriteLine : System.Reflection.FieldInfo -&gt; unit" Usage="iLGenerator.EmitWriteLine fld" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fld" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="fld">其值将写入控制台的字段。</param>
        <summary>发出用给定字段调用 <see cref="Overload:System.Console.WriteLine" /> 所需的 Microsoft 中间语言 (MSIL)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的类型 `fld` 必须与方法的重载的参数类型相匹配 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 。  
  
   
  
## Examples  
 下面的代码示例演示 <xref:System.Reflection.Emit.ILGenerator.EmitWriteLine%2A> 如何使用方法在动态方法中将字符串写入控制台。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">不存在接受指定字段类型的 <see cref="Overload:System.Console.WriteLine" /> 方法重载。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="fld" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">字段类型为 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 或 <see cref="T:System.Reflection.Emit.EnumBuilder" />，这两种类型都不受支持。</exception>
      </Docs>
    </Member>
    <Member MemberName="EmitWriteLine">
      <MemberSignature Language="C#" Value="public virtual void EmitWriteLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitWriteLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitWriteLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EmitWriteLine (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitWriteLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member EmitWriteLine : string -&gt; unit&#xA;override this.EmitWriteLine : string -&gt; unit" Usage="iLGenerator.EmitWriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要打印的字符串。</param>
        <summary>发出 Microsoft 中间语言 (MSIL) 以用字符串调用 <see cref="Overload:System.Console.WriteLine" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必须已定义该字符串。  
  
   
  
## Examples  
 下面的代码示例演示了方法的上下文用法 `EmitWriteLine` ，以动态方法将字符串写入控制台。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndExceptionBlock">
      <MemberSignature Language="C#" Value="public virtual void EndExceptionBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndExceptionBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EndExceptionBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndExceptionBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndExceptionBlock();" />
      <MemberSignature Language="F#" Value="abstract member EndExceptionBlock : unit -&gt; unit&#xA;override this.EndExceptionBlock : unit -&gt; unit" Usage="iLGenerator.EndExceptionBlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>结束异常块。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示方法的上下文用法 `EndExceptionBlock` 。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">结束异常块在代码流中的意外位置出现。</exception>
        <exception cref="T:System.NotSupportedException">要生成的 Microsoft 中间语言 (MSIL) 当前不在异常块中。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndScope">
      <MemberSignature Language="C#" Value="public virtual void EndScope ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EndScope" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndScope ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndScope();" />
      <MemberSignature Language="F#" Value="abstract member EndScope : unit -&gt; unit&#xA;override this.EndScope : unit -&gt; unit" Usage="iLGenerator.EndScope " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>结束词法范围。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于发出符号信息。 它与一起使用 <xref:System.Reflection.Emit.ILGenerator.BeginScope%2A> 。  
  
 如果当前与 <xref:System.Reflection.Emit.ILGenerator> 某个对象相关联 <xref:System.Reflection.Emit.DynamicMethod> ，则它不支持符号信息。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 `BeginScope` 和 `EndScope` 。  
  
 [!code-cpp[ILGenerator_Begin_EndScope#2](~/samples/snippets/cpp/VS_Snippets_CLR/ILGenerator_Begin_EndScope/CPP/ilgenerator_begin_endscope.cpp#2)]
 [!code-csharp[ILGenerator_Begin_EndScope#2](~/samples/snippets/csharp/VS_Snippets_CLR/ILGenerator_Begin_EndScope/CS/ilgenerator_begin_endscope.cs#2)]
 [!code-vb[ILGenerator_Begin_EndScope#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ILGenerator_Begin_EndScope/VB/ilgenerator_begin_endscope.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">此 <see cref="T:System.Reflection.Emit.ILGenerator" /> 属于某个 <see cref="T:System.Reflection.Emit.DynamicMethod" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ILOffset">
      <MemberSignature Language="C#" Value="public virtual int ILOffset { get; }" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ILOffset" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ILGenerator.ILOffset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ILOffset As Integer" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ILOffset { int get(); };" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.ILOffset : int" Usage="System.Reflection.Emit.ILGenerator.ILOffset" />
      <MemberSignature Language="C#" Value="public int ILOffset { get; }" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ILOffset As Integer" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ILOffset { int get(); };" FrameworkAlternate="xamarinios-10.8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取由 <see cref="T:System.Reflection.Emit.ILGenerator" /> 发出的 Microsoft 中间语言 (MSIL) 流中的当前偏移量（以字节为单位）。</summary>
        <value>MSIL 流中的偏移量，将在此处发出下一个指令。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是透明的，可从部分受信任的代码调用。  
  
 如果在 <xref:System.Reflection.Emit.ILGenerator.ILOffset%2A> 发出任何 MSIL 指令之前访问了属性，它将返回 0 (零) 。  
  
 当为动态语言生成 MSIL 时，此属性可用于将 MSIL 流中的偏移量映射到源代码行号。 当引发异常时，可使用生成的信息来提供堆栈跟踪。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarkLabel">
      <MemberSignature Language="C#" Value="public virtual void MarkLabel (System.Reflection.Emit.Label loc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MarkLabel(valuetype System.Reflection.Emit.Label loc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.MarkLabel(System.Reflection.Emit.Label)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MarkLabel (loc As Label)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MarkLabel(System::Reflection::Emit::Label loc);" />
      <MemberSignature Language="F#" Value="abstract member MarkLabel : System.Reflection.Emit.Label -&gt; unit&#xA;override this.MarkLabel : System.Reflection.Emit.Label -&gt; unit" Usage="iLGenerator.MarkLabel loc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loc" Type="System.Reflection.Emit.Label" />
      </Parameters>
      <Docs>
        <param name="loc">为其设置索引的标签。</param>
        <summary>用给定标签标记 Microsoft 中间语言 (MSIL) 流的当前位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不能多次定义标签。  
  
   
  
## Examples  
 下面的代码示例演示了 `MarkLabel` 在动态方法中实现 MSIL 分支的上下文用法。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="loc" /> 表示标签数组中的无效索引。  
  
- 或 - 
已定义 <paramref name="loc" /> 的索引。</exception>
      </Docs>
    </Member>
    <Member MemberName="MarkSequencePoint">
      <MemberSignature Language="C#" Value="public virtual void MarkSequencePoint (System.Diagnostics.SymbolStore.ISymbolDocumentWriter document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MarkSequencePoint(class System.Diagnostics.SymbolStore.ISymbolDocumentWriter document, int32 startLine, int32 startColumn, int32 endLine, int32 endColumn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.MarkSequencePoint(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MarkSequencePoint (document As ISymbolDocumentWriter, startLine As Integer, startColumn As Integer, endLine As Integer, endColumn As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MarkSequencePoint(System::Diagnostics::SymbolStore::ISymbolDocumentWriter ^ document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="F#" Value="abstract member MarkSequencePoint : System.Diagnostics.SymbolStore.ISymbolDocumentWriter * int * int * int * int -&gt; unit&#xA;override this.MarkSequencePoint : System.Diagnostics.SymbolStore.ISymbolDocumentWriter * int * int * int * int -&gt; unit" Usage="iLGenerator.MarkSequencePoint (document, startLine, startColumn, endLine, endColumn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Diagnostics.SymbolStore.ISymbolDocumentWriter" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="startLine" Type="System.Int32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="startColumn" Type="System.Int32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="endLine" Type="System.Int32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="endColumn" Type="System.Int32" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="document">为其定义序列点的文档。</param>
        <param name="startLine">序列点开始的行。</param>
        <param name="startColumn">序列点开始的行中的列。</param>
        <param name="endLine">序列点结束的行。</param>
        <param name="endColumn">序列点结束的行中的列。</param>
        <summary>在 Microsoft 中间语言 (MSIL) 流中标记序列点。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 行号从1开始编制索引。 列从0编制索引。  
  
 符号信息对于每个源行通常至少包含一个 MSIL 偏移量。 当实时 (JIT) 编译器要编译方法时，它会请求分析服务提供应保留的 MSIL 偏移量列表。 这些 MSIL 偏移量称为 *序列点*。  
  
 如果当前与 <xref:System.Reflection.Emit.ILGenerator> 某个对象相关联 <xref:System.Reflection.Emit.DynamicMethod> ，则它不支持符号信息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startLine" /> 或 <paramref name="endLine" /> 为 &lt;= 0。</exception>
        <exception cref="T:System.NotSupportedException">此 <see cref="T:System.Reflection.Emit.ILGenerator" /> 属于某个 <see cref="T:System.Reflection.Emit.DynamicMethod" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ILGenerator.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _ILGenerator.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ILGenerator.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _ILGenerator.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ILGenerator.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_ILGenerator::GetIDsOfNames;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.InteropServices._ILGenerator.GetIDsOfNames : Guid * nativeint * uint32 * uint32 * nativeint -&gt; unit&#xA;override this.System.Runtime.InteropServices._ILGenerator.GetIDsOfNames : Guid * nativeint * uint32 * uint32 * nativeint -&gt; unit" Usage="iLGenerator.System.Runtime.InteropServices._ILGenerator.GetIDsOfNames (riid, rgszNames, cNames, lcid, rgDispId)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ILGenerator.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid">留待将来使用。 必须为 IID_NULL。</param>
        <param name="rgszNames">要映射的名称的传入数组。</param>
        <param name="cNames">要映射的名称的计数。</param>
        <param name="lcid">要在其中解释名称的区域设置上下文。</param>
        <param name="rgDispId">调用方分配的数组，用于接收与名称对应的 ID。</param>
        <summary>将一组名称映射为对应的一组调度标识符。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于从非托管代码访问托管类，不应从托管代码调用。 有关的详细信息 `IDispatch::GetIDsOfNames` ，请参阅 MSDN library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法称为使用 COM <c>IDispatch</c> 接口的后期绑定。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ILGenerator.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _ILGenerator.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ILGenerator.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _ILGenerator.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ILGenerator.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_ILGenerator::GetTypeInfo;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.InteropServices._ILGenerator.GetTypeInfo : uint32 * uint32 * nativeint -&gt; unit&#xA;override this.System.Runtime.InteropServices._ILGenerator.GetTypeInfo : uint32 * uint32 * nativeint -&gt; unit" Usage="iLGenerator.System.Runtime.InteropServices._ILGenerator.GetTypeInfo (iTInfo, lcid, ppTInfo)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ILGenerator.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo">要返回的类型信息。</param>
        <param name="lcid">类型信息的区域设置标识符。</param>
        <param name="ppTInfo">接收一个指针，指向请求的类型信息对象。</param>
        <summary>检索对象的类型信息，然后可以使用该信息获取接口的类型信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于从非托管代码访问托管类，不应从托管代码调用。 有关的详细信息 `IDispatch::GetTypeInfo` ，请参阅 MSDN library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法称为使用 COM <c>IDispatch</c> 接口的后期绑定。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _ILGenerator.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _ILGenerator.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_ILGenerator::GetTypeInfoCount;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount : uint32 -&gt; unit&#xA;override this.System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount : uint32 -&gt; unit" Usage="iLGenerator.System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount pcTInfo" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">指向一个位置，该位置接收对象提供的类型信息接口的数量。</param>
        <summary>检索对象提供的类型信息接口的数量（0 或 1）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于从非托管代码访问托管类，不应从托管代码调用。 有关的详细信息 `IDispatch::GetTypeInfoCount` ，请参阅 MSDN library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法称为使用 COM <c>IDispatch</c> 接口的后期绑定。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ILGenerator.Invoke">
      <MemberSignature Language="C#" Value="void _ILGenerator.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ILGenerator.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _ILGenerator.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ILGenerator.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_ILGenerator::Invoke;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.InteropServices._ILGenerator.Invoke : uint32 * Guid * uint32 * int16 * nativeint * nativeint * nativeint * nativeint -&gt; unit&#xA;override this.System.Runtime.InteropServices._ILGenerator.Invoke : uint32 * Guid * uint32 * int16 * nativeint * nativeint * nativeint * nativeint -&gt; unit" Usage="iLGenerator.System.Runtime.InteropServices._ILGenerator.Invoke (dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ILGenerator.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">标识成员。</param>
        <param name="riid">留待将来使用。 必须为 IID_NULL。</param>
        <param name="lcid">要在其中解释自变量的区域设置上下文。</param>
        <param name="wFlags">描述调用的上下文的标志。</param>
        <param name="pDispParams">指向一个结构的指针，该结构包含一个参数数组、一个命名参数的 DISPID 参数数组和数组中元素数的计数。</param>
        <param name="pVarResult">指向要存储结果的位置的指针。</param>
        <param name="pExcepInfo">指向一个包含异常信息的结构的指针。</param>
        <param name="puArgErr">第一个出错参数的索引。</param>
        <summary>提供对某一对象公开的属性和方法的访问。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于从非托管代码访问托管类，不应从托管代码调用。 有关的详细信息 `IDispatch::Invoke` ，请参阅 MSDN library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法称为使用 COM <c>IDispatch</c> 接口的后期绑定。</exception>
      </Docs>
    </Member>
    <Member MemberName="ThrowException">
      <MemberSignature Language="C#" Value="public virtual void ThrowException (Type excType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ThrowException(class System.Type excType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.ThrowException(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ThrowException (excType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ThrowException(Type ^ excType);" />
      <MemberSignature Language="F#" Value="abstract member ThrowException : Type -&gt; unit&#xA;override this.ThrowException : Type -&gt; unit" Usage="iLGenerator.ThrowException excType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="excType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="excType">要引发的异常类型的类。</param>
        <summary>发出指令以引发异常。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示了的上下文用法， `ThrowException` 以在动态方法的 MSIL 中引发异常。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="excType" /> 不是 <see cref="T:System.Exception" /> 类或 <see cref="T:System.Exception" /> 的派生类。  
  
- 或 - 
该类型没有无参数构造函数。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="excType" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="UsingNamespace">
      <MemberSignature Language="C#" Value="public virtual void UsingNamespace (string usingNamespace);" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UsingNamespace(string usingNamespace) cil managed" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.UsingNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UsingNamespace (usingNamespace As String)" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UsingNamespace(System::String ^ usingNamespace);" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member UsingNamespace : string -&gt; unit&#xA;override this.UsingNamespace : string -&gt; unit" Usage="iLGenerator.UsingNamespace usingNamespace" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public void UsingNamespace (string usingNamespace);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UsingNamespace(string usingNamespace) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Sub UsingNamespace (usingNamespace As String)" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UsingNamespace(System::String ^ usingNamespace);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="member this.UsingNamespace : string -&gt; unit" Usage="iLGenerator.UsingNamespace usingNamespace" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="usingNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="usingNamespace">用于计算当前活动词法范围的局部变量和监视值的命名空间</param>
        <summary>指定用于计算当前活动词法范围的局部变量和监视值的命名空间。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前与 <xref:System.Reflection.Emit.ILGenerator> <xref:System.Reflection.Emit.DynamicMethod> 对象关联，则不支持此方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="usingNamespace" /> 的长度为零。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="usingNamespace" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">此 <see cref="T:System.Reflection.Emit.ILGenerator" /> 属于某个 <see cref="T:System.Reflection.Emit.DynamicMethod" />。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
