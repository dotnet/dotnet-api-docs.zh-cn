<Type Name="MethodBuilder" FullName="System.Reflection.Emit.MethodBuilder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4355e0ddd9d731309ce3d709b6068bb7af19df06" /><Meta Name="ms.sourcegitcommit" Value="943c8cdbe5b47c6c296a6f4b73038bbd43da0dd2" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="02/12/2021" /><Meta Name="ms.locfileid" Value="100320497" /></Metadata><TypeSignature Language="C#" Value="public sealed class MethodBuilder : System.Reflection.MethodInfo" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit MethodBuilder extends System.Reflection.MethodInfo" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.MethodBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class MethodBuilder&#xA;Inherits MethodInfo" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodBuilder sealed : System::Reflection::MethodInfo" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
  <TypeSignature Language="F#" Value="type MethodBuilder = class&#xA;    inherit MethodInfo" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1;xamarinios-10.8" />
  <TypeSignature Language="C#" Value="public sealed class MethodBuilder : System.Reflection.MethodInfo, System.Runtime.InteropServices._MethodBuilder" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit MethodBuilder extends System.Reflection.MethodInfo implements class System.Runtime.InteropServices._MethodBuilder" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class MethodBuilder&#xA;Inherits MethodInfo&#xA;Implements _MethodBuilder" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodBuilder sealed : System::Reflection::MethodInfo, System::Runtime::InteropServices::_MethodBuilder" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type MethodBuilder = class&#xA;    inherit MethodInfo&#xA;    interface _MethodBuilder" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit MethodBuilder extends System.Reflection.MethodInfo implements class System.Runtime.InteropServices._MethodBuilder" FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0" />
  <TypeSignature Language="C#" Value="public abstract class MethodBuilder : System.Reflection.MethodInfo" FrameworkAlternate="xamarinios-10.8" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit MethodBuilder extends System.Reflection.MethodInfo" FrameworkAlternate="xamarinios-10.8" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MethodBuilder&#xA;Inherits MethodInfo" FrameworkAlternate="xamarinios-10.8" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodBuilder abstract : System::Reflection::MethodInfo" FrameworkAlternate="xamarinios-10.8" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Reflection.Emit" ToVersion="0.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Reflection.Emit" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Reflection.MethodInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0">
      <InterfaceName>System.Runtime.InteropServices._MethodBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodBuilder))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodBuilder))&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="6292e-101">定义并表示动态类上的方法（或构造函数）。</span><span class="sxs-lookup"><span data-stu-id="6292e-101">Defines and represents a method (or constructor) on a dynamic class.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-102"><xref:System.Reflection.Emit.MethodBuilder>类用于以 Microsoft 中间语言 (MSIL) （包括名称、特性、签名和方法正文）完全描述方法。</span><span class="sxs-lookup"><span data-stu-id="6292e-102">The <xref:System.Reflection.Emit.MethodBuilder> class is used to fully describe a method in Microsoft intermediate language (MSIL), including the name, attributes, signature, and method body.</span></span> <span data-ttu-id="6292e-103">它与类结合使用 <xref:System.Reflection.Emit.TypeBuilder> ，以便在运行时创建类。</span><span class="sxs-lookup"><span data-stu-id="6292e-103">It is used in conjunction with the <xref:System.Reflection.Emit.TypeBuilder> class to create classes at runtime.</span></span>  
  
## <a name="global-methods-and-methods-as-type-members"></a><span data-ttu-id="6292e-104">作为类型成员的全局方法和方法</span><span class="sxs-lookup"><span data-stu-id="6292e-104">Global methods and methods as type members</span></span>  
 <span data-ttu-id="6292e-105">可以使用反射发出来定义全局方法，并将方法定义为类型成员。</span><span class="sxs-lookup"><span data-stu-id="6292e-105">You can use reflection emit to define global methods and to define methods as type members.</span></span> <span data-ttu-id="6292e-106">定义方法的 Api 返回 <xref:System.Reflection.Emit.MethodBuilder> 对象。</span><span class="sxs-lookup"><span data-stu-id="6292e-106">The APIs that define methods return <xref:System.Reflection.Emit.MethodBuilder> objects.</span></span>  
  
### <a name="global-methods"></a><span data-ttu-id="6292e-107">全局方法</span><span class="sxs-lookup"><span data-stu-id="6292e-107">Global methods</span></span>  
 <span data-ttu-id="6292e-108">全局方法是使用方法定义的 <xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A?displayProperty=nameWithType> ，该方法返回 **MethodBuilder** 对象。</span><span class="sxs-lookup"><span data-stu-id="6292e-108">A global method is defined by using the <xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A?displayProperty=nameWithType> method, which returns a **MethodBuilder** object.</span></span>  
  
 <span data-ttu-id="6292e-109">全局方法必须是静态的。</span><span class="sxs-lookup"><span data-stu-id="6292e-109">Global methods must be static.</span></span> <span data-ttu-id="6292e-110">如果动态模块包含全局方法，则在 <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A?displayProperty=nameWithType> 持久化动态模块或包含动态程序集之前，必须先调用方法，因为公共语言运行时推迟了在定义所有全局函数之前修复动态模块。</span><span class="sxs-lookup"><span data-stu-id="6292e-110">If a dynamic module contains global methods, the <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A?displayProperty=nameWithType> method must be called before persisting the dynamic module or the containing dynamic assembly because the common language runtime postpones fixing up the dynamic module until all global functions have been defined.</span></span>  
  
 <span data-ttu-id="6292e-111">全局本机方法是使用方法定义的 <xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-111">A global native method is defined by using the <xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="6292e-112">平台调用 (PInvoke) 方法不能声明为 abstract 或 virtual。</span><span class="sxs-lookup"><span data-stu-id="6292e-112">Platform invoke (PInvoke) methods must not be declared abstract or virtual.</span></span> <span data-ttu-id="6292e-113">运行时设置 <xref:System.Reflection.MethodAttributes.PinvokeImpl?displayProperty=nameWithType> 平台调用方法的属性。</span><span class="sxs-lookup"><span data-stu-id="6292e-113">The runtime sets the <xref:System.Reflection.MethodAttributes.PinvokeImpl?displayProperty=nameWithType> attribute for a platform invoke method.</span></span>  
  
### <a name="methods-as-members-of-types"></a><span data-ttu-id="6292e-114">作为类型成员的方法</span><span class="sxs-lookup"><span data-stu-id="6292e-114">Methods as members of types</span></span>  
 <span data-ttu-id="6292e-115">方法通过使用 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> 方法（该方法返回对象）定义为类型成员 <xref:System.Reflection.Emit.MethodBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-115">A method is defined as a type member by using the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> method, which returns a <xref:System.Reflection.Emit.MethodBuilder> object.</span></span>  
  
 <span data-ttu-id="6292e-116"><xref:System.Reflection.Emit.MethodBuilder.DefineParameter%2A>方法用于设置参数的名称和参数属性，或返回值的属性。</span><span class="sxs-lookup"><span data-stu-id="6292e-116">The <xref:System.Reflection.Emit.MethodBuilder.DefineParameter%2A> method is used to set the name and parameter attributes of a parameter, or of the return value.</span></span> <span data-ttu-id="6292e-117"><xref:System.Reflection.Emit.ParameterBuilder>此方法返回的对象表示参数或返回值。</span><span class="sxs-lookup"><span data-stu-id="6292e-117">The <xref:System.Reflection.Emit.ParameterBuilder> object returned by this method represents a parameter or the return value.</span></span> <span data-ttu-id="6292e-118"><xref:System.Reflection.Emit.ParameterBuilder>对象可用于设置封送处理、设置常数值和应用自定义属性。</span><span class="sxs-lookup"><span data-stu-id="6292e-118">The <xref:System.Reflection.Emit.ParameterBuilder> object can be used to set the marshaling, to set the constant value, and to apply custom attributes.</span></span>  
  
## <a name="attributes"></a><span data-ttu-id="6292e-119">属性</span><span class="sxs-lookup"><span data-stu-id="6292e-119">Attributes</span></span>  
 <span data-ttu-id="6292e-120">枚举的成员 <xref:System.Reflection.MethodAttributes> 定义动态方法的精确字符：</span><span class="sxs-lookup"><span data-stu-id="6292e-120">Members of the <xref:System.Reflection.MethodAttributes> enumeration define the precise character of a dynamic method:</span></span>  
  
-   <span data-ttu-id="6292e-121">静态方法是使用属性指定的 <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-121">Static methods are specified using the <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType> attribute.</span></span>  
  
-   <span data-ttu-id="6292e-122">不能重写的最终方法 (使用特性指定的) <xref:System.Reflection.MethodAttributes.Final?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-122">Final methods (methods that cannot be overridden) are specified using the <xref:System.Reflection.MethodAttributes.Final?displayProperty=nameWithType> attribute.</span></span>  
  
-   <span data-ttu-id="6292e-123">使用特性指定虚方法 <xref:System.Reflection.MethodAttributes.Virtual?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-123">Virtual methods are specified using the <xref:System.Reflection.MethodAttributes.Virtual?displayProperty=nameWithType> attribute.</span></span>  
  
-   <span data-ttu-id="6292e-124">使用特性指定抽象方法 <xref:System.Reflection.MethodAttributes.Abstract?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-124">Abstract methods are specified using the <xref:System.Reflection.MethodAttributes.Abstract?displayProperty=nameWithType> attribute.</span></span>  
  
-   <span data-ttu-id="6292e-125">若干特性确定方法可见性。</span><span class="sxs-lookup"><span data-stu-id="6292e-125">Several attributes determine method visibility.</span></span> <span data-ttu-id="6292e-126">请参阅枚举的说明 <xref:System.Reflection.MethodAttributes> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-126">See the description of the <xref:System.Reflection.MethodAttributes> enumeration.</span></span>  
  
-   <span data-ttu-id="6292e-127">实现重载运算符的方法必须设置 <xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType> 特性。</span><span class="sxs-lookup"><span data-stu-id="6292e-127">Methods that implement overloaded operators must set the <xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType> attribute.</span></span>  
  
-   <span data-ttu-id="6292e-128">终结器必须设置 <xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType> 特性。</span><span class="sxs-lookup"><span data-stu-id="6292e-128">Finalizers must set the <xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType> attribute.</span></span>  
  
## <a name="known-issues"></a><span data-ttu-id="6292e-129">已知问题</span><span class="sxs-lookup"><span data-stu-id="6292e-129">Known Issues</span></span>  
  
-   <span data-ttu-id="6292e-130">尽管 <xref:System.Reflection.Emit.MethodBuilder> 派生自，但在 <xref:System.Reflection.MethodInfo> <xref:System.Reflection.MethodInfo> 中未完全实现类中定义的某些抽象方法 <xref:System.Reflection.Emit.MethodBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-130">Although <xref:System.Reflection.Emit.MethodBuilder> is derived from <xref:System.Reflection.MethodInfo>, some of the abstract methods defined in the <xref:System.Reflection.MethodInfo> class are not fully implemented in <xref:System.Reflection.Emit.MethodBuilder>.</span></span> <span data-ttu-id="6292e-131">这些 <xref:System.Reflection.Emit.MethodBuilder> 方法会引发 <xref:System.NotSupportedException> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-131">These <xref:System.Reflection.Emit.MethodBuilder> methods throw the <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="6292e-132">例如， <xref:System.Reflection.Emit.MethodBuilder.Invoke%2A?displayProperty=nameWithType> 方法未完全实现。</span><span class="sxs-lookup"><span data-stu-id="6292e-132">For example the <xref:System.Reflection.Emit.MethodBuilder.Invoke%2A?displayProperty=nameWithType> method is not fully implemented.</span></span> <span data-ttu-id="6292e-133">您可以通过使用或方法检索封闭类型来反映这些方法 <xref:System.Type.GetType%2A?displayProperty=nameWithType> <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-133">You can reflect on these methods by retrieving the enclosing type using the <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> methods.</span></span>  
  
-   <span data-ttu-id="6292e-134">从 .NET Framework 版本2.0 开始支持自定义修饰符。</span><span class="sxs-lookup"><span data-stu-id="6292e-134">Custom modifiers are supported starting with the .NET Framework version 2.0.</span></span> <span data-ttu-id="6292e-135">它们在早期版本中不受支持。</span><span class="sxs-lookup"><span data-stu-id="6292e-135">They are not supported in earlier versions.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6292e-136">下面的示例使用 <xref:System.Reflection.Emit.MethodBuilder> 类在动态类型中创建方法。</span><span class="sxs-lookup"><span data-stu-id="6292e-136">The following example uses the <xref:System.Reflection.Emit.MethodBuilder> class to create a method within a dynamic type.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MethodBuilder ();" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.#ctor" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MethodBuilder();" FrameworkAlternate="xamarinios-10.8" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddDeclarativeSecurity">
      <MemberSignature Language="C#" Value="public void AddDeclarativeSecurity (System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDeclarativeSecurity(valuetype System.Security.Permissions.SecurityAction action, class System.Security.PermissionSet pset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDeclarativeSecurity (action As SecurityAction, pset As PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDeclarativeSecurity(System::Security::Permissions::SecurityAction action, System::Security::PermissionSet ^ pset);" />
      <MemberSignature Language="F#" Value="member this.AddDeclarativeSecurity : System.Security.Permissions.SecurityAction * System.Security.PermissionSet -&gt; unit" Usage="methodBuilder.AddDeclarativeSecurity (action, pset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Security.Permissions.SecurityAction" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pset" Type="System.Security.PermissionSet" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="6292e-137">要执行的安全操作（Demand、Assert 等等）。</span><span class="sxs-lookup"><span data-stu-id="6292e-137">The security action to be taken (Demand, Assert, and so on).</span></span></param>
        <param name="pset"><span data-ttu-id="6292e-138">应用此操作的权限集。</span><span class="sxs-lookup"><span data-stu-id="6292e-138">The set of permissions the action applies to.</span></span></param>
        <summary><span data-ttu-id="6292e-139">向此方法添加声明性安全。</span><span class="sxs-lookup"><span data-stu-id="6292e-139">Adds declarative security to this method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-140"><xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A> 可以多次调用，每次调用指定安全操作 (如 `Demand` 、 `Assert` 和 `Deny`) 以及操作应用到的权限集。</span><span class="sxs-lookup"><span data-stu-id="6292e-140"><xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A> can be called several times, with each call specifying a security action (such as `Demand`, `Assert`, and `Deny`) and a set of permissions that the action applies to.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6292e-141">在 .NET Framework 版本1.0、1.1 和2.0 中，通过使用方法应用到方法的声明性安全特性 <xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A> 以旧 XML 元数据格式存储。</span><span class="sxs-lookup"><span data-stu-id="6292e-141">In the .NET Framework versions 1.0, 1.1, and 2.0, the declarative security attributes applied to a method by using the <xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A> method are stored in the old XML metadata format.</span></span> <span data-ttu-id="6292e-142">请参阅发出声明性安全特性。</span><span class="sxs-lookup"><span data-stu-id="6292e-142">See Emitting Declarative Security Attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6292e-143">下面的代码示例演示了的上下文用法，它 `AddDeclarativeSecurity` 要求方法的调用方具有不受限制的权限。</span><span class="sxs-lookup"><span data-stu-id="6292e-143">The code sample below illustrates the contextual use of `AddDeclarativeSecurity` to require the caller of a method to have unrestricted permissions.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="6292e-144"><paramref name="action" /> 无效（<see langword="RequestMinimum" />、<see langword="RequestOptional" /> 和 <see langword="RequestRefuse" /> 无效）。</span><span class="sxs-lookup"><span data-stu-id="6292e-144">The <paramref name="action" /> is invalid (<see langword="RequestMinimum" />, <see langword="RequestOptional" />, and <see langword="RequestRefuse" /> are invalid).</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6292e-145">已使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建包含类型。</span><span class="sxs-lookup"><span data-stu-id="6292e-145">The containing type has been created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="6292e-146">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6292e-146">-or-</span></span> 
<span data-ttu-id="6292e-147">权限集 <paramref name="pset" /> 包含之前由 <see cref="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" /> 添加的操作。</span><span class="sxs-lookup"><span data-stu-id="6292e-147">The permission set <paramref name="pset" /> contains an action that was added earlier by <see cref="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />.</span></span>  
  
<span data-ttu-id="6292e-148">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6292e-148">-or-</span></span> 
<span data-ttu-id="6292e-149">对于当前的方法，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-149">For the current method, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6292e-150"><paramref name="pset" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-150"><paramref name="pset" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.MethodAttributes" Usage="System.Reflection.Emit.MethodBuilder.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6292e-151">检索此方法的属性。</span><span class="sxs-lookup"><span data-stu-id="6292e-151">Retrieves the attributes for this method.</span></span></summary>
        <value><span data-ttu-id="6292e-152">只读。</span><span class="sxs-lookup"><span data-stu-id="6292e-152">Read-only.</span></span> <span data-ttu-id="6292e-153">检索此方法的 <see langword="MethodAttributes" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-153">Retrieves the <see langword="MethodAttributes" /> for this method.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public override System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberSignature Language="F#" Value="member this.CallingConvention : System.Reflection.CallingConventions" Usage="System.Reflection.Emit.MethodBuilder.CallingConvention" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6292e-154">返回此方法的调用约定。</span><span class="sxs-lookup"><span data-stu-id="6292e-154">Returns the calling convention of the method.</span></span></summary>
        <value><span data-ttu-id="6292e-155">只读。</span><span class="sxs-lookup"><span data-stu-id="6292e-155">Read-only.</span></span> <span data-ttu-id="6292e-156">方法的调用约定。</span><span class="sxs-lookup"><span data-stu-id="6292e-156">The calling convention of the method.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public override bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Reflection.Emit.MethodBuilder.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6292e-157">不支持此类型。</span><span class="sxs-lookup"><span data-stu-id="6292e-157">Not supported for this type.</span></span></summary>
        <value><span data-ttu-id="6292e-158">不支持。</span><span class="sxs-lookup"><span data-stu-id="6292e-158">Not supported.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-159"><xref:System.Reflection.Emit.MethodBuilder>始终表示泛型方法定义，因此无法调用。</span><span class="sxs-lookup"><span data-stu-id="6292e-159">A <xref:System.Reflection.Emit.MethodBuilder> always represents a generic method definition, and thus cannot be invoked.</span></span>  
  
 <span data-ttu-id="6292e-160">有关详细信息，请参阅 <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> 和 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6292e-160">For more information, see <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="6292e-161">有关泛型类型的信息，请参阅 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-161">For information on generic types, see <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6292e-162">基类不支持调用的方法。</span><span class="sxs-lookup"><span data-stu-id="6292e-162">The invoked method is not supported in the base class.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="CreateMethodBody">
      <MemberSignature Language="C#" Value="public void CreateMethodBody (byte[] il, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateMethodBody(unsigned int8[] il, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateMethodBody (il As Byte(), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateMethodBody(cli::array &lt;System::Byte&gt; ^ il, int count);" />
      <MemberSignature Language="F#" Value="member this.CreateMethodBody : byte[] * int -&gt; unit" Usage="methodBuilder.CreateMethodBody (il, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="il" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="il"><span data-ttu-id="6292e-163">包含有效的 MSIL 指令的数组。</span><span class="sxs-lookup"><span data-stu-id="6292e-163">An array containing valid MSIL instructions.</span></span> <span data-ttu-id="6292e-164">如果此参数为 <see langword="null" />，则清除方法的主体。</span><span class="sxs-lookup"><span data-stu-id="6292e-164">If this parameter is <see langword="null" />, the method's body is cleared.</span></span></param>
        <param name="count"><span data-ttu-id="6292e-165">MSIL 数组中的有效字节数。</span><span class="sxs-lookup"><span data-stu-id="6292e-165">The number of valid bytes in the MSIL array.</span></span> <span data-ttu-id="6292e-166">如果 MSIL 为 <see langword="null" />，则忽略此值。</span><span class="sxs-lookup"><span data-stu-id="6292e-166">This value is ignored if MSIL is <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="6292e-167">使用 Microsoft 中间语言 (MSIL) 指令提供的字节数组的创建方法的主体。</span><span class="sxs-lookup"><span data-stu-id="6292e-167">Creates the body of the method using a supplied byte array of Microsoft intermediate language (MSIL) instructions.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-168">此方法从创建方法的主体 `il` ，其中包含作为操作码的 MSIL 指令的数组。</span><span class="sxs-lookup"><span data-stu-id="6292e-168">This method creates the method's body from `il`, an array containing MSIL instructions as opcodes.</span></span> <span data-ttu-id="6292e-169">有效 MSIL 的字节数由 count 提供。</span><span class="sxs-lookup"><span data-stu-id="6292e-169">The number of bytes of valid MSIL is given by count.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6292e-170">目前不完全支持这种情况。</span><span class="sxs-lookup"><span data-stu-id="6292e-170">This is currently not fully supported.</span></span> <span data-ttu-id="6292e-171">用户无法提供令牌修补程序和异常处理程序的位置。</span><span class="sxs-lookup"><span data-stu-id="6292e-171">The user cannot supply the location of token fix ups and exception handlers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6292e-172">在下面提供的示例中，添加两个整数的简单方法是通过 opcode 使用生成的 `CreateMethodBody` 。</span><span class="sxs-lookup"><span data-stu-id="6292e-172">In the example provided below, a simple method that adds two integers is generated via opcode using `CreateMethodBody`.</span></span>  
  
 [!code-cpp[System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Refelction.Emit.MethodBuilder.CreateMethodBody Example/CPP/source.cpp#1)]
 [!code-csharp[System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Refelction.Emit.MethodBuilder.CreateMethodBody Example/CS/source.cs#1)]
 [!code-vb[System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Refelction.Emit.MethodBuilder.CreateMethodBody Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="6292e-173"><paramref name="count" /> 不在提供的 MSIL 指令数组的索引范围内，且 <paramref name="il" /> 不是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-173">The <paramref name="count" /> is not within the range of indexes of the supplied MSIL instruction array and <paramref name="il" /> is not <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6292e-174">该包含类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</span><span class="sxs-lookup"><span data-stu-id="6292e-174">The containing type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="6292e-175">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6292e-175">-or-</span></span> 
<span data-ttu-id="6292e-176">以前在包含不是 <see langword="null" /> 的 <paramref name="il" /> 参数的此 <see langword="MethodBuilder" /> 上调用了此方法。</span><span class="sxs-lookup"><span data-stu-id="6292e-176">This method was called previously on this <see langword="MethodBuilder" /> with an <paramref name="il" /> argument that was not <see langword="null" />.</span></span>  
  
<span data-ttu-id="6292e-177">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6292e-177">-or-</span></span> 
<span data-ttu-id="6292e-178">对于当前的方法，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-178">For the current method, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type? DeclaringType { get; }" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Reflection.Emit.MethodBuilder.DeclaringType" />
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6292e-179">返回声明此方法的类型。</span><span class="sxs-lookup"><span data-stu-id="6292e-179">Returns the type that declares this method.</span></span></summary>
        <value><span data-ttu-id="6292e-180">只读。</span><span class="sxs-lookup"><span data-stu-id="6292e-180">Read-only.</span></span> <span data-ttu-id="6292e-181">声明此方法的类型。</span><span class="sxs-lookup"><span data-stu-id="6292e-181">The type that declares this method.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="6292e-182">下面的代码演示属性的用法 `Type` 。</span><span class="sxs-lookup"><span data-stu-id="6292e-182">The following code illustrates the use of the `Type` property.</span></span>  
  
 [!code-cpp[MethodBuilderClass_TypeSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBuilderClass_TypeSample/CPP/methodbuilderclass.cpp#1)]
 [!code-csharp[MethodBuilderClass_TypeSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBuilderClass_TypeSample/CS/methodbuilderclass.cs#1)]
 [!code-vb[MethodBuilderClass_TypeSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBuilderClass_TypeSample/VB/methodbuilderclass.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineGenericParameters">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (params string[] names);" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters(string[] names) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGenericParameters (ParamArray names As String()) As GenericTypeParameterBuilder()" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Emit::GenericTypeParameterBuilder ^&gt; ^ DefineGenericParameters(... cli::array &lt;System::String ^&gt; ^ names);" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.DefineGenericParameters : string[] -&gt; System.Reflection.Emit.GenericTypeParameterBuilder[]" Usage="methodBuilder.DefineGenericParameters names" />
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (string[] names);" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGenericParameters (names As String()) As GenericTypeParameterBuilder()" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Emit::GenericTypeParameterBuilder ^&gt; ^ DefineGenericParameters(cli::array &lt;System::String ^&gt; ^ names);" FrameworkAlternate="xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.GenericTypeParameterBuilder[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="names" Type="System.String[]" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="names"><span data-ttu-id="6292e-183">一个字符串数组，表示泛型类型参数的名称。</span><span class="sxs-lookup"><span data-stu-id="6292e-183">An array of strings that represent the names of the generic type parameters.</span></span></param>
        <summary><span data-ttu-id="6292e-184">设置当前方法的泛型类型参数的数目，指定其名称并返回一个可用于定义其约束的 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="6292e-184">Sets the number of generic type parameters for the current method, specifies their names, and returns an array of <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objects that can be used to define their constraints.</span></span></summary>
        <returns><span data-ttu-id="6292e-185">一个 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 对象数组，表示泛型方法的类型参数。</span><span class="sxs-lookup"><span data-stu-id="6292e-185">An array of <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objects representing the type parameters of the generic method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-186">调用 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 方法会使当前方法成为泛型方法。</span><span class="sxs-lookup"><span data-stu-id="6292e-186">Calling the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method makes the current method generic.</span></span> <span data-ttu-id="6292e-187">无法撤消此更改。</span><span class="sxs-lookup"><span data-stu-id="6292e-187">There is no way to undo this change.</span></span> <span data-ttu-id="6292e-188">第二次调用此方法会导致 <xref:System.InvalidOperationException> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-188">Calling this method a second time causes an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="6292e-189">以后可以使用方法检索泛型方法的类型参数 <xref:System.Reflection.Emit.MethodBuilder.GetGenericArguments%2A> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-189">The type parameters of the generic method can be retrieved later by using the <xref:System.Reflection.Emit.MethodBuilder.GetGenericArguments%2A> method.</span></span>  
  
 <span data-ttu-id="6292e-190">按照约定，类型参数名称是单个大写字母。</span><span class="sxs-lookup"><span data-stu-id="6292e-190">By convention, a type parameter name is a single uppercase letter.</span></span>  
  
 <span data-ttu-id="6292e-191">有关详细信息，请参阅 <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> 和 <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6292e-191">For more information, see <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="6292e-192">有关泛型类型的信息，请参阅 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-192">For information on generic types, see <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6292e-193">下面的代码示例创建动态类型， `DemoType` 它包含动态泛型方法 `DemoMethod` 。</span><span class="sxs-lookup"><span data-stu-id="6292e-193">The following code example creates a dynamic type, `DemoType`, which contains the dynamic generic method `DemoMethod`.</span></span> <span data-ttu-id="6292e-194">此方法具有两个泛型类型参数，其中一个参数用作参数，另一个用作返回类型。</span><span class="sxs-lookup"><span data-stu-id="6292e-194">This method has two generic type parameters, one of which is used as a parameter, and the other as the return type.</span></span>  
  
 <span data-ttu-id="6292e-195">执行代码时，该动态程序集会另存为 DemoGenericMethod1.dll，使用 [Ildasm.exe（IL 反汇编程序）](/dotnet/framework/tools/ildasm-exe-il-disassembler) 可以对其进行检查。</span><span class="sxs-lookup"><span data-stu-id="6292e-195">When the code is executed, the dynamic assembly is saved as DemoGenericMethod1.dll, and can be examined using the [Ildasm.exe (IL Disassembler)](/dotnet/framework/tools/ildasm-exe-il-disassembler).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6292e-196">此代码示例将生成一个简单的方法体，只返回空引用。</span><span class="sxs-lookup"><span data-stu-id="6292e-196">This code example generates a simple method body that merely returns a null reference.</span></span> <span data-ttu-id="6292e-197">有关使用更全面开发的方法体创建和使用泛型类型的代码示例，请参阅 [如何：使用反射发出定义泛型方法](/dotnet/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit)。</span><span class="sxs-lookup"><span data-stu-id="6292e-197">For a code example with a more fully developed method body that creates and uses generic types, see [How to: Define a Generic Method with Reflection Emit](/dotnet/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit).</span></span>  
  
 [!code-cpp[GenericMethodBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#1)]
 [!code-csharp[GenericMethodBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#1)]
 [!code-vb[GenericMethodBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6292e-198">已为此方法定义了泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="6292e-198">Generic type parameters have already been defined for this method.</span></span>  
  
<span data-ttu-id="6292e-199">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6292e-199">-or-</span></span> 
<span data-ttu-id="6292e-200">已完成该方法。</span><span class="sxs-lookup"><span data-stu-id="6292e-200">The method has been completed already.</span></span>  
  
<span data-ttu-id="6292e-201">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6292e-201">-or-</span></span> 
<span data-ttu-id="6292e-202">已为当前方法调用了 <see cref="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="6292e-202">The <see cref="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" /> method has been called for the current method.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6292e-203"><paramref name="names" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-203"><paramref name="names" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="6292e-204">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6292e-204">-or-</span></span> 
<span data-ttu-id="6292e-205"><paramref name="names" /> 的元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-205">An element of <paramref name="names" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6292e-206"><paramref name="names" /> 是一个空数组。</span><span class="sxs-lookup"><span data-stu-id="6292e-206"><paramref name="names" /> is an empty array.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.DefineMethod" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit"><span data-ttu-id="6292e-207">如何：用反射发出定义泛型方法</span><span class="sxs-lookup"><span data-stu-id="6292e-207">How to: Define a Generic Method with Reflection Emit</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string? strParamName);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ParameterBuilder DefineParameter(int32 position, valuetype System.Reflection.ParameterAttributes attributes, string strParamName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineParameter (position As Integer, attributes As ParameterAttributes, strParamName As String) As ParameterBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ParameterBuilder ^ DefineParameter(int position, System::Reflection::ParameterAttributes attributes, System::String ^ strParamName);" />
      <MemberSignature Language="F#" Value="member this.DefineParameter : int * System.Reflection.ParameterAttributes * string -&gt; System.Reflection.Emit.ParameterBuilder" Usage="methodBuilder.DefineParameter (position, attributes, strParamName)" />
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string strParamName);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" />
        <Parameter Name="strParamName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="position"><span data-ttu-id="6292e-208">参数在参数列表中的位置。</span><span class="sxs-lookup"><span data-stu-id="6292e-208">The position of the parameter in the parameter list.</span></span> <span data-ttu-id="6292e-209">通过第一个参数以数字 1 开头对参数编制索引；数字 0 表示方法的返回值。</span><span class="sxs-lookup"><span data-stu-id="6292e-209">Parameters are indexed beginning with the number 1 for the first parameter; the number 0 represents the return value of the method.</span></span></param>
        <param name="attributes"><span data-ttu-id="6292e-210">参数的参数属性。</span><span class="sxs-lookup"><span data-stu-id="6292e-210">The parameter attributes of the parameter.</span></span></param>
        <param name="strParamName"><span data-ttu-id="6292e-211">参数的名称。</span><span class="sxs-lookup"><span data-stu-id="6292e-211">The name of the parameter.</span></span> <span data-ttu-id="6292e-212">名称可以是空字符串。</span><span class="sxs-lookup"><span data-stu-id="6292e-212">The name can be the null string.</span></span></param>
        <summary><span data-ttu-id="6292e-213">设置参数属性和此方法的参数名称或此方法的返回值的名称。</span><span class="sxs-lookup"><span data-stu-id="6292e-213">Sets the parameter attributes and the name of a parameter of this method, or of the return value of this method.</span></span> <span data-ttu-id="6292e-214">返回可用于应用自定义属性的 ParameterBuilder。</span><span class="sxs-lookup"><span data-stu-id="6292e-214">Returns a ParameterBuilder that can be used to apply custom attributes.</span></span></summary>
        <returns><span data-ttu-id="6292e-215">返回 <see langword="ParameterBuilder" /> 对象，该对象表示此方法的参数或此方法的返回值。</span><span class="sxs-lookup"><span data-stu-id="6292e-215">Returns a <see langword="ParameterBuilder" /> object that represents a parameter of this method or the return value of this method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-216"><xref:System.Reflection.Emit.ParameterBuilder>此方法返回的对象可用于设置参数的默认值或应用自定义属性。</span><span class="sxs-lookup"><span data-stu-id="6292e-216">The <xref:System.Reflection.Emit.ParameterBuilder> object returned by this method can be used to set the default value for a parameter or to apply custom attributes.</span></span>  
  
 <span data-ttu-id="6292e-217">参数编号从1开始，因此 `position` 第一个参数的编号为1。</span><span class="sxs-lookup"><span data-stu-id="6292e-217">Parameter numbering begins with 1, so `position` is 1 for the first parameter.</span></span> <span data-ttu-id="6292e-218">如果 `position` 为零，则此方法会影响返回值。</span><span class="sxs-lookup"><span data-stu-id="6292e-218">If `position` is zero, this method affects the return value.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6292e-219">在 .NET Framework 版本1.0 和1.1 中，如果为零，则会引发异常 `position` ，因此此方法不能用于修改这些版本中的返回值的属性。</span><span class="sxs-lookup"><span data-stu-id="6292e-219">In the .NET Framework versions 1.0 and 1.1, an exception is thrown if `position` is zero, so this method cannot be used to modify attributes of the return value in those versions.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="6292e-220">此方法没有参数。</span><span class="sxs-lookup"><span data-stu-id="6292e-220">The method has no parameters.</span></span>  
  
<span data-ttu-id="6292e-221">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6292e-221">-or-</span></span> 
 <span data-ttu-id="6292e-222"><paramref name="position" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="6292e-222"><paramref name="position" /> is less than zero.</span></span>  
  
<span data-ttu-id="6292e-223">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6292e-223">-or-</span></span> 
 <span data-ttu-id="6292e-224"><paramref name="position" /> 大于此方法的参数数目。</span><span class="sxs-lookup"><span data-stu-id="6292e-224"><paramref name="position" /> is greater than the number of the method's parameters.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6292e-225">该包含类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</span><span class="sxs-lookup"><span data-stu-id="6292e-225">The containing type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="6292e-226">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6292e-226">-or-</span></span> 
<span data-ttu-id="6292e-227">对于当前的方法，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-227">For the current method, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object? obj);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="methodBuilder.Equals obj" />
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="6292e-228">要与此 <see langword="MethodBuilder" /> 实例进行比较的对象。</span><span class="sxs-lookup"><span data-stu-id="6292e-228">The object to compare with this <see langword="MethodBuilder" /> instance.</span></span></param>
        <summary><span data-ttu-id="6292e-229">确定给定对象是否等于此实例。</span><span class="sxs-lookup"><span data-stu-id="6292e-229">Determines whether the given object is equal to this instance.</span></span></summary>
        <returns><span data-ttu-id="6292e-230">如果 <paramref name="obj" /> 为 <see langword="MethodBuilder" /> 的实例并且等于此对象，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-230"><see langword="true" /> if <paramref name="obj" /> is an instance of <see langword="MethodBuilder" /> and is equal to this object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-231">相等性通过具有相同的名称、属性和签名来确定。</span><span class="sxs-lookup"><span data-stu-id="6292e-231">Equality is determined by having the same name, attributes, and signature.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetBaseDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="methodBuilder.GetBaseDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6292e-232">返回方法的基实现。</span><span class="sxs-lookup"><span data-stu-id="6292e-232">Return the base implementation for a method.</span></span></summary>
        <returns><span data-ttu-id="6292e-233">此方法的基实现。</span><span class="sxs-lookup"><span data-stu-id="6292e-233">The base implementation of this method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-234">此始终返回当前 `MethodBuilder` 对象。</span><span class="sxs-lookup"><span data-stu-id="6292e-234">This always returns the current `MethodBuilder` object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="6292e-235">返回为此方法定义的自定义属性。</span><span class="sxs-lookup"><span data-stu-id="6292e-235">Returns the custom attributes defined for this method.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="methodBuilder.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="inherit"><span data-ttu-id="6292e-236">指定是否搜索此成员的继承链以查找自定义属性。</span><span class="sxs-lookup"><span data-stu-id="6292e-236">Specifies whether to search this member's inheritance chain to find the custom attributes.</span></span></param>
        <summary><span data-ttu-id="6292e-237">返回为此方法定义的所有自定义属性。</span><span class="sxs-lookup"><span data-stu-id="6292e-237">Returns all the custom attributes defined for this method.</span></span></summary>
        <returns><span data-ttu-id="6292e-238">返回一个对象数组，其中的对象表示此方法的所有自定义属性。</span><span class="sxs-lookup"><span data-stu-id="6292e-238">Returns an array of objects representing all the custom attributes of this method.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6292e-239">目前尚不支持此方法。</span><span class="sxs-lookup"><span data-stu-id="6292e-239">This method is not currently supported.</span></span> <span data-ttu-id="6292e-240">使用 <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> 检索此方法，并在返回的 <see cref="T:System.Reflection.MethodInfo" /> 上调用 <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-240">Retrieve the method using <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> and call <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> on the returned <see cref="T:System.Reflection.MethodInfo" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="methodBuilder.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="6292e-241">自定义属性类型。</span><span class="sxs-lookup"><span data-stu-id="6292e-241">The custom attribute type.</span></span></param>
        <param name="inherit"><span data-ttu-id="6292e-242">指定是否搜索此成员的继承链以查找自定义属性。</span><span class="sxs-lookup"><span data-stu-id="6292e-242">Specifies whether to search this member's inheritance chain to find the custom attributes.</span></span></param>
        <summary><span data-ttu-id="6292e-243">返回由给定类型标识的自定义属性。</span><span class="sxs-lookup"><span data-stu-id="6292e-243">Returns the custom attributes identified by the given type.</span></span></summary>
        <returns><span data-ttu-id="6292e-244">返回一个对象数组，表示此方法的属性属于类型 <paramref name="attributeType" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-244">Returns an array of objects representing the attributes of this method that are of type <paramref name="attributeType" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6292e-245">目前尚不支持此方法。</span><span class="sxs-lookup"><span data-stu-id="6292e-245">This method is not currently supported.</span></span> <span data-ttu-id="6292e-246">使用 <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> 检索此方法，并在返回的 <see cref="T:System.Reflection.MethodInfo" /> 上调用 <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-246">Retrieve the method using <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> and call <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> on the returned <see cref="T:System.Reflection.MethodInfo" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="override this.GetGenericArguments : unit -&gt; Type[]" Usage="methodBuilder.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6292e-247">返回表示此方法的类型参数的 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 对象数组（如果为泛型）。</span><span class="sxs-lookup"><span data-stu-id="6292e-247">Returns an array of <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objects that represent the type parameters of the method, if it is generic.</span></span></summary>
        <returns><span data-ttu-id="6292e-248">如果方法是泛型，则为表示此类型参数的 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />，或者如果方法不是泛型，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-248">An array of <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objects representing the type parameters, if the method is generic, or <see langword="null" /> if the method is not generic.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-249">泛型方法的类型参数还由用于定义泛型方法的 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 方法返回。</span><span class="sxs-lookup"><span data-stu-id="6292e-249">The type parameters of a generic method also are returned by the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method that is used to define them.</span></span>  
  
 <span data-ttu-id="6292e-250">有关详细信息，请参阅 <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> 和 <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6292e-250">For more information, see <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="6292e-251">有关泛型类型的信息，请参阅 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-251">For information on generic types, see <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit"><span data-ttu-id="6292e-252">如何：用反射发出定义泛型方法</span><span class="sxs-lookup"><span data-stu-id="6292e-252">How to: Define a Generic Method with Reflection Emit</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetGenericMethodDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetGenericMethodDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericMethodDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetGenericMethodDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetGenericMethodDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="methodBuilder.GetGenericMethodDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6292e-253">返回此方法。</span><span class="sxs-lookup"><span data-stu-id="6292e-253">Returns this method.</span></span></summary>
        <returns><span data-ttu-id="6292e-254"><see cref="T:System.Reflection.Emit.MethodBuilder" /> 的当前实例。</span><span class="sxs-lookup"><span data-stu-id="6292e-254">The current instance of <see cref="T:System.Reflection.Emit.MethodBuilder" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-255"><xref:System.Reflection.Emit.MethodBuilder>不能用于直接发出构造的泛型方法。</span><span class="sxs-lookup"><span data-stu-id="6292e-255">A <xref:System.Reflection.Emit.MethodBuilder> cannot be used to emit a constructed generic method directly.</span></span> <span data-ttu-id="6292e-256">发出的方法是泛型方法定义。</span><span class="sxs-lookup"><span data-stu-id="6292e-256">The emitted method is a generic method definition.</span></span>  
  
 <span data-ttu-id="6292e-257">有关详细信息，请参阅 <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> 和 <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6292e-257">For more information, see <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="6292e-258">有关泛型类型的信息，请参阅 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-258">For information on generic types, see <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6292e-259">当前方法不是泛型方法。</span><span class="sxs-lookup"><span data-stu-id="6292e-259">The current method is not generic.</span></span> <span data-ttu-id="6292e-260">也就是说，<see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 属性将返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-260">That is, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property returns <see langword="false" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit"><span data-ttu-id="6292e-261">如何：用反射发出定义泛型方法</span><span class="sxs-lookup"><span data-stu-id="6292e-261">How to: Define a Generic Method with Reflection Emit</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="methodBuilder.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6292e-262">获取此方法的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="6292e-262">Gets the hash code for this method.</span></span></summary>
        <returns><span data-ttu-id="6292e-263">此方法的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="6292e-263">The hash code for this method.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetILGenerator">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="6292e-264">为此方法返回 <see langword="ILGenerator" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-264">Returns an <see langword="ILGenerator" /> for this method.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetILGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator () As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator();" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : unit -&gt; System.Reflection.Emit.ILGenerator" Usage="methodBuilder.GetILGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6292e-265">为此方法返回默认 Microsoft 中间语言 (MSIL) 流大小为 64 字节的 <see langword="ILGenerator" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-265">Returns an <see langword="ILGenerator" /> for this method with a default Microsoft intermediate language (MSIL) stream size of 64 bytes.</span></span></summary>
        <returns><span data-ttu-id="6292e-266">为此方法返回 <see langword="ILGenerator" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="6292e-266">Returns an <see langword="ILGenerator" /> object for this method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="6292e-267">下面的代码示例演示方法的上下文用法 `GetILGenerator` ，创建和发出一个动态程序集，该程序集将计算三维空间中两个点的点积。</span><span class="sxs-lookup"><span data-stu-id="6292e-267">The code sample below demonstrates the contextual usage of the `GetILGenerator` method, creating and emitting a dynamic assembly that will calculate the dot product of two points in 3D space.</span></span>  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6292e-268">由于其 <see cref="T:System.Reflection.MethodAttributes" /> 或 <see cref="T:System.Reflection.MethodImplAttributes" /> 标志，该方法不应具有主体，例如因为它具有 <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /> 标志。</span><span class="sxs-lookup"><span data-stu-id="6292e-268">The method should not have a body because of its <see cref="T:System.Reflection.MethodAttributes" /> or <see cref="T:System.Reflection.MethodImplAttributes" /> flags, for example because it has the <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /> flag.</span></span>  
  
<span data-ttu-id="6292e-269">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6292e-269">-or-</span></span> 
<span data-ttu-id="6292e-270">此方法是泛型方法，但不是泛型方法定义。</span><span class="sxs-lookup"><span data-stu-id="6292e-270">The method is a generic method, but not a generic method definition.</span></span> <span data-ttu-id="6292e-271">也就是说，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-271">That is, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator (int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator(int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator (size As Integer) As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator(int size);" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : int -&gt; System.Reflection.Emit.ILGenerator" Usage="methodBuilder.GetILGenerator size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="size"><span data-ttu-id="6292e-272">MSIL 流的大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="6292e-272">The size of the MSIL stream, in bytes.</span></span></param>
        <summary><span data-ttu-id="6292e-273">为此方法返回具有指定的 Microsoft 中间语言 (MSIL) 流大小的 <see langword="ILGenerator" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-273">Returns an <see langword="ILGenerator" /> for this method with the specified Microsoft intermediate language (MSIL) stream size.</span></span></summary>
        <returns><span data-ttu-id="6292e-274">为此方法返回 <see langword="ILGenerator" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="6292e-274">Returns an <see langword="ILGenerator" /> object for this method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="6292e-275">下面的代码示例演示方法的上下文用法 `GetILGenerator` ，创建和发出一个动态程序集，该程序集将计算三维空间中两个点的点积。</span><span class="sxs-lookup"><span data-stu-id="6292e-275">The code sample below demonstrates the contextual usage of the `GetILGenerator` method, creating and emitting a dynamic assembly that will calculate the dot product of two points in 3D space.</span></span>  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6292e-276">由于其 <see cref="T:System.Reflection.MethodAttributes" /> 或 <see cref="T:System.Reflection.MethodImplAttributes" /> 标志，该方法不应具有主体，例如因为它具有 <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /> 标志。</span><span class="sxs-lookup"><span data-stu-id="6292e-276">The method should not have a body because of its <see cref="T:System.Reflection.MethodAttributes" /> or <see cref="T:System.Reflection.MethodImplAttributes" /> flags, for example because it has the <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /> flag.</span></span>  
  
<span data-ttu-id="6292e-277">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6292e-277">-or-</span></span> 
<span data-ttu-id="6292e-278">此方法是泛型方法，但不是泛型方法定义。</span><span class="sxs-lookup"><span data-stu-id="6292e-278">The method is a generic method, but not a generic method definition.</span></span> <span data-ttu-id="6292e-279">也就是说，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-279">That is, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberSignature Language="F#" Value="override this.GetMethodImplementationFlags : unit -&gt; System.Reflection.MethodImplAttributes" Usage="methodBuilder.GetMethodImplementationFlags " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6292e-280">为此方法返回实现标志。</span><span class="sxs-lookup"><span data-stu-id="6292e-280">Returns the implementation flags for the method.</span></span></summary>
        <returns><span data-ttu-id="6292e-281">为此方法返回实现标志。</span><span class="sxs-lookup"><span data-stu-id="6292e-281">Returns the implementation flags for the method.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module GetModule ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Module GetModule() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetModule" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModule () As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Module ^ GetModule();" />
      <MemberSignature Language="F#" Value="member this.GetModule : unit -&gt; System.Reflection.Module" Usage="methodBuilder.GetModule " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6292e-282">返回对包含此方法的模块的引用。</span><span class="sxs-lookup"><span data-stu-id="6292e-282">Returns a reference to the module that contains this method.</span></span></summary>
        <returns><span data-ttu-id="6292e-283">返回对包含此方法的模块的引用。</span><span class="sxs-lookup"><span data-stu-id="6292e-283">Returns a reference to the module that contains this method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="6292e-284">下面的示例代码演示了 `GetModule` 如何使用方法来检索有关动态生成的模块的信息。</span><span class="sxs-lookup"><span data-stu-id="6292e-284">The sample code below illustrates the usage of the `GetModule` method to retrieve information about a dynamically-generated module.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/CPP/source3.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/CS/source3.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberSignature Language="F#" Value="override this.GetParameters : unit -&gt; System.Reflection.ParameterInfo[]" Usage="methodBuilder.GetParameters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6292e-285">返回此方法的参数。</span><span class="sxs-lookup"><span data-stu-id="6292e-285">Returns the parameters of this method.</span></span></summary>
        <returns><span data-ttu-id="6292e-286">表示此方法的参数的 <see langword="ParameterInfo" /> 对象数组。</span><span class="sxs-lookup"><span data-stu-id="6292e-286">An array of <see langword="ParameterInfo" /> objects that represent the parameters of the method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="6292e-287">下面的代码示例演示 `GetParameters` 如何使用来发现有关传递到动态生成的方法的参数的信息。</span><span class="sxs-lookup"><span data-stu-id="6292e-287">The code sample below illustrates the use of `GetParameters` to discover information on the parameters passed to a dynamically-generated method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.GetParameters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetParameters Example/CPP/source4.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.GetParameters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetParameters Example/CS/source4.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.GetParameters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetParameters Example/VB/source4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6292e-288">目前尚不支持此方法。</span><span class="sxs-lookup"><span data-stu-id="6292e-288">This method is not currently supported.</span></span> <span data-ttu-id="6292e-289">使用 <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> 检索此方法，并在返回的 <see cref="T:System.Reflection.MethodInfo" /> 上调用 <see langword="GetParameters" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-289">Retrieve the method using <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> and call <see langword="GetParameters" /> on the returned <see cref="T:System.Reflection.MethodInfo" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetToken ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetToken() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetToken" />
      <MemberSignature Language="VB.NET" Value="Public Function GetToken () As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetToken();" />
      <MemberSignature Language="F#" Value="member this.GetToken : unit -&gt; System.Reflection.Emit.MethodToken" Usage="methodBuilder.GetToken " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6292e-290">返回表示此方法的标记的 <see langword="MethodToken" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-290">Returns the <see langword="MethodToken" /> that represents the token for this method.</span></span></summary>
        <returns><span data-ttu-id="6292e-291">返回此方法的 <see langword="MethodToken" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-291">Returns the <see langword="MethodToken" /> of this method.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InitLocals">
      <MemberSignature Language="C#" Value="public bool InitLocals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InitLocals" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.InitLocals" />
      <MemberSignature Language="VB.NET" Value="Public Property InitLocals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InitLocals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.InitLocals : bool with get, set" Usage="System.Reflection.Emit.MethodBuilder.InitLocals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6292e-292">获取或设置一个布尔值，该值指定此方法中的局部变量是否初始化为零。</span><span class="sxs-lookup"><span data-stu-id="6292e-292">Gets or sets a Boolean value that specifies whether the local variables in this method are zero initialized.</span></span> <span data-ttu-id="6292e-293">此属性的默认值为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-293">The default value of this property is <see langword="true" />.</span></span></summary>
        <value><span data-ttu-id="6292e-294">如果应将此方法中的局部变量初始化为零，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-294"><see langword="true" /> if the local variables in this method should be zero initialized; otherwise <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-295">如果将此属性设置为 `true` ，则发出的 MSIL 包括初始化局部变量。</span><span class="sxs-lookup"><span data-stu-id="6292e-295">If this property is set to `true`, the emitted MSIL includes initialization of local variables.</span></span> <span data-ttu-id="6292e-296">如果将其设置为 `false` ，则不初始化局部变量，并且无法验证所生成的代码。</span><span class="sxs-lookup"><span data-stu-id="6292e-296">If it is set to `false`, local variables are not initialized and the generated code is unverifiable.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6292e-297">对于当前的方法，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-297">For the current method, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span></span> <span data-ttu-id="6292e-298">（获取或设置。）</span><span class="sxs-lookup"><span data-stu-id="6292e-298">(Get or set.)</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object Invoke (object? obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder? binder, object?[]? parameters, System.Globalization.CultureInfo? culture);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Invoke (obj As Object, invokeAttr As BindingFlags, binder As Binder, parameters As Object(), culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="override this.Invoke : obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="methodBuilder.Invoke (obj, invokeAttr, binder, parameters, culture)" />
      <MemberSignature Language="C#" Value="public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Object[]" Index="3" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="4" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="6292e-299">在其上调用指定方法的对象。</span><span class="sxs-lookup"><span data-stu-id="6292e-299">The object on which to invoke the specified method.</span></span> <span data-ttu-id="6292e-300">如果方法是静态的，则忽略此参数。</span><span class="sxs-lookup"><span data-stu-id="6292e-300">If the method is static, this parameter is ignored.</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="6292e-301">这必须是来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志：<see langword="InvokeMethod" />、<see langword="NonPublic" /> 等等。</span><span class="sxs-lookup"><span data-stu-id="6292e-301">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span></span></param>
        <param name="binder"><span data-ttu-id="6292e-302">启用绑定、强制参数类型、调用成员并通过反射检索 MemberInfo 对象的对象。</span><span class="sxs-lookup"><span data-stu-id="6292e-302">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of MemberInfo objects via reflection.</span></span> <span data-ttu-id="6292e-303">如果活页夹为 <see langword="null" />，则使用默认活页夹。</span><span class="sxs-lookup"><span data-stu-id="6292e-303">If binder is <see langword="null" />, the default binder is used.</span></span> <span data-ttu-id="6292e-304">如需了解详情，请访问 <see cref="T:System.Reflection.Binder" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-304">For more details, see <see cref="T:System.Reflection.Binder" />.</span></span></param>
        <param name="parameters"><span data-ttu-id="6292e-305">自变量列表。</span><span class="sxs-lookup"><span data-stu-id="6292e-305">An argument list.</span></span> <span data-ttu-id="6292e-306">此自变量数组在数量、顺序和类型方面与要调用的方法的参数相同。</span><span class="sxs-lookup"><span data-stu-id="6292e-306">This is an array of arguments with the same number, order, and type as the parameters of the method to be invoked.</span></span> <span data-ttu-id="6292e-307">如果不存在任何参数，则应为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-307">If there are no parameters this should be <see langword="null" />.</span></span></param>
        <param name="culture"><span data-ttu-id="6292e-308">用于控制类型强制的 <see cref="T:System.Globalization.CultureInfo" /> 的实例。</span><span class="sxs-lookup"><span data-stu-id="6292e-308">An instance of <see cref="T:System.Globalization.CultureInfo" /> used to govern the coercion of types.</span></span> <span data-ttu-id="6292e-309">如果这是 NULL，则使用当前线程的 <see cref="T:System.Globalization.CultureInfo" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-309">If this is null, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span> <span data-ttu-id="6292e-310">（请注意，例如，这对于将表示 1000 的 <see cref="T:System.String" /> 转换为 <see cref="T:System.Double" /> 值是必需的，因为不同的区域性以不同的方式表示 1000。）</span><span class="sxs-lookup"><span data-stu-id="6292e-310">(Note that this is necessary to, for example, convert a <see cref="T:System.String" /> that represents 1000 to a <see cref="T:System.Double" /> value, since 1000 is represented differently by different cultures.)</span></span></param>
        <summary><span data-ttu-id="6292e-311">动态调用方法，此方法由此实例在给定对象上进行反射，传递指定的参数，并受给定绑定器的约束。</span><span class="sxs-lookup"><span data-stu-id="6292e-311">Dynamically invokes the method reflected by this instance on the given object, passing along the specified parameters, and under the constraints of the given binder.</span></span></summary>
        <returns><span data-ttu-id="6292e-312">返回包含已调用方法的返回值的对象。</span><span class="sxs-lookup"><span data-stu-id="6292e-312">Returns an object containing the return value of the invoked method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-313">如果该方法是静态的，则 `obj` 忽略该参数。</span><span class="sxs-lookup"><span data-stu-id="6292e-313">If the method is static, the `obj` parameter is ignored.</span></span> <span data-ttu-id="6292e-314">对于非静态方法， `obj` 应为继承或声明方法的类的实例，并且必须与此类具有相同的类型。</span><span class="sxs-lookup"><span data-stu-id="6292e-314">For non-static methods, `obj` should be an instance of a class that inherits or declares the method and must be the same type as this class.</span></span> <span data-ttu-id="6292e-315">如果该方法没有参数，则的值 `parameters` 应为 `null` 。</span><span class="sxs-lookup"><span data-stu-id="6292e-315">If the method has no parameters, the value of `parameters` should be `null`.</span></span> <span data-ttu-id="6292e-316">否则，参数数组中元素的数量、类型和顺序应与此实例所反射的方法的参数的数量、类型和顺序相同。</span><span class="sxs-lookup"><span data-stu-id="6292e-316">Otherwise the number, type, and order of elements in the parameters array should be identical to the number, type, and order of parameters for the method reflected by this instance.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6292e-317">对于完全受信任的代码，将忽略访问限制。</span><span class="sxs-lookup"><span data-stu-id="6292e-317">Access restrictions are ignored for fully-trusted code.</span></span> <span data-ttu-id="6292e-318">也就是说，只要代码完全受信任，就可以使用反射来访问和调用私有构造函数、方法、字段和属性。</span><span class="sxs-lookup"><span data-stu-id="6292e-318">That is, private constructors, methods, fields, and properties can be accessed and invoked using Reflection whenever the code is fully-trusted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6292e-319">目前尚不支持此方法。</span><span class="sxs-lookup"><span data-stu-id="6292e-319">This method is not currently supported.</span></span> <span data-ttu-id="6292e-320">使用 <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> 检索此方法，并在返回的 <see cref="T:System.Reflection.MethodInfo" /> 上调用 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-320">Retrieve the method using <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> and call <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> on the returned <see cref="T:System.Reflection.MethodInfo" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericMethod">
      <MemberSignature Language="C#" Value="public override bool IsConstructedGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsConstructedGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsConstructedGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericMethod { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericMethod : bool" Usage="System.Reflection.Emit.MethodBuilder.IsConstructedGenericMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="methodBuilder.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="6292e-321">自定义属性类型。</span><span class="sxs-lookup"><span data-stu-id="6292e-321">The custom attribute type.</span></span></param>
        <param name="inherit"><span data-ttu-id="6292e-322">指定是否搜索此成员的继承链以查找自定义属性。</span><span class="sxs-lookup"><span data-stu-id="6292e-322">Specifies whether to search this member's inheritance chain to find the custom attributes.</span></span></param>
        <summary><span data-ttu-id="6292e-323">检查是否定义了指定的自定义属性类型。</span><span class="sxs-lookup"><span data-stu-id="6292e-323">Checks if the specified custom attribute type is defined.</span></span></summary>
        <returns><span data-ttu-id="6292e-324">如果定义了指定的自定义属性类型，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-324"><see langword="true" /> if the specified custom attribute type is defined; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6292e-325">目前尚不支持此方法。</span><span class="sxs-lookup"><span data-stu-id="6292e-325">This method is not currently supported.</span></span> <span data-ttu-id="6292e-326">使用 <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> 检索此方法，并在返回的 <see cref="T:System.Reflection.MethodInfo" /> 上调用 <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-326">Retrieve the method using <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> and call <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> on the returned <see cref="T:System.Reflection.MethodInfo" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethod">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethod { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethod : bool" Usage="System.Reflection.Emit.MethodBuilder.IsGenericMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6292e-327">获取一个值，该值指示方法是否为泛型方法。</span><span class="sxs-lookup"><span data-stu-id="6292e-327">Gets a value indicating whether the method is a generic method.</span></span></summary>
        <value><span data-ttu-id="6292e-328">如果该方法是泛型方法，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-328"><see langword="true" /> if the method is generic; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-329">如果方法具有类型参数，则该方法为泛型。</span><span class="sxs-lookup"><span data-stu-id="6292e-329">A method is generic if it has type parameters.</span></span> <span data-ttu-id="6292e-330">可以通过调用 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 方法来添加类型参数，使方法成为泛型方法。</span><span class="sxs-lookup"><span data-stu-id="6292e-330">You can make a method generic by calling the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method to add type parameters.</span></span> <span data-ttu-id="6292e-331">此更改不可逆。</span><span class="sxs-lookup"><span data-stu-id="6292e-331">This change cannot be reversed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6292e-332">下面的代码示例显示方法的状态。</span><span class="sxs-lookup"><span data-stu-id="6292e-332">The following code example displays the status of a method.</span></span> <span data-ttu-id="6292e-333">此代码是为方法提供的更大示例的一部分 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-333">This code is part of a larger example provided for the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method.</span></span>  
  
 [!code-cpp[GenericMethodBuilder#7](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#7)]
 [!code-csharp[GenericMethodBuilder#7](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#7)]
 [!code-vb[GenericMethodBuilder#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit"><span data-ttu-id="6292e-334">如何：用反射发出定义泛型方法</span><span class="sxs-lookup"><span data-stu-id="6292e-334">How to: Define a Generic Method with Reflection Emit</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethodDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethodDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodDefinition : bool" Usage="System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6292e-335">获取一个值，该值指示当前 <see cref="T:System.Reflection.Emit.MethodBuilder" /> 对象是否表示泛型方法的定义。</span><span class="sxs-lookup"><span data-stu-id="6292e-335">Gets a value indicating whether the current <see cref="T:System.Reflection.Emit.MethodBuilder" /> object represents the definition of a generic method.</span></span></summary>
        <value><span data-ttu-id="6292e-336">如果当前 <see cref="T:System.Reflection.Emit.MethodBuilder" /> 对象表示泛型方法的定义，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-336"><see langword="true" /> if the current <see cref="T:System.Reflection.Emit.MethodBuilder" /> object represents the definition of a generic method; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-337"><xref:System.Reflection.Emit.MethodBuilder>只能用于创建泛型方法定义; 不能用于直接创建构造的泛型方法。</span><span class="sxs-lookup"><span data-stu-id="6292e-337">A <xref:System.Reflection.Emit.MethodBuilder> can only be used to create generic method definitions; it cannot be used to create a constructed generic method directly.</span></span> <span data-ttu-id="6292e-338">但是，的子类 <xref:System.Reflection.Emit.MethodBuilder> 可能表示构造的泛型方法。</span><span class="sxs-lookup"><span data-stu-id="6292e-338">However, a subclass of <xref:System.Reflection.Emit.MethodBuilder> might represent a constructed generic method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6292e-339">下面的代码示例显示方法的状态。</span><span class="sxs-lookup"><span data-stu-id="6292e-339">The following code example displays the status of a method.</span></span> <span data-ttu-id="6292e-340">此代码是为方法提供的更大示例的一部分 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-340">This code is part of a larger example provided for the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method.</span></span>  
  
 [!code-cpp[GenericMethodBuilder#7](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#7)]
 [!code-csharp[GenericMethodBuilder#7](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#7)]
 [!code-vb[GenericMethodBuilder#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit"><span data-ttu-id="6292e-341">如何：用反射发出定义泛型方法</span><span class="sxs-lookup"><span data-stu-id="6292e-341">How to: Define a Generic Method with Reflection Emit</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.Emit.MethodBuilder.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6292e-342">在所有情况下均引发 <see cref="T:System.NotSupportedException" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-342">Throws a <see cref="T:System.NotSupportedException" /> in all cases.</span></span></summary>
        <value><span data-ttu-id="6292e-343">在所有情况下均引发 <see cref="T:System.NotSupportedException" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-343">Throws a <see cref="T:System.NotSupportedException" /> in all cases.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-344">若要确定动态程序集中的某个方法是否是安全关键的，请通过调用来完成该类型， <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> <xref:System.Type.GetMethod%2A> 在已完成的类型上调用方法，并获取 <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> 所生成的的属性 <xref:System.Reflection.MethodInfo> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-344">To determine whether a method in a dynamic assembly is security-critical, complete the type by calling <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>, call the <xref:System.Type.GetMethod%2A> method on the completed type, and get the <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> property on the resulting <xref:System.Reflection.MethodInfo>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6292e-345">在所有情况下。</span><span class="sxs-lookup"><span data-stu-id="6292e-345">In all cases.</span></span> <span data-ttu-id="6292e-346">动态程序集中不支持此属性。</span><span class="sxs-lookup"><span data-stu-id="6292e-346">This property is not supported in dynamic assemblies.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6292e-347">在所有情况下均引发 <see cref="T:System.NotSupportedException" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-347">Throws a <see cref="T:System.NotSupportedException" /> in all cases.</span></span></summary>
        <value><span data-ttu-id="6292e-348">在所有情况下均引发 <see cref="T:System.NotSupportedException" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-348">Throws a <see cref="T:System.NotSupportedException" /> in all cases.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-349">若要确定动态程序集中的方法是否是安全可靠关键的，请通过调用来完成该类型， <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> <xref:System.Type.GetMethod%2A> 在已完成的类型上调用方法，并获取 <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> 所生成的的属性 <xref:System.Reflection.MethodInfo> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-349">To determine whether a method in a dynamic assembly is security-safe-critical, complete the type by calling <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>, call the <xref:System.Type.GetMethod%2A> method on the completed type, and get the <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> property on the resulting <xref:System.Reflection.MethodInfo>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6292e-350">在所有情况下。</span><span class="sxs-lookup"><span data-stu-id="6292e-350">In all cases.</span></span> <span data-ttu-id="6292e-351">动态程序集中不支持此属性。</span><span class="sxs-lookup"><span data-stu-id="6292e-351">This property is not supported in dynamic assemblies.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.Emit.MethodBuilder.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6292e-352">在所有情况下均引发 <see cref="T:System.NotSupportedException" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-352">Throws a <see cref="T:System.NotSupportedException" /> in all cases.</span></span></summary>
        <value><span data-ttu-id="6292e-353">在所有情况下均引发 <see cref="T:System.NotSupportedException" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-353">Throws a <see cref="T:System.NotSupportedException" /> in all cases.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-354">若要确定动态程序集中的某个方法是否为安全透明的，请通过调用完成该类型， <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> <xref:System.Type.GetMethod%2A> 在已完成的类型上调用方法，并获取 <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> 所生成的的属性 <xref:System.Reflection.MethodInfo> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-354">To determine whether a method in a dynamic assembly is security-transparent, complete the type by calling <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>, call the <xref:System.Type.GetMethod%2A> method on the completed type, and get the <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> property on the resulting <xref:System.Reflection.MethodInfo>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6292e-355">在所有情况下。</span><span class="sxs-lookup"><span data-stu-id="6292e-355">In all cases.</span></span> <span data-ttu-id="6292e-356">动态程序集中不支持此属性。</span><span class="sxs-lookup"><span data-stu-id="6292e-356">This property is not supported in dynamic assemblies.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo MakeGenericMethod (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo MakeGenericMethod(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeGenericMethod (ParamArray typeArguments As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ MakeGenericMethod(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="override this.MakeGenericMethod : Type[] -&gt; System.Reflection.MethodInfo" Usage="methodBuilder.MakeGenericMethod typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments"><span data-ttu-id="6292e-357">表示泛型方法的类型参数的 <see cref="T:System.Type" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="6292e-357">An array of <see cref="T:System.Type" /> objects that represent the type arguments for the generic method.</span></span></param>
        <summary><span data-ttu-id="6292e-358">返回使用指定泛型类型参数从当前泛型方法定义构造的泛型方法。</span><span class="sxs-lookup"><span data-stu-id="6292e-358">Returns a generic method constructed from the current generic method definition using the specified generic type arguments.</span></span></summary>
        <returns><span data-ttu-id="6292e-359">一个 <see cref="T:System.Reflection.MethodInfo" />，它表示使用指定泛型类型参数从当前泛型方法定义构造的泛型方法。</span><span class="sxs-lookup"><span data-stu-id="6292e-359">A <see cref="T:System.Reflection.MethodInfo" /> representing the generic method constructed from the current generic method definition using the specified generic type arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-360">发出动态代码时，您可能需要在 <xref:System.Reflection.Emit.MethodBuilder> 完成封闭类型之前发出对由表示的泛型方法定义构造的方法的调用。</span><span class="sxs-lookup"><span data-stu-id="6292e-360">When you are emitting dynamic code, you might need to emit a call to a method constructed from the generic method definition represented by a <xref:System.Reflection.Emit.MethodBuilder>, before the enclosing type has been completed.</span></span> <span data-ttu-id="6292e-361">您可以使用 <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> 方法为 <xref:System.Reflection.MethodInfo> 此类构造方法创建一个，并 <xref:System.Reflection.MethodInfo> 在发出的调用中使用。</span><span class="sxs-lookup"><span data-stu-id="6292e-361">You can use the <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> method to create a <xref:System.Reflection.MethodInfo> for such a constructed method, and use the <xref:System.Reflection.MethodInfo> in the emitted call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6292e-362">下面的代码示例通过不完整的类型中的不完整泛型方法定义来创建构造方法。</span><span class="sxs-lookup"><span data-stu-id="6292e-362">The following code example creates a constructed method from an incomplete generic method definition in an incomplete type.</span></span>  
  
 <span data-ttu-id="6292e-363">该示例创建一个具有单个类型的临时程序集和模块，添加一个方法 `M` ，并通过使用方法添加一个类型参数来使该方法成为泛型方法 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-363">The example creates a transient assembly and module with a single type, adds a method `M`, and makes the method generic by adding a type parameter T using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method.</span></span> <span data-ttu-id="6292e-364">类型参数用作方法的参数类型，也用作其返回类型。</span><span class="sxs-lookup"><span data-stu-id="6292e-364">The type parameter is used as the type of the method's parameter, and also as its return type.</span></span> <span data-ttu-id="6292e-365">不会为泛型方法定义提供主体，并且不会完成封闭类型。</span><span class="sxs-lookup"><span data-stu-id="6292e-365">The generic method definition is not given a body, and the enclosing type is not completed.</span></span> <span data-ttu-id="6292e-366"><xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A>然后，使用方法将构造方法 `M<String>` (`M(Of String)` Visual Basic) 中。</span><span class="sxs-lookup"><span data-stu-id="6292e-366">The <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> method is then used to make the constructed method `M<String>` (`M(Of String)` in Visual Basic).</span></span> <span data-ttu-id="6292e-367">示例代码没有输出，因为 <xref:System.Reflection.MethodInfo> 方法返回的子类 <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> 不允许对其参数进行反射。</span><span class="sxs-lookup"><span data-stu-id="6292e-367">The example code has no output, because the subclass of <xref:System.Reflection.MethodInfo> returned by the <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> method does not allow reflection over its parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6292e-368">有关使用的其他代码示例 <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> ，请参见 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-368">For another code example that uses <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A>, see <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A>.</span></span> <span data-ttu-id="6292e-369"><xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> 发出使用泛型类型的代码时，也会广泛使用。</span><span class="sxs-lookup"><span data-stu-id="6292e-369"><xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> is also used extensively when emitting code that uses generic types.</span></span> <span data-ttu-id="6292e-370">请参阅 [如何：使用反射发出定义泛型方法](/dotnet/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit)。</span><span class="sxs-lookup"><span data-stu-id="6292e-370">See [How to: Define a Generic Method with Reflection Emit](/dotnet/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit).</span></span>  
  
 [!code-cpp[MethodBuilder.MakeGenericMethod#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBuilder.MakeGenericMethod/cpp/source.cpp#1)]
 [!code-csharp[MethodBuilder.MakeGenericMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBuilder.MakeGenericMethod/cs/source.cs#1)]
 [!code-vb[MethodBuilder.MakeGenericMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBuilder.MakeGenericMethod/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit"><span data-ttu-id="6292e-371">如何：用反射发出定义泛型方法</span><span class="sxs-lookup"><span data-stu-id="6292e-371">How to: Define a Generic Method with Reflection Emit</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public override RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodHandle : RuntimeMethodHandle" Usage="System.Reflection.Emit.MethodBuilder.MethodHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6292e-372">检索此方法的内部句柄。</span><span class="sxs-lookup"><span data-stu-id="6292e-372">Retrieves the internal handle for the method.</span></span> <span data-ttu-id="6292e-373">使用此句柄来访问基础元数据句柄。</span><span class="sxs-lookup"><span data-stu-id="6292e-373">Use this handle to access the underlying metadata handle.</span></span></summary>
        <value><span data-ttu-id="6292e-374">只读。</span><span class="sxs-lookup"><span data-stu-id="6292e-374">Read-only.</span></span> <span data-ttu-id="6292e-375">方法的内部处理程序。</span><span class="sxs-lookup"><span data-stu-id="6292e-375">The internal handle for the method.</span></span> <span data-ttu-id="6292e-376">使用此句柄来访问基础元数据句柄。</span><span class="sxs-lookup"><span data-stu-id="6292e-376">Use this handle to access the underlying metadata handle.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6292e-377">目前尚不支持此方法。</span><span class="sxs-lookup"><span data-stu-id="6292e-377">This method is not currently supported.</span></span> <span data-ttu-id="6292e-378">使用 <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> 检索此方法，并在返回的 <see cref="T:System.Reflection.MethodInfo" /> 上调用 <see cref="P:System.Reflection.MethodBase.MethodHandle" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-378">Retrieve the method using <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> and call <see cref="P:System.Reflection.MethodBase.MethodHandle" /> on the returned <see cref="T:System.Reflection.MethodInfo" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodImplementationFlags : System.Reflection.MethodImplAttributes" Usage="System.Reflection.Emit.MethodBuilder.MethodImplementationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.Emit.MethodBuilder.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6292e-379">获取在其中定义了当前方法的模块。</span><span class="sxs-lookup"><span data-stu-id="6292e-379">Gets the module in which the current method is being defined.</span></span></summary>
        <value><span data-ttu-id="6292e-380">正在定义其中成员由当前 <see cref="T:System.Reflection.MemberInfo" /> 表示的 <see cref="T:System.Reflection.Module" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-380">The <see cref="T:System.Reflection.Module" /> in which the member represented by the current <see cref="T:System.Reflection.MemberInfo" /> is being defined.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-381">提供此属性是为了方便。</span><span class="sxs-lookup"><span data-stu-id="6292e-381">This property is provided as a convenience.</span></span> <span data-ttu-id="6292e-382">它等效于使用 <xref:System.Reflection.Emit.MethodBuilder.DeclaringType%2A> 属性获取在其中声明该方法的类型，然后调用 <xref:System.Type.Module%2A> 所产生的对象的属性 <xref:System.Type> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-382">It is equivalent to using the <xref:System.Reflection.Emit.MethodBuilder.DeclaringType%2A> property to get the type in which the method is being declared, and then calling the <xref:System.Type.Module%2A> property of the resulting <xref:System.Type> object.</span></span>  
  
 <span data-ttu-id="6292e-383">此属性也等效于调用 <xref:System.Reflection.Emit.MethodBuilder.GetModule%2A> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-383">This property is also equivalent to calling <xref:System.Reflection.Emit.MethodBuilder.GetModule%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.MethodBuilder.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6292e-384">检索此方法的名称。</span><span class="sxs-lookup"><span data-stu-id="6292e-384">Retrieves the name of this method.</span></span></summary>
        <value><span data-ttu-id="6292e-385">只读。</span><span class="sxs-lookup"><span data-stu-id="6292e-385">Read-only.</span></span> <span data-ttu-id="6292e-386">检索包含此方法简单名称的字符串。</span><span class="sxs-lookup"><span data-stu-id="6292e-386">Retrieves a string containing the simple name of this method.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type? ReflectedType { get; }" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Reflection.Emit.MethodBuilder.ReflectedType" />
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6292e-387">检索在反射中用于获取此对象的类。</span><span class="sxs-lookup"><span data-stu-id="6292e-387">Retrieves the class that was used in reflection to obtain this object.</span></span></summary>
        <value><span data-ttu-id="6292e-388">只读。</span><span class="sxs-lookup"><span data-stu-id="6292e-388">Read-only.</span></span> <span data-ttu-id="6292e-389">用于获取此方法的类型。</span><span class="sxs-lookup"><span data-stu-id="6292e-389">The type used to obtain this method.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnParameter : System.Reflection.ParameterInfo" Usage="System.Reflection.Emit.MethodBuilder.ReturnParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6292e-390">获取一个 <see cref="T:System.Reflection.ParameterInfo" /> 对象，该对象包含有关方法的返回类型的信息（例如返回类型是否具有自定义修饰符）。</span><span class="sxs-lookup"><span data-stu-id="6292e-390">Gets a <see cref="T:System.Reflection.ParameterInfo" /> object that contains information about the return type of the method, such as whether the return type has custom modifiers.</span></span></summary>
        <value><span data-ttu-id="6292e-391">一个 <see cref="T:System.Reflection.ParameterInfo" /> 对象，包含有关返回类型的信息。</span><span class="sxs-lookup"><span data-stu-id="6292e-391">A <see cref="T:System.Reflection.ParameterInfo" /> object that contains information about the return type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-392">编译器设计器可以使用 <xref:System.Reflection.ParameterInfo> 此属性返回的对象来发现自定义修饰符（如 <xref:Microsoft.VisualC.IsConstModifier> ）是否已应用于返回类型。</span><span class="sxs-lookup"><span data-stu-id="6292e-392">Compiler designers can use the <xref:System.Reflection.ParameterInfo> object returned by this property to discover whether custom modifiers, such as <xref:Microsoft.VisualC.IsConstModifier>, have been applied to the return type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6292e-393">尚未创建声明类型。</span><span class="sxs-lookup"><span data-stu-id="6292e-393">The declaring type has not been created.</span></span></exception>
        <altmember cref="M:System.Reflection.ParameterInfo.GetOptionalCustomModifiers" />
        <altmember cref="M:System.Reflection.ParameterInfo.GetRequiredCustomModifiers" />
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public override Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnType : Type" Usage="System.Reflection.Emit.MethodBuilder.ReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6292e-394">获取此 <see cref="T:System.Reflection.Emit.MethodBuilder" /> 所表示的方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="6292e-394">Gets the return type of the method represented by this <see cref="T:System.Reflection.Emit.MethodBuilder" />.</span></span></summary>
        <value><span data-ttu-id="6292e-395">方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="6292e-395">The return type of the method.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="6292e-396">从 .NET Framework 2.0 和 .NET Compact Framework 2.0 开始，此成员继承自基类 <xref:System.Reflection.MethodInfo> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-396">Starting with the .NET Framework 2.0 and the .NET Compact Framework 2.0, this member is inherited from the base class, <xref:System.Reflection.MethodInfo>.</span></span> <span data-ttu-id="6292e-397">请参阅 <xref:System.Reflection.MethodInfo.ReturnType%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6292e-397">See <xref:System.Reflection.MethodInfo.ReturnType%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnTypeCustomAttributes : System.Reflection.ICustomAttributeProvider" Usage="System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6292e-398">返回此方法的返回类型的自定义属性。</span><span class="sxs-lookup"><span data-stu-id="6292e-398">Returns the custom attributes of the method's return type.</span></span></summary>
        <value><span data-ttu-id="6292e-399">只读。</span><span class="sxs-lookup"><span data-stu-id="6292e-399">Read-only.</span></span> <span data-ttu-id="6292e-400">此方法的返回类型的自定义属性。</span><span class="sxs-lookup"><span data-stu-id="6292e-400">The custom attributes of the method's return type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-401">此方法始终返回 `null`。</span><span class="sxs-lookup"><span data-stu-id="6292e-401">This method always returns `null`.</span></span> <span data-ttu-id="6292e-402">在 <xref:System.Reflection.MethodInfo> <xref:System.Type> 上创建并调用包含的后获取 <xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A> <xref:System.Reflection.MethodInfo> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-402">Get the <xref:System.Reflection.MethodInfo> after the containing <xref:System.Type> has been created and invoked <xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A> on the <xref:System.Reflection.MethodInfo>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCustomAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="6292e-403">设置自定义属性。</span><span class="sxs-lookup"><span data-stu-id="6292e-403">Sets a custom attribute.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (customBuilder As CustomAttributeBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::Emit::CustomAttributeBuilder ^ customBuilder);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.Emit.CustomAttributeBuilder -&gt; unit" Usage="methodBuilder.SetCustomAttribute customBuilder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder"><span data-ttu-id="6292e-404">用于描述自定义属性的帮助器类的实例。</span><span class="sxs-lookup"><span data-stu-id="6292e-404">An instance of a helper class to describe the custom attribute.</span></span></param>
        <summary><span data-ttu-id="6292e-405">使用自定义属性生成器设置自定义属性。</span><span class="sxs-lookup"><span data-stu-id="6292e-405">Sets a custom attribute using a custom attribute builder.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-406"><xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 当两个方法结合使用时，方法可以与方法交互。</span><span class="sxs-lookup"><span data-stu-id="6292e-406">The <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> method can interact with the <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> method when the two methods are used in combination.</span></span> <span data-ttu-id="6292e-407">有关详细信息，请参阅方法的 "备注" 部分 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-407">See the Remarks section of the <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> method for details.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6292e-408"><paramref name="customBuilder" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-408"><paramref name="customBuilder" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6292e-409">对于当前的方法，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-409">For the current method, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (con As ConstructorInfo, binaryAttribute As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::ConstructorInfo ^ con, cli::array &lt;System::Byte&gt; ^ binaryAttribute);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.ConstructorInfo * byte[] -&gt; unit" Usage="methodBuilder.SetCustomAttribute (con, binaryAttribute)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con"><span data-ttu-id="6292e-410">自定义属性的构造函数。</span><span class="sxs-lookup"><span data-stu-id="6292e-410">The constructor for the custom attribute.</span></span></param>
        <param name="binaryAttribute"><span data-ttu-id="6292e-411">表示属性的字节 blob。</span><span class="sxs-lookup"><span data-stu-id="6292e-411">A byte blob representing the attributes.</span></span></param>
        <summary><span data-ttu-id="6292e-412">使用指定的自定义属性 blob 设置自定义属性。</span><span class="sxs-lookup"><span data-stu-id="6292e-412">Sets a custom attribute using a specified custom attribute blob.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-413">有关如何设置格式的详细信息 `binaryAttribute` ，请参阅公共语言基础结构 (CLI) 文档，尤其是 "第二部分：元数据定义和语义"。</span><span class="sxs-lookup"><span data-stu-id="6292e-413">For details on how to format `binaryAttribute`, see the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="6292e-414">可联机获取该文档；请参阅 MSDN 上的 [ECMA C# 和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)和 Ecma International 网站上的[标准 ECMA-335 - 公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)。</span><span class="sxs-lookup"><span data-stu-id="6292e-414">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 <span data-ttu-id="6292e-415"><xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 当两个方法结合使用时，方法可以与方法交互。</span><span class="sxs-lookup"><span data-stu-id="6292e-415">The <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> method can interact with the <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> method when the two methods are used in combination.</span></span> <span data-ttu-id="6292e-416">有关详细信息，请参阅方法的 "备注" 部分 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-416">See the Remarks section of the <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> method for details.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6292e-417"><paramref name="con" /> 或 <paramref name="binaryAttribute" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-417"><paramref name="con" /> or <paramref name="binaryAttribute" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6292e-418">对于当前的方法，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-418">For the current method, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetImplementationFlags">
      <MemberSignature Language="C#" Value="public void SetImplementationFlags (System.Reflection.MethodImplAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetImplementationFlags(valuetype System.Reflection.MethodImplAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetImplementationFlags (attributes As MethodImplAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetImplementationFlags(System::Reflection::MethodImplAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.SetImplementationFlags : System.Reflection.MethodImplAttributes -&gt; unit" Usage="methodBuilder.SetImplementationFlags attributes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodImplAttributes" />
      </Parameters>
      <Docs>
        <param name="attributes"><span data-ttu-id="6292e-419">要设置的实现标志。</span><span class="sxs-lookup"><span data-stu-id="6292e-419">The implementation flags to set.</span></span></param>
        <summary><span data-ttu-id="6292e-420">为此方法设置实现标志。</span><span class="sxs-lookup"><span data-stu-id="6292e-420">Sets the implementation flags for this method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-421">将 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 方法与方法结合使用时 <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> ，请注意潜在的交互。</span><span class="sxs-lookup"><span data-stu-id="6292e-421">When you use the <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> method in combination with the <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> method, be aware of potential interactions.</span></span> <span data-ttu-id="6292e-422">例如，使用 <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> 方法添加 <xref:System.Runtime.InteropServices.DllImportAttribute> 特性还会设置 <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> 标志。</span><span class="sxs-lookup"><span data-stu-id="6292e-422">For example, using the <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> method to add the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute also sets the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="6292e-423">如果随后调用 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 方法，则 <xref:System.Reflection.MethodImplAttributes.PreserveSig> 会覆盖标志。</span><span class="sxs-lookup"><span data-stu-id="6292e-423">If you subsequently call the <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> method, the <xref:System.Reflection.MethodImplAttributes.PreserveSig> flag is overwritten.</span></span> <span data-ttu-id="6292e-424">可通过两种方式来避免此问题：</span><span class="sxs-lookup"><span data-stu-id="6292e-424">There are two ways to avoid this:</span></span>  
  
-   <span data-ttu-id="6292e-425">在 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 调用方法之前调用方法 <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-425">Call the <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> method before you call the <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> method.</span></span> <span data-ttu-id="6292e-426"><xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A>方法始终遵循现有方法实现标志。</span><span class="sxs-lookup"><span data-stu-id="6292e-426">The <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> method always respects existing method implementation flags.</span></span>  
  
-   <span data-ttu-id="6292e-427">设置实现标志后，调用 <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A> 方法以检索现有标志，使用按位或添加标志，然后调用 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="6292e-427">When you set implementation flags, call the <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A> method to retrieve the existing flags, use bitwise OR to add your flag, and then call the <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6292e-428">下面的代码示例演示了 `SetImplementationFlags` 如何在方法体中描述 MSIL 实现的方法的上下文用法。</span><span class="sxs-lookup"><span data-stu-id="6292e-428">The code sample below illustrates the contextual use of the `SetImplementationFlags` method to describe the implementation of MSIL in a method body.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetImplementationFlags Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetImplementationFlags Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetImplementationFlags Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6292e-429">该包含类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</span><span class="sxs-lookup"><span data-stu-id="6292e-429">The containing type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="6292e-430">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6292e-430">-or-</span></span> 
<span data-ttu-id="6292e-431">对于当前的方法，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-431">For the current method, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetMarshal">
      <MemberSignature Language="C#" Value="public void SetMarshal (System.Reflection.Emit.UnmanagedMarshal unmanagedMarshal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMarshal(class System.Reflection.Emit.UnmanagedMarshal unmanagedMarshal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetMarshal (unmanagedMarshal As UnmanagedMarshal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetMarshal(System::Reflection::Emit::UnmanagedMarshal ^ unmanagedMarshal);" />
      <MemberSignature Language="F#" Value="member this.SetMarshal : System.Reflection.Emit.UnmanagedMarshal -&gt; unit" Usage="methodBuilder.SetMarshal unmanagedMarshal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Obsolete("An alternate API is available: Emit the MarshalAs custom attribute instead. http://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("An alternate API is available: Emit the MarshalAs custom attribute instead. http://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Obsolete("An alternate API is available: Emit the MarshalAs custom attribute instead.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("An alternate API is available: Emit the MarshalAs custom attribute instead.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unmanagedMarshal" Type="System.Reflection.Emit.UnmanagedMarshal" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="unmanagedMarshal"><span data-ttu-id="6292e-432">此方法的返回类型的封送处理信息。</span><span class="sxs-lookup"><span data-stu-id="6292e-432">Marshaling information for the return type of this method.</span></span></param>
        <summary><span data-ttu-id="6292e-433">设置此方法的返回类型的封送处理信息。</span><span class="sxs-lookup"><span data-stu-id="6292e-433">Sets marshaling information for the return type of this method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="6292e-434">下面的代码示例演示了方法的上下文用法 `SetMarshal` ，以将方法调用的结果封送为不同的类型。</span><span class="sxs-lookup"><span data-stu-id="6292e-434">The code sample below illustrates the contextual usage of the `SetMarshal` method to marshal the results of a method call as a different type.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.SetMarshal Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetMarshal Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.SetMarshal Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetMarshal Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.SetMarshal Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetMarshal Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6292e-435">该包含类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</span><span class="sxs-lookup"><span data-stu-id="6292e-435">The containing type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="6292e-436">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6292e-436">-or-</span></span> 
<span data-ttu-id="6292e-437">对于当前的方法，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-437">For the current method, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetMethodBody">
      <MemberSignature Language="C#" Value="public void SetMethodBody (byte[] il, int maxStack, byte[] localSignature, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.ExceptionHandler&gt; exceptionHandlers, System.Collections.Generic.IEnumerable&lt;int&gt; tokenFixups);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMethodBody(unsigned int8[] il, int32 maxStack, unsigned int8[] localSignature, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Reflection.Emit.ExceptionHandler&gt; exceptionHandlers, class System.Collections.Generic.IEnumerable`1&lt;int32&gt; tokenFixups) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetMethodBody (il As Byte(), maxStack As Integer, localSignature As Byte(), exceptionHandlers As IEnumerable(Of ExceptionHandler), tokenFixups As IEnumerable(Of Integer))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetMethodBody(cli::array &lt;System::Byte&gt; ^ il, int maxStack, cli::array &lt;System::Byte&gt; ^ localSignature, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::ExceptionHandler&gt; ^ exceptionHandlers, System::Collections::Generic::IEnumerable&lt;int&gt; ^ tokenFixups);" />
      <MemberSignature Language="F#" Value="member this.SetMethodBody : byte[] * int * byte[] * seq&lt;System.Reflection.Emit.ExceptionHandler&gt; * seq&lt;int&gt; -&gt; unit" Usage="methodBuilder.SetMethodBody (il, maxStack, localSignature, exceptionHandlers, tokenFixups)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="il" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="maxStack" Type="System.Int32" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="localSignature" Type="System.Byte[]" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exceptionHandlers" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.ExceptionHandler&gt;" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="tokenFixups" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" Index="4" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="il"><span data-ttu-id="6292e-438">包含有效 MSIL 指令的数组。</span><span class="sxs-lookup"><span data-stu-id="6292e-438">An array that contains valid MSIL instructions.</span></span></param>
        <param name="maxStack"><span data-ttu-id="6292e-439">最大堆栈评估深度。</span><span class="sxs-lookup"><span data-stu-id="6292e-439">The maximum stack evaluation depth.</span></span></param>
        <param name="localSignature"><span data-ttu-id="6292e-440">包含序列化本地变量结构的字节数组。</span><span class="sxs-lookup"><span data-stu-id="6292e-440">An array of bytes that contain the serialized local variable structure.</span></span> <span data-ttu-id="6292e-441">如果此方法不具有任何本地变量，则指定 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-441">Specify <see langword="null" /> if the method has no local variables.</span></span></param>
        <param name="exceptionHandlers"><span data-ttu-id="6292e-442">包含此方法的异常处理程序的集合。</span><span class="sxs-lookup"><span data-stu-id="6292e-442">A collection that contains the exception handlers for the method.</span></span> <span data-ttu-id="6292e-443">如果此方法没有异常处理程序，则指定 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-443">Specify <see langword="null" /> if the method has no exception handlers.</span></span></param>
        <param name="tokenFixups"><span data-ttu-id="6292e-444">表示 <paramref name="il" /> 中的偏移量的值的集合，其中的每个值指定可以修改的令牌起始点。</span><span class="sxs-lookup"><span data-stu-id="6292e-444">A collection of values that represent offsets in <paramref name="il" />, each of which specifies the beginning of a token that may be modified.</span></span> <span data-ttu-id="6292e-445">如果此方法没有需要修改的令牌，则指定 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-445">Specify <see langword="null" /> if the method has no tokens that have to be modified.</span></span></param>
        <summary><span data-ttu-id="6292e-446">通过使用 Microsoft 中间语言 (MSIL) 指令指定的字节数组创建方法的主体。</span><span class="sxs-lookup"><span data-stu-id="6292e-446">Creates the body of the method by using a specified byte array of Microsoft intermediate language (MSIL) instructions.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6292e-447"><paramref name="il" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-447"><paramref name="il" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="6292e-448"><paramref name="maxStack" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="6292e-448"><paramref name="maxStack" /> is negative.</span></span>  
  
<span data-ttu-id="6292e-449">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6292e-449">-or-</span></span> 
<span data-ttu-id="6292e-450">其中一个 <paramref name="exceptionHandlers" /> 指定 <paramref name="il" /> 外部的偏移量。</span><span class="sxs-lookup"><span data-stu-id="6292e-450">One of <paramref name="exceptionHandlers" /> specifies an offset outside of <paramref name="il" />.</span></span>  
  
<span data-ttu-id="6292e-451">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6292e-451">-or-</span></span> 
<span data-ttu-id="6292e-452">其中一个 <paramref name="tokenFixups" /> 指定 <paramref name="il" /> 数组外部的偏移量。</span><span class="sxs-lookup"><span data-stu-id="6292e-452">One of <paramref name="tokenFixups" /> specifies an offset that is outside the <paramref name="il" /> array.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6292e-453">该包含类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 方法创建的。</span><span class="sxs-lookup"><span data-stu-id="6292e-453">The containing type was previously created using the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span></span>  
  
<span data-ttu-id="6292e-454">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6292e-454">-or-</span></span> 
<span data-ttu-id="6292e-455">之前已在此 <see cref="T:System.Reflection.Emit.MethodBuilder" /> 对象上调用过此方法。</span><span class="sxs-lookup"><span data-stu-id="6292e-455">This method was called previously on this <see cref="T:System.Reflection.Emit.MethodBuilder" /> object.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetParameters">
      <MemberSignature Language="C#" Value="public void SetParameters (params Type[] parameterTypes);" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetParameters(class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetParameters (ParamArray parameterTypes As Type())" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetParameters(... cli::array &lt;Type ^&gt; ^ parameterTypes);" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.SetParameters : Type[] -&gt; unit" Usage="methodBuilder.SetParameters parameterTypes" />
      <MemberSignature Language="C#" Value="public void SetParameters (Type[] parameterTypes);" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetParameters (parameterTypes As Type())" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetParameters(cli::array &lt;Type ^&gt; ^ parameterTypes);" FrameworkAlternate="xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterTypes" Type="System.Type[]" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parameterTypes"><span data-ttu-id="6292e-456">表示参数类型的 <see cref="T:System.Type" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="6292e-456">An array of <see cref="T:System.Type" /> objects representing the parameter types.</span></span></param>
        <summary><span data-ttu-id="6292e-457">为方法设置参数的数量和类型。</span><span class="sxs-lookup"><span data-stu-id="6292e-457">Sets the number and types of parameters for a method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-458">如果在定义方法时参数的数量和类型已知，则可以使用 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> 接受参数类型数组的方法的任何重载来设置这些参数。</span><span class="sxs-lookup"><span data-stu-id="6292e-458">If the number and types of the parameters are known when the method is defined, they can be set using any overload of the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> method that accepts an array of parameter types.</span></span> <span data-ttu-id="6292e-459">但是，泛型方法可以具有其类型由一个或多个其自己的泛型类型参数指定的参数，在定义该方法之后，才能定义这些参数。</span><span class="sxs-lookup"><span data-stu-id="6292e-459">However, a generic method can have parameters whose types are specified by one or more of its own generic type parameters, which cannot be defined until after the method has been defined.</span></span> <span data-ttu-id="6292e-460">在这种情况下，使用此方法设置参数类型。</span><span class="sxs-lookup"><span data-stu-id="6292e-460">Use this method to set the parameter types in that case.</span></span>  
  
 <span data-ttu-id="6292e-461">如果返回类型具有可选或必需的自定义修饰符（例如 <xref:System.Runtime.CompilerServices.IsConst> ），请使用 <xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29> 方法重载。</span><span class="sxs-lookup"><span data-stu-id="6292e-461">If the return type has optional or required custom modifiers, such as <xref:System.Runtime.CompilerServices.IsConst>, use the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29> method overload.</span></span>  
  
 <span data-ttu-id="6292e-462">调用此方法将替换使用方法设置的任何参数类型 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-462">Calling this method replaces any parameter types that were set using the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6292e-463">下面的代码示例使用 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 方法使方法成为泛型方法。</span><span class="sxs-lookup"><span data-stu-id="6292e-463">The following code example uses the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method to make a method generic.</span></span> <span data-ttu-id="6292e-464"><xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A>方法用于为方法指定一个参数，该参数的类型将由第一个泛型类型参数指定。</span><span class="sxs-lookup"><span data-stu-id="6292e-464">The <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> method is used to give the method one parameter, whose type will be specified by the first generic type parameter.</span></span> <span data-ttu-id="6292e-465"><xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A>方法用于为方法指定由第二个泛型类型参数指定的返回类型。</span><span class="sxs-lookup"><span data-stu-id="6292e-465">The <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> method is used to give the method a return type, specified by the second generic type parameter.</span></span>  
  
 <span data-ttu-id="6292e-466">此代码是为方法提供的更大示例的一部分 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-466">This code is part of a larger example provided for the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method.</span></span>  
  
 [!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
 [!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
 [!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6292e-467">当前方法是泛型方法，但不是泛型方法定义。</span><span class="sxs-lookup"><span data-stu-id="6292e-467">The current method is generic, but is not a generic method definition.</span></span> <span data-ttu-id="6292e-468">也就是说，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-468">That is, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span></span></exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit"><span data-ttu-id="6292e-469">如何：用反射发出定义泛型方法</span><span class="sxs-lookup"><span data-stu-id="6292e-469">How to: Define a Generic Method with Reflection Emit</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetReturnType">
      <MemberSignature Language="C#" Value="public void SetReturnType (Type? returnType);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetReturnType(class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetReturnType (returnType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetReturnType(Type ^ returnType);" />
      <MemberSignature Language="F#" Value="member this.SetReturnType : Type -&gt; unit" Usage="methodBuilder.SetReturnType returnType" />
      <MemberSignature Language="C#" Value="public void SetReturnType (Type returnType);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="returnType"><span data-ttu-id="6292e-470">表示方法的返回类型的 <see cref="T:System.Type" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="6292e-470">A <see cref="T:System.Type" /> object that represents the return type of the method.</span></span></param>
        <summary><span data-ttu-id="6292e-471">设置方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="6292e-471">Sets the return type of the method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-472">如果返回类型由方法的一个泛型类型参数指定，则使用此方法设置泛型方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="6292e-472">Use this method to set the return type of a generic method, when the return type is specified by one of the generic type parameters of the method.</span></span> <span data-ttu-id="6292e-473">如果返回类型具有可选或必需的自定义修饰符（例如 <xref:System.Runtime.CompilerServices.IsConst> ），请使用 <xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29> 方法重载。</span><span class="sxs-lookup"><span data-stu-id="6292e-473">If the return type has optional or required custom modifiers, such as <xref:System.Runtime.CompilerServices.IsConst>, use the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29> method overload.</span></span>  
  
 <span data-ttu-id="6292e-474">调用此方法将替换使用方法建立的返回类型 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-474">Calling this method replaces a return type established using the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6292e-475">下面的代码示例使用 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 方法使方法成为泛型方法。</span><span class="sxs-lookup"><span data-stu-id="6292e-475">The following code example uses the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method to make a method generic.</span></span> <span data-ttu-id="6292e-476"><xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A>方法用于为方法指定一个参数，该参数的类型将由第一个泛型类型参数指定。</span><span class="sxs-lookup"><span data-stu-id="6292e-476">The <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> method is used to give the method one parameter, whose type will be specified by the first generic type parameter.</span></span> <span data-ttu-id="6292e-477"><xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A>方法用于为方法指定由第二个泛型类型参数指定的返回类型。</span><span class="sxs-lookup"><span data-stu-id="6292e-477">The <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> method is used to give the method a return type, specified by the second generic type parameter.</span></span>  
  
 <span data-ttu-id="6292e-478">此代码是为方法提供的更大示例的一部分 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-478">This code is part of a larger example provided for the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method.</span></span>  
  
 [!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
 [!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
 [!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6292e-479">当前方法是泛型方法，但不是泛型方法定义。</span><span class="sxs-lookup"><span data-stu-id="6292e-479">The current method is generic, but is not a generic method definition.</span></span> <span data-ttu-id="6292e-480">也就是说，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-480">That is, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span></span></exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit"><span data-ttu-id="6292e-481">如何：用反射发出定义泛型方法</span><span class="sxs-lookup"><span data-stu-id="6292e-481">How to: Define a Generic Method with Reflection Emit</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetSignature">
      <MemberSignature Language="C#" Value="public void SetSignature (Type? returnType, Type[]? returnTypeRequiredCustomModifiers, Type[]? returnTypeOptionalCustomModifiers, Type[]? parameterTypes, Type[][]? parameterTypeRequiredCustomModifiers, Type[][]? parameterTypeOptionalCustomModifiers);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSignature(class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSignature (returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSignature(Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.SetSignature : Type * Type[] * Type[] * Type[] * Type[][] * Type[][] -&gt; unit" Usage="methodBuilder.SetSignature (returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers)" />
      <MemberSignature Language="C#" Value="public void SetSignature (Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" Index="1" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" Index="2" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameterTypes" Type="System.Type[]" Index="3" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" Index="4" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" Index="5" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="returnType"><span data-ttu-id="6292e-482">方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="6292e-482">The return type of the method.</span></span></param>
        <param name="returnTypeRequiredCustomModifiers"><span data-ttu-id="6292e-483">一个类型数组，表示该方法的返回类型所必需的自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-483">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span></span> <span data-ttu-id="6292e-484">如果返回类型没有所需的自定义修饰符，则指定 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-484">If the return type has no required custom modifiers, specify <see langword="null" />.</span></span></param>
        <param name="returnTypeOptionalCustomModifiers"><span data-ttu-id="6292e-485">一个类型数组，表示该方法的返回类型的可选自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-485">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span></span> <span data-ttu-id="6292e-486">如果返回类型没有可选的自定义修饰符，则指定 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-486">If the return type has no optional custom modifiers, specify <see langword="null" />.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="6292e-487">方法参数的类型。</span><span class="sxs-lookup"><span data-stu-id="6292e-487">The types of the parameters of the method.</span></span></param>
        <param name="parameterTypeRequiredCustomModifiers"><span data-ttu-id="6292e-488">由类型数组组成的数组。</span><span class="sxs-lookup"><span data-stu-id="6292e-488">An array of arrays of types.</span></span> <span data-ttu-id="6292e-489">每个类型数组均表示相应参数所必需的自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-489">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="6292e-490">如果某个特定参数没有所需的自定义修饰符，则指定 <see langword="null" />，而不要指定类型数组。</span><span class="sxs-lookup"><span data-stu-id="6292e-490">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="6292e-491">如果所有参数都没有所需的自定义修饰符，则指定 <see langword="null" />，而不要指定由数组组成的数组。</span><span class="sxs-lookup"><span data-stu-id="6292e-491">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <param name="parameterTypeOptionalCustomModifiers"><span data-ttu-id="6292e-492">由类型数组组成的数组。</span><span class="sxs-lookup"><span data-stu-id="6292e-492">An array of arrays of types.</span></span> <span data-ttu-id="6292e-493">每个类型数组均表示相应参数的可选自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-493">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="6292e-494">如果某个特定参数没有可选的自定义修饰符，则指定 <see langword="null" />，而不要指定类型数组。</span><span class="sxs-lookup"><span data-stu-id="6292e-494">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="6292e-495">如果所有参数都没有可选的自定义修饰符，则指定 <see langword="null" />，而不要指定由数组组成的数组。</span><span class="sxs-lookup"><span data-stu-id="6292e-495">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <summary><span data-ttu-id="6292e-496">设置方法签名，包括返回类型、参数类型以及返回类型和参数类型所需和可选的自定义修饰符。</span><span class="sxs-lookup"><span data-stu-id="6292e-496">Sets the method signature, including the return type, the parameter types, and the required and optional custom modifiers of the return type and parameter types.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-497">如果在定义方法时知道返回类型和参数的数目，则可以使用 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> 接受参数类型数组的方法的任何重载来建立它们。</span><span class="sxs-lookup"><span data-stu-id="6292e-497">If the return type and the number and types of the parameters are known when the method is defined, they can be established using any overload of the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> method that accepts an array of parameter types.</span></span> <span data-ttu-id="6292e-498">但是，泛型方法可以具有其类型由一个或多个其自己的泛型类型参数指定的参数，在定义该方法之后，才能定义这些参数。</span><span class="sxs-lookup"><span data-stu-id="6292e-498">However, a generic method can have parameters whose types are specified by one or more of its own generic type parameters, which cannot be defined until after the method has been defined.</span></span> <span data-ttu-id="6292e-499">在这种情况下，使用此方法设置参数类型。</span><span class="sxs-lookup"><span data-stu-id="6292e-499">Use this method to set the parameter types in that case.</span></span>  
  
 <span data-ttu-id="6292e-500">如果返回类型和参数类型都没有可选的或必需的自定义修饰符（例如 <xref:Microsoft.VisualC.IsConstModifier> ），则可以使用 <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> 和 <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="6292e-500">If neither the return type nor the parameter types have optional or required custom modifiers, such as <xref:Microsoft.VisualC.IsConstModifier>, you can use the <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> and <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> methods.</span></span>  
  
 <span data-ttu-id="6292e-501">调用此方法将替换使用方法建立的参数和返回类型 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-501">Calling this method replaces the parameters and return type established using the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6292e-502">下面的代码示例包含一个名为 Sample 的泛型类的源代码，该类具有一个类型参数 `T` 。</span><span class="sxs-lookup"><span data-stu-id="6292e-502">The following code example contains source code for a generic class named Sample that has a type parameter `T`.</span></span> <span data-ttu-id="6292e-503">类具有一个名为 `Field` 、类型为的字段 `T` 和一个 `GM` 具有自己的类型参数的泛型方法 `U` 。</span><span class="sxs-lookup"><span data-stu-id="6292e-503">The class has a field named `Field`, of type `T`, and a generic method `GM` with its own type parameter, `U`.</span></span> <span data-ttu-id="6292e-504">方法 `GM` 创建一个示例实例，并将其自己的类型参数替换 `U` 为 sample 的类型参数，并在中存储其输入参数 `Field` 。</span><span class="sxs-lookup"><span data-stu-id="6292e-504">Method `GM` creates an instance of Sample, substituting its own type parameter `U` for the type parameter of Sample, and stores its input parameter in `Field`.</span></span> <span data-ttu-id="6292e-505">已编译但未使用此源代码;你可以使用 [Ildasm.exe (IL 拆装器) ](/dotnet/framework/tools/ildasm-exe-il-disassembler)查看它，并将其与类发出的代码进行比较 `Example` 。</span><span class="sxs-lookup"><span data-stu-id="6292e-505">This source code is compiled but not used; you can view it with the [Ildasm.exe (IL Disassembler)](/dotnet/framework/tools/ildasm-exe-il-disassembler), and compare it to the code emitted by class `Example`.</span></span>  
  
 <span data-ttu-id="6292e-506">类中的代码 `Example` 演示如何 <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A> 在发出泛型代码时使用方法。</span><span class="sxs-lookup"><span data-stu-id="6292e-506">The code in class `Example` demonstrates the use of the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A> method in emitting generic code.</span></span> <span data-ttu-id="6292e-507">`Main`类的方法 `Example` 创建一个动态程序集，其中包含一个名为的类 `Sample` ，并使用 <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> 方法通过添加一个名为的类型参数使其成为泛型 `T` 。</span><span class="sxs-lookup"><span data-stu-id="6292e-507">The `Main` method of class `Example` creates a dynamic assembly containing a class named `Sample`, and uses the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method to make it generic by adding a type parameter named `T`.</span></span> <span data-ttu-id="6292e-508">向类添加了一个无参数的构造函数和一个名为 `Field` 的类型为的字段 `T` `Sample` 。</span><span class="sxs-lookup"><span data-stu-id="6292e-508">A parameterless constructor and a field named `Field`, of type `T`, are added to class `Sample`.</span></span> <span data-ttu-id="6292e-509">添加方法 `GM` ，并使用方法将其转换为泛型方法 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-509">A method `GM` is added, and turned into a generic method using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method.</span></span> <span data-ttu-id="6292e-510">的类型参数 `GM` 命名为 `U` 。</span><span class="sxs-lookup"><span data-stu-id="6292e-510">The type parameter of `GM` is named `U`.</span></span> <span data-ttu-id="6292e-511">定义类型参数后， `GM` 将使用方法添加的签名 <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A> 。</span><span class="sxs-lookup"><span data-stu-id="6292e-511">Once the type parameter is defined, the signature of `GM` is added, using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A> method.</span></span> <span data-ttu-id="6292e-512">没有返回类型，并且没有必需的修饰符或自定义修饰符，因此，此方法的所有参数都是 `null` 除外，这将 `parameterTypes` 设置方法的唯一参数的类型; 此参数设置为方法的类型参数 `U` 。</span><span class="sxs-lookup"><span data-stu-id="6292e-512">There is no return type, and no required or custom modifiers, so all the parameters of this method are `null` except `parameterTypes`, which sets the type of the only parameter of the method; this is set to the method's type parameter, `U`.</span></span> <span data-ttu-id="6292e-513">方法的主体 `Sample<U>` 在 Visual Basic) 中创建构造类型 (实例 `Sample(Of U)` ，并将该方法的参数分配给 `Field` ，然后输出的值 `Field` 。</span><span class="sxs-lookup"><span data-stu-id="6292e-513">The body of the method creates an instance of the constructed type `Sample<U>` (`Sample(Of U)` in Visual Basic), assigns the method's parameter to `Field`, and then prints the value of `Field`.</span></span> <span data-ttu-id="6292e-514">定义了一个虚类型以容纳入口点方法 `Main` 。</span><span class="sxs-lookup"><span data-stu-id="6292e-514">A dummy type is defined, to hold the entry point method `Main`.</span></span> <span data-ttu-id="6292e-515">在的正文中 `Main` ，将在 `GM` Visual Basic) 中构造的泛型类型 (调用静态方法 `Sample<int>` `Sample(Of Integer)` ，并将类型 <xref:System.String> 替换为 `U` 。</span><span class="sxs-lookup"><span data-stu-id="6292e-515">In the body of `Main`, the static `GM` method is invoked on the constructed generic type `Sample<int>` (`Sample(Of Integer)` in Visual Basic), with type <xref:System.String> substituted for `U`.</span></span> <span data-ttu-id="6292e-516"><xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A?displayProperty=nameWithType>方法用于为 <xref:System.Reflection.MethodInfo> 构造的泛型类型的静态 `GM` 方法创建 `Sample<U>` ， <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> 然后使用方法来创建 <xref:System.Reflection.MethodInfo> 可以在方法调用中发出的。</span><span class="sxs-lookup"><span data-stu-id="6292e-516">The <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A?displayProperty=nameWithType> method is used to create a <xref:System.Reflection.MethodInfo> for the static `GM` method of the constructed generic type `Sample<U>`, and the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> method is then used to create a <xref:System.Reflection.MethodInfo> that can emitted in a method call.</span></span>  
  
 <span data-ttu-id="6292e-517">运行代码示例时，它会将发出的程序集保存为 TypeBuilderGetFieldExample.exe。</span><span class="sxs-lookup"><span data-stu-id="6292e-517">When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</span></span> <span data-ttu-id="6292e-518">您可以 TypeBuilderGetFieldExample.exe 运行，并且可以使用 [Ildasm.exe (IL 拆装器) ](/dotnet/framework/tools/ildasm-exe-il-disassembler) 将发出的代码与 `Sample` 编译到代码示例本身中的类的代码进行比较。</span><span class="sxs-lookup"><span data-stu-id="6292e-518">You can run TypeBuilderGetFieldExample.exe, and you can use the [Ildasm.exe (IL Disassembler)](/dotnet/framework/tools/ildasm-exe-il-disassembler) to compare the emitted code with the code for the `Sample` class that is compiled into the code example itself.</span></span>  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6292e-519">当前方法是泛型方法，但不是泛型方法定义。</span><span class="sxs-lookup"><span data-stu-id="6292e-519">The current method is generic, but is not a generic method definition.</span></span> <span data-ttu-id="6292e-520">也就是说，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-520">That is, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span></span></exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)" />
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="SetSymCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetSymCustomAttribute (string name, byte[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSymCustomAttribute(string name, unsigned int8[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSymCustomAttribute (name As String, data As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSymCustomAttribute(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data);" />
      <MemberSignature Language="F#" Value="member this.SetSymCustomAttribute : string * byte[] -&gt; unit" Usage="methodBuilder.SetSymCustomAttribute (name, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="data" Type="System.Byte[]" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="6292e-521">符号自定义属性的名称。</span><span class="sxs-lookup"><span data-stu-id="6292e-521">The name of the symbolic custom attribute.</span></span></param>
        <param name="data"><span data-ttu-id="6292e-522">表示符号自定义属性的值的字节 blob。</span><span class="sxs-lookup"><span data-stu-id="6292e-522">The byte blob that represents the value of the symbolic custom attribute.</span></span></param>
        <summary><span data-ttu-id="6292e-523">使用 blob 设置符号自定义属性。</span><span class="sxs-lookup"><span data-stu-id="6292e-523">Set a symbolic custom attribute using a blob.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-524">与元数据自定义特性不同，此自定义特性与符号编写器相关联。</span><span class="sxs-lookup"><span data-stu-id="6292e-524">Unlike the metadata custom attribute, this custom attribute is associated with a symbol writer.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6292e-525">下面的代码示例演示了方法的上下文用法 `SetSymCustomAttribute` ，以设置附加到方法的自定义特性的名称和键的字节值。</span><span class="sxs-lookup"><span data-stu-id="6292e-525">The code sample below illustrates the contextual usage of the `SetSymCustomAttribute` method to set the byte values for the name and key of a custom attribute attached to a method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example/CPP/source2.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example/CS/source2.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6292e-526">该包含类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</span><span class="sxs-lookup"><span data-stu-id="6292e-526">The containing type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="6292e-527">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6292e-527">-or-</span></span> 
<span data-ttu-id="6292e-528">包含此方法的模块不是调试模块。</span><span class="sxs-lookup"><span data-stu-id="6292e-528">The module that contains this method is not a debug module.</span></span>  
  
<span data-ttu-id="6292e-529">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6292e-529">-or-</span></span> 
<span data-ttu-id="6292e-530">对于当前的方法，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6292e-530">For the current method, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Signature">
      <MemberSignature Language="C#" Value="public string Signature { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Signature" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Signature" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Signature As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Signature { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Signature : string" Usage="System.Reflection.Emit.MethodBuilder.Signature" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6292e-531">检索方法的签名。</span><span class="sxs-lookup"><span data-stu-id="6292e-531">Retrieves the signature of the method.</span></span></summary>
        <value><span data-ttu-id="6292e-532">只读。</span><span class="sxs-lookup"><span data-stu-id="6292e-532">Read-only.</span></span> <span data-ttu-id="6292e-533">包含此 <see langword="MethodBase" /> 实例反射的方法的签名的字符串。</span><span class="sxs-lookup"><span data-stu-id="6292e-533">A String containing the signature of the method reflected by this <see langword="MethodBase" /> instance.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _MethodBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _MethodBuilder.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_MethodBuilder::GetIDsOfNames;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames : Guid * nativeint * uint32 * uint32 * nativeint -&gt; unit&#xA;override this.System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames : Guid * nativeint * uint32 * uint32 * nativeint -&gt; unit" Usage="methodBuilder.System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames (riid, rgszNames, cNames, lcid, rgDispId)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="6292e-534">留待将来使用。</span><span class="sxs-lookup"><span data-stu-id="6292e-534">Reserved for future use.</span></span> <span data-ttu-id="6292e-535">必须为 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="6292e-535">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="6292e-536">要映射的名称的传入数组。</span><span class="sxs-lookup"><span data-stu-id="6292e-536">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="6292e-537">要映射的名称的计数。</span><span class="sxs-lookup"><span data-stu-id="6292e-537">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="6292e-538">要在其中解释名称的区域设置上下文。</span><span class="sxs-lookup"><span data-stu-id="6292e-538">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="6292e-539">调用方分配的数组，用于接收与名称对应的 ID。</span><span class="sxs-lookup"><span data-stu-id="6292e-539">Caller-allocated array that receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="6292e-540">将一组名称映射为对应的一组调度标识符。</span><span class="sxs-lookup"><span data-stu-id="6292e-540">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-541">此方法用于从非托管代码访问托管类，不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="6292e-541">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="6292e-542">有关详细信息，请参阅 [IDispatch：： idispatch.getidsofnames](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames)。</span><span class="sxs-lookup"><span data-stu-id="6292e-542">For more information, see [IDispatch::GetIDsOfNames](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames).</span></span>
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="6292e-543">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="6292e-543">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _MethodBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _MethodBuilder.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_MethodBuilder::GetTypeInfo;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.InteropServices._MethodBuilder.GetTypeInfo : uint32 * uint32 * nativeint -&gt; unit&#xA;override this.System.Runtime.InteropServices._MethodBuilder.GetTypeInfo : uint32 * uint32 * nativeint -&gt; unit" Usage="methodBuilder.System.Runtime.InteropServices._MethodBuilder.GetTypeInfo (iTInfo, lcid, ppTInfo)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="6292e-544">要返回的类型信息。</span><span class="sxs-lookup"><span data-stu-id="6292e-544">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="6292e-545">类型信息的区域设置标识符。</span><span class="sxs-lookup"><span data-stu-id="6292e-545">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="6292e-546">接收一个指针，指向请求的类型信息对象。</span><span class="sxs-lookup"><span data-stu-id="6292e-546">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="6292e-547">检索对象的类型信息，然后可以使用该信息获取接口的类型信息。</span><span class="sxs-lookup"><span data-stu-id="6292e-547">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-548">此方法用于从非托管代码访问托管类，不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="6292e-548">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="6292e-549">有关详细信息，请参阅 [IDispatch：： GetTypeInfo](/windows/win32/api/oaidl/nf-oaidl-idispatch-gettypeinfo)。</span><span class="sxs-lookup"><span data-stu-id="6292e-549">For more information, see [IDispatch::GetTypeInfo](/windows/win32/api/oaidl/nf-oaidl-idispatch-gettypeinfo).</span></span>
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="6292e-550">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="6292e-550">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _MethodBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _MethodBuilder.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_MethodBuilder::GetTypeInfoCount;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount : uint32 -&gt; unit&#xA;override this.System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount : uint32 -&gt; unit" Usage="methodBuilder.System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount pcTInfo" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="6292e-551">指向一个位置，该位置接收对象提供的类型信息接口的数量。</span><span class="sxs-lookup"><span data-stu-id="6292e-551">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="6292e-552">检索对象提供的类型信息接口的数量（0 或 1）。</span><span class="sxs-lookup"><span data-stu-id="6292e-552">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-553">此方法用于从非托管代码访问托管类，不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="6292e-553">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="6292e-554">有关详细信息，请参阅 [IDispatch：： GetTypeInfoCount](/windows/win32/api/oaidl/nf-oaidl-idispatch-gettypeinfocount)。</span><span class="sxs-lookup"><span data-stu-id="6292e-554">For more information, see [IDispatch::GetTypeInfoCount](/windows/win32/api/oaidl/nf-oaidl-idispatch-gettypeinfocount).</span></span>
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="6292e-555">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="6292e-555">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _MethodBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _MethodBuilder.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_MethodBuilder::Invoke;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.InteropServices._MethodBuilder.Invoke : uint32 * Guid * uint32 * int16 * nativeint * nativeint * nativeint * nativeint -&gt; unit&#xA;override this.System.Runtime.InteropServices._MethodBuilder.Invoke : uint32 * Guid * uint32 * int16 * nativeint * nativeint * nativeint * nativeint -&gt; unit" Usage="methodBuilder.System.Runtime.InteropServices._MethodBuilder.Invoke (dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="6292e-556">标识成员。</span><span class="sxs-lookup"><span data-stu-id="6292e-556">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="6292e-557">留待将来使用。</span><span class="sxs-lookup"><span data-stu-id="6292e-557">Reserved for future use.</span></span> <span data-ttu-id="6292e-558">必须为 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="6292e-558">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="6292e-559">要在其中解释自变量的区域设置上下文。</span><span class="sxs-lookup"><span data-stu-id="6292e-559">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="6292e-560">描述调用的上下文的标志。</span><span class="sxs-lookup"><span data-stu-id="6292e-560">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="6292e-561">指向一个结构的指针，该结构包含一个参数数组、一个命名参数的 DispID 参数数组和数组中元素数的计数。</span><span class="sxs-lookup"><span data-stu-id="6292e-561">Pointer to a structure containing an array of arguments, an array of argument DispIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="6292e-562">指向要存储结果的位置的指针。</span><span class="sxs-lookup"><span data-stu-id="6292e-562">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="6292e-563">指向一个包含异常信息的结构的指针。</span><span class="sxs-lookup"><span data-stu-id="6292e-563">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="6292e-564">第一个出错参数的索引。</span><span class="sxs-lookup"><span data-stu-id="6292e-564">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="6292e-565">提供对某一对象公开的属性和方法的访问。</span><span class="sxs-lookup"><span data-stu-id="6292e-565">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6292e-566">此方法用于从非托管代码访问托管类，不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="6292e-566">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="6292e-567">有关详细信息，请参阅 [IDispatch：： Invoke](/windows/win32/api/oaidl/nf-oaidl-idispatch-invoke)。</span><span class="sxs-lookup"><span data-stu-id="6292e-567">For more information, see [IDispatch::Invoke](/windows/win32/api/oaidl/nf-oaidl-idispatch-invoke).</span></span>
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="6292e-568">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="6292e-568">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="methodBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6292e-569">将此 <see langword="MethodBuilder" /> 实例作为字符串返回。</span><span class="sxs-lookup"><span data-stu-id="6292e-569">Returns this <see langword="MethodBuilder" /> instance as a string.</span></span></summary>
        <returns><span data-ttu-id="6292e-570">返回一个字符串，此字符串包含名称、 属性、 方法签名、 异常和此方法的本地签名，并且末尾处为当前的 Microsoft 中间语言 (MSIL) 流。</span><span class="sxs-lookup"><span data-stu-id="6292e-570">Returns a string containing the name, attributes, method signature, exceptions, and local signature of this method followed by the current Microsoft intermediate language (MSIL) stream.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
