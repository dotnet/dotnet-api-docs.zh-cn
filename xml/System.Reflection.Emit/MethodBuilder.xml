<Type Name="MethodBuilder" FullName="System.Reflection.Emit.MethodBuilder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2cbc561b95aa1977c61851adc8b1bf8ebd13eac2" /><Meta Name="ms.sourcegitcommit" Value="c982ad9e10a242d90f1e631b5981570f9e5d9f34" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/10/2020" /><Meta Name="ms.locfileid" Value="89757845" /></Metadata><TypeSignature Language="C#" Value="public sealed class MethodBuilder : System.Reflection.MethodInfo" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit MethodBuilder extends System.Reflection.MethodInfo" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.MethodBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class MethodBuilder&#xA;Inherits MethodInfo" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodBuilder sealed : System::Reflection::MethodInfo" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
  <TypeSignature Language="F#" Value="type MethodBuilder = class&#xA;    inherit MethodInfo" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1;xamarinios-10.8" />
  <TypeSignature Language="C#" Value="public sealed class MethodBuilder : System.Reflection.MethodInfo, System.Runtime.InteropServices._MethodBuilder" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit MethodBuilder extends System.Reflection.MethodInfo implements class System.Runtime.InteropServices._MethodBuilder" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class MethodBuilder&#xA;Inherits MethodInfo&#xA;Implements _MethodBuilder" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodBuilder sealed : System::Reflection::MethodInfo, System::Runtime::InteropServices::_MethodBuilder" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type MethodBuilder = class&#xA;    inherit MethodInfo&#xA;    interface _MethodBuilder" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit MethodBuilder extends System.Reflection.MethodInfo implements class System.Runtime.InteropServices._MethodBuilder" FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0" />
  <TypeSignature Language="C#" Value="public abstract class MethodBuilder : System.Reflection.MethodInfo" FrameworkAlternate="xamarinios-10.8" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit MethodBuilder extends System.Reflection.MethodInfo" FrameworkAlternate="xamarinios-10.8" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MethodBuilder&#xA;Inherits MethodInfo" FrameworkAlternate="xamarinios-10.8" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodBuilder abstract : System::Reflection::MethodInfo" FrameworkAlternate="xamarinios-10.8" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Reflection.Emit" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Reflection.MethodInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0">
      <InterfaceName>System.Runtime.InteropServices._MethodBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodBuilder))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodBuilder))&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>定义并表示动态类上的方法（或构造函数）。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.MethodBuilder>类用于以 Microsoft 中间语言 (MSIL) （包括名称、特性、签名和方法正文）完全描述方法。 它与类结合使用 <xref:System.Reflection.Emit.TypeBuilder> ，以便在运行时创建类。  
  
## <a name="global-methods-and-methods-as-type-members"></a>作为类型成员的全局方法和方法  
 可以使用反射发出来定义全局方法，并将方法定义为类型成员。 定义方法的 Api 返回 <xref:System.Reflection.Emit.MethodBuilder> 对象。  
  
### <a name="global-methods"></a>全局方法  
 全局方法是使用方法定义的 <xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A?displayProperty=nameWithType> ，该方法返回 **MethodBuilder** 对象。  
  
 全局方法必须是静态的。 如果动态模块包含全局方法，则在 <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A?displayProperty=nameWithType> 持久化动态模块或包含动态程序集之前，必须先调用方法，因为公共语言运行时推迟了在定义所有全局函数之前修复动态模块。  
  
 全局本机方法是使用方法定义的 <xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A?displayProperty=nameWithType> 。 平台调用 (PInvoke) 方法不能声明为 abstract 或 virtual。 运行时设置 <xref:System.Reflection.MethodAttributes.PinvokeImpl?displayProperty=nameWithType> 平台调用方法的属性。  
  
### <a name="methods-as-members-of-types"></a>作为类型成员的方法  
 方法通过使用 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> 方法（该方法返回对象）定义为类型成员 <xref:System.Reflection.Emit.MethodBuilder> 。  
  
 <xref:System.Reflection.Emit.MethodBuilder.DefineParameter%2A>方法用于设置参数的名称和参数属性，或返回值的属性。 <xref:System.Reflection.Emit.ParameterBuilder>此方法返回的对象表示参数或返回值。 <xref:System.Reflection.Emit.ParameterBuilder>对象可用于设置封送处理、设置常数值和应用自定义属性。  
  
## <a name="attributes"></a>属性  
 枚举的成员 <xref:System.Reflection.MethodAttributes> 定义动态方法的精确字符：  
  
-   静态方法是使用属性指定的 <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType> 。  
  
-   不能重写的最终方法 (使用特性指定的) <xref:System.Reflection.MethodAttributes.Final?displayProperty=nameWithType> 。  
  
-   使用特性指定虚方法 <xref:System.Reflection.MethodAttributes.Virtual?displayProperty=nameWithType> 。  
  
-   使用特性指定抽象方法 <xref:System.Reflection.MethodAttributes.Abstract?displayProperty=nameWithType> 。  
  
-   若干特性确定方法可见性。 请参阅枚举的说明 <xref:System.Reflection.MethodAttributes> 。  
  
-   实现重载运算符的方法必须设置 <xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType> 特性。  
  
-   终结器必须设置 <xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType> 特性。  
  
## <a name="known-issues"></a>已知问题  
  
-   尽管 <xref:System.Reflection.Emit.MethodBuilder> 派生自，但在 <xref:System.Reflection.MethodInfo> <xref:System.Reflection.MethodInfo> 中未完全实现类中定义的某些抽象方法 <xref:System.Reflection.Emit.MethodBuilder> 。 这些 <xref:System.Reflection.Emit.MethodBuilder> 方法会引发 <xref:System.NotSupportedException> 。 例如， <xref:System.Reflection.Emit.MethodBuilder.Invoke%2A?displayProperty=nameWithType> 方法未完全实现。 您可以通过使用或方法检索封闭类型来反映这些方法 <xref:System.Type.GetType%2A?displayProperty=nameWithType> <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 。  
  
-   从 .NET Framework 版本2.0 开始支持自定义修饰符。 它们在早期版本中不受支持。  
  
   
  
## Examples  
 下面的示例使用 <xref:System.Reflection.Emit.MethodBuilder> 类在动态类型中创建方法。  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MethodBuilder ();" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.#ctor" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MethodBuilder();" FrameworkAlternate="xamarinios-10.8" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddDeclarativeSecurity">
      <MemberSignature Language="C#" Value="public void AddDeclarativeSecurity (System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDeclarativeSecurity(valuetype System.Security.Permissions.SecurityAction action, class System.Security.PermissionSet pset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDeclarativeSecurity (action As SecurityAction, pset As PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDeclarativeSecurity(System::Security::Permissions::SecurityAction action, System::Security::PermissionSet ^ pset);" />
      <MemberSignature Language="F#" Value="member this.AddDeclarativeSecurity : System.Security.Permissions.SecurityAction * System.Security.PermissionSet -&gt; unit" Usage="methodBuilder.AddDeclarativeSecurity (action, pset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Security.Permissions.SecurityAction" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pset" Type="System.Security.PermissionSet" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action">要执行的安全操作（Demand、Assert 等等）。</param>
        <param name="pset">应用此操作的权限集。</param>
        <summary>向此方法添加声明性安全。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A> 可以多次调用，每次调用指定安全操作 (如 `Demand` 、 `Assert` 和 `Deny`) 以及操作应用到的权限集。  
  
> [!NOTE]
>  在 .NET Framework 版本1.0、1.1 和2.0 中，通过使用方法应用到方法的声明性安全特性 <xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A> 以旧 XML 元数据格式存储。 请参阅发出声明性安全特性。  
  
   
  
## Examples  
 下面的代码示例演示了的上下文用法，它 `AddDeclarativeSecurity` 要求方法的调用方具有不受限制的权限。  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="action" /> 无效（<see langword="RequestMinimum" />、<see langword="RequestOptional" /> 和 <see langword="RequestRefuse" /> 无效）。</exception>
        <exception cref="T:System.InvalidOperationException">已使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建包含类型。  
  
- 或 - 
权限集 <paramref name="pset" /> 包含之前由 <see cref="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" /> 添加的操作。  
  
- 或 - 
对于当前的方法，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pset" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.MethodAttributes" Usage="System.Reflection.Emit.MethodBuilder.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>检索此方法的属性。</summary>
        <value>只读。 检索此方法的 <see langword="MethodAttributes" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public override System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberSignature Language="F#" Value="member this.CallingConvention : System.Reflection.CallingConventions" Usage="System.Reflection.Emit.MethodBuilder.CallingConvention" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>返回此方法的调用约定。</summary>
        <value>只读。 方法的调用约定。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public override bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Reflection.Emit.MethodBuilder.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>不支持此类型。</summary>
        <value>不支持。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.MethodBuilder>始终表示泛型方法定义，因此无法调用。  
  
 有关详细信息，请参阅 <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> 和 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType>。 有关泛型类型的信息，请参阅 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="CreateMethodBody">
      <MemberSignature Language="C#" Value="public void CreateMethodBody (byte[] il, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateMethodBody(unsigned int8[] il, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateMethodBody (il As Byte(), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateMethodBody(cli::array &lt;System::Byte&gt; ^ il, int count);" />
      <MemberSignature Language="F#" Value="member this.CreateMethodBody : byte[] * int -&gt; unit" Usage="methodBuilder.CreateMethodBody (il, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="il" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="il">包含有效的 MSIL 指令的数组。 如果此参数为 <see langword="null" />，则清除方法的主体。</param>
        <param name="count">MSIL 数组中的有效字节数。 如果 MSIL 为 <see langword="null" />，则忽略此值。</param>
        <summary>使用 Microsoft 中间语言 (MSIL) 指令提供的字节数组的创建方法的主体。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法从创建方法的主体 `il` ，其中包含作为操作码的 MSIL 指令的数组。 有效 MSIL 的字节数由 count 提供。  
  
> [!NOTE]
>  目前不完全支持这种情况。 用户无法提供令牌修补程序和异常处理程序的位置。  
  
   
  
## Examples  
 在下面提供的示例中，添加两个整数的简单方法是通过 opcode 使用生成的 `CreateMethodBody` 。  
  
 [!code-cpp[System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Refelction.Emit.MethodBuilder.CreateMethodBody Example/CPP/source.cpp#1)]
 [!code-csharp[System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Refelction.Emit.MethodBuilder.CreateMethodBody Example/CS/source.cs#1)]
 [!code-vb[System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Refelction.Emit.MethodBuilder.CreateMethodBody Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 不在提供的 MSIL 指令数组的索引范围内，且 <paramref name="il" /> 不是 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">该包含类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。  
  
- 或 - 
以前在包含不是 <see langword="null" /> 的 <paramref name="il" /> 参数的此 <see langword="MethodBuilder" /> 上调用了此方法。  
  
- 或 - 
对于当前的方法，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type? DeclaringType { get; }" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Reflection.Emit.MethodBuilder.DeclaringType" />
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>返回声明此方法的类型。</summary>
        <value>只读。 声明此方法的类型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码演示属性的用法 `Type` 。  
  
 [!code-cpp[MethodBuilderClass_TypeSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBuilderClass_TypeSample/CPP/methodbuilderclass.cpp#1)]
 [!code-csharp[MethodBuilderClass_TypeSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBuilderClass_TypeSample/CS/methodbuilderclass.cs#1)]
 [!code-vb[MethodBuilderClass_TypeSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBuilderClass_TypeSample/VB/methodbuilderclass.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineGenericParameters">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (params string[] names);" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters(string[] names) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGenericParameters (ParamArray names As String()) As GenericTypeParameterBuilder()" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Emit::GenericTypeParameterBuilder ^&gt; ^ DefineGenericParameters(... cli::array &lt;System::String ^&gt; ^ names);" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.DefineGenericParameters : string[] -&gt; System.Reflection.Emit.GenericTypeParameterBuilder[]" Usage="methodBuilder.DefineGenericParameters names" />
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (string[] names);" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGenericParameters (names As String()) As GenericTypeParameterBuilder()" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Emit::GenericTypeParameterBuilder ^&gt; ^ DefineGenericParameters(cli::array &lt;System::String ^&gt; ^ names);" FrameworkAlternate="xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.GenericTypeParameterBuilder[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="names" Type="System.String[]" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="names">一个字符串数组，表示泛型类型参数的名称。</param>
        <summary>设置当前方法的泛型类型参数的数目，指定其名称并返回一个可用于定义其约束的 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 对象的数组。</summary>
        <returns>一个 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 对象数组，表示泛型方法的类型参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 方法会使当前方法成为泛型方法。 无法撤消此更改。 第二次调用此方法会导致 <xref:System.InvalidOperationException> 。  
  
 以后可以使用方法检索泛型方法的类型参数 <xref:System.Reflection.Emit.MethodBuilder.GetGenericArguments%2A> 。  
  
 按照约定，类型参数名称是单个大写字母。  
  
 有关详细信息，请参阅 <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> 和 <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType>。 有关泛型类型的信息，请参阅 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> 。  
  
   
  
## Examples  
 下面的代码示例创建动态类型， `DemoType` 它包含动态泛型方法 `DemoMethod` 。 此方法具有两个泛型类型参数，其中一个参数用作参数，另一个用作返回类型。  
  
 执行代码时，该动态程序集会另存为 DemoGenericMethod1.dll，使用 [Ildasm.exe（IL 反汇编程序）](/dotnet/framework/tools/ildasm-exe-il-disassembler) 可以对其进行检查。  
  
> [!NOTE]
>  此代码示例将生成一个简单的方法体，只返回空引用。 有关使用更全面开发的方法体创建和使用泛型类型的代码示例，请参阅 [如何：使用反射发出定义泛型方法](/dotnet/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit)。  
  
 [!code-cpp[GenericMethodBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#1)]
 [!code-csharp[GenericMethodBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#1)]
 [!code-vb[GenericMethodBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已为此方法定义了泛型类型参数。  
  
- 或 - 
已完成该方法。  
  
- 或 - 
已为当前方法调用了 <see cref="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" /> 方法。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="names" /> 为 <see langword="null" />。  
  
- 或 - 
<paramref name="names" /> 的元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="names" /> 是一个空数组。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.DefineMethod" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit">如何：用反射发出定义泛型方法</related>
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string? strParamName);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ParameterBuilder DefineParameter(int32 position, valuetype System.Reflection.ParameterAttributes attributes, string strParamName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineParameter (position As Integer, attributes As ParameterAttributes, strParamName As String) As ParameterBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ParameterBuilder ^ DefineParameter(int position, System::Reflection::ParameterAttributes attributes, System::String ^ strParamName);" />
      <MemberSignature Language="F#" Value="member this.DefineParameter : int * System.Reflection.ParameterAttributes * string -&gt; System.Reflection.Emit.ParameterBuilder" Usage="methodBuilder.DefineParameter (position, attributes, strParamName)" />
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string strParamName);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" />
        <Parameter Name="strParamName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="position">参数在参数列表中的位置。 通过第一个参数以数字 1 开头对参数编制索引；数字 0 表示方法的返回值。</param>
        <param name="attributes">参数的参数属性。</param>
        <param name="strParamName">参数的名称。 名称可以是空字符串。</param>
        <summary>设置参数属性和此方法的参数名称或此方法的返回值的名称。 返回可用于应用自定义属性的 ParameterBuilder。</summary>
        <returns>返回 <see langword="ParameterBuilder" /> 对象，该对象表示此方法的参数或此方法的返回值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.ParameterBuilder>此方法返回的对象可用于设置参数的默认值或应用自定义属性。  
  
 参数编号从1开始，因此 `position` 第一个参数的编号为1。 如果 `position` 为零，则此方法会影响返回值。  
  
> [!NOTE]
>  在 .NET Framework 版本1.0 和1.1 中，如果为零，则会引发异常 `position` ，因此此方法不能用于修改这些版本中的返回值的属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">此方法没有参数。  
  
- 或 - 
 <paramref name="position" /> 小于零。  
  
- 或 - 
 <paramref name="position" /> 大于此方法的参数数目。</exception>
        <exception cref="T:System.InvalidOperationException">该包含类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。  
  
- 或 - 
对于当前的方法，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="methodBuilder.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">要与此 <see langword="MethodBuilder" /> 实例进行比较的对象。</param>
        <summary>确定给定对象是否等于此实例。</summary>
        <returns>如果 <paramref name="obj" /> 为 <see langword="MethodBuilder" /> 的实例并且等于此对象，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 相等性通过具有相同的名称、属性和签名来确定。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetBaseDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="methodBuilder.GetBaseDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回方法的基实现。</summary>
        <returns>此方法的基实现。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此始终返回当前 `MethodBuilder` 对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回为此方法定义的自定义属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="methodBuilder.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="inherit">指定是否搜索此成员的继承链以查找自定义属性。</param>
        <summary>返回为此方法定义的所有自定义属性。</summary>
        <returns>返回一个对象数组，其中的对象表示此方法的所有自定义属性。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">目前尚不支持此方法。 使用 <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> 检索此方法，并在返回的 <see cref="T:System.Reflection.MethodInfo" /> 上调用 <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="methodBuilder.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="attributeType">自定义属性类型。</param>
        <param name="inherit">指定是否搜索此成员的继承链以查找自定义属性。</param>
        <summary>返回由给定类型标识的自定义属性。</summary>
        <returns>返回一个对象数组，表示此方法的属性属于类型 <paramref name="attributeType" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">目前尚不支持此方法。 使用 <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> 检索此方法，并在返回的 <see cref="T:System.Reflection.MethodInfo" /> 上调用 <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="override this.GetGenericArguments : unit -&gt; Type[]" Usage="methodBuilder.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示此方法的类型参数的 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 对象数组（如果为泛型）。</summary>
        <returns>如果方法是泛型，则为表示此类型参数的 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />，或者如果方法不是泛型，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 泛型方法的类型参数还由用于定义泛型方法的 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 方法返回。  
  
 有关详细信息，请参阅 <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> 和 <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>。 有关泛型类型的信息，请参阅 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> 。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit">如何：用反射发出定义泛型方法</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetGenericMethodDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetGenericMethodDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericMethodDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetGenericMethodDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetGenericMethodDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="methodBuilder.GetGenericMethodDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此方法。</summary>
        <returns><see cref="T:System.Reflection.Emit.MethodBuilder" /> 的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.MethodBuilder>不能用于直接发出构造的泛型方法。 发出的方法是泛型方法定义。  
  
 有关详细信息，请参阅 <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> 和 <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType>。 有关泛型类型的信息，请参阅 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前方法不是泛型方法。 也就是说，<see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 属性将返回 <see langword="false" />。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit">如何：用反射发出定义泛型方法</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="methodBuilder.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取此方法的哈希代码。</summary>
        <returns>此方法的哈希代码。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetILGenerator">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>为此方法返回 <see langword="ILGenerator" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetILGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator () As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator();" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : unit -&gt; System.Reflection.Emit.ILGenerator" Usage="methodBuilder.GetILGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为此方法返回默认 Microsoft 中间语言 (MSIL) 流大小为 64 字节的 <see langword="ILGenerator" />。</summary>
        <returns>为此方法返回 <see langword="ILGenerator" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示方法的上下文用法 `GetILGenerator` ，创建和发出一个动态程序集，该程序集将计算三维空间中两个点的点积。  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">由于其 <see cref="T:System.Reflection.MethodAttributes" /> 或 <see cref="T:System.Reflection.MethodImplAttributes" /> 标志，该方法不应具有主体，例如因为它具有 <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /> 标志。  
  
- 或 - 
此方法是泛型方法，但不是泛型方法定义。 也就是说，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator (int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator(int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator (size As Integer) As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator(int size);" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : int -&gt; System.Reflection.Emit.ILGenerator" Usage="methodBuilder.GetILGenerator size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="size">MSIL 流的大小（以字节为单位）。</param>
        <summary>为此方法返回具有指定的 Microsoft 中间语言 (MSIL) 流大小的 <see langword="ILGenerator" />。</summary>
        <returns>为此方法返回 <see langword="ILGenerator" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示方法的上下文用法 `GetILGenerator` ，创建和发出一个动态程序集，该程序集将计算三维空间中两个点的点积。  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">由于其 <see cref="T:System.Reflection.MethodAttributes" /> 或 <see cref="T:System.Reflection.MethodImplAttributes" /> 标志，该方法不应具有主体，例如因为它具有 <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /> 标志。  
  
- 或 - 
此方法是泛型方法，但不是泛型方法定义。 也就是说，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberSignature Language="F#" Value="override this.GetMethodImplementationFlags : unit -&gt; System.Reflection.MethodImplAttributes" Usage="methodBuilder.GetMethodImplementationFlags " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为此方法返回实现标志。</summary>
        <returns>为此方法返回实现标志。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module GetModule ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Module GetModule() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetModule" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModule () As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Module ^ GetModule();" />
      <MemberSignature Language="F#" Value="member this.GetModule : unit -&gt; System.Reflection.Module" Usage="methodBuilder.GetModule " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回对包含此方法的模块的引用。</summary>
        <returns>返回对包含此方法的模块的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例代码演示了 `GetModule` 如何使用方法来检索有关动态生成的模块的信息。  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/CPP/source3.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/CS/source3.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberSignature Language="F#" Value="override this.GetParameters : unit -&gt; System.Reflection.ParameterInfo[]" Usage="methodBuilder.GetParameters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此方法的参数。</summary>
        <returns>表示此方法的参数的 <see langword="ParameterInfo" /> 对象数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示 `GetParameters` 如何使用来发现有关传递到动态生成的方法的参数的信息。  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.GetParameters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetParameters Example/CPP/source4.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.GetParameters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetParameters Example/CS/source4.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.GetParameters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetParameters Example/VB/source4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">目前尚不支持此方法。 使用 <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> 检索此方法，并在返回的 <see cref="T:System.Reflection.MethodInfo" /> 上调用 <see langword="GetParameters" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetToken ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetToken() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetToken" />
      <MemberSignature Language="VB.NET" Value="Public Function GetToken () As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetToken();" />
      <MemberSignature Language="F#" Value="member this.GetToken : unit -&gt; System.Reflection.Emit.MethodToken" Usage="methodBuilder.GetToken " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示此方法的标记的 <see langword="MethodToken" />。</summary>
        <returns>返回此方法的 <see langword="MethodToken" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InitLocals">
      <MemberSignature Language="C#" Value="public bool InitLocals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InitLocals" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.InitLocals" />
      <MemberSignature Language="VB.NET" Value="Public Property InitLocals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InitLocals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.InitLocals : bool with get, set" Usage="System.Reflection.Emit.MethodBuilder.InitLocals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个布尔值，该值指定此方法中的局部变量是否初始化为零。 此属性的默认值为 <see langword="true" />。</summary>
        <value>如果应将此方法中的局部变量初始化为零，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果将此属性设置为 `true` ，则发出的 MSIL 包括初始化局部变量。 如果将其设置为 `false` ，则不初始化局部变量，并且无法验证所生成的代码。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">对于当前的方法，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。 （获取或设置。）</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object? Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Invoke (obj As Object, invokeAttr As BindingFlags, binder As Binder, parameters As Object(), culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="override this.Invoke : obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="methodBuilder.Invoke (obj, invokeAttr, binder, parameters, culture)" />
      <MemberSignature Language="C#" Value="public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Object[]" Index="3" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="4" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">在其上调用指定方法的对象。 如果方法是静态的，则忽略此参数。</param>
        <param name="invokeAttr">这必须是来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志：<see langword="InvokeMethod" />、<see langword="NonPublic" /> 等等。</param>
        <param name="binder">启用绑定、强制参数类型、调用成员并通过反射检索 MemberInfo 对象的对象。 如果活页夹为 <see langword="null" />，则使用默认活页夹。 如需了解详情，请访问 <see cref="T:System.Reflection.Binder" />。</param>
        <param name="parameters">自变量列表。 此自变量数组在数量、顺序和类型方面与要调用的方法的参数相同。 如果不存在任何参数，则应为 <see langword="null" />。</param>
        <param name="culture">用于控制类型强制的 <see cref="T:System.Globalization.CultureInfo" /> 的实例。 如果这是 NULL，则使用当前线程的 <see cref="T:System.Globalization.CultureInfo" />。 （请注意，例如，这对于将表示 1000 的 <see cref="T:System.String" /> 转换为 <see cref="T:System.Double" /> 值是必需的，因为不同的区域性以不同的方式表示 1000。）</param>
        <summary>动态调用方法，此方法由此实例在给定对象上进行反射，传递指定的参数，并受给定绑定器的约束。</summary>
        <returns>返回包含已调用方法的返回值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果该方法是静态的，则 `obj` 忽略该参数。 对于非静态方法， `obj` 应为继承或声明方法的类的实例，并且必须与此类具有相同的类型。 如果该方法没有参数，则的值 `parameters` 应为 `null` 。 否则，参数数组中元素的数量、类型和顺序应与此实例所反射的方法的参数的数量、类型和顺序相同。  
  
> [!NOTE]
>  对于完全受信任的代码，将忽略访问限制。 也就是说，只要代码完全受信任，就可以使用反射来访问和调用私有构造函数、方法、字段和属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">目前尚不支持此方法。 使用 <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> 检索此方法，并在返回的 <see cref="T:System.Reflection.MethodInfo" /> 上调用 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericMethod">
      <MemberSignature Language="C#" Value="public override bool IsConstructedGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsConstructedGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsConstructedGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericMethod { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericMethod : bool" Usage="System.Reflection.Emit.MethodBuilder.IsConstructedGenericMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="methodBuilder.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="attributeType">自定义属性类型。</param>
        <param name="inherit">指定是否搜索此成员的继承链以查找自定义属性。</param>
        <summary>检查是否定义了指定的自定义属性类型。</summary>
        <returns>如果定义了指定的自定义属性类型，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">目前尚不支持此方法。 使用 <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> 检索此方法，并在返回的 <see cref="T:System.Reflection.MethodInfo" /> 上调用 <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethod">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethod { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethod : bool" Usage="System.Reflection.Emit.MethodBuilder.IsGenericMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示方法是否为泛型方法。</summary>
        <value>如果该方法是泛型方法，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果方法具有类型参数，则该方法为泛型。 可以通过调用 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 方法来添加类型参数，使方法成为泛型方法。 此更改不可逆。  
  
   
  
## Examples  
 下面的代码示例显示方法的状态。 此代码是为方法提供的更大示例的一部分 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 。  
  
 [!code-cpp[GenericMethodBuilder#7](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#7)]
 [!code-csharp[GenericMethodBuilder#7](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#7)]
 [!code-vb[GenericMethodBuilder#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit">如何：用反射发出定义泛型方法</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethodDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethodDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodDefinition : bool" Usage="System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前 <see cref="T:System.Reflection.Emit.MethodBuilder" /> 对象是否表示泛型方法的定义。</summary>
        <value>如果当前 <see cref="T:System.Reflection.Emit.MethodBuilder" /> 对象表示泛型方法的定义，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.MethodBuilder>只能用于创建泛型方法定义; 不能用于直接创建构造的泛型方法。 但是，的子类 <xref:System.Reflection.Emit.MethodBuilder> 可能表示构造的泛型方法。  
  
   
  
## Examples  
 下面的代码示例显示方法的状态。 此代码是为方法提供的更大示例的一部分 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 。  
  
 [!code-cpp[GenericMethodBuilder#7](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#7)]
 [!code-csharp[GenericMethodBuilder#7](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#7)]
 [!code-vb[GenericMethodBuilder#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit">如何：用反射发出定义泛型方法</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.Emit.MethodBuilder.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所有情况下均引发 <see cref="T:System.NotSupportedException" />。</summary>
        <value>在所有情况下均引发 <see cref="T:System.NotSupportedException" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要确定动态程序集中的某个方法是否是安全关键的，请通过调用来完成该类型， <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> <xref:System.Type.GetMethod%2A> 在已完成的类型上调用方法，并获取 <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> 所生成的的属性 <xref:System.Reflection.MethodInfo> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">在所有情况下。 动态程序集中不支持此属性。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所有情况下均引发 <see cref="T:System.NotSupportedException" />。</summary>
        <value>在所有情况下均引发 <see cref="T:System.NotSupportedException" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要确定动态程序集中的方法是否是安全可靠关键的，请通过调用来完成该类型， <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> <xref:System.Type.GetMethod%2A> 在已完成的类型上调用方法，并获取 <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> 所生成的的属性 <xref:System.Reflection.MethodInfo> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">在所有情况下。 动态程序集中不支持此属性。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.Emit.MethodBuilder.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所有情况下均引发 <see cref="T:System.NotSupportedException" />。</summary>
        <value>在所有情况下均引发 <see cref="T:System.NotSupportedException" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要确定动态程序集中的某个方法是否为安全透明的，请通过调用完成该类型， <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> <xref:System.Type.GetMethod%2A> 在已完成的类型上调用方法，并获取 <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> 所生成的的属性 <xref:System.Reflection.MethodInfo> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">在所有情况下。 动态程序集中不支持此属性。</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo MakeGenericMethod (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo MakeGenericMethod(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeGenericMethod (ParamArray typeArguments As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ MakeGenericMethod(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="override this.MakeGenericMethod : Type[] -&gt; System.Reflection.MethodInfo" Usage="methodBuilder.MakeGenericMethod typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">表示泛型方法的类型参数的 <see cref="T:System.Type" /> 对象的数组。</param>
        <summary>返回使用指定泛型类型参数从当前泛型方法定义构造的泛型方法。</summary>
        <returns>一个 <see cref="T:System.Reflection.MethodInfo" />，它表示使用指定泛型类型参数从当前泛型方法定义构造的泛型方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 发出动态代码时，您可能需要在 <xref:System.Reflection.Emit.MethodBuilder> 完成封闭类型之前发出对由表示的泛型方法定义构造的方法的调用。 您可以使用 <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> 方法为 <xref:System.Reflection.MethodInfo> 此类构造方法创建一个，并 <xref:System.Reflection.MethodInfo> 在发出的调用中使用。  
  
   
  
## Examples  
 下面的代码示例通过不完整的类型中的不完整泛型方法定义来创建构造方法。  
  
 该示例创建一个具有单个类型的临时程序集和模块，添加一个方法 `M` ，并通过使用方法添加一个类型参数来使该方法成为泛型方法 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 。 类型参数用作方法的参数类型，也用作其返回类型。 不会为泛型方法定义提供主体，并且不会完成封闭类型。 <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A>然后，使用方法将构造方法 `M<String>` (`M(Of String)` Visual Basic) 中。 示例代码没有输出，因为 <xref:System.Reflection.MethodInfo> 方法返回的子类 <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> 不允许对其参数进行反射。  
  
> [!NOTE]
>  有关使用的其他代码示例 <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> ，请参见 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 。 <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> 发出使用泛型类型的代码时，也会广泛使用。 请参阅 [如何：使用反射发出定义泛型方法](/dotnet/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit)。  
  
 [!code-cpp[MethodBuilder.MakeGenericMethod#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBuilder.MakeGenericMethod/cpp/source.cpp#1)]
 [!code-csharp[MethodBuilder.MakeGenericMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBuilder.MakeGenericMethod/cs/source.cs#1)]
 [!code-vb[MethodBuilder.MakeGenericMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBuilder.MakeGenericMethod/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit">如何：用反射发出定义泛型方法</related>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public override RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodHandle : RuntimeMethodHandle" Usage="System.Reflection.Emit.MethodBuilder.MethodHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>检索此方法的内部句柄。 使用此句柄来访问基础元数据句柄。</summary>
        <value>只读。 方法的内部处理程序。 使用此句柄来访问基础元数据句柄。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">目前尚不支持此方法。 使用 <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> 检索此方法，并在返回的 <see cref="T:System.Reflection.MethodInfo" /> 上调用 <see cref="P:System.Reflection.MethodBase.MethodHandle" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodImplementationFlags : System.Reflection.MethodImplAttributes" Usage="System.Reflection.Emit.MethodBuilder.MethodImplementationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.Emit.MethodBuilder.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在其中定义了当前方法的模块。</summary>
        <value>正在定义其中成员由当前 <see cref="T:System.Reflection.MemberInfo" /> 表示的 <see cref="T:System.Reflection.Module" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此属性是为了方便。 它等效于使用 <xref:System.Reflection.Emit.MethodBuilder.DeclaringType%2A> 属性获取在其中声明该方法的类型，然后调用 <xref:System.Type.Module%2A> 所产生的对象的属性 <xref:System.Type> 。  
  
 此属性也等效于调用 <xref:System.Reflection.Emit.MethodBuilder.GetModule%2A> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.MethodBuilder.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>检索此方法的名称。</summary>
        <value>只读。 检索包含此方法简单名称的字符串。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type? ReflectedType { get; }" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Reflection.Emit.MethodBuilder.ReflectedType" />
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>检索在反射中用于获取此对象的类。</summary>
        <value>只读。 用于获取此方法的类型。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnParameter : System.Reflection.ParameterInfo" Usage="System.Reflection.Emit.MethodBuilder.ReturnParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Reflection.ParameterInfo" /> 对象，该对象包含有关方法的返回类型的信息（例如返回类型是否具有自定义修饰符）。</summary>
        <value>一个 <see cref="T:System.Reflection.ParameterInfo" /> 对象，包含有关返回类型的信息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 编译器设计器可以使用 <xref:System.Reflection.ParameterInfo> 此属性返回的对象来发现自定义修饰符（如 <xref:Microsoft.VisualC.IsConstModifier> ）是否已应用于返回类型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尚未创建声明类型。</exception>
        <altmember cref="M:System.Reflection.ParameterInfo.GetOptionalCustomModifiers" />
        <altmember cref="M:System.Reflection.ParameterInfo.GetRequiredCustomModifiers" />
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public override Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnType : Type" Usage="System.Reflection.Emit.MethodBuilder.ReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此 <see cref="T:System.Reflection.Emit.MethodBuilder" /> 所表示的方法的返回类型。</summary>
        <value>方法的返回类型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从 .NET Framework 2.0 和 .NET Compact Framework 2.0 开始，此成员继承自基类 <xref:System.Reflection.MethodInfo> 。 请参阅 <xref:System.Reflection.MethodInfo.ReturnType%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnTypeCustomAttributes : System.Reflection.ICustomAttributeProvider" Usage="System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>返回此方法的返回类型的自定义属性。</summary>
        <value>只读。 此方法的返回类型的自定义属性。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法始终返回 `null`。 在 <xref:System.Reflection.MethodInfo> <xref:System.Type> 上创建并调用包含的后获取 <xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A> <xref:System.Reflection.MethodInfo> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCustomAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>设置自定义属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (customBuilder As CustomAttributeBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::Emit::CustomAttributeBuilder ^ customBuilder);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.Emit.CustomAttributeBuilder -&gt; unit" Usage="methodBuilder.SetCustomAttribute customBuilder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">用于描述自定义属性的帮助器类的实例。</param>
        <summary>使用自定义属性生成器设置自定义属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 当两个方法结合使用时，方法可以与方法交互。 有关详细信息，请参阅方法的 "备注" 部分 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="customBuilder" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">对于当前的方法，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (con As ConstructorInfo, binaryAttribute As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::ConstructorInfo ^ con, cli::array &lt;System::Byte&gt; ^ binaryAttribute);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.ConstructorInfo * byte[] -&gt; unit" Usage="methodBuilder.SetCustomAttribute (con, binaryAttribute)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">自定义属性的构造函数。</param>
        <param name="binaryAttribute">表示属性的字节 blob。</param>
        <summary>使用指定的自定义属性 blob 设置自定义属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关如何设置格式的详细信息 `binaryAttribute` ，请参阅公共语言基础结构 (CLI) 文档，尤其是 "第二部分：元数据定义和语义"。 可联机获取该文档；请参阅 MSDN 上的 [ECMA C# 和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)和 Ecma International 网站上的[标准 ECMA-335 - 公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)。  
  
 <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 当两个方法结合使用时，方法可以与方法交互。 有关详细信息，请参阅方法的 "备注" 部分 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="con" /> 或 <paramref name="binaryAttribute" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">对于当前的方法，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetImplementationFlags">
      <MemberSignature Language="C#" Value="public void SetImplementationFlags (System.Reflection.MethodImplAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetImplementationFlags(valuetype System.Reflection.MethodImplAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetImplementationFlags (attributes As MethodImplAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetImplementationFlags(System::Reflection::MethodImplAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.SetImplementationFlags : System.Reflection.MethodImplAttributes -&gt; unit" Usage="methodBuilder.SetImplementationFlags attributes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodImplAttributes" />
      </Parameters>
      <Docs>
        <param name="attributes">要设置的实现标志。</param>
        <summary>为此方法设置实现标志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 方法与方法结合使用时 <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> ，请注意潜在的交互。 例如，使用 <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> 方法添加 <xref:System.Runtime.InteropServices.DllImportAttribute> 特性还会设置 <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> 标志。 如果随后调用 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 方法，则 <xref:System.Reflection.MethodImplAttributes.PreserveSig> 会覆盖标志。 可通过两种方式来避免此问题：  
  
-   在 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 调用方法之前调用方法 <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> 。 <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A>方法始终遵循现有方法实现标志。  
  
-   设置实现标志后，调用 <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A> 方法以检索现有标志，使用按位或添加标志，然后调用 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 方法。  
  
   
  
## Examples  
 下面的代码示例演示了 `SetImplementationFlags` 如何在方法体中描述 MSIL 实现的方法的上下文用法。  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetImplementationFlags Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetImplementationFlags Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetImplementationFlags Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">该包含类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。  
  
- 或 - 
对于当前的方法，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetMarshal">
      <MemberSignature Language="C#" Value="public void SetMarshal (System.Reflection.Emit.UnmanagedMarshal unmanagedMarshal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMarshal(class System.Reflection.Emit.UnmanagedMarshal unmanagedMarshal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetMarshal (unmanagedMarshal As UnmanagedMarshal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetMarshal(System::Reflection::Emit::UnmanagedMarshal ^ unmanagedMarshal);" />
      <MemberSignature Language="F#" Value="member this.SetMarshal : System.Reflection.Emit.UnmanagedMarshal -&gt; unit" Usage="methodBuilder.SetMarshal unmanagedMarshal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Obsolete("An alternate API is available: Emit the MarshalAs custom attribute instead. http://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("An alternate API is available: Emit the MarshalAs custom attribute instead. http://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Obsolete("An alternate API is available: Emit the MarshalAs custom attribute instead.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("An alternate API is available: Emit the MarshalAs custom attribute instead.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unmanagedMarshal" Type="System.Reflection.Emit.UnmanagedMarshal" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="unmanagedMarshal">此方法的返回类型的封送处理信息。</param>
        <summary>设置此方法的返回类型的封送处理信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示了方法的上下文用法 `SetMarshal` ，以将方法调用的结果封送为不同的类型。  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.SetMarshal Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetMarshal Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.SetMarshal Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetMarshal Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.SetMarshal Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetMarshal Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">该包含类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。  
  
- 或 - 
对于当前的方法，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetMethodBody">
      <MemberSignature Language="C#" Value="public void SetMethodBody (byte[] il, int maxStack, byte[] localSignature, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.ExceptionHandler&gt; exceptionHandlers, System.Collections.Generic.IEnumerable&lt;int&gt; tokenFixups);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMethodBody(unsigned int8[] il, int32 maxStack, unsigned int8[] localSignature, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Reflection.Emit.ExceptionHandler&gt; exceptionHandlers, class System.Collections.Generic.IEnumerable`1&lt;int32&gt; tokenFixups) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetMethodBody (il As Byte(), maxStack As Integer, localSignature As Byte(), exceptionHandlers As IEnumerable(Of ExceptionHandler), tokenFixups As IEnumerable(Of Integer))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetMethodBody(cli::array &lt;System::Byte&gt; ^ il, int maxStack, cli::array &lt;System::Byte&gt; ^ localSignature, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::ExceptionHandler&gt; ^ exceptionHandlers, System::Collections::Generic::IEnumerable&lt;int&gt; ^ tokenFixups);" />
      <MemberSignature Language="F#" Value="member this.SetMethodBody : byte[] * int * byte[] * seq&lt;System.Reflection.Emit.ExceptionHandler&gt; * seq&lt;int&gt; -&gt; unit" Usage="methodBuilder.SetMethodBody (il, maxStack, localSignature, exceptionHandlers, tokenFixups)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="il" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="maxStack" Type="System.Int32" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="localSignature" Type="System.Byte[]" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exceptionHandlers" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.ExceptionHandler&gt;" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="tokenFixups" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" Index="4" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="il">包含有效 MSIL 指令的数组。</param>
        <param name="maxStack">最大堆栈评估深度。</param>
        <param name="localSignature">包含序列化本地变量结构的字节数组。 如果此方法不具有任何本地变量，则指定 <see langword="null" />。</param>
        <param name="exceptionHandlers">包含此方法的异常处理程序的集合。 如果此方法没有异常处理程序，则指定 <see langword="null" />。</param>
        <param name="tokenFixups">表示 <paramref name="il" /> 中的偏移量的值的集合，其中的每个值指定可以修改的令牌起始点。 如果此方法没有需要修改的令牌，则指定 <see langword="null" />。</param>
        <summary>通过使用 Microsoft 中间语言 (MSIL) 指令指定的字节数组创建方法的主体。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="il" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxStack" /> 为负数。  
  
- 或 - 
其中一个 <paramref name="exceptionHandlers" /> 指定 <paramref name="il" /> 外部的偏移量。  
  
- 或 - 
其中一个 <paramref name="tokenFixups" /> 指定 <paramref name="il" /> 数组外部的偏移量。</exception>
        <exception cref="T:System.InvalidOperationException">该包含类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 方法创建的。  
  
- 或 - 
之前已在此 <see cref="T:System.Reflection.Emit.MethodBuilder" /> 对象上调用过此方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetParameters">
      <MemberSignature Language="C#" Value="public void SetParameters (params Type[] parameterTypes);" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetParameters(class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetParameters (ParamArray parameterTypes As Type())" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetParameters(... cli::array &lt;Type ^&gt; ^ parameterTypes);" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.SetParameters : Type[] -&gt; unit" Usage="methodBuilder.SetParameters parameterTypes" />
      <MemberSignature Language="C#" Value="public void SetParameters (Type[] parameterTypes);" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetParameters (parameterTypes As Type())" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetParameters(cli::array &lt;Type ^&gt; ^ parameterTypes);" FrameworkAlternate="xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterTypes" Type="System.Type[]" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parameterTypes">表示参数类型的 <see cref="T:System.Type" /> 对象的数组。</param>
        <summary>为方法设置参数的数量和类型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在定义方法时参数的数量和类型已知，则可以使用 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> 接受参数类型数组的方法的任何重载来设置这些参数。 但是，泛型方法可以具有其类型由一个或多个其自己的泛型类型参数指定的参数，在定义该方法之后，才能定义这些参数。 在这种情况下，使用此方法设置参数类型。  
  
 如果返回类型具有可选或必需的自定义修饰符（例如 <xref:System.Runtime.CompilerServices.IsConst> ），请使用 <xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29> 方法重载。  
  
 调用此方法将替换使用方法设置的任何参数类型 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> 。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 方法使方法成为泛型方法。 <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A>方法用于为方法指定一个参数，该参数的类型将由第一个泛型类型参数指定。 <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A>方法用于为方法指定由第二个泛型类型参数指定的返回类型。  
  
 此代码是为方法提供的更大示例的一部分 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 。  
  
 [!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
 [!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
 [!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前方法是泛型方法，但不是泛型方法定义。 也就是说，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit">如何：用反射发出定义泛型方法</related>
      </Docs>
    </Member>
    <Member MemberName="SetReturnType">
      <MemberSignature Language="C#" Value="public void SetReturnType (Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetReturnType(class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetReturnType (returnType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetReturnType(Type ^ returnType);" />
      <MemberSignature Language="F#" Value="member this.SetReturnType : Type -&gt; unit" Usage="methodBuilder.SetReturnType returnType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="returnType">表示方法的返回类型的 <see cref="T:System.Type" /> 对象。</param>
        <summary>设置方法的返回类型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果返回类型由方法的一个泛型类型参数指定，则使用此方法设置泛型方法的返回类型。 如果返回类型具有可选或必需的自定义修饰符（例如 <xref:System.Runtime.CompilerServices.IsConst> ），请使用 <xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29> 方法重载。  
  
 调用此方法将替换使用方法建立的返回类型 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> 。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 方法使方法成为泛型方法。 <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A>方法用于为方法指定一个参数，该参数的类型将由第一个泛型类型参数指定。 <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A>方法用于为方法指定由第二个泛型类型参数指定的返回类型。  
  
 此代码是为方法提供的更大示例的一部分 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 。  
  
 [!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
 [!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
 [!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前方法是泛型方法，但不是泛型方法定义。 也就是说，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit">如何：用反射发出定义泛型方法</related>
      </Docs>
    </Member>
    <Member MemberName="SetSignature">
      <MemberSignature Language="C#" Value="public void SetSignature (Type returnType, Type[]? returnTypeRequiredCustomModifiers, Type[]? returnTypeOptionalCustomModifiers, Type[]? parameterTypes, Type[][]? parameterTypeRequiredCustomModifiers, Type[][]? parameterTypeOptionalCustomModifiers);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSignature(class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSignature (returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSignature(Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.SetSignature : Type * Type[] * Type[] * Type[] * Type[][] * Type[][] -&gt; unit" Usage="methodBuilder.SetSignature (returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers)" />
      <MemberSignature Language="C#" Value="public void SetSignature (Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" Index="1" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" Index="2" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameterTypes" Type="System.Type[]" Index="3" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" Index="4" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" Index="5" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="returnType">方法的返回类型。</param>
        <param name="returnTypeRequiredCustomModifiers">一个类型数组，表示该方法的返回类型所必需的自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。 如果返回类型没有所需的自定义修饰符，则指定 <see langword="null" />。</param>
        <param name="returnTypeOptionalCustomModifiers">一个类型数组，表示该方法的返回类型的可选自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。 如果返回类型没有可选的自定义修饰符，则指定 <see langword="null" />。</param>
        <param name="parameterTypes">方法参数的类型。</param>
        <param name="parameterTypeRequiredCustomModifiers">由类型数组组成的数组。 每个类型数组均表示相应参数所必需的自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。 如果某个特定参数没有所需的自定义修饰符，则指定 <see langword="null" />，而不要指定类型数组。 如果所有参数都没有所需的自定义修饰符，则指定 <see langword="null" />，而不要指定由数组组成的数组。</param>
        <param name="parameterTypeOptionalCustomModifiers">由类型数组组成的数组。 每个类型数组均表示相应参数的可选自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。 如果某个特定参数没有可选的自定义修饰符，则指定 <see langword="null" />，而不要指定类型数组。 如果所有参数都没有可选的自定义修饰符，则指定 <see langword="null" />，而不要指定由数组组成的数组。</param>
        <summary>设置方法签名，包括返回类型、参数类型以及返回类型和参数类型所需和可选的自定义修饰符。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在定义方法时知道返回类型和参数的数目，则可以使用 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> 接受参数类型数组的方法的任何重载来建立它们。 但是，泛型方法可以具有其类型由一个或多个其自己的泛型类型参数指定的参数，在定义该方法之后，才能定义这些参数。 在这种情况下，使用此方法设置参数类型。  
  
 如果返回类型和参数类型都没有可选的或必需的自定义修饰符（例如 <xref:Microsoft.VisualC.IsConstModifier> ），则可以使用 <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> 和 <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> 方法。  
  
 调用此方法将替换使用方法建立的参数和返回类型 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> 。  
  
   
  
## Examples  
 下面的代码示例包含一个名为 Sample 的泛型类的源代码，该类具有一个类型参数 `T` 。 类具有一个名为 `Field` 、类型为的字段 `T` 和一个 `GM` 具有自己的类型参数的泛型方法 `U` 。 方法 `GM` 创建一个示例实例，并将其自己的类型参数替换 `U` 为 sample 的类型参数，并在中存储其输入参数 `Field` 。 已编译但未使用此源代码;你可以使用 [Ildasm.exe (IL 拆装器) ](/dotnet/framework/tools/ildasm-exe-il-disassembler)查看它，并将其与类发出的代码进行比较 `Example` 。  
  
 类中的代码 `Example` 演示如何 <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A> 在发出泛型代码时使用方法。 `Main`类的方法 `Example` 创建一个动态程序集，其中包含一个名为的类 `Sample` ，并使用 <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> 方法通过添加一个名为的类型参数使其成为泛型 `T` 。 向类添加了一个无参数的构造函数和一个名为 `Field` 的类型为的字段 `T` `Sample` 。 添加方法 `GM` ，并使用方法将其转换为泛型方法 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 。 的类型参数 `GM` 命名为 `U` 。 定义类型参数后， `GM` 将使用方法添加的签名 <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A> 。 没有返回类型，并且没有必需的修饰符或自定义修饰符，因此，此方法的所有参数都是 `null` 除外，这将 `parameterTypes` 设置方法的唯一参数的类型; 此参数设置为方法的类型参数 `U` 。 方法的主体 `Sample<U>` 在 Visual Basic) 中创建构造类型 (实例 `Sample(Of U)` ，并将该方法的参数分配给 `Field` ，然后输出的值 `Field` 。 定义了一个虚类型以容纳入口点方法 `Main` 。 在的正文中 `Main` ，将在 `GM` Visual Basic) 中构造的泛型类型 (调用静态方法 `Sample<int>` `Sample(Of Integer)` ，并将类型 <xref:System.String> 替换为 `U` 。 <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A?displayProperty=nameWithType>方法用于为 <xref:System.Reflection.MethodInfo> 构造的泛型类型的静态 `GM` 方法创建 `Sample<U>` ， <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> 然后使用方法来创建 <xref:System.Reflection.MethodInfo> 可以在方法调用中发出的。  
  
 运行代码示例时，它会将发出的程序集保存为 TypeBuilderGetFieldExample.exe。 您可以 TypeBuilderGetFieldExample.exe 运行，并且可以使用 [Ildasm.exe (IL 拆装器) ](/dotnet/framework/tools/ildasm-exe-il-disassembler) 将发出的代码与 `Sample` 编译到代码示例本身中的类的代码进行比较。  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前方法是泛型方法，但不是泛型方法定义。 也就是说，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)" />
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="SetSymCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetSymCustomAttribute (string name, byte[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSymCustomAttribute(string name, unsigned int8[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSymCustomAttribute (name As String, data As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSymCustomAttribute(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data);" />
      <MemberSignature Language="F#" Value="member this.SetSymCustomAttribute : string * byte[] -&gt; unit" Usage="methodBuilder.SetSymCustomAttribute (name, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="data" Type="System.Byte[]" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">符号自定义属性的名称。</param>
        <param name="data">表示符号自定义属性的值的字节 blob。</param>
        <summary>使用 blob 设置符号自定义属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与元数据自定义特性不同，此自定义特性与符号编写器相关联。  
  
   
  
## Examples  
 下面的代码示例演示了方法的上下文用法 `SetSymCustomAttribute` ，以设置附加到方法的自定义特性的名称和键的字节值。  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example/CPP/source2.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example/CS/source2.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">该包含类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。  
  
- 或 - 
包含此方法的模块不是调试模块。  
  
- 或 - 
对于当前的方法，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Signature">
      <MemberSignature Language="C#" Value="public string Signature { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Signature" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Signature" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Signature As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Signature { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Signature : string" Usage="System.Reflection.Emit.MethodBuilder.Signature" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>检索方法的签名。</summary>
        <value>只读。 包含此 <see langword="MethodBase" /> 实例反射的方法的签名的字符串。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _MethodBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _MethodBuilder.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_MethodBuilder::GetIDsOfNames;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames : Guid * nativeint * uint32 * uint32 * nativeint -&gt; unit&#xA;override this.System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames : Guid * nativeint * uint32 * uint32 * nativeint -&gt; unit" Usage="methodBuilder.System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames (riid, rgszNames, cNames, lcid, rgDispId)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid">留待将来使用。 必须为 IID_NULL。</param>
        <param name="rgszNames">要映射的名称的传入数组。</param>
        <param name="cNames">要映射的名称的计数。</param>
        <param name="lcid">要在其中解释名称的区域设置上下文。</param>
        <param name="rgDispId">调用方分配的数组，用于接收与名称对应的 ID。</param>
        <summary>将一组名称映射为对应的一组调度标识符。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于从非托管代码访问托管类，不应从托管代码调用。 有关的详细信息 `IDispatch::GetIDsOfNames` ，请参阅 MSDN library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _MethodBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _MethodBuilder.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_MethodBuilder::GetTypeInfo;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.InteropServices._MethodBuilder.GetTypeInfo : uint32 * uint32 * nativeint -&gt; unit&#xA;override this.System.Runtime.InteropServices._MethodBuilder.GetTypeInfo : uint32 * uint32 * nativeint -&gt; unit" Usage="methodBuilder.System.Runtime.InteropServices._MethodBuilder.GetTypeInfo (iTInfo, lcid, ppTInfo)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo">要返回的类型信息。</param>
        <param name="lcid">类型信息的区域设置标识符。</param>
        <param name="ppTInfo">接收一个指针，指向请求的类型信息对象。</param>
        <summary>检索对象的类型信息，然后可以使用该信息获取接口的类型信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于从非托管代码访问托管类，不应从托管代码调用。 有关的详细信息 `IDispatch::GetTypeInfo` ，请参阅 MSDN library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _MethodBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _MethodBuilder.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_MethodBuilder::GetTypeInfoCount;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount : uint32 -&gt; unit&#xA;override this.System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount : uint32 -&gt; unit" Usage="methodBuilder.System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount pcTInfo" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">指向一个位置，该位置接收对象提供的类型信息接口的数量。</param>
        <summary>检索对象提供的类型信息接口的数量（0 或 1）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于从非托管代码访问托管类，不应从托管代码调用。 有关的详细信息 `IDispatch::GetTypeInfoCount` ，请参阅 MSDN library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _MethodBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _MethodBuilder.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_MethodBuilder::Invoke;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.InteropServices._MethodBuilder.Invoke : uint32 * Guid * uint32 * int16 * nativeint * nativeint * nativeint * nativeint -&gt; unit&#xA;override this.System.Runtime.InteropServices._MethodBuilder.Invoke : uint32 * Guid * uint32 * int16 * nativeint * nativeint * nativeint * nativeint -&gt; unit" Usage="methodBuilder.System.Runtime.InteropServices._MethodBuilder.Invoke (dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">标识成员。</param>
        <param name="riid">留待将来使用。 必须为 IID_NULL。</param>
        <param name="lcid">要在其中解释自变量的区域设置上下文。</param>
        <param name="wFlags">描述调用的上下文的标志。</param>
        <param name="pDispParams">指向一个结构的指针，该结构包含一个参数数组、一个命名参数的 DispID 参数数组和数组中元素数的计数。</param>
        <param name="pVarResult">指向要存储结果的位置的指针。</param>
        <param name="pExcepInfo">指向一个包含异常信息的结构的指针。</param>
        <param name="puArgErr">第一个出错参数的索引。</param>
        <summary>提供对某一对象公开的属性和方法的访问。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于从非托管代码访问托管类，不应从托管代码调用。 有关的详细信息 `IDispatch::Invoke` ，请参阅 MSDN library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="methodBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将此 <see langword="MethodBuilder" /> 实例作为字符串返回。</summary>
        <returns>返回一个字符串，此字符串包含名称、 属性、 方法签名、 异常和此方法的本地签名，并且末尾处为当前的 Microsoft 中间语言 (MSIL) 流。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
