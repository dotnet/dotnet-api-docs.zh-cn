<Type Name="TypeBuilder" FullName="System.Reflection.Emit.TypeBuilder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9c1711e1ea1f39d9dc463772a519b84a00e5548f" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75169250" /></Metadata><TypeSignature Language="C#" Value="public sealed class TypeBuilder : System.Reflection.TypeInfo, System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit TypeBuilder extends System.Reflection.TypeInfo implements class System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.TypeBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class TypeBuilder&#xA;Inherits TypeInfo&#xA;Implements _TypeBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeBuilder sealed : System::Reflection::TypeInfo, System::Runtime::InteropServices::_TypeBuilder" />
  <TypeSignature Language="F#" Value="type TypeBuilder = class&#xA;    inherit TypeInfo&#xA;    interface _TypeBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.TypeInfo</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netcore-2.0">System.Type</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._TypeBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._TypeBuilder))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="43201-101">在运行时定义并创建类的新实例。</span><span class="sxs-lookup"><span data-stu-id="43201-101">Defines and creates new instances of classes during run time.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-102"><xref:System.Reflection.Emit.TypeBuilder> 是用于控制在运行时中创建动态类的根类。</span><span class="sxs-lookup"><span data-stu-id="43201-102"><xref:System.Reflection.Emit.TypeBuilder> is the root class used to control the creation of dynamic classes in the runtime.</span></span> <span data-ttu-id="43201-103">它提供一组例程，用于定义类、添加方法和字段，以及在模块中创建类。</span><span class="sxs-lookup"><span data-stu-id="43201-103">It provides a set of routines that are used to define classes, add methods and fields, and create the class inside a module.</span></span> <span data-ttu-id="43201-104">可以通过调用返回 <xref:System.Reflection.Emit.TypeBuilder> 对象的 <xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType> 方法，从动态模块创建新 <xref:System.Reflection.Emit.TypeBuilder>。</span><span class="sxs-lookup"><span data-stu-id="43201-104">A new <xref:System.Reflection.Emit.TypeBuilder> can be created from a dynamic module by calling the <xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType> method, which returns a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="43201-105">反射发出提供以下用于定义类型的选项：</span><span class="sxs-lookup"><span data-stu-id="43201-105">Reflection emit provides the following options for defining types:</span></span>  
  
-   <span data-ttu-id="43201-106">定义具有给定名称的类或接口。</span><span class="sxs-lookup"><span data-stu-id="43201-106">Define a class or interface with the given name.</span></span>  
  
-   <span data-ttu-id="43201-107">定义具有给定名称和属性的类或接口。</span><span class="sxs-lookup"><span data-stu-id="43201-107">Define a class or interface with the given name and attributes.</span></span>  
  
-   <span data-ttu-id="43201-108">使用给定的名称、属性和基类定义类。</span><span class="sxs-lookup"><span data-stu-id="43201-108">Define a class with the given name, attributes, and base class.</span></span>  
  
-   <span data-ttu-id="43201-109">使用给定的名称、属性、基类和类实现的接口集定义类。</span><span class="sxs-lookup"><span data-stu-id="43201-109">Define a class with the given name, attributes, base class, and the set of interfaces that the class implements.</span></span>  
  
-   <span data-ttu-id="43201-110">使用给定的名称、属性、基类和封装大小定义类。</span><span class="sxs-lookup"><span data-stu-id="43201-110">Define a class with the given name, attributes, base class, and packing size.</span></span>  
  
-   <span data-ttu-id="43201-111">使用给定的名称、属性、基类和类大小作为一个整体来定义类。</span><span class="sxs-lookup"><span data-stu-id="43201-111">Define a class with the given name, attributes, base class, and the class size as a whole.</span></span>  
  
-   <span data-ttu-id="43201-112">使用给定的名称、属性、基类、包装大小和类大小作为一个整体来定义类。</span><span class="sxs-lookup"><span data-stu-id="43201-112">Define a class with the given name, attributes, base class, packing size, and the class size as a whole.</span></span>  
  
 <span data-ttu-id="43201-113">若要为 <xref:System.Reflection.Emit.TypeBuilder> 对象表示的不完整类型创建数组类型、指针类型或 byref 类型，请分别使用 <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> 方法、<xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> 方法或 <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="43201-113">To create an array type, pointer type, or byref type for an incomplete type that is represented by a <xref:System.Reflection.Emit.TypeBuilder> object, use the <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> method, <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> method, or <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> method, respectively.</span></span>  
  
 <span data-ttu-id="43201-114">使用类型之前，必须先调用 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="43201-114">Before a type is used, the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> method must be called.</span></span> <span data-ttu-id="43201-115">**CreateType**完成类型的创建。</span><span class="sxs-lookup"><span data-stu-id="43201-115">**CreateType** completes the creation of the type.</span></span> <span data-ttu-id="43201-116">调用**CreateType**后，调用方可以使用 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 方法来实例化该类型，并通过使用 <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> 方法调用该类型的成员。</span><span class="sxs-lookup"><span data-stu-id="43201-116">Following the call to **CreateType**, the caller can instantiate the type by using the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and invoke members of the type by using the <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="43201-117">调用**CreateType**后，调用更改类型实现的方法是错误的。</span><span class="sxs-lookup"><span data-stu-id="43201-117">It is an error to invoke methods that change the implementation of a type after **CreateType** has been called.</span></span> <span data-ttu-id="43201-118">例如，如果调用方尝试向类型中添加新成员，则公共语言运行时将引发异常。</span><span class="sxs-lookup"><span data-stu-id="43201-118">For example, the common language runtime throws an exception if the caller tries to add new members to a type.</span></span>  
  
 <span data-ttu-id="43201-119">类初始值设定项是使用 <xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType> 方法创建的。</span><span class="sxs-lookup"><span data-stu-id="43201-119">A class initializer is created by using the <xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="43201-120">**DefineTypeInitializer**返回 <xref:System.Reflection.Emit.ConstructorBuilder> 的对象。</span><span class="sxs-lookup"><span data-stu-id="43201-120">**DefineTypeInitializer** returns a <xref:System.Reflection.Emit.ConstructorBuilder> object.</span></span>  
  
 <span data-ttu-id="43201-121">嵌套类型是通过调用 <xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType> 方法之一来定义的。</span><span class="sxs-lookup"><span data-stu-id="43201-121">Nested types are defined by calling one of the <xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType> methods.</span></span>  
  
## <a name="attributes"></a><span data-ttu-id="43201-122">特性</span><span class="sxs-lookup"><span data-stu-id="43201-122">Attributes</span></span>  
 <span data-ttu-id="43201-123"><xref:System.Reflection.Emit.TypeBuilder> 类使用 <xref:System.Reflection.TypeAttributes> 枚举进一步指定要创建的类型的特征：</span><span class="sxs-lookup"><span data-stu-id="43201-123">The <xref:System.Reflection.Emit.TypeBuilder> class uses the <xref:System.Reflection.TypeAttributes> enumeration to further specify the characteristics of the type to be created:</span></span>  
  
-   <span data-ttu-id="43201-124">接口是使用 <xref:System.Reflection.TypeAttributes.Interface?displayProperty=nameWithType> 和 <xref:System.Reflection.TypeAttributes.Abstract?displayProperty=nameWithType> 属性指定的。</span><span class="sxs-lookup"><span data-stu-id="43201-124">Interfaces are specified using the <xref:System.Reflection.TypeAttributes.Interface?displayProperty=nameWithType> and <xref:System.Reflection.TypeAttributes.Abstract?displayProperty=nameWithType> attributes.</span></span>  
  
-   <span data-ttu-id="43201-125">使用 <xref:System.Reflection.TypeAttributes.Sealed?displayProperty=nameWithType> 特性指定具体类（不能扩展的类）。</span><span class="sxs-lookup"><span data-stu-id="43201-125">Concrete classes (classes that cannot be extended) are specified using the <xref:System.Reflection.TypeAttributes.Sealed?displayProperty=nameWithType> attribute.</span></span>  
  
-   <span data-ttu-id="43201-126">几个属性确定类型可见性。</span><span class="sxs-lookup"><span data-stu-id="43201-126">Several attributes determine type visibility.</span></span> <span data-ttu-id="43201-127">请参阅 <xref:System.Reflection.TypeAttributes> 枚举的说明。</span><span class="sxs-lookup"><span data-stu-id="43201-127">See the description of the <xref:System.Reflection.TypeAttributes> enumeration.</span></span>  
  
-   <span data-ttu-id="43201-128">如果指定了 <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>，类加载程序将按从元数据中读取字段的顺序对它们进行布局。</span><span class="sxs-lookup"><span data-stu-id="43201-128">If <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> is specified, the class loader lays out fields in the order they are read from metadata.</span></span> <span data-ttu-id="43201-129">类加载器会考虑指定的封装大小，但会忽略任何指定的字段偏移量。</span><span class="sxs-lookup"><span data-stu-id="43201-129">The class loader considers the specified packing size but ignores any specified field offsets.</span></span> <span data-ttu-id="43201-130">元数据保留发出字段定义的顺序。</span><span class="sxs-lookup"><span data-stu-id="43201-130">The metadata preserves the order in which the field definitions are emitted.</span></span> <span data-ttu-id="43201-131">甚至跨合并，元数据也不会对字段定义重新排序。</span><span class="sxs-lookup"><span data-stu-id="43201-131">Even across a merge, the metadata will not reorder the field definitions.</span></span> <span data-ttu-id="43201-132">仅当指定 <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> 时，加载程序才服从指定的字段偏移量。</span><span class="sxs-lookup"><span data-stu-id="43201-132">The loader will honor the specified field offsets only if <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> is specified.</span></span>  
  
## <a name="known-issues"></a><span data-ttu-id="43201-133">已知问题</span><span class="sxs-lookup"><span data-stu-id="43201-133">Known Issues</span></span>  
  
-   <span data-ttu-id="43201-134">反射发出不验证实现接口的非抽象类是否实现了在接口中声明的所有方法。</span><span class="sxs-lookup"><span data-stu-id="43201-134">Reflection emit does not verify whether a non-abstract class that implements an interface has implemented all the methods declared in the interface.</span></span> <span data-ttu-id="43201-135">但是，如果类未实现在接口中声明的所有方法，则运行时不会加载类。</span><span class="sxs-lookup"><span data-stu-id="43201-135">However, if the class does not implement all the methods declared in an interface, the runtime does not load the class.</span></span>  
  
-   <span data-ttu-id="43201-136">尽管 <xref:System.Reflection.Emit.TypeBuilder> 派生自 <xref:System.Type>，但 <xref:System.Type> 类中定义的某些抽象方法未在 <xref:System.Reflection.Emit.TypeBuilder> 类中完全实现。</span><span class="sxs-lookup"><span data-stu-id="43201-136">Although <xref:System.Reflection.Emit.TypeBuilder> is derived from <xref:System.Type>, some of the abstract methods defined in the <xref:System.Type> class are not fully implemented in the <xref:System.Reflection.Emit.TypeBuilder> class.</span></span> <span data-ttu-id="43201-137">对这些 <xref:System.Reflection.Emit.TypeBuilder> 方法的调用将引发 <xref:System.NotSupportedException> 异常。</span><span class="sxs-lookup"><span data-stu-id="43201-137">Calls to these <xref:System.Reflection.Emit.TypeBuilder> methods throw a <xref:System.NotSupportedException> exception.</span></span> <span data-ttu-id="43201-138">可以通过使用 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 或 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 检索创建的类型并在检索的类型上进行反射来获取所需的功能。</span><span class="sxs-lookup"><span data-stu-id="43201-138">The desired functionality can be obtained by retrieving the created type using the <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and reflecting on the retrieved type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43201-139">本部分包含两个代码示例。</span><span class="sxs-lookup"><span data-stu-id="43201-139">This section contains two code examples.</span></span> <span data-ttu-id="43201-140">第一个示例演示如何使用字段、构造函数、属性和方法创建动态类型。</span><span class="sxs-lookup"><span data-stu-id="43201-140">The first example shows how to create a dynamic type with a field, constructor, property, and method.</span></span> <span data-ttu-id="43201-141">第二个示例从用户输入动态生成方法。</span><span class="sxs-lookup"><span data-stu-id="43201-141">The second example builds a method dynamically from user input.</span></span>  
  
 <span data-ttu-id="43201-142">**示例一**</span><span class="sxs-lookup"><span data-stu-id="43201-142">**Example one**</span></span>  
  
 <span data-ttu-id="43201-143">下面的代码示例演示如何使用一个模块定义动态程序集。</span><span class="sxs-lookup"><span data-stu-id="43201-143">The following code example shows how to define a dynamic assembly with one module.</span></span> <span data-ttu-id="43201-144">示例程序集中的模块包含一种类型，`MyDynamicType`，其中包含一个私有字段、一个用于获取和设置私有字段的属性、用于初始化私有字段的构造函数，以及一个方法，该方法将用户提供的数字与私有字段值相乘并返回结果。</span><span class="sxs-lookup"><span data-stu-id="43201-144">The module in the example assembly contains one type, `MyDynamicType`, which has a private field, a property that gets and sets the private field, constructors that initialize the private field, and a method that multiplies a user-supplied number by the private field value and returns the result.</span></span>  
  
 <span data-ttu-id="43201-145"><xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType> 字段是在创建程序集时指定的。</span><span class="sxs-lookup"><span data-stu-id="43201-145">The <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType> field is specified when the assembly is created.</span></span> <span data-ttu-id="43201-146">系统将立即使用程序集代码，并将程序集保存到磁盘，以便可以使用[Ildasm （IL 拆装器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)或在其他程序中使用它来检查程序集代码。</span><span class="sxs-lookup"><span data-stu-id="43201-146">The assembly code is used immediately, and the assembly is also saved to disk so that it can be examined with [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) or used in another program.</span></span>  
  
 [!code-cpp[AssemblyBuilderClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilderClass/cpp/24895.cpp#1)]
 [!code-csharp[AssemblyBuilderClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilderClass/cs/24895.cs#1)]
 [!code-vb[AssemblyBuilderClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilderClass/vb/24895.vb#1)]  
  
 <span data-ttu-id="43201-147">**示例二**</span><span class="sxs-lookup"><span data-stu-id="43201-147">**Example two**</span></span>  
  
 <span data-ttu-id="43201-148">下面的代码示例演示如何使用 `TypeBuilder`生成动态类型。</span><span class="sxs-lookup"><span data-stu-id="43201-148">The following code sample demonstrates how to build a dynamic type by using `TypeBuilder`.</span></span>  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/07d5f01a-7b5b-40ea-9b15-f21561098fe4"><span data-ttu-id="43201-149">如何：用反射发出定义泛型类型</span><span class="sxs-lookup"><span data-stu-id="43201-149">How to: Define a Generic Type with Reflection Emit</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeBuilder ();" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.#ctor" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TypeBuilder();" FrameworkAlternate="xamarinios-10.8" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddDeclarativeSecurity">
      <MemberSignature Language="C#" Value="public void AddDeclarativeSecurity (System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDeclarativeSecurity(valuetype System.Security.Permissions.SecurityAction action, class System.Security.PermissionSet pset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDeclarativeSecurity (action As SecurityAction, pset As PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDeclarativeSecurity(System::Security::Permissions::SecurityAction action, System::Security::PermissionSet ^ pset);" />
      <MemberSignature Language="F#" Value="member this.AddDeclarativeSecurity : System.Security.Permissions.SecurityAction * System.Security.PermissionSet -&gt; unit" Usage="typeBuilder.AddDeclarativeSecurity (action, pset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Security.Permissions.SecurityAction" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pset" Type="System.Security.PermissionSet" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="43201-150">要执行的安全操作，如 Demand、Assert 等。</span><span class="sxs-lookup"><span data-stu-id="43201-150">The security action to be taken such as Demand, Assert, and so on.</span></span></param>
        <param name="pset"><span data-ttu-id="43201-151">应用此操作的权限集。</span><span class="sxs-lookup"><span data-stu-id="43201-151">The set of permissions the action applies to.</span></span></param>
        <summary><span data-ttu-id="43201-152">将声明性安全添加到此类型。</span><span class="sxs-lookup"><span data-stu-id="43201-152">Adds declarative security to this type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-153">每次调用都可以调用 `AddDeclarativeSecurity` 多次，每次调用指定安全操作（如 Demand、Assert 或 Deny）和一组适用于该操作的权限。</span><span class="sxs-lookup"><span data-stu-id="43201-153">`AddDeclarativeSecurity` may be called several times with each call specifying a security action (such as Demand, Assert, or Deny) and a set of permissions that apply to the action.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="43201-154">在 .NET Framework 版本1.0、1.1 和2.0 中，使用此方法应用于类型的声明性安全特性以旧的 XML 元数据格式存储。</span><span class="sxs-lookup"><span data-stu-id="43201-154">In the .NET Framework versions 1.0, 1.1, and 2.0, the declarative security attributes applied to a type by using this method are stored in the old XML metadata format.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43201-155">下面的示例演示如何使用 `AddDeclarativeSecurity` 方法，将具有 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.SecurityPermission> 的安全要求添加到名为 EmittedExample 的程序集中的一个名为 `MyDynamicClass`的动态类型。</span><span class="sxs-lookup"><span data-stu-id="43201-155">The following example demonstrates the use of the `AddDeclarativeSecurity` method to add a security demand for <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag to a dynamic type named `MyDynamicClass`, in an assembly named EmittedExample.dll.</span></span> <span data-ttu-id="43201-156">该示例不生成控制台输出;运行后，可以使用[Ildasm （IL 拆装器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)来检查 EmittedExample。</span><span class="sxs-lookup"><span data-stu-id="43201-156">The example produces no console output; after you run it, you can use [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine EmittedExample.dll.</span></span> <span data-ttu-id="43201-157">在 `MyDynamicClass`中，打开 `.class public auto ansi` 语句以查看声明性权限。</span><span class="sxs-lookup"><span data-stu-id="43201-157">In `MyDynamicClass`, open the `.class public auto ansi` statement to see the declarative permission.</span></span>  
  
 [!code-cpp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CPP/typebuilder_adddeclarativesecurity.cpp#1)]
 [!code-csharp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CS/typebuilder_adddeclarativesecurity.cs#1)]
 [!code-vb[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/VB/typebuilder_adddeclarativesecurity.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="43201-158"><paramref name="action" /> 无效（<see langword="RequestMinimum" />、<see langword="RequestOptional" /> 和 <see langword="RequestRefuse" /> 无效）。</span><span class="sxs-lookup"><span data-stu-id="43201-158">The <paramref name="action" /> is invalid (<see langword="RequestMinimum" />, <see langword="RequestOptional" />, and <see langword="RequestRefuse" /> are invalid).</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-159">已使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建包含类型。</span><span class="sxs-lookup"><span data-stu-id="43201-159">The containing type has been created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="43201-160">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-160">-or-</span></span> 
<span data-ttu-id="43201-161">权限集 <paramref name="pset" /> 包含之前由 <see langword="AddDeclarativeSecurity" /> 添加的操作。</span><span class="sxs-lookup"><span data-stu-id="43201-161">The permission set <paramref name="pset" /> contains an action that was added earlier by <see langword="AddDeclarativeSecurity" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-162"><paramref name="pset" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-162"><paramref name="pset" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AddInterfaceImplementation">
      <MemberSignature Language="C#" Value="public void AddInterfaceImplementation (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddInterfaceImplementation(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddInterfaceImplementation (interfaceType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddInterfaceImplementation(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="member this.AddInterfaceImplementation : Type -&gt; unit" Usage="typeBuilder.AddInterfaceImplementation interfaceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType"><span data-ttu-id="43201-163">此类型实现的接口。</span><span class="sxs-lookup"><span data-stu-id="43201-163">The interface that this type implements.</span></span></param>
        <summary><span data-ttu-id="43201-164">添加一个此类型实现的接口。</span><span class="sxs-lookup"><span data-stu-id="43201-164">Adds an interface that this type implements.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="43201-165">下面的代码示例演示如何使用 `AddInterfaceImplementation`在动态创建的类型上实现接口。</span><span class="sxs-lookup"><span data-stu-id="43201-165">The following code sample demonstrates the implementation of an interface on a dynamically created type using `AddInterfaceImplementation`.</span></span>  
  
 [!code-cpp[TypeBuilder_Sample_4#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#3)]
 [!code-csharp[TypeBuilder_Sample_4#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#3)]
 [!code-vb[TypeBuilder_Sample_4#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-166"><paramref name="interfaceType" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-166"><paramref name="interfaceType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-167">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</span><span class="sxs-lookup"><span data-stu-id="43201-167">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Reflection.Emit.TypeBuilder.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43201-168">检索包含此类型定义的动态程序集。</span><span class="sxs-lookup"><span data-stu-id="43201-168">Retrieves the dynamic assembly that contains this type definition.</span></span></summary>
        <value><span data-ttu-id="43201-169">只读。</span><span class="sxs-lookup"><span data-stu-id="43201-169">Read-only.</span></span> <span data-ttu-id="43201-170">检索包含此类型定义的动态程序集。</span><span class="sxs-lookup"><span data-stu-id="43201-170">Retrieves the dynamic assembly that contains this type definition.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public override string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43201-171">返回由程序集的显示名称限定的此类型的全名。</span><span class="sxs-lookup"><span data-stu-id="43201-171">Returns the full name of this type qualified by the display name of the assembly.</span></span></summary>
        <value><span data-ttu-id="43201-172">只读。</span><span class="sxs-lookup"><span data-stu-id="43201-172">Read-only.</span></span> <span data-ttu-id="43201-173">由程序集的显示名称限定的此类型的全名。</span><span class="sxs-lookup"><span data-stu-id="43201-173">The full name of this type qualified by the display name of the assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-174">返回的字符串的格式为类型（<xref:System.Reflection.Emit.TypeBuilder.FullName%2A>）的完整名称与程序集（<xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType>）的显示名称的串联，并用逗号和空格分隔。</span><span class="sxs-lookup"><span data-stu-id="43201-174">The format of the returned string is the concatenation of the full name of the type (<xref:System.Reflection.Emit.TypeBuilder.FullName%2A>) and the display name of the assembly (<xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType>), separated by a comma and a space.</span></span>  
  
 <span data-ttu-id="43201-175">有关程序集显示名称的格式的说明，请参阅 <xref:System.Reflection.AssemblyName>。</span><span class="sxs-lookup"><span data-stu-id="43201-175">See <xref:System.Reflection.AssemblyName> for a description of the format of the display name of an assembly.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="43201-176">版本信息</span><span class="sxs-lookup"><span data-stu-id="43201-176">Version Information</span></span>  
 <span data-ttu-id="43201-177">在 .NET Framework 版本1.0 和1.1 中，此属性的值不包括区域性或公钥。</span><span class="sxs-lookup"><span data-stu-id="43201-177">In the .NET Framework versions 1.0 and 1.1, the value of this property does not include the culture or public key.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Reflection.Emit.TypeBuilder.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public override Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Reflection.Emit.TypeBuilder.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43201-178">检索此类型的基类型。</span><span class="sxs-lookup"><span data-stu-id="43201-178">Retrieves the base type of this type.</span></span></summary>
        <value><span data-ttu-id="43201-179">只读。</span><span class="sxs-lookup"><span data-stu-id="43201-179">Read-only.</span></span> <span data-ttu-id="43201-180">检索此类型的基类型。</span><span class="sxs-lookup"><span data-stu-id="43201-180">Retrieves the base type of this type.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public override bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Reflection.Emit.TypeBuilder.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateType">
      <MemberSignature Language="C#" Value="public Type CreateType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type CreateType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateType" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ CreateType();" />
      <MemberSignature Language="F#" Value="member this.CreateType : unit -&gt; Type" Usage="typeBuilder.CreateType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43201-181">创建类的 <see cref="T:System.Type" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="43201-181">Creates a <see cref="T:System.Type" /> object for the class.</span></span> <span data-ttu-id="43201-182">定义了类的字段和方法后，调用 <see langword="CreateType" /> 以加载其 <see langword="Type" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="43201-182">After defining fields and methods on the class, <see langword="CreateType" /> is called in order to load its <see langword="Type" /> object.</span></span></summary>
        <returns><span data-ttu-id="43201-183">为此类返回新的 <see cref="T:System.Type" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="43201-183">Returns the new <see cref="T:System.Type" /> object for this class.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-184">如果此类型是嵌套类型，则在对嵌套类型调用 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 方法之前，必须在封闭类型上调用该类型。</span><span class="sxs-lookup"><span data-stu-id="43201-184">If this type is a nested type, the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method must be called on the enclosing type before it is called on the nested type.</span></span>  
  
 <span data-ttu-id="43201-185">如果当前类型派生自不完整的类型或实现了不完整的接口，请先对父类型和接口类型调用 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 方法，然后再在当前类型上调用该方法。</span><span class="sxs-lookup"><span data-stu-id="43201-185">If the current type derives from an incomplete type or implements incomplete interfaces, call the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method on the parent type and the interface types before calling it on the current type.</span></span>  
  
 <span data-ttu-id="43201-186">如果封闭类型包含的字段是定义为嵌套类型的值类型（例如，作为定义为嵌套类型的枚举的字段），则对封闭类型调用 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 方法将生成 <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> 事件。</span><span class="sxs-lookup"><span data-stu-id="43201-186">If the enclosing type contains a field that is a value type defined as a nested type (for example, a field that is an enumeration defined as a nested type), calling the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method on the enclosing type will generate a <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="43201-187">这是因为加载程序不能确定封闭类型的大小，直到嵌套类型完成。</span><span class="sxs-lookup"><span data-stu-id="43201-187">This is because the loader cannot determine the size of the enclosing type until the nested type has been completed.</span></span> <span data-ttu-id="43201-188">调用方应为 <xref:System.AppDomain.TypeResolve> 事件定义处理程序，以通过对表示嵌套类型的 <xref:System.Reflection.Emit.TypeBuilder> 对象调用 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 来完成嵌套类型的定义。</span><span class="sxs-lookup"><span data-stu-id="43201-188">The caller should define a handler for the <xref:System.AppDomain.TypeResolve> event to complete the definition of the nested type by calling <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> on the <xref:System.Reflection.Emit.TypeBuilder> object that represents the nested type.</span></span> <span data-ttu-id="43201-189">本主题的代码示例演示如何定义此类事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="43201-189">The code example for this topic shows how to define such an event handler.</span></span>  
  
 <span data-ttu-id="43201-190">仅创建一次类型，无论调用 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 方法多少次。</span><span class="sxs-lookup"><span data-stu-id="43201-190">A type is created only once, no matter how many times the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method is called.</span></span> <span data-ttu-id="43201-191">所有调用都返回相同的 <xref:System.Type> 对象。</span><span class="sxs-lookup"><span data-stu-id="43201-191">All calls return the same <xref:System.Type> object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43201-192">下面的代码示例演示如何为 <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> 事件定义事件处理程序，以便在对封闭类型的 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 调用期间调用嵌套类型的 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="43201-192">The following code example shows how to define an event handler for the <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> event, in order to call the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method on a nested type during a <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> call on the enclosing type.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CPP/nestedenum.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CS/nestedenum.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/VB/nestedenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-193">尚未创建封闭类型。</span><span class="sxs-lookup"><span data-stu-id="43201-193">The enclosing type has not been created.</span></span>  
  
 <span data-ttu-id="43201-194">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-194">-or-</span></span>  
  
 <span data-ttu-id="43201-195">此类型是非抽象类型，且包含一个抽象方法。</span><span class="sxs-lookup"><span data-stu-id="43201-195">This type is non-abstract and contains an abstract method.</span></span>  
  
 <span data-ttu-id="43201-196">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-196">-or-</span></span>  
  
 <span data-ttu-id="43201-197">此类型不是抽象类或接口，并且具有一个没有方法体的方法。</span><span class="sxs-lookup"><span data-stu-id="43201-197">This type is not an abstract class or an interface and has a method without a method body.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-198"><see cref="T:System.Reflection.Emit.ILGenerator" /> 中的错误标签内容：已定义标签，但未调用 <see cref="M:System.Reflection.Emit.ILGenerator.MarkLabel(System.Reflection.Emit.Label)" />。</span><span class="sxs-lookup"><span data-stu-id="43201-198">Bad label content in <see cref="T:System.Reflection.Emit.ILGenerator" />: You have defined a label without calling <see cref="M:System.Reflection.Emit.ILGenerator.MarkLabel(System.Reflection.Emit.Label)" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="43201-199">此类型包含无效的 Microsoft 中间语言 (MSIL) 代码。</span><span class="sxs-lookup"><span data-stu-id="43201-199">The type contains invalid Microsoft intermediate language (MSIL) code.</span></span>  
  
 <span data-ttu-id="43201-200">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-200">-or-</span></span>  
  
 <span data-ttu-id="43201-201">分支目标使用 1 个字节的偏移量指定，但目标离分支的距离大于 127 个字节。</span><span class="sxs-lookup"><span data-stu-id="43201-201">The branch target is specified using a 1-byte offset, but the target is at a distance greater than 127 bytes from the branch.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="43201-202">无法加载此类型。</span><span class="sxs-lookup"><span data-stu-id="43201-202">The type cannot be loaded.</span></span> <span data-ttu-id="43201-203">例如，它包含具有调用约定 <see cref="F:System.Reflection.CallingConventions.HasThis" /> 的 <see langword="static" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="43201-203">For example, it contains a <see langword="static" /> method that has the calling convention <see cref="F:System.Reflection.CallingConventions.HasThis" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateTypeInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeInfo CreateTypeInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.TypeInfo CreateTypeInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateTypeInfo () As TypeInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::TypeInfo ^ CreateTypeInfo();" />
      <MemberSignature Language="F#" Value="member this.CreateTypeInfo : unit -&gt; System.Reflection.TypeInfo" Usage="typeBuilder.CreateTypeInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43201-204">获取一个表示此类型的 <see cref="T:System.Reflection.TypeInfo" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="43201-204">Gets a <see cref="T:System.Reflection.TypeInfo" /> object that represents this type.</span></span></summary>
        <returns><span data-ttu-id="43201-205">一个表示此类型的对象。</span><span class="sxs-lookup"><span data-stu-id="43201-205">An object that represents this type.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Reflection.Emit.TypeBuilder.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43201-206">获取声明了当前泛型类型参数的方法。</span><span class="sxs-lookup"><span data-stu-id="43201-206">Gets the method that declared the current generic type parameter.</span></span></summary>
        <value><span data-ttu-id="43201-207">如果当前的类型是一个泛型类型参数，则为表示声明了当前类型的方法的 <see cref="T:System.Reflection.MethodBase" />；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-207">A <see cref="T:System.Reflection.MethodBase" /> that represents the method that declared the current type, if the current type is a generic type parameter; otherwise, <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="43201-208">发出代码时，泛型类型参数由 <xref:System.Reflection.Emit.GenericTypeParameterBuilder> 对象而不是 <xref:System.Reflection.Emit.TypeBuilder> 对象表示。</span><span class="sxs-lookup"><span data-stu-id="43201-208">When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Reflection.Emit.TypeBuilder.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43201-209">返回声明此类型的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-209">Returns the type that declared this type.</span></span></summary>
        <value><span data-ttu-id="43201-210">只读。</span><span class="sxs-lookup"><span data-stu-id="43201-210">Read-only.</span></span> <span data-ttu-id="43201-211">声明此类型的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-211">The type that declared this type.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineConstructor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="43201-212">将新的构造函数添加到动态类型。</span><span class="sxs-lookup"><span data-stu-id="43201-212">Adds a new constructor to the dynamic type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineConstructor (attributes As MethodAttributes, callingConvention As CallingConventions, parameterTypes As Type()) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineConstructor(System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineConstructor : System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type[] -&gt; System.Reflection.Emit.ConstructorBuilder" Usage="typeBuilder.DefineConstructor (attributes, callingConvention, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="attributes"><span data-ttu-id="43201-213">构造函数的属性。</span><span class="sxs-lookup"><span data-stu-id="43201-213">The attributes of the constructor.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="43201-214">构造函数的调用约定。</span><span class="sxs-lookup"><span data-stu-id="43201-214">The calling convention of the constructor.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="43201-215">构造函数的参数类型。</span><span class="sxs-lookup"><span data-stu-id="43201-215">The parameter types of the constructor.</span></span></param>
        <summary><span data-ttu-id="43201-216">用给定的属性和签名，向类型中添加新的构造函数。</span><span class="sxs-lookup"><span data-stu-id="43201-216">Adds a new constructor to the type, with the given attributes and signature.</span></span></summary>
        <returns><span data-ttu-id="43201-217">定义构造函数。</span><span class="sxs-lookup"><span data-stu-id="43201-217">The defined constructor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-218">如果没有为动态类型定义构造函数，则自动提供无参数的构造函数，并调用基类的无参数构造函数。</span><span class="sxs-lookup"><span data-stu-id="43201-218">If you do not define a constructor for your dynamic type, a parameterless constructor is provided automatically, and it calls the parameterless constructor of the base class.</span></span>  
  
 <span data-ttu-id="43201-219">如果为动态类型定义构造函数，则不会提供无参数的构造函数。</span><span class="sxs-lookup"><span data-stu-id="43201-219">If you define a constructor for your dynamic type, a parameterless constructor is not provided.</span></span> <span data-ttu-id="43201-220">除了定义构造函数外，还可以使用以下选项来提供无参数的构造函数：</span><span class="sxs-lookup"><span data-stu-id="43201-220">You have the following options for providing a parameterless constructor in addition to the constructor you defined:</span></span>  
  
-   <span data-ttu-id="43201-221">如果需要一个无参数的构造函数，该构造函数只调用基类的无参数构造函数，则可以使用 <xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A> 方法创建一个（可以选择限制对其的访问）。</span><span class="sxs-lookup"><span data-stu-id="43201-221">If you want a parameterless constructor that simply calls the parameterless constructor of the base class, you can use the <xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A> method to create one (and optionally restrict access to it).</span></span> <span data-ttu-id="43201-222">不要提供此无参数构造函数的实现。</span><span class="sxs-lookup"><span data-stu-id="43201-222">Do not provide an implementation for this parameterless constructor.</span></span> <span data-ttu-id="43201-223">如果这样做，则在您尝试使用构造函数时会引发异常。</span><span class="sxs-lookup"><span data-stu-id="43201-223">If you do, an exception is thrown when you try to use the constructor.</span></span> <span data-ttu-id="43201-224">调用 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 方法时，不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="43201-224">No exception is thrown when the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method is called.</span></span>  
  
-   <span data-ttu-id="43201-225">如果需要一个执行操作的方法不只是调用基类的无参数构造函数或调用基类的其他构造函数，或者完全执行其他操作，则必须使用 <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType> 方法来创建一个，并提供您自己的实现。</span><span class="sxs-lookup"><span data-stu-id="43201-225">If you want a parameterless constructor that does something more than simply calling the parameterless constructor of the base class, or that calls another constructor of the base class, or that does something else entirely, you must use the <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType> method to create one, and provide your own implementation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43201-226">下面的代码示例演示如何使用 `DefineConstructor` 在动态类型上设置构造函数的特定签名和特性，并为 MSIL 填充返回相应的 <xref:System.Reflection.Emit.ConstructorBuilder>。</span><span class="sxs-lookup"><span data-stu-id="43201-226">The following code sample demonstrates the use of `DefineConstructor` to set a constructor's particular signature and attributes on a dynamic type and return a corresponding <xref:System.Reflection.Emit.ConstructorBuilder> for MSIL population.</span></span>  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-227">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</span><span class="sxs-lookup"><span data-stu-id="43201-227">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes, class System.Type[][] requiredCustomModifiers, class System.Type[][] optionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineConstructor (attributes As MethodAttributes, callingConvention As CallingConventions, parameterTypes As Type(), requiredCustomModifiers As Type()(), optionalCustomModifiers As Type()()) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineConstructor(System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ requiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ optionalCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.DefineConstructor : System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type[] * Type[][] * Type[][] -&gt; System.Reflection.Emit.ConstructorBuilder" Usage="typeBuilder.DefineConstructor (attributes, callingConvention, parameterTypes, requiredCustomModifiers, optionalCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameterTypes" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[][]" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[][]" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="attributes"><span data-ttu-id="43201-228">构造函数的属性。</span><span class="sxs-lookup"><span data-stu-id="43201-228">The attributes of the constructor.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="43201-229">构造函数的调用约定。</span><span class="sxs-lookup"><span data-stu-id="43201-229">The calling convention of the constructor.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="43201-230">构造函数的参数类型。</span><span class="sxs-lookup"><span data-stu-id="43201-230">The parameter types of the constructor.</span></span></param>
        <param name="requiredCustomModifiers"><span data-ttu-id="43201-231">由类型数组组成的数组。</span><span class="sxs-lookup"><span data-stu-id="43201-231">An array of arrays of types.</span></span> <span data-ttu-id="43201-232">每个类型数组均表示相应参数所必需的自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span><span class="sxs-lookup"><span data-stu-id="43201-232">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="43201-233">如果某个特定参数没有所需的自定义修饰符，则指定 <see langword="null" />，而不要指定类型数组。</span><span class="sxs-lookup"><span data-stu-id="43201-233">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="43201-234">如果所有参数都没有所需的自定义修饰符，则指定 <see langword="null" />，而不要指定由数组组成的数组。</span><span class="sxs-lookup"><span data-stu-id="43201-234">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <param name="optionalCustomModifiers"><span data-ttu-id="43201-235">由类型数组组成的数组。</span><span class="sxs-lookup"><span data-stu-id="43201-235">An array of arrays of types.</span></span> <span data-ttu-id="43201-236">每个类型数组均表示相应参数的可选自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span><span class="sxs-lookup"><span data-stu-id="43201-236">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="43201-237">如果某个特定参数没有可选的自定义修饰符，则指定 <see langword="null" />，而不要指定类型数组。</span><span class="sxs-lookup"><span data-stu-id="43201-237">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="43201-238">如果所有参数都没有可选的自定义修饰符，则指定 <see langword="null" />，而不要指定由数组组成的数组。</span><span class="sxs-lookup"><span data-stu-id="43201-238">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <summary><span data-ttu-id="43201-239">将新构造函数添加到该类型，其属性、签名和自定义修饰符已给定。</span><span class="sxs-lookup"><span data-stu-id="43201-239">Adds a new constructor to the type, with the given attributes, signature, and custom modifiers.</span></span></summary>
        <returns><span data-ttu-id="43201-240">定义构造函数。</span><span class="sxs-lookup"><span data-stu-id="43201-240">The defined constructor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-241">此重载是为托管编译器的设计器提供的。</span><span class="sxs-lookup"><span data-stu-id="43201-241">This overload is provided for designers of managed compilers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="43201-242">有关自定义修饰符的详细信息，请参阅 ECMA Partition II 元数据文档。</span><span class="sxs-lookup"><span data-stu-id="43201-242">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="43201-243">可联机获取该文档；请参阅 MSDN 上的 [ECMA C# 和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)和 Ecma International 网站上的[标准 ECMA-335 - 公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)。</span><span class="sxs-lookup"><span data-stu-id="43201-243">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-244"><paramref name="requiredCustomModifiers" /> 或 <paramref name="optionalCustomModifiers" /> 的大小与 <paramref name="parameterTypes" /> 的大小不相等。</span><span class="sxs-lookup"><span data-stu-id="43201-244">The size of <paramref name="requiredCustomModifiers" /> or <paramref name="optionalCustomModifiers" /> does not equal the size of <paramref name="parameterTypes" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-245">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</span><span class="sxs-lookup"><span data-stu-id="43201-245">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="43201-246">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-246">-or-</span></span> 
<span data-ttu-id="43201-247">对于当前的动态类型，属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 的值为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 的值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43201-247">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDefaultConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor (System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor(valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDefaultConstructor (attributes As MethodAttributes) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineDefaultConstructor(System::Reflection::MethodAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDefaultConstructor : System.Reflection.MethodAttributes -&gt; System.Reflection.Emit.ConstructorBuilder" Usage="typeBuilder.DefineDefaultConstructor attributes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
      </Parameters>
      <Docs>
        <param name="attributes"><span data-ttu-id="43201-248"><see langword="MethodAttributes" /> 对象，表示要应用到此构造函数的属性 。</span><span class="sxs-lookup"><span data-stu-id="43201-248">A <see langword="MethodAttributes" /> object representing the attributes to be applied to the constructor.</span></span></param>
        <summary><span data-ttu-id="43201-249">定义无参数构造函数。</span><span class="sxs-lookup"><span data-stu-id="43201-249">Defines the parameterless constructor.</span></span> <span data-ttu-id="43201-250">在此处定义的构造函数将只调用父类的无参数构造函数。</span><span class="sxs-lookup"><span data-stu-id="43201-250">The constructor defined here will simply call the parameterless constructor of the parent.</span></span></summary>
        <returns><span data-ttu-id="43201-251">返回构造函数。</span><span class="sxs-lookup"><span data-stu-id="43201-251">Returns the constructor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-252">由于自动定义了无参数的构造函数，因此仅在以下情况下才需要调用此方法：</span><span class="sxs-lookup"><span data-stu-id="43201-252">Because the parameterless constructor is automatically defined, it is necessary to call this method only in the following situations:</span></span>  
  
-   <span data-ttu-id="43201-253">您已经定义了另一个构造函数，并且还需要一个无参数的构造函数来调用基类构造函数。</span><span class="sxs-lookup"><span data-stu-id="43201-253">You have defined another constructor and you also want a parameterless constructor that simply calls the base class constructor.</span></span>  
  
-   <span data-ttu-id="43201-254">需要将无参数构造函数上的属性设置为 <xref:System.Reflection.MethodAttributes.PrivateScope>、<xref:System.Reflection.MethodAttributes.Public>、<xref:System.Reflection.MethodAttributes.HideBySig>、<xref:System.Reflection.MethodAttributes.SpecialName>和 <xref:System.Reflection.MethodAttributes.RTSpecialName>以外的其他内容。</span><span class="sxs-lookup"><span data-stu-id="43201-254">You want to set the attributes on the parameterless constructor to something other than <xref:System.Reflection.MethodAttributes.PrivateScope>, <xref:System.Reflection.MethodAttributes.Public>, <xref:System.Reflection.MethodAttributes.HideBySig>, <xref:System.Reflection.MethodAttributes.SpecialName>, and <xref:System.Reflection.MethodAttributes.RTSpecialName>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43201-255">下面的代码示例演示如何使用 `DefineConstructor` 在动态类型上设置构造函数的特定签名和特性，并为 MSIL 填充返回相应的 <xref:System.Reflection.Emit.ConstructorBuilder>。</span><span class="sxs-lookup"><span data-stu-id="43201-255">The following code sample demonstrates the use of `DefineConstructor` to set a constructor's particular signature and attributes on a dynamic type and return a corresponding <xref:System.Reflection.Emit.ConstructorBuilder> for MSIL population.</span></span>  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="43201-256">此父类型（基类型）没有无参数构造函数。</span><span class="sxs-lookup"><span data-stu-id="43201-256">The parent type (base type) does not have a parameterless constructor.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-257">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</span><span class="sxs-lookup"><span data-stu-id="43201-257">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="43201-258">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-258">-or-</span></span> 
<span data-ttu-id="43201-259">对于当前的动态类型，属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 的值为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 的值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43201-259">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.EventBuilder DefineEvent (string name, System.Reflection.EventAttributes attributes, Type eventtype);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.EventBuilder DefineEvent(string name, valuetype System.Reflection.EventAttributes attributes, class System.Type eventtype) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineEvent (name As String, attributes As EventAttributes, eventtype As Type) As EventBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::EventBuilder ^ DefineEvent(System::String ^ name, System::Reflection::EventAttributes attributes, Type ^ eventtype);" />
      <MemberSignature Language="F#" Value="member this.DefineEvent : string * System.Reflection.EventAttributes * Type -&gt; System.Reflection.Emit.EventBuilder" Usage="typeBuilder.DefineEvent (name, attributes, eventtype)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.EventBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.EventAttributes" />
        <Parameter Name="eventtype" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="43201-260">事件的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-260">The name of the event.</span></span> <span data-ttu-id="43201-261"><paramref name="name" /> 不能包含嵌入的 null。</span><span class="sxs-lookup"><span data-stu-id="43201-261"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="43201-262">事件的属性。</span><span class="sxs-lookup"><span data-stu-id="43201-262">The attributes of the event.</span></span></param>
        <param name="eventtype"><span data-ttu-id="43201-263">事件的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-263">The type of the event.</span></span></param>
        <summary><span data-ttu-id="43201-264">将新事件添加到该类型，使用给定的名称、属性和事件类型。</span><span class="sxs-lookup"><span data-stu-id="43201-264">Adds a new event to the type, with the given name, attributes and event type.</span></span></summary>
        <returns><span data-ttu-id="43201-265">已定义的事件。</span><span class="sxs-lookup"><span data-stu-id="43201-265">The defined event.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-266"><paramref name="name" /> 的长度为零。</span><span class="sxs-lookup"><span data-stu-id="43201-266">The length of <paramref name="name" /> is zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-267"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-267"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="43201-268">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-268">-or-</span></span> 
 <span data-ttu-id="43201-269"><paramref name="eventtype" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-269"><paramref name="eventtype" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-270">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</span><span class="sxs-lookup"><span data-stu-id="43201-270">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineField">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="43201-271">将新字段添加到动态类型。</span><span class="sxs-lookup"><span data-stu-id="43201-271">Adds a new field to the dynamic type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineField(System::String ^ fieldName, Type ^ type, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineField : string * Type * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="typeBuilder.DefineField (fieldName, type, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="fieldName"><span data-ttu-id="43201-272">字段的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-272">The name of the field.</span></span> <span data-ttu-id="43201-273"><paramref name="fieldName" /> 不能包含嵌入的 null。</span><span class="sxs-lookup"><span data-stu-id="43201-273"><paramref name="fieldName" /> cannot contain embedded nulls.</span></span></param>
        <param name="type"><span data-ttu-id="43201-274">字段的类型</span><span class="sxs-lookup"><span data-stu-id="43201-274">The type of the field</span></span></param>
        <param name="attributes"><span data-ttu-id="43201-275">字段的属性。</span><span class="sxs-lookup"><span data-stu-id="43201-275">The attributes of the field.</span></span></param>
        <summary><span data-ttu-id="43201-276">将新字段添加到该类型，其名称、属性和字段类型已给定。</span><span class="sxs-lookup"><span data-stu-id="43201-276">Adds a new field to the type, with the given name, attributes, and field type.</span></span></summary>
        <returns><span data-ttu-id="43201-277">已定义的字段。</span><span class="sxs-lookup"><span data-stu-id="43201-277">The defined field.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-278"><paramref name="fieldName" /> 的长度为零。</span><span class="sxs-lookup"><span data-stu-id="43201-278">The length of <paramref name="fieldName" /> is zero.</span></span>  
  
<span data-ttu-id="43201-279">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-279">-or-</span></span> 
 <span data-ttu-id="43201-280"><paramref name="type" /> 是 System.Void。</span><span class="sxs-lookup"><span data-stu-id="43201-280"><paramref name="type" /> is System.Void.</span></span>  
  
<span data-ttu-id="43201-281">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-281">-or-</span></span> 
<span data-ttu-id="43201-282">为此字段的父类指定了总大小。</span><span class="sxs-lookup"><span data-stu-id="43201-282">A total size was specified for the parent class of this field.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-283"><paramref name="fieldName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-283"><paramref name="fieldName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-284">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</span><span class="sxs-lookup"><span data-stu-id="43201-284">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, class System.Type[] requiredCustomModifiers, class System.Type[] optionalCustomModifiers, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineField(System::String ^ fieldName, Type ^ type, cli::array &lt;Type ^&gt; ^ requiredCustomModifiers, cli::array &lt;Type ^&gt; ^ optionalCustomModifiers, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineField : string * Type * Type[] * Type[] * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="typeBuilder.DefineField (fieldName, type, requiredCustomModifiers, optionalCustomModifiers, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fieldName"><span data-ttu-id="43201-285">字段的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-285">The name of the field.</span></span> <span data-ttu-id="43201-286"><paramref name="fieldName" /> 不能包含嵌入的 null。</span><span class="sxs-lookup"><span data-stu-id="43201-286"><paramref name="fieldName" /> cannot contain embedded nulls.</span></span></param>
        <param name="type"><span data-ttu-id="43201-287">字段的类型</span><span class="sxs-lookup"><span data-stu-id="43201-287">The type of the field</span></span></param>
        <param name="requiredCustomModifiers"><span data-ttu-id="43201-288">一个类型数组，表示字段所必需的自定义修饰符，如 <see cref="T:Microsoft.VisualC.IsConstModifier" />。</span><span class="sxs-lookup"><span data-stu-id="43201-288">An array of types representing the required custom modifiers for the field, such as <see cref="T:Microsoft.VisualC.IsConstModifier" />.</span></span></param>
        <param name="optionalCustomModifiers"><span data-ttu-id="43201-289">一个类型数组，表示字段可选的自定义修饰符，如 <see cref="T:Microsoft.VisualC.IsConstModifier" />。</span><span class="sxs-lookup"><span data-stu-id="43201-289">An array of types representing the optional custom modifiers for the field, such as <see cref="T:Microsoft.VisualC.IsConstModifier" />.</span></span></param>
        <param name="attributes"><span data-ttu-id="43201-290">字段的属性。</span><span class="sxs-lookup"><span data-stu-id="43201-290">The attributes of the field.</span></span></param>
        <summary><span data-ttu-id="43201-291">将新字段添加到该类型，其名称、属性、字段类型和自定义修饰符已给定。</span><span class="sxs-lookup"><span data-stu-id="43201-291">Adds a new field to the type, with the given name, attributes, field type, and custom modifiers.</span></span></summary>
        <returns><span data-ttu-id="43201-292">已定义的字段。</span><span class="sxs-lookup"><span data-stu-id="43201-292">The defined field.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-293">此重载是为托管编译器的设计器提供的。</span><span class="sxs-lookup"><span data-stu-id="43201-293">This overload is provided for designers of managed compilers.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-294"><paramref name="fieldName" /> 的长度为零。</span><span class="sxs-lookup"><span data-stu-id="43201-294">The length of <paramref name="fieldName" /> is zero.</span></span>  
  
<span data-ttu-id="43201-295">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-295">-or-</span></span> 
 <span data-ttu-id="43201-296"><paramref name="type" /> 是 System.Void。</span><span class="sxs-lookup"><span data-stu-id="43201-296"><paramref name="type" /> is System.Void.</span></span>  
  
<span data-ttu-id="43201-297">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-297">-or-</span></span> 
<span data-ttu-id="43201-298">为此字段的父类指定了总大小。</span><span class="sxs-lookup"><span data-stu-id="43201-298">A total size was specified for the parent class of this field.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-299"><paramref name="fieldName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-299"><paramref name="fieldName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-300">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</span><span class="sxs-lookup"><span data-stu-id="43201-300">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGenericParameters">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (params string[] names);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters(string[] names) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGenericParameters (ParamArray names As String()) As GenericTypeParameterBuilder()" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Emit::GenericTypeParameterBuilder ^&gt; ^ DefineGenericParameters(... cli::array &lt;System::String ^&gt; ^ names);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.DefineGenericParameters : string[] -&gt; System.Reflection.Emit.GenericTypeParameterBuilder[]" Usage="typeBuilder.DefineGenericParameters names" />
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (string[] names);" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGenericParameters (names As String()) As GenericTypeParameterBuilder()" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Emit::GenericTypeParameterBuilder ^&gt; ^ DefineGenericParameters(cli::array &lt;System::String ^&gt; ^ names);" FrameworkAlternate="xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.GenericTypeParameterBuilder[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="names" Type="System.String[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-1.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="names"><span data-ttu-id="43201-301">泛型类型参数的名称的数组。</span><span class="sxs-lookup"><span data-stu-id="43201-301">An array of names for the generic type parameters.</span></span></param>
        <summary><span data-ttu-id="43201-302">定义当前类型的泛型类型，指定其数量和名称并返回一个可用于设置其约束的 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="43201-302">Defines the generic type parameters for the current type, specifying their number and their names, and returns an array of <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objects that can be used to set their constraints.</span></span></summary>
        <returns><span data-ttu-id="43201-303"><see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 对象的一个数组，可用于定义当前类型的泛型类型参数的约束。</span><span class="sxs-lookup"><span data-stu-id="43201-303">An array of <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objects that can be used to define the constraints of the generic type parameters for the current type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-304">调用此方法会使当前类型成为泛型类型。</span><span class="sxs-lookup"><span data-stu-id="43201-304">Calling this method makes the current type a generic type.</span></span> <span data-ttu-id="43201-305">如果再次在同一类型上调用方法，则会引发 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="43201-305">If the method is called again on the same type, an <xref:System.InvalidOperationException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43201-306">下面的代码示例创建一个具有两个类型参数的泛型类型，并将它们保存在程序集 GenericEmitExample1 中。</span><span class="sxs-lookup"><span data-stu-id="43201-306">The following code example creates a generic type with two type parameters and saves them in the assembly GenericEmitExample1.dll.</span></span> <span data-ttu-id="43201-307">可以使用[Ildasm （IL 拆装器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)查看生成的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-307">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to view the generated types.</span></span> <span data-ttu-id="43201-308">有关定义动态泛型类型所涉及步骤的更详细说明，请参阅[如何：使用反射发出定义泛型类型](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md)。</span><span class="sxs-lookup"><span data-stu-id="43201-308">For a more detailed explanation of the steps involved in defining a dynamic generic type, see [How to: Define a Generic Type with Reflection Emit](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md).</span></span>  
  
 [!code-cpp[EmitGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR/EmitGenericType/CPP/source.cpp#1)]
 [!code-csharp[EmitGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR/EmitGenericType/CS/source.cs#1)]
 [!code-vb[EmitGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EmitGenericType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-309">已为此类型定义了泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="43201-309">Generic type parameters have already been defined for this type.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-310"><paramref name="names" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-310"><paramref name="names" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="43201-311">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-311">-or-</span></span> 
<span data-ttu-id="43201-312"><paramref name="names" /> 的元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-312">An element of <paramref name="names" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-313"><paramref name="names" /> 是一个空数组。</span><span class="sxs-lookup"><span data-stu-id="43201-313"><paramref name="names" /> is an empty array.</span></span></exception>
        <altmember cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
        <related type="Article" href="https://msdn.microsoft.com/library/07d5f01a-7b5b-40ea-9b15-f21561098fe4"><span data-ttu-id="43201-314">如何：用反射发出定义泛型类型</span><span class="sxs-lookup"><span data-stu-id="43201-314">How to: Define a Generic Type with Reflection Emit</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DefineInitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineInitializedData (string name, byte[] data, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineInitializedData(string name, unsigned int8[] data, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineInitializedData (name As String, data As Byte(), attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineInitializedData(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineInitializedData : string * byte[] * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="typeBuilder.DefineInitializedData (name, data, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="43201-315">用于引用数据的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-315">The name used to refer to the data.</span></span> <span data-ttu-id="43201-316"><paramref name="name" /> 不能包含嵌入的 null。</span><span class="sxs-lookup"><span data-stu-id="43201-316"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="data"><span data-ttu-id="43201-317">数据 blob。</span><span class="sxs-lookup"><span data-stu-id="43201-317">The blob of data.</span></span></param>
        <param name="attributes"><span data-ttu-id="43201-318">字段的属性。</span><span class="sxs-lookup"><span data-stu-id="43201-318">The attributes for the field.</span></span></param>
        <summary><span data-ttu-id="43201-319">在可移植可执行 (PE) 文件的 .sdata 部分定义已初始化的数据字段。</span><span class="sxs-lookup"><span data-stu-id="43201-319">Defines initialized data field in the .sdata section of the portable executable (PE) file.</span></span></summary>
        <returns><span data-ttu-id="43201-320">用于引用数据的字段。</span><span class="sxs-lookup"><span data-stu-id="43201-320">A field to reference the data.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-321">你用此方法创建的字段将被 `static`，即使在 `attributes` 参数中未包含 `FieldAttributes.Static` 也是如此。</span><span class="sxs-lookup"><span data-stu-id="43201-321">The field that you create with this method will be `static`, even if you do not include `FieldAttributes.Static` in the `attributes` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-322"><paramref name="name" /> 的长度为零。</span><span class="sxs-lookup"><span data-stu-id="43201-322">Length of <paramref name="name" /> is zero.</span></span>  
  
<span data-ttu-id="43201-323">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-323">-or-</span></span> 
<span data-ttu-id="43201-324">数据的大小小于或等于零，或者大于或等于 0x3f0000。</span><span class="sxs-lookup"><span data-stu-id="43201-324">The size of the data is less than or equal to zero, or greater than or equal to 0x3f0000.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-325"><paramref name="name" /> 或 <paramref name="data" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-325"><paramref name="name" /> or <paramref name="data" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-326"><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 以前被调用过。</span><span class="sxs-lookup"><span data-stu-id="43201-326"><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> has been previously called.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="43201-327">向类型添加一个方法。</span><span class="sxs-lookup"><span data-stu-id="43201-327">Adds a method to the type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="43201-328">方法的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-328">The name of the method.</span></span> <span data-ttu-id="43201-329"><paramref name="name" /> 不能包含嵌入的 null。</span><span class="sxs-lookup"><span data-stu-id="43201-329"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="43201-330">方法的属性。</span><span class="sxs-lookup"><span data-stu-id="43201-330">The attributes of the method.</span></span></param>
        <summary><span data-ttu-id="43201-331">向此类型添加新方法，使用指定的名称和方法属性。</span><span class="sxs-lookup"><span data-stu-id="43201-331">Adds a new method to the type, with the specified name and method attributes.</span></span></summary>
        <returns><span data-ttu-id="43201-332">表示新定义的方法的 <see cref="T:System.Reflection.Emit.MethodBuilder" />。</span><span class="sxs-lookup"><span data-stu-id="43201-332">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> representing the newly defined method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-333">如果在定义方法时不知道方法签名，请使用此方法重载。</span><span class="sxs-lookup"><span data-stu-id="43201-333">Use this method overload when you do not know the method signature at the time you define the method.</span></span> <span data-ttu-id="43201-334">例如，泛型方法的参数类型和返回类型可能由方法的泛型类型参数指定，该方法必须在方法添加到类型后定义。</span><span class="sxs-lookup"><span data-stu-id="43201-334">For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type.</span></span> <span data-ttu-id="43201-335">以后可以使用 <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> 方法设置方法的参数和返回类型。</span><span class="sxs-lookup"><span data-stu-id="43201-335">The parameters and return type of the method can be set later using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="43201-336">此方法重载定义 <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>的方法。</span><span class="sxs-lookup"><span data-stu-id="43201-336">This method overload defines a method with <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.</span></span> <span data-ttu-id="43201-337">如果需要使用不同的调用约定来定义没有签名的方法，请使用 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> 方法重载。</span><span class="sxs-lookup"><span data-stu-id="43201-337">If you need to define a method without a signature, with a different calling convention, use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43201-338">下面的代码示例定义了一个名为 `DemoMethod` 的泛型方法，该方法的参数类型和返回类型由其泛型类型参数指定。</span><span class="sxs-lookup"><span data-stu-id="43201-338">The following code example defines a generic method named `DemoMethod` whose parameter type and return type are specified by its generic type parameters.</span></span> <span data-ttu-id="43201-339">使用标准调用约定定义方法时不使用签名。</span><span class="sxs-lookup"><span data-stu-id="43201-339">The method is defined without a signature, using the standard calling convention.</span></span> <span data-ttu-id="43201-340"><xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> 方法用于使 `DemoMethod` 泛型方法，并将新定义的类型参数用于签名和返回类型。</span><span class="sxs-lookup"><span data-stu-id="43201-340">The <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method is used to make `DemoMethod` a generic method, and the newly defined type parameters are then used for the signature and return type.</span></span>  
  
 <span data-ttu-id="43201-341">此代码示例是为 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 方法提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="43201-341">This code example is part of a larger example provided for the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method.</span></span>  
  
 [!code-cpp[GenericMethodBuilder#4](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#4)]
 [!code-csharp[GenericMethodBuilder#4](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#4)]
 [!code-vb[GenericMethodBuilder#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#4)]  
[!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
[!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
[!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-342"><paramref name="name" /> 的长度为零。</span><span class="sxs-lookup"><span data-stu-id="43201-342">The length of <paramref name="name" /> is zero.</span></span>  
  
<span data-ttu-id="43201-343">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-343">-or-</span></span> 
<span data-ttu-id="43201-344">此方法的父类型是一个接口，并且此方法不是虚方法（Visual Basic 中为 <see langword="Overridable" />）。</span><span class="sxs-lookup"><span data-stu-id="43201-344">The type of the parent of this method is an interface, and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-345"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-345"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-346">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</span><span class="sxs-lookup"><span data-stu-id="43201-346">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="43201-347">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-347">-or-</span></span> 
<span data-ttu-id="43201-348">对于当前的动态类型，属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 的值为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 的值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43201-348">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes, callingConvention)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="43201-349">方法的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-349">The name of the method.</span></span> <span data-ttu-id="43201-350"><paramref name="name" /> 不能包含嵌入的 null。</span><span class="sxs-lookup"><span data-stu-id="43201-350"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="43201-351">方法的属性。</span><span class="sxs-lookup"><span data-stu-id="43201-351">The attributes of the method.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="43201-352">方法的调用约定。</span><span class="sxs-lookup"><span data-stu-id="43201-352">The calling convention of the method.</span></span></param>
        <summary><span data-ttu-id="43201-353">将具有指定的名称、 方法属性和调用约定的新方法添加到此类型。</span><span class="sxs-lookup"><span data-stu-id="43201-353">Adds a new method to the type, with the specified name, method attributes, and calling convention.</span></span></summary>
        <returns><span data-ttu-id="43201-354">表示新定义的方法的 <see cref="T:System.Reflection.Emit.MethodBuilder" />。</span><span class="sxs-lookup"><span data-stu-id="43201-354">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> representing the newly defined method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-355">如果在定义方法时不知道方法签名，请使用此方法重载。</span><span class="sxs-lookup"><span data-stu-id="43201-355">Use this method overload when you do not know the method signature at the time you define the method.</span></span> <span data-ttu-id="43201-356">例如，泛型方法的参数类型和返回类型可能由方法的泛型类型参数指定，该方法必须在方法添加到类型后定义。</span><span class="sxs-lookup"><span data-stu-id="43201-356">For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type.</span></span> <span data-ttu-id="43201-357">以后可以使用 <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> 方法设置方法的参数和返回类型。</span><span class="sxs-lookup"><span data-stu-id="43201-357">The parameters and return type of the method can be set later using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-358"><paramref name="name" /> 的长度为零。</span><span class="sxs-lookup"><span data-stu-id="43201-358">The length of <paramref name="name" /> is zero.</span></span>  
  
<span data-ttu-id="43201-359">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-359">-or-</span></span> 
<span data-ttu-id="43201-360">此方法的父类型是一个接口，并且此方法不是虚方法（Visual Basic 中为 <see langword="Overridable" />）。</span><span class="sxs-lookup"><span data-stu-id="43201-360">The type of the parent of this method is an interface and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-361"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-361"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-362">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</span><span class="sxs-lookup"><span data-stu-id="43201-362">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="43201-363">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-363">-or-</span></span> 
<span data-ttu-id="43201-364">对于当前的动态类型，属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 的值为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 的值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43201-364">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes * Type * Type[] -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="43201-365">方法的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-365">The name of the method.</span></span> <span data-ttu-id="43201-366"><paramref name="name" /> 不能包含嵌入的 null。</span><span class="sxs-lookup"><span data-stu-id="43201-366"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="43201-367">方法的属性。</span><span class="sxs-lookup"><span data-stu-id="43201-367">The attributes of the method.</span></span></param>
        <param name="returnType"><span data-ttu-id="43201-368">方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="43201-368">The return type of the method.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="43201-369">方法参数的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-369">The types of the parameters of the method.</span></span></param>
        <summary><span data-ttu-id="43201-370">向此类型添加新方法，并指定方法的名称、 属性和签名。</span><span class="sxs-lookup"><span data-stu-id="43201-370">Adds a new method to the type, with the specified name, method attributes, and method signature.</span></span></summary>
        <returns><span data-ttu-id="43201-371">已定义的方法。</span><span class="sxs-lookup"><span data-stu-id="43201-371">The defined method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="43201-372">下面的代码示例演示如何使用 `DefineMethod` 在动态类型上设置构造函数的特定签名和特性，并为 MSIL 填充返回相应的 <xref:System.Reflection.Emit.MethodBuilder>。</span><span class="sxs-lookup"><span data-stu-id="43201-372">The following code sample demonstrates the use of `DefineMethod` to set a constructor's particular signature and attributes on a dynamic type and to return a corresponding <xref:System.Reflection.Emit.MethodBuilder> for MSIL population.</span></span>  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-373"><paramref name="name" /> 的长度为零。</span><span class="sxs-lookup"><span data-stu-id="43201-373">The length of <paramref name="name" /> is zero.</span></span>  
  
<span data-ttu-id="43201-374">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-374">-or-</span></span> 
<span data-ttu-id="43201-375">此方法的父类型是一个接口，并且此方法不是虚方法（Visual Basic 中为 <see langword="Overridable" />）。</span><span class="sxs-lookup"><span data-stu-id="43201-375">The type of the parent of this method is an interface, and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-376"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-376"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-377">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</span><span class="sxs-lookup"><span data-stu-id="43201-377">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="43201-378">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-378">-or-</span></span> 
<span data-ttu-id="43201-379">对于当前的动态类型，属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 的值为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 的值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43201-379">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes, callingConvention, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="43201-380">方法的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-380">The name of the method.</span></span> <span data-ttu-id="43201-381"><paramref name="name" /> 不能包含嵌入的 null。</span><span class="sxs-lookup"><span data-stu-id="43201-381"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="43201-382">方法的属性。</span><span class="sxs-lookup"><span data-stu-id="43201-382">The attributes of the method.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="43201-383">方法的调用约定。</span><span class="sxs-lookup"><span data-stu-id="43201-383">The calling convention of the method.</span></span></param>
        <param name="returnType"><span data-ttu-id="43201-384">方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="43201-384">The return type of the method.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="43201-385">方法参数的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-385">The types of the parameters of the method.</span></span></param>
        <summary><span data-ttu-id="43201-386">使用指定的名称、方法属性、调用约定和方法签名向类型中添加新方法。</span><span class="sxs-lookup"><span data-stu-id="43201-386">Adds a new method to the type, with the specified name, method attributes, calling convention, and method signature.</span></span></summary>
        <returns><span data-ttu-id="43201-387">表示新定义的方法的 <see cref="T:System.Reflection.Emit.MethodBuilder" />。</span><span class="sxs-lookup"><span data-stu-id="43201-387">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> representing the newly defined method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="43201-388">下面的代码示例演示如何使用 `DefineMethod` 在动态类型上设置构造函数的特定签名和特性，并为 MSIL 填充返回相应的 <xref:System.Reflection.Emit.MethodBuilder>。</span><span class="sxs-lookup"><span data-stu-id="43201-388">The following code sample demonstrates the use of `DefineMethod` to set a constructor's particular signature and attributes on a dynamic type and to return a corresponding <xref:System.Reflection.Emit.MethodBuilder> for MSIL population.</span></span>  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-389"><paramref name="name" /> 的长度为零。</span><span class="sxs-lookup"><span data-stu-id="43201-389">The length of <paramref name="name" /> is zero.</span></span>  
  
<span data-ttu-id="43201-390">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-390">-or-</span></span> 
<span data-ttu-id="43201-391">此方法的父类型是一个接口，并且此方法不是虚方法（Visual Basic 中为 <see langword="Overridable" />）。</span><span class="sxs-lookup"><span data-stu-id="43201-391">The type of the parent of this method is an interface, and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-392"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-392"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-393">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</span><span class="sxs-lookup"><span data-stu-id="43201-393">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="43201-394">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-394">-or-</span></span> 
<span data-ttu-id="43201-395">对于当前的动态类型，属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 的值为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 的值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43201-395">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type[] * Type[] * Type[][] * Type[][] -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameterTypes" Type="System.Type[]" Index="6" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" Index="7" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" Index="8" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="43201-396">方法的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-396">The name of the method.</span></span> <span data-ttu-id="43201-397"><paramref name="name" /> 不能包含嵌入的 null。</span><span class="sxs-lookup"><span data-stu-id="43201-397"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="43201-398">方法的属性。</span><span class="sxs-lookup"><span data-stu-id="43201-398">The attributes of the method.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="43201-399">方法的调用约定。</span><span class="sxs-lookup"><span data-stu-id="43201-399">The calling convention of the method.</span></span></param>
        <param name="returnType"><span data-ttu-id="43201-400">方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="43201-400">The return type of the method.</span></span></param>
        <param name="returnTypeRequiredCustomModifiers"><span data-ttu-id="43201-401">一个类型数组，表示该方法的返回类型所必需的自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span><span class="sxs-lookup"><span data-stu-id="43201-401">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span></span> <span data-ttu-id="43201-402">如果返回类型没有所需的自定义修饰符，则指定 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-402">If the return type has no required custom modifiers, specify <see langword="null" />.</span></span></param>
        <param name="returnTypeOptionalCustomModifiers"><span data-ttu-id="43201-403">一个类型数组，表示该方法的返回类型的可选自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span><span class="sxs-lookup"><span data-stu-id="43201-403">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span></span> <span data-ttu-id="43201-404">如果返回类型没有可选的自定义修饰符，则指定 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-404">If the return type has no optional custom modifiers, specify <see langword="null" />.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="43201-405">方法参数的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-405">The types of the parameters of the method.</span></span></param>
        <param name="parameterTypeRequiredCustomModifiers"><span data-ttu-id="43201-406">由类型数组组成的数组。</span><span class="sxs-lookup"><span data-stu-id="43201-406">An array of arrays of types.</span></span> <span data-ttu-id="43201-407">每个类型数组均表示相应参数所必需的自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span><span class="sxs-lookup"><span data-stu-id="43201-407">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="43201-408">如果某个特定参数没有所需的自定义修饰符，则指定 <see langword="null" />，而不要指定类型数组。</span><span class="sxs-lookup"><span data-stu-id="43201-408">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="43201-409">如果所有参数都没有所需的自定义修饰符，则指定 <see langword="null" />，而不要指定由数组组成的数组。</span><span class="sxs-lookup"><span data-stu-id="43201-409">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <param name="parameterTypeOptionalCustomModifiers"><span data-ttu-id="43201-410">由类型数组组成的数组。</span><span class="sxs-lookup"><span data-stu-id="43201-410">An array of arrays of types.</span></span> <span data-ttu-id="43201-411">每个类型数组均表示相应参数的可选自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span><span class="sxs-lookup"><span data-stu-id="43201-411">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="43201-412">如果某个特定参数没有可选的自定义修饰符，则指定 <see langword="null" />，而不要指定类型数组。</span><span class="sxs-lookup"><span data-stu-id="43201-412">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="43201-413">如果所有参数都没有可选的自定义修饰符，则指定 <see langword="null" />，而不要指定由数组组成的数组。</span><span class="sxs-lookup"><span data-stu-id="43201-413">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <summary><span data-ttu-id="43201-414">使用指定名称、方法属性、调用约定、方法签名和自定义修饰符向类型中添加新方法。</span><span class="sxs-lookup"><span data-stu-id="43201-414">Adds a new method to the type, with the specified name, method attributes, calling convention, method signature, and custom modifiers.</span></span></summary>
        <returns><span data-ttu-id="43201-415">一个表示新添加方法的 <see cref="T:System.Reflection.Emit.MethodBuilder" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="43201-415">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> object representing the newly added method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-416">如果需要指定自定义修饰符，请使用此重载。</span><span class="sxs-lookup"><span data-stu-id="43201-416">Use this overload if you need to specify custom modifiers.</span></span> <span data-ttu-id="43201-417">如果在创建方法之后需要指定自定义修饰符（例如，使用其参数类型由其泛型类型参数指定的泛型方法），则可以使用 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> 或 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> 方法重载来定义方法，然后使用 <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> 方法定义参数并返回具有自定义修饰符的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-417">If you need to specify custom modifiers after the method has been created, as you would, for example, with a generic method whose parameter types are specified by its generic type parameters, you can use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> or <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> method overloads to define the method and then use the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method to define the parameter and return types with custom modifiers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="43201-418">有关自定义修饰符的详细信息，请参阅 ECMA Partition II 元数据文档。</span><span class="sxs-lookup"><span data-stu-id="43201-418">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="43201-419">可联机获取该文档；请参阅 MSDN 上的 [ECMA C# 和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)和 Ecma International 网站上的[标准 ECMA-335 - 公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)。</span><span class="sxs-lookup"><span data-stu-id="43201-419">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-420"><paramref name="name" /> 的长度为零。</span><span class="sxs-lookup"><span data-stu-id="43201-420">The length of <paramref name="name" /> is zero.</span></span>  
  
<span data-ttu-id="43201-421">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-421">-or-</span></span> 
<span data-ttu-id="43201-422">此方法的父类型是一个接口，并且此方法不是虚方法（Visual Basic 中为 <see langword="Overridable" />）。</span><span class="sxs-lookup"><span data-stu-id="43201-422">The type of the parent of this method is an interface, and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span></span>  
  
<span data-ttu-id="43201-423">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-423">-or-</span></span> 
<span data-ttu-id="43201-424"><paramref name="parameterTypeRequiredCustomModifiers" /> 或 <paramref name="parameterTypeOptionalCustomModifiers" /> 的大小与 <paramref name="parameterTypes" /> 的大小不相等。</span><span class="sxs-lookup"><span data-stu-id="43201-424">The size of <paramref name="parameterTypeRequiredCustomModifiers" /> or <paramref name="parameterTypeOptionalCustomModifiers" /> does not equal the size of <paramref name="parameterTypes" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-425"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-425"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-426">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</span><span class="sxs-lookup"><span data-stu-id="43201-426">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="43201-427">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-427">-or-</span></span> 
<span data-ttu-id="43201-428">对于当前的动态类型，属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 的值为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 的值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43201-428">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethodOverride">
      <MemberSignature Language="C#" Value="public void DefineMethodOverride (System.Reflection.MethodInfo methodInfoBody, System.Reflection.MethodInfo methodInfoDeclaration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineMethodOverride(class System.Reflection.MethodInfo methodInfoBody, class System.Reflection.MethodInfo methodInfoDeclaration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DefineMethodOverride (methodInfoBody As MethodInfo, methodInfoDeclaration As MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefineMethodOverride(System::Reflection::MethodInfo ^ methodInfoBody, System::Reflection::MethodInfo ^ methodInfoDeclaration);" />
      <MemberSignature Language="F#" Value="member this.DefineMethodOverride : System.Reflection.MethodInfo * System.Reflection.MethodInfo -&gt; unit" Usage="typeBuilder.DefineMethodOverride (methodInfoBody, methodInfoDeclaration)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodInfoBody" Type="System.Reflection.MethodInfo" />
        <Parameter Name="methodInfoDeclaration" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="methodInfoBody"><span data-ttu-id="43201-429">要使用的方法体。</span><span class="sxs-lookup"><span data-stu-id="43201-429">The method body to be used.</span></span> <span data-ttu-id="43201-430">应当为 <see langword="MethodBuilder" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="43201-430">This should be a <see langword="MethodBuilder" /> object.</span></span></param>
        <param name="methodInfoDeclaration"><span data-ttu-id="43201-431">要使用其声明的方法。</span><span class="sxs-lookup"><span data-stu-id="43201-431">The method whose declaration is to be used.</span></span></param>
        <summary><span data-ttu-id="43201-432">指定实现给定方法声明的给定方法体（可能使用其他名称）。</span><span class="sxs-lookup"><span data-stu-id="43201-432">Specifies a given method body that implements a given method declaration, potentially with a different name.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-433">不要使用此方法发出方法重写或接口实现。</span><span class="sxs-lookup"><span data-stu-id="43201-433">Do not use this method to emit method overrides or interface implementations.</span></span> <span data-ttu-id="43201-434">若要重写基类的方法或实现接口的方法，只需使用与要重写或实现的方法相同的名称和签名发出方法，如代码示例中所示。</span><span class="sxs-lookup"><span data-stu-id="43201-434">To override a method of a base class or to implement a method of an interface, simply emit a method with the same name and signature as the method to be overridden or implemented, as demonstrated in the code example.</span></span>  
  
 <span data-ttu-id="43201-435">当方法体和方法声明具有不同的名称时，将使用 <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="43201-435">The <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> method is used when a method body and a method declaration have different names.</span></span> <span data-ttu-id="43201-436">例如，类可以重写基类方法，还可以为具有相同名称的接口成员提供单独的实现，如代码示例中所示。</span><span class="sxs-lookup"><span data-stu-id="43201-436">For example, a class might override a base class method and also provide a separate implementation for an interface member with the same name, as demonstrated in the code example.</span></span>  
  
 <span data-ttu-id="43201-437">`DefineMethodOverride` 定义 `methodimpl`，它包含一对元数据标记。</span><span class="sxs-lookup"><span data-stu-id="43201-437">`DefineMethodOverride` defines a `methodimpl`, which consists of a pair of metadata tokens.</span></span> <span data-ttu-id="43201-438">一个标记指向实现，另一个标记指向主体实现的声明。</span><span class="sxs-lookup"><span data-stu-id="43201-438">One token points to an implementation, and the other token points to a declaration that the body implements.</span></span> <span data-ttu-id="43201-439">主体必须在 impl 定义的类型上定义，并且正文必须为虚拟（`Overridable` Visual Basic）。</span><span class="sxs-lookup"><span data-stu-id="43201-439">The body must be defined on the type the method impl is defined on, and the body must be virtual (`Overridable` in Visual Basic).</span></span> <span data-ttu-id="43201-440">声明可对由类型实现的接口、派生类上的方法或在类型中定义的方法进行定义。</span><span class="sxs-lookup"><span data-stu-id="43201-440">The declaration can be made to a method defined on an interface implemented by the type, a method on a derived class, or a method defined in the type.</span></span> <span data-ttu-id="43201-441">如果该声明仅位于某个接口上，则更改为该接口定义的槽。</span><span class="sxs-lookup"><span data-stu-id="43201-441">If the declaration is on an interface only, the slot defined for the interface is altered.</span></span> <span data-ttu-id="43201-442">如果对基类型的方法进行声明，则会重写该方法的槽并替换重写方法的任何重复项。</span><span class="sxs-lookup"><span data-stu-id="43201-442">If the declaration is made to a method on a base type, the slot for the method is overridden and any duplicates for the overridden method are also replaced.</span></span> <span data-ttu-id="43201-443">重写的方法不能是声明的实际方法。</span><span class="sxs-lookup"><span data-stu-id="43201-443">The overridden method cannot be the actual method that is declared.</span></span> <span data-ttu-id="43201-444">如果方法在同一类型上，则将替换槽，并覆盖替换的方法的任何重复项。</span><span class="sxs-lookup"><span data-stu-id="43201-444">If the method is on the same type, the slot is replaced and any duplicates for the replaced methods are overridden.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="43201-445">有关方法 impls 的详细信息，请参阅 ECMA Partition II 元数据文档中的 `MethodImpl`。</span><span class="sxs-lookup"><span data-stu-id="43201-445">For more information about method impls, see `MethodImpl` in the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="43201-446">可联机获取该文档；请参阅 MSDN 上的 [ECMA C# 和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)和 Ecma International 网站上的[标准 ECMA-335 - 公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)。</span><span class="sxs-lookup"><span data-stu-id="43201-446">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="43201-447">调用 <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> 方法后，无法更改 `methodInfoBody` 的某些功能。</span><span class="sxs-lookup"><span data-stu-id="43201-447">After the <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> method is called, some features of `methodInfoBody` cannot be changed.</span></span> <span data-ttu-id="43201-448">例如，不能通过使用 <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> 方法将特性应用于 `methodInfoBody` 的泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="43201-448">For example, you cannot apply an attribute to a generic type parameter of `methodInfoBody` by using the <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> method.</span></span> <span data-ttu-id="43201-449">如果必须使用 <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> 方法，请在定义 `methodInfoBody` 的所有特性后执行此操作。</span><span class="sxs-lookup"><span data-stu-id="43201-449">If you must use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> method, do so after all characteristics of `methodInfoBody` have been defined.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43201-450">下面的代码示例包含一个接口 `I`，其中包含一个方法 `M()`，一个实现接口的基类 `A`，另一个派生类 `C` 用于重写 `M()` 的基类实现，并且还提供 `I.M()`的单独显式实现。</span><span class="sxs-lookup"><span data-stu-id="43201-450">The following code example contains an interface `I` with a method `M()`, a base class `A` that implements the interface, and a derived class `C` that overrides the base class implementation of `M()` and also provides a separate explicit implementation of `I.M()`.</span></span>  
  
 <span data-ttu-id="43201-451">代码示例的 `main()` 方法说明了如何 `C`发出派生类。</span><span class="sxs-lookup"><span data-stu-id="43201-451">The `main()` method of the code example shows how to emit the derived class `C`.</span></span> <span data-ttu-id="43201-452">只需使用同一签名发出 `M()` 方法，即可实现 `A.M()` 的重写。</span><span class="sxs-lookup"><span data-stu-id="43201-452">The override of `A.M()` is accomplished simply by emitting a method `M()` with the same signature.</span></span> <span data-ttu-id="43201-453">但是，若要提供 `I.M()`的单独实现，必须定义一个方法体，然后使用 <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> 方法将该方法体与表示 `I.M()`的 <xref:System.Reflection.MethodInfo> 相关联。</span><span class="sxs-lookup"><span data-stu-id="43201-453">However, to provide a separate implementation of `I.M()`, you must define a method body and then use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> method to associate that method body with a <xref:System.Reflection.MethodInfo> representing `I.M()`.</span></span> <span data-ttu-id="43201-454">方法体的名称并不重要。</span><span class="sxs-lookup"><span data-stu-id="43201-454">The name of the method body does not matter.</span></span>  
  
 <span data-ttu-id="43201-455">此代码示例创建已发出的类的实例。</span><span class="sxs-lookup"><span data-stu-id="43201-455">The code example creates an instance of the emitted class.</span></span> <span data-ttu-id="43201-456">它获取 `I.M()`的 <xref:System.Reflection.MethodInfo> 对象，并使用它来调用发出的类的显式接口实现。</span><span class="sxs-lookup"><span data-stu-id="43201-456">It obtains a <xref:System.Reflection.MethodInfo> object for `I.M()`, and uses it to invoke the emitted class's explicit interface implementation.</span></span> <span data-ttu-id="43201-457">然后，它获取 `A.M()`的 <xref:System.Reflection.MethodInfo> 对象，并使用它来调用该方法的已发出类的重写。</span><span class="sxs-lookup"><span data-stu-id="43201-457">It then obtains a <xref:System.Reflection.MethodInfo> object for `A.M()`, and uses it to invoke the emitted class's override of that method.</span></span>  
  
 [!code-cpp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cpp/source.cpp#1)]
 [!code-csharp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cs/source.cs#1)]
 [!code-vb[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-458"><paramref name="methodInfoBody" /> 不属于此类。</span><span class="sxs-lookup"><span data-stu-id="43201-458"><paramref name="methodInfoBody" /> does not belong to this class.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-459"><paramref name="methodInfoBody" /> 或 <paramref name="methodInfoDeclaration" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-459"><paramref name="methodInfoBody" /> or <paramref name="methodInfoDeclaration" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-460">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</span><span class="sxs-lookup"><span data-stu-id="43201-460">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="43201-461">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-461">-or-</span></span> 
<span data-ttu-id="43201-462"><paramref name="methodInfoBody" /> 的声明类型不是此 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 表示的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-462">The declaring type of <paramref name="methodInfoBody" /> is not the type represented by this <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineNestedType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="43201-463">定义嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-463">Defines a nested type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="43201-464">类型的短名称。</span><span class="sxs-lookup"><span data-stu-id="43201-464">The short name of the type.</span></span> <span data-ttu-id="43201-465"><paramref name="name" /> 不能包含嵌入的 null。</span><span class="sxs-lookup"><span data-stu-id="43201-465"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <summary><span data-ttu-id="43201-466">定义嵌套的类型，并给定其名称。</span><span class="sxs-lookup"><span data-stu-id="43201-466">Defines a nested type, given its name.</span></span></summary>
        <returns><span data-ttu-id="43201-467">已定义的嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-467">The defined nested type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-468">即使已对封闭类型调用 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 方法，也可以使用此方法创建嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-468">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="43201-469">嵌套类型需要先完成，然后才能使用 <xref:System.Type.GetMembers%2A>、<xref:System.Type.GetNestedType%2A>或 <xref:System.Type.GetNestedTypes%2A>进行反射。</span><span class="sxs-lookup"><span data-stu-id="43201-469">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="43201-470">请参阅 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 的说明，了解应如何完成嵌套类型和嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-470">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="43201-471">如果 `name` 与以前定义的类型或嵌套类型的名称相同，则不一定会创建重复的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-471">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="43201-472">若要进行重复，全名必须相同，包括命名空间和所有嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-472">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-473"><paramref name="name" /> 长度为零或大于 1023。</span><span class="sxs-lookup"><span data-stu-id="43201-473">Length of <paramref name="name" /> is zero or greater than 1023.</span></span>  
  
<span data-ttu-id="43201-474">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-474">-or-</span></span> 
<span data-ttu-id="43201-475">此操作将在当前程序集中创建一个具有重复 <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-475">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-476"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-476"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="43201-477">类型的短名称。</span><span class="sxs-lookup"><span data-stu-id="43201-477">The short name of the type.</span></span> <span data-ttu-id="43201-478"><paramref name="name" /> 不能包含嵌入的 null。</span><span class="sxs-lookup"><span data-stu-id="43201-478"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attr"><span data-ttu-id="43201-479">此类型的属性。</span><span class="sxs-lookup"><span data-stu-id="43201-479">The attributes of the type.</span></span></param>
        <summary><span data-ttu-id="43201-480">已知名称和属性，定义嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-480">Defines a nested type, given its name and attributes.</span></span></summary>
        <returns><span data-ttu-id="43201-481">已定义的嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-481">The defined nested type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-482">即使已对封闭类型调用 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 方法，也可以使用此方法创建嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-482">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="43201-483">嵌套类型需要先完成，然后才能使用 <xref:System.Type.GetMembers%2A>、<xref:System.Type.GetNestedType%2A>或 <xref:System.Type.GetNestedTypes%2A>进行反射。</span><span class="sxs-lookup"><span data-stu-id="43201-483">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="43201-484">请参阅 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 的说明，了解应如何完成嵌套类型和嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-484">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="43201-485">如果 `name` 与以前定义的类型或嵌套类型的名称相同，则不一定会创建重复的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-485">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="43201-486">若要进行重复，全名必须相同，包括命名空间和所有嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-486">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-487">未指定嵌套属性。</span><span class="sxs-lookup"><span data-stu-id="43201-487">The nested attribute is not specified.</span></span>  
  
<span data-ttu-id="43201-488">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-488">-or-</span></span> 
<span data-ttu-id="43201-489">此类型已密封。</span><span class="sxs-lookup"><span data-stu-id="43201-489">This type is sealed.</span></span>  
  
<span data-ttu-id="43201-490">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-490">-or-</span></span> 
<span data-ttu-id="43201-491">此类型是一个数组。</span><span class="sxs-lookup"><span data-stu-id="43201-491">This type is an array.</span></span>  
  
<span data-ttu-id="43201-492">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-492">-or-</span></span> 
<span data-ttu-id="43201-493">此类型是一个接口，但嵌套类型不是一个接口。</span><span class="sxs-lookup"><span data-stu-id="43201-493">This type is an interface, but the nested type is not an interface.</span></span>  
  
<span data-ttu-id="43201-494">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-494">-or-</span></span> 
<span data-ttu-id="43201-495"><paramref name="name" /> 的长度为零或大于 1023。</span><span class="sxs-lookup"><span data-stu-id="43201-495">The length of <paramref name="name" /> is zero or greater than 1023.</span></span>  
  
<span data-ttu-id="43201-496">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-496">-or-</span></span> 
<span data-ttu-id="43201-497">此操作将在当前程序集中创建一个具有重复 <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-497">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-498"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-498"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="43201-499">类型的短名称。</span><span class="sxs-lookup"><span data-stu-id="43201-499">The short name of the type.</span></span> <span data-ttu-id="43201-500"><paramref name="name" /> 不能包含嵌入的 null。</span><span class="sxs-lookup"><span data-stu-id="43201-500"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attr"><span data-ttu-id="43201-501">此类型的属性。</span><span class="sxs-lookup"><span data-stu-id="43201-501">The attributes of the type.</span></span></param>
        <param name="parent"><span data-ttu-id="43201-502">此嵌套类型扩展的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-502">The type that the nested type extends.</span></span></param>
        <summary><span data-ttu-id="43201-503">定义嵌套类型，其名称、属性以及它所扩展的类型已给定。</span><span class="sxs-lookup"><span data-stu-id="43201-503">Defines a nested type, given its name, attributes, and the type that it extends.</span></span></summary>
        <returns><span data-ttu-id="43201-504">已定义的嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-504">The defined nested type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-505">即使已对封闭类型调用 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 方法，也可以使用此方法创建嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-505">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="43201-506">嵌套类型需要先完成，然后才能使用 <xref:System.Type.GetMembers%2A>、<xref:System.Type.GetNestedType%2A>或 <xref:System.Type.GetNestedTypes%2A>进行反射。</span><span class="sxs-lookup"><span data-stu-id="43201-506">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="43201-507">请参阅 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 的说明，了解应如何完成嵌套类型和嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-507">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="43201-508">如果 `name` 与以前定义的类型或嵌套类型的名称相同，则不一定会创建重复的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-508">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="43201-509">若要进行重复，全名必须相同，包括命名空间和所有嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-509">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-510">未指定嵌套属性。</span><span class="sxs-lookup"><span data-stu-id="43201-510">The nested attribute is not specified.</span></span>  
  
<span data-ttu-id="43201-511">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-511">-or-</span></span> 
<span data-ttu-id="43201-512">此类型已密封。</span><span class="sxs-lookup"><span data-stu-id="43201-512">This type is sealed.</span></span>  
  
<span data-ttu-id="43201-513">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-513">-or-</span></span> 
<span data-ttu-id="43201-514">此类型是一个数组。</span><span class="sxs-lookup"><span data-stu-id="43201-514">This type is an array.</span></span>  
  
<span data-ttu-id="43201-515">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-515">-or-</span></span> 
<span data-ttu-id="43201-516">此类型是一个接口，但嵌套类型不是一个接口。</span><span class="sxs-lookup"><span data-stu-id="43201-516">This type is an interface, but the nested type is not an interface.</span></span>  
  
<span data-ttu-id="43201-517">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-517">-or-</span></span> 
<span data-ttu-id="43201-518"><paramref name="name" /> 的长度为零或大于 1023。</span><span class="sxs-lookup"><span data-stu-id="43201-518">The length of <paramref name="name" /> is zero or greater than 1023.</span></span>  
  
<span data-ttu-id="43201-519">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-519">-or-</span></span> 
<span data-ttu-id="43201-520">此操作将在当前程序集中创建一个具有重复 <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-520">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-521"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-521"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, typeSize As Integer) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, int typeSize);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type * int -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent, typeSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="typeSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="43201-522">类型的短名称。</span><span class="sxs-lookup"><span data-stu-id="43201-522">The short name of the type.</span></span> <span data-ttu-id="43201-523"><paramref name="name" /> 不能包含嵌入的 null。</span><span class="sxs-lookup"><span data-stu-id="43201-523"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attr"><span data-ttu-id="43201-524">此类型的属性。</span><span class="sxs-lookup"><span data-stu-id="43201-524">The attributes of the type.</span></span></param>
        <param name="parent"><span data-ttu-id="43201-525">此嵌套类型扩展的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-525">The type that the nested type extends.</span></span></param>
        <param name="typeSize"><span data-ttu-id="43201-526">此类型的总大小。</span><span class="sxs-lookup"><span data-stu-id="43201-526">The total size of the type.</span></span></param>
        <summary><span data-ttu-id="43201-527">定义嵌套类型，其名称、属性、该类型的总大小以及它所扩展的类型已给定。</span><span class="sxs-lookup"><span data-stu-id="43201-527">Defines a nested type, given its name, attributes, the total size of the type, and the type that it extends.</span></span></summary>
        <returns><span data-ttu-id="43201-528">已定义的嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-528">The defined nested type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-529">即使已对封闭类型调用 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 方法，也可以使用此方法创建嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-529">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="43201-530">嵌套类型需要先完成，然后才能使用 <xref:System.Type.GetMembers%2A>、<xref:System.Type.GetNestedType%2A>或 <xref:System.Type.GetNestedTypes%2A>进行反射。</span><span class="sxs-lookup"><span data-stu-id="43201-530">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="43201-531">请参阅 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 的说明，了解应如何完成嵌套类型和嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-531">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="43201-532">如果 `name` 与以前定义的类型或嵌套类型的名称相同，则不一定会创建重复的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-532">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="43201-533">若要进行重复，全名必须相同，包括命名空间和所有嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-533">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-534">未指定嵌套属性。</span><span class="sxs-lookup"><span data-stu-id="43201-534">The nested attribute is not specified.</span></span>  
  
<span data-ttu-id="43201-535">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-535">-or-</span></span> 
<span data-ttu-id="43201-536">此类型已密封。</span><span class="sxs-lookup"><span data-stu-id="43201-536">This type is sealed.</span></span>  
  
<span data-ttu-id="43201-537">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-537">-or-</span></span> 
<span data-ttu-id="43201-538">此类型是一个数组。</span><span class="sxs-lookup"><span data-stu-id="43201-538">This type is an array.</span></span>  
  
<span data-ttu-id="43201-539">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-539">-or-</span></span> 
<span data-ttu-id="43201-540">此类型是一个接口，但嵌套类型不是一个接口。</span><span class="sxs-lookup"><span data-stu-id="43201-540">This type is an interface, but the nested type is not an interface.</span></span>  
  
<span data-ttu-id="43201-541">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-541">-or-</span></span> 
<span data-ttu-id="43201-542"><paramref name="name" /> 的长度为零或大于 1023。</span><span class="sxs-lookup"><span data-stu-id="43201-542">The length of <paramref name="name" /> is zero or greater than 1023.</span></span>  
  
<span data-ttu-id="43201-543">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-543">-or-</span></span> 
<span data-ttu-id="43201-544">此操作将在当前程序集中创建一个具有重复 <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-544">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-545"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-545"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, packSize As PackingSize) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packSize);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type * System.Reflection.Emit.PackingSize -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent, packSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="43201-546">类型的短名称。</span><span class="sxs-lookup"><span data-stu-id="43201-546">The short name of the type.</span></span> <span data-ttu-id="43201-547"><paramref name="name" /> 不能包含嵌入的 null。</span><span class="sxs-lookup"><span data-stu-id="43201-547"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attr"><span data-ttu-id="43201-548">此类型的属性。</span><span class="sxs-lookup"><span data-stu-id="43201-548">The attributes of the type.</span></span></param>
        <param name="parent"><span data-ttu-id="43201-549">此嵌套类型扩展的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-549">The type that the nested type extends.</span></span></param>
        <param name="packSize"><span data-ttu-id="43201-550">此类型的封装大小。</span><span class="sxs-lookup"><span data-stu-id="43201-550">The packing size of the type.</span></span></param>
        <summary><span data-ttu-id="43201-551">定义嵌套类型，其名称、属性、它所扩展的类型以及封装大小已给定。</span><span class="sxs-lookup"><span data-stu-id="43201-551">Defines a nested type, given its name, attributes, the type that it extends, and the packing size.</span></span></summary>
        <returns><span data-ttu-id="43201-552">已定义的嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-552">The defined nested type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-553">即使已对封闭类型调用 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 方法，也可以使用此方法创建嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-553">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="43201-554">嵌套类型需要先完成，然后才能使用 <xref:System.Type.GetMembers%2A>、<xref:System.Type.GetNestedType%2A>或 <xref:System.Type.GetNestedTypes%2A>进行反射。</span><span class="sxs-lookup"><span data-stu-id="43201-554">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="43201-555">请参阅 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 的说明，了解应如何完成嵌套类型和嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-555">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="43201-556">如果 `name` 与以前定义的类型或嵌套类型的名称相同，则不一定会创建重复的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-556">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="43201-557">若要进行重复，全名必须相同，包括命名空间和所有嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-557">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-558">未指定嵌套属性。</span><span class="sxs-lookup"><span data-stu-id="43201-558">The nested attribute is not specified.</span></span>  
  
<span data-ttu-id="43201-559">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-559">-or-</span></span> 
<span data-ttu-id="43201-560">此类型已密封。</span><span class="sxs-lookup"><span data-stu-id="43201-560">This type is sealed.</span></span>  
  
<span data-ttu-id="43201-561">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-561">-or-</span></span> 
<span data-ttu-id="43201-562">此类型是一个数组。</span><span class="sxs-lookup"><span data-stu-id="43201-562">This type is an array.</span></span>  
  
<span data-ttu-id="43201-563">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-563">-or-</span></span> 
<span data-ttu-id="43201-564">此类型是一个接口，但嵌套类型不是一个接口。</span><span class="sxs-lookup"><span data-stu-id="43201-564">This type is an interface, but the nested type is not an interface.</span></span>  
  
<span data-ttu-id="43201-565">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-565">-or-</span></span> 
<span data-ttu-id="43201-566"><paramref name="name" /> 的长度为零或大于 1023。</span><span class="sxs-lookup"><span data-stu-id="43201-566">The length of <paramref name="name" /> is zero or greater than 1023.</span></span>  
  
<span data-ttu-id="43201-567">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-567">-or-</span></span> 
<span data-ttu-id="43201-568">此操作将在当前程序集中创建一个具有重复 <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-568">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-569"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-569"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, Type[] interfaces);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, class System.Type[] interfaces) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, interfaces As Type()) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, cli::array &lt;Type ^&gt; ^ interfaces);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type * Type[] -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent, interfaces)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="interfaces" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="43201-570">类型的短名称。</span><span class="sxs-lookup"><span data-stu-id="43201-570">The short name of the type.</span></span> <span data-ttu-id="43201-571"><paramref name="name" /> 不能包含嵌入的 null。</span><span class="sxs-lookup"><span data-stu-id="43201-571"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attr"><span data-ttu-id="43201-572">此类型的属性。</span><span class="sxs-lookup"><span data-stu-id="43201-572">The attributes of the type.</span></span></param>
        <param name="parent"><span data-ttu-id="43201-573">此嵌套类型扩展的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-573">The type that the nested type extends.</span></span></param>
        <param name="interfaces"><span data-ttu-id="43201-574">此嵌套类型实现的接口。</span><span class="sxs-lookup"><span data-stu-id="43201-574">The interfaces that the nested type implements.</span></span></param>
        <summary><span data-ttu-id="43201-575">定义嵌套类型，其名称、属性、它所扩展的类型以及它所实现的接口已给定。</span><span class="sxs-lookup"><span data-stu-id="43201-575">Defines a nested type, given its name, attributes, the type that it extends, and the interfaces that it implements.</span></span></summary>
        <returns><span data-ttu-id="43201-576">已定义的嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-576">The defined nested type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-577">即使已对封闭类型调用 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 方法，也可以使用此方法创建嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-577">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="43201-578">嵌套类型需要先完成，然后才能使用 <xref:System.Type.GetMembers%2A>、<xref:System.Type.GetNestedType%2A>或 <xref:System.Type.GetNestedTypes%2A>进行反射。</span><span class="sxs-lookup"><span data-stu-id="43201-578">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="43201-579">请参阅 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 的说明，了解应如何完成嵌套类型和嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-579">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="43201-580">如果 `name` 与以前定义的类型或嵌套类型的名称相同，则不一定会创建重复的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-580">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="43201-581">若要进行重复，全名必须相同，包括命名空间和所有嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-581">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-582">未指定嵌套属性。</span><span class="sxs-lookup"><span data-stu-id="43201-582">The nested attribute is not specified.</span></span>  
  
<span data-ttu-id="43201-583">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-583">-or-</span></span> 
<span data-ttu-id="43201-584">此类型已密封。</span><span class="sxs-lookup"><span data-stu-id="43201-584">This type is sealed.</span></span>  
  
<span data-ttu-id="43201-585">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-585">-or-</span></span> 
<span data-ttu-id="43201-586">此类型是一个数组。</span><span class="sxs-lookup"><span data-stu-id="43201-586">This type is an array.</span></span>  
  
<span data-ttu-id="43201-587">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-587">-or-</span></span> 
<span data-ttu-id="43201-588">此类型是一个接口，但嵌套类型不是一个接口。</span><span class="sxs-lookup"><span data-stu-id="43201-588">This type is an interface, but the nested type is not an interface.</span></span>  
  
<span data-ttu-id="43201-589">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-589">-or-</span></span> 
<span data-ttu-id="43201-590"><paramref name="name" /> 的长度为零或大于 1023。</span><span class="sxs-lookup"><span data-stu-id="43201-590">The length of <paramref name="name" /> is zero or greater than 1023.</span></span>  
  
<span data-ttu-id="43201-591">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-591">-or-</span></span> 
<span data-ttu-id="43201-592">此操作将在当前程序集中创建一个具有重复 <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-592">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-593"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-593"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="43201-594">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-594">-or-</span></span> 
<span data-ttu-id="43201-595"><paramref name="interfaces" /> 数组的一个元素是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-595">An element of the <paramref name="interfaces" /> array is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, packSize As PackingSize, typeSize As Integer) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packSize, int typeSize);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type * System.Reflection.Emit.PackingSize * int -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent, packSize, typeSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parent" Type="System.Type" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeSize" Type="System.Int32" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="43201-596">类型的短名称。</span><span class="sxs-lookup"><span data-stu-id="43201-596">The short name of the type.</span></span> <span data-ttu-id="43201-597"><paramref name="name" /> 不能包含嵌入的 null 值。</span><span class="sxs-lookup"><span data-stu-id="43201-597"><paramref name="name" /> cannot contain embedded null values.</span></span></param>
        <param name="attr"><span data-ttu-id="43201-598">此类型的属性。</span><span class="sxs-lookup"><span data-stu-id="43201-598">The attributes of the type.</span></span></param>
        <param name="parent"><span data-ttu-id="43201-599">此嵌套类型扩展的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-599">The type that the nested type extends.</span></span></param>
        <param name="packSize"><span data-ttu-id="43201-600">此类型的封装大小。</span><span class="sxs-lookup"><span data-stu-id="43201-600">The packing size of the type.</span></span></param>
        <param name="typeSize"><span data-ttu-id="43201-601">此类型的总大小。</span><span class="sxs-lookup"><span data-stu-id="43201-601">The total size of the type.</span></span></param>
        <summary><span data-ttu-id="43201-602">定义嵌套类型，指定其名称、 属性、 大小和它所扩展的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-602">Defines a nested type, given its name, attributes, size, and the type that it extends.</span></span></summary>
        <returns><span data-ttu-id="43201-603">已定义的嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-603">The defined nested type.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefinePInvokeMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="43201-604">定义 <see langword="PInvoke" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="43201-604">Defines a <see langword="PInvoke" /> method.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberSignature Language="F#" Value="member this.DefinePInvokeMethod : string * string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Runtime.InteropServices.CallingConvention * System.Runtime.InteropServices.CharSet -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefinePInvokeMethod (name, dllName, attributes, callingConvention, returnType, parameterTypes, nativeCallConv, nativeCharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="dllName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="returnType" Type="System.Type" Index="4" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="parameterTypes" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" Index="6" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" Index="7" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="43201-605"><see langword="PInvoke" /> 方法的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-605">The name of the <see langword="PInvoke" /> method.</span></span> <span data-ttu-id="43201-606"><paramref name="name" /> 不能包含嵌入的 null。</span><span class="sxs-lookup"><span data-stu-id="43201-606"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="dllName"><span data-ttu-id="43201-607">定义 <see langword="PInvoke" /> 方法所使用的 DLL 的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-607">The name of the DLL in which the <see langword="PInvoke" /> method is defined.</span></span></param>
        <param name="attributes"><span data-ttu-id="43201-608">方法的属性。</span><span class="sxs-lookup"><span data-stu-id="43201-608">The attributes of the method.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="43201-609">方法的调用约定。</span><span class="sxs-lookup"><span data-stu-id="43201-609">The method's calling convention.</span></span></param>
        <param name="returnType"><span data-ttu-id="43201-610">方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="43201-610">The method's return type.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="43201-611">方法参数的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-611">The types of the method's parameters.</span></span></param>
        <param name="nativeCallConv"><span data-ttu-id="43201-612">本地调用约定。</span><span class="sxs-lookup"><span data-stu-id="43201-612">The native calling convention.</span></span></param>
        <param name="nativeCharSet"><span data-ttu-id="43201-613">方法的本地字符集。</span><span class="sxs-lookup"><span data-stu-id="43201-613">The method's native character set.</span></span></param>
        <summary><span data-ttu-id="43201-614">定义 <see langword="PInvoke" /> 方法，指定方法的名称、定义方法所使用的 DLL 的名称、方法的属性、方法的调用约定、 方法的返回类型、 方法的参数类型，以及 <see langword="PInvoke" /> 标志。</span><span class="sxs-lookup"><span data-stu-id="43201-614">Defines a <see langword="PInvoke" /> method given its name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <see langword="PInvoke" /> flags.</span></span></summary>
        <returns><span data-ttu-id="43201-615">已定义的 <see langword="PInvoke" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="43201-615">The defined <see langword="PInvoke" /> method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-616">无法将某些 DLL 导入属性（请参阅 <xref:System.Runtime.InteropServices.DllImportAttribute>的说明）指定为此方法的参数。</span><span class="sxs-lookup"><span data-stu-id="43201-616">Some DLL import attributes (see the description of <xref:System.Runtime.InteropServices.DllImportAttribute>) cannot be specified as arguments to this method.</span></span> <span data-ttu-id="43201-617">例如，如果该方法返回一个值，则在创建 `PInvoke` 方法之后，必须添加 DLL 导入属性 <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="43201-617">For example, the DLL import attribute <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> must be added after the `PInvoke` method is created, if the method returns a value.</span></span> <span data-ttu-id="43201-618">此示例演示如何执行此操作。</span><span class="sxs-lookup"><span data-stu-id="43201-618">The example shows how to do this.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43201-619">下面的示例演示如何使用 <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> 方法创建 `PInvoke` 方法，以及如何在创建 <xref:System.Reflection.Emit.MethodBuilder>后使用 <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> 和 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> 方法将 <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> 标志添加到方法实现标志。</span><span class="sxs-lookup"><span data-stu-id="43201-619">The following example demonstrates how to use the <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> method to create a `PInvoke` method, and how to add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag to the method implementation flags after you create the <xref:System.Reflection.Emit.MethodBuilder>, by using the <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> and <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> methods.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="43201-620">若要获取非零返回值，必须添加 <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> 标志。</span><span class="sxs-lookup"><span data-stu-id="43201-620">To get a non-zero return value, you must add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="43201-621">该示例创建一个动态程序集，其中包含一个动态模块和一个包含 `PInvoke` 方法 `MyType`的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-621">The example creates a dynamic assembly with one dynamic module and a single type, `MyType`, that contains the `PInvoke` method.</span></span> <span data-ttu-id="43201-622">`PInvoke` 方法表示 Win32 `GetTickCount` 函数。</span><span class="sxs-lookup"><span data-stu-id="43201-622">The `PInvoke` method represents the Win32 `GetTickCount` function.</span></span>  
  
 <span data-ttu-id="43201-623">运行该示例时，它将执行 `PInvoke` 方法。</span><span class="sxs-lookup"><span data-stu-id="43201-623">When the example is run, it executes the `PInvoke` method.</span></span> <span data-ttu-id="43201-624">它还会将动态程序集保存为 PInvokeTest。</span><span class="sxs-lookup"><span data-stu-id="43201-624">It also saves the dynamic assembly as PInvokeTest.dll.</span></span> <span data-ttu-id="43201-625">可以使用[Ildasm （IL 拆装器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)检查 `MyType` 类以及它包含的 `static` （Visual Basic 中的`Shared` `PInvoke`）。</span><span class="sxs-lookup"><span data-stu-id="43201-625">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the `MyType` class and the `static` (`Shared` in Visual Basic) `PInvoke` method it contains.</span></span> <span data-ttu-id="43201-626">可以通过在运行 csc 或C# dcdiag.exe 时包括对 DLL 的引用，来编译使用静态 `MyType.GetTickCount` 方法的 Visual Basic 或程序;例如，`/r:PInvokeTest.dll`。</span><span class="sxs-lookup"><span data-stu-id="43201-626">You can compile a Visual Basic or C# program that uses the static `MyType.GetTickCount` method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, `/r:PInvokeTest.dll`.</span></span>  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-627">此方法不是静态的。</span><span class="sxs-lookup"><span data-stu-id="43201-627">The method is not static.</span></span>  
  
<span data-ttu-id="43201-628">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-628">-or-</span></span> 
<span data-ttu-id="43201-629">此父类型为一个接口。</span><span class="sxs-lookup"><span data-stu-id="43201-629">The parent type is an interface.</span></span>  
  
<span data-ttu-id="43201-630">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-630">-or-</span></span> 
<span data-ttu-id="43201-631">这种方法是抽象的方法。</span><span class="sxs-lookup"><span data-stu-id="43201-631">The method is abstract.</span></span>  
  
<span data-ttu-id="43201-632">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-632">-or-</span></span> 
<span data-ttu-id="43201-633">此方法之前已定义。</span><span class="sxs-lookup"><span data-stu-id="43201-633">The method was previously defined.</span></span>  
  
<span data-ttu-id="43201-634">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-634">-or-</span></span> 
<span data-ttu-id="43201-635"><paramref name="name" /> 或 <paramref name="dllName" /> 的长度为零。</span><span class="sxs-lookup"><span data-stu-id="43201-635">The length of <paramref name="name" /> or <paramref name="dllName" /> is zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-636"><paramref name="name" /> 或 <paramref name="dllName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-636"><paramref name="name" /> or <paramref name="dllName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-637">之前已使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建包含类型。</span><span class="sxs-lookup"><span data-stu-id="43201-637">The containing type has been previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::String ^ entryName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberSignature Language="F#" Value="member this.DefinePInvokeMethod : string * string * string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Runtime.InteropServices.CallingConvention * System.Runtime.InteropServices.CharSet -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefinePInvokeMethod (name, dllName, entryName, attributes, callingConvention, returnType, parameterTypes, nativeCallConv, nativeCharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="dllName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="entryName" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" Index="3" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" Index="4" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="returnType" Type="System.Type" Index="5" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="parameterTypes" Type="System.Type[]" Index="6" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" Index="7" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" Index="8" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="43201-638"><see langword="PInvoke" /> 方法的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-638">The name of the <see langword="PInvoke" /> method.</span></span> <span data-ttu-id="43201-639"><paramref name="name" /> 不能包含嵌入的 null。</span><span class="sxs-lookup"><span data-stu-id="43201-639"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="dllName"><span data-ttu-id="43201-640">定义 <see langword="PInvoke" /> 方法所使用的 DLL 的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-640">The name of the DLL in which the <see langword="PInvoke" /> method is defined.</span></span></param>
        <param name="entryName"><span data-ttu-id="43201-641">DLL 中入口点的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-641">The name of the entry point in the DLL.</span></span></param>
        <param name="attributes"><span data-ttu-id="43201-642">方法的属性。</span><span class="sxs-lookup"><span data-stu-id="43201-642">The attributes of the method.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="43201-643">方法的调用约定。</span><span class="sxs-lookup"><span data-stu-id="43201-643">The method's calling convention.</span></span></param>
        <param name="returnType"><span data-ttu-id="43201-644">方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="43201-644">The method's return type.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="43201-645">方法参数的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-645">The types of the method's parameters.</span></span></param>
        <param name="nativeCallConv"><span data-ttu-id="43201-646">本地调用约定。</span><span class="sxs-lookup"><span data-stu-id="43201-646">The native calling convention.</span></span></param>
        <param name="nativeCharSet"><span data-ttu-id="43201-647">方法的本地字符集。</span><span class="sxs-lookup"><span data-stu-id="43201-647">The method's native character set.</span></span></param>
        <summary><span data-ttu-id="43201-648">定义 <see langword="PInvoke" /> 方法，指定方法的名称、定义方法所使用的 DLL 的名称、入口点名称、 方法的属性、方法的调用约定、 方法的返回类型、 方法的参数类型，以及 <see langword="PInvoke" /> 标志。</span><span class="sxs-lookup"><span data-stu-id="43201-648">Defines a <see langword="PInvoke" /> method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <see langword="PInvoke" /> flags.</span></span></summary>
        <returns><span data-ttu-id="43201-649">已定义的 <see langword="PInvoke" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="43201-649">The defined <see langword="PInvoke" /> method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-650">无法将某些 DLL 导入属性（请参阅 <xref:System.Runtime.InteropServices.DllImportAttribute>的说明）指定为此方法的参数。</span><span class="sxs-lookup"><span data-stu-id="43201-650">Some DLL import attributes (see the description of <xref:System.Runtime.InteropServices.DllImportAttribute>) cannot be specified as arguments to this method.</span></span> <span data-ttu-id="43201-651">例如，如果该方法返回一个值，则在创建 `PInvoke` 方法之后，必须添加 DLL 导入属性 <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="43201-651">For example, the DLL import attribute <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> must be added after the `PInvoke` method is created, if the method returns a value.</span></span> <span data-ttu-id="43201-652">此示例演示如何执行此操作。</span><span class="sxs-lookup"><span data-stu-id="43201-652">The example shows how to do this.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43201-653">下面的代码示例演示如何使用 <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> 方法创建 `PInvoke` 方法，以及如何在创建 <xref:System.Reflection.Emit.MethodBuilder>后使用 <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> 和 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> 方法将 <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> 标志添加到方法实现标志。</span><span class="sxs-lookup"><span data-stu-id="43201-653">The following code example demonstrates how to use the <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> method to create a `PInvoke` method, and how to add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag to the method implementation flags after you create the <xref:System.Reflection.Emit.MethodBuilder>, by using the <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> and <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> methods.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="43201-654">若要获取非零返回值，必须添加 <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> 标志。</span><span class="sxs-lookup"><span data-stu-id="43201-654">To get a non-zero return value, you must add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="43201-655">该示例创建一个动态程序集，其中包含一个动态模块和一个包含 `PInvoke` 方法 `MyType`的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-655">The example creates a dynamic assembly with one dynamic module and a single type, `MyType`, that contains the `PInvoke` method.</span></span> <span data-ttu-id="43201-656">`PInvoke` 方法表示 Win32 `GetTickCount` 函数。</span><span class="sxs-lookup"><span data-stu-id="43201-656">The `PInvoke` method represents the Win32 `GetTickCount` function.</span></span>  
  
 <span data-ttu-id="43201-657">运行该示例时，它将执行 `PInvoke` 方法。</span><span class="sxs-lookup"><span data-stu-id="43201-657">When the example is run, it executes the `PInvoke` method.</span></span> <span data-ttu-id="43201-658">它还会将动态程序集保存为 PInvokeTest。</span><span class="sxs-lookup"><span data-stu-id="43201-658">It also saves the dynamic assembly as PInvokeTest.dll.</span></span> <span data-ttu-id="43201-659">可以使用[Ildasm （IL 拆装器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)检查 `MyType` 类以及它包含的 `static` （Visual Basic 中的`Shared` `PInvoke`）。</span><span class="sxs-lookup"><span data-stu-id="43201-659">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the `MyType` class and the `static` (`Shared` in Visual Basic) `PInvoke` method it contains.</span></span> <span data-ttu-id="43201-660">可以通过在运行 csc 或C# dcdiag.exe 时包括对 DLL 的引用，来编译使用静态 `MyType.GetTickCount` 方法的 Visual Basic 或程序;例如，`/r:PInvokeTest.dll`。</span><span class="sxs-lookup"><span data-stu-id="43201-660">You can compile a Visual Basic or C# program that uses the static `MyType.GetTickCount` method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, `/r:PInvokeTest.dll`.</span></span>  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-661">此方法不是静态的。</span><span class="sxs-lookup"><span data-stu-id="43201-661">The method is not static.</span></span>  
  
<span data-ttu-id="43201-662">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-662">-or-</span></span> 
<span data-ttu-id="43201-663">此父类型为一个接口。</span><span class="sxs-lookup"><span data-stu-id="43201-663">The parent type is an interface.</span></span>  
  
<span data-ttu-id="43201-664">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-664">-or-</span></span> 
<span data-ttu-id="43201-665">这种方法是抽象的方法。</span><span class="sxs-lookup"><span data-stu-id="43201-665">The method is abstract.</span></span>  
  
<span data-ttu-id="43201-666">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-666">-or-</span></span> 
<span data-ttu-id="43201-667">此方法之前已定义。</span><span class="sxs-lookup"><span data-stu-id="43201-667">The method was previously defined.</span></span>  
  
<span data-ttu-id="43201-668">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-668">-or-</span></span> 
<span data-ttu-id="43201-669"><paramref name="name" />、<paramref name="dllName" /> 或 <paramref name="entryName" /> 的长度为零。</span><span class="sxs-lookup"><span data-stu-id="43201-669">The length of <paramref name="name" />, <paramref name="dllName" />, or <paramref name="entryName" /> is zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-670"><paramref name="name" />、<paramref name="dllName" /> 或 <paramref name="entryName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-670"><paramref name="name" />, <paramref name="dllName" />, or <paramref name="entryName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-671">之前已使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建包含类型。</span><span class="sxs-lookup"><span data-stu-id="43201-671">The containing type has been previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::String ^ entryName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberSignature Language="F#" Value="member this.DefinePInvokeMethod : string * string * string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type[] * Type[] * Type[][] * Type[][] * System.Runtime.InteropServices.CallingConvention * System.Runtime.InteropServices.CharSet -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefinePInvokeMethod (name, dllName, entryName, attributes, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers, nativeCallConv, nativeCharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="dllName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="entryName" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" Index="3" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" Index="4" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="returnType" Type="System.Type" Index="5" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" Index="6" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="parameterTypes" Type="System.Type[]" Index="8" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" Index="9" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" Index="10" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" Index="11" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" Index="12" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="43201-672"><see langword="PInvoke" /> 方法的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-672">The name of the <see langword="PInvoke" /> method.</span></span> <span data-ttu-id="43201-673"><paramref name="name" /> 不能包含嵌入的 null。</span><span class="sxs-lookup"><span data-stu-id="43201-673"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="dllName"><span data-ttu-id="43201-674">定义 <see langword="PInvoke" /> 方法所使用的 DLL 的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-674">The name of the DLL in which the <see langword="PInvoke" /> method is defined.</span></span></param>
        <param name="entryName"><span data-ttu-id="43201-675">DLL 中入口点的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-675">The name of the entry point in the DLL.</span></span></param>
        <param name="attributes"><span data-ttu-id="43201-676">方法的属性。</span><span class="sxs-lookup"><span data-stu-id="43201-676">The attributes of the method.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="43201-677">方法的调用约定。</span><span class="sxs-lookup"><span data-stu-id="43201-677">The method's calling convention.</span></span></param>
        <param name="returnType"><span data-ttu-id="43201-678">方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="43201-678">The method's return type.</span></span></param>
        <param name="returnTypeRequiredCustomModifiers"><span data-ttu-id="43201-679">一个类型数组，表示该方法的返回类型所必需的自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span><span class="sxs-lookup"><span data-stu-id="43201-679">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span></span> <span data-ttu-id="43201-680">如果返回类型没有所需的自定义修饰符，则指定 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-680">If the return type has no required custom modifiers, specify <see langword="null" />.</span></span></param>
        <param name="returnTypeOptionalCustomModifiers"><span data-ttu-id="43201-681">一个类型数组，表示该方法的返回类型的可选自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span><span class="sxs-lookup"><span data-stu-id="43201-681">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span></span> <span data-ttu-id="43201-682">如果返回类型没有可选的自定义修饰符，则指定 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-682">If the return type has no optional custom modifiers, specify <see langword="null" />.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="43201-683">方法参数的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-683">The types of the method's parameters.</span></span></param>
        <param name="parameterTypeRequiredCustomModifiers"><span data-ttu-id="43201-684">由类型数组组成的数组。</span><span class="sxs-lookup"><span data-stu-id="43201-684">An array of arrays of types.</span></span> <span data-ttu-id="43201-685">每个类型数组均表示相应参数所必需的自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span><span class="sxs-lookup"><span data-stu-id="43201-685">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="43201-686">如果某个特定参数没有所需的自定义修饰符，则指定 <see langword="null" />，而不要指定类型数组。</span><span class="sxs-lookup"><span data-stu-id="43201-686">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="43201-687">如果所有参数都没有所需的自定义修饰符，则指定 <see langword="null" />，而不要指定由数组组成的数组。</span><span class="sxs-lookup"><span data-stu-id="43201-687">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <param name="parameterTypeOptionalCustomModifiers"><span data-ttu-id="43201-688">由类型数组组成的数组。</span><span class="sxs-lookup"><span data-stu-id="43201-688">An array of arrays of types.</span></span> <span data-ttu-id="43201-689">每个类型数组均表示相应参数的可选自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span><span class="sxs-lookup"><span data-stu-id="43201-689">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="43201-690">如果某个特定参数没有可选的自定义修饰符，则指定 <see langword="null" />，而不要指定类型数组。</span><span class="sxs-lookup"><span data-stu-id="43201-690">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="43201-691">如果所有参数都没有可选的自定义修饰符，则指定 <see langword="null" />，而不要指定由数组组成的数组。</span><span class="sxs-lookup"><span data-stu-id="43201-691">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <param name="nativeCallConv"><span data-ttu-id="43201-692">本地调用约定。</span><span class="sxs-lookup"><span data-stu-id="43201-692">The native calling convention.</span></span></param>
        <param name="nativeCharSet"><span data-ttu-id="43201-693">方法的本地字符集。</span><span class="sxs-lookup"><span data-stu-id="43201-693">The method's native character set.</span></span></param>
        <summary><span data-ttu-id="43201-694">定义 <see langword="PInvoke" /> 方法，指定方法的名称、定义方法所使用的 DLL 的名称、入口点名称、方法的属性、方法的调用约定、方法的返回类型、方法的参数类型、<see langword="PInvoke" /> 标志，以及参数和返回类型的自定义修饰符。</span><span class="sxs-lookup"><span data-stu-id="43201-694">Defines a <see langword="PInvoke" /> method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, the <see langword="PInvoke" /> flags, and custom modifiers for the parameters and return type.</span></span></summary>
        <returns><span data-ttu-id="43201-695">一个 <see cref="T:System.Reflection.Emit.MethodBuilder" />，表示所定义的 <see langword="PInvoke" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="43201-695">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> representing the defined <see langword="PInvoke" /> method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-696">无法将某些 DLL 导入属性（请参阅 <xref:System.Runtime.InteropServices.DllImportAttribute>的说明）指定为此方法的参数。</span><span class="sxs-lookup"><span data-stu-id="43201-696">Some DLL import attributes (see the description of <xref:System.Runtime.InteropServices.DllImportAttribute>) cannot be specified as arguments to this method.</span></span> <span data-ttu-id="43201-697">例如，如果该方法返回一个值，则在创建 `PInvoke` 方法之后，必须添加 DLL 导入属性 <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="43201-697">For example, the DLL import attribute <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> must be added after the `PInvoke` method is created, if the method returns a value.</span></span> <span data-ttu-id="43201-698">此示例演示如何执行此操作。</span><span class="sxs-lookup"><span data-stu-id="43201-698">The example shows how to do this.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="43201-699">有关自定义修饰符的详细信息，请参阅 ECMA Partition II 元数据文档。</span><span class="sxs-lookup"><span data-stu-id="43201-699">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="43201-700">可联机获取该文档；请参阅 MSDN 上的 [ECMA C# 和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)和 Ecma International 网站上的[标准 ECMA-335 - 公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)。</span><span class="sxs-lookup"><span data-stu-id="43201-700">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43201-701">下面的代码示例演示了如何使用 \]和\[方法，在创建 \]后，如何使用 [\]，键入\[\]，键入\[\[\]\[\]\<> `PInvoke` <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> <xref:System.Reflection.Emit.MethodBuilder><xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> 方法创建方法，以及如何将标志添加到方法实现标志。</span><span class="sxs-lookup"><span data-stu-id="43201-701">The following code example demonstrates how to use the [\], Type\[\], Type\[\], Type\[\]\[\], Type\[\]\<xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> method to create a `PInvoke` method, and how to add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag to the method implementation flags after you create the <xref:System.Reflection.Emit.MethodBuilder>, by using the <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> and <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="43201-702">该示例创建一个动态程序集，其中包含一个动态模块和一个包含 `PInvoke` 方法 `MyType`的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-702">The example creates a dynamic assembly with one dynamic module and a single type, `MyType`, that contains the `PInvoke` method.</span></span> <span data-ttu-id="43201-703">`PInvoke` 方法表示 Win32 `GetTickCount` 函数。</span><span class="sxs-lookup"><span data-stu-id="43201-703">The `PInvoke` method represents the Win32 `GetTickCount` function.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="43201-704">若要获取非零返回值，必须添加 <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> 标志。</span><span class="sxs-lookup"><span data-stu-id="43201-704">To get a non-zero return value, you must add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="43201-705">该示例使用未指定自定义修饰符的重载。</span><span class="sxs-lookup"><span data-stu-id="43201-705">The example uses an overload that does not specify custom modifiers.</span></span> <span data-ttu-id="43201-706">若要指定自定义修饰符，请将示例代码改为使用此方法重载。</span><span class="sxs-lookup"><span data-stu-id="43201-706">To specify custom modifiers, change the example code to use this method overload instead.</span></span>  
  
 <span data-ttu-id="43201-707">运行该示例时，它将执行 `PInvoke` 方法。</span><span class="sxs-lookup"><span data-stu-id="43201-707">When the example is run, it executes the `PInvoke` method.</span></span> <span data-ttu-id="43201-708">它还会将动态程序集保存为 PInvokeTest。</span><span class="sxs-lookup"><span data-stu-id="43201-708">It also saves the dynamic assembly as PInvokeTest.dll.</span></span> <span data-ttu-id="43201-709">可以使用[Ildasm （IL 拆装器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)检查 `MyType` 类以及它包含的 `static` （Visual Basic 中的`Shared` `PInvoke`）。</span><span class="sxs-lookup"><span data-stu-id="43201-709">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the `MyType` class and the `static` (`Shared` in Visual Basic) `PInvoke` method it contains.</span></span> <span data-ttu-id="43201-710">可以通过在运行 csc 或C# dcdiag.exe 时包括对 DLL 的引用，来编译使用静态 `MyType.GetTickCount` 方法的 Visual Basic 或程序;例如，`/r:PInvokeTest.dll`。</span><span class="sxs-lookup"><span data-stu-id="43201-710">You can compile a Visual Basic or C# program that uses the static `MyType.GetTickCount` method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, `/r:PInvokeTest.dll`.</span></span>  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-711">此方法不是静态的。</span><span class="sxs-lookup"><span data-stu-id="43201-711">The method is not static.</span></span>  
  
<span data-ttu-id="43201-712">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-712">-or-</span></span> 
<span data-ttu-id="43201-713">此父类型为一个接口。</span><span class="sxs-lookup"><span data-stu-id="43201-713">The parent type is an interface.</span></span>  
  
<span data-ttu-id="43201-714">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-714">-or-</span></span> 
<span data-ttu-id="43201-715">这种方法是抽象的方法。</span><span class="sxs-lookup"><span data-stu-id="43201-715">The method is abstract.</span></span>  
  
<span data-ttu-id="43201-716">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-716">-or-</span></span> 
<span data-ttu-id="43201-717">此方法之前已定义。</span><span class="sxs-lookup"><span data-stu-id="43201-717">The method was previously defined.</span></span>  
  
<span data-ttu-id="43201-718">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-718">-or-</span></span> 
<span data-ttu-id="43201-719"><paramref name="name" />、<paramref name="dllName" /> 或 <paramref name="entryName" /> 的长度为零。</span><span class="sxs-lookup"><span data-stu-id="43201-719">The length of <paramref name="name" />, <paramref name="dllName" />, or <paramref name="entryName" /> is zero.</span></span>  
  
<span data-ttu-id="43201-720">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-720">-or-</span></span> 
<span data-ttu-id="43201-721"><paramref name="parameterTypeRequiredCustomModifiers" /> 或 <paramref name="parameterTypeOptionalCustomModifiers" /> 的大小与 <paramref name="parameterTypes" /> 的大小不相等。</span><span class="sxs-lookup"><span data-stu-id="43201-721">The size of <paramref name="parameterTypeRequiredCustomModifiers" /> or <paramref name="parameterTypeOptionalCustomModifiers" /> does not equal the size of <paramref name="parameterTypes" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-722"><paramref name="name" />、<paramref name="dllName" /> 或 <paramref name="entryName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-722"><paramref name="name" />, <paramref name="dllName" />, or <paramref name="entryName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-723">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</span><span class="sxs-lookup"><span data-stu-id="43201-723">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="43201-724">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-724">-or-</span></span> 
<span data-ttu-id="43201-725">对于当前的动态类型，属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 的值为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 的值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43201-725">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineProperty">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="43201-726">向此类型添加一个新的属性。</span><span class="sxs-lookup"><span data-stu-id="43201-726">Adds a new property to the type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, returnType As Type, parameterTypes As Type()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineProperty : string * System.Reflection.PropertyAttributes * Type * Type[] -&gt; System.Reflection.Emit.PropertyBuilder" Usage="typeBuilder.DefineProperty (name, attributes, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="43201-727">属性的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-727">The name of the property.</span></span> <span data-ttu-id="43201-728"><paramref name="name" /> 不能包含嵌入的 null。</span><span class="sxs-lookup"><span data-stu-id="43201-728"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="43201-729">属性的特性。</span><span class="sxs-lookup"><span data-stu-id="43201-729">The attributes of the property.</span></span></param>
        <param name="returnType"><span data-ttu-id="43201-730">属性的返回类型。</span><span class="sxs-lookup"><span data-stu-id="43201-730">The return type of the property.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="43201-731">属性的参数类型。</span><span class="sxs-lookup"><span data-stu-id="43201-731">The types of the parameters of the property.</span></span></param>
        <summary><span data-ttu-id="43201-732">将新属性添加到具有给定名称和属性签名的类型中。</span><span class="sxs-lookup"><span data-stu-id="43201-732">Adds a new property to the type, with the given name and property signature.</span></span></summary>
        <returns><span data-ttu-id="43201-733">定义的属性。</span><span class="sxs-lookup"><span data-stu-id="43201-733">The defined property.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="43201-734">下面的代码示例演示如何定义动态属性并获取规范 <xref:System.Reflection.Emit.PropertyBuilder>。</span><span class="sxs-lookup"><span data-stu-id="43201-734">The following code sample demonstrates how to define a dynamic property and obtain a <xref:System.Reflection.Emit.PropertyBuilder> for specification.</span></span> <span data-ttu-id="43201-735">请注意，`PropertyBuilder` 还必须具有相应的 <xref:System.Reflection.Emit.MethodBuilder>，它将承载属性的 IL 逻辑。</span><span class="sxs-lookup"><span data-stu-id="43201-735">Note that a `PropertyBuilder` must also have a corresponding <xref:System.Reflection.Emit.MethodBuilder>, which will house the IL logic for the property.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-736"><paramref name="name" /> 的长度为零。</span><span class="sxs-lookup"><span data-stu-id="43201-736">The length of <paramref name="name" /> is zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-737"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-737"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="43201-738">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-738">-or-</span></span> 
<span data-ttu-id="43201-739"><paramref name="parameterTypes" /> 数组的任何元素都是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-739">Any of the elements of the <paramref name="parameterTypes" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-740">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</span><span class="sxs-lookup"><span data-stu-id="43201-740">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineProperty : string * System.Reflection.PropertyAttributes * System.Reflection.CallingConventions * Type * Type[] -&gt; System.Reflection.Emit.PropertyBuilder" Usage="typeBuilder.DefineProperty (name, attributes, callingConvention, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameterTypes" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="43201-741">属性的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-741">The name of the property.</span></span> <span data-ttu-id="43201-742"><paramref name="name" /> 不能包含嵌入的 null。</span><span class="sxs-lookup"><span data-stu-id="43201-742"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="43201-743">属性的特性。</span><span class="sxs-lookup"><span data-stu-id="43201-743">The attributes of the property.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="43201-744">属性访问器的调用约定。</span><span class="sxs-lookup"><span data-stu-id="43201-744">The calling convention of the property accessors.</span></span></param>
        <param name="returnType"><span data-ttu-id="43201-745">属性的返回类型。</span><span class="sxs-lookup"><span data-stu-id="43201-745">The return type of the property.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="43201-746">属性的参数类型。</span><span class="sxs-lookup"><span data-stu-id="43201-746">The types of the parameters of the property.</span></span></param>
        <summary><span data-ttu-id="43201-747">将新属性添加到具有给定名称、属性、调用约定和属性签名的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-747">Adds a new property to the type, with the given name, attributes, calling convention, and property signature.</span></span></summary>
        <returns><span data-ttu-id="43201-748">定义的属性。</span><span class="sxs-lookup"><span data-stu-id="43201-748">The defined property.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-749"><paramref name="name" /> 的长度为零。</span><span class="sxs-lookup"><span data-stu-id="43201-749">The length of <paramref name="name" /> is zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-750"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-750"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="43201-751">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-751">-or-</span></span> 
<span data-ttu-id="43201-752"><paramref name="parameterTypes" /> 数组的任何元素都是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-752">Any of the elements of the <paramref name="parameterTypes" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-753">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</span><span class="sxs-lookup"><span data-stu-id="43201-753">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.DefineProperty : string * System.Reflection.PropertyAttributes * Type * Type[] * Type[] * Type[] * Type[][] * Type[][] -&gt; System.Reflection.Emit.PropertyBuilder" Usage="typeBuilder.DefineProperty (name, attributes, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="returnType" Type="System.Type" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameterTypes" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" Index="6" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" Index="7" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="43201-754">属性的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-754">The name of the property.</span></span> <span data-ttu-id="43201-755"><paramref name="name" /> 不能包含嵌入的 null。</span><span class="sxs-lookup"><span data-stu-id="43201-755"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="43201-756">属性的特性。</span><span class="sxs-lookup"><span data-stu-id="43201-756">The attributes of the property.</span></span></param>
        <param name="returnType"><span data-ttu-id="43201-757">属性的返回类型。</span><span class="sxs-lookup"><span data-stu-id="43201-757">The return type of the property.</span></span></param>
        <param name="returnTypeRequiredCustomModifiers"><span data-ttu-id="43201-758">一个类型数组，它表示属性的返回类型所必需的自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span><span class="sxs-lookup"><span data-stu-id="43201-758">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the property.</span></span> <span data-ttu-id="43201-759">如果返回类型没有所需的自定义修饰符，则指定 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-759">If the return type has no required custom modifiers, specify <see langword="null" />.</span></span></param>
        <param name="returnTypeOptionalCustomModifiers"><span data-ttu-id="43201-760">一个类型数组，它表示属性的返回类型的可选自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span><span class="sxs-lookup"><span data-stu-id="43201-760">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the property.</span></span> <span data-ttu-id="43201-761">如果返回类型没有可选的自定义修饰符，则指定 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-761">If the return type has no optional custom modifiers, specify <see langword="null" />.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="43201-762">属性的参数类型。</span><span class="sxs-lookup"><span data-stu-id="43201-762">The types of the parameters of the property.</span></span></param>
        <param name="parameterTypeRequiredCustomModifiers"><span data-ttu-id="43201-763">由类型数组组成的数组。</span><span class="sxs-lookup"><span data-stu-id="43201-763">An array of arrays of types.</span></span> <span data-ttu-id="43201-764">每个类型数组均表示相应参数所必需的自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span><span class="sxs-lookup"><span data-stu-id="43201-764">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="43201-765">如果某个特定参数没有所需的自定义修饰符，则指定 <see langword="null" />，而不要指定类型数组。</span><span class="sxs-lookup"><span data-stu-id="43201-765">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="43201-766">如果所有参数都没有所需的自定义修饰符，则指定 <see langword="null" />，而不要指定由数组组成的数组。</span><span class="sxs-lookup"><span data-stu-id="43201-766">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <param name="parameterTypeOptionalCustomModifiers"><span data-ttu-id="43201-767">由类型数组组成的数组。</span><span class="sxs-lookup"><span data-stu-id="43201-767">An array of arrays of types.</span></span> <span data-ttu-id="43201-768">每个类型数组均表示相应参数的可选自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span><span class="sxs-lookup"><span data-stu-id="43201-768">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="43201-769">如果某个特定参数没有可选的自定义修饰符，则指定 <see langword="null" />，而不要指定类型数组。</span><span class="sxs-lookup"><span data-stu-id="43201-769">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="43201-770">如果所有参数都没有可选的自定义修饰符，则指定 <see langword="null" />，而不要指定由数组组成的数组。</span><span class="sxs-lookup"><span data-stu-id="43201-770">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <summary><span data-ttu-id="43201-771">将新属性添加到具有给定名称、属性签名和自定义修饰符的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-771">Adds a new property to the type, with the given name, property signature, and custom modifiers.</span></span></summary>
        <returns><span data-ttu-id="43201-772">定义的属性。</span><span class="sxs-lookup"><span data-stu-id="43201-772">The defined property.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-773">此重载是为托管编译器的设计器提供的。</span><span class="sxs-lookup"><span data-stu-id="43201-773">This overload is provided for designers of managed compilers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="43201-774">有关自定义修饰符的详细信息，请参阅 ECMA Partition II 元数据文档。</span><span class="sxs-lookup"><span data-stu-id="43201-774">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="43201-775">可联机获取该文档；请参阅 MSDN 上的 [ECMA C# 和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)和 Ecma International 网站上的[标准 ECMA-335 - 公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)。</span><span class="sxs-lookup"><span data-stu-id="43201-775">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-776"><paramref name="name" /> 的长度为零。</span><span class="sxs-lookup"><span data-stu-id="43201-776">The length of <paramref name="name" /> is zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-777"><paramref name="name" /> 为 <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="43201-777"><paramref name="name" /> is <see langword="null" /></span></span>  
  
<span data-ttu-id="43201-778">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-778">-or-</span></span> 
<span data-ttu-id="43201-779"><paramref name="parameterTypes" /> 数组的任何元素都是 <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="43201-779">Any of the elements of the <paramref name="parameterTypes" /> array is <see langword="null" /></span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-780">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</span><span class="sxs-lookup"><span data-stu-id="43201-780">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, callingConvention As CallingConventions, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.DefineProperty : string * System.Reflection.PropertyAttributes * System.Reflection.CallingConventions * Type * Type[] * Type[] * Type[] * Type[][] * Type[][] -&gt; System.Reflection.Emit.PropertyBuilder" Usage="typeBuilder.DefineProperty (name, attributes, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameterTypes" Type="System.Type[]" Index="6" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" Index="7" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" Index="8" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="43201-781">属性的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-781">The name of the property.</span></span> <span data-ttu-id="43201-782"><paramref name="name" /> 不能包含嵌入的 null。</span><span class="sxs-lookup"><span data-stu-id="43201-782"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="43201-783">属性的特性。</span><span class="sxs-lookup"><span data-stu-id="43201-783">The attributes of the property.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="43201-784">属性访问器的调用约定。</span><span class="sxs-lookup"><span data-stu-id="43201-784">The calling convention of the property accessors.</span></span></param>
        <param name="returnType"><span data-ttu-id="43201-785">属性的返回类型。</span><span class="sxs-lookup"><span data-stu-id="43201-785">The return type of the property.</span></span></param>
        <param name="returnTypeRequiredCustomModifiers"><span data-ttu-id="43201-786">一个类型数组，它表示属性的返回类型所必需的自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span><span class="sxs-lookup"><span data-stu-id="43201-786">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the property.</span></span> <span data-ttu-id="43201-787">如果返回类型没有所需的自定义修饰符，则指定 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-787">If the return type has no required custom modifiers, specify <see langword="null" />.</span></span></param>
        <param name="returnTypeOptionalCustomModifiers"><span data-ttu-id="43201-788">一个类型数组，它表示属性的返回类型的可选自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span><span class="sxs-lookup"><span data-stu-id="43201-788">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the property.</span></span> <span data-ttu-id="43201-789">如果返回类型没有可选的自定义修饰符，则指定 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-789">If the return type has no optional custom modifiers, specify <see langword="null" />.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="43201-790">属性的参数类型。</span><span class="sxs-lookup"><span data-stu-id="43201-790">The types of the parameters of the property.</span></span></param>
        <param name="parameterTypeRequiredCustomModifiers"><span data-ttu-id="43201-791">由类型数组组成的数组。</span><span class="sxs-lookup"><span data-stu-id="43201-791">An array of arrays of types.</span></span> <span data-ttu-id="43201-792">每个类型数组均表示相应参数所必需的自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span><span class="sxs-lookup"><span data-stu-id="43201-792">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="43201-793">如果某个特定参数没有所需的自定义修饰符，则指定 <see langword="null" />，而不要指定类型数组。</span><span class="sxs-lookup"><span data-stu-id="43201-793">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="43201-794">如果所有参数都没有所需的自定义修饰符，则指定 <see langword="null" />，而不要指定由数组组成的数组。</span><span class="sxs-lookup"><span data-stu-id="43201-794">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <param name="parameterTypeOptionalCustomModifiers"><span data-ttu-id="43201-795">由类型数组组成的数组。</span><span class="sxs-lookup"><span data-stu-id="43201-795">An array of arrays of types.</span></span> <span data-ttu-id="43201-796">每个类型数组均表示相应参数的可选自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span><span class="sxs-lookup"><span data-stu-id="43201-796">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="43201-797">如果某个特定参数没有可选的自定义修饰符，则指定 <see langword="null" />，而不要指定类型数组。</span><span class="sxs-lookup"><span data-stu-id="43201-797">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="43201-798">如果所有参数都没有可选的自定义修饰符，则指定 <see langword="null" />，而不要指定由数组组成的数组。</span><span class="sxs-lookup"><span data-stu-id="43201-798">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <summary><span data-ttu-id="43201-799">将新属性添加到具有给定名称、调用约定、属性签名和自定义修饰符的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-799">Adds a new property to the type, with the given name, calling convention, property signature, and custom modifiers.</span></span></summary>
        <returns><span data-ttu-id="43201-800">定义的属性。</span><span class="sxs-lookup"><span data-stu-id="43201-800">The defined property.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-801">此重载是为托管编译器的设计器提供的。</span><span class="sxs-lookup"><span data-stu-id="43201-801">This overload is provided for designers of managed compilers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="43201-802">有关自定义修饰符的详细信息，请参阅 ECMA Partition II 元数据文档。</span><span class="sxs-lookup"><span data-stu-id="43201-802">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="43201-803">可联机获取该文档；请参阅 MSDN 上的 [ECMA C# 和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)和 Ecma International 网站上的[标准 ECMA-335 - 公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)。</span><span class="sxs-lookup"><span data-stu-id="43201-803">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 <span data-ttu-id="43201-804">此方法重载在 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本中引入。</span><span class="sxs-lookup"><span data-stu-id="43201-804">This method overload is introduced in the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-805"><paramref name="name" /> 的长度为零。</span><span class="sxs-lookup"><span data-stu-id="43201-805">The length of <paramref name="name" /> is zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-806"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-806"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="43201-807">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-807">-or-</span></span> 
<span data-ttu-id="43201-808"><paramref name="parameterTypes" /> 数组的任何元素都是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-808">Any of the elements of the <paramref name="parameterTypes" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-809">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</span><span class="sxs-lookup"><span data-stu-id="43201-809">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineTypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineTypeInitializer () As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineTypeInitializer();" />
      <MemberSignature Language="F#" Value="member this.DefineTypeInitializer : unit -&gt; System.Reflection.Emit.ConstructorBuilder" Usage="typeBuilder.DefineTypeInitializer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43201-810">定义此类型的初始值设定项。</span><span class="sxs-lookup"><span data-stu-id="43201-810">Defines the initializer for this type.</span></span></summary>
        <returns><span data-ttu-id="43201-811">返回类型初始值设定项。</span><span class="sxs-lookup"><span data-stu-id="43201-811">Returns a type initializer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-812">创建的初始值设定项始终是公共的。</span><span class="sxs-lookup"><span data-stu-id="43201-812">The initializer created is always public.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43201-813">下面的代码示例演示如何使用 `DefineTypeInitializer`创建初始化构造函数。</span><span class="sxs-lookup"><span data-stu-id="43201-813">The following code sample demonstrates how to create an initialization constructor using `DefineTypeInitializer`.</span></span>  
  
 [!code-cpp[TypeBuilder_Properties1#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Properties1/CPP/typebuilder_properties.cpp#3)]
 [!code-csharp[TypeBuilder_Properties1#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Properties1/CS/typebuilder_properties.cs#3)]
 [!code-vb[TypeBuilder_Properties1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Properties1/VB/typebuilder_properties.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-814">之前已使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建包含类型。</span><span class="sxs-lookup"><span data-stu-id="43201-814">The containing type has been previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUninitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineUninitializedData (string name, int size, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineUninitializedData(string name, int32 size, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineUninitializedData (name As String, size As Integer, attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineUninitializedData(System::String ^ name, int size, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineUninitializedData : string * int * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="typeBuilder.DefineUninitializedData (name, size, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="43201-815">用于引用数据的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-815">The name used to refer to the data.</span></span> <span data-ttu-id="43201-816"><paramref name="name" /> 不能包含嵌入的 null。</span><span class="sxs-lookup"><span data-stu-id="43201-816"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="size"><span data-ttu-id="43201-817">数据字段的大小。</span><span class="sxs-lookup"><span data-stu-id="43201-817">The size of the data field.</span></span></param>
        <param name="attributes"><span data-ttu-id="43201-818">字段的属性。</span><span class="sxs-lookup"><span data-stu-id="43201-818">The attributes for the field.</span></span></param>
        <summary><span data-ttu-id="43201-819">在可移植可执行 (PE) 文件的 <see langword=".sdata" /> 部分中定义未初始化的数据字段。</span><span class="sxs-lookup"><span data-stu-id="43201-819">Defines an uninitialized data field in the <see langword=".sdata" /> section of the portable executable (PE) file.</span></span></summary>
        <returns><span data-ttu-id="43201-820">用于引用数据的字段。</span><span class="sxs-lookup"><span data-stu-id="43201-820">A field to reference the data.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-821">你用此方法创建的字段将被 `static`，即使在 `attributes` 参数中未包含 `FieldAttributes.Static` 也是如此。</span><span class="sxs-lookup"><span data-stu-id="43201-821">The field that you create with this method will be `static`, even if you do not include `FieldAttributes.Static` in the `attributes` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43201-822">下面的代码示例演示如何使用 `DefineUninitializedData` 在动态类型中创建未初始化的数据字段：</span><span class="sxs-lookup"><span data-stu-id="43201-822">The following code sample demonstrates the use of `DefineUninitializedData` to create an uninitialized data field in a dynamic type:</span></span>  
  
 [!code-cpp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CPP/typebuilder_defineuninitializeddata.cpp#1)]
 [!code-csharp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CS/typebuilder_defineuninitializeddata.cs#1)]
 [!code-vb[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/VB/typebuilder_defineuninitializeddata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-823"><paramref name="name" /> 的长度为零。</span><span class="sxs-lookup"><span data-stu-id="43201-823">Length of <paramref name="name" /> is zero.</span></span>  
  
<span data-ttu-id="43201-824">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-824">-or-</span></span> 
 <span data-ttu-id="43201-825"><paramref name="size" /> 小于或等于零，或者大于或等于 0x003f0000。</span><span class="sxs-lookup"><span data-stu-id="43201-825"><paramref name="size" /> is less than or equal to zero, or greater than or equal to 0x003f0000.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-826"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-826"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-827">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</span><span class="sxs-lookup"><span data-stu-id="43201-827">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Reflection.Emit.TypeBuilder.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43201-828">检索此类型的完整路径。</span><span class="sxs-lookup"><span data-stu-id="43201-828">Retrieves the full path of this type.</span></span></summary>
        <value><span data-ttu-id="43201-829">只读。</span><span class="sxs-lookup"><span data-stu-id="43201-829">Read-only.</span></span> <span data-ttu-id="43201-830">检索此类型的完整路径。</span><span class="sxs-lookup"><span data-stu-id="43201-830">Retrieves the full path of this type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-831">对于嵌套类型，返回的格式为 "enclosingTypeFullName + nestedTypeName"; 对于非嵌套类型，则为 "typeName"。</span><span class="sxs-lookup"><span data-stu-id="43201-831">The returned format is "enclosingTypeFullName+nestedTypeName" for nested types and "typeName" for non-nested types.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Reflection.Emit.TypeBuilder.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43201-832">获取一个值，该值指示当前泛型类型参数的协变和特殊约束。</span><span class="sxs-lookup"><span data-stu-id="43201-832">Gets a value that indicates the covariance and special constraints of the current generic type parameter.</span></span></summary>
        <value><span data-ttu-id="43201-833"><see cref="T:System.Reflection.GenericParameterAttributes" /> 值的按位组合，用于描述当前泛型类型参数的协变和特殊约束。</span><span class="sxs-lookup"><span data-stu-id="43201-833">A bitwise combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> values that describes the covariance and special constraints of the current generic type parameter.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="43201-834">发出代码时，泛型类型参数由 <xref:System.Reflection.Emit.GenericTypeParameterBuilder> 对象而不是 <xref:System.Reflection.Emit.TypeBuilder> 对象表示。</span><span class="sxs-lookup"><span data-stu-id="43201-834">When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public override int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Reflection.Emit.TypeBuilder.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43201-835">获取声明参数的泛型类型的类型参数列表中的类型参数位置。</span><span class="sxs-lookup"><span data-stu-id="43201-835">Gets the position of a type parameter in the type parameter list of the generic type that declared the parameter.</span></span></summary>
        <value><span data-ttu-id="43201-836">如果当前 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 对象表示一个泛型类型参数，则为类型参数在声明它的泛型类型的类型参数列表中的位置；否则为未定义。</span><span class="sxs-lookup"><span data-stu-id="43201-836">If the current <see cref="T:System.Reflection.Emit.TypeBuilder" /> object represents a generic type parameter, the position of the type parameter in the type parameter list of the generic type that declared the parameter; otherwise, undefined.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="43201-837">发出代码时，泛型类型参数由 <xref:System.Reflection.Emit.GenericTypeParameterBuilder> 对象而不是 <xref:System.Reflection.Emit.TypeBuilder> 对象表示。</span><span class="sxs-lookup"><span data-stu-id="43201-837">When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="43201-838">如果当前 <xref:System.Reflection.Emit.TypeBuilder> 不表示泛型类型参数，则此属性的值是不确定的。</span><span class="sxs-lookup"><span data-stu-id="43201-838">If the current <xref:System.Reflection.Emit.TypeBuilder> does not represent a generic type parameter, the value of this property is undefined.</span></span> <span data-ttu-id="43201-839">使用 <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> 属性来确定当前 <xref:System.Reflection.Emit.TypeBuilder> 是否表示泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="43201-839">Use the <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> property to determine whether the current <xref:System.Reflection.Emit.TypeBuilder> represents a generic type parameter.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public override Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Reflection.Emit.TypeBuilder.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public override int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetArrayRank();" />
      <MemberSignature Language="F#" Value="override this.GetArrayRank : unit -&gt; int" Usage="typeBuilder.GetArrayRank " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="override this.GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="typeBuilder.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public static System.Reflection.ConstructorInfo GetConstructor (Type type, System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.ConstructorInfo GetConstructor(class System.Type type, class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::ConstructorInfo ^ GetConstructor(Type ^ type, System::Reflection::ConstructorInfo ^ constructor);" />
      <MemberSignature Language="F#" Value="static member GetConstructor : Type * System.Reflection.ConstructorInfo -&gt; System.Reflection.ConstructorInfo" Usage="System.Reflection.Emit.TypeBuilder.GetConstructor (type, constructor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="43201-840">已返回其构造函数的构造泛型类型。</span><span class="sxs-lookup"><span data-stu-id="43201-840">The constructed generic type whose constructor is returned.</span></span></param>
        <param name="constructor"><span data-ttu-id="43201-841">基于 <paramref name="type" /> 的泛型类型定义的构造函数，该函数指定要返回 <paramref name="type" /> 的哪个构造函数</span><span class="sxs-lookup"><span data-stu-id="43201-841">A constructor on the generic type definition of <paramref name="type" />, which specifies which constructor of <paramref name="type" /> to return.</span></span></param>
        <summary><span data-ttu-id="43201-842">返回与指定泛型类型定义的构造函数相对应的指定构造泛型类型的构造函数。</span><span class="sxs-lookup"><span data-stu-id="43201-842">Returns the constructor of the specified constructed generic type that corresponds to the specified constructor of the generic type definition.</span></span></summary>
        <returns><span data-ttu-id="43201-843"><see cref="T:System.Reflection.ConstructorInfo" /> 对象，它表示与 <paramref name="constructor" /> 对应的 <paramref name="type" /> 的构造函数，它指定属于 <paramref name="type" /> 的泛型类型定义的构造函数 。</span><span class="sxs-lookup"><span data-stu-id="43201-843">A <see cref="T:System.Reflection.ConstructorInfo" /> object that represents the constructor of <paramref name="type" /> corresponding to <paramref name="constructor" />, which specifies a constructor belonging to the generic type definition of <paramref name="type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-844"><xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> 方法提供了一种方法，用于获取表示构造泛型类型的构造函数的 <xref:System.Reflection.ConstructorInfo> 对象，其泛型类型定义由一个 <xref:System.Reflection.Emit.TypeBuilder> 对象表示。</span><span class="sxs-lookup"><span data-stu-id="43201-844">The <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> method provides a way to get a <xref:System.Reflection.ConstructorInfo> object that represents a constructor of a constructed generic type whose generic type definition is represented by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="43201-845">例如，假设您有一个 <xref:System.Reflection.Emit.TypeBuilder> 对象，该对象表示语法中C#的类型 `G<T>` （`G(Of T)` Visual Basic 中 `generic <T> ref class G` C++）和表示 <xref:System.Reflection.Emit.ConstructorBuilder> 构造函数的 `G<T>`对象。</span><span class="sxs-lookup"><span data-stu-id="43201-845">For example, suppose you have a <xref:System.Reflection.Emit.TypeBuilder> object that represents the type `G<T>` in C# syntax (`G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) and a <xref:System.Reflection.Emit.ConstructorBuilder> object that represents a constructor of `G<T>`.</span></span> <span data-ttu-id="43201-846">假定 `G<T>` 具有一个类型参数为 `U` 的泛型方法，该方法可创建构造类型 `G<U>`的实例。</span><span class="sxs-lookup"><span data-stu-id="43201-846">Suppose that `G<T>` has a generic method with type parameter `U` that creates an instance of the constructed type `G<U>`.</span></span> <span data-ttu-id="43201-847">为了发出代码以创建构造类型的实例，你需要一个表示此构造类型的构造函数的 <xref:System.Reflection.ConstructorInfo> 对象-换言之，它创建 `G<U>`的实例。</span><span class="sxs-lookup"><span data-stu-id="43201-847">In order to emit the code to create an instance of the constructed type, you need a <xref:System.Reflection.ConstructorInfo> object that represents the constructor of this constructed type - in other words, that creates an instance of `G<U>`.</span></span> <span data-ttu-id="43201-848">为此，请先对 <xref:System.Reflection.Emit.TypeBuilder> 对象调用 <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> 方法，并指定将 `U` 表示为类型参数的 <xref:System.Reflection.Emit.GenericTypeParameterBuilder> 对象。</span><span class="sxs-lookup"><span data-stu-id="43201-848">To do this, first call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on the <xref:System.Reflection.Emit.TypeBuilder> object, specifying the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object that represents `U` as the type argument.</span></span> <span data-ttu-id="43201-849">然后调用 <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> 方法，并将 <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> 方法的返回值作为参数 `type`，并将表示 `G<U>` 构造函数的 <xref:System.Reflection.Emit.ConstructorBuilder> 对象作为参数 `constructor`。</span><span class="sxs-lookup"><span data-stu-id="43201-849">Then call the <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> method with the return value of the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method as parameter `type` and the <xref:System.Reflection.Emit.ConstructorBuilder> object that represents the constructor of `G<U>` as parameter `constructor`.</span></span> <span data-ttu-id="43201-850">返回值是发出函数调用所需的 <xref:System.Reflection.ConstructorInfo> 对象。</span><span class="sxs-lookup"><span data-stu-id="43201-850">The return value is the <xref:System.Reflection.ConstructorInfo> object you need to emit the function call.</span></span> <span data-ttu-id="43201-851">此代码示例演示了这种情况。</span><span class="sxs-lookup"><span data-stu-id="43201-851">The code example demonstrates this scenario.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43201-852">下面的代码示例包含一个名为 `Sample` 的泛型类的源代码，该类具有名为 `T`的类型参数。</span><span class="sxs-lookup"><span data-stu-id="43201-852">The following code example contains source code for a generic class named `Sample` that has a type parameter named `T`.</span></span> <span data-ttu-id="43201-853">类有一个名为 `Field`、类型为 `T`的字段和一个名为 `GM` 的泛型方法，该方法具有其自己的类型参数，名为 "`U`"。</span><span class="sxs-lookup"><span data-stu-id="43201-853">The class has a field named `Field`, of type `T`, and a generic method named `GM` with its own type parameter, named `U`.</span></span> <span data-ttu-id="43201-854">方法 `GM` 创建 `Sample`的实例，将其自己的类型参数替换为 `Sample`的类型参数 `U`，并将其输入参数存储在 `Field`中。</span><span class="sxs-lookup"><span data-stu-id="43201-854">Method `GM` creates an instance of `Sample`, substituting its own type parameter `U` for the type parameter of `Sample`, and stores its input parameter in `Field`.</span></span> <span data-ttu-id="43201-855">已编译但未使用此源代码;可以使用[Ildasm （IL 拆装器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)查看它，并将其与类 `Example`所发出的代码进行比较。</span><span class="sxs-lookup"><span data-stu-id="43201-855">This source code is compiled but not used; you can view it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) and compare it to the code emitted by class `Example`.</span></span>  
  
 <span data-ttu-id="43201-856">类 `Example` 中的代码演示如何使用 <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> 方法发出泛型代码。</span><span class="sxs-lookup"><span data-stu-id="43201-856">The code in class `Example` demonstrates the use of the <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> method to emit generic code.</span></span> <span data-ttu-id="43201-857">类 `Example` 的 `Main` 方法创建了一个动态程序集，其中包含一个名为的类 `Sample`，并使用 <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> 方法通过添加一个名为 `T`的类型参数使其成为泛型。</span><span class="sxs-lookup"><span data-stu-id="43201-857">The `Main` method of class `Example` creates a dynamic assembly containing a class named `Sample` and uses the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method to make it generic by adding a type parameter named `T`.</span></span> <span data-ttu-id="43201-858">`T`类型的无参数构造函数和名为 `Field`的字段将添加到类 `Sample`。</span><span class="sxs-lookup"><span data-stu-id="43201-858">A parameterless constructor and a field named `Field`, of type `T`, are added to class `Sample`.</span></span> <span data-ttu-id="43201-859">使用 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> 方法添加并转换为泛型方法 `GM` 的方法。</span><span class="sxs-lookup"><span data-stu-id="43201-859">A method `GM` is added and turned into a generic method by using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="43201-860">`GM` 的类型参数名为 `U`。</span><span class="sxs-lookup"><span data-stu-id="43201-860">The type parameter of `GM` is named `U`.</span></span> <span data-ttu-id="43201-861">定义类型参数后，将使用 <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> 方法添加 `GM` 的签名。</span><span class="sxs-lookup"><span data-stu-id="43201-861">After the type parameter is defined, the signature of `GM` is added by using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="43201-862">没有返回类型，并且没有必需的修饰符或自定义修饰符，因此此方法的所有参数都是 `null` `parameterTypes`;`parameterTypes` 将方法的唯一参数类型设置为 `U`的方法的泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="43201-862">There is no return type and no required or custom modifiers, so all the parameters of this method are `null` except `parameterTypes`; `parameterTypes` sets the type of the method's only parameter to `U`, the method's generic type parameter.</span></span> <span data-ttu-id="43201-863">方法的主体创建构造类型的实例 `Sample<U>` （`Sample(Of U)` 在 Visual Basic 中），将该方法的参数分配给 `Field`，然后打印 `Field`的值。</span><span class="sxs-lookup"><span data-stu-id="43201-863">The body of the method creates an instance of the constructed type `Sample<U>` (`Sample(Of U)` in Visual Basic), assigns the method's parameter to `Field`, and then prints the value of `Field`.</span></span> <span data-ttu-id="43201-864"><xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> 方法用于创建表示构造泛型 `Sample<U>` 类型的无参数构造函数的 <xref:System.Reflection.ConstructorInfo>，该构造函数用于创建实例的 <xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType> 指令中。</span><span class="sxs-lookup"><span data-stu-id="43201-864">The <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> method is used to create a <xref:System.Reflection.ConstructorInfo> that represents the parameterless constructor of the constructed generic type `Sample<U>` in the <xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType> instruction that creates the instance.</span></span>  
  
 <span data-ttu-id="43201-865">定义了一个虚拟类型来保存入口点方法 `Main`。</span><span class="sxs-lookup"><span data-stu-id="43201-865">A dummy type is defined to hold the entry-point method `Main`.</span></span> <span data-ttu-id="43201-866">在 `Main`的主体中，将在构造的泛型类型 `Sample<int>` （`Sample(Of Integer)` 中的 Visual Basic）中调用静态 `GM` 方法，并将类型 <xref:System.String> 替换为 `U`。</span><span class="sxs-lookup"><span data-stu-id="43201-866">In the body of `Main`, the static `GM` method is invoked on the constructed generic type `Sample<int>` (`Sample(Of Integer)` in Visual Basic), with type <xref:System.String> substituted for `U`.</span></span>  
  
 <span data-ttu-id="43201-867">运行代码示例时，它会将发出的程序集保存为 TypeBuilderGetFieldExample。</span><span class="sxs-lookup"><span data-stu-id="43201-867">When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</span></span> <span data-ttu-id="43201-868">您可以运行 TypeBuilderGetFieldExample，并且可以使用[Ildasm （IL 拆装器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)将发出的代码与编译为代码示例本身的 `Sample` 类的代码进行比较。</span><span class="sxs-lookup"><span data-stu-id="43201-868">You can run TypeBuilderGetFieldExample.exe, and you can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to compare the emitted code with the code for the `Sample` class that is compiled into the code example itself.</span></span>  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-869"><paramref name="type" /> 不表示泛型类型。</span><span class="sxs-lookup"><span data-stu-id="43201-869"><paramref name="type" /> does not represent a generic type.</span></span>  
  
<span data-ttu-id="43201-870">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-870">-or-</span></span> 
 <span data-ttu-id="43201-871"><paramref name="type" /> 的类型不是 <see cref="T:System.Reflection.Emit.TypeBuilder" />。</span><span class="sxs-lookup"><span data-stu-id="43201-871"><paramref name="type" /> is not of type <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span></span>  
  
<span data-ttu-id="43201-872">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-872">-or-</span></span> 
<span data-ttu-id="43201-873"><paramref name="constructor" /> 的声明类型不是一个泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="43201-873">The declaring type of <paramref name="constructor" /> is not a generic type definition.</span></span>  
  
<span data-ttu-id="43201-874">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-874">-or-</span></span> 
<span data-ttu-id="43201-875"><paramref name="constructor" /> 的声明类型不是 <paramref name="type" /> 的泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="43201-875">The declaring type of <paramref name="constructor" /> is not the generic type definition of <paramref name="type" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="override this.GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="typeBuilder.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public override System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="typeBuilder.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="43201-876">这必须是 <see cref="T:System.Reflection.BindingFlags" /> 中的位标志，类似于 <see langword="InvokeMethod" />、<see langword="NonPublic" /> 等中的位标志。</span><span class="sxs-lookup"><span data-stu-id="43201-876">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span></span></param>
        <summary><span data-ttu-id="43201-877">按照指定，返回 <see cref="T:System.Reflection.ConstructorInfo" /> 对象的数组，表示为此类定义的公共和非公共构造函数。</span><span class="sxs-lookup"><span data-stu-id="43201-877">Returns an array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing the public and non-public constructors defined for this class, as specified.</span></span></summary>
        <returns><span data-ttu-id="43201-878">返回 <see cref="T:System.Reflection.ConstructorInfo" /> 对象的数组，表示为此类定义的指定构造函数。</span><span class="sxs-lookup"><span data-stu-id="43201-878">Returns an array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing the specified constructors defined for this class.</span></span> <span data-ttu-id="43201-879">如果未定义任何构造函数，则返回一个空数组。</span><span class="sxs-lookup"><span data-stu-id="43201-879">If no constructors are defined, an empty array is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-880">使用 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 或 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 检索该类型，并对检索到的类型使用反射。</span><span class="sxs-lookup"><span data-stu-id="43201-880">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="43201-881">不会为不完整类型实现此方法。</span><span class="sxs-lookup"><span data-stu-id="43201-881">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="43201-882">返回为此类型定义的自定义属性。</span><span class="sxs-lookup"><span data-stu-id="43201-882">Returns the custom attributes defined for this type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="typeBuilder.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="inherit"><span data-ttu-id="43201-883">指定是否搜索此成员的继承链以查找属性。</span><span class="sxs-lookup"><span data-stu-id="43201-883">Specifies whether to search this member's inheritance chain to find the attributes.</span></span></param>
        <summary><span data-ttu-id="43201-884">返回为此类型定义的所有自定义属性。</span><span class="sxs-lookup"><span data-stu-id="43201-884">Returns all the custom attributes defined for this type.</span></span></summary>
        <returns><span data-ttu-id="43201-885">返回一个对象数组，其中的对象表示此类型的所有自定义属性。</span><span class="sxs-lookup"><span data-stu-id="43201-885">Returns an array of objects representing all the custom attributes of this type.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="43201-886">不完整类型目前不支持此方法。</span><span class="sxs-lookup"><span data-stu-id="43201-886">This method is not currently supported for incomplete types.</span></span> <span data-ttu-id="43201-887">使用 <see cref="M:System.Type.GetType" /> 检索此类型，并对返回的 <see cref="T:System.Type" /> 调用 <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />。</span><span class="sxs-lookup"><span data-stu-id="43201-887">Retrieve the type using <see cref="M:System.Type.GetType" /> and call <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> on the returned <see cref="T:System.Type" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="typeBuilder.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="43201-888">要搜索的属性的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-888">The type of attribute to search for.</span></span> <span data-ttu-id="43201-889">仅返回可分配给此类型的属性。</span><span class="sxs-lookup"><span data-stu-id="43201-889">Only attributes that are assignable to this type are returned.</span></span></param>
        <param name="inherit"><span data-ttu-id="43201-890">指定是否搜索此成员的继承链以查找属性。</span><span class="sxs-lookup"><span data-stu-id="43201-890">Specifies whether to search this member's inheritance chain to find the attributes.</span></span></param>
        <summary><span data-ttu-id="43201-891">返回当前类型的所有自定义属性，该属性可分配给指定类型。</span><span class="sxs-lookup"><span data-stu-id="43201-891">Returns all the custom attributes of the current type that are assignable to a specified type.</span></span></summary>
        <returns><span data-ttu-id="43201-892">在当前类型上定义的自定义属性数组。</span><span class="sxs-lookup"><span data-stu-id="43201-892">An array of custom attributes defined on the current type.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="43201-893">不完整类型目前不支持此方法。</span><span class="sxs-lookup"><span data-stu-id="43201-893">This method is not currently supported for incomplete types.</span></span> <span data-ttu-id="43201-894">使用 <see cref="M:System.Type.GetType" /> 检索此类型，并对返回的 <see cref="T:System.Type" /> 调用 <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />。</span><span class="sxs-lookup"><span data-stu-id="43201-894">Retrieve the type using <see cref="M:System.Type.GetType" /> and call <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> on the returned <see cref="T:System.Type" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-895"><paramref name="attributeType" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-895"><paramref name="attributeType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-896">该类型必须是由基础运行时系统提供的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-896">The type must be a type provided by the underlying runtime system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public override Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="override this.GetElementType : unit -&gt; Type" Usage="typeBuilder.GetElementType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43201-897">调用此方法始终引发 <see cref="T:System.NotSupportedException" />。</span><span class="sxs-lookup"><span data-stu-id="43201-897">Calling this method always throws <see cref="T:System.NotSupportedException" />.</span></span></summary>
        <returns><span data-ttu-id="43201-898">不支持此方法。</span><span class="sxs-lookup"><span data-stu-id="43201-898">This method is not supported.</span></span> <span data-ttu-id="43201-899">不返回任何值。</span><span class="sxs-lookup"><span data-stu-id="43201-899">No value is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-900">使用 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 或 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 检索该类型，并对检索到的类型使用反射。</span><span class="sxs-lookup"><span data-stu-id="43201-900">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="43201-901">不支持此方法。</span><span class="sxs-lookup"><span data-stu-id="43201-901">This method is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="typeBuilder.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="43201-902">要搜索的事件的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-902">The name of the event to search for.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="43201-903">用于限制搜索的 <see cref="T:System.Reflection.BindingFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="43201-903">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limits the search.</span></span></param>
        <summary><span data-ttu-id="43201-904">返回具有指定名称的事件。</span><span class="sxs-lookup"><span data-stu-id="43201-904">Returns the event with the specified name.</span></span></summary>
        <returns><span data-ttu-id="43201-905">一个 <see cref="T:System.Reflection.EventInfo" /> 对象，表示这个指定名称的类型声明或继承的事件；如果没有匹配项，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-905">An <see cref="T:System.Reflection.EventInfo" /> object representing the event declared or inherited by this type with the specified name, or <see langword="null" /> if there are no matches.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-906">使用 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 或 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 检索该类型，并对检索到的类型使用反射。</span><span class="sxs-lookup"><span data-stu-id="43201-906">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="43201-907">不会为不完整类型实现此方法。</span><span class="sxs-lookup"><span data-stu-id="43201-907">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="43201-908">返回由当前 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 定义的事件。</span><span class="sxs-lookup"><span data-stu-id="43201-908">Returns the events defined by the current <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="typeBuilder.GetEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43201-909">返回此类型声明或继承的公共事件。</span><span class="sxs-lookup"><span data-stu-id="43201-909">Returns the public events declared or inherited by this type.</span></span></summary>
        <returns><span data-ttu-id="43201-910">返回 <see cref="T:System.Reflection.EventInfo" /> 对象的数组，表示此类型声明或继承的公共事件。</span><span class="sxs-lookup"><span data-stu-id="43201-910">Returns an array of <see cref="T:System.Reflection.EventInfo" /> objects representing the public events declared or inherited by this type.</span></span> <span data-ttu-id="43201-911">如果没有任何公共事件，则返回一个空数组。</span><span class="sxs-lookup"><span data-stu-id="43201-911">An empty array is returned if there are no public events.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-912">使用 <xref:System.Type.GetType%2A> 或 <xref:System.Reflection.Assembly.GetType%2A> 检索该类型，并对检索到的类型使用反射。</span><span class="sxs-lookup"><span data-stu-id="43201-912">Retrieve the type using <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetType%2A> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="43201-913">不会为不完整类型实现此方法。</span><span class="sxs-lookup"><span data-stu-id="43201-913">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="typeBuilder.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="43201-914">用于限制搜索的 <see cref="T:System.Reflection.BindingFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="43201-914">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limits the search.</span></span></param>
        <summary><span data-ttu-id="43201-915">返回此类型声明的公共和非公共事件。</span><span class="sxs-lookup"><span data-stu-id="43201-915">Returns the public and non-public events that are declared by this type.</span></span></summary>
        <returns><span data-ttu-id="43201-916">返回 <see cref="T:System.Reflection.EventInfo" /> 对象的数组，表示此类型声明或继承的与指定的绑定标志匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="43201-916">Returns an array of <see cref="T:System.Reflection.EventInfo" /> objects representing the events declared or inherited by this type that match the specified binding flags.</span></span> <span data-ttu-id="43201-917">如果没有匹配的事件，则返回空数组。</span><span class="sxs-lookup"><span data-stu-id="43201-917">An empty array is returned if there are no matching events.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-918">使用 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 或 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 检索该类型，并对检索到的类型使用反射。</span><span class="sxs-lookup"><span data-stu-id="43201-918">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="43201-919">不会为不完整类型实现此方法。</span><span class="sxs-lookup"><span data-stu-id="43201-919">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="43201-920">返回由当前 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 定义的字段。</span><span class="sxs-lookup"><span data-stu-id="43201-920">Returns a field defined by the current <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="typeBuilder.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="43201-921">要获取的字段的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-921">The name of the field to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="43201-922">这必须是 <see cref="T:System.Reflection.BindingFlags" /> 中的位标志，类似于 <see langword="InvokeMethod" />、<see langword="NonPublic" /> 等中的位标志。</span><span class="sxs-lookup"><span data-stu-id="43201-922">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span></span></param>
        <summary><span data-ttu-id="43201-923">返回由给定名称指定的字段。</span><span class="sxs-lookup"><span data-stu-id="43201-923">Returns the field specified by the given name.</span></span></summary>
        <returns><span data-ttu-id="43201-924">返回 <see cref="T:System.Reflection.FieldInfo" /> 对象，该对象表示由此类型声明或继承的具有指定名称和公共或非公共修饰符的字段。</span><span class="sxs-lookup"><span data-stu-id="43201-924">Returns the <see cref="T:System.Reflection.FieldInfo" /> object representing the field declared or inherited by this type with the specified name and public or non-public modifier.</span></span> <span data-ttu-id="43201-925">如果没有匹配项，则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-925">If there are no matches then <see langword="null" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-926">使用 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 或 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 检索该类型，并对检索到的类型使用反射。</span><span class="sxs-lookup"><span data-stu-id="43201-926">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="43201-927">不会为不完整类型实现此方法。</span><span class="sxs-lookup"><span data-stu-id="43201-927">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public static System.Reflection.FieldInfo GetField (Type type, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.FieldInfo GetField(class System.Type type, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::FieldInfo ^ GetField(Type ^ type, System::Reflection::FieldInfo ^ field);" />
      <MemberSignature Language="F#" Value="static member GetField : Type * System.Reflection.FieldInfo -&gt; System.Reflection.FieldInfo" Usage="System.Reflection.Emit.TypeBuilder.GetField (type, field)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="43201-928">返回其字段的构造泛型类型。</span><span class="sxs-lookup"><span data-stu-id="43201-928">The constructed generic type whose field is returned.</span></span></param>
        <param name="field"><span data-ttu-id="43201-929"><paramref name="type" /> 的泛型类型定义中的一个字段，用于指定要返回 <paramref name="type" /> 的哪一个字段。</span><span class="sxs-lookup"><span data-stu-id="43201-929">A field on the generic type definition of <paramref name="type" />, which specifies which field of <paramref name="type" /> to return.</span></span></param>
        <summary><span data-ttu-id="43201-930">返回指定的构造泛型类型的字段，该字段对应于泛型类型定义的指定字段。</span><span class="sxs-lookup"><span data-stu-id="43201-930">Returns the field of the specified constructed generic type that corresponds to the specified field of the generic type definition.</span></span></summary>
        <returns><span data-ttu-id="43201-931"><see cref="T:System.Reflection.FieldInfo" /> 对象，它表示与 <paramref name="field" /> 对应的 <paramref name="type" /> 的字段，用于指定属于 <paramref name="type" /> 的泛型类型定义的字段。</span><span class="sxs-lookup"><span data-stu-id="43201-931">A <see cref="T:System.Reflection.FieldInfo" /> object that represents the field of <paramref name="type" /> corresponding to <paramref name="field" />, which specifies a field belonging to the generic type definition of <paramref name="type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-932"><xref:System.Reflection.Emit.TypeBuilder.GetField%2A> 方法提供一种方法来获取表示构造泛型类型（其泛型类型定义由 <xref:System.Reflection.Emit.TypeBuilder> 对象表示）的字段的 <xref:System.Reflection.FieldInfo> 对象。</span><span class="sxs-lookup"><span data-stu-id="43201-932">The <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> method provides a way to get a <xref:System.Reflection.FieldInfo> object that represents a field of a constructed generic type whose generic type definition is represented by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="43201-933">例如，假设您有一个表示C# `G<T>` 语法中的类型的 <xref:System.Reflection.Emit.TypeBuilder> 对象（在 Visual Basic 中为`G(Of T)`，`generic <T> ref class G` C++在中），而 <xref:System.Reflection.Emit.FieldBuilder> 对象表示 `public T F` 所定义C#的语法C++中的`Public F As T` Visual Basic `public: T F` `G<T>`中的字段。</span><span class="sxs-lookup"><span data-stu-id="43201-933">For example, suppose you have a <xref:System.Reflection.Emit.TypeBuilder> object that represents the type `G<T>` in C# syntax (`G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) and a <xref:System.Reflection.Emit.FieldBuilder> object that represents a field `public T F` in C# syntax (`Public F As T` in Visual Basic, `public: T F` in C++) that is defined by `G<T>`.</span></span> <span data-ttu-id="43201-934">假定 `G<T>` 具有一个类型参数为 `U` 的泛型方法，该方法可创建构造类型的实例 `G<U>` 并对该实例调用字段 `F`。</span><span class="sxs-lookup"><span data-stu-id="43201-934">Suppose that `G<T>` has a generic method with type parameter `U` that creates an instance of the constructed type `G<U>` and calls field `F` on that instance.</span></span> <span data-ttu-id="43201-935">为了发出函数调用，需要一个表示构造类型上 `F` 的 <xref:System.Reflection.FieldInfo> 对象，即类型 `U`，而不是 `T`类型。</span><span class="sxs-lookup"><span data-stu-id="43201-935">In order to emit the function call, you need a <xref:System.Reflection.FieldInfo> object that represents `F` on the constructed type - in other words, that is of type `U` rather than type `T`.</span></span> <span data-ttu-id="43201-936">为此，请先对 <xref:System.Reflection.Emit.TypeBuilder> 对象调用 <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> 方法，并指定将 `U` 表示为类型参数的 <xref:System.Reflection.Emit.GenericTypeParameterBuilder> 对象。</span><span class="sxs-lookup"><span data-stu-id="43201-936">To do this, first call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on the <xref:System.Reflection.Emit.TypeBuilder> object, specifying the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object that represents `U` as the type argument.</span></span> <span data-ttu-id="43201-937">然后调用 <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> 方法，并将 <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> 方法的返回值作为参数 `type`，并将表示 `F` 的 <xref:System.Reflection.Emit.FieldBuilder> 对象作为参数 `field`。</span><span class="sxs-lookup"><span data-stu-id="43201-937">Then call the <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> method with the return value of the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method as parameter `type` and the <xref:System.Reflection.Emit.FieldBuilder> object that represents `F` as parameter `field`.</span></span> <span data-ttu-id="43201-938">返回值是发出函数调用所需的 <xref:System.Reflection.FieldInfo> 对象。</span><span class="sxs-lookup"><span data-stu-id="43201-938">The return value is the <xref:System.Reflection.FieldInfo> object you need to emit the function call.</span></span> <span data-ttu-id="43201-939">此代码示例演示了这种情况。</span><span class="sxs-lookup"><span data-stu-id="43201-939">The code example demonstrates this scenario.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43201-940">下面的代码示例包含名为 Sample 的泛型类的源代码，该类具有名为 `T`的类型参数。</span><span class="sxs-lookup"><span data-stu-id="43201-940">The following code example contains source code for a generic class named Sample that has a type parameter named `T`.</span></span> <span data-ttu-id="43201-941">类有一个名为 `Field`、类型为 `T`的字段和一个名为 `GM` 的泛型方法，该方法具有其自己的类型参数，名为 "`U`"。</span><span class="sxs-lookup"><span data-stu-id="43201-941">The class has a field named `Field`, of type `T`, and a generic method named `GM` with its own type parameter, named `U`.</span></span> <span data-ttu-id="43201-942">方法 `GM` 创建 `Sample`的实例，将其自己的类型参数替换为 `Sample`的类型参数 `U`，并将其输入参数存储在 `Field`中。</span><span class="sxs-lookup"><span data-stu-id="43201-942">Method `GM` creates an instance of `Sample`, substituting its own type parameter `U` for the type parameter of `Sample`, and stores its input parameter in `Field`.</span></span> <span data-ttu-id="43201-943">已编译但未使用此源代码;可以使用[Ildasm （IL 拆装器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)查看它，并将其与类 `Example`所发出的代码进行比较。</span><span class="sxs-lookup"><span data-stu-id="43201-943">This source code is compiled but not used; you can view it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) and compare it to the code emitted by class `Example`.</span></span>  
  
 <span data-ttu-id="43201-944">类 `Example` 中的代码演示如何使用 <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> 方法发出泛型代码。</span><span class="sxs-lookup"><span data-stu-id="43201-944">The code in class `Example` demonstrates the use of the <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> method to emit generic code.</span></span> <span data-ttu-id="43201-945">类 `Example` 的 `Main` 方法创建一个包含名为 `Sample`的类的动态程序集，并使用 <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> 方法通过添加一个名为 `T`的类型参数使其成为泛型。</span><span class="sxs-lookup"><span data-stu-id="43201-945">The `Main` method of class `Example` creates a dynamic assembly containing a class named `Sample`, and uses the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method to make it generic by adding a type parameter named `T`.</span></span> <span data-ttu-id="43201-946">`T`类型的无参数构造函数和名为 `Field`的字段将添加到类 `Sample`。</span><span class="sxs-lookup"><span data-stu-id="43201-946">A parameterless constructor and a field named `Field`, of type `T`, are added to class `Sample`.</span></span> <span data-ttu-id="43201-947">使用 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> 方法添加并转换为泛型方法 `GM` 的方法。</span><span class="sxs-lookup"><span data-stu-id="43201-947">A method `GM` is added and turned into a generic method by using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="43201-948">`GM` 的类型参数名为 `U`。</span><span class="sxs-lookup"><span data-stu-id="43201-948">The type parameter of `GM` is named `U`.</span></span> <span data-ttu-id="43201-949">定义类型参数后，将使用 <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> 方法添加 `GM` 的签名。</span><span class="sxs-lookup"><span data-stu-id="43201-949">After the type parameter is defined, the signature of `GM` is added by using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="43201-950">没有返回类型，并且没有必需的修饰符或自定义修饰符，因此此方法的所有参数都是 `null` `parameterTypes`;`parameterTypes` 将方法的唯一参数类型设置为 `U`的方法的泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="43201-950">There is no return type and no required or custom modifiers, so all the parameters of this method are `null` except `parameterTypes`; `parameterTypes` sets the type of the method's only parameter to `U`, the method's generic type parameter.</span></span> <span data-ttu-id="43201-951">方法的主体创建构造类型的实例 `Sample<U>` （`Sample(Of U)` 在 Visual Basic 中），将该方法的参数分配给 `Field`，然后打印 `Field`的值。</span><span class="sxs-lookup"><span data-stu-id="43201-951">The body of the method creates an instance of the constructed type `Sample<U>` (`Sample(Of U)` in Visual Basic), assigns the method's parameter to `Field`, and then prints the value of `Field`.</span></span> <span data-ttu-id="43201-952"><xref:System.Reflection.Emit.TypeBuilder.GetField%2A> 方法用于创建 <xref:System.Reflection.FieldInfo>，它表示 <xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType> 和 <xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType> 说明中构造的泛型类型 `Sample<U>` 的字段。</span><span class="sxs-lookup"><span data-stu-id="43201-952">The <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> method is used to create a <xref:System.Reflection.FieldInfo> that represents the field of the constructed generic type `Sample<U>` in the <xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType> and <xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType> instructions.</span></span>  
  
 <span data-ttu-id="43201-953">定义了一个虚拟类型来保存入口点方法 `Main`。</span><span class="sxs-lookup"><span data-stu-id="43201-953">A dummy type is defined to hold the entry-point method `Main`.</span></span> <span data-ttu-id="43201-954">在 `Main`的主体中，将在构造的泛型类型 `Sample<int>` （`Sample(Of Integer)` 中的 Visual Basic）中调用静态 `GM` 方法，并将类型 <xref:System.String> 替换为 `U`。</span><span class="sxs-lookup"><span data-stu-id="43201-954">In the body of `Main`, the static `GM` method is invoked on the constructed generic type `Sample<int>` (`Sample(Of Integer)` in Visual Basic), with type <xref:System.String> substituted for `U`.</span></span>  
  
 <span data-ttu-id="43201-955">运行代码示例时，它会将发出的程序集保存为 TypeBuilderGetFieldExample。</span><span class="sxs-lookup"><span data-stu-id="43201-955">When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</span></span> <span data-ttu-id="43201-956">您可以运行 TypeBuilderGetFieldExample，并且可以使用[Ildasm （IL 拆装器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)将发出的代码与编译为代码示例本身的 `Sample` 类的代码进行比较。</span><span class="sxs-lookup"><span data-stu-id="43201-956">You can run TypeBuilderGetFieldExample.exe, and you can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to compare the emitted code with the code for the `Sample` class that is compiled into the code example itself.</span></span>  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-957"><paramref name="type" /> 不表示泛型类型。</span><span class="sxs-lookup"><span data-stu-id="43201-957"><paramref name="type" /> does not represent a generic type.</span></span>  
  
<span data-ttu-id="43201-958">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-958">-or-</span></span> 
 <span data-ttu-id="43201-959"><paramref name="type" /> 的类型不是 <see cref="T:System.Reflection.Emit.TypeBuilder" />。</span><span class="sxs-lookup"><span data-stu-id="43201-959"><paramref name="type" /> is not of type <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span></span>  
  
<span data-ttu-id="43201-960">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-960">-or-</span></span> 
<span data-ttu-id="43201-961"><paramref name="field" /> 的声明类型不是一个泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="43201-961">The declaring type of <paramref name="field" /> is not a generic type definition.</span></span>  
  
<span data-ttu-id="43201-962">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-962">-or-</span></span> 
<span data-ttu-id="43201-963"><paramref name="field" /> 的声明类型不是 <paramref name="type" /> 的泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="43201-963">The declaring type of <paramref name="field" /> is not the generic type definition of <paramref name="type" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="typeBuilder.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="43201-964">这必须是来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志：<see langword="InvokeMethod" />、<see langword="NonPublic" /> 等等。</span><span class="sxs-lookup"><span data-stu-id="43201-964">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span></span></param>
        <summary><span data-ttu-id="43201-965">返回此类型声明的公共和非公共字段。</span><span class="sxs-lookup"><span data-stu-id="43201-965">Returns the public and non-public fields that are declared by this type.</span></span></summary>
        <returns><span data-ttu-id="43201-966">返回 <see cref="T:System.Reflection.FieldInfo" /> 对象的数组，表示此类型声明或继承的公共和非公共字段。</span><span class="sxs-lookup"><span data-stu-id="43201-966">Returns an array of <see cref="T:System.Reflection.FieldInfo" /> objects representing the public and non-public fields declared or inherited by this type.</span></span> <span data-ttu-id="43201-967">按照指定，如果没有字段，则返回空数组。</span><span class="sxs-lookup"><span data-stu-id="43201-967">An empty array is returned if there are no fields, as specified.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-968"><xref:System.Reflection.Emit.TypeBuilder.GetFields%2A> 方法不按特定顺序（如字母顺序或声明顺序）返回字段。</span><span class="sxs-lookup"><span data-stu-id="43201-968">The <xref:System.Reflection.Emit.TypeBuilder.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="43201-969">你的代码不能依赖于字段的返回顺序，因为该顺序可能会有所不同。</span><span class="sxs-lookup"><span data-stu-id="43201-969">Your code must not depend on the order in which fields are returned, because that order can vary.</span></span>  
  
 <span data-ttu-id="43201-970">使用 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 或 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 检索该类型，并对检索到的类型使用反射。</span><span class="sxs-lookup"><span data-stu-id="43201-970">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="43201-971">不会为不完整类型实现此方法。</span><span class="sxs-lookup"><span data-stu-id="43201-971">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="override this.GetGenericArguments : unit -&gt; Type[]" Usage="typeBuilder.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43201-972">返回一个 <see cref="T:System.Type" /> 对象的数组，表示泛型类型的类型变量或泛型类型定义的类型参数。</span><span class="sxs-lookup"><span data-stu-id="43201-972">Returns an array of <see cref="T:System.Type" /> objects representing the type arguments of a generic type or the type parameters of a generic type definition.</span></span></summary>
        <returns><span data-ttu-id="43201-973">一个 <see cref="T:System.Type" /> 对象数组。</span><span class="sxs-lookup"><span data-stu-id="43201-973">An array of <see cref="T:System.Type" /> objects.</span></span> <span data-ttu-id="43201-974">此数组的元素表示泛型类型的类型参数或泛型类型定义的类型参数。</span><span class="sxs-lookup"><span data-stu-id="43201-974">The elements of the array represent the type arguments of a generic type or the type parameters of a generic type definition.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-975">返回数组的元素按它们出现在泛型类型定义的类型参数列表中的顺序排列。</span><span class="sxs-lookup"><span data-stu-id="43201-975">The elements of the returned array are in the order in which they appear in the list of type parameters for the generic type definition.</span></span>  
  
 <span data-ttu-id="43201-976">如果 <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> 方法已用于为其提供泛型类型参数，则 <xref:System.Reflection.Emit.TypeBuilder> 对象表示泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="43201-976">A <xref:System.Reflection.Emit.TypeBuilder> object represents a generic type definition if the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method has been used to give it generic type parameters.</span></span> <span data-ttu-id="43201-977">此方法检索表示泛型类型参数的 <xref:System.Reflection.Emit.GenericTypeParameterBuilder> 对象。</span><span class="sxs-lookup"><span data-stu-id="43201-977">This method retrieves the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objects that represent the generic type parameters.</span></span>  
  
 <span data-ttu-id="43201-978">若要详细了解反射中的泛型类型和泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="43201-978">For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericArguments" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="typeBuilder.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetGenericTypeDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="typeBuilder.GetGenericTypeDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43201-979">返回一个 <see cref="T:System.Type" /> 对象，该对象表示可从中获取当前类型的泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="43201-979">Returns a <see cref="T:System.Type" /> object that represents a generic type definition from which the current type can be obtained.</span></span></summary>
        <returns><span data-ttu-id="43201-980">一个 <see cref="T:System.Type" /> 对象，该对象表示可从中获取当前类型的泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="43201-980">A <see cref="T:System.Type" /> object representing a generic type definition from which the current type can be obtained.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-981">如果对 <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> 属性返回 `true`的 <xref:System.Reflection.Emit.TypeBuilder> 对象调用 <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> 方法，则 <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> 属性返回当前实例。</span><span class="sxs-lookup"><span data-stu-id="43201-981">If you call the <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> method on a <xref:System.Reflection.Emit.TypeBuilder> object for which the <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> property returns `true`, the <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> property returns the current instance.</span></span> <span data-ttu-id="43201-982">表示泛型类型的 <xref:System.Reflection.Emit.TypeBuilder> 始终是泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="43201-982">A <xref:System.Reflection.Emit.TypeBuilder> that represents a generic type is always a generic type definition.</span></span>  
  
 <span data-ttu-id="43201-983">如果使用 <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> 方法从表示泛型类型定义的 <xref:System.Reflection.Emit.TypeBuilder> 对象构造泛型类型，则使用构造类型上的 <xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType> 方法将返回表示泛型类型定义的 <xref:System.Reflection.Emit.TypeBuilder> 对象。</span><span class="sxs-lookup"><span data-stu-id="43201-983">If you used the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method to construct a generic type from a <xref:System.Reflection.Emit.TypeBuilder> object that represents a generic type definition, using the <xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType> method on the constructed type gets back the <xref:System.Reflection.Emit.TypeBuilder> object that represents the generic type definition.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-984">当前类型不为泛型。</span><span class="sxs-lookup"><span data-stu-id="43201-984">The current type is not generic.</span></span> <span data-ttu-id="43201-985">也就是说，<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43201-985">That is, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> returns <see langword="false" />.</span></span></exception>
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public override Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetInterface : string * bool -&gt; Type" Usage="typeBuilder.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="43201-986">接口的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-986">The name of the interface.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="43201-987">如果为 <see langword="true" />，则搜索不区分大小写。</span><span class="sxs-lookup"><span data-stu-id="43201-987">If <see langword="true" />, the search is case-insensitive.</span></span> <span data-ttu-id="43201-988">如果为 <see langword="false" />，则搜索区分大小写。</span><span class="sxs-lookup"><span data-stu-id="43201-988">If <see langword="false" />, the search is case-sensitive.</span></span></param>
        <summary><span data-ttu-id="43201-989">返回由此类直接或间接实现的接口，该接口具有与给定接口名匹配的完全限定名。</span><span class="sxs-lookup"><span data-stu-id="43201-989">Returns the interface implemented (directly or indirectly) by this class with the fully qualified name matching the given interface name.</span></span></summary>
        <returns><span data-ttu-id="43201-990">返回 <see cref="T:System.Type" /> 对象，该对象表示实现的接口。</span><span class="sxs-lookup"><span data-stu-id="43201-990">Returns a <see cref="T:System.Type" /> object representing the implemented interface.</span></span> <span data-ttu-id="43201-991">如果未找到名称匹配的接口，则返回 null。</span><span class="sxs-lookup"><span data-stu-id="43201-991">Returns null if no interface matching name is found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-992">使用 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 或 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 检索该类型，并对检索到的类型使用反射。</span><span class="sxs-lookup"><span data-stu-id="43201-992">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="43201-993">不会为不完整类型实现此方法。</span><span class="sxs-lookup"><span data-stu-id="43201-993">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public override System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="typeBuilder.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="interfaceType"><span data-ttu-id="43201-994">要为其检索映射的接口的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="43201-994">The <see cref="T:System.Type" /> of the interface for which the mapping is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="43201-995">返回请求的接口的接口映射。</span><span class="sxs-lookup"><span data-stu-id="43201-995">Returns an interface mapping for the requested interface.</span></span></summary>
        <returns><span data-ttu-id="43201-996">返回请求的接口映射。</span><span class="sxs-lookup"><span data-stu-id="43201-996">Returns the requested interface mapping.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-997">使用 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 或 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 检索该类型，并对检索到的类型使用反射。</span><span class="sxs-lookup"><span data-stu-id="43201-997">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="43201-998">不会为不完整类型实现此方法。</span><span class="sxs-lookup"><span data-stu-id="43201-998">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public override Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="override this.GetInterfaces : unit -&gt; Type[]" Usage="typeBuilder.GetInterfaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43201-999">返回在此类型及其基类上实现的所有接口的数组。</span><span class="sxs-lookup"><span data-stu-id="43201-999">Returns an array of all the interfaces implemented on this type and its base types.</span></span></summary>
        <returns><span data-ttu-id="43201-1000">返回 <see cref="T:System.Type" /> 对象的数组，表示已实现的接口。</span><span class="sxs-lookup"><span data-stu-id="43201-1000">Returns an array of <see cref="T:System.Type" /> objects representing the implemented interfaces.</span></span> <span data-ttu-id="43201-1001">如果未定义任何内容，则返回一个空数组。</span><span class="sxs-lookup"><span data-stu-id="43201-1001">If none are defined, an empty array is returned.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="typeBuilder.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="43201-1002">成员名。</span><span class="sxs-lookup"><span data-stu-id="43201-1002">The name of the member.</span></span></param>
        <param name="type"><span data-ttu-id="43201-1003">要返回的成员的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1003">The type of the member to return.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="43201-1004">这必须是 <see cref="T:System.Reflection.BindingFlags" /> 的位标志，例如 <see langword="InvokeMethod" />、<see langword="NonPublic" /> 等中的位标志。</span><span class="sxs-lookup"><span data-stu-id="43201-1004">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" />, as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span></span></param>
        <summary><span data-ttu-id="43201-1005">按照指定，返回此类型声明或继承的所有公共和非公共成员。</span><span class="sxs-lookup"><span data-stu-id="43201-1005">Returns all the public and non-public members declared or inherited by this type, as specified.</span></span></summary>
        <returns><span data-ttu-id="43201-1006">如果使用 <paramref name="nonPublic" />，则返回 <see cref="T:System.Reflection.MemberInfo" /> 对象的数组，表示在此类型上定义的公共和非公共成员；否则，仅返回公共成员。</span><span class="sxs-lookup"><span data-stu-id="43201-1006">Returns an array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public and non-public members defined on this type if <paramref name="nonPublic" /> is used; otherwise, only the public members are returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-1007">使用 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 或 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 检索该类型，并对检索到的类型使用反射。</span><span class="sxs-lookup"><span data-stu-id="43201-1007">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="43201-1008">不会为不完整类型实现此方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1008">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="typeBuilder.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="43201-1009">这必须是来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志，例如 <see langword="InvokeMethod" />、<see langword="NonPublic" /> 等等。</span><span class="sxs-lookup"><span data-stu-id="43201-1009">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" />, such as <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span></span></param>
        <summary><span data-ttu-id="43201-1010">返回此类型声明或继承的公共和非公共成员。</span><span class="sxs-lookup"><span data-stu-id="43201-1010">Returns the members for the public and non-public members declared or inherited by this type.</span></span></summary>
        <returns><span data-ttu-id="43201-1011">返回 <see cref="T:System.Reflection.MemberInfo" /> 对象的数组，表示此类型声明或继承的公共和非公共成员。</span><span class="sxs-lookup"><span data-stu-id="43201-1011">Returns an array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public and non-public members declared or inherited by this type.</span></span> <span data-ttu-id="43201-1012">如果没有匹配的成员，则返回空数组。</span><span class="sxs-lookup"><span data-stu-id="43201-1012">An empty array is returned if there are no matching members.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-1013">使用 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 或 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 检索该类型，并对检索到的类型使用反射。</span><span class="sxs-lookup"><span data-stu-id="43201-1013">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="43201-1014">不会为不完整类型实现此方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1014">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodInfo GetMethod (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodInfo GetMethod(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodInfo ^ GetMethod(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member GetMethod : Type * System.Reflection.MethodInfo -&gt; System.Reflection.MethodInfo" Usage="System.Reflection.Emit.TypeBuilder.GetMethod (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="43201-1015">已返回其方法的构造泛型类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1015">The constructed generic type whose method is returned.</span></span></param>
        <param name="method"><span data-ttu-id="43201-1016"><paramref name="type" /> 的泛型类型定义的方法，该方法指定要返回 <paramref name="type" /> 的方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1016">A method on the generic type definition of <paramref name="type" />, which specifies which method of <paramref name="type" /> to return.</span></span></param>
        <summary><span data-ttu-id="43201-1017">返回与指定泛型类型定义的方法相对应的指定构造泛型类型的方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1017">Returns the method of the specified constructed generic type that corresponds to the specified method of the generic type definition.</span></span></summary>
        <returns><span data-ttu-id="43201-1018"><see cref="T:System.Reflection.MethodInfo" /> 对象，它表示与 <paramref name="method" /> 对应的 <paramref name="type" /> 的方法，它指定属于 <paramref name="type" /> 的泛型类型定义的方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1018">A <see cref="T:System.Reflection.MethodInfo" /> object that represents the method of <paramref name="type" /> corresponding to <paramref name="method" />, which specifies a method belonging to the generic type definition of <paramref name="type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-1019"><xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> 方法提供了一种方法，用于获取表示构造泛型类型的方法的 <xref:System.Reflection.MethodInfo> 对象，其泛型类型定义由 <xref:System.Reflection.Emit.TypeBuilder> 对象表示。</span><span class="sxs-lookup"><span data-stu-id="43201-1019">The <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> method provides a way to get a <xref:System.Reflection.MethodInfo> object that represents a method of a constructed generic type whose generic type definition is represented by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="43201-1020">例如，假设您有一个表示C# `G<T>` 语法中的类型的 <xref:System.Reflection.Emit.TypeBuilder> 对象（在 Visual Basic 中为`G(Of T)`，`generic <T> ref class G` C++在中），而 <xref:System.Reflection.Emit.MethodBuilder> 对象表示 `T M()` 定义的C#语法C++中的`Function M() As T` Visual Basic `T M()` `G<T>`中的方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1020">For example, suppose you have a <xref:System.Reflection.Emit.TypeBuilder> object that represents the type `G<T>` in C# syntax (`G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) and a <xref:System.Reflection.Emit.MethodBuilder> object that represents a method `T M()` in C# syntax (`Function M() As T` in Visual Basic, `T M()` in C++) that is defined by `G<T>`.</span></span> <span data-ttu-id="43201-1021">假定 `G<T>` 具有一个类型参数为 `U` 的泛型方法，该方法创建构造类型的实例 `G<U>` 并对该实例调用方法 `M`。</span><span class="sxs-lookup"><span data-stu-id="43201-1021">Suppose that `G<T>` has a generic method with type parameter `U` that creates an instance of the constructed type `G<U>` and calls method `M` on that instance.</span></span> <span data-ttu-id="43201-1022">为了发出函数调用，需要一个表示构造类型上 `M` 的 <xref:System.Reflection.MethodInfo> 对象-换言之，返回类型 `U`，而不是 `T`类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1022">In order to emit the function call, you need a <xref:System.Reflection.MethodInfo> object that represents `M` on the constructed type - in other words, that returns type `U` rather than type `T`.</span></span> <span data-ttu-id="43201-1023">为此，请先对 <xref:System.Reflection.Emit.TypeBuilder> 对象调用 <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> 方法，并指定将 `U` 表示为类型参数的 <xref:System.Reflection.Emit.GenericTypeParameterBuilder> 对象。</span><span class="sxs-lookup"><span data-stu-id="43201-1023">To do this, first call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on the <xref:System.Reflection.Emit.TypeBuilder> object, specifying the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object that represents `U` as the type argument.</span></span> <span data-ttu-id="43201-1024">然后调用 <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> 方法，并将 <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> 方法的返回值作为参数 `type`，并将表示 `T M()` 的 <xref:System.Reflection.Emit.MethodBuilder> 对象作为参数 `method`。</span><span class="sxs-lookup"><span data-stu-id="43201-1024">Then call the <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> method with the return value of the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method as parameter `type` and the <xref:System.Reflection.Emit.MethodBuilder> object that represents `T M()` as parameter `method`.</span></span> <span data-ttu-id="43201-1025">返回值是发出函数调用所需的 <xref:System.Reflection.MethodInfo> 对象。</span><span class="sxs-lookup"><span data-stu-id="43201-1025">The return value is the <xref:System.Reflection.MethodInfo> object you need to emit the function call.</span></span> <span data-ttu-id="43201-1026">此代码示例演示与此类似的方案。</span><span class="sxs-lookup"><span data-stu-id="43201-1026">The code example demonstrates a scenario similar to this.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43201-1027">下面的代码示例包含一个名为 `Sample` 的泛型类的源代码，该类具有名为 `T`的类型参数。</span><span class="sxs-lookup"><span data-stu-id="43201-1027">The following code example contains source code for a generic class named `Sample` that has a type parameter named `T`.</span></span> <span data-ttu-id="43201-1028">类有一个名为 `Field`、类型为 `T`的字段和一个名为 `GM` 的泛型方法，该方法具有其自己的类型参数，名为 "`U`"。</span><span class="sxs-lookup"><span data-stu-id="43201-1028">The class has a field named `Field`, of type `T`, and a generic method named `GM` with its own type parameter, named `U`.</span></span> <span data-ttu-id="43201-1029">方法 `GM` 创建 `Sample`的实例，将其自己的类型参数替换为 `Sample`的类型参数 `U`，并将其输入参数存储在 `Field`中。</span><span class="sxs-lookup"><span data-stu-id="43201-1029">Method `GM` creates an instance of `Sample`, substituting its own type parameter `U` for the type parameter of `Sample`, and stores its input parameter in `Field`.</span></span> <span data-ttu-id="43201-1030">已编译但未使用此源代码;可以使用[Ildasm （IL 拆装器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)查看它，并将其与类 `Example`所发出的代码进行比较。</span><span class="sxs-lookup"><span data-stu-id="43201-1030">This source code is compiled but not used; you can view it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) and compare it to the code emitted by class `Example`.</span></span>  
  
 <span data-ttu-id="43201-1031">类 `Example` 中的代码演示如何使用 <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> 方法发出泛型代码。</span><span class="sxs-lookup"><span data-stu-id="43201-1031">The code in class `Example` demonstrates the use of the <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> method to emit generic code.</span></span> <span data-ttu-id="43201-1032">类 `Example` 的 `Main` 方法创建了一个动态程序集，其中包含一个名为的类 `Sample`，并使用 <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> 方法通过添加一个名为 `T`的类型参数使其成为泛型。</span><span class="sxs-lookup"><span data-stu-id="43201-1032">The `Main` method of class `Example` creates a dynamic assembly containing a class named `Sample` and uses the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method to make it generic by adding a type parameter named `T`.</span></span> <span data-ttu-id="43201-1033">`T`类型的无参数构造函数和名为 `Field`的字段将添加到类 `Sample`。</span><span class="sxs-lookup"><span data-stu-id="43201-1033">A parameterless constructor and a field named `Field`, of type `T`, are added to class `Sample`.</span></span> <span data-ttu-id="43201-1034">使用 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> 方法添加并转换为泛型方法 `GM` 的方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1034">A method `GM` is added and turned into a generic method by using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="43201-1035">`GM` 的类型参数名为 `U`。</span><span class="sxs-lookup"><span data-stu-id="43201-1035">The type parameter of `GM` is named `U`.</span></span> <span data-ttu-id="43201-1036">定义类型参数后，将使用 <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> 方法添加 `GM` 的签名。</span><span class="sxs-lookup"><span data-stu-id="43201-1036">After the type parameter is defined, the signature of `GM` is added by using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="43201-1037">没有返回类型，并且没有必需的修饰符或自定义修饰符，因此此方法的所有参数都是 `null` `parameterTypes`;`parameterTypes` 将方法的唯一参数类型设置为 `U`的方法的泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="43201-1037">There is no return type and no required or custom modifiers, so all the parameters of this method are `null` except `parameterTypes`; `parameterTypes` sets the type of the method's only parameter to `U`, the method's generic type parameter.</span></span> <span data-ttu-id="43201-1038">方法的主体创建构造类型的实例 `Sample<U>` （`Sample(Of U)` 在 Visual Basic 中），将该方法的参数分配给 `Field`，然后打印 `Field`的值。</span><span class="sxs-lookup"><span data-stu-id="43201-1038">The body of the method creates an instance of the constructed type `Sample<U>` (`Sample(Of U)` in Visual Basic), assigns the method's parameter to `Field`, and then prints the value of `Field`.</span></span> <span data-ttu-id="43201-1039">定义了一个虚拟类型来保存入口点方法 `Main`。</span><span class="sxs-lookup"><span data-stu-id="43201-1039">A dummy type is defined to hold the entry-point method `Main`.</span></span> <span data-ttu-id="43201-1040">在 `Main`的主体中，将在构造的泛型类型 `Sample<int>` （`Sample(Of Integer)` 中的 Visual Basic）中调用静态 `GM` 方法，并将类型 <xref:System.String> 替换为 `U`。</span><span class="sxs-lookup"><span data-stu-id="43201-1040">In the body of `Main`, the static `GM` method is invoked on the constructed generic type `Sample<int>` (`Sample(Of Integer)` in Visual Basic), with type <xref:System.String> substituted for `U`.</span></span> <span data-ttu-id="43201-1041"><xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> 方法用于为构造的泛型类型 `Sample<U>`的静态 `GM` 方法创建 <xref:System.Reflection.MethodInfo>，然后使用 <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> 方法创建可在方法调用中发出的 <xref:System.Reflection.MethodInfo>。</span><span class="sxs-lookup"><span data-stu-id="43201-1041">The <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> method is used to create a <xref:System.Reflection.MethodInfo> for the static `GM` method of the constructed generic type `Sample<U>`, and the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> method is then used to create a <xref:System.Reflection.MethodInfo> that can emitted in a method call.</span></span>  
  
 <span data-ttu-id="43201-1042">运行代码示例时，它会将发出的程序集保存为 TypeBuilderGetFieldExample。</span><span class="sxs-lookup"><span data-stu-id="43201-1042">When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</span></span> <span data-ttu-id="43201-1043">您可以运行 TypeBuilderGetFieldExample，并且可以使用[Ildasm （IL 拆装器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)将发出的代码与编译为代码示例本身的 `Sample` 类的代码进行比较。</span><span class="sxs-lookup"><span data-stu-id="43201-1043">You can run TypeBuilderGetFieldExample.exe, and you can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to compare the emitted code with the code for the `Sample` class that is compiled into the code example itself.</span></span>  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-1044"><paramref name="method" /> 是一个非泛型方法定义的泛型方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1044"><paramref name="method" /> is a generic method that is not a generic method definition.</span></span>  
  
<span data-ttu-id="43201-1045">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-1045">-or-</span></span> 
 <span data-ttu-id="43201-1046"><paramref name="type" /> 不表示泛型类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1046"><paramref name="type" /> does not represent a generic type.</span></span>  
  
<span data-ttu-id="43201-1047">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-1047">-or-</span></span> 
 <span data-ttu-id="43201-1048"><paramref name="type" /> 的类型不是 <see cref="T:System.Reflection.Emit.TypeBuilder" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1048"><paramref name="type" /> is not of type <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span></span>  
  
<span data-ttu-id="43201-1049">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-1049">-or-</span></span> 
<span data-ttu-id="43201-1050"><paramref name="method" /> 的声明类型不是一个泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="43201-1050">The declaring type of <paramref name="method" /> is not a generic type definition.</span></span>  
  
<span data-ttu-id="43201-1051">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-1051">-or-</span></span> 
<span data-ttu-id="43201-1052"><paramref name="method" /> 的声明类型不是 <paramref name="type" /> 的泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="43201-1052">The declaring type of <paramref name="method" /> is not the generic type definition of <paramref name="type" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="override this.GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="typeBuilder.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="typeBuilder.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="43201-1053">这必须是 <see cref="T:System.Reflection.BindingFlags" /> 中的位标志，类似于 <see langword="InvokeMethod" />、<see langword="NonPublic" /> 等中的位标志。</span><span class="sxs-lookup"><span data-stu-id="43201-1053">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span></span></param>
        <summary><span data-ttu-id="43201-1054">按照指定，返回此类型声明或继承的所有公共和非公共方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1054">Returns all the public and non-public methods declared or inherited by this type, as specified.</span></span></summary>
        <returns><span data-ttu-id="43201-1055">如果使用 <paramref name="nonPublic" />，则返回 <see cref="T:System.Reflection.MethodInfo" /> 对象数组，表示在该类型上定义的公共和非公共方法；否则，仅返回公共方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1055">Returns an array of <see cref="T:System.Reflection.MethodInfo" /> objects representing the public and non-public methods defined on this type if <paramref name="nonPublic" /> is used; otherwise, only the public methods are returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-1056">使用 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 或 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 检索该类型，并对检索到的类型使用反射。</span><span class="sxs-lookup"><span data-stu-id="43201-1056">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="43201-1057">不会为不完整类型实现此方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1057">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public override Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="typeBuilder.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="43201-1058">包含要获取的嵌套类型的名称的 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1058">The <see cref="T:System.String" /> containing the name of the nested type to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="43201-1059">一个位屏蔽，由一个或多个指定搜索执行方式的 <see cref="T:System.Reflection.BindingFlags" /> 组成。</span><span class="sxs-lookup"><span data-stu-id="43201-1059">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="43201-1060">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-1060">-or-</span></span> 
<span data-ttu-id="43201-1061">零，表示对公共方法执行区分大小写的搜索。</span><span class="sxs-lookup"><span data-stu-id="43201-1061">Zero, to conduct a case-sensitive search for public methods.</span></span></param>
        <summary><span data-ttu-id="43201-1062">返回此类型声明的公共和非公共嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1062">Returns the public and non-public nested types that are declared by this type.</span></span></summary>
        <returns><span data-ttu-id="43201-1063">表示符合指定要求的嵌套类型的 <see cref="T:System.Type" /> 对象（如果找到）；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1063">A <see cref="T:System.Type" /> object representing the nested type that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-1064">使用 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 或 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 检索该类型，并对检索到的类型使用反射。</span><span class="sxs-lookup"><span data-stu-id="43201-1064">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 <span data-ttu-id="43201-1065">如果此类型为 "已完成" （例如，如果在此类型上调用了 `CreateType`，但存在不完整的嵌套类型），则 `GetNestedTypes` 将仅返回已为其调用了 `CreateType` 的嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1065">If this type is complete, for example, if `CreateType` has been called on this type, but there are nested types that are not complete, then `GetNestedTypes` will only return those nested types for which `CreateType` has been called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="43201-1066">不会为不完整类型实现此方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1066">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public override Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="typeBuilder.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="43201-1067">这必须是 <see cref="T:System.Reflection.BindingFlags" /> 的位标志，例如 <see langword="InvokeMethod" />、<see langword="NonPublic" /> 等中的位标志。</span><span class="sxs-lookup"><span data-stu-id="43201-1067">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" />, as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span></span></param>
        <summary><span data-ttu-id="43201-1068">返回此类型声明或继承的公共和非公共嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1068">Returns the public and non-public nested types that are declared or inherited by this type.</span></span></summary>
        <returns><span data-ttu-id="43201-1069"><see cref="T:System.Type" /> 对象数组，表示当前 <see cref="T:System.Type" /> 中嵌套的与指定的绑定约束匹配的所有类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1069">An array of <see cref="T:System.Type" /> objects representing all the types nested within the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="43201-1070">如果当前 <see cref="T:System.Type" /> 中未嵌套任何类型，或者如果没有一个嵌套类型与绑定约束匹配，则为类型 <see cref="T:System.Type" /> 的空数组。</span><span class="sxs-lookup"><span data-stu-id="43201-1070">An empty array of type <see cref="T:System.Type" />, if no types are nested within the current <see cref="T:System.Type" />, or if none of the nested types match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-1071">使用 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 或 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 检索该类型，并对检索到的类型使用反射。</span><span class="sxs-lookup"><span data-stu-id="43201-1071">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 <span data-ttu-id="43201-1072">如果此类型为 "已完成" （例如，如果在此类型上调用了 `CreateType`，但存在不完整的嵌套类型），则 `GetNestedTypes` 将仅返回已为其调用了 `CreateType` 的嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1072">If this type is complete, for example, if `CreateType` has been called on this type, but there are nested types that are not complete, then `GetNestedTypes` will only return those nested types for which `CreateType` has been called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="43201-1073">不会为不完整类型实现此方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1073">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public override System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="typeBuilder.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="43201-1074">此调用属性。</span><span class="sxs-lookup"><span data-stu-id="43201-1074">This invocation attribute.</span></span> <span data-ttu-id="43201-1075">这必须是来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志：<see langword="InvokeMethod" />、<see langword="NonPublic" /> 等等。</span><span class="sxs-lookup"><span data-stu-id="43201-1075">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span></span></param>
        <summary><span data-ttu-id="43201-1076">按照指定，返回此类型声明或继承的所有公共和非公共属性。</span><span class="sxs-lookup"><span data-stu-id="43201-1076">Returns all the public and non-public properties declared or inherited by this type, as specified.</span></span></summary>
        <returns><span data-ttu-id="43201-1077">如果使用 <paramref name="nonPublic" />，则返回 <see langword="PropertyInfo" /> 对象的数组，表示在此类型上定义的公共和非公共属性；否则，仅返回公共属性。</span><span class="sxs-lookup"><span data-stu-id="43201-1077">Returns an array of <see langword="PropertyInfo" /> objects representing the public and non-public properties defined on this type if <paramref name="nonPublic" /> is used; otherwise, only the public properties are returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-1078">使用 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 或 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 检索该类型，并对检索到的类型使用反射。</span><span class="sxs-lookup"><span data-stu-id="43201-1078">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="43201-1079">不会为不完整类型实现此方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1079">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="override this.GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="typeBuilder.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="returnType">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public override Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GUID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Reflection.Emit.TypeBuilder.GUID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43201-1080">检索此类型的 GUID。</span><span class="sxs-lookup"><span data-stu-id="43201-1080">Retrieves the GUID of this type.</span></span></summary>
        <value><span data-ttu-id="43201-1081">只读。</span><span class="sxs-lookup"><span data-stu-id="43201-1081">Read-only.</span></span> <span data-ttu-id="43201-1082">检索此类型的 GUID</span><span class="sxs-lookup"><span data-stu-id="43201-1082">Retrieves the GUID of this type</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-1083">使用 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 或 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 检索该类型，并对检索到的类型使用反射。</span><span class="sxs-lookup"><span data-stu-id="43201-1083">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="43201-1084">不完整类型目前不支持此方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1084">This method is not currently supported for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="override this.HasElementTypeImpl : unit -&gt; bool" Usage="typeBuilder.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public override object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="typeBuilder.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="namedParameters" Type="System.String[]" Index="7" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="43201-1085">要调用的成员的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-1085">The name of the member to invoke.</span></span> <span data-ttu-id="43201-1086">这可以是构造函数、方法、属性或字段。</span><span class="sxs-lookup"><span data-stu-id="43201-1086">This can be a constructor, method, property, or field.</span></span> <span data-ttu-id="43201-1087">必须指定合适的调用属性。</span><span class="sxs-lookup"><span data-stu-id="43201-1087">A suitable invocation attribute must be specified.</span></span> <span data-ttu-id="43201-1088">请注意，可以通过将一个空字符串作为成员的名称进行传递来调用一个类的默认成员。</span><span class="sxs-lookup"><span data-stu-id="43201-1088">Note that it is possible to invoke the default member of a class by passing an empty string as the name of the member.</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="43201-1089">调用属性。</span><span class="sxs-lookup"><span data-stu-id="43201-1089">The invocation attribute.</span></span> <span data-ttu-id="43201-1090">这必须是来自 <see langword="BindingFlags" /> 的位标志。</span><span class="sxs-lookup"><span data-stu-id="43201-1090">This must be a bit flag from <see langword="BindingFlags" />.</span></span></param>
        <param name="binder"><span data-ttu-id="43201-1091">一个对象，它使用反射启用绑定、参数类型的强制、成员的调用和 <see langword="MemberInfo" /> 对象的检索。</span><span class="sxs-lookup"><span data-stu-id="43201-1091">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="43201-1092">如果 binder 为 <see langword="null" />，则使用默认活页夹。</span><span class="sxs-lookup"><span data-stu-id="43201-1092">If binder is <see langword="null" />, the default binder is used.</span></span> <span data-ttu-id="43201-1093">请参阅 <see cref="T:System.Reflection.Binder" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1093">See <see cref="T:System.Reflection.Binder" />.</span></span></param>
        <param name="target"><span data-ttu-id="43201-1094">对其调用指定成员的对象。</span><span class="sxs-lookup"><span data-stu-id="43201-1094">The object on which to invoke the specified member.</span></span> <span data-ttu-id="43201-1095">如果该成员为静态，则忽略此参数。</span><span class="sxs-lookup"><span data-stu-id="43201-1095">If the member is static, this parameter is ignored.</span></span></param>
        <param name="args"><span data-ttu-id="43201-1096">自变量列表。</span><span class="sxs-lookup"><span data-stu-id="43201-1096">An argument list.</span></span> <span data-ttu-id="43201-1097">这是一个对象的数组，该对象包含要调用的成员的参数的数量、顺序和类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1097">This is an array of Objects that contains the number, order, and type of the parameters of the member to be invoked.</span></span> <span data-ttu-id="43201-1098">如果不存在任何参数，则这应为 null。</span><span class="sxs-lookup"><span data-stu-id="43201-1098">If there are no parameters this should be null.</span></span></param>
        <param name="modifiers"><span data-ttu-id="43201-1099">与 <paramref name="args" /> 长度相同的数组，其元素表示与要调用的成员的自变量关联的特性。</span><span class="sxs-lookup"><span data-stu-id="43201-1099">An array of the same length as <paramref name="args" /> with elements that represent the attributes associated with the arguments of the member to be invoked.</span></span> <span data-ttu-id="43201-1100">参数在元数据中具有与之相关联的属性。</span><span class="sxs-lookup"><span data-stu-id="43201-1100">A parameter has attributes associated with it in the metadata.</span></span> <span data-ttu-id="43201-1101">它们由不同的互操作性服务使用。</span><span class="sxs-lookup"><span data-stu-id="43201-1101">They are used by various interoperability services.</span></span> <span data-ttu-id="43201-1102">有关更多详细信息，请参阅元数据规范。</span><span class="sxs-lookup"><span data-stu-id="43201-1102">See the metadata specs for more details.</span></span></param>
        <param name="culture"><span data-ttu-id="43201-1103">用于控制类型强制的 <see langword="CultureInfo" /> 的实例。</span><span class="sxs-lookup"><span data-stu-id="43201-1103">An instance of <see langword="CultureInfo" /> used to govern the coercion of types.</span></span> <span data-ttu-id="43201-1104">如果这是 NULL，则使用当前线程的 <see langword="CultureInfo" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1104">If this is null, the <see langword="CultureInfo" /> for the current thread is used.</span></span> <span data-ttu-id="43201-1105">（注意，这对于某些转换是必要的，例如，将表示 1000 的 String 转换为 Double 值，因为不同区域性的 1000 表示形式不同。）</span><span class="sxs-lookup"><span data-stu-id="43201-1105">(Note that this is necessary to, for example, convert a String that represents 1000 to a Double value, since 1000 is represented differently by different cultures.)</span></span></param>
        <param name="namedParameters"><span data-ttu-id="43201-1106"><paramref name="namedParameters" /> 数组中的每个参数对应 <paramref name="args" /> 数组中的元素来获取值。</span><span class="sxs-lookup"><span data-stu-id="43201-1106">Each parameter in the <paramref name="namedParameters" /> array gets the value in the corresponding element in the <paramref name="args" /> array.</span></span> <span data-ttu-id="43201-1107">如果 <paramref name="args" /> 的长度大于 <paramref name="namedParameters" /> 的长度，则剩余的自变量值将按顺序传递。</span><span class="sxs-lookup"><span data-stu-id="43201-1107">If the length of <paramref name="args" /> is greater than the length of <paramref name="namedParameters" />, the remaining argument values are passed in order.</span></span></param>
        <summary><span data-ttu-id="43201-1108">调用指定的成员。</span><span class="sxs-lookup"><span data-stu-id="43201-1108">Invokes the specified member.</span></span> <span data-ttu-id="43201-1109">在指定的活页夹和调用属性的约束下，要调用的方法必须为可访问，并且提供与指定的自变量列表最具体的匹配。</span><span class="sxs-lookup"><span data-stu-id="43201-1109">The method that is to be invoked must be accessible and provide the most specific match with the specified argument list, under the constraints of the specified binder and invocation attributes.</span></span></summary>
        <returns><span data-ttu-id="43201-1110">返回被调用的成员的返回值。</span><span class="sxs-lookup"><span data-stu-id="43201-1110">Returns the return value of the invoked member.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-1111">如果方法声明中的参数数目等于指定参数列表中的参数数量，则将调用方法，并且每个参数的类型都可以由联编程序转换为参数的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1111">A method will be invoked if the number of parameters in the method declaration equals the number of arguments in the specified argument list, and the type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="43201-1112">此联编程序将查找所有匹配的方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1112">The binder will find all of the matching methods.</span></span> <span data-ttu-id="43201-1113">这些方法基于所请求的绑定类型（Bindingflag，InvokeMethod，Bindingflag. GetProperties，等等）。</span><span class="sxs-lookup"><span data-stu-id="43201-1113">These methods are found based on the type of binding requested (BindingFlags.InvokeMethod, BindingFlags.GetProperties, and so on.).</span></span> <span data-ttu-id="43201-1114">方法集按名称、参数数目和在联编程序中定义的一组搜索修饰符进行筛选。</span><span class="sxs-lookup"><span data-stu-id="43201-1114">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span> <span data-ttu-id="43201-1115">选择方法后，将调用该方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1115">After the method is selected, it will be invoked.</span></span> <span data-ttu-id="43201-1116">此时将检查可访问性。</span><span class="sxs-lookup"><span data-stu-id="43201-1116">Accessibility is checked at that point.</span></span> <span data-ttu-id="43201-1117">搜索可根据与方法关联的可访问性属性控制要搜索的方法集。</span><span class="sxs-lookup"><span data-stu-id="43201-1117">The search can control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="43201-1118">`IBinder.BindToMethod` 方法负责选择要调用的方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1118">The `IBinder.BindToMethod` method is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="43201-1119">默认联编程序将选择最特定的匹配项。</span><span class="sxs-lookup"><span data-stu-id="43201-1119">The default binder selects the most specific match.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="43201-1120">对于完全受信任的代码，将忽略访问限制。</span><span class="sxs-lookup"><span data-stu-id="43201-1120">Access restrictions are ignored for fully trusted code.</span></span> <span data-ttu-id="43201-1121">也就是说，只要代码完全受信任，就可以使用反射来访问和调用私有构造函数、方法、字段和属性。</span><span class="sxs-lookup"><span data-stu-id="43201-1121">That is, private constructors, methods, fields, and properties can be accessed and invoked using Reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="43201-1122">目前尚不支持此方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1122">This method is not currently supported.</span></span> <span data-ttu-id="43201-1123">您可以使用 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 或 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 检索该类型，并在检索的类型上使用反射。</span><span class="sxs-lookup"><span data-stu-id="43201-1123">You can retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="43201-1124">不完整类型目前不支持此方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1124">This method is not currently supported for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected override bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="override this.IsArrayImpl : unit -&gt; bool" Usage="typeBuilder.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAssignableFrom">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="43201-1125">确定某个指定类型是否可以赋值给此对象。</span><span class="sxs-lookup"><span data-stu-id="43201-1125">Determines whether a specified type can be assigned to this object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (System.Reflection.TypeInfo typeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Reflection.TypeInfo typeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsAssignableFrom(System::Reflection::TypeInfo ^ typeInfo);" />
      <MemberSignature Language="F#" Value="override this.IsAssignableFrom : System.Reflection.TypeInfo -&gt; bool" Usage="typeBuilder.IsAssignableFrom typeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeInfo" Type="System.Reflection.TypeInfo" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="typeInfo"><span data-ttu-id="43201-1126">要测试的对象。</span><span class="sxs-lookup"><span data-stu-id="43201-1126">The object to test.</span></span></param>
        <summary><span data-ttu-id="43201-1127">获取一个值，该值表示是否可以将指定的 <see cref="T:System.Reflection.TypeInfo" /> 对象赋值给此对象。</span><span class="sxs-lookup"><span data-stu-id="43201-1127">Gets a value that indicates whether a specified <see cref="T:System.Reflection.TypeInfo" /> object can be assigned to this object.</span></span></summary>
        <returns><span data-ttu-id="43201-1128">如果可以将 <paramref name="typeInfo" /> 赋值给此对象，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1128"><see langword="true" /> if <paramref name="typeInfo" /> can be assigned to this object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="override this.IsAssignableFrom : Type -&gt; bool" Usage="typeBuilder.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="c"><span data-ttu-id="43201-1129">要测试的对象。</span><span class="sxs-lookup"><span data-stu-id="43201-1129">The object to test.</span></span></param>
        <summary><span data-ttu-id="43201-1130">获取一个值，该值指示是否可将指定的 <see cref="T:System.Type" /> 分配给此对象。</span><span class="sxs-lookup"><span data-stu-id="43201-1130">Gets a value that indicates whether a specified <see cref="T:System.Type" /> can be assigned to this object.</span></span></summary>
        <returns><span data-ttu-id="43201-1131">如果 <paramref name="c" /> 参数和当前类型表示相同的类型，或当前类型位于 <paramref name="c" /> 的继承层次结构中，或当前类型是 <paramref name="c" /> 支持的接口，则为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1131"><see langword="true" /> if the <paramref name="c" /> parameter and the current type represent the same type, or if the current type is in the inheritance hierarchy of <paramref name="c" />, or if the current type is an interface that <paramref name="c" /> supports.</span></span> <span data-ttu-id="43201-1132">如果上述条件均无效或 <paramref name="c" /> 为 <see langword="null" />；则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1132"><see langword="false" /> if none of these conditions are valid, or if <paramref name="c" /> is <see langword="null" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected override bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="override this.IsByRefImpl : unit -&gt; bool" Usage="typeBuilder.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public override bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Reflection.Emit.TypeBuilder.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected override bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="override this.IsCOMObjectImpl : unit -&gt; bool" Usage="typeBuilder.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public override bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Reflection.Emit.TypeBuilder.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43201-1133">获取指示此对象是否表示构造的泛型类型的值。</span><span class="sxs-lookup"><span data-stu-id="43201-1133">Gets a value that indicates whether this object represents a constructed generic type.</span></span></summary>
        <value><span data-ttu-id="43201-1134">如果此对象表示构造泛型类型，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1134"><see langword="true" /> if this object represents a constructed generic type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCreated">
      <MemberSignature Language="C#" Value="public bool IsCreated ();" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsCreated() cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCreated" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCreated () As Boolean" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsCreated();" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.IsCreated : unit -&gt; bool" Usage="typeBuilder.IsCreated " FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43201-1135">返回一个值，该值指示是否已创建当前的动态类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1135">Returns a value that indicates whether the current dynamic type has been created.</span></span></summary>
        <returns><span data-ttu-id="43201-1136">如果已调用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 方法，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1136"><see langword="true" /> if the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method has been called; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-1137">调用 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 方法后，<xref:System.Reflection.Emit.TypeBuilder> 对象表示的类型已完成。</span><span class="sxs-lookup"><span data-stu-id="43201-1137">After the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called, the type represented by the <xref:System.Reflection.Emit.TypeBuilder> object is complete.</span></span> <span data-ttu-id="43201-1138">尝试添加成员或更改类型的其他特征时，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="43201-1138">Exceptions are thrown on any further attempts to add members or change other characteristics of the type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="typeBuilder.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="43201-1139">要搜索的属性的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1139">The type of attribute to search for.</span></span> <span data-ttu-id="43201-1140">仅返回可分配给此类型的属性。</span><span class="sxs-lookup"><span data-stu-id="43201-1140">Only attributes that are assignable to this type are returned.</span></span></param>
        <param name="inherit"><span data-ttu-id="43201-1141">指定是否搜索此成员的继承链以查找属性。</span><span class="sxs-lookup"><span data-stu-id="43201-1141">Specifies whether to search this member's inheritance chain to find the attributes.</span></span></param>
        <summary><span data-ttu-id="43201-1142">确定是否将自定义属性应用于当前类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1142">Determines whether a custom attribute is applied to the current type.</span></span></summary>
        <returns><span data-ttu-id="43201-1143">如果针对此类型定义了 <paramref name="attributeType" /> 的一个或多个实例，或定义了从 <paramref name="attributeType" /> 派生的属性，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1143"><see langword="true" /> if one or more instances of <paramref name="attributeType" />, or an attribute derived from <paramref name="attributeType" />, is defined on this type; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-1144">不完整的泛型类型参数不支持此方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1144">This method is not supported for incomplete generic type parameters.</span></span> <span data-ttu-id="43201-1145">使用 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 或 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 检索该类型，并对检索到的类型使用反射。</span><span class="sxs-lookup"><span data-stu-id="43201-1145">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="43201-1146">不完整类型目前不支持此方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1146">This method is not currently supported for incomplete types.</span></span> <span data-ttu-id="43201-1147">使用 <see cref="M:System.Type.GetType" /> 检索此类型，并对返回的 <see cref="T:System.Type" /> 调用 <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1147">Retrieve the type using <see cref="M:System.Type.GetType" /> and call <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> on the returned <see cref="T:System.Type" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-1148">未定义 <paramref name="attributeType" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1148"><paramref name="attributeType" /> is not defined.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-1149"><paramref name="attributeType" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1149"><paramref name="attributeType" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public override bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Reflection.Emit.TypeBuilder.IsEnum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public override bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Reflection.Emit.TypeBuilder.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43201-1150">获取一个值，该值指示当前类型是否是泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="43201-1150">Gets a value indicating whether the current type is a generic type parameter.</span></span></summary>
        <value><span data-ttu-id="43201-1151">如果当前 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 对象表示泛型类型参数，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1151"><see langword="true" /> if the current <see cref="T:System.Reflection.Emit.TypeBuilder" /> object represents a generic type parameter; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="43201-1152">发出代码时，泛型类型参数由 <xref:System.Reflection.Emit.GenericTypeParameterBuilder> 对象而不是 <xref:System.Reflection.Emit.TypeBuilder> 对象表示。</span><span class="sxs-lookup"><span data-stu-id="43201-1152">When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public override bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Reflection.Emit.TypeBuilder.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43201-1153">获取一个值，该值指示当前类型是否是泛型类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1153">Gets a value indicating whether the current type is a generic type.</span></span></summary>
        <value><span data-ttu-id="43201-1154">如果当前 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 对象表示的类型是泛型，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1154"><see langword="true" /> if the type represented by the current <see cref="T:System.Reflection.Emit.TypeBuilder" /> object is generic; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-1155">如果 <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> 方法已用于为其提供泛型类型参数，则 <xref:System.Reflection.Emit.TypeBuilder> 对象表示泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="43201-1155">A <xref:System.Reflection.Emit.TypeBuilder> object represents a generic type definition if the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method has been used to give it generic type parameters.</span></span> <span data-ttu-id="43201-1156">泛型 <xref:System.Reflection.Emit.TypeBuilder> 类的实例始终是一个泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="43201-1156">An instance of the <xref:System.Reflection.Emit.TypeBuilder> class that is generic is always a generic type definition.</span></span>  
  
 <span data-ttu-id="43201-1157">若要详细了解反射中的泛型类型和泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="43201-1157">For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43201-1158">获取一个值，该值指示当前 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 是否表示可以用来构造其他泛型类型的泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="43201-1158">Gets a value indicating whether the current <see cref="T:System.Reflection.Emit.TypeBuilder" /> represents a generic type definition from which other generic types can be constructed.</span></span></summary>
        <value><span data-ttu-id="43201-1159">如果此 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 对象表示泛型类型定义，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1159"><see langword="true" /> if this <see cref="T:System.Reflection.Emit.TypeBuilder" /> object represents a generic type definition; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-1160">如果 <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> 方法已用于为其提供泛型类型参数，则 <xref:System.Reflection.Emit.TypeBuilder> 对象表示泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="43201-1160">A <xref:System.Reflection.Emit.TypeBuilder> object represents a generic type definition if the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method has been used to give it generic type parameters.</span></span> <span data-ttu-id="43201-1161">泛型 <xref:System.Reflection.Emit.TypeBuilder> 类的实例始终是一个泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="43201-1161">An instance of the <xref:System.Reflection.Emit.TypeBuilder> class that is generic is always a generic type definition.</span></span>  
  
 <span data-ttu-id="43201-1162"><xref:System.Reflection.Emit.TypeBuilder> 可用于生成泛型类型定义，但不能用于构建泛型类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1162">A <xref:System.Reflection.Emit.TypeBuilder> can be used to build generic type definitions, but not constructed generic types.</span></span> <span data-ttu-id="43201-1163">若要获取构造的泛型类型，请对表示泛型类型定义的 <xref:System.Reflection.Emit.TypeBuilder> 调用 <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1163">To get a constructed generic type, call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on a <xref:System.Reflection.Emit.TypeBuilder> that represents a generic type definition.</span></span>  
  
 <span data-ttu-id="43201-1164">若要详细了解反射中的泛型类型和泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="43201-1164">For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="override this.IsPointerImpl : unit -&gt; bool" Usage="typeBuilder.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="override this.IsPrimitiveImpl : unit -&gt; bool" Usage="typeBuilder.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43201-1165">获取一个值，该值指示当前类型是安全-关键的还是安全-可靠-关键的，且因此是否可执行关键操作。</span><span class="sxs-lookup"><span data-stu-id="43201-1165">Gets a value that indicates whether the current type is security-critical or security-safe-critical, and therefore can perform critical operations.</span></span></summary>
        <value><span data-ttu-id="43201-1166">如果当前类型是安全-关键的或安全-可靠-关键的，则为 <see langword="true" />；如果它是透明的，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1166"><see langword="true" /> if the current type is security-critical or security-safe-critical; <see langword="false" /> if it is transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-1167"><xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>、<xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>和 <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> 属性报告由公共语言运行时（CLR）确定的类型的透明度级别。</span><span class="sxs-lookup"><span data-stu-id="43201-1167">The <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> properties report the transparency level of the type, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="43201-1168">下表显示了这些属性的组合：</span><span class="sxs-lookup"><span data-stu-id="43201-1168">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="43201-1169">安全级别</span><span class="sxs-lookup"><span data-stu-id="43201-1169">Security level</span></span>|<span data-ttu-id="43201-1170">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="43201-1170">IsSecurityCritical</span></span>|<span data-ttu-id="43201-1171">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="43201-1171">IsSecuritySafeCritical</span></span>|<span data-ttu-id="43201-1172">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="43201-1172">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="43201-1173">严重</span><span class="sxs-lookup"><span data-stu-id="43201-1173">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="43201-1174">安全-关键</span><span class="sxs-lookup"><span data-stu-id="43201-1174">Safe-critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="43201-1175">透明</span><span class="sxs-lookup"><span data-stu-id="43201-1175">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="43201-1176">使用这些属性比检查程序集及其类型的安全批注、检查当前的信任级别，以及尝试复制运行时的规则要简单得多。</span><span class="sxs-lookup"><span data-stu-id="43201-1176">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
 <span data-ttu-id="43201-1177">运行时开始计算程序集的透明度级别。</span><span class="sxs-lookup"><span data-stu-id="43201-1177">The runtime begins evaluating transparency levels at the assembly.</span></span> <span data-ttu-id="43201-1178">例如，如果动态程序集是安全关键的，则类型上的批注将被忽略，并且所有类型都是安全关键的。</span><span class="sxs-lookup"><span data-stu-id="43201-1178">For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</span></span>  
  
 <span data-ttu-id="43201-1179">默认情况下，动态程序集继承发出它的程序集的透明度。</span><span class="sxs-lookup"><span data-stu-id="43201-1179">By default, a dynamic assembly inherits the transparency of the assembly that emits it.</span></span> <span data-ttu-id="43201-1180">您可以使用 <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>、<xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>或 <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> 方法重载并指定安全特性来重写此默认值。</span><span class="sxs-lookup"><span data-stu-id="43201-1180">You can override this default by using the <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, or <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> method overload and specifying security attributes.</span></span> <span data-ttu-id="43201-1181">您无法通过执行此操作提升安全级别;也就是说，透明代码无法发出安全关键代码或安全可靠关键代码。</span><span class="sxs-lookup"><span data-stu-id="43201-1181">You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</span></span> <span data-ttu-id="43201-1182">创建动态程序集时必须指定属性，或在程序集保存到磁盘并重新加载后，它们才会生效。</span><span class="sxs-lookup"><span data-stu-id="43201-1182">Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="43201-1183">默认继承限制为运行时的透明度计算。</span><span class="sxs-lookup"><span data-stu-id="43201-1183">Default inheritance is limited to the runtime's evaluation of transparency.</span></span> <span data-ttu-id="43201-1184">没有属性应用于动态程序集。</span><span class="sxs-lookup"><span data-stu-id="43201-1184">No attributes are applied to the dynamic assembly.</span></span> <span data-ttu-id="43201-1185">如果要添加安全属性，则必须自行应用这些属性。</span><span class="sxs-lookup"><span data-stu-id="43201-1185">If you want to add security attributes, you must apply them yourself.</span></span>  
  
 <span data-ttu-id="43201-1186">有关反射发出和透明度的详细信息，请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。</span><span class="sxs-lookup"><span data-stu-id="43201-1186">For more information about reflection emit and transparency, see [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span></span> <span data-ttu-id="43201-1187">有关透明度的信息，请参阅[安全更改](~/docs/framework/security/security-changes.md)。</span><span class="sxs-lookup"><span data-stu-id="43201-1187">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="43201-1188">当前动态类型不是通过调用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 方法创建的。</span><span class="sxs-lookup"><span data-stu-id="43201-1188">The current dynamic type has not been created by calling the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span></span></exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md"><span data-ttu-id="43201-1189">反射发出中的安全问题</span><span class="sxs-lookup"><span data-stu-id="43201-1189">Security Issues in Reflection Emit</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="43201-1190">反射的安全注意事项</span><span class="sxs-lookup"><span data-stu-id="43201-1190">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="43201-1191">.NET Framework 4.0 版中的安全性更改</span><span class="sxs-lookup"><span data-stu-id="43201-1191">Security Changes in the .NET Framework Version 4.0</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf"><span data-ttu-id="43201-1192">安全透明代码，级别1</span><span class="sxs-lookup"><span data-stu-id="43201-1192">Security-Transparent Code, Level 1</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0"><span data-ttu-id="43201-1193">安全透明的代码，级别 2</span><span class="sxs-lookup"><span data-stu-id="43201-1193">Security-Transparent Code, Level 2</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43201-1194">获取一个值，该值指示当前类型是否为安全-可靠-关键，即它是否可执行关键操作且可由透明代码访问。</span><span class="sxs-lookup"><span data-stu-id="43201-1194">Gets a value that indicates whether the current type is security-safe-critical; that is, whether it can perform critical operations and can be accessed by transparent code.</span></span></summary>
        <value><span data-ttu-id="43201-1195">如果当前类型为安全-可靠-关键，则为 <see langword="true" />；如果它为安全-关键或透明，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1195"><see langword="true" /> if the current type is security-safe-critical; <see langword="false" /> if it is security-critical or transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-1196"><xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>、<xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>和 <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> 属性报告由公共语言运行时（CLR）确定的类型的透明度级别。</span><span class="sxs-lookup"><span data-stu-id="43201-1196">The <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> properties report the transparency level of the type, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="43201-1197">下表显示了这些属性的组合：</span><span class="sxs-lookup"><span data-stu-id="43201-1197">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="43201-1198">安全级别</span><span class="sxs-lookup"><span data-stu-id="43201-1198">Security level</span></span>|<span data-ttu-id="43201-1199">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="43201-1199">IsSecurityCritical</span></span>|<span data-ttu-id="43201-1200">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="43201-1200">IsSecuritySafeCritical</span></span>|<span data-ttu-id="43201-1201">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="43201-1201">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="43201-1202">严重</span><span class="sxs-lookup"><span data-stu-id="43201-1202">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="43201-1203">安全-关键</span><span class="sxs-lookup"><span data-stu-id="43201-1203">Safe-critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="43201-1204">透明</span><span class="sxs-lookup"><span data-stu-id="43201-1204">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="43201-1205">使用这些属性比检查程序集及其类型的安全批注、检查当前的信任级别，以及尝试复制运行时的规则要简单得多。</span><span class="sxs-lookup"><span data-stu-id="43201-1205">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
 <span data-ttu-id="43201-1206">运行时开始计算程序集的透明度级别。</span><span class="sxs-lookup"><span data-stu-id="43201-1206">The runtime begins evaluating transparency levels at the assembly.</span></span> <span data-ttu-id="43201-1207">例如，如果动态程序集是安全关键的，则类型上的批注将被忽略，并且所有类型都是安全关键的。</span><span class="sxs-lookup"><span data-stu-id="43201-1207">For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</span></span>  
  
 <span data-ttu-id="43201-1208">默认情况下，动态程序集继承发出它的程序集的透明度。</span><span class="sxs-lookup"><span data-stu-id="43201-1208">By default, a dynamic assembly inherits the transparency of the assembly that emits it.</span></span> <span data-ttu-id="43201-1209">您可以使用 <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>、<xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>或 <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> 方法重载并指定安全特性来重写此默认值。</span><span class="sxs-lookup"><span data-stu-id="43201-1209">You can override this default by using the <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, or <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> method overload and specifying security attributes.</span></span> <span data-ttu-id="43201-1210">您无法通过执行此操作提升安全级别;也就是说，透明代码无法发出安全关键代码或安全可靠关键代码。</span><span class="sxs-lookup"><span data-stu-id="43201-1210">You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</span></span> <span data-ttu-id="43201-1211">创建动态程序集时必须指定属性，或在程序集保存到磁盘并重新加载后，它们才会生效。</span><span class="sxs-lookup"><span data-stu-id="43201-1211">Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="43201-1212">默认继承限制为运行时的透明度计算。</span><span class="sxs-lookup"><span data-stu-id="43201-1212">Default inheritance is limited to the runtime's evaluation of transparency.</span></span> <span data-ttu-id="43201-1213">没有属性应用于动态程序集。</span><span class="sxs-lookup"><span data-stu-id="43201-1213">No attributes are applied to the dynamic assembly.</span></span> <span data-ttu-id="43201-1214">如果要添加安全属性，则必须自行应用这些属性。</span><span class="sxs-lookup"><span data-stu-id="43201-1214">If you want to add security attributes, you must apply them yourself.</span></span>  
  
 <span data-ttu-id="43201-1215">有关反射发出和透明度的详细信息，请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。</span><span class="sxs-lookup"><span data-stu-id="43201-1215">For more information about reflection emit and transparency, see [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span></span> <span data-ttu-id="43201-1216">有关透明度的信息，请参阅[安全更改](~/docs/framework/security/security-changes.md)。</span><span class="sxs-lookup"><span data-stu-id="43201-1216">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="43201-1217">当前动态类型不是通过调用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 方法创建的。</span><span class="sxs-lookup"><span data-stu-id="43201-1217">The current dynamic type has not been created by calling the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span></span></exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md"><span data-ttu-id="43201-1218">反射发出中的安全问题</span><span class="sxs-lookup"><span data-stu-id="43201-1218">Security Issues in Reflection Emit</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="43201-1219">反射的安全注意事项</span><span class="sxs-lookup"><span data-stu-id="43201-1219">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="43201-1220">.NET Framework 4.0 版中的安全性更改</span><span class="sxs-lookup"><span data-stu-id="43201-1220">Security Changes in the .NET Framework Version 4.0</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf"><span data-ttu-id="43201-1221">安全透明代码，级别1</span><span class="sxs-lookup"><span data-stu-id="43201-1221">Security-Transparent Code, Level 1</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0"><span data-ttu-id="43201-1222">安全透明的代码，级别 2</span><span class="sxs-lookup"><span data-stu-id="43201-1222">Security-Transparent Code, Level 2</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43201-1223">获取一个值，该值指示当前类型是否透明，且因此是否无法指定关键操作。</span><span class="sxs-lookup"><span data-stu-id="43201-1223">Gets a value that indicates whether the current type is transparent, and therefore cannot perform critical operations.</span></span></summary>
        <value><span data-ttu-id="43201-1224">如果此类型是安全-透明的，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1224"><see langword="true" /> if the type is security-transparent; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-1225"><xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>、<xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>和 <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> 属性报告由公共语言运行时（CLR）确定的类型的透明度级别。</span><span class="sxs-lookup"><span data-stu-id="43201-1225">The <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> properties report the transparency level of the type, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="43201-1226">下表显示了这些属性的组合：</span><span class="sxs-lookup"><span data-stu-id="43201-1226">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="43201-1227">安全级别</span><span class="sxs-lookup"><span data-stu-id="43201-1227">Security level</span></span>|<span data-ttu-id="43201-1228">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="43201-1228">IsSecurityCritical</span></span>|<span data-ttu-id="43201-1229">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="43201-1229">IsSecuritySafeCritical</span></span>|<span data-ttu-id="43201-1230">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="43201-1230">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="43201-1231">严重</span><span class="sxs-lookup"><span data-stu-id="43201-1231">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="43201-1232">安全-关键</span><span class="sxs-lookup"><span data-stu-id="43201-1232">Safe-critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="43201-1233">透明</span><span class="sxs-lookup"><span data-stu-id="43201-1233">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="43201-1234">使用这些属性比检查程序集及其类型的安全批注、检查当前的信任级别，以及尝试复制运行时的规则要简单得多。</span><span class="sxs-lookup"><span data-stu-id="43201-1234">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
 <span data-ttu-id="43201-1235">运行时开始计算程序集的透明度级别。</span><span class="sxs-lookup"><span data-stu-id="43201-1235">The runtime begins evaluating transparency levels at the assembly.</span></span> <span data-ttu-id="43201-1236">例如，如果动态程序集是安全关键的，则类型上的批注将被忽略，并且所有类型都是安全关键的。</span><span class="sxs-lookup"><span data-stu-id="43201-1236">For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</span></span>  
  
 <span data-ttu-id="43201-1237">默认情况下，动态程序集继承发出它的程序集的透明度。</span><span class="sxs-lookup"><span data-stu-id="43201-1237">By default, a dynamic assembly inherits the transparency of the assembly that emits it.</span></span> <span data-ttu-id="43201-1238">您可以使用 <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>、<xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>或 <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> 方法重载并指定安全特性来重写此默认值。</span><span class="sxs-lookup"><span data-stu-id="43201-1238">You can override this default by using the <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, or <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> method overload and specifying security attributes.</span></span> <span data-ttu-id="43201-1239">您无法通过执行此操作提升安全级别;也就是说，透明代码无法发出安全关键代码或安全可靠关键代码。</span><span class="sxs-lookup"><span data-stu-id="43201-1239">You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</span></span> <span data-ttu-id="43201-1240">创建动态程序集时必须指定属性，或在程序集保存到磁盘并重新加载后，它们才会生效。</span><span class="sxs-lookup"><span data-stu-id="43201-1240">Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="43201-1241">默认继承限制为运行时的透明度计算。</span><span class="sxs-lookup"><span data-stu-id="43201-1241">Default inheritance is limited to the runtime's evaluation of transparency.</span></span> <span data-ttu-id="43201-1242">没有属性应用于动态程序集。</span><span class="sxs-lookup"><span data-stu-id="43201-1242">No attributes are applied to the dynamic assembly.</span></span> <span data-ttu-id="43201-1243">如果要添加安全属性，则必须自行应用这些属性。</span><span class="sxs-lookup"><span data-stu-id="43201-1243">If you want to add security attributes, you must apply them yourself.</span></span>  
  
 <span data-ttu-id="43201-1244">有关反射发出和透明度的详细信息，请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。</span><span class="sxs-lookup"><span data-stu-id="43201-1244">For more information about reflection emit and transparency, see [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span></span> <span data-ttu-id="43201-1245">有关透明度的信息，请参阅[安全更改](~/docs/framework/security/security-changes.md)。</span><span class="sxs-lookup"><span data-stu-id="43201-1245">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="43201-1246">当前动态类型不是通过调用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 方法创建的。</span><span class="sxs-lookup"><span data-stu-id="43201-1246">The current dynamic type has not been created by calling the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span></span></exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md"><span data-ttu-id="43201-1247">反射发出中的安全问题</span><span class="sxs-lookup"><span data-stu-id="43201-1247">Security Issues in Reflection Emit</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="43201-1248">反射的安全注意事项</span><span class="sxs-lookup"><span data-stu-id="43201-1248">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="43201-1249">.NET Framework 4.0 版中的安全性更改</span><span class="sxs-lookup"><span data-stu-id="43201-1249">Security Changes in the .NET Framework Version 4.0</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf"><span data-ttu-id="43201-1250">安全透明代码，级别1</span><span class="sxs-lookup"><span data-stu-id="43201-1250">Security-Transparent Code, Level 1</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0"><span data-ttu-id="43201-1251">安全透明的代码，级别 2</span><span class="sxs-lookup"><span data-stu-id="43201-1251">Security-Transparent Code, Level 2</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public override bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSerializable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public override bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="override this.IsSubclassOf : Type -&gt; bool" Usage="typeBuilder.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="c"><span data-ttu-id="43201-1252">要检查的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1252">A <see cref="T:System.Type" /> that is to be checked.</span></span></param>
        <summary><span data-ttu-id="43201-1253">确定此类型是否派生自指定类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1253">Determines whether this type is derived from a specified type.</span></span></summary>
        <returns><span data-ttu-id="43201-1254">只读。</span><span class="sxs-lookup"><span data-stu-id="43201-1254">Read-only.</span></span> <span data-ttu-id="43201-1255">如果此类型与类型 <paramref name="c" /> 相同或为类型 <paramref name="c" /> 的子类型，则返回 <see langword="true" />；否则返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1255">Returns <see langword="true" /> if this type is the same as the type <paramref name="c" />, or is a subtype of type <paramref name="c" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public override bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Reflection.Emit.TypeBuilder.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="override this.IsValueTypeImpl : unit -&gt; bool" Usage="typeBuilder.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public override bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Reflection.Emit.TypeBuilder.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="43201-1256">返回表示当前类型的数组的 <see cref="T:System.Type" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="43201-1256">Returns a <see cref="T:System.Type" /> object that represents an array of the current type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeArrayType();" />
      <MemberSignature Language="F#" Value="override this.MakeArrayType : unit -&gt; Type" Usage="typeBuilder.MakeArrayType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43201-1257">返回 <see cref="T:System.Type" /> 对象，该对象表示当前类型的一维数组（下限为零）。</span><span class="sxs-lookup"><span data-stu-id="43201-1257">Returns a <see cref="T:System.Type" /> object that represents a one-dimensional array of the current type, with a lower bound of zero.</span></span></summary>
        <returns><span data-ttu-id="43201-1258"><see cref="T:System.Type" /> 对象，该对象表示一维数组类型，其元素类型为当前类型（下限为零）。</span><span class="sxs-lookup"><span data-stu-id="43201-1258">A <see cref="T:System.Type" /> object representing a one-dimensional array type whose element type is the current type, with a lower bound of zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-1259"><xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> 方法提供了一种方法，用于生成包含任何可能的元素类型（包括泛型类型）的数组类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1259">The <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> method provides a way to generate an array type with any possible element type, including generic types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43201-1260">下面的代码示例创建一个动态模块、一个名为 `Sample`的抽象类型和一个名为 `TestMethod`的抽象方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1260">The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`.</span></span> <span data-ttu-id="43201-1261">`TestMethod` 采用类型 `Sample`的 `ref` 参数（`ByRef` Visual Basic）、指向类型 `Sample`的指针和 `Sample`类型的数组。</span><span class="sxs-lookup"><span data-stu-id="43201-1261">`TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`.</span></span> <span data-ttu-id="43201-1262">它返回 `Sample`类型的二维数组。</span><span class="sxs-lookup"><span data-stu-id="43201-1262">It returns a two-dimensional array of type `Sample`.</span></span> <span data-ttu-id="43201-1263">此代码示例将动态模块保存到磁盘中，因此可以通过[Ildasm （IL 拆装器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)进行检查。</span><span class="sxs-lookup"><span data-stu-id="43201-1263">The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeArrayType(int rank);" />
      <MemberSignature Language="F#" Value="override this.MakeArrayType : int -&gt; Type" Usage="typeBuilder.MakeArrayType rank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rank"><span data-ttu-id="43201-1264">数组的维数。</span><span class="sxs-lookup"><span data-stu-id="43201-1264">The number of dimensions for the array.</span></span></param>
        <summary><span data-ttu-id="43201-1265">返回 <see cref="T:System.Type" /> 对象，此对象表示当前类型的具有指定维数的数组。</span><span class="sxs-lookup"><span data-stu-id="43201-1265">Returns a <see cref="T:System.Type" /> object that represents an array of the current type, with the specified number of dimensions.</span></span></summary>
        <returns><span data-ttu-id="43201-1266">表示当前类型的一维数组的 <see cref="T:System.Type" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="43201-1266">A <see cref="T:System.Type" /> object that represents a one-dimensional array of the current type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-1267"><xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> 方法提供了一种方法，用于生成包含任何可能的元素类型（包括泛型类型）的数组类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1267">The <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> method provides a way to generate an array type with any possible element type, including generic types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43201-1268">下面的代码示例创建一个动态模块、一个名为 `Sample`的抽象类型和一个名为 `TestMethod`的抽象方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1268">The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`.</span></span> <span data-ttu-id="43201-1269">`TestMethod` 采用类型 `Sample`的 `ref` 参数（`ByRef` Visual Basic）、指向类型 `Sample`的指针和 `Sample`类型的数组。</span><span class="sxs-lookup"><span data-stu-id="43201-1269">`TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`.</span></span> <span data-ttu-id="43201-1270">它返回 `Sample`类型的二维数组。</span><span class="sxs-lookup"><span data-stu-id="43201-1270">It returns a two-dimensional array of type `Sample`.</span></span> <span data-ttu-id="43201-1271">此代码示例将动态模块保存到磁盘中，因此可以通过[Ildasm （IL 拆装器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)进行检查。</span><span class="sxs-lookup"><span data-stu-id="43201-1271">The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="43201-1272"><paramref name="rank" /> 不是有效的数组维数。</span><span class="sxs-lookup"><span data-stu-id="43201-1272"><paramref name="rank" /> is not a valid array dimension.</span></span></exception>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public override Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeByRefType();" />
      <MemberSignature Language="F#" Value="override this.MakeByRefType : unit -&gt; Type" Usage="typeBuilder.MakeByRefType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43201-1273">返回一个 <see cref="T:System.Type" /> 对象，它在作为 <see langword="ref" /> 参数（Visual Basic 中的 <see langword="ByRef" />）传递时表示当前类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1273">Returns a <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> in Visual Basic).</span></span></summary>
        <returns><span data-ttu-id="43201-1274"><see cref="T:System.Type" /> 对象，它在作为 <see langword="ref" /> 参数（Visual Basic 中的 <see langword="ByRef" />）传递时表示当前类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1274">A <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> in Visual Basic).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-1275"><xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> 方法提供了一种为参数列表生成 `ref` 类型（Visual Basic 中的`ByRef`）的方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1275">The <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> method provides a way to generate `ref` types (`ByRef` in Visual Basic) for parameter lists.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="43201-1276">如果当前 <xref:System.Reflection.Emit.TypeBuilder> 表示 `MyType`，则使用 Microsoft 中间语言（MSIL）语法，此方法返回的类型将为 `MyType&`。</span><span class="sxs-lookup"><span data-stu-id="43201-1276">Using Microsoft intermediate language (MSIL) syntax, if the current <xref:System.Reflection.Emit.TypeBuilder> represents `MyType`, then the type returned by this method would be `MyType&`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43201-1277">下面的代码示例创建一个动态模块、一个名为 `Sample`的抽象类型和一个名为 `TestMethod`的抽象方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1277">The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`.</span></span> <span data-ttu-id="43201-1278">`TestMethod` 采用类型 `Sample`的 `ref` 参数（`ByRef` Visual Basic）、指向类型 `Sample`的指针和 `Sample`类型的数组。</span><span class="sxs-lookup"><span data-stu-id="43201-1278">`TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`.</span></span> <span data-ttu-id="43201-1279">它返回 `Sample`类型的二维数组。</span><span class="sxs-lookup"><span data-stu-id="43201-1279">It returns a two-dimensional array of type `Sample`.</span></span> <span data-ttu-id="43201-1280">此代码示例将动态模块保存到磁盘中，因此可以通过[Ildasm （IL 拆装器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)进行检查。</span><span class="sxs-lookup"><span data-stu-id="43201-1280">The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public override Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="override this.MakeGenericType : Type[] -&gt; Type" Usage="typeBuilder.MakeGenericType typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-1.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments"><span data-ttu-id="43201-1281">当前泛型类型定义的类型参数将要替代的类型数组。</span><span class="sxs-lookup"><span data-stu-id="43201-1281">An array of types to be substituted for the type parameters of the current generic type definition.</span></span></param>
        <summary><span data-ttu-id="43201-1282">将类型数组中的元素替换为当前泛型类型定义的类型参数，并返回生成的构造类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1282">Substitutes the elements of an array of types for the type parameters of the current generic type definition, and returns the resulting constructed type.</span></span></summary>
        <returns><span data-ttu-id="43201-1283"><see cref="T:System.Type" /> 表示的构造类型通过以下方式形成：用 <paramref name="typeArguments" /> 的元素取代当前泛型类型的类型参数。</span><span class="sxs-lookup"><span data-stu-id="43201-1283">A <see cref="T:System.Type" /> representing the constructed type formed by substituting the elements of <paramref name="typeArguments" /> for the type parameters of the current generic type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-1284">当发出的代码需要从当前泛型类型定义构造的类型时，请使用此方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1284">Use this method when your emitted code requires a type constructed from the current generic type definition.</span></span> <span data-ttu-id="43201-1285">不需要先调用 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 方法，然后才能对表示泛型类型定义的 <xref:System.Reflection.Emit.TypeBuilder> 调用 <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1285">It is not necessary to call the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method before calling the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on a <xref:System.Reflection.Emit.TypeBuilder> that represents a generic type definition.</span></span> <span data-ttu-id="43201-1286">如果当前 <xref:System.Reflection.Emit.TypeBuilder> 不表示泛型类型的定义，则会引发 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="43201-1286">If the current <xref:System.Reflection.Emit.TypeBuilder> does not represent the definition of a generic type, an <xref:System.InvalidOperationException> is thrown.</span></span>  
  
 <span data-ttu-id="43201-1287">此方法返回的对象充当发出的代码中构造的泛型类型的占位符。</span><span class="sxs-lookup"><span data-stu-id="43201-1287">The object returned by this method functions as a placeholder for a constructed generic type in your emitted code.</span></span> <span data-ttu-id="43201-1288">它是从具有有限功能的 <xref:System.Type> 派生的类的实例。</span><span class="sxs-lookup"><span data-stu-id="43201-1288">It is an instance of a class derived from <xref:System.Type> that has limited capabilities.</span></span> <span data-ttu-id="43201-1289">具体而言：</span><span class="sxs-lookup"><span data-stu-id="43201-1289">In particular:</span></span>  
  
-   <span data-ttu-id="43201-1290">若要获取这些构造的泛型类型的方法、字段和构造函数，请使用 <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>、<xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29>和 <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29> 方法重载。</span><span class="sxs-lookup"><span data-stu-id="43201-1290">To get methods, fields, and constructors for these constructed generic types, use the <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>, <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29>, and <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29> method overloads.</span></span>  
  
-   <span data-ttu-id="43201-1291">表示相同构造类型的两个实例不会比较为相等。</span><span class="sxs-lookup"><span data-stu-id="43201-1291">Two instances that represent the same constructed type do not compare as equal.</span></span> <span data-ttu-id="43201-1292">例如，在以下代码中 `t1.Equals(t2)` 返回 `false`：</span><span class="sxs-lookup"><span data-stu-id="43201-1292">For example, in the following code `t1.Equals(t2)` returns `false`:</span></span>  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/vb/remarks.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-1293">此当前类型不表示泛型类型的定义。</span><span class="sxs-lookup"><span data-stu-id="43201-1293">The current type does not represent the definition of a generic type.</span></span> <span data-ttu-id="43201-1294">也就是说，<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1294">That is, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-1295"><paramref name="typeArguments" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1295"><paramref name="typeArguments" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="43201-1296">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-1296">-or-</span></span> 
<span data-ttu-id="43201-1297"><paramref name="typeArguments" /> 的任意元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1297">Any element of <paramref name="typeArguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-1298"><paramref name="typeArguments" /> 的任意元素的属性 <see cref="P:System.Type.Module" /> 的值为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1298">The <see cref="P:System.Type.Module" /> property of any element of <paramref name="typeArguments" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="43201-1299">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-1299">-or-</span></span> 
<span data-ttu-id="43201-1300"><paramref name="typeArguments" /> 的任意元素的模块的属性 <see cref="P:System.Reflection.Module.Assembly" /> 的值为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1300">The <see cref="P:System.Reflection.Module.Assembly" /> property of the module of any element of <paramref name="typeArguments" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public override Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakePointerType();" />
      <MemberSignature Language="F#" Value="override this.MakePointerType : unit -&gt; Type" Usage="typeBuilder.MakePointerType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43201-1301">返回表示指向当前类型的非托管指针的类型的 <see cref="T:System.Type" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="43201-1301">Returns a <see cref="T:System.Type" /> object that represents the type of an unmanaged pointer to the current type.</span></span></summary>
        <returns><span data-ttu-id="43201-1302">表示指向当前类型的非托管指针的类型的 <see cref="T:System.Type" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="43201-1302">A <see cref="T:System.Type" /> object that represents the type of an unmanaged pointer to the current type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-1303"><xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> 方法提供了一种方法来生成参数列表的指针类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1303">The <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> method provides a way to generate pointer types for parameter lists.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="43201-1304">如果当前 <xref:System.Reflection.Emit.TypeBuilder> 表示 `MyType`，则使用 Microsoft 中间语言（MSIL）语法，此方法返回的类型将为 `MyType*`。</span><span class="sxs-lookup"><span data-stu-id="43201-1304">Using Microsoft intermediate language (MSIL) syntax, if the current <xref:System.Reflection.Emit.TypeBuilder> represents `MyType`, then the type returned by this method would be `MyType*`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43201-1305">下面的代码示例创建一个动态模块、一个名为 `Sample`的抽象类型和一个名为 `TestMethod`的抽象方法。</span><span class="sxs-lookup"><span data-stu-id="43201-1305">The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`.</span></span> <span data-ttu-id="43201-1306">`TestMethod` 采用类型 `Sample`的 `ref` 参数（`ByRef` Visual Basic）、指向类型 `Sample`的指针和 `Sample`类型的数组。</span><span class="sxs-lookup"><span data-stu-id="43201-1306">`TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`.</span></span> <span data-ttu-id="43201-1307">它返回 `Sample`类型的二维数组。</span><span class="sxs-lookup"><span data-stu-id="43201-1307">It returns a two-dimensional array of type `Sample`.</span></span> <span data-ttu-id="43201-1308">此代码示例将动态模块保存到磁盘中，因此可以通过[Ildasm （IL 拆装器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)进行检查。</span><span class="sxs-lookup"><span data-stu-id="43201-1308">The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.Emit.TypeBuilder.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43201-1309">检索包含此类型定义的动态模块。</span><span class="sxs-lookup"><span data-stu-id="43201-1309">Retrieves the dynamic module that contains this type definition.</span></span></summary>
        <value><span data-ttu-id="43201-1310">只读。</span><span class="sxs-lookup"><span data-stu-id="43201-1310">Read-only.</span></span> <span data-ttu-id="43201-1311">检索包含此类型定义的动态模块。</span><span class="sxs-lookup"><span data-stu-id="43201-1311">Retrieves the dynamic module that contains this type definition.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.TypeBuilder.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43201-1312">检索此类型的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-1312">Retrieves the name of this type.</span></span></summary>
        <value><span data-ttu-id="43201-1313">只读。</span><span class="sxs-lookup"><span data-stu-id="43201-1313">Read-only.</span></span> <span data-ttu-id="43201-1314">检索此类型的 <see cref="T:System.String" /> 名称。</span><span class="sxs-lookup"><span data-stu-id="43201-1314">Retrieves the <see cref="T:System.String" /> name of this type.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public override string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Reflection.Emit.TypeBuilder.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43201-1315">检索定义了此 <see langword="TypeBuilder" /> 的命名空间。</span><span class="sxs-lookup"><span data-stu-id="43201-1315">Retrieves the namespace where this <see langword="TypeBuilder" /> is defined.</span></span></summary>
        <value><span data-ttu-id="43201-1316">只读。</span><span class="sxs-lookup"><span data-stu-id="43201-1316">Read-only.</span></span> <span data-ttu-id="43201-1317">检索定义了此 <see langword="TypeBuilder" /> 的命名空间。</span><span class="sxs-lookup"><span data-stu-id="43201-1317">Retrieves the namespace where this <see langword="TypeBuilder" /> is defined.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PackingSize">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PackingSize PackingSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.PackingSize PackingSize" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.PackingSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PackingSize As PackingSize" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Emit::PackingSize PackingSize { System::Reflection::Emit::PackingSize get(); };" />
      <MemberSignature Language="F#" Value="member this.PackingSize : System.Reflection.Emit.PackingSize" Usage="System.Reflection.Emit.TypeBuilder.PackingSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PackingSize</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43201-1318">检索此类型的包装大小。</span><span class="sxs-lookup"><span data-stu-id="43201-1318">Retrieves the packing size of this type.</span></span></summary>
        <value><span data-ttu-id="43201-1319">只读。</span><span class="sxs-lookup"><span data-stu-id="43201-1319">Read-only.</span></span> <span data-ttu-id="43201-1320">检索此类型的包装大小。</span><span class="sxs-lookup"><span data-stu-id="43201-1320">Retrieves the packing size of this type.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Reflection.Emit.TypeBuilder.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43201-1321">返回用于获取此类型的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1321">Returns the type that was used to obtain this type.</span></span></summary>
        <value><span data-ttu-id="43201-1322">只读。</span><span class="sxs-lookup"><span data-stu-id="43201-1322">Read-only.</span></span> <span data-ttu-id="43201-1323">用于获取此类型的类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1323">The type that was used to obtain this type.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCustomAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="43201-1324">设置自定义属性。</span><span class="sxs-lookup"><span data-stu-id="43201-1324">Sets a custom attribute.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (customBuilder As CustomAttributeBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::Emit::CustomAttributeBuilder ^ customBuilder);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.Emit.CustomAttributeBuilder -&gt; unit" Usage="typeBuilder.SetCustomAttribute customBuilder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder"><span data-ttu-id="43201-1325">用于定义自定义属性的帮助程序类的一个实例。</span><span class="sxs-lookup"><span data-stu-id="43201-1325">An instance of a helper class to define the custom attribute.</span></span></param>
        <summary><span data-ttu-id="43201-1326">使用自定义属性生成器设置自定义属性。</span><span class="sxs-lookup"><span data-stu-id="43201-1326">Set a custom attribute using a custom attribute builder.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="43201-1327">从 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]开始，此成员不再需要带有 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.ReflectionPermission>。</span><span class="sxs-lookup"><span data-stu-id="43201-1327">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="43201-1328">（请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。）若要使用此功能，应用程序应面向 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="43201-1328">(See [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-1329"><paramref name="customBuilder" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1329"><paramref name="customBuilder" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-1330">对于当前的动态类型，属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 的值为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 的值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1330">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (con As ConstructorInfo, binaryAttribute As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::ConstructorInfo ^ con, cli::array &lt;System::Byte&gt; ^ binaryAttribute);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.ConstructorInfo * byte[] -&gt; unit" Usage="typeBuilder.SetCustomAttribute (con, binaryAttribute)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con"><span data-ttu-id="43201-1331">自定义属性的构造函数。</span><span class="sxs-lookup"><span data-stu-id="43201-1331">The constructor for the custom attribute.</span></span></param>
        <param name="binaryAttribute"><span data-ttu-id="43201-1332">表示属性的字节 blob。</span><span class="sxs-lookup"><span data-stu-id="43201-1332">A byte blob representing the attributes.</span></span></param>
        <summary><span data-ttu-id="43201-1333">使用指定的自定义属性 blob 设置自定义属性。</span><span class="sxs-lookup"><span data-stu-id="43201-1333">Sets a custom attribute using a specified custom attribute blob.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-1334">有关如何 `binaryAttribute`格式的详细信息，请参阅公共语言基础结构（CLI）文档，尤其是 "第二部分：元数据定义和语义"。</span><span class="sxs-lookup"><span data-stu-id="43201-1334">For more information on how to format `binaryAttribute`, see the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="43201-1335">可联机获取该文档；请参阅 MSDN 上的 [ECMA C# 和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)和 Ecma International 网站上的[标准 ECMA-335 - 公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)。</span><span class="sxs-lookup"><span data-stu-id="43201-1335">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="43201-1336">从 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]开始，此成员不再需要带有 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.ReflectionPermission>。</span><span class="sxs-lookup"><span data-stu-id="43201-1336">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="43201-1337">（请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。）若要使用此功能，应用程序应面向 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="43201-1337">(See [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43201-1338"><paramref name="con" /> 或 <paramref name="binaryAttribute" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1338"><paramref name="con" /> or <paramref name="binaryAttribute" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-1339">对于当前的动态类型，属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 的值为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 的值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1339">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetParent">
      <MemberSignature Language="C#" Value="public void SetParent (Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetParent(class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetParent (parent As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetParent(Type ^ parent);" />
      <MemberSignature Language="F#" Value="member this.SetParent : Type -&gt; unit" Usage="typeBuilder.SetParent parent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="parent"><span data-ttu-id="43201-1340">新的基类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1340">The new base type.</span></span></param>
        <summary><span data-ttu-id="43201-1341">设置当前正在构造的类型的基类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1341">Sets the base type of the type currently under construction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-1342">如果 `null``parent`，<xref:System.Object> 将用作基类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1342">If `parent` is `null`, <xref:System.Object> is used as the base type.</span></span>  
  
 <span data-ttu-id="43201-1343">在 .NET Framework 版本1.0 和1.1 中，如果 `parent` 为接口类型，则不会引发异常，但在调用 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 方法时将引发 <xref:System.TypeLoadException>。</span><span class="sxs-lookup"><span data-stu-id="43201-1343">In the .NET Framework versions 1.0 and 1.1, no exception is thrown if `parent` is an interface type, but a <xref:System.TypeLoadException> is thrown when the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method is called.</span></span>  
  
 <span data-ttu-id="43201-1344"><xref:System.Reflection.Emit.TypeBuilder.SetParent%2A> 方法不检查大多数无效的父类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1344">The <xref:System.Reflection.Emit.TypeBuilder.SetParent%2A> method does not check for most invalid parent types.</span></span> <span data-ttu-id="43201-1345">例如，当当前类型具有无参数构造函数时，它不会拒绝没有无参数构造函数的父类型，它不会拒绝密封类型，也不会拒绝 <xref:System.Delegate> 类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1345">For example, it does not reject a parent type that has no parameterless constructor when the current type has a parameterless constructor, it does not reject sealed types, and it does not reject the <xref:System.Delegate> type.</span></span> <span data-ttu-id="43201-1346">在所有这些情况下，<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 方法均引发异常。</span><span class="sxs-lookup"><span data-stu-id="43201-1346">In all these cases, exceptions are thrown by the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-1347">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</span><span class="sxs-lookup"><span data-stu-id="43201-1347">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="43201-1348">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-1348">-or-</span></span> 
 <span data-ttu-id="43201-1349"><paramref name="parent" /> 为 <see langword="null" />，并且当前实例表示其属性不包括 <see cref="F:System.Reflection.TypeAttributes.Abstract" /> 的接口。</span><span class="sxs-lookup"><span data-stu-id="43201-1349"><paramref name="parent" /> is <see langword="null" />, and the current instance represents an interface whose attributes do not include <see cref="F:System.Reflection.TypeAttributes.Abstract" />.</span></span>  
  
<span data-ttu-id="43201-1350">- 或 -</span><span class="sxs-lookup"><span data-stu-id="43201-1350">-or-</span></span> 
<span data-ttu-id="43201-1351">对于当前的动态类型，属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 的值为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 的值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1351">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43201-1352"><paramref name="parent" /> 是一个接口。</span><span class="sxs-lookup"><span data-stu-id="43201-1352"><paramref name="parent" /> is an interface.</span></span> <span data-ttu-id="43201-1353">此异常条件是 .NET Framework 2.0 版中新增的。</span><span class="sxs-lookup"><span data-stu-id="43201-1353">This exception condition is new in the .NET Framework version 2.0.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public int Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Size" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Size" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Size As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Size { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Size : int" Usage="System.Reflection.Emit.TypeBuilder.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43201-1354">检索类型的总大小。</span><span class="sxs-lookup"><span data-stu-id="43201-1354">Retrieves the total size of a type.</span></span></summary>
        <value><span data-ttu-id="43201-1355">只读。</span><span class="sxs-lookup"><span data-stu-id="43201-1355">Read-only.</span></span> <span data-ttu-id="43201-1356">检索此类型的总大小。</span><span class="sxs-lookup"><span data-stu-id="43201-1356">Retrieves this type's total size.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _TypeBuilder.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_TypeBuilder::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="43201-1357">留待将来使用。</span><span class="sxs-lookup"><span data-stu-id="43201-1357">Reserved for future use.</span></span> <span data-ttu-id="43201-1358">必须为 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="43201-1358">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="43201-1359">要映射的名称的传入数组。</span><span class="sxs-lookup"><span data-stu-id="43201-1359">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="43201-1360">要映射的名称的计数。</span><span class="sxs-lookup"><span data-stu-id="43201-1360">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="43201-1361">要在其中解释名称的区域设置上下文。</span><span class="sxs-lookup"><span data-stu-id="43201-1361">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="43201-1362">调用方分配的数组，用于接收与名称对应的 ID。</span><span class="sxs-lookup"><span data-stu-id="43201-1362">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="43201-1363">将一组名称映射为对应的一组调度标识符。</span><span class="sxs-lookup"><span data-stu-id="43201-1363">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-1364">此方法用于从非托管代码访问托管类，不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="43201-1364">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="43201-1365">有关 `IDispatch::GetIDsOfNames`的详细信息，请参阅 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="43201-1365">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="43201-1366">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="43201-1366">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _TypeBuilder.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_TypeBuilder::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="43201-1367">要返回的类型信息。</span><span class="sxs-lookup"><span data-stu-id="43201-1367">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="43201-1368">类型信息的区域设置标识符。</span><span class="sxs-lookup"><span data-stu-id="43201-1368">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="43201-1369">接收一个指针，指向请求的类型信息对象。</span><span class="sxs-lookup"><span data-stu-id="43201-1369">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="43201-1370">检索对象的类型信息，然后可以使用该信息获取接口的类型信息。</span><span class="sxs-lookup"><span data-stu-id="43201-1370">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-1371">此方法用于从非托管代码访问托管类，不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="43201-1371">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="43201-1372">有关 `IDispatch::GetTypeInfo`的详细信息，请参阅 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="43201-1372">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="43201-1373">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="43201-1373">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _TypeBuilder.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_TypeBuilder::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="43201-1374">指向一个位置，该位置接收对象提供的类型信息接口的数量。</span><span class="sxs-lookup"><span data-stu-id="43201-1374">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="43201-1375">检索对象提供的类型信息接口的数量（0 或 1）。</span><span class="sxs-lookup"><span data-stu-id="43201-1375">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-1376">此方法用于从非托管代码访问托管类，不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="43201-1376">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="43201-1377">有关 `IDispatch::GetTypeInfoCount`的详细信息，请参阅 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="43201-1377">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="43201-1378">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="43201-1378">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _TypeBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _TypeBuilder.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_TypeBuilder::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="43201-1379">标识成员。</span><span class="sxs-lookup"><span data-stu-id="43201-1379">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="43201-1380">留待将来使用。</span><span class="sxs-lookup"><span data-stu-id="43201-1380">Reserved for future use.</span></span> <span data-ttu-id="43201-1381">必须为 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="43201-1381">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="43201-1382">要在其中解释自变量的区域设置上下文。</span><span class="sxs-lookup"><span data-stu-id="43201-1382">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="43201-1383">描述调用的上下文的标志。</span><span class="sxs-lookup"><span data-stu-id="43201-1383">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="43201-1384">指向一个结构的指针，该结构包含一个参数数组、一个命名参数的 DISPID 参数数组和数组中元素数的计数。</span><span class="sxs-lookup"><span data-stu-id="43201-1384">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="43201-1385">指向要存储结果的位置的指针。</span><span class="sxs-lookup"><span data-stu-id="43201-1385">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="43201-1386">指向一个包含异常信息的结构的指针。</span><span class="sxs-lookup"><span data-stu-id="43201-1386">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="43201-1387">第一个出错参数的索引。</span><span class="sxs-lookup"><span data-stu-id="43201-1387">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="43201-1388">提供对某一对象公开的属性和方法的访问。</span><span class="sxs-lookup"><span data-stu-id="43201-1388">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-1389">此方法用于从非托管代码访问托管类，不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="43201-1389">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="43201-1390">有关 `IDispatch::Invoke`的详细信息，请参阅 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="43201-1390">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="43201-1391">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="43201-1391">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="typeBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43201-1392">返回不包括命名空间的类型的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-1392">Returns the name of the type excluding the namespace.</span></span></summary>
        <returns><span data-ttu-id="43201-1393">只读。</span><span class="sxs-lookup"><span data-stu-id="43201-1393">Read-only.</span></span> <span data-ttu-id="43201-1394">不包括命名空间的类型的名称。</span><span class="sxs-lookup"><span data-stu-id="43201-1394">The name of the type excluding the namespace.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public override RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Reflection.Emit.TypeBuilder.TypeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43201-1395">不支持动态模块。</span><span class="sxs-lookup"><span data-stu-id="43201-1395">Not supported in dynamic modules.</span></span></summary>
        <value><span data-ttu-id="43201-1396">只读。</span><span class="sxs-lookup"><span data-stu-id="43201-1396">Read-only.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43201-1397">使用 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 或 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 检索该类型，并对检索到的类型使用反射。</span><span class="sxs-lookup"><span data-stu-id="43201-1397">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="43201-1398">不支持动态模块。</span><span class="sxs-lookup"><span data-stu-id="43201-1398">Not supported in dynamic modules.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TypeToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeToken TypeToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.TypeToken TypeToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeToken As TypeToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Emit::TypeToken TypeToken { System::Reflection::Emit::TypeToken get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeToken : System.Reflection.Emit.TypeToken" Usage="System.Reflection.Emit.TypeBuilder.TypeToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43201-1399">返回此类型的类型标记。</span><span class="sxs-lookup"><span data-stu-id="43201-1399">Returns the type token of this type.</span></span></summary>
        <value><span data-ttu-id="43201-1400">只读。</span><span class="sxs-lookup"><span data-stu-id="43201-1400">Read-only.</span></span> <span data-ttu-id="43201-1401">返回此类型的 <see langword="TypeToken" />。</span><span class="sxs-lookup"><span data-stu-id="43201-1401">Returns the <see langword="TypeToken" /> of this type.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-1402">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</span><span class="sxs-lookup"><span data-stu-id="43201-1402">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public override Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Reflection.Emit.TypeBuilder.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43201-1403">返回此 <see langword="TypeBuilder" /> 的基础系统类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1403">Returns the underlying system type for this <see langword="TypeBuilder" />.</span></span></summary>
        <value><span data-ttu-id="43201-1404">只读。</span><span class="sxs-lookup"><span data-stu-id="43201-1404">Read-only.</span></span> <span data-ttu-id="43201-1405">返回基础系统类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1405">Returns the underlying system type.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43201-1406">此类型是一个枚举，但没有任何基础系统类型。</span><span class="sxs-lookup"><span data-stu-id="43201-1406">This type is an enumeration, but there is no underlying system type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="UnspecifiedTypeSize">
      <MemberSignature Language="C#" Value="public const int UnspecifiedTypeSize = 0;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 UnspecifiedTypeSize = (0)" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize" />
      <MemberSignature Language="VB.NET" Value="Public Const UnspecifiedTypeSize As Integer  = 0" />
      <MemberSignature Language="C++ CLI" Value="public: int UnspecifiedTypeSize = 0;" />
      <MemberSignature Language="F#" Value="val mutable UnspecifiedTypeSize : int" Usage="System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary><span data-ttu-id="43201-1407">表示未指定类型的总大小。</span><span class="sxs-lookup"><span data-stu-id="43201-1407">Represents that total size for the type is not specified.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
