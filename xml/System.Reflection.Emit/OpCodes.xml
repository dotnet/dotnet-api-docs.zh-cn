<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c96aa9e4ce2a7d98b19a6ef14e35b41284c5a5f1" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78693044" /></Metadata><TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Reflection.Primitives" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>通过 <see cref="T:System.Reflection.Emit.ILGenerator" /> 类成员（例如 <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />）为发出提供 Microsoft 中间语言 (MSIL) 指令的字段表示形式。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关成员操作码的详细说明，请参阅公共语言基础结构（CLI）文档，尤其是 "第三部分： CIL 指令集" 和 "第二部分：元数据定义和语义"。 可联机获取该文档；请参阅 MSDN 上的 [ECMA C# 和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)和 Ecma International 网站上的[标准 ECMA-335 - 公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)。  
  
   
  
## Examples  
 下面的示例演示如何使用 <xref:System.Reflection.Emit.ILGenerator> 将 `OpCodes` 发送到 <xref:System.Reflection.Emit.MethodBuilder>的动态方法。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个值相加并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|58|add|将两个数值相加，并返回一个新的数值。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;`value1` 添加到 `value2`中。  
  
4.  将结果推送到堆栈上。  
  
 未检测到用于整数运算的溢出（有关正确的溢出处理，请参阅 <xref:System.Reflection.Emit.OpCodes.Add_Ovf>）。  
  
 整数加法换行，而不是尽量充满。 例如，假设 `value1` 的8位整数设置为255，并且 `value2` 设置为1，则已包装的结果为0而不是256。  
  
 浮点溢出返回 `+inf` （`PositiveInfinity`）或 `-inf` （`NegativeInfinity`）。  
  
 下表列出了可接受的操作数类型及其对应的结果数据类型。 如果没有特定类型组合的条目（例如 `int32` 和 `float`; `int32` 和 `int64`），则它是无效的 Microsoft 中间语言（MSIL）并生成错误。  
  
|操作数|value1 类型|value2 类型|结果类型|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|添加|`int32`|`native int`|`native int`|  
|添加|`int32`|`&`|`&`|  
|添加|`int32`|`*`|`*`|  
|添加|`int64`|`int64`|`int64`|  
|添加|`native int`|`int32`|`native int`|  
|添加|`native int`|`native int`|`native int`|  
|添加|`native int`|`&`|`&`|  
|添加|`native int`|`*`|`*`|  
|添加|`F`|`F`|`F`|  
|添加|`&`|`int32`|`&`|  
|添加|`&`|`native int`|`&`|  
|添加|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `add` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个整数相加，执行溢出检查，并且将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|D6|add.ovf|使用溢出检查添加两个有符号整数值。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;将 `value1` 添加到具有溢出检查的 `value2` 中。  
  
4.  将结果推送到堆栈上。  
  
 如果结果类型中未表示结果，则会引发 <xref:System.OverflowException>。  
  
 您可以对有符号整数执行此操作。 对于浮点值，请使用 <xref:System.Reflection.Emit.OpCodes.Add>。  
  
 下表列出了可接受的操作数类型及其对应的结果数据类型。 如果没有特定类型组合的条目（例如 `int32` 和 `float`; `int32` 和 `int64`），则它是无效的 Microsoft 中间语言（MSIL）指令并生成错误。  
  
|操作数|value1 类型|value2 类型|结果类型|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|添加|`int32`|`native int`|`native int`|  
|添加|`int32`|`&`|`&`|  
|添加|`int32`|`*`|`*`|  
|添加|`int64`|`int64`|`int64`|  
|添加|`native int`|`int32`|`native int`|  
|添加|`native int`|`native int`|`native int`|  
|添加|`native int`|`&`|`&`|  
|添加|`native int`|`*`|`*`|  
|添加|`F`|`F`|`F`|  
|添加|`&`|`int32`|`&`|  
|添加|`&`|`native int`|`&`|  
|添加|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `add.ovf` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个无符号整数值相加，执行溢出检查，并且将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|D7|add.ovf.un|使用溢出检查添加两个无符号整数值。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;将 `value1` 添加到具有溢出检查的 `value2` 中。  
  
4.  将结果推送到堆栈上。  
  
 如果结果类型中未表示结果，则会引发 <xref:System.OverflowException>。  
  
 您可以对有符号整数执行此操作。 对于浮点值，请使用 <xref:System.Reflection.Emit.OpCodes.Add>。  
  
 下表列出了可接受的操作数类型及其对应的结果数据类型。 如果没有特定类型组合的条目（例如 `int32` 和 `float`; `int32` 和 `int64`），则它是无效的 Microsoft 中间语言（MSIL）指令并生成错误。  
  
|操作数|value1 类型|value2 类型|结果类型|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|添加|`int32`|`native int`|`native int`|  
|添加|`int32`|`&`|`&`|  
|添加|`int32`|`*`|`*`|  
|添加|`int64`|`int64`|`int64`|  
|添加|`native int`|`int32`|`native int`|  
|添加|`native int`|`native int`|`native int`|  
|添加|`native int`|`&`|`&`|  
|添加|`native int`|`*`|`*`|  
|添加|`F`|`F`|`F`|  
|添加|`&`|`int32`|`&`|  
|添加|`&`|`native int`|`&`|  
|添加|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `add.ovf.un` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>计算两个值的按位“与”并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|指令|描述|  
|------------|-----------------|-----------------|  
|5F|和|确定两个整数值的按位 "与"。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value1` 和 `value2`;计算两个值的按位 "与"。  
  
4.  将结果推送到堆栈上。  
  
 `and` 指令计算堆栈上前两个值的按位 "与"，并将结果保留在堆栈上。  
  
 `And` 是特定于整数的操作。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `and` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>返回指向当前方法的参数列表的非托管指针。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 00|arglist|返回当前方法的参数列表句柄。|  
  
 此操作不会执行任何计算堆栈行为。  
  
 `arglist` 指令返回表示当前方法的参数列表的不透明的句柄（类型为 `native int`的非托管指针）。 此句柄仅在当前方法的生存期内有效。 但是，只要当前方法在控制线程上，你就可以将该句柄传递给其他方法。 只能在采用可变数目的参数的方法中执行 `arglist` 指令。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `arglist` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果两个值相等，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|3B < `int32` >|beq `target`|如果两个值相等，则在偏移 `target` 分支到目标指令。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 等于 `value2`，则执行分支操作。  
  
 如果 `value1` 等于 `value2`，则 `beq` 指令将控制转移到指定的目标指令。 其效果与执行 `ceq` 指令后跟特定目标指令的 `brtrue` 分支相同。 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 可接受的操作数类型如下所示：  
  
 如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。  
  
 此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制（此类传输受到严格限制，因此必须改用 <xref:System.Reflection.Emit.OpCodes.Leave> 指令）。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `beq` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果两个值相等，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|2E < `int8` >|beq `target`|如果相等，则分支到目标指令（如果相等） `target` 短格式|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 等于 `value2`，则执行分支操作。  
  
 如果 `value1` 等于 `value2`，则 `beq.s` 指令将控制转移到指定的目标指令。 其效果与执行 `ceq` 指令后跟特定目标指令的 `brtrue` 分支相同。 目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。  
  
 可接受的操作数类型如下所示：  
  
 如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。  
  
 此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制（此类传输受到严格限制，因此必须改用 <xref:System.Reflection.Emit.OpCodes.Leave> 指令）。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `beq.s` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值大于或等于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|3C `<int32>`|bge `target`|如果第一个值大于或等于第二个值，则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 大于或等于 `value2`，则执行分支操作。  
  
 如果 `value1` 大于或等于 `value2`，则 `bge` 指令将控制转移到指定的目标指令。 此效果等同于执行 `clt` 指令（`clt.un` 对于浮点数），后跟一个 `brfalse` 分支到特定目标指令。 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。 此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `bge` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值大于或等于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|2F `<int8>`|bge `target`|如果第一个值大于或等于第二个值，则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 大于或等于 `value2`，则执行分支操作。  
  
 如果 `value1` 大于或等于 `value2`，则 `bge.s` 指令将控制转移到指定的目标指令。 此效果等同于执行 `clt` 指令（`clt.un` 对于浮点数），后跟一个 `brfalse` 分支到特定目标指令。 目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。 此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `bge.s` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或未经排序的浮点值时，如果第一个值大于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|41 `<int32>`|bge `target`|如果第一个值大于或等于第二个值（无符号值），则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 大于或等于 `value2`，则执行分支操作。  
  
 如果 `value1` 大于或等于 `value2`，则在使用无符号整数或无序浮点值进行比较时，`bge.un` 指令将控制转移到指定的目标指令。 此效果等同于执行 `clt.un` 指令（`clt` 对于浮点数），后跟一个 `brfalse` 分支到特定目标指令。 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。 此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `bge.un` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或未经排序的浮点值时，如果第一个值大于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|34 < `int8` >|bge `target`|如果第一个值大于或等于第二个值（无符号值），则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 大于或等于 `value2`，则执行分支操作。  
  
 如果 `value1` 大于或等于 `value2`，则在使用无符号整数或无序浮点值进行比较时，`bge.un.s` 指令将控制转移到指定的目标指令。 此效果等同于执行 `clt.un` 指令（`clt` 对于浮点数），后跟一个 `brfalse` 分支到特定目标指令。 目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。 此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `bge.un.s` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值大于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|3D < `int32` >|预算 `target`|如果第一个值大于第二个值，则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 大于 `value2`，则执行分支操作。  
  
 如果 `value1` 大于 `value2`，则 `bgt` 指令将控制转移到指定的目标指令。 其效果与执行 `cgt` 指令后跟特定目标指令的 `brtrue` 分支相同。 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。 此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `bgt` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值大于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|30 < `int8` >|预算 `target`|如果第一个值大于第二个值，则按指定的偏移量分支到目标指令（缩写形式）。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 大于 `value2`，则执行分支操作。  
  
 如果 `value1` 大于 `value2`，则 `bgt.s` 指令将控制转移到指定的目标指令。 其效果与执行 `cgt` 指令后跟特定目标指令的 `brtrue` 分支相同。 目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。 此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `bgt.s` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或未经排序的浮点值时，如果第一个值大于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|42 < `int32` >|预算 `target`|如果第一个值大于第二个值（无符号值），则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 大于 `value2`，则执行分支操作。  
  
 当使用无符号整数或无序浮点值进行比较时，如果 `value1` 大于 `value2`，则 `bgt.un` 指令将控制转移到指定的目标指令。 其效果与执行 `cgt.un` 指令后跟特定目标指令的 `brtrue` 分支相同。 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。 此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `bgt.un` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或未经排序的浮点值时，如果第一个值大于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|35 < `int8` >|预算 `target`|如果第一个值大于第二个值（无符号值），则按指定的偏移量分支到目标指令（短格式）。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 大于 `value2`，则执行分支操作。  
  
 当使用无符号整数或无序浮点值进行比较时，如果 `value1` 大于 `value2`，则 `bgt.un.s` 指令将控制转移到指定的目标指令。 其效果与执行 `cgt.un` 指令后跟特定目标指令的 `brtrue` 分支相同。 目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。 此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `bgt.un.s` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值小于或等于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|3E `<int32>`|ble `target`|如果第一个值小于或等于第二个值，则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 小于或等于 `value2`，则执行分支操作。  
  
 如果 `value1` 小于或等于 `value2`，则 `ble` 指令将控制转移到指定的目标指令。 此效果等同于执行 `cgt` 指令（`cgt.un` 对于浮点数），后跟一个 `brfalse` 分支到特定目标指令。 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。 此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ble` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值小于或等于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|31 `<int8>`|ble `target`|如果第一个值小于或等于第二个值，则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 小于或等于 `value2`，则执行分支操作。  
  
 如果 `value1` 小于或等于 `value2`，则 `ble.s` 指令将控制转移到指定的目标指令。 其效果与执行 `cgt` 指令（`cgt.un` 对于浮点数）指令相同，后面跟有`brfalse` 分支到特定目标指令。 目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。 此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ble.s` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或未经排序的浮点值时，如果第一个值小于或等于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|43 `<int32>`|ble `target`|如果第一个值小于或等于第二个值（无符号值），则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 小于或等于 `value2`，则执行分支操作。  
  
 当使用无符号整数或无序浮点值进行比较时，如果 `value1` 小于或等于 `value2`，则 `ble.un` 指令将控制转移到指定的目标指令。 此效果等同于执行 `cgt.un` 指令（`cgt` 对于浮点数），后跟一个 `brfalse` 分支到特定目标指令。 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。 此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ble.un` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或未经排序的浮点值时，如果第一个值小于或等于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|36 `<int8>`|ble `target`|如果第一个值小于或等于第二个值（无符号值），则按指定的偏移量分支到目标指令（短格式）。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 小于或等于 `value2`，则执行分支操作。  
  
 当使用无符号整数或无序浮点值进行比较时，如果 `value1` 小于或等于 `value2`，则 `ble.un.s` 指令将控制转移到指定的目标指令。 此效果等同于执行 `cgt.un` 指令（`cgt` 对于浮点数），后跟一个 `brfalse` 分支到特定目标指令。 目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。 此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ble.un.s` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值小于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|3F < `int32` >|blt `target`|如果第一个值小于第二个值，则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 小于 `value2`，则执行分支操作。  
  
 如果 `value1` 小于或等于 `value2`，则 `blt` 指令将控制转移到指定的目标指令。 其效果与执行 `clt` 指令后跟特定目标指令的 `brtrue` 分支相同。 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。 此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `blt` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值小于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|32 < `int8` >|blt `target`|如果第一个值小于第二个值，则按指定的偏移量分支到目标指令（缩写形式）。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 小于 `value2`，则执行分支操作。  
  
 如果 `value1` 小于 `value2`，则 `blt.s` 指令将控制转移到指定的目标指令。 其效果与执行 `clt` 指令后跟特定目标指令的 `brtrue` 分支相同。 目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。 此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `blt.s` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或未经排序的浮点值时，如果第一个值小于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|44 < `int32` >|blt `target`|如果第一个值小于第二个值（无符号值），则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 小于 `value2`，则执行分支操作。  
  
 当使用无符号整数或无序浮点值进行比较时，如果 `value1` 小于 `value2`，则 `blt.un` 指令将控制转移到指定的目标指令。 其效果与执行 `clt.un` 指令后跟特定目标指令的 `brtrue` 分支相同。 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。 此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `blt.un` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或未经排序的浮点值时，如果第一个值小于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|37 < `int8` >|blt `target`|如果第一个值小于第二个值（无符号值），则按指定的偏移量分支到目标指令（短格式）。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 小于 `value2`，则执行分支操作。  
  
 当使用无符号整数或无序浮点值进行比较时，如果 `value1` 小于 `value2`，则 `blt.un` 指令将控制转移到指定的目标指令。 其效果与执行 `clt.un` 指令后跟特定目标指令的 `brtrue` 分支相同。 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。 此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `blt.un.s` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当两个无符号整数值或未经排序的浮点值不相等时，将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|40 < `int32` >|bne `target`|如果两个无符号整数值不相等（无符号值），则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 不等于 `value2`，则执行分支操作。  
  
 当使用无符号整数或无序浮点值进行比较时，如果 `value1` 不等于 `value2`，则 `bne.un` 指令将控制转移到指定的目标指令。 其效果与执行 `ceq` 指令后跟特定目标指令的 `brfalse` 分支相同。 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。 此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `bne.un` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当两个无符号整数值或未经排序的浮点值不相等时，将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|33 < `int8` >|bne `target`|如果两个无符号整数值不相等（无符号值），则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 不等于 `value2`，则执行分支操作。  
  
 当使用无符号整数或无序浮点值进行比较时，如果 `value1` 不等于 `value2`，则 `bne.un` 指令将控制转移到指定的目标指令。 其效果与执行 `ceq` 指令后跟特定目标指令的 `brfalse` 分支相同。 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。 此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `bne.un.s` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将值类转换为对象引用（<see langword="O" /> 类型）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|8C < `T` >|box `valTypeToken`|将值类型（在 `valTypeToken`中指定的类型）转换为真正的对象引用。|  
  
 堆栈转换行为顺序如下：  
  
1.  值类型被推送到堆栈上。  
  
2.  从堆栈中弹出值类型;执行 `box` 操作。  
  
3.  对生成的 "装箱" 值类型的对象引用被推送到堆栈上。  
  
 值类型在公共语言基础结构（CLI）中具有两种不同的表示形式：  
  
-   当值类型嵌入到另一个对象或堆栈上时使用的 "原始" 窗体。  
  
-   "装箱" 窗体，其中值类型中的数据被包装（装箱）到对象中，因此它可以作为独立实体存在。  
  
 `box` 指令将 "raw" （未装箱）值类型转换为对象引用（类型 `O`）。 为此，可以创建一个新的对象，并将数据从值类型复制到新分配的对象。 `valTypeToken` 是指示堆栈上值类型类型的元数据标记。  
  
 如果内存不足，无法满足请求，则会引发 <xref:System.OutOfMemoryException>。  
  
 如果找不到类，则会引发 <xref:System.TypeLoadException>。 当 Microsoft 中间语言（MSIL）转换为本机代码而不是运行时，通常会检测到此情况。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `box` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>无条件地将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|38 < `int32` >|br `target`|按指定的偏移量分支到目标指令。|  
  
 此操作不会执行任何计算堆栈行为。  
  
 `br` 指令无条件地将控制转移到目标指令。 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。 此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `br` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>无条件地将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|2B < `int8` >|br `target`|按指定的偏移量（短格式）分支到目标指令。|  
  
 此操作不会执行任何计算堆栈行为。  
  
 `br.s` 指令无条件地将控制转移到目标指令。 目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。 此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `br.s` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>向公共语言结构 (CLI) 发出信号以通知调试器已撞上了一个断点。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|01|break|通知调试器已达到断点。|  
  
 此操作不会执行任何计算堆栈行为。  
  
 `break` 指令用于调试支持。 它向 CLI 发出信号，通知调试器中断点已被终止。 它对解释器状态没有其他影响。  
  
 `break` 指令的最小可能的指令大小，这使得代码可以使用断点进行修补，并为环绕代码生成最小的干扰。  
  
 `break` 指令可以捕获调试器、不执行任何操作，或者引发安全异常。 确切的行为是实现定义的。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `break` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果 <paramref name="value" /> 为 <see langword="false" />、空引用（Visual Basic 中的 <see langword="Nothing" />）或零，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|39 < `int32` >|brfalse `target`<br /><br /> brnull `target`<br /><br /> brzero `target`|如果 `false`，则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下：  
  
1.  之前的操作将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`;如果 `false``value`，则分支到 `target`。  
  
 如果 `value` （类型 `int32`、`int64`、对象引用 `O`、托管指针 `&`、暂时性指针 `*`、`native int`）为零（`false`），则 `brfalse` 指令（及其别名 `brnull` 和 `brzero`）将控制转移到指定的目标指令。 如果 `value` 为非零（`true`），则在下一条指令处继续执行。  
  
 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。 此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `brfalse` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果 <paramref name="value" /> 为 <see langword="false" />、空引用或零，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|2C <`int8` >|brfalse `target`<br /><br /> brnull `target`<br /><br /> brzero `target`|如果 `false`，则按指定的偏移量分支到目标指令（缩写形式）。|  
  
 堆栈转换行为顺序如下：  
  
1.  之前的操作将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`;如果 `false``value`，则分支到 `target`。  
  
 如果 `value` （类型 `int32`、`int64`、对象引用 `O`、托管指针 `&`、暂时性指针 `*`、`native int`）为零（`false`），则 `brfalse.s` 指令（及其别名 `brnull` 和 `brzero`）将控制转移到指定的目标指令。 如果 `value` 为非零（`true`），则在下一条指令处继续执行。  
  
 目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。 此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `brfalse.s` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果 <paramref name="value" /> 为 <see langword="true" />、非空或非零，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|3A < `int32` >|brtrue `target`<br /><br /> brinst `target`|如果非零（`true`），则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下：  
  
1.  之前的操作将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`;如果 `true``value`，则分支到 `target`。  
  
 如果 `value` （类型 `native int`）为非零（`true`），则 `brtrue` 指令将控制转移到指定的目标指令。 如果 `value` 为零（`false`），则在下一条指令处继续执行。  
  
 如果 `value` 是对象引用（键入 `O`），则 `brinst` （`brtrue`的别名）在表示对象的实例的情况下传输控制（例如，如果它不是 null 对象引用，请参阅 <xref:System.Reflection.Emit.OpCodes.Ldnull>）。  
  
 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。 此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `brtrue` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果 <paramref name="value" /> 为 <see langword="true" />、非空或非零，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|2D < `int8` >|brtrue `target`<br /><br /> brinst `target`|如果非零（`true`），则按指定的偏移量分支到目标指令（缩写形式）。|  
  
 堆栈转换行为顺序如下：  
  
1.  之前的操作将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`;如果 `true``value`，则分支到 `target`。  
  
 如果 `value` （类型 `native int`）为非零（`true`），则 `brtrue.s` 指令将控制转移到指定的目标指令。 如果 `value` 为零（`false`），则在下一条指令处继续执行。  
  
 如果 `value` 是对象引用（键入 `O`），则 `brinst` （`brtrue`的别名）在表示对象的实例的情况下传输控制（例如，如果它不是 null 对象引用，请参阅 <xref:System.Reflection.Emit.OpCodes.Ldnull>）。  
  
 目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。 此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `brtrue.s` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>调用由传递的方法说明符指示的方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|28 < `T` >|致电 `methodDesc`|调用 `methodDesc`描述的方法。|  
  
 堆栈转换行为顺序如下：  
  
1.  通过 `argN` `arg1` 的方法参数被推送到堆栈上。  
  
2.  从堆栈中弹出 `argN` `arg1` 的方法参数;使用这些参数执行方法调用，并将控件传输到方法说明符所引用的方法。 完成后，调用方方法将生成一个返回值，并将其发送给调用方。  
  
3.  将返回值推送到堆栈上。  
  
 `call` 指令调用通过指令传递的方法说明符指示的方法。 方法描述符是一种元数据标记，用于指示要调用的方法，以及要传递到该方法的堆栈上的参数的数量、类型和顺序，以及要使用的调用约定。 `call` 指令前面可以跟 `tail` （<xref:System.Reflection.Emit.OpCodes.Tailcall>）前缀指令，以指定在传输控制之前应释放当前方法状态。 如果调用将控制转移到比源方法更高的信任方法，则不会释放堆栈帧。 相反，执行将以无提示方式继续，就好像尚未提供 `tail`。 元数据标记携带足够的信息来确定调用是静态方法、实例方法、虚方法还是全局函数。 在所有这些情况下，均从方法描述符完全确定目标地址（与此与调用虚拟方法的 <xref:System.Reflection.Emit.OpCodes.Callvirt> 指令比较），其中目标地址还依赖于在 <xref:System.Reflection.Emit.OpCodes.Callvirt>之前推送的实例引用的运行时类型。  
  
 自变量以从左到右的顺序放置在堆栈上。 也就是说，第一个参数是计算并放置在堆栈上，然后是第三个参数，然后是第三个参数，直到所有必需的参数按降序排列。 有三个重要的特殊情况：  
  
 1. 对实例（或虚拟）方法的调用必须将该实例引用推送到任何用户可见参数之前。 实例引用不得为空引用。 在元数据中携带的签名在 `this` 指针的参数列表中不包含项;相反，它使用一个位来指示方法是否要求传递 `this` 指针。  
  
 2. 使用 `call` （而不是 `callvirt`）调用虚拟方法是有效的;这表示使用方法指定的类（而不是从所调用的对象动态指定）解析方法。  
  
 3. 请注意，可以使用 `call` 或 `callvirt` 指令调用委托的 `Invoke` 方法。  
  
 如果系统安全不允许调用方访问调用的方法，则可能会引发 <xref:System.Security.SecurityException>。 当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是运行时，可能会进行安全检查。  
  
> [!NOTE]
>  当在值类型上调用 System.object 的方法时，请考虑将 `constrained` 前缀与 `callvirt` 指令一起使用，而不是发出 `call` 指令。 这就不必发出不同的 IL，具体取决于值类型是否重写方法，避免出现潜在的版本控制问题。 当对值类型调用接口方法时，请考虑使用 `constrained` 前缀，因为实现接口方法的值类型方法可以使用 `MethodImpl`进行更改。 <xref:System.Reflection.Emit.OpCodes.Constrained> opcode 中更详细地介绍了这些问题。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `call` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.EmitCall%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%2CSystem.Type%5B%5D%29?displayProperty=nameWithType>  
  
> [!NOTE]
>  提供 `varargs` 调用的 <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> 方法。 使用 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法进行正常调用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>通过调用约定描述的参数调用在计算堆栈上指示的方法（作为指向入口点的指针）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|29 < `T` >|calli `callSiteDescr`|使用调用约定描述的参数调用指向的方法。|  
  
 堆栈转换行为顺序如下：  
  
1.  通过 `argN` `arg1` 的方法参数被推送到堆栈上。  
  
2.  方法输入指针被推送到堆栈上。  
  
3.  通过 `argN` `arg1` 方法参数，并从堆栈中弹出方法输入指针;执行对方法的调用。 完成后，调用方方法将生成一个返回值，并将其发送给调用方。  
  
4.  将返回值推送到堆栈上。  
  
 `calli` 指令使用 `arg1` 通过 `argN`的参数调用方法输入指针。 这些参数的类型由特定的调用约定（`callSiteDesc`）描述。 `calli` 指令前面可以跟 `tail` 前缀（<xref:System.Reflection.Emit.OpCodes.Tailcall>），以指定在传输控制之前应释放当前方法状态。 如果调用会将控制传输到比源方法更高的信任方法，则不会释放堆栈帧;相反，执行将会以静默方式继续，就好像尚未提供 `tail`。  
  
 假定方法输入指针是指向本机代码（目标计算机）的特定指针，该指针可以使用调用约定描述的参数（独立签名的元数据标记）合法调用。 此类指针可使用 <xref:System.Reflection.Emit.OpCodes.Ldftn> 或 <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> 说明创建，或通过本机代码传入。  
  
 不动态检查调用约定，因此，如果目标不实际使用指定的调用约定，则使用 `calli` 指令的代码将无法正常运行。  
  
 自变量以从左到右的顺序放置在堆栈上。 也就是说，第一个参数是计算并放置在堆栈上，然后是第三个参数，然后是第三个参数，直到所有必需的参数按降序排列。 实例或虚方法的参数生成代码序列必须在任何用户可见参数之前推送该实例引用（不得为空引用）。  
  
 如果系统安全不允许调用方访问调用的方法，则可能会引发 <xref:System.Security.SecurityException>。 当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是运行时时，可能会进行安全检查。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> 方法可用于对堆栈执行 `calli` 指令。 请注意，`calli` 应通过以下方法调用，而不是使用 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 类将指令直接放置在堆栈上。  
  
-   使用托管调用约定 <xref:System.Reflection.Emit.ILGenerator.EmitCalli%28System.Reflection.Emit.OpCode%2CSystem.Reflection.CallingConventions%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType> 调用。  
  
-   使用非托管调用约定 <xref:System.Reflection.Emit.ILGenerator.EmitCalli%28System.Reflection.Emit.OpCode%2CSystem.Runtime.InteropServices.CallingConvention%2CSystem.Type%2CSystem.Type%5B%5D%29?displayProperty=nameWithType> 调用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>对对象调用后期绑定方法，并且将返回值推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|6F < `T` >|callvirt `method`|调用与 `obj`相关联的特定方法。|  
  
 堆栈转换行为顺序如下：  
  
1.  对象引用 `obj` 被推送到堆栈上。  
  
2.  通过 `argN` `arg1` 的方法参数被推送到堆栈上。  
  
3.  通过 `argN` `arg1` 方法参数，并从堆栈中弹出对象引用 `obj`;使用这些参数执行方法调用，并将控件传输到方法元数据标记所引用 `obj` 中的方法。 完成后，调用方方法将生成一个返回值，并将其发送给调用方。  
  
4.  将返回值推送到堆栈上。  
  
 `callvirt` 指令对对象调用后期绑定方法。 也就是说，将根据 `obj` 的运行时类型而不是方法指针中的编译时类选择方法。 `Callvirt` 可用于调用虚拟方法和实例方法。 `callvirt` 指令前面可能紧跟 `tail` （<xref:System.Reflection.Emit.OpCodes.Tailcall>）前缀，以指定在传输控制之前应释放当前堆栈帧。 如果调用会将控制传输到比原始方法更高的信任方法，则不会释放堆栈帧。  
  
 方法元数据标记提供要调用的方法的名称、类和签名。 与 `obj` 关联的类是它作为其实例的类。 如果类定义了与指定方法名称和签名匹配的非静态方法，则会调用此方法。 否则，会按顺序检查此类的基类链中的所有类。 如果未找到任何方法，则是错误的。  
  
 `Callvirt` 在调用方法之前，将对象和关联参数从计算堆栈中弹出。 如果该方法具有返回值，则在方法完成后将其推送到堆栈上。 在被调用方方，`obj` 参数作为参数0进行访问，`arg1` 为参数1，依此类推。  
  
 自变量以从左到右的顺序放置在堆栈上。 也就是说，第一个参数是计算并放置在堆栈上，然后是第三个参数，然后是第三个参数，直到所有必需的参数按降序排列。 实例引用 `obj` （始终需要用于 `callvirt`）必须在任何用户可见参数之前推送。 签名（包含在元数据标记中）不需要包含在此指针的参数列表中的条目。  
  
 请注意，还可以使用 <xref:System.Reflection.Emit.OpCodes.Call> 指令调用虚拟方法。  
  
 如果在与 `obj` 或其任何基类关联的类中找不到具有指定名称和签名的非静态方法，则会引发 <xref:System.MissingMethodException>。 当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是运行时，通常会检测到此情况。  
  
 如果 obj 为 null，则会引发 <xref:System.NullReferenceException>。  
  
 如果系统安全不向调用方授予对所调用方法的访问权限，则会引发 <xref:System.Security.SecurityException>。 当 CIL 转换为本机代码而不是运行时，可能会进行安全检查。  
  
> [!NOTE]
>  当在值类型上调用 System.object 的方法时，请考虑将 `constrained` 前缀与 `callvirt` 指令一起使用。 这就不必发出不同的 IL，具体取决于值类型是否重写方法，避免出现潜在的版本控制问题。 当对值类型调用接口方法时，请考虑使用 `constrained` 前缀，因为实现接口方法的值类型方法可以使用 `MethodImpl`进行更改。 <xref:System.Reflection.Emit.OpCodes.Constrained> opcode 中更详细地介绍了这些问题。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `callvirt` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.EmitCall%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%2CSystem.Type%5B%5D%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>尝试将引用传递的对象转换为指定的类。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|74 < `T` >|castclass `class`|将对象强制转换为类型 `class`的新对象。|  
  
 堆栈转换行为顺序如下：  
  
1.  对象引用被推送到堆栈上。  
  
2.  从堆栈中弹出对象引用;被引用对象被强制转换为指定的 `class`。  
  
3.  如果成功，则将新的对象引用推送到堆栈上。  
  
 `castclass` 指令尝试将堆栈顶部的对象引用（类型 `O`）强制转换为指定的类。 新类由指示所需类的元数据标记指定。 如果堆栈顶部对象的类未实现新类（假定新类为接口），并且不是新类的派生类，则会引发 <xref:System.InvalidCastException>。 如果对象引用为空引用，则 `castclass` 成功，并返回新的对象作为空引用。  
  
 如果无法将 obj 强制转换为类，则会引发 <xref:System.InvalidCastException>。  
  
 如果找不到类，则会引发 <xref:System.TypeLoadException>。 当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是运行时，通常会检测到此情况。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `castclass` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比较两个值。 如果这两个值相等，则将整数值 1 <see langword="(int32" />) 推送到计算堆栈上；否则，将 0 (<see langword="int32" />) 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 01|ceq|如果 `value1` 等于 `value2`，则推送 1;else 将0推送。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;将 `value1` 与 `value2`进行比较。  
  
4.  如果 `value1` 等于 `value2`，则将1推送到堆栈上;否则，将0推送到堆栈上。  
  
 `ceq` 指令比较 `value1` 和 `value2`。 如果 `value1` 等于 `value2`，则将1（类型 `int32`）推送到堆栈上。 否则，将0（类型 `int32`）推送到堆栈上。  
  
 对于浮点数，如果数字未排序（或两者均为 NaN），`ceq` 将返回0。 无限值等于自身。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ceq` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比较两个值。 如果第一个值大于第二个值，则将整数值 1 <see langword="(int32" />) 推送到计算堆栈上；反之，将 0 (<see langword="int32" />) 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 02|cgt|如果 `value1` 大于 `value2`，则推送 1;else 将0推送。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 大于 `value2`，则测试 `cgt`。  
  
4.  如果 `value1` 大于 `value2`，则将1推送到堆栈上;否则，将0推送到堆栈上。  
  
 `cgt` 指令比较 `value1` 和 `value2`。 如果 `value1` 严格大于 `value2`，则将 `int32` 值1推送到堆栈上。 否则，在堆栈上推送 `int32` 值0。  
  
-   对于浮点数，如果数字未排序（也就是说，如果一个参数或两个参数均为 NaN），`cgt` 将返回0。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `cgt` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比较两个无符号的或未经排序的值。 如果第一个值大于第二个值，则将整数值 1 <see langword="(int32" />) 推送到计算堆栈上；反之，将 0 (<see langword="int32" />) 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 03|cgt.un|如果 `value1` 大于 `value2`，则推送 1;else 将0（无符号值）推送。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 大于 `value2`，则测试 `cgt.un`。  
  
4.  如果 `value1` 大于 `value2`，则将1推送到堆栈上;否则，将0推送到堆栈上。  
  
 如果 `true` 以下任意一项，则将 `int32` 值1推送到堆栈上：  
  
 对于浮点数，`value1` 不按 `value2`排序。  
  
 对于整数值，当被视为无符号数字时，`value1` 严格大于 `value2`。  
  
 否则，在堆栈上推送 `int32` 值0。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `cgt.un` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果值不是有限数，则引发 <see cref="T:System.ArithmeticException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|C3|ckfinite|如果值不是有限数，则引发 <xref:System.ArithmeticException>。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。 
  
2.  `value` 从堆栈中弹出，并对其执行 `ckfinite` 指令。  
  
3.  如果未引发异常，则将 `value` 推送回堆栈。  
  
 如果 `value` （浮点数）为 "不是数字" 值（NaN）或 `+-` 无穷值，则 `ckfinite instruction` 引发 <xref:System.ArithmeticException>。 如果未引发异常，`Ckfinite` 将值保留在堆栈上。 如果 `value` 不是浮点数，则不指定执行。  
  
 如果 `value` 不是 "normal" 数字，则会引发 <xref:System.ArithmeticException>。  
  
 请注意，特殊的异常或派生类 <xref:System.ArithmeticException> 可能更合适，将错误值传递到异常处理程序。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ckfinite` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比较两个值。 如果第一个值小于第二个值，则将整数值 1 <see langword="(int32" />) 推送到计算堆栈上；反之，将 0 (<see langword="int32" />) 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 04|clt|如果 `value1` 小于 `value2`，则推送 1;else 将0推送。|  
  
 堆栈转换行为顺序如下： 

1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 小于 `value2`，则 `clt` 测试。  
  
4.  如果 `value1` 小于 `value2`，则将1推送到堆栈上;否则，将0推送到堆栈上。  
  
 `clt` 指令比较 `value1` 和 `value2`。 如果 `value1` 严格小于 `value2`，则将 `int32` 值1推送到堆栈上。 否则，在堆栈上推送 `int32` 值0。  
  
-   对于浮点数，如果数字未排序（也就是说，如果一个参数或两个参数均为 NaN），`clt` 将返回0。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `clt` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比较无符号的或不可排序的值 <paramref name="value1" /> 和 <paramref name="value2" />。 如果 <paramref name="value1" /> 小于 <paramref name="value2" />，则将整数值 1 <see langword="(int32" /> ) 推送到计算堆栈上；反之，将 0 ( <see langword="int32" /> ) 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 05|clt.un|如果 `value1` 小于 `value2`，则推送 1;else 将0（无符号值）推送。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 小于 `value2`，则 `clt.un` 测试。  
  
4.  如果 `value1` 小于 `value2`，则将1推送到堆栈上;否则，将0推送到堆栈上。  
  
 `clt.un` 指令比较 `value1` 和 `value2`。 如果满足以下任一条件，则将 `int32` 值1推送到堆栈上：  
  
-   `value1` 严格低于 `value2` （`clt`）。  
  
-   对于浮点数，`value1` 不按 `value2`排序。  
  
-   对于整数值，当被视为无符号数字时，`value1` 严格小于 `value2`。  
  
 否则，在堆栈上推送 `int32` 值0。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `clt.un` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>约束要对其进行虚方法调用的类型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 16 < `T` >|有限. `thisType`|对被约束为类型 `T`的类型调用虚拟方法。|  
  
 仅对 `callvirt` 指令允许 `constrained` 前缀。  
  
 此时 MSIL 堆栈的状态必须如下所示：  
  
1.  托管指针 `ptr`被推送到堆栈上。 `ptr` 的类型必须是 `thisType`的托管指针（`&`）。 请注意，这与没有前缀 `callvirt` 指令的情况不同，后者需要 `thisType`的引用。  
  
2.  `arg1` 通过 `argN` 将方法参数推送到堆栈上，就像没有前缀的 `callvirt` 指令一样。  
  
 `constrained` 前缀旨在允许 `callvirt` 指令以统一的方式进行，而不管 `thisType` 是值类型还是引用类型。  
  
 如果 `callvirt` `method` 指令以 `constrained` `thisType`为前缀，则按如下方式执行指令：  
  
-   如果 `thisType` 是引用类型（而不是值类型），则 `ptr` 被取消引用并作为 "this" 指针传递到 `method`的 `callvirt`。  
  
-   如果 `thisType` 是值类型，并且 `thisType` 实现 `method` 那么，`ptr` 将作为 "this" 指针传递到 `call` `method` 指令，以 `method` `thisType`的实现实现。  
  
-   如果 `thisType` 是值类型，并且 `thisType` 未实现 `method`，则 `ptr` 是取消引用并装箱，并作为 "this" 指针传递到 `callvirt` `method` 指令。  
  
 仅当在 <xref:System.Object>、<xref:System.ValueType>或 <xref:System.Enum> 上定义 `method`，而不是 `thisType`重写时，才会出现这种情况。 在这种情况下，装箱会导致生成原始对象的副本。 但是，因为没有 <xref:System.Object>、<xref:System.ValueType>和 <xref:System.Enum> 的方法修改对象的状态，所以无法检测到这种情况。  
  
 `constrained` 前缀支持创建泛型代码的 IL 生成器。 通常，`callvirt` 指令对值类型无效。 相反，IL 编译器必须在编译时有效地执行上述 "this" 转换，具体取决于 `ptr` 的类型和所调用的方法。 但是，如果 `ptr` 是在编译时未知的泛型类型，则不能在编译时进行此转换。  
  
 `constrained` opcode 允许 IL 编译器以统一的方式对虚拟函数进行调用，而不管 `ptr` 是值类型还是引用类型。 尽管它适用于 `thisType` 为泛型类型变量的情况，但 `constrained` 前缀还适用于非泛型类型，并且可以降低以隐藏值类型和引用类型之间的区别的语言生成虚拟调用的复杂性。  
  
 使用 `constrained` 前缀还可以避免值类型出现潜在的版本管理问题。 如果未使用 `constrained` 前缀，则必须根据值类型是否覆盖 System.object 的方法来发出不同的 IL。 例如，如果值类型 `V` 重写对象的 ToString （）方法，则会发出 `call` `V.ToString()` 指令;如果没有，则发出 `box` 指令和 `callvirt` `Object.ToString()` 指令。 如果稍后要删除重写，并且在后一种情况下，如果后来添加了替代，则可能会出现版本控制问题。  
  
 `constrained` 前缀还可用于对值类型调用接口方法，因为实现接口方法的值类型方法可以使用 `MethodImpl`进行更改。 如果未使用 `constrained` 前缀，则强制编译器选择要在编译时绑定到的值类型的方法。 使用 `constrained` 前缀允许 MSIL 绑定到在运行时（而不是在编译时）实现接口方法的方法。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `constrained` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="native int" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|D3|约定|转换为 `native int`，将 `native int` 推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.i` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值保留在堆栈的顶部。 小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.i` 或 `conv.u`，在这种情况下，结果也是 `native int`的）。 将浮点值转换为 `F` 类型。  
  
 从浮点数到整数值的转换会将数字截断到零。 从 `float64` 转换到 `float32`时，精度可能会丢失。 如果 `value` 太大而无法容纳在 `float32 (F)`中，则返回正无穷（如果 `value` 为正）或负无穷（如果 `value` 为负数）。 如果在将一个整数类型转换为另一个整数类型时发生溢出，则会截断高序位。 如果结果小于 `int32`，则值将进行符号扩展以填充槽。  
  
 如果发生溢出，将浮点类型转换为整数，则返回的值是未指定的。  
  
 使用此字段时，不会引发异常。 有关在结果类型无法正确表示结果值时将引发异常的等效说明，请参阅 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> 和 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.i` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="int8" />，然后将其扩展（填充）为 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|67|约定 i1|转换为 `int8`，将 `int32` 推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.i1` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值保留在堆栈的顶部。 小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.i` 或 `conv.u`，在这种情况下，结果也是 `native int`的）。 将浮点值转换为 `F` 类型。  
  
 从浮点数到整数值的转换会将数字截断到零。 从 `float64` 转换到 `float32`时，精度可能会丢失。 如果 `value` 太大而无法容纳在 `float32 (F)`中，则返回正无穷（如果 `value` 为正）或负无穷（如果 `value` 为负数）。 如果在将一个整数类型转换为另一个整数类型时发生溢出，则会截断高序位。 如果结果小于 `int32`，则值将进行符号扩展以填充槽。  
  
 如果发生溢出，将浮点类型转换为整数，则返回的值是未指定的。  
  
 使用此字段时，不会引发异常。 有关在结果类型无法正确表示结果值时将引发异常的等效说明，请参阅 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> 和 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.i1` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="int16" />，然后将其扩展（填充）为 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|68|约定|转换为 `int16`，将 `int32` 推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.i2` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值保留在堆栈的顶部。 小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.i` 或 `conv.u`，在这种情况下，结果也是 `native int`的）。 将浮点值转换为 `F` 类型。  
  
 从浮点数到整数值的转换会将数字截断到零。 从 `float64` 转换到 `float32`时，精度可能会丢失。 如果 `value` 太大而无法容纳在 `float32 (F)`中，则返回正无穷（如果 `value` 为正）或负无穷（如果 `value` 为负数）。 如果在将一个整数类型转换为另一个整数类型时发生溢出，则会截断高序位。 如果结果小于 `int32`，则值将进行符号扩展以填充槽。  
  
 如果发生溢出，将浮点类型转换为整数，则返回的值是未指定的。  
  
 使用此字段时，不会引发异常。 有关在结果类型无法正确表示结果值时将引发异常的等效说明，请参阅 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> 和 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.i2` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|69|i4|转换为 `int32`，将 `int32` 推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.i4` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值保留在堆栈的顶部。 小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.i` 或 `conv.u`，在这种情况下，结果也是 `native int`的）。 将浮点值转换为 `F` 类型。  
  
 从浮点数到整数值的转换会将数字截断到零。 从 `float64` 转换到 `float32`时，精度可能会丢失。 如果 `value` 太大而无法容纳在 `float32 (F)`中，则返回正无穷（如果 `value` 为正）或负无穷（如果 `value` 为负数）。 如果在将一个整数类型转换为另一个整数类型时发生溢出，则会截断高序位。 如果结果小于 `int32`，则值将进行符号扩展以填充槽。  
  
 如果发生溢出，将浮点类型转换为整数，则返回的值是未指定的。  
  
 使用此字段时，不会引发异常。 有关在结果类型无法正确表示结果值时将引发异常的等效说明，请参阅 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> 和 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.i4` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="int64" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|6A|i8|转换为 `int64`，将 `int64` 推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.i8` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值保留在堆栈的顶部。 小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.i` 或 `conv.u`，在这种情况下，结果也是 `native int`的）。 将浮点值转换为 `F` 类型。  
  
 从浮点数到整数值的转换会将数字截断到零。 从 `float64` 转换到 `float32`时，精度可能会丢失。 如果 `value` 太大而无法容纳在 `float32 (F)`中，则返回正无穷（如果 `value` 为正）或负无穷（如果 `value` 为负数）。 如果在将一个整数类型转换为另一个整数类型时发生溢出，则会截断高序位。 如果结果小于 `int32`，则值将进行符号扩展以填充槽。  
  
 如果发生溢出，将浮点类型转换为整数，则返回的值是未指定的。  
  
 使用此字段时，不会引发异常。 有关在结果类型无法正确表示结果值时将引发异常的等效说明，请参阅 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> 和 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.i8` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为有符号 <see langword="native int" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|D4|ovf。 i|转换为 `native int` （在堆栈上为 `native int`）并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。 如果发生溢出，则会引发异常。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.ovf.i` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。 如果值太大或太小而无法由目标类型表示，则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。  
  
 如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.i` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为有符号 <see langword="native int" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|8A|将 ovf|将无符号值转换为 `native int` （在堆栈上为 `native int`）并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。 如果发生溢出，则会引发异常。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.ovf.i.un` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。 如果值太大或太小而无法由目标类型表示，则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。  
  
 如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.i.un` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为有符号的 <see langword="int8" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|B3|conv.ovf.i1|转换为 `int8` （在堆栈上为 `int32`）并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。 如果发生溢出，则会引发异常。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.ovf.i1` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。 如果值太大或太小而无法由目标类型表示，则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。  
  
 如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.i1` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为有符号 <see langword="int8" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|82|conv.ovf.i1.un|将无符号值转换为 `int8` （在堆栈上为 `int32`）并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。 如果发生溢出，则会引发异常。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.ovf.i1.un` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。 如果值太大或太小而无法由目标类型表示，则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。  
  
 如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.i1.un` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为有符号 <see langword="int16" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|B5|conv.ovf.i2|转换为 `int16` （在堆栈上为 `int32`）并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。 如果发生溢出，则会引发异常。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.ovf.i2` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。 如果值太大或太小而无法由目标类型表示，则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。  
  
 如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.i2` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为有符号 <see langword="int16" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|83|conv.ovf.i2.un|将无符号值转换为 `int16` （在堆栈上为 `int32`）并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。 如果发生溢出，则会引发异常。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.ovf.i2.un` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。 如果值太大或太小而无法由目标类型表示，则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。  
  
 如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.i2.un` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为有符号 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|B7|conv.ovf.i4|转换为 `int32` （在堆栈上为 `int32`）并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。 如果发生溢出，则会引发异常。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.ovf.i4` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。 如果值太大或太小而无法由目标类型表示，则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。  
  
 如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.i4` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为有符号 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|84|conv.ovf.i4.un|将无符号值转换为 `int32` （在堆栈上为 `int32`）并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。 如果发生溢出，则会引发异常。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.ovf.i4.un` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。 如果值太大或太小而无法由目标类型表示，则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。  
  
 如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.i4.un` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为有符号 <see langword="int64" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|B9|conv.ovf.i8|转换为 `int64` （在堆栈上为 `int64`）并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。 如果发生溢出，则会引发异常。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.ovf.i8` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。 如果值太大或太小而无法由目标类型表示，则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。  
  
 如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.i8` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为有符号 <see langword="int64" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|85|conv.ovf.i8.un|将无符号值转换为 `int64` （在堆栈上为 `int64`）并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。 如果发生溢出，则会引发异常。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.ovf.i8.un` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。 如果值太大或太小而无法由目标类型表示，则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。  
  
 如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.i8.un` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为 <see langword="unsigned native int" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|D5|conv.ovf.u|转换为 `unsigned native int` （在堆栈上为 `native int`）并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。 如果发生溢出，则会引发异常。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.ovf.u` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。 如果值太大或太小而无法由目标类型表示，则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。  
  
 如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.u` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为 <see langword="unsigned native int" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|8B|conv.ovf.u.un|将无符号值转换为 `unsigned native int` （在堆栈上为 `native int`），并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。 如果发生溢出，则会引发异常。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.ovf.u.un` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。 如果值太大或太小而无法由目标类型表示，则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。  
  
 如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.uvf.u.un` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为 <see langword="unsigned int8" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|B4|conv.ovf.u1|转换为 `unsigned int8` （在堆栈上为 `int32`）并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。 如果发生溢出，则会引发异常。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.ovf.u1` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。 如果值太大或太小而无法由目标类型表示，则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。  
  
 如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.u1` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为 <see langword="unsigned int8" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|86|conv.ovf.u1.un|将无符号值转换为 `unsigned int8` （在堆栈上为 `int32`）并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。 如果发生溢出，则会引发异常。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.ovf.u1.un` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。 如果值太大或太小而无法由目标类型表示，则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。  
  
 如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.u1.un` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为 <see langword="unsigned int16" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|B6|conv.ovf.u2|转换为 `unsigned int16` （在堆栈上为 `int32`）并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。 如果发生溢出，则会引发异常。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.ovf.u2` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。 如果值太大或太小而无法由目标类型表示，则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。  
  
 如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.u2` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为 <see langword="unsigned int16" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|87|conv.ovf.u2.un|将无符号值转换为 `unsigned int16` （在堆栈上为 `int32`）并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。 如果发生溢出，则会引发异常。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.ovf.u2.un` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。 如果值太大或太小而无法由目标类型表示，则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。  
  
 如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.u2.un` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为 <see langword="unsigned int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|B8|conv.ovf.u4|转换为 `unsigned int32` （在堆栈上为 `int32`）并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。 如果发生溢出，则会引发异常。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.ovf.u4` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。 如果值太大或太小而无法由目标类型表示，则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。  
  
 如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.u4` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为 <see langword="unsigned int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|88|conv.ovf.u4.un|将无符号值转换为 `unsigned int32` （在堆栈上为 `int32`）并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。 如果发生溢出，则会引发异常。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.ovf.u4.un` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。 如果值太大或太小而无法由目标类型表示，则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。  
  
 如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.u4.un` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为 <see langword="unsigned int64" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|BA|conv.ovf.u8|转换为 `unsigned int64` （在堆栈上为 `int64`）并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。 如果发生溢出，则会引发异常。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.ovf.u8` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。 如果值太大或太小而无法由目标类型表示，则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。  
  
 如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.u8` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为 <see langword="unsigned int64" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|89|conv.ovf.u8.un|将无符号值转换为 `unsigned int64` （在堆栈上为 `int64`）并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。 如果发生溢出，则会引发异常。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.ovf.u8.un` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。 如果值太大或太小而无法由目标类型表示，则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。  
  
 如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.u8.un` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号整数值转换为 <see langword="float32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|76|约定|将无符号整数转换为浮点，并将 `F` 推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.r.un` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值保留在堆栈的顶部。 小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.i` 或 `conv.u`，在这种情况下，结果也是 `native int`的）。 将浮点值转换为 `F` 类型。  
  
 从浮点数到整数值的转换会将数字截断到零。 从 `float64` 转换到 `float32`时，精度可能会丢失。 如果 `value` 太大而无法容纳在 `float32 (F)`中，则返回正无穷（如果 `value` 为正）或负无穷（如果 `value` 为负数）。 如果在将一个整数类型转换为另一个整数类型时发生溢出，则会截断高序位。 如果结果小于 `int32`，则值将进行符号扩展以填充槽。  
  
 如果在将浮点类型转换为整数时出现溢出，则不指定返回的 `result`。 `conv.r.un` 操作从堆栈中提取一个整数，将其解释为无符号的整数，并将其替换为浮点数以表示整数：无论是 `float32`，只要这种宽度足以表示整数而不丢失精度，或者 `float64`。  
  
 使用此字段时，不会引发异常。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.r.un` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="float32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|6B|conv.r4|转换为 `float32`，将 `F` 推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.r4` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值保留在堆栈的顶部。 小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.i` 或 `conv.u`，在这种情况下，结果也是 `native int`的）。 将浮点值转换为 `F` 类型。  
  
 从浮点数到整数值的转换会将数字截断到零。 从 `float64` 转换到 `float32`时，精度可能会丢失。 如果 `value` 太大而无法容纳在 `float32 (F)`中，则返回正无穷（如果 `value` 为正）或负无穷（如果 `value` 为负数）。 如果在将一个整数类型转换为另一个整数类型时发生溢出，则会截断高序位。 如果结果小于 `int32`，则值将进行符号扩展以填充槽。  
  
 如果发生溢出，将浮点类型转换为整数，则返回的值是未指定的。  
  
 使用此字段时，不会引发异常。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.r4` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="float64" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|6C|conv.r8|转换为 `float64`，将 `F` 推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.r8` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值保留在堆栈的顶部。 小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.i` 或 `conv.u`，在这种情况下，结果也是 `native int`的）。 将浮点值转换为 `F` 类型。  
  
 从浮点数到整数值的转换会将数字截断到零。 从 `float64` 转换到 `float32`时，精度可能会丢失。 如果 `value` 太大而无法容纳在 `float32 (F)`中，则返回正无穷（如果 `value` 为正）或负无穷（如果 `value` 为负数）。 如果在将一个整数类型转换为另一个整数类型时发生溢出，则会截断高序位。 如果结果小于 `int32`，则值将进行符号扩展以填充槽。  
  
 如果发生溢出，将浮点类型转换为整数，则返回的值是未指定的。  
  
 使用此字段时，不会引发异常。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.r8` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="unsigned native int" />，然后将其扩展为 <see langword="native int" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|E0|约定|转换为 `unsigned native int`，将 `native int` 推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.u` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值保留在堆栈的顶部。 小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.i` 或 `conv.u`，在这种情况下，结果也是 `native int`的）。 将浮点值转换为 `F` 类型。  
  
 从浮点数到整数值的转换会将数字截断到零。 从 `float64` 转换到 `float32`时，精度可能会丢失。 如果 `value` 太大而无法容纳在 `float32 (F)`中，则返回正无穷（如果 `value` 为正）或负无穷（如果 `value` 为负数）。 如果在将一个整数类型转换为另一个整数类型时发生溢出，则会截断高序位。 如果结果小于 `int32`，则值将进行符号扩展以填充槽。  
  
 如果发生溢出，将浮点类型转换为整数，则返回的值是未指定的。  
  
 使用此字段时，不会引发异常。 有关在结果类型无法正确表示结果值时将引发异常的等效说明，请参阅 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> 和 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.u` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="unsigned int8" />，然后将其扩展为 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|D2|约定|转换为 `int8`，将 `int32` 推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.u1` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值保留在堆栈的顶部。 小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.i` 或 `conv.u`，在这种情况下，结果也是 `native int`的）。 将浮点值转换为 `F` 类型。  
  
 从浮点数到整数值的转换会将数字截断到零。 从 `float64` 转换到 `float32`时，精度可能会丢失。 如果 `value` 太大而无法容纳在 `float32 (F)`中，则返回正无穷（如果 `value` 为正）或负无穷（如果 `value` 为负数）。 如果在将一个整数类型转换为另一个整数类型时发生溢出，则会截断高序位。 如果结果小于 `int32`，则值将进行符号扩展以填充槽。  
  
 如果发生溢出，将浮点类型转换为整数，则返回的值是未指定的。  
  
 使用此字段时，不会引发异常。 有关在结果类型无法正确表示结果值时将引发异常的等效说明，请参阅 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> 和 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.u1` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="unsigned int16" />，然后将其扩展为 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|D1|约定|转换为 `int16`，将 `int32` 推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.u2` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值保留在堆栈的顶部。 小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.i` 或 `conv.u`，在这种情况下，结果也是 `native int`的）。 将浮点值转换为 `F` 类型。  
  
 从浮点数到整数值的转换会将数字截断到零。 从 `float64` 转换到 `float32`时，精度可能会丢失。 如果 `value` 太大而无法容纳在 `float32 (F)`中，则返回正无穷（如果 `value` 为正）或负无穷（如果 `value` 为负数）。 如果在将一个整数类型转换为另一个整数类型时发生溢出，则会截断高序位。 如果结果小于 `int32`，则值将进行符号扩展以填充槽。  
  
 如果发生溢出，将浮点类型转换为整数，则返回的值是未指定的。  
  
 使用此字段时，不会引发异常。 有关在结果类型无法正确表示结果值时将引发异常的等效说明，请参阅 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> 和 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.u2` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="unsigned int32" />，然后将其扩展为 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|6D|u4|转换为 `unsigned int32`，将 `int32` 推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.u4` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值保留在堆栈的顶部。 小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.i` 或 `conv.u`，在这种情况下，结果也是 `native int`的）。 将浮点值转换为 `F` 类型。  
  
 从浮点数到整数值的转换会将数字截断到零。 从 `float64` 转换到 `float32`时，精度可能会丢失。 如果 `value` 太大而无法容纳在 `float32 (F)`中，则返回正无穷（如果 `value` 为正）或负无穷（如果 `value` 为负数）。 如果在将一个整数类型转换为另一个整数类型时发生溢出，则会截断高序位。 如果结果小于 `int32`，则值将进行符号扩展以填充槽。  
  
 如果发生溢出，将浮点类型转换为整数，则返回的值是未指定的。  
  
 使用此字段时，不会引发异常。 有关在结果类型无法正确表示结果值时将引发异常的等效说明，请参阅 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> 和 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.u4` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="unsigned int64" />，然后将其扩展为 <see langword="int64" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|6E|u8|转换为 `int64`，将 `int64` 推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并尝试执行转换操作。  
  
3.  如果转换成功，则将结果值推送到堆栈上。  
  
 `conv.u8` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值保留在堆栈的顶部。 小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.i` 或 `conv.u`，在这种情况下，结果也是 `native int`的）。 将浮点值转换为 `F` 类型。  
  
 从浮点数到整数值的转换会将数字截断到零。 从 `float64` 转换到 `float32`时，精度可能会丢失。 如果 `value` 太大而无法容纳在 `float32 (F)`中，则返回正无穷（如果 `value` 为正）或负无穷（如果 `value` 为负数）。 如果在将一个整数类型转换为另一个整数类型时发生溢出，则会截断高序位。 如果结果小于 `int32`，则值将进行符号扩展以填充槽。  
  
 如果发生溢出，将浮点类型转换为整数，则返回的值是未指定的。  
  
 使用此字段时，不会引发异常。 有关在结果类型无法正确表示结果值时将引发异常的等效说明，请参阅 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> 和 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.u8` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将指定数目的字节从源地址复制到目标地址。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 17|cpblk|将数据从一个内存块复制到另一个内存块。|  
  
 堆栈转换行为顺序如下：  
  
1.  目标地址被推送到堆栈上。  
  
2.  源地址被推送到堆栈上。  
  
3.  要复制的字节数将被推送到堆栈上。  
  
4.  从堆栈中弹出的字节数、源地址和目标地址;指定的字节数从源地址复制到目标地址。  
  
 `cpblk` 指令将字节数（类型 `unsigned int32`）从源地址（类型为 `*`、`native int`或 `&`）复制到目标地址（类型为 `*`、`native int`或 `&`）。 如果源区域和目标区域重叠，则未指定 `cpblk` 的行为。  
  
 `cpblk` 假设源和目标均与计算机的自然大小对齐。 `cpblk` 指令前面可以紧跟 `unaligned.<prefix>` 指令，以指示源或目标是不对齐的。  
  
 `cpblk` 指令的操作可以通过紧挨着 <xref:System.Reflection.Emit.OpCodes.Volatile> 或 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀指令来更改。  
  
 如果检测到无效地址，则可能会引发 <xref:System.NullReferenceException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `cpblk` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于对象（<see langword="&amp;" />、<see langword="*" /> 或 <see langword="native int" /> 类型）地址的值类型复制到目标对象（<see langword="&amp;" />、<see langword="*" /> 或 <see langword="native int" /> 类型）的地址。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|70 < `T` >|cpobj `classTok`|将值类型从源对象复制到目标对象。|  
  
 堆栈转换行为顺序如下：  
  
1.  目标对象引用被推送到堆栈上。  
  
2.  源对象引用被推送到堆栈上。  
  
3.  从堆栈中弹出两个对象引用;将源对象地址的值类型复制到目标对象的地址。  
  
 如果源对象和目标对象引用不是指向类标记所表示的类的实例的指针 `classTok` （`typeref` 或 `typedef`），或者如果 `classTok` 不表示值类型，则未指定 `cpobj` 的行为。  
  
 如果检测到无效地址，则可能会引发 <xref:System.NullReferenceException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `cpobj` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个值相除并将结果作为浮点（<see langword="F" /> 类型）或商（<see langword="int32" /> 类型）推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|5B|div|将两个值相除以返回商或浮点结果。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;`value1` 除以 `value2`。  
  
4.  将结果推送到堆栈上。  
  
 `value1` div value2 `result` = 满足以下条件：  
  
 &#124;`result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;，以及：  
  
 sign （`result`） = +，if sign （`value1`） = sign （`value2`）或-，if sign （`value1`） ~ = sign （`value2`）  
  
 `div` 指令计算结果并将结果推送到堆栈上。  
  
 整数除法向零截断。  
  
 有限数除以零会生成正确的无符号无限值。  
  
 零除以零或无穷大按无穷产生 NaN （非数字）值。 除以无限大的任何数字都会产生零值。  
  
 如果结果不能用结果类型表示，则整型运算将引发 <xref:System.ArithmeticException>。 如果 `value1` 是最大负值，并且 `value2` 为-1，则可能会发生这种情况。  
  
 如果 `value2` 为零，则整型运算引发 <xref:System.DivideByZeroException>。  
  
 请注意，在基于 Intel 的平台上，计算时将引发 <xref:System.OverflowException> （minint div-1）。 浮点运算永远不会引发异常（而是生成 Nan 或无穷大）。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `div` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>两个无符号整数值相除并将结果 ( <see langword="int32" /> ) 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|5C|div. un|将两个值相除，并返回商。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;`value1` 除以 `value2`。  
  
4.  将结果推送到堆栈上。  
  
 `div.un` 指令计算 `value1` 除以 `value2`，并将其作为无符号整数进行计算，并将 `result` 推送到堆栈上。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `div.un` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>复制计算堆栈上当前最顶端的值，然后将副本推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|25|dup|复制堆栈顶部的值。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value` 以进行复制。  
  
3.  `value` 被推送回堆栈上。  
  
4.  将重复的值推送到堆栈上。  
  
 `dup` 指令复制堆栈的顶部元素，并将两个相同的值留在其顶部。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `dup` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将控制从异常的 <see langword="filter" /> 子句转移回公共语言结构 (CLI) 异常处理程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 11|执行 endfilter|SEH 异常处理的结束筛选器子句。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`;执行 `endfilter`，并将控制传输到异常处理程序。  
  
 从 filter 子句返回 `Value` （必须是 `int32` 类型，并且是一组特定的值）。 它应该是以下其中之一：  
  
-   `exception_continue_search` （`value` = 0）以继续搜索异常处理程序  
  
-   `exception_execute_handler` （`value` = 1）以启动异常处理的第二个阶段，其中 finally 块将一直运行，直到找到与此筛选器子句关联的处理程序。 发现后，将执行处理程序。  
  
 其他整数值将产生未指定的结果。  
  
 筛选器的入口点（如方法的异常表中所示）必须是筛选器的代码块中的第一个指令。 `endfilter` 指令必须是筛选器的代码块中的最后一个指令（因此任何单个筛选器块只能有一个 `endfilter`）。 执行 `endfilter` 指令后，控件将以逻辑方式流回 CLI 异常处理机制。  
  
 不能将控件传输到筛选器块中，除非通过异常机制。 除了通过使用 `throw` 指令或通过执行最终 `endfilter` 指令以外，无法将控制转移出筛选器块。 不能将 `try` 块嵌入 `filter` 块中。 如果在 `filter` 块内引发异常，则将截获该异常，并返回值0（`exception_continue_search`）。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `endfilter` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将控制从异常块的 <see langword="fault" /> 或 <see langword="finally" /> 子句转移回公共语言结构 (CLI) 异常处理程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|DC|执行 endfinally<br /><br /> endfault|结束异常块的 `finally` 或 `fault` 子句。|  
  
 此指令没有堆栈转换行为。  
  
 `Endfinally` 和 `endfault` 信号结束 `finally` 或 `fault` 子句的末尾，以便堆栈展开可以继续，直到调用异常处理程序。 `endfinally` 或 `endfault` 指令将控制转移回 CLI 异常机制。 然后，当受保护的块退出并带有 leave 指令时，该机制会搜索链中的下一个 `finally` 子句。 如果被保护的块退出但出现异常，CLI 将搜索下一 `finally` 或 `fault`，或者输入在第一次处理异常过程中选择的异常处理程序。  
  
 `endfinally` 指令可能仅在 `finally` 块中以词法上出现。 与 `endfilter` 指令不同，块以 `endfinally` 指令结束，并且在所需的块中可能有尽可能多的 `endfinally` 指令。 这些相同的限制适用于 `endfault` 指令和 `fault` 块。  
  
 不能将控件传输到 `finally` （或 `fault`）块中，除非通过异常机制。 除了通过使用 `throw` 指令或执行 `endfinally` （或 `endfault`）指令以外，不能从 `finally` （或 `fault`）块中传出控制。 特别是，不能 "`finally` （或 `fault`）块的" 跳出 "或在 `finally` （或 `fault`）块中执行 <xref:System.Reflection.Emit.OpCodes.Ret> 或 <xref:System.Reflection.Emit.OpCodes.Leave> 指令。  
  
 请注意，`endfault` 和 `endfinally` 说明是别名，它们对应于相同的操作码。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `endfinally` （`endfault`）操作码，并 <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>的 `ILGenerator` 方法。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于特定地址的内存的指定块初始化为给定大小和初始值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 18|initblk|将内存块中的每个位置设置为给定值。|  
  
 堆栈转换行为顺序如下：  
  
1.  起始地址被推送到堆栈上。  
  
2.  将初始化值推送到堆栈上。  
  
3.  要初始化的字节数将被推送到堆栈上。  
  
4.  从堆栈中弹出字节数、初始化值和起始地址，并按它们的值执行初始化。  
  
 `initblk` 指令将从指定的地址（类型为 `native int`、`&`或 `*`）开始的字节数（`unsigned int32`）设置为初始化值（类型为 `unsigned int8`）。 `initblk` 假设起始地址与计算机的自然大小对齐。  
  
 `initblk` 指令的操作可以通过紧挨着 <xref:System.Reflection.Emit.OpCodes.Volatile> 或 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀指令来更改。  
  
 如果检测到无效地址，则可能会引发 <xref:System.NullReferenceException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `initblk` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定地址的值类型的每个字段初始化为空引用或适当的基元类型的 0。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 15 < `T` >|`initobj` `typeTok`|初始化值类型。|  
  
 堆栈转换行为顺序如下：  
  
1.  要初始化的值类型的地址被推送到堆栈上。  
  
2.  从堆栈中弹出该地址;指定地址处的值类型初始化为 `typeTok`类型。  
  
 `initobj` 指令将推送地址（类型为 `native int`、`&`或 `*`）指定的值类型的每个字段初始化为空引用或适当的基元类型的0。 调用此方法后，该实例已准备好调用构造函数方法。 如果 `typeTok` 是引用类型，则此指令与 `ldnull` 后跟 `stind.ref`相同。  
  
 与 <xref:System.Reflection.Emit.OpCodes.Newobj>不同，`initobj` 不调用构造函数方法。 `Initobj` 用于初始化值类型，而 `newobj` 用于分配和初始化对象。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `initobj` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>测试对象引用（<see langword="O" /> 类型）是否为特定类的实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|75 < `T` >|isinst `class`|测试对象引用是否为 `class`的实例，同时返回空引用或该类或接口的实例。|  
  
 堆栈转换行为顺序如下：  
  
1.  对象引用被推送到堆栈上。  
  
2.  从堆栈中弹出对象引用并对其进行测试，以查看它是否是 `class`中传递的类的实例。  
  
3.  结果（对象引用或空引用）被推送到堆栈上。  
  
 `Class` 是指明所需类的元数据标记。 如果堆栈顶部对象的类实现 `class` （如果 `class` 为接口），或者是 `class` 的派生类（如果 `class` 是一个常规类），则会将其强制转换为类型 `class`，并将结果推送到堆栈上，就像调用 <xref:System.Reflection.Emit.OpCodes.Castclass> 一样。 否则，在堆栈上推送空引用。 如果对象引用本身为空引用，则 `isinst` 同样返回空引用。  
  
 如果找不到类，则会引发 <xref:System.TypeLoadException>。 当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是运行时，通常会检测到此情况。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `isinst` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>退出当前方法并跳至指定方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|27 < `T` >|跳转 `method`|退出当前方法并跳至指定方法。|  
  
 此指令没有堆栈转换行为。  
  
 `jmp` （跳转）指令将控制转移到 `method`指定的方法，该方法是方法引用的元数据标记。 当前参数将传输到目标方法。  
  
 执行此指令时，计算堆栈必须为空。 目标地址的调用约定、数量和参数类型必须与当前方法的参数匹配。  
  
 `jmp` 指令不能用于将控制转移出 `try`、`filter`、`catch`或 `finally` 块。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `jmp` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将自变量（由指定索引值引用）加载到堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 09 < `unsigned int16` >|ldarg `index`|将 `index` 上的参数加载到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  `index` 中的参数值被推送到堆栈上。  
  
 `ldarg` 指令将在 `index`中编制索引的自变量推送到计算堆栈上。 `ldarg` 指令可用于将值类型或基元值从传入参数复制到堆栈上。 参数值的类型与参数的类型相同，后者由当前方法的签名指定。  
  
 对于采用可变长度参数列表的过程，`ldarg` 指令只能用于初始固定参数，而不能用于签名的变量部分的参数（有关详细信息，请参阅 <xref:System.Reflection.Emit.OpCodes.Arglist> 指令）。  
  
 保留小于4个字节的整数值的参数将在加载到堆栈上时展开为类型 `int32`。 浮点值将扩展为其本机大小（类型 `F`）。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldarg` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Int16%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引为 0 的自变量加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|02|ldarg|将参数0加载到堆栈上|  
  
 堆栈转换行为顺序如下：  
  
1.  将索引0处的参数值推送到堆栈上。  
  
 `ldarg.0` 指令是用于在索引0处加载参数值的有效编码。  
  
 `ldarg.0` 指令将索引为0的参数推送到计算堆栈上。 `ldarg.0` 指令可用于将值类型或基元值从传入参数复制到堆栈上。 参数值的类型与参数的类型相同，后者由当前方法的签名指定。  
  
 保留小于4个字节的整数值的参数将在加载到堆栈上时展开为类型 `int32`。 浮点值将扩展为其本机大小（类型 `F`）。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldarg.0` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引为 1 的参数加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|03|ldarg|将参数1加载到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  将索引为1的参数值推送到堆栈上。  
  
 `ldarg.1` 指令是用于在索引1处加载参数值的有效编码。  
  
 `ldarg.1` 指令将索引为1的参数推送到计算堆栈上。 `ldarg.1` 指令可用于将值类型或基元值从传入参数复制到堆栈上。 参数值的类型与参数的类型相同，后者由当前方法的签名指定。  
  
 保留小于4个字节的整数值的参数将在加载到堆栈上时展开为类型 `int32`。 浮点值将扩展为其本机大小（类型 `F`）。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldarg.1` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引为 2 的参数加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|04|ldarg|将参数2加载到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  索引2处的参数值被推送到堆栈上。  
  
 `ldarg.2` 指令是用于在索引2处加载参数值的有效编码。  
  
 `ldarg.2` 指令将索引为2的参数推送到计算堆栈上。 `ldarg.2` 指令可用于将值类型或基元值从传入参数复制到堆栈上。 参数值的类型与参数的类型相同，后者由当前方法的签名指定。  
  
 保留小于4个字节的整数值的参数将在加载到堆栈上时展开为类型 `int32`。 浮点值将扩展为其本机大小（类型 `F`）。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldarg.2` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引为 3 的自变量加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|05|ldarg|将参数3加载到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  将索引为3的参数值推送到堆栈上。  
  
 `ldarg.3` 指令是用于在索引3处加载参数值的有效编码。  
  
 `ldarg.3` 指令将索引为3的参数推送到计算堆栈上。 `ldarg.3` 指令可用于将值类型或基元值从传入参数复制到堆栈上。 参数值的类型与参数的类型相同，后者由当前方法的签名指定。  
  
 保留小于4个字节的整数值的参数将在加载到堆栈上时展开为类型 `int32`。 浮点值将扩展为其本机大小（类型 `F`）。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldarg.3` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将自变量（由指定的短格式索引引用）加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|0E < `unsigned int8` >|ldarg `index`|将 `index` 上的参数加载到堆栈上（短格式）。|  
  
 堆栈转换行为顺序如下：  
  
1.  `index` 中的参数值被推送到堆栈上。  
  
 `ldarg.s` 指令是用于加载从4到255的索引参数的有效编码。  
  
 `ldarg.s` 指令将在 `index`中编制索引的自变量推送到计算堆栈上。 `ldarg.s` 指令可用于将值类型或基元值从传入参数复制到堆栈上。 参数值的类型与参数的类型相同，后者由当前方法的签名指定。  
  
 对于采用可变长度参数列表的过程，`ldarg.s` 指令只能用于初始固定参数，而不能用于签名的变量部分的参数（有关详细信息，请参阅 <xref:System.Reflection.Emit.OpCodes.Arglist> 指令）。  
  
 保留小于4个字节的整数值的参数将在加载到堆栈上时展开为类型 `int32`。 浮点值将扩展为其本机大小（类型 `F`）。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldarg.s` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Byte%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将参数地址加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 0A < `unsigned int16` >|ldarga `index`|提取 `index`索引的参数的地址。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `index` 索引的参数的地址 `addr` 推送到堆栈上。  
  
 `ldarga` 指令提取按 `index`编制索引的自变量的地址（类型 `*`），其中参数从0开始编制索引。 地址 `addr` 始终与目标计算机上的自然边界对齐。  
  
 对于采用可变长度参数列表的过程，`ldarga` 指令只能用于初始固定参数，而不能用于签名的变量部分。  
  
 `ldarga` 用于通过引用传递的参数。 对于其他情况，应使用 <xref:System.Reflection.Emit.OpCodes.Ldarg> 和 <xref:System.Reflection.Emit.OpCodes.Starg>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldarga` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Int16%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以短格式将自变量地址加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|0F < `unsigned int8` >|ldarga `index`|提取 `index`的索引的参数地址（缩写形式）。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `index` 索引的参数的地址 `addr` 推送到堆栈上。  
  
 `ldarga.s` （`ldarga`的缩写形式）应用于0到255之间的参数编号，并且是一种更有效的编码。  
  
 `ldarga.s` 指令提取按 `index`编制索引的自变量的地址（类型`*`），其中参数从0开始编制索引。 地址 `addr` 始终与目标计算机上的自然边界对齐。  
  
 对于采用可变长度参数列表的过程，`ldarga.s` 指令只能用于初始固定参数，而不能用于签名的变量部分。  
  
 `ldarga.s` 用于通过引用传递的参数。 对于其他情况，应使用 <xref:System.Reflection.Emit.OpCodes.Ldarg_S> 和 <xref:System.Reflection.Emit.OpCodes.Starg_S>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldarga.s` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Byte%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将所提供的 <see langword="int32" /> 类型的值作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|20 < `int32` >|ldc. i4 `num`|将值 `num` 推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  `num` 的值推送到堆栈上。  
  
 请注意，对于从-128 到127的整数，会有特殊的简短编码（因而更有效），尤其是-1 到8的短编码。 所有短编码将4字节整数推送到堆栈上。 较长的编码用于8字节整数、4字节和8字节浮点数，以及不符合短格式的4字节值。 有三种方法可将8字节整数常量推送到堆栈上  
  
 1. 对于必须以32多位表示的常量，请使用 <xref:System.Reflection.Emit.OpCodes.Ldc_I8> 指令。  
  
 2. 使用 <xref:System.Reflection.Emit.OpCodes.Ldc_I4> 指令，后跟需要9到32位的常量的 <xref:System.Reflection.Emit.OpCodes.Conv_I8>。  
  
 3. 使用简短的窗体指令，后面跟有可以用8个或更少位表示的常量的 <xref:System.Reflection.Emit.OpCodes.Conv_I8>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.i4` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Int32%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 0 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|16|ldc.i4.0|将0推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  值0被推送到堆栈上。  
  
 这是一个用于推送整数值0的特殊短编码。 所有特殊的短编码将4字节整数推送到堆栈上。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.i4.0` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 1 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|17|ldc.i4.1|将1推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  值1被推送到堆栈上。  
  
 这是用于推送整数值1的特殊短编码。 所有特殊的短编码将4字节整数推送到堆栈上。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.i4.1` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 2 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|18|ldc.i4.2|将2推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  值2被推送到堆栈上。  
  
 这是用于推送整数值2的特殊短编码。 所有特殊的短编码将4字节整数推送到堆栈上。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.i4.2` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 3 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|19|ldc.i4.3|将3推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  值3被推送到堆栈上。  
  
 这是用于推送整数值3的特殊短编码。 所有特殊的短编码将4字节整数推送到堆栈上。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.i4.3` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 4 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|1A|ldc.i4.4|将4推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  值4被推送到堆栈上。  
  
 这是一个用于推送整数值4的特殊短编码。 所有特殊的短编码将4字节整数推送到堆栈上。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.i4.4` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 5 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|1B|ldc.i4.5|将5推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  值5被推送到堆栈上。  
  
 这是一个用于推送整数值5的特殊短编码。 所有特殊的短编码将4字节整数推送到堆栈上。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.i4.5` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 6 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|1C|ldc.i4.6|将6推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  值6被推送到堆栈上。  
  
 这是一个用于推送整数值6的特殊短编码。 所有特殊的短编码将4字节整数推送到堆栈上。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.i4.6` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 7 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|1D|ldc.i4.7|将7推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  值7被推送到堆栈上。  
  
 这是一个用于推送整数值7的特殊短编码。 所有特殊的短编码将4字节整数推送到堆栈上。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.i4.7` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 8 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|1E|ldc.i4.8|将8推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  值8被推送到堆栈上。  
  
 这是用于推送整数值8的特殊短编码。 所有特殊的短编码将4字节整数推送到堆栈上。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.i4.8` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 -1 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|15|ldc.i4.m1|将-1 推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  值-1 被推送到堆栈上。  
  
 这是用于推送整数值-1 的特殊短编码。 所有特殊的短编码将4字节整数推送到堆栈上。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.i4.m1` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将提供的 <see langword="int8" /> 值作为 <see langword="int32" /> 推送到计算堆栈上（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|1F < `int8` >|ldc. i4 `num`|将 `num` 作为 `int32`的短格式推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  `num` 的值推送到堆栈上。  
  
 `ldc.i4.s` 是一种更有效的编码方式，用于将从-128 到127的整数推送到计算堆栈上。  
  
以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.i4.s` 操作码：
  
- <xref:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Byte)?displayProperty=nameWithType>
- <xref:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.SByte)?displayProperty=nameWithType>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将所提供的 <see langword="int64" /> 类型的值作为 <see langword="int64" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|21 < `int64` >|ldc. i8 `num`|将 `num` 作为 `int64`推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  `num` 的值推送到堆栈上。  
  
 此编码将 `int64` 值推送到堆栈上。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.i8` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Int64%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将所提供的 <see langword="float32" /> 类型的值作为 <see langword="F" /> (float) 类型推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|22 < `float32` >|ldc. r4 `num`|将 `num` 作为 `F`推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  `num` 的值推送到堆栈上。  
  
 此编码将 `float32` 值推送到堆栈上。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.r4` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Single%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将所提供的 <see langword="float64" /> 类型的值作为 <see langword="F" /> (float) 类型推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|23 < `float64` >|ldc. r8 `num`|将 `num` 作为 `F`推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  `num` 的值推送到堆栈上。  
  
 此编码将 `float64` 值推送到堆栈上。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.r8` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Double%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>按照指令中指定的类型，将指定数组索引中的元素加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|A3 < `T` >|ldelem `typeTok`|将 `index` 中的元素加载到堆栈顶部作为 `typeTok`类型。|  
  
 堆栈转换行为顺序如下：  
  
1.  对象引用 `array` 被推送到堆栈上。  
  
2.  将 `index` 的索引值推送到堆栈上。  
  
3.  从堆栈中弹出 `index` 和 `array`;查找 `array` 中 `index` 位置上存储的值。  
  
4.  值推送到堆栈上。  
  
 `ldelem` 指令在从零开始的一维 `array` 数组中加载具有索引 `index` （类型 `native int`）的元素的值，并将其放在堆栈顶部。 数组是对象，因此由 `O`类型的值表示。  
  
 返回值的类型由指令中的 `typeTok` 标记指定。  
  
 如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。  
  
 如果 `index` 为负数或大于 `array`的上限，则会引发 <xref:System.IndexOutOfRangeException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldelem` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="native int" /> 类型的元素作为 <see langword="native int" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|97|ldelem。 i|将 `index` 类型 `native int` 的元素作为 `native int`加载到堆栈的顶部。|  
  
 堆栈转换行为顺序如下：  
  
1.  对象引用 `array` 被推送到堆栈上。  
  
2.  将 `index` 的索引值推送到堆栈上。  
  
3.  从堆栈中弹出 `index` 和 `array`;查找 `array` 中 `index` 位置上存储的值。  
  
4.  值推送到堆栈上。  
  
 `ldelem.i` 指令在从零开始的一维 `array` 数组中加载具有索引 `index` （类型 `native int`）的元素的值，并将其放在堆栈顶部。 数组是对象，因此由 `O`类型的值表示。  
  
 `ldelem.i` 的返回值为 `native int`。  
  
 请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。  
  
 如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。  
  
 如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。  
  
 如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldelem.i` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="int8" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|90|ldelem.i1|将 `index` 类型 `int8` 的元素作为 `int32`加载到堆栈的顶部。|  
  
 堆栈转换行为顺序如下：  
  
1.  对象引用 `array` 被推送到堆栈上。  
  
2.  将 `index` 的索引值推送到堆栈上。  
  
3.  从堆栈中弹出 `index` 和 `array`;查找 `array` 中 `index` 位置上存储的值。  
  
4.  值推送到堆栈上。  
  
 `ldelem.i1` 指令在从零开始的一维 `array` 数组中加载具有索引 `index` （类型 `native int`）的元素的值，并将其放在堆栈顶部。 数组是对象，因此由 `O`类型的值表示。  
  
 `ldelem.i1` 的返回值为 `int8`。  
  
 请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。  
  
 如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。  
  
 如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。  
  
 如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldelem.i1` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="int16" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|92|ldelem.i2|将 `index` 类型 `int16` 的元素作为 `int32`加载到堆栈的顶部。|  
  
 堆栈转换行为顺序如下：  
  
1.  对象引用 `array` 被推送到堆栈上。  
  
2.  将 `index` 的索引值推送到堆栈上。  
  
3.  从堆栈中弹出 `index` 和 `array`;查找 `array` 中 `index` 位置上存储的值。  
  
4.  值推送到堆栈上。  
  
 `ldelem.i2` 指令在从零开始的一维 `array` 数组中加载具有索引 `index` （类型 `native int`）的元素的值，并将其放在堆栈顶部。 数组是对象，因此由 `O`类型的值表示。  
  
 `ldelem.i2` 的返回值为 `int16`。  
  
 请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。  
  
 如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。  
  
 如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。  
  
 如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldelem.i2` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="int32" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|94|ldelem.i4|将 `index` 类型 `int32` 的元素作为 `int32`加载到堆栈的顶部。|  
  
 堆栈转换行为顺序如下：  
  
1.  对象引用 `array` 被推送到堆栈上。  
  
2.  将 `index` 的索引值推送到堆栈上。  
  
3.  从堆栈中弹出 `index` 和 `array`;查找 `array` 中 `index` 位置上存储的值。  
  
4.  值推送到堆栈上。  
  
 `ldelem.i4` 指令在从零开始的一维 `array` 数组中加载具有索引 `index` （类型 `native int`）的元素的值，并将其放在堆栈顶部。 数组是对象，因此由 `O`类型的值表示。  
  
 `ldelem.i4` 的返回值为 `int32`。  
  
 请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。  
  
 如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。  
  
 如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。  
  
 如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldelem.i4` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="int64" /> 类型的元素作为 <see langword="int64" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|96|ldelem.i8|将 `index` 类型 `int64` 的元素作为 `int64`加载到堆栈的顶部。|  
  
 堆栈转换行为顺序如下：  
  
1.  对象引用 `array` 被推送到堆栈上。  
  
2.  将 `index` 的索引值推送到堆栈上。  
  
3.  从堆栈中弹出 `index` 和 `array`;查找 `array` 中 `index` 位置上存储的值。  
  
4.  值推送到堆栈上。  
  
 `ldelem.i8` 指令在从零开始的一维 `array` 数组中加载具有索引 `index` （类型 `native int`）的元素的值，并将其放在堆栈顶部。 数组是对象，因此由 `O`类型的值表示。  
  
 `ldelem.i8` 的返回值为 `int64`。  
  
 请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。  
  
 如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。  
  
 如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。  
  
 如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldelem.i8` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="float32" /> 类型的元素作为 <see langword="F" /> 类型（浮点型）加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|98|ldelem.r4|将 `index` 类型 `float32` 的元素作为类型 `F`加载到堆栈的顶部。|  
  
 堆栈转换行为顺序如下：  
  
1.  对象引用 `array` 被推送到堆栈上。  
  
2.  将 `index` 的索引值推送到堆栈上。  
  
3.  从堆栈中弹出 `index` 和 `array`;查找 `array` 中 `index` 位置上存储的值。  
  
4.  值推送到堆栈上。  
  
 `ldelem.r4` 指令在从零开始的一维 `array` 数组中加载具有索引 `index` （类型 `native int`）的元素的值，并将其放在堆栈顶部。 数组是对象，因此由 `O`类型的值表示。  
  
 `ldelem.r4` 的返回值为 `float32`。  
  
 将浮点值加载到计算堆栈上时，会将其转换为类型 `F`。  
  
 如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。  
  
 如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。  
  
 如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldelem.r4` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="float64" /> 类型的元素作为 <see langword="F" /> 类型（浮点型）加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|99|ldelem.r8|将 `index` 类型 `float64` 的元素作为类型 `F`加载到堆栈的顶部。|  
  
 堆栈转换行为顺序如下：  
  
1.  对象引用 `array` 被推送到堆栈上。  
  
2.  将 `index` 的索引值推送到堆栈上。  
  
3.  从堆栈中弹出 `index` 和 `array`;查找 `array` 中 `index` 位置上存储的值。  
  
4.  值推送到堆栈上。  
  
 `ldelem.r8` 指令在从零开始的一维 `array` 数组中加载具有索引 `index` （类型 `native int`）的元素的值，并将其放在堆栈顶部。 数组是对象，因此由 `O`类型的值表示。  
  
 `ldelem.r8` 的返回值为 `float64`。  
  
 将浮点值加载到计算堆栈上时，会将其转换为类型 `F`。  
  
 如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。  
  
 如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。  
  
 如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldelem.r8` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的包含对象引用的元素作为 <see langword="O" /> 类型（对象引用）加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|9A|ldelem.ref|将具有对象引用的元素作为 `O`的类型加载到堆栈顶部 `index`。|  
  
 堆栈转换行为顺序如下：  
  
1.  对象引用 `array` 被推送到堆栈上。  
  
2.  将 `index` 的索引值推送到堆栈上。  
  
3.  从堆栈中弹出 `index` 和 `array`;查找 `array` 中 `index` 位置上存储的值。  
  
4.  值推送到堆栈上。  
  
 `ldelem.ref` 指令在从零开始的一维 `array` 数组中加载具有索引 `index` （类型 `native int`）的元素的值，并将其放在堆栈顶部。 数组是对象，因此由 `O`类型的值表示。  
  
 `ldelem.ref` 的返回值为类型 `O` （对象引用）。  
  
 如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。  
  
 如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。  
  
 如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldelem.ref` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="unsigned int8" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|91|ldelem.u1|将 `index` 类型 `unsigned int8` 的元素作为 `int32`加载到堆栈的顶部。|  
  
 堆栈转换行为顺序如下：  
  
1.  对象引用 `array` 被推送到堆栈上。  
  
2.  将 `index` 的索引值推送到堆栈上。  
  
3.  从堆栈中弹出 `index` 和 `array`;查找 `array` 中 `index` 位置上存储的值。  
  
4.  值推送到堆栈上。  
  
 `ldelem.u1` 指令在从零开始的一维 `array` 数组中加载具有索引 `index` （类型 `native int`）的元素的值，并将其放在堆栈顶部。 数组是对象，因此由 `O`类型的值表示。  
  
 `ldelem.u1` 的返回值为 `int8`。  
  
 请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。  
  
 如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。  
  
 如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。  
  
 如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldelem.u1` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="unsigned int16" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|93|ldelem.u2|将索引中类型 `unsigned int16` 的元素作为 `int32`加载到堆栈的顶部。|  
  
 堆栈转换行为顺序如下：  
  
1.  对象引用 `array` 被推送到堆栈上。  
  
2.  将 `index` 的索引值推送到堆栈上。  
  
3.  从堆栈中弹出 `index` 和 `array`;查找 `array` 中 `index` 位置上存储的值。  
  
4.  值推送到堆栈上。  
  
 `ldelem.u2` 指令在从零开始的一维 `array` 数组中加载具有索引 `index` （类型 `native int`）的元素的值，并将其放在堆栈顶部。 数组是对象，因此由 `O`类型的值表示。  
  
 `ldelem.u2` 的返回值为 `int16`。  
  
 请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。  
  
 如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。  
  
 如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。  
  
 如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldelem.u2` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="unsigned int32" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|95|ldelem.u4|将索引中类型 `unsigned int32` 的元素作为 `int32`加载到堆栈的顶部。|  
  
 堆栈转换行为顺序如下：  
  
1.  对象引用 `array` 被推送到堆栈上。  
  
2.  将 `index` 的索引值推送到堆栈上。  
  
3.  从堆栈中弹出 `index` 和 `array`;查找 `array` 中 `index` 位置上存储的值。  
  
4.  值推送到堆栈上。  
  
 `ldelem.u4` 指令在从零开始的一维 `array` 数组中加载具有索引 `index` （类型 `native int`）的元素的值，并将其放在堆栈顶部。 数组是对象，因此由 `O`类型的值表示。  
  
 `ldelem.u4` 的返回值为 `int32`。  
  
 请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。  
  
 如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。  
  
 如果数组不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。  
  
 如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldelem.u4` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引的数组元素的地址作为 <see langword="&amp;" /> 类型（托管指针）加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|8F < `T` >|ldelema `class`|将 `index` 上数组元素的地址作为类型 `&` （托管指针）加载到计算堆栈的顶部。|  
  
 堆栈转换行为顺序如下：  
  
1.  对象引用 `array` 被推送到堆栈上。  
  
2.  将 `index` 的索引值推送到堆栈上。  
  
3.  从堆栈中弹出 `index` 和 `array`;查找 `array` 中 `index` 位置上存储的地址。  
  
4.  该地址将被推送到堆栈上。  
  
 `ldelema` 用于检索对象数组（类型 `class`）中特定索引处的对象的地址。 `ldelema` 指令会在从零开始的一维 `array` 数组中的索引 `index` （类型 `native int`）处加载值的地址，并将其放在堆栈顶部。 数组是对象，因此由 `O`类型的值表示。 该值必须是随指令传递 `class` 类型。  
  
 `ldelema` 的返回值为托管指针（类型 `&`）。  
  
 请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。  
  
 如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。  
  
 如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。  
  
 如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldelema` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>查找对象中其引用当前位于计算堆栈的字段的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|7B < `T` >|ldfld `field`|将指定对象中的字段的值推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  对象引用（或指针）被推送到堆栈上。  
  
2.  从堆栈中弹出对象引用（或指针）;找到对象中指定字段的值。  
  
3.  存储在字段中的值将被推送到堆栈上。  
  
 `ldfld` 指令将位于对象中的字段的值推送到堆栈上。 对象必须位于堆栈上以作为对象引用（类型 `O`）、托管指针（类型 `&`）、非托管指针（类型 `native int`）、暂时性指针（类型 `*`）或值类型的实例。 可验证代码中不允许使用非托管指针。 对象的字段由必须引用字段成员的元数据标记指定。 返回类型与字段关联的类型相同。 字段可以是实例字段（在这种情况下，对象不得为空引用）或静态字段。  
  
 `ldfld` 指令前面可以是 <xref:System.Reflection.Emit.OpCodes.Unaligned> 和/或 <xref:System.Reflection.Emit.OpCodes.Volatile> 前缀。  
  
 如果对象为 null，并且该字段不是静态的，则会引发 <xref:System.NullReferenceException>。  
  
 如果在元数据中找不到指定的字段，则会引发 <xref:System.MissingFieldException>。 当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是在运行时，通常会检查此情况。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldfld` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.FieldInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>查找对象中其引用当前位于计算堆栈的字段的地址。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|7C < `T` >|ldflda `field`|将指定对象中的 `field` 的地址推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  对象引用（或指针）被推送到堆栈上。  
  
2.  从堆栈中弹出对象引用（或指针）;找到对象中指定字段的地址。  
  
3.  指定字段的地址被推送到堆栈上。  
  
 `ldflda` 指令将位于对象中的字段的地址推送到堆栈上。 对象必须位于堆栈上以作为对象引用（类型 `O`）、托管指针（类型 `&`）、非托管指针（类型 `native int`）、暂时性指针（类型 `*`）或值类型的实例。 可验证代码中不允许使用非托管指针。 对象的字段由必须引用字段成员的元数据标记指定。  
  
 `ldflda` 返回的值是托管指针（类型 `&`），除非将该对象作为非托管指针推送到堆栈上，在这种情况下，返回地址也是非托管指针（类型 `native int`）。  
  
 `ldflda` 指令前面可以是 <xref:System.Reflection.Emit.OpCodes.Unaligned> 和/或 <xref:System.Reflection.Emit.OpCodes.Volatile> 前缀。  
  
 如果对象不在从中访问它的应用程序域中，则会引发 <xref:System.InvalidOperationException>。 不在访问应用程序域中的字段的地址无法加载。  
  
 如果对象为 null，并且该字段不是静态的，则会引发 <xref:System.NullReferenceException>。  
  
 如果在元数据中找不到指定的字段，则会引发 <xref:System.MissingFieldException>。 当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是在运行时，通常会检查此情况。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldflda` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.FieldInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将指向实现特定方法的本机代码的非托管指针（<see langword="native int" /> 类型）推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 06 < `T` >|ldftn `method`|将指向 `method` 引用的方法的指针推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  指向特定方法的非托管指针将被推送到堆栈上。  
  
 如果特定方法（`method`）引用托管方法（或从托管代码转换为非托管代码的存根），则可以使用 <xref:System.Reflection.Emit.OpCodes.Calli> 指令进行调用。  
  
 返回的值指向使用 CLR 调用约定的本机代码。 此方法指针不应作为回调例程传递到非托管的本机代码。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldftn` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="native int" /> 类型的值作为 <see langword="native int" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|4D|ldind。 i|将位于地址 `addr` 的 `native int` 值作为 `native int`加载到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  地址被推送到堆栈上。  
  
2.  从堆栈中弹出该地址;获取位于地址的值。  
  
3.  提取的值被推送到堆栈上。  
  
 `ldind.i` 指令将指定地址（类型 `native int`、`&`或 *）的 `native int` 值作为 `native int`间接加载到堆栈上。  
  
 所有 `ldind` 说明都是指定相应内置值类的 <xref:System.Reflection.Emit.OpCodes.Ldobj> 指令的快捷方式。  
  
 请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。 将浮点值加载到计算堆栈上时，会将其转换为 `F` 类型。  
  
 格式正确的 Microsoft 中间语言（MSIL）确保以与指针类型一致的方式使用 `ldind` 指令。  
  
 最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐，否则可能会出现 <xref:System.NullReferenceException> （请参阅针对预防措施的 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀说明）。 返回地址的所有 MSIL 指令的结果（例如 <xref:System.Reflection.Emit.OpCodes.Ldloca> 和 <xref:System.Reflection.Emit.OpCodes.Ldarga>）都安全对齐。 对于大于1个字节的数据类型，字节排序依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 如果检测到无效地址，则可能引发 <xref:System.NullReferenceException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldind.i` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="int8" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|46|ldind|将位于地址 `addr` 的 `int8` 值作为 `int32`加载到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  地址被推送到堆栈上。  
  
2.  从堆栈中弹出该地址;获取位于地址的值。  
  
3.  提取的值被推送到堆栈上。 
  
 `ldind.i1` 指令将指定地址（类型 `native int`、`&`或 *）的 `int8` 值作为 `int32`间接加载到堆栈上。  
  
 所有 `ldind` 说明都是指定相应内置值类的 <xref:System.Reflection.Emit.OpCodes.Ldobj> 指令的快捷方式。  
  
 请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。 将浮点值加载到计算堆栈上时，会将其转换为 `F` 类型。  
  
 格式正确的 Microsoft 中间语言（MSIL）确保以与指针类型一致的方式使用 `ldind` 指令。  
  
 最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐，否则可能会出现 <xref:System.NullReferenceException> （请参阅针对预防措施的 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀说明）。 返回地址的所有 MSIL 指令的结果（例如 <xref:System.Reflection.Emit.OpCodes.Ldloca> 和 <xref:System.Reflection.Emit.OpCodes.Ldarga>）都安全对齐。 对于大于1个字节的数据类型，字节排序依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 如果检测到无效地址，则可能引发 <xref:System.NullReferenceException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldind.i1` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="int16" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|48|ldind|将位于地址 `addr` 的 `int16` 值作为 `int32`加载到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  地址被推送到堆栈上。  
  
2.  从堆栈中弹出该地址;获取位于地址的值。  
  
3.  提取的值被推送到堆栈上。  
  
 `ldind.i2` 指令将指定地址（类型 `native int`、`&`或 *）的 `int16` 值作为 `int32`间接加载到堆栈上。  
  
 所有 `ldind` 说明都是指定相应内置值类的 <xref:System.Reflection.Emit.OpCodes.Ldobj> 指令的快捷方式。  
  
 请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。 将浮点值加载到计算堆栈上时，会将其转换为 `F` 类型。  
  
 格式正确的 Microsoft 中间语言（MSIL）确保以与指针类型一致的方式使用 `ldind` 指令。  
  
 最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐，否则可能会出现 <xref:System.NullReferenceException> （请参阅针对预防措施的 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀说明）。 返回地址的所有 MSIL 指令的结果（例如 <xref:System.Reflection.Emit.OpCodes.Ldloca> 和 <xref:System.Reflection.Emit.OpCodes.Ldarga>）都安全对齐。 对于大于1个字节的数据类型，字节排序依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 如果检测到无效地址，则可能引发 <xref:System.NullReferenceException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldind.i2` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="int32" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|4A|ldind. i4|将位于地址 `addr` 的 `int32` 值作为 `int32`加载到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  地址被推送到堆栈上。  
  
2.  从堆栈中弹出该地址;获取位于地址的值。  
  
3.  提取的值被推送到堆栈上。  
  
 `ldind.i4` 指令将指定地址（类型 `native int`、`&`或 *）的 `int32` 值作为 `int32`间接加载到堆栈上。  
  
 所有 `ldind` 说明都是指定相应内置值类的 <xref:System.Reflection.Emit.OpCodes.Ldobj> 指令的快捷方式。  
  
 请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。 将浮点值加载到计算堆栈上时，会将其转换为 `F` 类型。  
  
 格式正确的 Microsoft 中间语言（MSIL）确保以与指针类型一致的方式使用 `ldind` 指令。  
  
 最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐，否则可能会出现 <xref:System.NullReferenceException> （请参阅针对预防措施的 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀说明）。 返回地址的所有 MSIL 指令的结果（例如 <xref:System.Reflection.Emit.OpCodes.Ldloca> 和 <xref:System.Reflection.Emit.OpCodes.Ldarga>）都安全对齐。 对于大于1个字节的数据类型，字节排序依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 如果检测到无效地址，则可能引发 <xref:System.NullReferenceException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldind.i4` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="int64" /> 类型的值作为 <see langword="int64" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|4C|ldind. i8|将位于地址 `addr` 的 `int64` 值作为 `int64`加载到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  地址被推送到堆栈上。  
  
2.  从堆栈中弹出该地址;获取位于地址的值。  
  
3.  提取的值被推送到堆栈上。  
  
 `ldind.i8` 指令将指定地址（类型 `native int`、`&`或 *）的 `int64` 值作为 `int64`间接加载到堆栈上。  
  
 所有 `ldind` 说明都是指定相应内置值类的 <xref:System.Reflection.Emit.OpCodes.Ldobj> 指令的快捷方式。  
  
 请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。 将浮点值加载到计算堆栈上时，会将其转换为 `F` 类型。  
  
 格式正确的 Microsoft 中间语言（MSIL）确保以与指针类型一致的方式使用 `ldind` 指令。  
  
 最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐，否则可能会出现 <xref:System.NullReferenceException> （请参阅针对预防措施的 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀说明）。 返回地址的所有 MSIL 指令的结果（例如 <xref:System.Reflection.Emit.OpCodes.Ldloca> 和 <xref:System.Reflection.Emit.OpCodes.Ldarga>）都安全对齐。 对于大于1个字节的数据类型，字节排序依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 如果检测到无效地址，则可能引发 <xref:System.NullReferenceException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldind.i8` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="float32" /> 类型的值作为 <see langword="F" /> (float) 类型间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|4E|ldind. r4|将位于地址 `addr` 的 `float32` 值作为类型 `F`加载到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  地址被推送到堆栈上。  
  
2.  从堆栈中弹出该地址;获取位于地址的值。  
  
3.  提取的值被推送到堆栈上。  
  
 `ldind.r4` 指令将指定地址（类型 `native int`、`&`或 *）的 `float32` 值作为类型 `F`间接加载到堆栈上。  
  
 所有 `ldind` 说明都是指定相应内置值类的 <xref:System.Reflection.Emit.OpCodes.Ldobj> 指令的快捷方式。  
  
 请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。 将浮点值加载到计算堆栈上时，会将其转换为 `F` 类型。  
  
 格式正确的 Microsoft 中间语言（MSIL）确保以与指针类型一致的方式使用 `ldind` 指令。  
  
 最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐，否则可能会出现 <xref:System.NullReferenceException> （请参阅针对预防措施的 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀说明）。 返回地址的所有 MSIL 指令的结果（例如 <xref:System.Reflection.Emit.OpCodes.Ldloca> 和 <xref:System.Reflection.Emit.OpCodes.Ldarga>）都安全对齐。 对于大于1个字节的数据类型，字节排序依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 如果检测到无效地址，则可能引发 <xref:System.NullReferenceException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldind.r4` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="float64" /> 类型的值作为 <see langword="F" /> (float) 类型间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|4F|ldind. r8|将位于地址 `addr` 的 `float64` 值作为类型 `F`加载到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  地址被推送到堆栈上。  
  
2.  从堆栈中弹出该地址;获取位于地址的值。  
  
3.  提取的值被推送到堆栈上。  
  
 `ldind.r8` 指令将指定地址（类型 `native int`、`&`或 *）的 `float64` 值作为 `float64`间接加载到堆栈上。  
  
 所有 `ldind` 说明都是指定相应内置值类的 <xref:System.Reflection.Emit.OpCodes.Ldobj> 指令的快捷方式。  
  
 请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。 将浮点值加载到计算堆栈上时，会将其转换为 `F` 类型。  
  
 格式正确的 Microsoft 中间语言（MSIL）确保以与指针类型一致的方式使用 `ldind` 指令。  
  
 最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐，否则可能会出现 <xref:System.NullReferenceException> （请参阅针对预防措施的 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀说明）。 返回地址的所有 MSIL 指令的结果（例如 <xref:System.Reflection.Emit.OpCodes.Ldloca> 和 <xref:System.Reflection.Emit.OpCodes.Ldarga>）都安全对齐。 对于大于1个字节的数据类型，字节排序依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 如果检测到无效地址，则可能引发 <xref:System.NullReferenceException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldind.r8` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将对象引用作为 <see langword="O" />（对象引用）类型间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|50|ldind.ref|将位于地址 `addr` 的对象引用作为类型加载到堆栈上 `O`|  
  
 堆栈转换行为顺序如下：  
  
1.  地址被推送到堆栈上。  
  
2.  从堆栈中弹出该地址;提取位于地址处的对象引用。  
  
3.  提取的引用将被推送到堆栈上。  
  
 `ldind.ref` 指令将对象引用（类型 `native int`、`&`或 *）的指定地址作为类型 `O`间接加载到堆栈上。  
  
 所有 `ldind` 说明都是指定相应内置值类的 <xref:System.Reflection.Emit.OpCodes.Ldobj> 指令的快捷方式。  
  
 请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。 将浮点值加载到计算堆栈上时，会将其转换为 `F` 类型。  
  
 格式正确的 Microsoft 中间语言（MSIL）确保以与指针类型一致的方式使用 `ldind` 指令。  
  
 最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐，否则可能会出现 <xref:System.NullReferenceException> （请参阅针对预防措施的 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀说明）。 返回地址的所有 MSIL 指令的结果（例如 <xref:System.Reflection.Emit.OpCodes.Ldloca> 和 <xref:System.Reflection.Emit.OpCodes.Ldarga>）都安全对齐。 对于大于1个字节的数据类型，字节排序依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 如果检测到无效地址，则可能引发 <xref:System.NullReferenceException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldind.ref` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="unsigned int8" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|47|ldind|将位于地址 `addr` 的 `unsigned int8` 值作为 `int32`加载到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  地址被推送到堆栈上。  
  
2.  从堆栈中弹出该地址;获取位于地址的值。  
  
3.  提取的值被推送到堆栈上。  
  
 `ldind.u1` 指令将指定地址（类型`native int`、`&`或 *）的 `unsigned int8` 值作为 `int32`间接加载到堆栈上。  
  
 所有 `ldind` 说明都是指定相应内置值类的 <xref:System.Reflection.Emit.OpCodes.Ldobj> 指令的快捷方式。  
  
 请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。 将浮点值加载到计算堆栈上时，会将其转换为 `F` 类型。  
  
 格式正确的 Microsoft 中间语言（MSIL）确保以与指针类型一致的方式使用 `ldind` 指令。  
  
 最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐，否则可能会出现 <xref:System.NullReferenceException> （请参阅针对预防措施的 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀说明）。 返回地址的所有 MSIL 指令的结果（例如 <xref:System.Reflection.Emit.OpCodes.Ldloca> 和 <xref:System.Reflection.Emit.OpCodes.Ldarga>）都安全对齐。 对于大于1个字节的数据类型，字节排序依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 如果检测到无效地址，则可能引发 <xref:System.NullReferenceException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldind.u1` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="unsigned int16" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|49|ldind|将位于地址 `addr` 的 `unsigned int16` 值作为 `int32`加载到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  地址被推送到堆栈上。  
  
2.  从堆栈中弹出该地址;获取位于地址的值。  
  
3.  提取的值被推送到堆栈上。  
  
 `ldind.u2` 指令将指定地址（类型 `native int`、`&`或 *）的 `unsigned int16` 值作为 `int32`间接加载到堆栈上。  
  
 所有 `ldind` 说明都是指定相应内置值类的 <xref:System.Reflection.Emit.OpCodes.Ldobj> 指令的快捷方式。  
  
 请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。 将浮点值加载到计算堆栈上时，会将其转换为 `F` 类型。  
  
 格式正确的 Microsoft 中间语言（MSIL）确保以与指针类型一致的方式使用 `ldind` 指令。  
  
 最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐，否则可能会出现 <xref:System.NullReferenceException> （请参阅针对预防措施的 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀说明）。 返回地址的所有 MSIL 指令的结果（例如 <xref:System.Reflection.Emit.OpCodes.Ldloca> 和 <xref:System.Reflection.Emit.OpCodes.Ldarga>）都安全对齐。 对于大于1个字节的数据类型，字节排序依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 如果检测到无效地址，则可能引发 <xref:System.NullReferenceException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldind.u2` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="unsigned int32" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|4B|ldind. u4|将位于地址 `addr` 的 `unsigned int32` 值作为 `int32`加载到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  地址被推送到堆栈上。  
  
2.  从堆栈中弹出该地址;获取位于地址的值。  
  
3.  提取的值被推送到堆栈上。  
  
 `ldind.u4` 指令将指定地址（类型 `native int`、`&`或 *）的 `unsigned int32` 值作为 `int32`间接加载到堆栈上。  
  
 所有 `ldind` 说明都是指定相应内置值类的 <xref:System.Reflection.Emit.OpCodes.Ldobj> 指令的快捷方式。  
  
 请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。 将浮点值加载到计算堆栈上时，会将其转换为 `F` 类型。  
  
 格式正确的 Microsoft 中间语言（MSIL）确保以与指针类型一致的方式使用 `ldind` 指令。  
  
 最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐，否则可能会出现 <xref:System.NullReferenceException> （请参阅针对预防措施的 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀说明）。 返回地址的所有 MSIL 指令的结果（例如 <xref:System.Reflection.Emit.OpCodes.Ldloca> 和 <xref:System.Reflection.Emit.OpCodes.Ldarga>）都安全对齐。 对于大于1个字节的数据类型，字节排序依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 如果检测到无效地址，则可能引发 <xref:System.NullReferenceException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldind.u4` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将从零开始的、一维数组的元素的数目推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|8E|ldlen|将数组的长度（类型 `natural unsigned int`）推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  对数组的对象引用被推送到堆栈上。  
  
2.  从堆栈中弹出数组引用并计算长度。  
  
3.  长度被推送到堆栈上。  
  
 数组是对象，因此由 `O`类型的值表示。 长度作为 `natural unsigned int`返回。  
  
 如果数组引用为空引用，则会引发 <xref:System.NullReferenceException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldlen` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将指定索引处的局部变量加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 0C < `unsigned int16` >|ldloc `index`|将索引 `index` 上的局部变量加载到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  将指定索引处的本地变量值推送到堆栈上。  
  
 `ldloc` 指令将传递的索引处的局部变量数字的内容推送到计算堆栈上，其中本地变量从0开始编号。 仅当方法的 initialize 标志为 true 时，才在输入方法之前，将局部变量初始化为0。 可能存在65535（2 ^ 16-1）个本地变量（0-65534）。 索引65535无效，因为可能的实现将使用2字节整数跟踪本地的索引，以及给定方法的局部变量总数。 如果已将65535的索引设为有效，则需要更宽的整数来跟踪此类方法中的局部变量的数目。  
  
 `ldloc.0`、`ldloc.1`、`ldloc.2`和 `ldloc.3` 说明提供了用于访问前四个局部变量的有效编码。  
  
 值的类型与在方法头中指定的局部变量的类型相同。 请参阅 Partition I. 小于4个字节的局部变量在加载到堆栈上时，将扩展为类型 `int32`。 浮点值将扩展为其本机大小（类型 `F`）。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldloc` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.LocalBuilder%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Int16%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引 0 处的局部变量加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|06|ldloc|将索引 0 处的局部变量加载到计算堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  将索引0处的局部变量值推送到堆栈上。  
  
 `ldloc.0` 是 <xref:System.Reflection.Emit.OpCodes.Ldloc>的一个特别高效的编码，允许访问索引0处的局部变量。  
  
 值的类型与在方法头中指定的局部变量的类型相同。 在将小于4个字节的局部变量加载到堆栈上时，将扩展为 `int32` 类型。 浮点值将扩展为其本机大小（类型 `F`）。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldloc.0` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引 1 处的局部变量加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|07|ldloc.1|将索引 1 处的局部变量加载到计算堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  位于索引1处的局部变量值被推送到堆栈上。  
  
 `ldloc.1` 是 <xref:System.Reflection.Emit.OpCodes.Ldloc>的一个特别高效的编码，允许访问索引1处的局部变量。  
  
 值的类型与在方法头中指定的局部变量的类型相同。 在将小于4个字节的局部变量加载到堆栈上时，将扩展为 `int32` 类型。 浮点值将扩展为其本机大小（类型 `F`）。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldloc.1` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引 2 处的局部变量加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|08|ldloc.2|将索引 2 处的局部变量加载到计算堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  将索引2处的局部变量值推送到堆栈上。  
  
 `ldloc.2` 是 <xref:System.Reflection.Emit.OpCodes.Ldloc>的一个特别高效的编码，允许访问索引2处的局部变量。  
  
 值的类型与在方法头中指定的局部变量的类型相同。 在将小于4个字节的局部变量加载到堆栈上时，将扩展为 `int32` 类型。 浮点值将扩展为其本机大小（类型 `F`）。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldloc.2` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引 3 处的局部变量加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|09|ldloc.3|将索引 3 处的局部变量加载到计算堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  将索引为3的本地变量值推送到堆栈上。  
  
 `ldloc.3` 是 <xref:System.Reflection.Emit.OpCodes.Ldloc>的一个特别高效的编码，允许访问索引3处的局部变量。  
  
 值的类型与在方法头中指定的局部变量的类型相同。 在将小于4个字节的局部变量加载到堆栈上时，将扩展为 `int32` 类型。 浮点值将扩展为其本机大小（类型 `F`）。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldloc.3` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将特定索引处的局部变量加载到计算堆栈上（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|11 < `unsigned int8` >|ldloc `index`|将索引 `index` 上的局部变量加载到堆栈上（短格式）。|  
  
 堆栈转换行为顺序如下：  
  
1.  将指定索引处的本地变量值推送到堆栈上。  
  
 `ldloc.s` 指令将传递的索引处的局部变量数字的内容推送到计算堆栈上，其中本地变量从0开始编号。 如果对方法的 initialize 标志为 true，则在输入方法之前，本地变量将初始化为0。 可以使用256（2 ^ 8）个本地变量（0-255），这是一种比 `ldloc`更有效的编码。  
  
 值的类型与在方法头中指定的局部变量的类型相同。 请参阅 Partition I. 小于4个字节的局部变量在加载到堆栈上时，将扩展为类型 `int32`。 浮点值将扩展为其本机大小（类型 `F`）。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldloc.s` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.LocalBuilder%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Byte%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于特定索引处的局部变量的地址加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE OD < `unsigned int16` >|ldloca `index`|将 `index` 中的局部变量的地址加载到计算堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  存储在本地变量中指定索引处的地址被推送到堆栈上。  
  
 `ldloca` 指令将传递的索引处的局部变量号的地址推送到堆栈上，其中局部变量从0开始编号。 堆栈中推送的值已正确对齐，以便与 <xref:System.Reflection.Emit.OpCodes.Ldind_I> 和 <xref:System.Reflection.Emit.OpCodes.Stind_I>等说明一起使用。 结果为暂时性指针（类型 `*`）。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldloca` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Int16%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于特定索引处的局部变量的地址加载到计算堆栈上（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|12 < `unsigned int8` >|ldloca `index`|将 `index` 中的局部变量的地址加载到计算堆栈上（短格式）。|  
  
 堆栈转换行为顺序如下：  
  
1.  存储在本地变量中指定索引处的地址被推送到堆栈上。  
  
 `ldloca.s` 指令将传递的索引处的局部变量号的地址推送到堆栈上，其中局部变量从0开始编号。 堆栈中推送的值已正确对齐，以便与 <xref:System.Reflection.Emit.OpCodes.Ldind_I> 和 <xref:System.Reflection.Emit.OpCodes.Stind_I>等说明一起使用。 结果为暂时性指针（类型 `*`）。  
  
 `ldloca.s` 指令提供了一个有效的编码，可与局部变量0到255一起使用。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldloca.s` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Byte%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将空引用（<see langword="O" /> 类型）推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|14|ldnull|在堆栈上推送空引用|  
  
 堆栈转换行为顺序如下：  
  
1.  空对象引用被推送到堆栈上。  
  
 `ldnull` 将堆栈上的空引用（类型 `O`）推送。 这用于在使用数据填充位置之前或在位置被弃用时初始化位置。  
  
 `ldnull` 提供了一个与大小无关的空引用。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldnull` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将地址指向的值类型对象复制到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|71 < `T` >|ldobj `class`|将值类型 `class` 的实例复制到堆栈中。|  
  
 堆栈转换行为顺序如下：  
  
1.  值类型对象的地址被推送到堆栈上。  
  
2.  从堆栈中弹出该地址，并查找该特定地址处的实例。  
  
3.  存储在该地址的对象的值被推送到堆栈上。  
  
 `ldobj` 指令用于作为参数传递值类型。  
  
 `ldobj` 指令将 `addrOfValObj` 的值（类型 `&`、`*`或 `native int`）复制到堆栈顶部。 已复制的字节数取决于类的大小（由 `class` 参数指定）。 `class` 参数是表示值类型的元数据标记。  
  
 `ldobj` 指令的操作可以通过紧挨着 <xref:System.Reflection.Emit.OpCodes.Volatile> 或 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀指令来更改。  
  
 如果找不到类，则会引发 <xref:System.TypeLoadException>。 当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是运行时，通常会检测到此情况。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldobj` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将静态字段的值推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|7E < `T` >|ldsfld `field`|将 `field` 的值推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  将特定字段的值推送到堆栈上。  
  
 `ldsfld` 指令推送堆栈上的静态（在类的所有实例中共享）字段的值。 返回类型是与传递的元数据标记 `field`关联的。  
  
 `ldsfld` 指令可以具有 <xref:System.Reflection.Emit.OpCodes.Volatile> 前缀。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldsfld` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.FieldInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将静态字段的地址推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|7F < `T` >|ldsflda `field`|推送堆栈上的 `field` 地址|  
  
 堆栈转换行为顺序如下：  
  
1.  将特定字段的地址推送到堆栈上。  
  
 `ldsflda` 指令将静态（在类的所有实例中共享）字段的地址推送到堆栈上。 如果元数据标记 `field` 引用其内存被管理的类型，则该地址可以表示为暂时性指针（类型 `*`）。 否则，它对应于非托管指针（类型 `native int`）。 请注意，`field` 可能是一个静态全局对象，它具有分配的相对虚拟地址（该字段的偏移量（其包含的 PE 文件将在其中加载到内存中），其中的内存是非托管的。  
  
 `ldsflda` 指令可以具有 <xref:System.Reflection.Emit.OpCodes.Volatile> 前缀。  
  
 如果在元数据中找不到字段，则会引发 <xref:System.MissingFieldException>。 当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是运行时，通常会检查此情况。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldsflda` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.FieldInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>推送对元数据中存储的字符串的新对象引用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|72 < `T` >|ldstr `mdToken`|推送 `mdToken`的元数据字符串标记的字符串对象。|  
  
 堆栈转换行为顺序如下：  
  
1.  将对字符串的对象引用推送到堆栈上。  
  
 `ldstr` 指令将对象引用（类型 `O`）推送到表示元数据中存储的特定字符串文本的新字符串对象。 `ldstr` 指令分配所需的内存量，并执行任何格式转换，以将字符串文本从文件中使用的格式转换为运行时所需的字符串格式。  
  
 公共语言基础结构（CLI）保证两个 `ldstr` 指令的结果引用两个具有相同字符序列的元数据标记，这将返回完全相同的字符串对象（称为 "字符串暂留" 的过程）。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldstr` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.String%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将元数据标记转换为其运行时表示形式，并将其推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|D0 < `T` >|ldtoken `token`|将元数据标记转换为其运行时表示形式。|  
  
 堆栈转换行为顺序如下：  
  
1.  传递的标记将转换为 `RuntimeHandle` 并推送到堆栈上。  
  
 `ldtoken` 指令为指定的元数据标记推送 `RuntimeHandle`。 `RuntimeHandle` 可以是 `fieldref/fielddef`、`methodref/methoddef`或 `typeref/typedef`。  
  
 可以在对系统类库中 `Reflection` 方法的调用中使用推送到堆栈中的值。  
  
 有关运行时句柄的信息，请参阅以下类： <xref:System.RuntimeFieldHandle>、<xref:System.RuntimeTypeHandle>和 <xref:System.RuntimeMethodHandle>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldtoken` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.FieldInfo%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将指向实现与指定对象关联的特定虚方法的本机代码的非托管指针（<see langword="native int" /> 类型）推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 07 < `T` >|ldvirtftn `method`|将指针推送到对象的虚拟方法 `method` 堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  对象引用被推送到堆栈上。  
  
2.  从堆栈中弹出对象引用，并查找方法（由元数据标记 `method`）指定的入口点地址。  
  
3.  指向 `method` 的指针被推送到堆栈上。  
  
 如果所生成的非托管指针引用托管方法（或从托管代码转换为非托管代码的存根），则可以使用 <xref:System.Reflection.Emit.OpCodes.Calli> 指令，将该指针推送到 `ldvirtftn` 指令推送到堆栈上。  
  
 非托管指针使用 CLR 调用约定指向本机代码。 此方法指针不应作为回调例程传递到非托管的本机代码。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldvirtftn` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>退出受保护的代码区域，无条件将控制转移到特定目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|DD < `int32` >|离开 `target`|退出受保护的代码区域。|  
  
 没有为此指令指定堆栈转换行为。  
  
 `leave` 指令无条件地将控制转移到特定目标指令，表示为从当前指令后面的指令开头开始的4字节有符号偏移量。  
  
 `leave` 指令与 `br` 指令类似，但它可用于退出 `try`、`filter`或 `catch` 块，而普通的分支指令只能在此类块中使用。 `leave` 指令将清空计算堆栈，并确保执行适当的周围 `finally` 块。  
  
 不能使用 `leave` 指令退出 `finally` 块。 为了简化异常处理程序的代码生成，它在 catch 块中有效，可使用 `leave` 指令将控制转移到关联的 `try` 块内的任何指令。  
  
 如果指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `leave` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>退出受保护的代码区域，无条件将控制转移到目标指令（缩写形式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|DE < `int8` >|离开 `target`|退出受保护的代码区域（缩写形式）。|  
  
 没有为此指令指定堆栈转换行为。  
  
 `leave.s` 指令无条件地将控制转移到传递的目标指令，表示为从当前指令后面的指令开头开始的1字节有符号偏移量。  
  
 `leave.s` 指令与 `br` 指令类似，但它可用于退出 `try`、`filter`或 `catch` 块，而普通的分支指令只能在此类块中使用。 `leave.s` 指令将清空计算堆栈，并确保执行适当的周围 `finally` 块。  
  
 不能使用 `leave.s` 指令退出 `finally` 块。 为了简化异常处理程序的代码生成，它在 catch 块中有效，可使用 `leave.s` 指令将控制转移到关联的 `try` 块内的任何指令。  
  
 如果指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `leave.s` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从本地动态内存池分配特定数目的字节并将第一个分配的字节的地址（瞬态指针，<see langword="*" /> 类型）推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 0F|localloc|从本地堆中分配空间。|  
  
 堆栈转换行为顺序如下：  
  
1.  要分配的字节数将被推送到堆栈上。  
  
2.  从堆栈中弹出字节数;与该大小相对应的内存量从本地堆中分配。  
  
3.  指向分配的内存的第一个字节的指针被推送到堆栈上。  
  
 `localloc` 指令从本地动态内存池分配 `size` （类型 `natural unsigned int`）个字节，并返回第一个分配的字节的地址（瞬态指针，类型 `*`）。 仅当对方法的 initialize 标志 `true`时，返回的内存块才会初始化为0。 当当前方法执行 <xref:System.Reflection.Emit.OpCodes.Ret>时，本地内存池可供重复使用。  
  
 生成的地址是对齐的，以便可以使用 `stind` 指令（如 <xref:System.Reflection.Emit.OpCodes.Stind_I4>）将任何基元数据类型存储在此处，并使用 `ldind` 指令（如 <xref:System.Reflection.Emit.OpCodes.Ldind_I4>）进行加载。  
  
 `localloc` 指令不能出现在 `filter`、`catch`、`finally`或 `fault` 块内。  
  
 如果没有足够的内存来为请求提供服务，则会引发 <xref:System.StackOverflowException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `localloc` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将对特定类型实例的类型化引用推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|C6 < `T` >|mkrefany `class`|将类型 `class` 的类型化引用推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  指向片段的数据被推送到堆栈上。  
  
2.  将弹出指针并将其转换为类型 `class`的类型化引用。  
  
3.  类型化的引用被推送到堆栈上。  
  
 `mkrefany` 指令支持动态类型化引用的传递。 指针的类型必须为 `&`、`*`或 `native int`，并保存一段数据的有效地址。 `Class` 是描述指针所引用的数据类型的类标记。 `Mkrefany` 将类型化引用推送到堆栈上，同时提供指针和类型 `class`的不透明说明符。  
  
 对类型化引用允许的唯一有效操作是将其传递到要求类型化引用作为参数的方法。 然后，调用方可以使用 <xref:System.Reflection.Emit.OpCodes.Refanytype> 和 <xref:System.Reflection.Emit.OpCodes.Refanyval> 指令分别检索类型（类）和地址。  
  
 如果找不到 `class`，则会引发 <xref:System.TypeLoadException>。 当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是运行时，通常会检测到此情况。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `mkrefany` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个值相乘并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|5A|mul|将两个值相乘。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;`value1` 与 `value2`相乘。  
  
4.  将结果推送到堆栈上。  
  
 `mul` 指令将 `value1` 乘以 `value2` 并将结果推送到堆栈上。 整数运算在溢出时无提示截断高位。  
  
 有关使用溢出处理的特定于整数的乘法运算，请参阅 <xref:System.Reflection.Emit.OpCodes.Mul_Ovf>。  
  
 对于浮点类型，为 0 * 无穷 = NaN。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `mul` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个整数值相乘，执行溢出检查，并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|D8|mul.ovf|使用溢出检查将堆栈上的两个整数值相乘。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;`value1` 与 `value2`相乘，并进行溢出检查。  
  
4.  将结果推送到堆栈上。  
  
 `mul.ovf` 指令将整数 `value1` 乘以整数 `value2`，并将结果推送到堆栈上。 如果结果类型中不能容纳结果，则会引发异常。  
  
 如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `mul.ovf` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个无符号整数值相乘，执行溢出检查，并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|D9|mul.ovf.un|将堆栈上的两个无符号值与溢出检查相乘。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;`value1` 与 `value2`相乘，并进行溢出检查。  
  
4.  将结果推送到堆栈上。  
  
 `mul.ovf.un` 指令将无符号整数 `value1` 为无 `value2` 符号整数，并将结果推送到堆栈上。 如果结果类型中不能容纳结果，则会引发异常。  
  
 如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `mul.ovf.un` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>对一个值执行求反并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|65|neg|对当前位于堆栈顶部的值求反。|  
  
 堆栈转换行为顺序如下：  
  
1.  将值推送到堆栈上。  
  
2.  从堆栈中弹出一个值并对其进行求反。  
  
3.  将结果推送到堆栈上。  
  
 `neg` 指令对值进行求反并将结果推送到堆栈顶部。 返回类型与操作数类型相同。  
  
 整数值的求反是标准2的补码反运算。 特别是，取消最多负数（不具有正号）将产生最大的负数。 若要检测此溢出，请改用 <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> 指令（即从0中减去）。  
  
 取消浮点数不能溢出，取消 NaN 返回 NaN。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `neg` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将对新的从零开始的一维数组（其元素属于特定类型）的对象引用推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|8 D< `T` >|newarr `etype`|使用 `etype`类型的元素创建一个新数组。|  
  
 堆栈转换行为顺序如下：  
  
1.  数组中的元素数被推送到堆栈上。  
  
2.  从堆栈中弹出元素数并创建数组。  
  
3.  对新数组的对象引用被推送到堆栈上。  
  
 `newarr` 指令将对象引用（类型 `O`）推送到新的从零开始的一维数组，该数组的元素的类型为 `etype` （描述该类型的元数据标记）。 新数组中的元素数应指定为 `native int`。 有效的数组索引范围从零到最大元素数减一。  
  
 数组元素可以是任何类型，包括值类型。  
  
 从零开始的一维数组，使用引用适当值类型（<xref:System.Int32>等）的元数据标记创建。 数组的元素初始化为适当类型的0。  
  
 基于非零的一维数组和多维数组使用 <xref:System.Reflection.Emit.OpCodes.Newobj> 而不是 `newarr`来创建。 通常，它们是使用 .NET Framework 中 <xref:System.Array> 类的方法创建的。  
  
 如果内存不足，无法满足请求，则会引发 <xref:System.OutOfMemoryException>。  
  
 如果 `numElems` 小于0，则会引发 <xref:System.OverflowException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `newarr` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>创建一个值类型的新对象或新实例，并将对象引用（<see langword="O" /> 类型）推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|73 < `T` >|newobj `ctor`|分配未初始化的对象或值类型，并 `ctor`调用构造函数方法。|  
  
 堆栈转换行为顺序如下：  
  
1.  `arg1` 通过 `argn` 的参数按顺序推送到堆栈上。  
  
2.  从堆栈中弹出 `argn` 到 `arg1` 的参数，并将其传递给 `ctor` 以创建对象。  
  
3.  对新的对象的引用被推送到堆栈上。  
  
 `newobj` 指令创建新对象或值类型的新实例。 `Ctor` 是要调用的构造函数的名称、类和签名的元数据标记（必须标记为构造函数的 `methodref` 或 `methoddef`）。  
  
 `newobj` 指令分配与 `ctor` 关联的类的新实例，并根据需要将新实例中的所有字段初始化为0（适当的类型）或空引用。 然后，它将调用具有给定参数的构造 `ctor` 函数和新创建的实例。 调用构造函数后，现在将初始化的对象引用（类型 `O`）推送到堆栈上。  
  
 从构造函数的角度来看，未初始化的对象是参数0，传递给 newobj 的其他参数按照顺序排列。  
  
 所有从零开始的一维数组是使用 <xref:System.Reflection.Emit.OpCodes.Newarr>创建的，而不是 `newobj`的。 另一方面，将使用 `newobj`创建所有其他数组（多个维度，或一维但非从零开始）。  
  
 通常不使用 `newobj`创建值类型。 它们通常作为参数或局部变量分配，使用 `newarr` （适用于从零开始的一维数组）或作为对象的字段。 分配后，将使用 <xref:System.Reflection.Emit.OpCodes.Initobj>对其进行初始化。 但是，可以使用 `newobj` 指令在堆栈上创建值类型的新实例，然后可以将该实例作为参数进行传递，并将其存储在本地，等等。  
  
 如果内存不足，无法满足请求，则会引发 <xref:System.OutOfMemoryException>。  
  
 如果找不到具有指定名称、类和签名的构造函数方法 `ctor`，则会引发 <xref:System.MissingMethodException>。 当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是运行时，通常会检测到此情况。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `newobj` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.ConstructorInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果修补操作码，则填充空间。 尽管可能消耗处理周期，但未执行任何有意义的操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|00|nop|执行不具有行为的操作。|  
  
 没有为此指令定义堆栈过渡行为。  
  
 `nop` 操作不执行任何操作。 它用于在对操作码进行修补时填充空间。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `nop` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>计算堆栈顶部整数值的按位求补并将结果作为相同的类型推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|66|not|计算值的按位求补。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value` 推送到堆栈上。  
  
2.  从堆栈中弹出 `value`，并计算按位求补。  
  
3.  将结果推送到堆栈上。  
  
 `not` 指令计算整数值的按位求补并将结果推送到堆栈上。 返回类型与操作数类型相同。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `not` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>计算位于堆栈顶部的两个整数值的按位求补并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|60|or|计算两个整数值的按位 "或"，返回整数。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  `value2` 和 `value1` 从堆栈中弹出，并按位或计算。  
  
4.  将结果推送到堆栈上。  
  
 `or` 指令计算堆栈顶部的两个值的按位 "或"，并将结果推送到堆栈上。  
  
 `Or` 是特定于整数的操作。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `or` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>移除当前位于计算堆栈顶部的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|26|pop|从堆栈中弹出顶部值。|  
  
 堆栈转换行为顺序如下：  
  
1.  顶部值从堆栈中弹出。  
  
 `pop` 指令从堆栈中移除顶部元素。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `pop` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定后面的数组地址操作在运行时不执行类型检查，并且返回可变性受限的托管指针。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 1E|readonly。|指定后续数组地址操作在运行时不执行类型检查，并且它返回具有受限可变性的托管指针。|  
  
 此前缀只能出现在 `ldelema` 指令之前，并调用数组的特殊 `Address` 方法。 其对后续操作的影响是双重的：  
  
1.  在运行时，不执行任何类型检查操作。 请注意，在引用类型数组上使用时，通常会对 `ldelema` 进行隐式类型检查，并 `stelem` 说明。 对于值类，从来不会进行运行时类型检查，因此在这种情况下 `readonly` 是无操作的。  
  
2.  验证程序将操作地址操作的结果视为具有受限可变性的托管指针。  
  
 指针被称为具有受限的可变性，因为定义类型控制值是否可转变。 对于公开无公共字段或更新就地值的方法的值类，该指针为只读（因此为前缀的名称）。 特别是，表示基元类型的类（例如，System.object）不公开赋值函数，因此它们是只读的。  
  
 以这种方式限制的托管指针只能通过以下方式使用：  
  
-   作为 `ldfld`的 `object` 参数，`ldflda`、`stfld`、`call`或`constrained callvirt` 说明。  
  
-   作为 `ldobj` 指令的 `pointer` 参数或 `ldind` 说明之一。  
  
-   作为 `cpobj` 指令的 `source` 参数。  
  
 不允许所有其他操作，包括 `stobj`、`initobj`或 `mkrefany` 操作，或者任何 `stind` 说明。  
  
 `readonly` 前缀的目的是为了避免在从泛型代码中的数组获取元素时进行类型检查。 例如，表达式 `arr[i].m()`，其中数组 `arr` 的元素类型是一个泛型类型，该类型被约束为具有带方法 `m`的接口，可能会编译为以下 MSIL。  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 如果没有 `readonly` 前缀，则 `ldelema` 指令会在！0是引用类型的情况下执行类型检查。 这种类型的检查不仅低效，而且它在语义上不正确。 `ldelema` 的类型检查是完全匹配，这太强。 如果数组持有类型为！0的子类，则上述代码将无法通过类型检查。  
  
 提取数组元素的地址，而不是元素本身，以获得适用于值类型和引用类型的 `arr[i]` 的句柄，因此可将其传递给 `constrained callvirt` 指令。  
  
 通常，如果数组持有引用类型的元素，则跳过运行时检查是不安全的。 为安全起见，需要确保不通过此指针对数组进行任何修改。 验证程序规则确保这一点。 受限制的托管指针可以作为实例方法调用的对象进行传递，因此对于值类型而言，并不严格地说是只读的，但对于值类型，不存在任何类型安全问题。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `readonly` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>检索嵌入在类型化引用内的类型标记。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 1D|refanytype|推送在类型化引用中存储的类型标记。|  
  
 堆栈转换行为顺序如下：  
  
1.  值类型引用被推送到堆栈上。  
  
2.  类型化引用从堆栈中弹出，并检索其相应的类型标记。  
  
3.  类型标记被推送到堆栈上。  
  
 类型化引用包含对象实例的类型标记和地址。  
  
 `refanytype` 指令检索嵌入在类型化引用中的类型标记。 有关创建类型化引用的信息，请参阅 <xref:System.Reflection.Emit.OpCodes.Mkrefany> 说明。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `refanytype` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>检索嵌入在类型化引用内的地址（<see langword="&amp;" /> 类型）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|C2 < `T` >|refanyval `type`|推送在类型化引用中存储的地址。|  
  
 堆栈转换行为顺序如下：  
  
1.  值类型引用被推送到堆栈上。  
  
2.  从堆栈中弹出类型化引用和检索到相应的地址。  
  
3.  该地址将被推送到堆栈上。  
  
 类型化引用包含对象实例的类型标记和地址。  
  
 `refanyval` 指令检索嵌入在类型化引用中的地址。 在堆栈上提供的类型化引用中嵌入的类型必须与 `type` （元数据标记，`typedef` 或 `typeref`）指定的类型匹配。 请参阅 <xref:System.Reflection.Emit.OpCodes.Mkrefany> 说明了解相关内容。  
  
 如果 `type` 与类型引用中存储的类型不完全相同（在这种情况下，则会引发 <xref:System.InvalidCastException>，`type` 是提供给构造所说的类型化引用的 <xref:System.Reflection.Emit.OpCodes.Mkrefany> 指令的类。）  
  
 如果找不到 `type`，则会引发 <xref:System.TypeLoadException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `refanyval` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个值相除并将余数推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|5D|rem|将除以 `value2` `value1` 的剩余部分推送到堆栈上。|  
  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  `value2` 和 `value1` 从堆栈中弹出，`value1` `div` `value2` 计算所得的余数。  
  
4.  将结果推送到堆栈上。  
  
 `result` = `value1` `rem` `value2` 满足以下条件：  
  
 `result` = `value1` - `value2` `×` （`value1` `div` `value2`）和：  
  
 0 = &#124; `result` &#124; < &#124; `value2` &#124;、符号（`result`） = sign （`value1`），其中 `div` 是向零截断的除法指令。  
  
 如果 `value2` 为零或 `value1` 为无穷大，则结果为 NaN。 如果 `value2` 无穷，则结果为 `value1` （`-infinity`为求反）。  
  
 如果 `value2` 为零，则整型运算引发 <xref:System.DivideByZeroException>。  
  
 请注意，在基于 Intel 的平台上，计算（minint `rem`）时将引发 <xref:System.OverflowException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `rem` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个无符号值相除并将余数推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|5E|rem.un|将未签名 `value1` `value2` 的余数推送到堆栈上。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  `value2` 和 `value1` 从堆栈中弹出，`value1` `div` `value2` 计算所得的余数。  
  
4.  将结果推送到堆栈上。  
  
 `result` = `value1` `rem.un` `value2` 满足以下条件：  
  
 `result` = `value1` - `value2` x （`value1` `div.un` `value2`）和：  
  
 0 = `result` < `value2`，其中 `div.un` 是无符号除法指令。  
  
 `rem.un` 指令计算 `result` 并将其推送到堆栈上。 `Rem.un` 将其参数视为无符号整数，而 <xref:System.Reflection.Emit.OpCodes.Rem> 将其视为有符号整数。  
  
 不为浮点数指定 `Rem.un`。  
  
 如果 `value2` 为零，则整型运算引发 <xref:System.DivideByZeroException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `rem.un` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从当前方法返回，并将返回值（如果存在）从被调用方的计算堆栈推送到调用方的计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|2A|ret|从方法返回，可能返回值。|  
  
 堆栈转换行为顺序如下：  
  
1.  从被调用方的计算堆栈中弹出返回值。  
  
2.  在步骤1中获取的返回值被推送到调用方计算堆栈上。  
  
 如果返回值不在被调用方的计算堆栈上，则不返回任何值（对于被调用方或调用方方法，不返回任何堆栈转换行为）。  
  
 当前方法的返回值的类型（如果有）确定要从堆栈顶部获取的值的类型，并将其复制到调用当前方法的方法的堆栈上。 当前方法的计算堆栈必须为空，但要返回的值除外。  
  
 `ret` 指令不能用于将控制转移出`try`、`filter`、`catch`或 `finally` 块。 在 `try` 或 `catch`中，将 <xref:System.Reflection.Emit.OpCodes.Leave> 指令与所有封闭异常块之外的 `ret` 指令的目标一起使用。 由于 `filter` 和 `finally` 块在逻辑上是异常处理的一部分，而不是其代码的嵌入方法，因此正确生成的 Microsoft 中间语言（MSIL）指令不会从 `filter` 或 `finally`中执行方法返回。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ret` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>再次引发当前异常。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 1A|重新引发|重新引发当前异常|  
  
 没有为此指令定义堆栈转换行为。  
  
 仅允许在 `catch` 处理程序的主体内使用 `rethrow` 指令。 它将引发与此处理程序捕获的异常。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `rethrow` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值左移（用零填充）指定的位数，并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|62|shl|向左移动一个整数（以零为变化）。|  
  
 堆栈转换行为顺序如下：  
  
1.  将值推送到堆栈上。  
  
2.  要移动的位数将被推送到堆栈上。  
  
3.  要移动的位数以及从堆栈中弹出的值的数目;该值将向左移动指定的位数。  
  
4.  将结果推送到堆栈上。  
  
 `shl` 指令将值（类型 `int32`、`int64` 或 `native int`）向左移动指定的位数。 位数是 `int32` 或 `native int`类型的值。 如果要移位的位数大于或等于所提供值的宽度（以位为单位），则返回值为未指定。  
  
 `Shl` 将在每次移位的最小位置插入零位。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `shl` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值右移（保留符号）指定的位数，并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|63|shr|向右移动一个整数（移位）。|  
  
 堆栈转换行为顺序如下：  
  
1.  将值推送到堆栈上。  
  
2.  要移动的位数将被推送到堆栈上。  
  
3.  要移动的位数以及从堆栈中弹出的值的数目;值向右移动指定的位数。  
  
4.  将结果推送到堆栈上。  
  
 `shr.un` 指令将值（键入 `int32`、`int64` 或 `native int`）向右移动指定的位数。 位数是 `int32` 或 `native int`类型的值。 如果要移位的位数大于或等于所提供值的宽度（以位为单位），则返回值为未指定。  
  
 `Shr` 复制每个班次的高阶位，同时保留 `result`中原始值的符号。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `shr` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将无符号整数值右移（用零填充）指定的位数，并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|64|shr|向右移动一个整数（以零为变化）。|  
  
 堆栈转换行为顺序如下：  
  
1.  将值推送到堆栈上。  
  
2.  要移动的位数将被推送到堆栈上。  
  
3.  要移动的位数以及从堆栈中弹出的值的数目;值向右移动指定的位数。  
  
4.  将结果推送到堆栈上。  
  
 `shr.un` 指令将值（键入 `int32`、`int64` 或 `native int`）向右移动指定的位数。 位数是 `int32`、`int64` 或 `native int`类型的值。 如果要移位的位数大于或等于所提供值的宽度（以位为单位），则返回值为未指定。  
  
 `Shr.un` 在每个移位上的最高位置插入零位。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `shr.un` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将提供的值类型的大小（以字节为单位）推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 1C < `T` >|sizeof `valType`|将值类型的大小（以字节为单位）作为 `unsigned int32`推送。|  
  
 堆栈转换行为顺序如下：  
  
1.  将提供的值类型（`valType`）的大小（以字节为单位）推送到堆栈上。  
  
 `valType` 必须是指定值类型、引用类型或泛型类型参数的元数据标记（`typeref` 或 `typedef`）。  
  
 对于引用类型，返回的大小为相应类型的引用值的大小（32位系统上为4个字节），而不是存储在引用值引用的对象中的数据的大小。 泛型类型参数只能在定义它的类型或方法的主体中使用。 当对该类型或方法进行实例化时，泛型类型参数被替换为值类型或引用类型。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `sizeof` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值存储到位于指定索引的自变量槽中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 0B < `unsigned int16` >|starg `num`|从堆栈中弹出顶部值并将其存储在参数槽中 `num`。|  
  
 堆栈转换行为顺序如下：  
  
1.  将弹出当前位于堆栈顶部的值并将其放入参数槽位 `num`。  
  
 `starg` 指令从堆栈中弹出一个值，并将其放在参数槽中 `num`。 值的类型必须与当前方法的签名中指定的参数的类型匹配。  
  
 对于采用变量参数列表的过程，`starg` 指令只能用于初始固定参数，而不能用于签名的变量部分。  
  
 如果将存储区的参数保留为小于4个字节的整数值，则会在从堆栈移到参数时截断值。 浮点值从其本机大小（类型 `F`）舍入到与参数关联的大小。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `starg` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Int16%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值存储在自变量槽中的指定索引处（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|10 < `unsigned int8` >|starg `num`|从堆栈中弹出顶部值并将其存储在参数槽中 `num`缩写形式。|  
  
 堆栈转换行为顺序如下：  
  
1.  将弹出当前位于堆栈顶部的值并将其放入参数槽位 `num`。  
  
 `starg.s` 指令从堆栈中弹出一个值，并将其放在参数槽中 `num`。 值的类型必须与当前方法的签名中指定的参数的类型匹配。  
  
 `starg.s` 指令提供了一个有效的编码以便与前256个参数一起使用。  
  
 对于采用变量参数列表的过程，`starg.s` 指令只能用于初始固定参数，而不能用于签名的变量部分。  
  
 如果将存储区的参数保留为小于4个字节的整数值，则会在从堆栈移到参数时截断值。 浮点值从其本机大小（类型 `F`）舍入到与参数关联的大小。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `starg.s` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Byte%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈中的值替换给定索引处的数组元素，其类型在指令中指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|A4 < `T` >|stelem `typeTok`|将所提供索引处的数组元素替换为堆栈上的类型 `typeTok` 的值。|  
  
 堆栈转换行为顺序如下：  
  
1.  对数组 `array`的对象引用被推送到堆栈上。  
  
2.  将索引值 `index`到 `array` 中的元素推送到堆栈上。  
  
3.  指令中指定的类型的值被推送到堆栈上。  
  
4.  从堆栈中弹出值、索引和数组引用;将值放入给定索引处的数组元素。  
  
 `stelem` 指令用值替换一维 `array` 数组中提供的从零开始的索引处的元素的值。 值具有指令中的标记所指定的类型 `typeTok`。  
  
 数组是对象，因此由 `O`类型的值表示。 索引的类型 `native int`。  
  
 如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。  
  
 如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。  
  
 如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stelem` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的 <see langword="native int" /> 值替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|9B|stelem。 i|将所提供索引处的数组元素替换为堆栈上的 `native int` 值。|  
  
 堆栈转换行为顺序如下：  
  
1.  对数组 `array`的对象引用被推送到堆栈上。  
  
2.  将 `array` 中的元素的有效索引推送到堆栈上。  
  
3.  将值推送到堆栈上。  
  
4.  从堆栈中弹出值、索引和数组引用;将值放入给定索引处的数组元素。  
  
 `stelem.i` 指令替换一维数组中 `index` 元素的值 `array`，并将 `native int` 值推送到堆栈上。  
  
 数组是对象，因此由 `O`类型的值表示。 索引的类型 `native int`。  
  
 如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。  
  
 如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。  
  
 如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stelem.i` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的 <see langword="int8" /> 值替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|9C|stelem.i1|将所提供索引处的数组元素替换为堆栈上的 `int8` 值。|  
  
 堆栈转换行为顺序如下：  
  
1.  对数组 `array`的对象引用被推送到堆栈上。  
  
2.  将 `array` 中的元素的有效索引推送到堆栈上。  
  
3.  将值推送到堆栈上。  
  
4.  从堆栈中弹出值、索引和数组引用;将值放入给定索引处的数组元素。  
  
 `stelem.i1` 指令替换一维数组中 `index` 元素的值 `array`，并将 `int8` 值推送到堆栈上。  
  
 数组是对象，因此由 `O`类型的值表示。 索引的类型 `native int`。  
  
 如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。  
  
 如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。  
  
 如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stelem.i1` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的 <see langword="int16" /> 值替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|9D|stelem.i2|将所提供索引处的数组元素替换为堆栈上的 `int16` 值。|  
  
 堆栈转换行为顺序如下：  
  
1.  对数组 `array`的对象引用被推送到堆栈上。  
  
2.  将 `array` 中的元素的有效索引推送到堆栈上。  
  
3.  将值推送到堆栈上。  
  
4.  从堆栈中弹出值、索引和数组引用;将值放入给定索引处的数组元素。  
  
 `stelem.i2` 指令替换一维数组中 `index` 元素的值 `array`，并将 `int16` 值推送到堆栈上。  
  
 数组是对象，因此由 `O`类型的值表示。 索引的类型 `native int`。  
  
 如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。  
  
 如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。  
  
 如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stelem.i2` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的 <see langword="int32" /> 值替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|9E|stelem.i4|将所提供索引处的数组元素替换为堆栈上的 `int32` 值。|  
  
 堆栈转换行为顺序如下：  
  
1.  对数组 `array`的对象引用被推送到堆栈上。  
  
2.  将 `array` 中的元素的有效索引推送到堆栈上。  
  
3.  将值推送到堆栈上。  
  
4.  从堆栈中弹出值、索引和数组引用;将值放入给定索引处的数组元素。  
  
 `stelem.i4` 指令替换一维数组中 `index` 元素的值 `array`，并将 `int32` 值推送到堆栈上。  
  
 数组是对象，因此由 `O`类型的值表示。 索引的类型 `native int`。  
  
 如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。  
  
 如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。  
  
 如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stelem.i4` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的 <see langword="int64" /> 值替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|9F|stelem.i8|将所提供索引处的数组元素替换为堆栈上的 `int64` 值。|  
  
 堆栈转换行为顺序如下：  
  
1.  对数组 `array`的对象引用被推送到堆栈上。  
  
2.  将 `array` 中的元素的有效索引推送到堆栈上。  
  
3.  将值推送到堆栈上。  
  
4.  从堆栈中弹出值、索引和数组引用;将值放入给定索引处的数组元素。  
  
 `stelem.i8` 指令替换一维数组中 `index` 元素的值 `array`，并将 `int64` 值推送到堆栈上。  
  
 数组是对象，因此由 `O`类型的值表示。 索引的类型 `native int`。  
  
 如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。  
  
 如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。  
  
 如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stelem.i8` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的 <see langword="float32" /> 值替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|A0|stelem.r4|将所提供索引处的数组元素替换为堆栈上的 `float32` 值。|  
  
 堆栈转换行为顺序如下：  
  
1.  对数组 `array`的对象引用被推送到堆栈上。  
  
2.  将 `array` 中的元素的有效索引推送到堆栈上。  
  
3.  将值推送到堆栈上。  
  
4.  从堆栈中弹出值、索引和数组引用;将值放入给定索引处的数组元素。  
  
 `stelem.r4` 指令替换一维数组中 `index` 元素的值 `array`，并将 `float32` 值推送到堆栈上。  
  
 数组是对象，因此由 `O`类型的值表示。 索引的类型 `native int`。  
  
 如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。  
  
 如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。  
  
 如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stelem.r4` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的 <see langword="float64" /> 值替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|A1|stelem.r8|将所提供索引处的数组元素替换为堆栈上的 `float64` 值。|  
  
 堆栈转换行为顺序如下：  
  
1.  对数组 `array`的对象引用被推送到堆栈上。  
  
2.  将 `array` 中的元素的有效索引推送到堆栈上。  
  
3.  将值推送到堆栈上。  
  
4.  从堆栈中弹出值、索引和数组引用;将值放入给定索引处的数组元素。  
  
 `stelem.r8` 指令替换一维数组中 `index` 元素的值 `array`，并将 `float64` 值推送到堆栈上。  
  
 数组是对象，因此由 `O`类型的值表示。 索引的类型 `native int`。  
  
 如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。  
  
 如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。  
  
 如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stelem.r8` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的对象 ref 值（<see langword="O" /> 类型）替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|A2|stelem.ref|将所提供索引处的数组元素替换为堆栈上的 `ref` 值（类型 `O`）。|  
  
 堆栈转换行为顺序如下：  
  
1.  对数组 `array`的对象引用被推送到堆栈上。  
  
2.  将 `array` 中的元素的有效索引推送到堆栈上。  
  
3.  将值推送到堆栈上。  
  
4.  从堆栈中弹出值、索引和数组引用;将值放入给定索引处的数组元素。  
  
 `stelem.ref` 指令替换一维数组中所提供索引处的元素的值 `array` 并将 `ref` （类型 `O`）值推送到堆栈上。  
  
 数组是对象，因此由 `O`类型的值表示。 索引的类型 `native int`。  
  
 请注意，在为数组元素赋值之前，`stelem.ref` 会将提供的值隐式转换为 `array` 的元素类型。 此强制转换可能会失败，即使对于已验证的代码也是如此。 因此 `stelem.ref` 指令可能会引发 <xref:System.InvalidCastException>。 对于不是从零开始的一维数组和多维数组，<xref:System.Array> 类提供 <xref:System.Array.SetValue%2A> 方法。  
  
 如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。  
  
 如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。  
  
 如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stelem.ref` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用新值替换在对象引用或指针的字段中存储的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|7D < `T` >|stfld `field`|将对象 `field` 的值替换为新值。|  
  
 堆栈转换行为顺序如下：  
  
1.  对象引用或指针被推送到堆栈上。  
  
2.  将值推送到堆栈上。  
  
3.  从堆栈中弹出值和对象引用/指针;对象中 `field` 的值将替换为提供的值。  
  
 `stfld` 指令替换对象（类型 `O`）的字段的值，或通过具有给定值的指针（类型 `native int`、`&`或 `*`）替换。 `Field` 是引用字段成员引用的元数据标记。 `stfld` 指令可以具有 <xref:System.Reflection.Emit.OpCodes.Unaligned> 和 <xref:System.Reflection.Emit.OpCodes.Volatile>的一个或两个前缀。  
  
 如果对象引用或指针为空引用，并且该字段不是静态的，则会引发 <xref:System.NullReferenceException>。  
  
 如果在元数据中找不到 `field`，则会引发 <xref:System.MissingFieldException>。 当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是运行时，通常会检查此情况。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stfld` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.FieldInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的地址存储 <see langword="native int" /> 类型的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|DF|stind。 i|将 `native int` 值存储在给定地址。|  
  
 堆栈转换行为顺序如下：  
  
1.  地址被推送到堆栈上。  
  
2.  将值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址;值存储在地址上。  
  
 `stind.i` 指令将 `native int` 值存储在所提供的地址（类型 `native int`、`*`或 `&`）上。  
  
 类型安全操作要求 `stind.i` 指令的使用方式与指针的类型一致。 `stind.i` 指令的操作可以通过紧挨着 <xref:System.Reflection.Emit.OpCodes.Volatile> 或 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀指令来更改。  
  
 如果对于指令后缀隐含的参数类型，`addr` 不是自然对齐的，则会引发 <xref:System.NullReferenceException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stind.i` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的地址存储 <see langword="int8" /> 类型的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|52|stind|将 `int8` 值存储在给定地址。|  
  
 堆栈转换行为顺序如下：  
  
1.  地址被推送到堆栈上。  
  
2.  将值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址;值存储在地址上。  
  
 `stind.i1` 指令将 `int8` 值存储在所提供的地址（类型 `native int`、`*`或 `&`）上。  
  
 类型安全操作要求 `stind.i1` 指令的使用方式与指针的类型一致。 `stind.i1` 指令的操作可以通过紧挨着 <xref:System.Reflection.Emit.OpCodes.Volatile> 或 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀指令来更改。  
  
 如果对于指令后缀隐含的参数类型，`addr` 不是自然对齐的，则会引发 <xref:System.NullReferenceException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stind.i1` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的地址存储 <see langword="int16" /> 类型的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|53|stind|将 `int16` 值存储在给定地址。|  
  
 堆栈转换行为顺序如下：  
  
1.  地址被推送到堆栈上。  
  
2.  将值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址;值存储在地址上。  
  
 `stind.i2` 指令将 `int16` 值存储在所提供的地址（类型 `native int`、`*`或 `&`）上。  
  
 类型安全操作要求 `stind.2i` 指令的使用方式与指针的类型一致。 `stind.i2` 指令的操作可以通过紧挨着 <xref:System.Reflection.Emit.OpCodes.Volatile> 或 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀指令来更改。  
  
 如果对于指令后缀隐含的参数类型，`addr` 不是自然对齐的，则会引发 <xref:System.NullReferenceException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stind.i2` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的地址存储 <see langword="int32" /> 类型的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|54|stind. i4|将 `int32` 值存储在给定地址。|  
  
 堆栈转换行为顺序如下：  
  
1.  地址被推送到堆栈上。  
  
2.  将值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址;值存储在地址上。  
  
 `stind.i4` 指令将 `int32` 值存储在所提供的地址（类型 `native int`、`*`或 `&`）上。  
  
 类型安全操作要求 `stind.i4` 指令的使用方式与指针的类型一致。 `stind.i4` 指令的操作可以通过紧挨着 <xref:System.Reflection.Emit.OpCodes.Volatile> 或 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀指令来更改。  
  
 如果对于指令后缀隐含的参数类型，`addr` 不是自然对齐的，则会引发 <xref:System.NullReferenceException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stind.i4` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的地址存储 <see langword="int64" /> 类型的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|55|stind. i8|将 `int64` 值存储在给定地址。|  
  
 堆栈转换行为顺序如下：  
  
1.  地址被推送到堆栈上。  
  
2.  将值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址;值存储在地址上。  
  
 `stind.i8` 指令将 `int64` 值存储在所提供的地址（类型 `native int`、`*`或 `&`）上。  
  
 类型安全操作要求 `stind.i8` 指令的使用方式与指针的类型一致。 `stind.i` 指令的操作可以通过紧挨着 <xref:System.Reflection.Emit.OpCodes.Volatile> 或 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀指令来更改。  
  
 如果对于指令后缀隐含的参数类型，`addr` 不是自然对齐的，则会引发 <xref:System.NullReferenceException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stind.i8` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的地址存储 <see langword="float32" /> 类型的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|56|stind.r4|将 `float32` 值存储在给定地址。|  
  
 堆栈转换行为顺序如下：  
  
1.  地址被推送到堆栈上。  
  
2.  将值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址;值存储在地址上。  
  
 `stind.r4` 指令将 `float32` 值存储在所提供的地址（类型 `native int`、`*`或 `&`）上。  
  
 类型安全操作要求 `stind.r4` 指令的使用方式与指针的类型一致。 `stind.r4` 指令的操作可以通过紧挨着 <xref:System.Reflection.Emit.OpCodes.Volatile> 或 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀指令来更改。  
  
 如果对于指令后缀隐含的参数类型，`addr` 不是自然对齐的，则会引发 <xref:System.NullReferenceException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stind.r4` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的地址存储 <see langword="float64" /> 类型的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|57|stind. r8|将 `float64` 值存储在给定地址。|  
  
 堆栈转换行为顺序如下：  
  
1.  地址被推送到堆栈上。  
  
2.  将值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址;值存储在地址上。  
  
 `stind.r8` 指令将 `float64` 值存储在所提供的地址（类型 `native int`、`*`或 `&`）上。  
  
 类型安全操作要求 `stind.r8` 指令的使用方式与指针的类型一致。 `stind.r8` 指令的操作可以通过紧挨着 <xref:System.Reflection.Emit.OpCodes.Volatile> 或 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀指令来更改。  
  
 如果对于指令后缀隐含的参数类型，`addr` 不是自然对齐的，则会引发 <xref:System.NullReferenceException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stind.r8` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>存储所提供地址处的对象引用值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|51|stind.ref|将对象引用（类型 `O`）值存储在给定地址。|  
  
 堆栈转换行为顺序如下：  
  
1.  地址被推送到堆栈上。  
  
2.  将值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址;值存储在地址上。  
  
 `stind.ref` 指令将对象引用值存储在所提供的地址（类型 `native int`、`*`或 `&`）上。  
  
 类型安全操作要求 `stind.ref` 指令的使用方式与指针的类型一致。 `stind.ref` 指令的操作可以通过紧挨着 <xref:System.Reflection.Emit.OpCodes.Volatile> 或 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀指令来更改。  
  
 如果对于指令后缀隐含的参数类型，`addr` 不是自然对齐的，则会引发 <xref:System.NullReferenceException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stind.ref` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从计算堆栈的顶部弹出当前值并将其存储到指定索引处的局部变量列表中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 0E < `unsigned int16` >|stloc `index`|从堆栈中弹出一个值并将其存储在本地变量 `index`中。|  
  
 堆栈转换行为顺序如下：  
  
1.  将从堆栈中弹出一个值并将其放入本地变量 `index`中。  
  
 `stloc` 指令从计算堆栈中弹出顶部值，并将其移到局部变量号 `index`，其中局部变量从0开始编号。 值的类型必须与当前方法本地签名中指定的局部变量的类型匹配。  
  
 如果存储在保持小于4个字节的整数值的局部变量中，长时间将在从堆栈移到局部变量时截断值。 浮点值从其本机大小（类型 `F`）舍入到与参数关联的大小。  
  
 更正 Microsoft 中间语言（MSIL）指令需要 `index` 是有效的本地索引。 对于 `stloc` 指令，`index` 必须在0到65534的范围内（具体而言，65535是无效的）。 排除65535的原因是实际的：可能的实现将使用2字节整数跟踪本地的索引，以及给定方法的局部变量总数。 如果已将65535的索引设为有效，则需要更宽的整数来跟踪此类方法中的局部变量的数目。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stloc` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.LocalBuilder%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Int16%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从计算堆栈的顶部弹出当前值并将其存储到索引 0 处的局部变量列表中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|0A|stloc.0|将值从堆栈中弹出到局部变量0中。|  
  
 堆栈转换行为顺序如下：  
  
1.  从堆栈中弹出一个值，并将其放入索引为0的局部变量。  
  
 `stloc.0` 指令从计算堆栈中弹出顶部值，并将其移动到索引为0的局部变量中。 值的类型必须与当前方法本地签名中指定的局部变量的类型匹配。  
  
 `stloc.0` 是一种非常有效的编码，用于在局部变量0中存储值。  
  
 如果存储在保持小于4个字节的整数值的局部变量中，长时间将在从堆栈移到局部变量时截断值。 浮点值从其本机大小（类型 `F`）舍入到与参数关联的大小。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stloc.0` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从计算堆栈的顶部弹出当前值并将其存储到索引 1 处的局部变量列表中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|0B|stloc.1|将值从堆栈中弹出到局部变量1中。|  
  
 堆栈转换行为顺序如下：  
  
1.  从堆栈中弹出一个值，并将其放入索引为1的局部变量。  
  
 `stloc.1` 指令从计算堆栈中弹出顶部值，并将其移动到索引为1的本地变量中。 值的类型必须与当前方法本地签名中指定的局部变量的类型匹配。  
  
 `stloc.1` 是一种非常有效的编码方式，用于将值存储在本地变量1中。  
  
 如果存储在保持小于4个字节的整数值的局部变量中，长时间将在从堆栈移到局部变量时截断值。 浮点值从其本机大小（类型 `F`）舍入到与参数关联的大小。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stloc.1` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从计算堆栈的顶部弹出当前值并将其存储到索引 2 处的局部变量列表中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|0C|stloc.2|将值从堆栈中弹出到局部变量2中|  
  
 堆栈转换行为顺序如下：  
  
1.  从堆栈中弹出一个值，并将其放入索引为2的局部变量中。  
  
 `stloc.2` 指令从计算堆栈中弹出顶部值，并将其移动到索引为2的局部变量中。 值的类型必须与当前方法本地签名中指定的局部变量的类型匹配。  
  
 `stloc.2` 是一种非常有效的编码，用于在局部变量2中存储值。  
  
 如果存储在保持小于4个字节的整数值的局部变量中，长时间将在从堆栈移到局部变量时截断值。 浮点值从其本机大小（类型 `F`）舍入到与参数关联的大小。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stloc.2` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从计算堆栈的顶部弹出当前值并将其存储到索引 3 处的局部变量列表中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|0D|stloc.3|从堆栈中弹出一个值到局部变量3|  
  
 堆栈转换行为顺序如下：  
  
1.  从堆栈中弹出一个值，并将其放入索引为3的局部变量。  
  
 `stloc.3` 指令从计算堆栈中弹出顶部值，并将其移动到索引为3的本地变量中。 值的类型必须与当前方法本地签名中指定的局部变量的类型匹配。  
  
 `stloc.3` 是一种非常有效的编码，用于在局部变量3中存储值。  
  
 如果存储在保持小于4个字节的整数值的局部变量中，长时间将在从堆栈移到局部变量时截断值。 浮点值从其本机大小（类型 `F`）舍入到与参数关联的大小。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stloc.3` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从计算堆栈的顶部弹出当前值并将其存储在局部变量列表中的 <paramref name="index" /> 处（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|13 < `unsigned int8` >|stloc `index`|从堆栈中弹出一个值并将其存储在本地变量 `index`中，即缩写形式。|  
  
 堆栈转换行为顺序如下：  
  
1.  将从堆栈中弹出一个值并将其放入本地变量 `index`中。  
  
 `stloc.s` 指令从计算堆栈中弹出顶部值，并将其移到局部变量号 `index`，其中局部变量从0开始编号。 值的类型必须与当前方法本地签名中指定的局部变量的类型匹配。  
  
 `stloc.s` 指令为局部变量0到255提供有效编码。  
  
 如果存储在保持小于4个字节的整数值的局部变量中，长时间将在从堆栈移到局部变量时截断值。 浮点值从其本机大小（类型 `F`）舍入到与参数关联的大小。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stloc.s` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.LocalBuilder%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Byte%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将指定类型的值从计算堆栈复制到所提供的内存地址中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|81 < `T` >|stobj `class`|将类型 `class` 的值存储在内存中。|  
  
 堆栈转换行为顺序如下：  
  
1.  地址被推送到堆栈上。  
  
2.  类型 `class` 的值类型对象被推送到堆栈上。  
  
3.  从堆栈中弹出对象和地址;值类型对象存储在地址上。  
  
 `stobj` 指令将值类型对象复制到地址指定的地址（`native int`、`*`或 `&`类型的指针）。 已复制的字节数取决于 `class`（表示值类型的元数据标记）所表示的类的大小。  
  
 `stobj` 指令的操作可以通过紧挨着 <xref:System.Reflection.Emit.OpCodes.Volatile> 或 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀指令来更改。  
  
 如果找不到类，则会引发 <xref:System.TypeLoadException>。 当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是运行时，通常会检测到此情况。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stobj` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用来自计算堆栈的值替换静态字段的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|80 < `T` >|stsfld `field`|将 `field` 中的值替换为提供的值。|  
  
 堆栈转换行为顺序如下：  
  
1.  将值推送到堆栈上。  
  
2.  从堆栈中弹出一个值并将其存储在 `field`中。  
  
 `stsfld` 指令用来自堆栈的值替换静态字段的值。 `field` 是必须引用静态字段成员的元数据标记。  
  
 `stsfld` 指令可能以 <xref:System.Reflection.Emit.OpCodes.Volatile>为前缀。  
  
 如果在元数据中找不到字段，则会引发 <xref:System.MissingFieldException>。 当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是在运行时，通常会检查此情况。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stsfld` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.FieldInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从其他值中减去一个值并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|59|sub|从一个值中减去另一个值，返回新的数值。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;从 `value1`中减去 `value2`。  
  
4.  将结果推送到堆栈上。  
  
 未检测到用于整数运算的溢出（有关正确的溢出处理，请参阅 <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>）。  
  
 整数减法环绕，而不是尽量充满。 例如：假设8位整数，其中 `value1` 设置为0，并且 `value2` 设置为1，则 "已包装" 结果将为255。  
  
 浮点溢出返回 `+inf` （`PositiveInfinity`）或 `-inf` （`NegativeInfinity`）。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `sub` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从另一值中减去一个整数值，执行溢出检查，并且将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|DA|sub.ovf|使用溢出检查从一个整数值中减去另一个整数值。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;将从 `value1` 中减去 `value2`，并检查是否有溢出。  
  
4.  将结果推送到堆栈上。  
  
 如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。  
  
 此操作在有符号整数上执行;对于浮点值，请使用 <xref:System.Reflection.Emit.OpCodes.Sub>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `sub.ovf` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从另一值中减去一个无符号整数值，执行溢出检查，并且将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|DB|sub.ovf.un|使用溢出检查从一个无符号整数值减去另一个无符号整数值。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  从堆栈中弹出 `value2` 和 `value1`;将从 `value1` 中减去 `value2`，并检查是否有溢出。  
  
4.  将结果推送到堆栈上。  
  
 如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。  
  
 此操作在有符号整数上执行;对于浮点值，请使用 <xref:System.Reflection.Emit.OpCodes.Sub>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `sub.ovf.un` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>实现跳转表。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|45 < `unsigned int32` > < `int32` > .。。< `int32` >|switch （`N`、`t1`、`t2`... `tN`）|跳转到 `N` 值之一。|  
  
 堆栈转换行为顺序如下：  
  
1.  将值推送到堆栈上。  
  
2.  该值将从堆栈中弹出，并按照值索引的偏移量将执行转移到指令，其中值小于 `N`。  
  
 `switch` 指令实现跳转表。 指令的格式是表示目标 `N`数量的 `unsigned int32`，后跟指定跳转目标 `N` int32 值。 这些目标在此 `switch` 指令后面的指令开头表示为偏移量（正或负）。  
  
 `switch` 指令从堆栈中弹出一个值，并将其作为无符号整数进行比较，以 `N`。 如果 value 小于 `N`，则将执行转移到按值索引的目标，其中目标从0开始编号（例如，值0采用第一个目标，值为1，则使用第二个目标，依此类推）。 如果该值大于或等于 `N`，则继续执行下一条指令（贯穿）。  
  
 如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。  
  
 此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。 （此类传输受到严格限制，因此必须改用 leave 指令）。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `switch` 操作码。 `Label[]` 参数是表示32位偏移量的标签数组。  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%5B%5D%29?displayProperty=nameWithType>  
  
   
  
## Examples  
 下面的代码示例演示如何使用 `Switch` 操作码来使用 <xref:System.Reflection.Emit.Label>的数组生成跳转表。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>执行后缀的方法调用指令，以便在执行实际调用指令前移除当前方法的堆栈帧。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 14|侧.|后续调用终止当前方法|  
  
 没有为此指令定义堆栈转换行为。  
  
 `tail` 前缀指令必须紧跟 <xref:System.Reflection.Emit.OpCodes.Call>、<xref:System.Reflection.Emit.OpCodes.Calli>或 <xref:System.Reflection.Emit.OpCodes.Callvirt> 指令之前。 它指示在执行调用指令之前应移除当前方法的堆栈帧。 它还意味着从以下调用返回的值也是当前方法返回的值，因此可以将调用转换为交叉方法跳转。  
  
 堆栈必须为空，但通过以下调用传输的参数除外。 调用指令后面的指令必须是 ret。因此，唯一有效的代码序列是 `tail. call` （或 `calli` 或 `callvirt`）。 更正 Microsoft 中间语言（MSIL）指令不能分支到 `call` 指令，但是它们可能会分支到后续的 <xref:System.Reflection.Emit.OpCodes.Ret>。  
  
 如果控件从不受信任的代码传输到受信任的代码，则无法放弃当前帧，因为这会危及代码标识安全性。 因此 .NET Framework 安全检查可能会导致 `tail` 被忽略，而保留标准 <xref:System.Reflection.Emit.OpCodes.Call> 指令。 同样，若要允许在调用返回后退出已同步的区域，则在用于退出标记为已同步的方法时，将忽略 `tail` 前缀。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `tail` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">操作码对象的实例。</param>
        <summary>如果提供的操作码采用单字节自变量则返回真或假。</summary>
        <returns><see langword="true" /> 或 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可用于查找要在优化代码中使用的 MSIL 操作码为 "短格式"。  
  
 如果 <xref:System.Reflection.Emit.OpCode> 实例在以下情况下使用单个字节参数，`TakesSingleByteArgument` 将返回 `true`：  
  
-   操作码对字节大小的地址（例如 <xref:System.Reflection.Emit.OpCodes.Br_S> 和 <xref:System.Reflection.Emit.OpCodes.Bgt_S>）执行分支指令。  
  
-   操作码将一个字节值推送到堆栈上（例如 <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>）。  
  
-   操作码通过大小为字节大小的 "缩写" （例如 <xref:System.Reflection.Emit.OpCodes.Ldloc_S> 和 <xref:System.Reflection.Emit.OpCodes.Stloc_S>）来引用变量或参数。  
  
 否则，它将返回 `false`。  
  
 下面的示例演示了如何使用 `TakesSingleByteArgument`，方法是反射到 `OpCodes` 类并进行测试，以查看每个 `OpCode` 字段是否采用单字节参数。  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>引发当前位于计算堆栈上的异常对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|7A|throw|引发异常。|  
  
 堆栈转换行为顺序如下：  
  
1.  将对象引用（对异常）推送到堆栈上。  
  
2.  从堆栈中弹出对象引用并引发异常。  
  
 `throw` 指令引发当前堆栈上的异常对象（类型 `O`）。  
  
 如果对象引用为空引用，则会引发 <xref:System.NullReferenceException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `throw` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示当前位于计算堆栈上的地址可能没有与紧接的 <see langword="ldind" />、<see langword="stind" />、<see langword="ldfld" />、<see langword="stfld" />、<see langword="ldobj" />、<see langword="stobj" />、<see langword="initblk" /> 或 <see langword="cpblk" /> 指令的自然大小对齐。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 12 < `unsigned int8` >|未对齐. `alignment`|指示后面的指针指令可能是不对齐的。|  
  
 堆栈转换行为顺序如下：  
  
1.  地址被推送到堆栈上。  
  
 `Unaligned` 指定堆栈上的地址（非托管指针、`native int`）可能不会与紧随其后 `ldind`、`stind`、`ldfld`、`stfld`、`ldobj`、`stobj`、`initblk`或 `cpblk` 指令的自然大小对齐。 也就是说，对于 <xref:System.Reflection.Emit.OpCodes.Ldind_I4> 说明地址的对齐方式可能不是4字节边界。 对于 `initblk` 和 `cpblk` 默认对齐方式取决于体系结构依赖（32位 Cpu 上的4个字节，64位 Cpu 上的8个字节）。 如果在编译时不知道对齐方式为8字节，则不会将其输出限制为32位 word 的代码生成器必须使用 `unaligned`。  
  
 "对齐" 的值必须是1、2或4，这意味着生成的代码应分别假定地址是字节、双字节或4字节对齐。 请注意，临时指针（类型 `*`）始终对齐。  
  
 尽管 `cpblk` 指令的对齐在逻辑上需要两个数字（一个用于源，另一个用于目标），但如果只指定了较小的数字，则对性能没有明显影响。  
  
 可以按任意顺序组合 `unaligned` 和 `volatile` 前缀。 它们必须紧跟在 `ldind`、`stind`、`ldfld`、`stfld`、`ldobj`、`stobj`、`initblk`或 `cpblk` 指令之前。 对于 <xref:System.Reflection.Emit.OpCodes.Ldsfld> 和 <xref:System.Reflection.Emit.OpCodes.Stsfld> 说明，只允许使用 <xref:System.Reflection.Emit.OpCodes.Volatile> 前缀。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `unaligned` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Byte%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将值类型的已装箱的表示形式转换为其未装箱的形式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|79 < `T` >|取消装箱 `valType`|从 `obj`（其装箱表示形式）中提取值类型数据。|  
  
 堆栈转换行为顺序如下：  
  
1.  对象引用被推送到堆栈上。  
  
2.  从堆栈中弹出对象引用，并取消装箱到值类型指针。  
  
3.  值类型指针被推送到堆栈上。  
  
 值类型在公共语言基础结构（CLI）中具有两种不同的表示形式：  
  
-   当值类型嵌入到另一个对象中时使用的 "原始" 窗体。  
  
-   "装箱" 窗体，其中值类型中的数据被包装（装箱）到对象中，因此它可以作为独立实体存在。  
  
 `unbox` 指令将对象引用（类型 `O`）、值类型的装箱表示形式转换为值类型指针（托管指针、类型 `&`）、其未装箱形式。 提供的值类型（`valType`）是一个元数据标记，用于指示装箱对象中包含的值类型类型。  
  
 与 <xref:System.Reflection.Emit.OpCodes.Box>（这是复制值类型以在对象中使用所必需的），不需要 `unbox` 从对象复制值类型。 通常，它只是计算装箱对象内已存在的值类型的地址。  
  
 如果对象未装箱为 `valType`，则会引发 <xref:System.InvalidCastException>。  
  
 如果对象引用为空引用，则会引发 <xref:System.NullReferenceException>。  
  
 如果找不到值类型 `valType`，则会引发 <xref:System.TypeLoadException>。 当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是运行时，通常会检测到此情况。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `unbox` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将指令中指定类型的已装箱的表示形式转换成未装箱形式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|A5 < `T` >|取消装箱。任意 `typeTok`|从 `obj`（其装箱表示形式）中提取数据。|  
  
 堆栈转换行为顺序如下：  
  
1.  对象引用 `obj` 被推送到堆栈上。  
  
2.  从堆栈中弹出对象引用，并取消装箱到指令中指定的类型。  
  
3.  生成的对象引用或值类型被推送到堆栈上。  
  
 当应用于值类型的装箱形式时，`unbox.any` 指令提取 `obj` 内包含的值（类型 `O`），因此等效于 `unbox` 后跟 `ldobj`。  
  
 当应用于引用类型时，`unbox.any` 指令与 `castclass` `typeTok`具有相同的效果。  
  
 如果操作数 `typeTok` 是泛型类型参数，则运行时行为取决于为该泛型类型参数指定的类型。  
  
 如果 `obj` 不是装箱类型，则会引发 <xref:System.InvalidCastException>。  
  
 如果 `obj` 为空引用，则会引发 <xref:System.NullReferenceException>。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `unbox.any` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定当前位于计算堆栈顶部的地址可以是易失的，并且读取该位置的结果不能被缓存，或者对该地址的多个存储区不能被取消。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 13|失效.|指示后续指针引用是可变的。|  
  
 堆栈转换行为顺序如下：  
  
1.  地址被推送到堆栈上。  
  
 `volatile`。 指定该地址是一个可变地址（即，可以从外部引用到当前执行线程），并且无法缓存读取该位置的结果，或者无法禁止显示此位置的多个存储。 将访问标记为 `volatile` 仅影响单一访问权限;必须单独标记对同一位置的其他访问。 不需要以原子方式执行对可变位置的访问。  
  
 可以按任意顺序组合 <xref:System.Reflection.Emit.OpCodes.Unaligned> 和 `volatile` 前缀。 它们必须紧跟在 `ldind`、`stind`、`ldfld`、`stfld`、`ldobj`、`stobj`、`initblk`或 `cpblk` 指令之前。 对于 <xref:System.Reflection.Emit.OpCodes.Ldsfld> 和 <xref:System.Reflection.Emit.OpCodes.Stsfld> 说明，只允许使用 `volatile` 前缀。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `volatile` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>计算位于计算堆栈顶部的两个值的按位异或，并且将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|61|xor|计算两个整数值的按位 XOR 并返回整数。|  
  
 堆栈转换行为顺序如下：  
  
1.  将 `value1` 推送到堆栈上。  
  
2.  将 `value2` 推送到堆栈上。  
  
3.  `value2` 和 `value1` 从堆栈中弹出，并计算按位 XOR。  
  
4.  将 `value2` 和 `value1` 的按位 XOR 推送到堆栈上。  
  
 `xor` 指令计算堆栈顶部两个值的按位 XOR，并将结果保留在堆栈上。  
  
 `Xor` 是特定于整数的操作。  
  
 以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `xor` 操作码：  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
