<Type Name="XmlSchemaSet" FullName="System.Xml.Schema.XmlSchemaSet">
  <Metadata><Meta Name="ms.openlocfilehash" Value="715ad4b548d7c767ca8d80797b7a392d8caa1b65" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86605369" /></Metadata><TypeSignature Language="C#" Value="public class XmlSchemaSet" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlSchemaSet extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Schema.XmlSchemaSet" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlSchemaSet" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlSchemaSet" />
  <TypeSignature Language="F#" Value="type XmlSchemaSet = class" />
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Xml.ReaderWriter" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>包含 XML 架构定义语言 (XSD) 架构的缓存。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
> -   不要使用来自未知或不受信任的源或位置的架构。 这样做会破坏代码的安全性。  
> -   XML 架构 (包括内联架构) 在本质上容易受到拒绝服务攻击;不要在不受信任的情况下接受它们。  
> -   架构验证错误消息和异常可能会向架构文件公开有关内容模型或 URI 路径的敏感信息。 请注意不要向不受信任的调用方公开此信息。  
> -   "安全注意事项" 部分中介绍了其他安全注意事项。  
  
 <xref:System.Xml.Schema.XmlSchemaSet> 是一个缓存或库，您可以在其中存储 XML 架构定义语言 (XSD) 架构。 <xref:System.Xml.Schema.XmlSchemaSet> 通过将架构缓存在内存中，而不是从文件或 URL 访问架构，从而提高性能。 每个架构都由命名空间 URI 和架构被添加到该集时指定的位置标识。 使用 <xref:System.Xml.XmlReaderSettings.Schemas%2A?displayProperty=nameWithType> 属性可分配 <xref:System.Xml.Schema.XmlSchemaSet> XML 读取器用于数据验证的对象。  
  
## <a name="security-considerations"></a>安全注意事项  
  
-   不要使用来自未知或不受信任的源的架构。 这样做会破坏代码的安全性。 在架构的包含、导入和重新定义元素中引用的外部命名空间或位置是根据包含或导入这些元素的架构的基本 URI 解析的。 例如，如果包含或导入架构的基本 URI 为空或 `null` ，则相对于当前目录解析外部位置。 <xref:System.Xml.XmlUrlResolver>默认情况下，类用于解析外部架构。 若要对架构的 include、import 和 redefine 元素禁用解析，请将 <xref:System.Xml.Schema.XmlSchemaSet.XmlResolver%2A?displayProperty=nameWithType> 属性设置为 `null` 。  
  
-   <xref:System.Xml.Schema.XmlSchemaSet>类使用 <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> 类在 XML 架构中分析和匹配正则表达式。 在 XML 架构中使用正则表达式验证模式方面可能会涉及到增加的 CPU 使用率，并且应避免在高可用性方案中使用。  
  
-   由于使用类而引发的异常 <xref:System.Xml.Schema.XmlSchemaSet> ，例如 <xref:System.Xml.Schema.XmlSchemaException> 类可能包含不应在不受信任的方案中公开的敏感信息。 例如，的 <xref:System.Xml.Schema.XmlSchemaException.SourceUri%2A> 属性将 <xref:System.Xml.Schema.XmlSchemaException> 返回引发异常的架构文件的 URI 路径。 <xref:System.Xml.Schema.XmlSchemaException.SourceUri%2A>不应在不受信任的方案中公开属性。 应正确处理异常，以便不受信任的情况下不公开此敏感信息。  
  
   
  
## Examples  
 以下示例使用 <xref:System.Xml.Schema.XmlSchemaSet> 中存储的架构验证 XML 文件。 XML 文件 `urn:bookstore-schema` 中的命名空间标识 <xref:System.Xml.Schema.XmlSchemaSet> 中要用于验证的架构。 该示例的输出显示 XML 文件有两个架构冲突：

 - 第一个 \<book> 元素包含 \<author> 元素，但不包含 \<title> 或 \<price> 元素。

 - \<author>最后一个元素中的元素 \<book> 缺少 \<first-name> and \<last-name> 元素，而具有无效的 \<name> 元素。   
  
 [!code-cpp[XmlReader_Validate_SchemaSet#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlReader_Validate_SchemaSet/CPP/XmlReader_Validate_SchemaSet.cpp#1)]
 [!code-csharp[XmlReader_Validate_SchemaSet#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Validate_SchemaSet/CS/validschemaset.cs#1)]
 [!code-vb[XmlReader_Validate_SchemaSet#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Validate_SchemaSet/VB/validschemaset.vb#1)]  
  
## <a name="input"></a>输入  
 示例使用下列两个输入文件。  
  
 **booksSchemaFail.xml：**  
  
 [!code-xml[XmlReader_Validate_SchemaSet#2](~/samples/snippets/xml/VS_Snippets_Data/XmlReader_Validate_SchemaSet/XML/booksschemafail.xml#2)]  
  
 **书籍 .xsd：**  
  
 [!code-xml[XmlReader_Validate_SchemaSet#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReader_Validate_SchemaSet/XML/books.xsd#3)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlSchemaSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.XmlSchemaSet.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlSchemaSet();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlSchemaSet (System.Xml.XmlNameTable nameTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlNameTable nameTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.XmlSchemaSet.#ctor(System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (nameTable As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlSchemaSet(System::Xml::XmlNameTable ^ nameTable);" />
      <MemberSignature Language="F#" Value="new System.Xml.Schema.XmlSchemaSet : System.Xml.XmlNameTable -&gt; System.Xml.Schema.XmlSchemaSet" Usage="new System.Xml.Schema.XmlSchemaSet nameTable" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="nameTable" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="nameTable">要使用的 <see cref="T:System.Xml.XmlNameTable" /> 对象。</param>
        <summary>使用指定的 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 初始化 <see cref="T:System.Xml.XmlNameTable" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">作为参数传递的 <see cref="T:System.Xml.XmlNameTable" /> 对象为 <see langword="null" />。</exception>
        <altmember cref="T:System.Xml.XmlNameTable" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将给定的 XML 架构定义语言 (XSD) 架构添加到 <see cref="T:System.Xml.Schema.XmlSchemaSet" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public System.Xml.Schema.XmlSchema Add (System.Xml.Schema.XmlSchema schema);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.Schema.XmlSchema Add(class System.Xml.Schema.XmlSchema schema) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.XmlSchemaSet.Add(System.Xml.Schema.XmlSchema)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (schema As XmlSchema) As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::Schema::XmlSchema ^ Add(System::Xml::Schema::XmlSchema ^ schema);" />
      <MemberSignature Language="F#" Value="member this.Add : System.Xml.Schema.XmlSchema -&gt; System.Xml.Schema.XmlSchema" Usage="xmlSchemaSet.Add schema" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schema" Type="System.Xml.Schema.XmlSchema" />
      </Parameters>
      <Docs>
        <param name="schema">添加到 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 的 <see cref="T:System.Xml.Schema.XmlSchema" /> 对象。</param>
        <summary>将指定的 <see cref="T:System.Xml.Schema.XmlSchema" /> 添加到 <see cref="T:System.Xml.Schema.XmlSchemaSet" />。</summary>
        <returns>如果架构有效，则为 <see cref="T:System.Xml.Schema.XmlSchema" /> 对象。 如果架构无效且指定了 <see cref="T:System.Xml.Schema.ValidationEventHandler" />，则将返回 <see langword="null" /> 并引发适当的验证事件。 否则会引发 <see cref="T:System.Xml.Schema.XmlSchemaException" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 <xref:System.Xml.Schema.XmlSchema> 中已存在对象 <xref:System.Xml.Schema.XmlSchemaSet> ，则此 <xref:System.Xml.Schema.XmlSchemaSet.Add%2A> 方法不执行任何操作。  
  
 此方法的功能与方法的功能相同 <xref:System.Xml.Schema.XmlSchemaSet.Add%2A> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaException">该架构无效。</exception>
        <exception cref="T:System.ArgumentNullException">作为参数传递的 <see cref="T:System.Xml.Schema.XmlSchema" /> 对象为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (System.Xml.Schema.XmlSchemaSet schemas);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(class System.Xml.Schema.XmlSchemaSet schemas) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.XmlSchemaSet.Add(System.Xml.Schema.XmlSchemaSet)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (schemas As XmlSchemaSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::Xml::Schema::XmlSchemaSet ^ schemas);" />
      <MemberSignature Language="F#" Value="member this.Add : System.Xml.Schema.XmlSchemaSet -&gt; unit" Usage="xmlSchemaSet.Add schemas" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemas" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemas"><see cref="T:System.Xml.Schema.XmlSchemaSet" /> 对象。</param>
        <summary>将给定的 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 中的所有 XML 架构定义语言 (XSD) 架构添加到 <see cref="T:System.Xml.Schema.XmlSchemaSet" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在将架构添加到之前，必须 <xref:System.Xml.Schema.XmlSchemaSet> 对其进行成功的预处理。 预处理执行以下基本任务。  
  
1.  根据 W3C XML 架构的规则检查架构的结构有效性，但架构未完全验证。  
  
2.  解析对内部和外部架构组件的引用。 已成功检索的任何导入或包含的架构也会添加到中 <xref:System.Xml.Schema.XmlSchemaSet> 。 导入的架构被添加为单独 <xref:System.Xml.Schema.XmlSchema> 的对象，并且包含的架构构成包括在内的部分 <xref:System.Xml.Schema.XmlSchema> 。  
  
 如果 <xref:System.Xml.Schema.XmlSchemaSet.IsCompiled%2A> 要添加的的属性 <xref:System.Xml.Schema.XmlSchemaSet> 为，则将 `true` 添加中的所有架构添加 <xref:System.Xml.Schema.XmlSchemaSet> 到中 <xref:System.Xml.Schema.XmlSchemaSet> 。 如果 <xref:System.Xml.Schema.XmlSchemaSet.IsCompiled%2A> 要添加的属性 <xref:System.Xml.Schema.XmlSchemaSet> 为，则添加的 `false` 每个架构都将进行预处理。 如果新添加的任何架构无法进行 <xref:System.Xml.Schema.XmlSchemaSet> 预处理，则不会添加任何架构; 相反， <xref:System.Xml.Schema.XmlSchemaException> 将引发。 因此，下面两个代码示例是不等效的。  
  
```vb  
' First example  
schemaSet.Add(schemaSet1)  
  
' Second example  
Dim schema As XmlSchema  
  
For Each schema in schemaSet.Schemas()  
  
    schemaSet.Add(schema)  
  
Next  
```  
  
```csharp  
// First example  
schemaSet.Add(schemaSet1);  
  
// Second example  
foreach(XmlSchema schema in schemaSet.Schemas())  
{  
    schemaSet.Add(schema);  
}  
```  
  
 前面的两个代码示例并不是等效的。 在第一个示例中，如果中存在无效的架构， `schemaSet1` 并且其 <xref:System.Xml.Schema.XmlSchemaSet.IsCompiled%2A> 属性设置为 `false` ，则不会将任何架构添加到中 `schemaSet` 。 在第二个示例中，可能会在遇到无效的架构之前添加多个架构， `schemaSet` 并引发异常。  
  
   
  
## Examples  
 下面的代码示例演示如何将架构添加到 <xref:System.Xml.Schema.XmlSchemaSet> ，然后 <xref:System.Xml.Schema.XmlSchemaSet> 使用方法将添加到新的中 <xref:System.Xml.Schema.XmlSchemaSet> <xref:System.Xml.Schema.XmlSchemaSet.Add%2A> 。  
  
```vb  
Dim schemaSet1 As XmlSchemaSet = New XmlSchemaSet  
schemaSet1.Add("http://www.contoso.com/retail", "http://www.contoso.com/retail.xsd")  
schemaSet1.Add("http://www.contoso.com/books", "http://www.contoso.com/books.xsd")  
schemaSet1.Add("http://www.contoso.com/music", "http://www.contoso.com/music.xsd")  
  
Dim schemaSet2 As XmlSchemaSet = New XmlSchemaSet  
schemaSet2.Add(schemaSet1)  
```  
  
```csharp  
XmlSchemaSet schemaSet1 = new XmlSchemaSet();  
schemaSet1.Add("http://www.contoso.com/retail", "http://www.contoso.com/retail.xsd");  
schemaSet1.Add("http://www.contoso.com/books", "http://www.contoso.com/books.xsd");  
schemaSet1.Add("http://www.contoso.com/music", "http://www.contoso.com/music.xsd");  
  
XmlSchemaSet schemaSet2 = new XmlSchemaSet();  
schemaSet2.Add(schemaSet1);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaException"><see cref="T:System.Xml.Schema.XmlSchemaSet" /> 中的架构无效。</exception>
        <exception cref="T:System.ArgumentNullException">作为参数传递的 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 对象为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public System.Xml.Schema.XmlSchema Add (string targetNamespace, string schemaUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.Schema.XmlSchema Add(string targetNamespace, string schemaUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.XmlSchemaSet.Add(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (targetNamespace As String, schemaUri As String) As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::Schema::XmlSchema ^ Add(System::String ^ targetNamespace, System::String ^ schemaUri);" />
      <MemberSignature Language="F#" Value="member this.Add : string * string -&gt; System.Xml.Schema.XmlSchema" Usage="xmlSchemaSet.Add (targetNamespace, schemaUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetNamespace" Type="System.String" />
        <Parameter Name="schemaUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetNamespace">架构的 <paramref name="targetNamespace" /> 属性或 <see langword="null" /> 以使用架构中指定的 <paramref name="targetNamespace" />。</param>
        <param name="schemaUri">指定要加载的架构的 URL。</param>
        <summary>将位于指定 URL 的 XML 架构定义语言 (XSD) 架构添加到 <see cref="T:System.Xml.Schema.XmlSchemaSet" />。</summary>
        <returns>如果架构有效，则为 <see cref="T:System.Xml.Schema.XmlSchema" /> 对象。 如果架构无效且指定了 <see cref="T:System.Xml.Schema.ValidationEventHandler" />，则将返回 <see langword="null" /> 并引发适当的验证事件。 否则会引发 <see cref="T:System.Xml.Schema.XmlSchemaException" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在将架构添加到之前，必须 <xref:System.Xml.Schema.XmlSchemaSet> 对其进行成功的预处理。 预处理执行以下基本任务。  
  
1.  根据 W3C XML 架构的规则检查架构的结构有效性，但架构未完全验证。  
  
2.  解析对内部和外部架构组件的引用。 已成功检索的任何导入或包含的架构也会添加到中 <xref:System.Xml.Schema.XmlSchemaSet> 。 导入的架构被添加为单独 <xref:System.Xml.Schema.XmlSchema> 的对象，并且包含的架构构成包括在内的部分 <xref:System.Xml.Schema.XmlSchema> 。  
  
 以下是使用方法时要考虑的重要注意事项 <xref:System.Xml.Schema.XmlSchemaSet.Add%2A> 。  
  
-   如果将架构添加到 <xref:System.Xml.Schema.XmlSchemaSet> 具有相同目标命名空间和架构位置的 URL，则 <xref:System.Xml.Schema.XmlSchemaSet> 将返回原始架构对象。  
  
-   将新架构成功添加到后 <xref:System.Xml.Schema.XmlSchemaSet> ， <xref:System.Xml.Schema.XmlSchemaSet.IsCompiled%2A> 的属性将 <xref:System.Xml.Schema.XmlSchemaSet> 设置为 `false` 。  
  
-   调用方法时，将解析 XML 架构中遇到的任何 include 或 import 元素 <xref:System.Xml.Schema.XmlSchemaSet.Add%2A> 。 如果无法解析 include 和 import 元素，则会导致架构验证警告，如果未 <xref:System.Xml.Schema.XmlSchemaSet.ValidationEventHandler> 为 <xref:System.Xml.Schema.XmlSchemaSet> 对象指定，则不会报告这些警告。  
  
-   如果将具有与中已存在的架构相同的目标命名空间的架构 <xref:System.Xml.Schema.XmlSchemaSet> 添加到，则 <xref:System.Xml.Schema.XmlSchemaSet> 这两个架构都将添加。  
  
    > [!NOTE]
    >  此行为与过时的 <xref:System.Xml.Schema.XmlSchemaCollection> 对象不同。  
  
-   的 <xref:System.Xml.Schema.XmlSchemaSet.Add%2A> 方法 <xref:System.Xml.Schema.XmlSchemaSet> 能够使用架构中定义的目标命名空间，而不需要在调用方法时将目标命名空间指定为参数 <xref:System.Xml.Schema.XmlSchemaSet.Add%2A> 。 `null`在方法的参数中指定将 `targetNamespace` <xref:System.Xml.Schema.XmlSchemaSet.Add%2A> 指示 <xref:System.Xml.Schema.XmlSchemaSet> 使用架构中定义的目标命名空间，如以下代码示例中所示。  
  
```vb  
Dim schemaSet As XmlSchemaSet = New XmlSchemaSet()  
schemaSet.Add(Nothing, "books.xsd")  
  
Dim schema As XmlSchema  
For Each schema In schemaSet.Schemas("http://www.contoso.com/books")  
    schema.Write(Console.Out)  
Next  
```  
  
```csharp  
XmlSchemaSet schemaSet = new XmlSchemaSet();  
schemaSet.Add(null, "books.xsd");  
  
foreach(XmlSchema schema in schemaSet.Schemas("http://www.contoso.com/books"))  
{  
    schema.Write(Console.Out);  
}  
```  
  
 在上面的代码示例中， `null` 将指定为 `targetNamespace` 方法的参数 <xref:System.Xml.Schema.XmlSchemaSet.Add%2A> 。 因此，将 `targetNamespace` 使用 books.xml 文件中定义的。 在这种情况下， <xref:System.Xml.Schema.XmlSchemaSet.Add%2A> 如果 `http://www.contoso.com/books` 已将指定为参数，则调用方法的结果将相同 `targetNamespace` 。  
  
-   W3C XML 架构允许在定义了目标命名空间的架构中包含无目标命名空间的架构。 在这种情况下，未定义目标命名空间的架构被强制转换为包含架构的目标命名空间。 包含的架构被视为已定义该目标命名空间。 同样，没有目标命名空间的架构可以添加到 <xref:System.Xml.Schema.XmlSchemaSet> 并强制转换为方法指定的目标命名空间 <xref:System.Xml.Schema.XmlSchemaSet.Add%2A> ，如以下示例中所示。  
  
```  
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">  
    <xs:element name="A" type="xs:string" />  
</xs:schema>  
```  
  
 如果上面的架构添加到 <xref:System.Xml.Schema.XmlSchemaSet> 具有目标命名空间的， `http://www.contoso.com/new/targetnamespace` (如下面的代码所示) ，则将其视为在架构中声明的目标命名空间为 `http://www.contoso.com/new/targetnamespace` 。  
  
```vb  
Dim schemaSet As XmlSchemaSet = New XmlSchemaSet()  
schemaSet.Add("http://www.contoso.com/new/targetnamespace", "http://www.contoso.com/targetnamespace.xsd")  
  
Dim schema As XmlSchema  
  
For Each schema in schemaSet.Schemas()  
  
    Console.WriteLine(schema.TargetNamespace)     
  
Next  
```  
  
```csharp  
XmlSchemaSet schemaSet = new XmlSchemaSet();  
schemaSet.Add("http://www.contoso.com/new/targetnamespace", "http://www.contoso.com/targetnamespace.xsd");  
foreach(XmlSchema schema in schemaSet.Schemas())  
{  
    Console.WriteLine(schema.TargetNamespace);  
}  
```  
  
   
  
## Examples  
 下面的代码示例将 `http://www.contoso.com/books.xsd` 具有目标命名空间的架构添加 `http://www.contoso.com/books` 到 <xref:System.Xml.Schema.XmlSchemaSet> 。  
  
```vb  
Dim schemaSet As XmlSchemaSet = New XmlSchemaSet()  
schemaSet.Add("http://www.contoso.com/books", "http://www.contoso.com/books.xsd")  
```  
  
```csharp  
XmlSchemaSet schemaSet = new XmlSchemaSet();  
schemaSet.Add("http://www.contoso.com/books", "http://www.contoso.com/books.xsd");  
```  
  
 示例使用 `books.xsd` 文件作为输入。  
  
 [!code-xml[XmlSchemaSetOverall Example#3](~/samples/snippets/xml/VS_Snippets_Data/XmlSchemaSetOverall Example/XML/books.xsd#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaException">该架构无效。</exception>
        <exception cref="T:System.ArgumentNullException">作为参数传递的 URL 为 <see langword="null" /> 或 <see cref="F:System.String.Empty" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public System.Xml.Schema.XmlSchema Add (string targetNamespace, System.Xml.XmlReader schemaDocument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.Schema.XmlSchema Add(string targetNamespace, class System.Xml.XmlReader schemaDocument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.XmlSchemaSet.Add(System.String,System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (targetNamespace As String, schemaDocument As XmlReader) As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::Schema::XmlSchema ^ Add(System::String ^ targetNamespace, System::Xml::XmlReader ^ schemaDocument);" />
      <MemberSignature Language="F#" Value="member this.Add : string * System.Xml.XmlReader -&gt; System.Xml.Schema.XmlSchema" Usage="xmlSchemaSet.Add (targetNamespace, schemaDocument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetNamespace" Type="System.String" />
        <Parameter Name="schemaDocument" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="targetNamespace">架构的 <paramref name="targetNamespace" /> 属性或 <see langword="null" /> 以使用架构中指定的 <paramref name="targetNamespace" />。</param>
        <param name="schemaDocument"><see cref="T:System.Xml.XmlReader" /> 对象。</param>
        <summary>将 <see cref="T:System.Xml.XmlReader" /> 中包含的 XML 架构定义语言 (XSD) 架构添加到 <see cref="T:System.Xml.Schema.XmlSchemaSet" />。</summary>
        <returns>如果架构有效，则为 <see cref="T:System.Xml.Schema.XmlSchema" /> 对象。 如果架构无效且指定了 <see cref="T:System.Xml.Schema.ValidationEventHandler" />，则将返回 <see langword="null" /> 并引发适当的验证事件。 否则会引发 <see cref="T:System.Xml.Schema.XmlSchemaException" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在将架构添加到之前，必须 <xref:System.Xml.Schema.XmlSchemaSet> 对其进行成功的预处理。 预处理执行以下基本任务。  
  
1.  根据 W3C XML 架构的规则检查架构的结构有效性，但架构未完全验证。  
  
2.  解析对内部和外部架构组件的引用。 已成功检索的任何导入或包含的架构也会添加到中 <xref:System.Xml.Schema.XmlSchemaSet> 。 导入的架构被添加为单独 <xref:System.Xml.Schema.XmlSchema> 的对象，并且包含的架构构成包括在内的部分 <xref:System.Xml.Schema.XmlSchema> 。  
  
 以下是使用方法时要考虑的重要注意事项 <xref:System.Xml.Schema.XmlSchemaSet.Add%2A> 。  
  
-   如果成功检索到中包含的架构导入或包含的架构， <xref:System.Xml.XmlReader> 还会将添加到中 <xref:System.Xml.Schema.XmlSchemaSet> 。  
  
-   如果 <xref:System.Xml.XmlReader> 未定位在根元素上， <xref:System.Xml.Schema.XmlSchemaException> 则会引发，除非当前项是一个元素。 如果当前项是一个 `xs:schema` 元素，则将架构文档读入 <xref:System.Xml.Schema.XmlSchemaSet> ; 否则， <xref:System.Xml.Schema.XmlSchemaException> 将引发，因为该架构无效。  
  
-   如果位于 <xref:System.Xml.XmlReader> XML 节点序列上，则只添加序列中的第一个节点。  
  
-   如果架构是通过 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 方法调用创建的，则忽略属性的值 <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema> ，因为不会对 W3C XML 架构文档应用内联架构处理。  
  
-   <xref:System.Xml.XmlResolver>的属性 <xref:System.Xml.XmlReader> 不用于解析对 include 和 import 元素中的命名空间或架构位置的引用。 相反， <xref:System.Xml.XmlResolver> 使用的属性 <xref:System.Xml.Schema.XmlSchemaSet> 。  
  
-   的 <xref:System.Xml.Schema.XmlSchemaSet.Add%2A> 方法 <xref:System.Xml.Schema.XmlSchemaSet> 能够使用架构中定义的目标命名空间，而不需要在调用方法时将目标命名空间指定为参数 <xref:System.Xml.Schema.XmlSchemaSet.Add%2A> 。 如果将 `null` 或指定 <xref:System.String.Empty?displayProperty=nameWithType> 为方法，将 <xref:System.Xml.Schema.XmlSchemaSet.Add%2A> 指示 <xref:System.Xml.Schema.XmlSchemaSet> 使用架构中定义的目标命名空间。 有关此行为的示例，请参见 <xref:System.Xml.Schema.XmlSchemaSet.Add%2A> 方法。  
  
 此方法的其余功能与方法的功能相同 <xref:System.Xml.Schema.XmlSchemaSet.Add%2A> 。  
  
   
  
## Examples  
 下面的代码示例将包含在中的、包含的目标命名空间的 books.xml 架构添加 <xref:System.Xml.XmlTextReader> `http://www.contoso.com/books` 到中 <xref:System.Xml.Schema.XmlSchemaSet> 。  
  
```vb  
Dim schemaSet As XmlSchemaSet = New XmlSchemaSet()  
schemaSet.Add("http://www.contoso.com/books", New XmlTextReader("books.xsd")  
```  
  
```csharp  
XmlSchemaSet schemaSet = new XmlSchemaSet();  
schemaSet.Add("http://www.contoso.com/books", new XmlTextReader("books.xsd");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaException">该架构无效。</exception>
        <exception cref="T:System.ArgumentNullException">作为参数传递的 <see cref="T:System.Xml.XmlReader" /> 对象为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="CompilationSettings">
      <MemberSignature Language="C#" Value="public System.Xml.Schema.XmlSchemaCompilationSettings CompilationSettings { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.XmlSchemaCompilationSettings CompilationSettings" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Schema.XmlSchemaSet.CompilationSettings" />
      <MemberSignature Language="VB.NET" Value="Public Property CompilationSettings As XmlSchemaCompilationSettings" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Schema::XmlSchemaCompilationSettings ^ CompilationSettings { System::Xml::Schema::XmlSchemaCompilationSettings ^ get(); void set(System::Xml::Schema::XmlSchemaCompilationSettings ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CompilationSettings : System.Xml.Schema.XmlSchemaCompilationSettings with get, set" Usage="System.Xml.Schema.XmlSchemaSet.CompilationSettings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaCompilationSettings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Xml.Schema.XmlSchemaCompilationSettings" /> 的 <see cref="T:System.Xml.Schema.XmlSchemaSet" />。</summary>
        <value><see cref="T:System.Xml.Schema.XmlSchemaCompilationSettings" /> 的 <see cref="T:System.Xml.Schema.XmlSchemaSet" />。 默认为 <see cref="T:System.Xml.Schema.XmlSchemaCompilationSettings" /> 属性设置为 <see langword="true" /> 的 <see cref="P:System.Xml.Schema.XmlSchemaCompilationSettings.EnableUpaCheck" /> 实例。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.Schema.XmlSchemaCompilationSettings>类为指定了唯一粒子归属 (UPA) 验证选项 <xref:System.Xml.Schema.XmlSchemaSet> 。 有关启用 UPA 验证检查的详细信息，请参阅 <xref:System.Xml.Schema.XmlSchemaCompilationSettings.EnableUpaCheck%2A> 属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Compile">
      <MemberSignature Language="C#" Value="public void Compile ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Compile() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.XmlSchemaSet.Compile" />
      <MemberSignature Language="VB.NET" Value="Public Sub Compile ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Compile();" />
      <MemberSignature Language="F#" Value="member this.Compile : unit -&gt; unit" Usage="xmlSchemaSet.Compile " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将添加到 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 的 XML 架构定义语言 (XSD) 架构编译成一个逻辑架构。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当需要验证并且 <xref:System.Xml.Schema.XmlSchemaSet> 以前未编译时（例如，当 <xref:System.Xml.Schema.XmlSchemaSet> 用作 <xref:System.Xml.XmlReader> 在对象的属性中创建对象的输入时），将自动调用此方法 <xref:System.Xml.Schema.XmlSchemaSet.Schemas%2A> <xref:System.Xml.XmlReaderSettings> 。 如果已 <xref:System.Xml.Schema.XmlSchemaSet> 处于已编译状态，此方法将不会重新编译架构。 如果此方法成功执行，则将 <xref:System.Xml.Schema.XmlSchemaSet.IsCompiled%2A> 属性设置为 `true` 。  
  
 之前由编译的架构 <xref:System.Xml.Schema.XmlSchemaSet> 不会重新编译。 但是，使用的方法编译的架构 <xref:System.Xml.Schema.XmlSchemaSet.Compile%2A> <xref:System.Xml.Schema.XmlSchema> 将被重新编译。  
  
> [!NOTE]
>  <xref:System.Xml.Schema.XmlSchemaSet.Reprocess%2A>如果在将架构添加到之后更改了架构 (或它的其中一个包含/导入) ，则需要调用方法 <xref:System.Xml.Schema.XmlSchemaSet> 。 <xref:System.Xml.Schema.XmlSchemaSet.Reprocess%2A>根据 W3C XML 架构的规则，方法将检查架构的结构有效性。 但是，它不会执行完全验证检查。 它还将解析对内部和外部架构组件的引用。 已成功检索的任何导入或包含的架构也会添加到中 <xref:System.Xml.Schema.XmlSchemaSet> 。 导入的架构将作为单独的对象添加， <xref:System.Xml.Schema.XmlSchema> 同时包含的架构将成为包括在内的部分 <xref:System.Xml.Schema.XmlSchema> 。 如果对重新处理的调用成功，则将 <xref:System.Xml.Schema.XmlSchemaSet.IsCompiled%2A> 属性设置为 false。  
  
   
  
## Examples  
  
```vb  
Dim schemaSet As XmlSchemaSet = New XmlSchemaSet()  
schemaSet.Add("http://www.contoso.com/books", "http://www.contoso.com/books.xsd")  
schemaSet.Compile()  
```  
  
```csharp  
XmlSchemaSet schemaSet = new XmlSchemaSet();  
schemaSet.Add("http://www.contoso.com/books", "http://www.contoso.com/books.xsd");  
schemaSet.Compile();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaException">当验证和编译 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 中的架构时发生错误。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Contains">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指示 XML 架构定义语言 (XSD) 架构是否位于 <see cref="T:System.Xml.Schema.XmlSchemaSet" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string targetNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string targetNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.XmlSchemaSet.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (targetNamespace As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ targetNamespace);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="xmlSchemaSet.Contains targetNamespace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetNamespace">架构 <paramref name="targetNamespace" /> 属性。</param>
        <summary>指示具有指定目标命名空间 URI 的 XML 架构定义语言 (XSD) 架构是否位于 <see cref="T:System.Xml.Schema.XmlSchemaSet" />。</summary>
        <returns>如果具有指定目标命名空间 URI 的架构位于 <see cref="T:System.Xml.Schema.XmlSchemaSet" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 间接添加到中的架构 <xref:System.Xml.Schema.XmlSchemaSet> 由方法检测到 <xref:System.Xml.Schema.XmlSchemaSet.Contains%2A> ，例如导入的架构。 因此，如果命名空间的架构 `http://www.contoso.com/retail` `http://www.contoso.com/books` 已添加到，则会将命名空间的架构添加到 <xref:System.Xml.Schema.XmlSchemaSet> ，并将 <xref:System.Xml.Schema.XmlSchemaSet.Contains%2A> `http://www.contoso.com/books` 作为参数调用，它将返回 `true` 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Xml.Schema.XmlSchema schema);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(class System.Xml.Schema.XmlSchema schema) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.XmlSchemaSet.Contains(System.Xml.Schema.XmlSchema)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (schema As XmlSchema) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Xml::Schema::XmlSchema ^ schema);" />
      <MemberSignature Language="F#" Value="member this.Contains : System.Xml.Schema.XmlSchema -&gt; bool" Usage="xmlSchemaSet.Contains schema" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schema" Type="System.Xml.Schema.XmlSchema" />
      </Parameters>
      <Docs>
        <param name="schema"><see cref="T:System.Xml.Schema.XmlSchema" /> 对象。</param>
        <summary>指示指定的 XML 架构定义语言 (XSD) <see cref="T:System.Xml.Schema.XmlSchema" /> 对象是否位于 <see cref="T:System.Xml.Schema.XmlSchemaSet" />。</summary>
        <returns>如果 <see cref="T:System.Xml.Schema.XmlSchema" /> 对象在 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 中，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">作为参数传递的 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.Xml.Schema.XmlSchema[] schemas, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Xml.Schema.XmlSchema[] schemas, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.XmlSchemaSet.CopyTo(System.Xml.Schema.XmlSchema[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (schemas As XmlSchema(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;System::Xml::Schema::XmlSchema ^&gt; ^ schemas, int index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.Xml.Schema.XmlSchema[] * int -&gt; unit" Usage="xmlSchemaSet.CopyTo (schemas, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemas" Type="System.Xml.Schema.XmlSchema[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="schemas">要向其复制对象的数组。</param>
        <param name="index">数组中开始复制处的索引。</param>
        <summary>将 <see cref="T:System.Xml.Schema.XmlSchema" /> 中的所有 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 对象复制到起始位置为给定索引的给定数组中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例将 <xref:System.Xml.Schema.XmlSchema> 中的所有对象复制 <xref:System.Xml.Schema.XmlSchemaSet> 到对象的数组中 <xref:System.Xml.Schema.XmlSchema> 。  
  
```vb  
Dim schemaSet As XmlSchemaSet = New XmlSchemaSet  
schemaSet.Add("http://www.contoso.com/retail", "http://www.contoso.com/retail.xsd")  
schemaSet.Add("http://www.contoso.com/books", "http://www.contoso.com/books.xsd")  
schemaSet.Add("http://www.contoso.com/music", "http://www.contoso.com/music.xsd")  
  
Dim schemas(schemaSet.Count) As XmlSchema  
schemaSet.CopyTo(schemas, 0)  
```  
  
```csharp  
XmlSchemaSet schemaSet = new XmlSchemaSet();  
schemaSet.Add("http://www.contoso.com/retail", "http://www.contoso.com/retail.xsd");  
schemaSet.Add("http://www.contoso.com/books", "http://www.contoso.com/books.xsd");  
schemaSet.Add("http://www.contoso.com/music", "http://www.contoso.com/music.xsd");  
  
XmlSchema[] schemas = new XmlSchema[schemaSet.Count];  
schemaSet.CopyTo(schemas, 0);  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Schema.XmlSchemaSet.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Xml.Schema.XmlSchemaSet.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 中逻辑 XML 架构定义语言 (XSD) 架构的数量。</summary>
        <value><see cref="T:System.Xml.Schema.XmlSchemaSet" /> 中的逻辑架构数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果中有两个命名空间的架构 `http://www.contoso.com` <xref:System.Xml.Schema.XmlSchemaSet> ，则 <xref:System.Xml.Schema.XmlSchemaSet.Count%2A> 属性将返回1，因为架构被视为用于验证目的的单个逻辑架构。 但是，如果命名空间的架构 `http://www.contoso.com/retail` 导入了 `http://www.contoso.com/books` 命名空间的架构，则该属性的值将 <xref:System.Xml.Schema.XmlSchemaSet.Count%2A> 为2。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalAttributes">
      <MemberSignature Language="C#" Value="public System.Xml.Schema.XmlSchemaObjectTable GlobalAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.XmlSchemaObjectTable GlobalAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Schema.XmlSchemaSet.GlobalAttributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalAttributes As XmlSchemaObjectTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Schema::XmlSchemaObjectTable ^ GlobalAttributes { System::Xml::Schema::XmlSchemaObjectTable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalAttributes : System.Xml.Schema.XmlSchemaObjectTable" Usage="System.Xml.Schema.XmlSchemaSet.GlobalAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaObjectTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 中所有 XML 架构定义语言 (XSD) 架构的所有全局特性。</summary>
        <value>属性特性的集合。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Xml.Schema.XmlSchemaSet.GlobalElements" />
        <altmember cref="P:System.Xml.Schema.XmlSchemaSet.GlobalTypes" />
        <altmember cref="T:System.Xml.Schema.XmlSchemaObjectTable" />
      </Docs>
    </Member>
    <Member MemberName="GlobalElements">
      <MemberSignature Language="C#" Value="public System.Xml.Schema.XmlSchemaObjectTable GlobalElements { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.XmlSchemaObjectTable GlobalElements" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Schema.XmlSchemaSet.GlobalElements" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalElements As XmlSchemaObjectTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Schema::XmlSchemaObjectTable ^ GlobalElements { System::Xml::Schema::XmlSchemaObjectTable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalElements : System.Xml.Schema.XmlSchemaObjectTable" Usage="System.Xml.Schema.XmlSchemaSet.GlobalElements" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaObjectTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 中所有 XML 架构定义语言 (XSD) 架构的所有全局元素。</summary>
        <value>全局元素的集合。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Xml.Schema.XmlSchemaSet.GlobalTypes" />
        <altmember cref="P:System.Xml.Schema.XmlSchemaSet.GlobalAttributes" />
        <altmember cref="T:System.Xml.Schema.XmlSchemaObjectTable" />
      </Docs>
    </Member>
    <Member MemberName="GlobalTypes">
      <MemberSignature Language="C#" Value="public System.Xml.Schema.XmlSchemaObjectTable GlobalTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.XmlSchemaObjectTable GlobalTypes" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Schema.XmlSchemaSet.GlobalTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalTypes As XmlSchemaObjectTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Schema::XmlSchemaObjectTable ^ GlobalTypes { System::Xml::Schema::XmlSchemaObjectTable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalTypes : System.Xml.Schema.XmlSchemaObjectTable" Usage="System.Xml.Schema.XmlSchemaSet.GlobalTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaObjectTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 中所有 XML 架构定义语言 (XSD) 架构的所有全局简单和复杂类型。</summary>
        <value>全局简单和复杂类型的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.Schema.XmlSchemaSet.GlobalTypes%2A>属性始终返回表示 `xs:anyType` 复杂类型的类型。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xml.Schema.XmlSchemaSet.GlobalElements" />
        <altmember cref="P:System.Xml.Schema.XmlSchemaSet.GlobalAttributes" />
        <altmember cref="T:System.Xml.Schema.XmlSchemaObjectTable" />
      </Docs>
    </Member>
    <Member MemberName="IsCompiled">
      <MemberSignature Language="C#" Value="public bool IsCompiled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompiled" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Schema.XmlSchemaSet.IsCompiled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompiled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompiled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompiled : bool" Usage="System.Xml.Schema.XmlSchemaSet.IsCompiled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值指示 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 中的 XML 架构定义语言 (XSD) 架构是否已编译的值。</summary>
        <value>如果 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 中的架构自上次在 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 中添加或移除以来已被编译，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果架构在 <xref:System.Xml.Schema.XmlSchemaSet.IsCompiled%2A> 中编辑，<xref:System.Xml.Schema.XmlSchemaSet> 属性不受影响。 不跟踪对 <xref:System.Xml.Schema.XmlSchemaSet> 中各个架构的更新。 因此，只要 <xref:System.Xml.Schema.XmlSchemaSet.IsCompiled%2A> 中没有添加或移除任何架构，即使 `true` 中包含的一个架构已更改，<xref:System.Xml.Schema.XmlSchemaSet> 属性也可以为 <xref:System.Xml.Schema.XmlSchemaSet>。  
  
   
  
## Examples  
 有关属性的示例 <xref:System.Xml.Schema.XmlSchemaSet.IsCompiled%2A> ，请参见 <xref:System.Xml.Schema.XmlSchemaSet.Reprocess%2A> 方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Schema.XmlSchemaSet.Compile" />
        <altmember cref="M:System.Xml.Schema.XmlSchemaSet.Reprocess(System.Xml.Schema.XmlSchema)" />
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public System.Xml.XmlNameTable NameTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Schema.XmlSchemaSet.NameTable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NameTable As XmlNameTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlNameTable ^ NameTable { System::Xml::XmlNameTable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NameTable : System.Xml.XmlNameTable" Usage="System.Xml.Schema.XmlSchemaSet.NameTable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取加载新的 XML 架构定义语言 (XSD) 架构时 <see cref="T:System.Xml.XmlNameTable" /> 使用的默认 <see cref="T:System.Xml.Schema.XmlSchemaSet" />。</summary>
        <value>原子化字符串对象表。</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Xml.XmlNameTable" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Xml.Schema.XmlSchema Remove (System.Xml.Schema.XmlSchema schema);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.Schema.XmlSchema Remove(class System.Xml.Schema.XmlSchema schema) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.XmlSchemaSet.Remove(System.Xml.Schema.XmlSchema)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (schema As XmlSchema) As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::Schema::XmlSchema ^ Remove(System::Xml::Schema::XmlSchema ^ schema);" />
      <MemberSignature Language="F#" Value="member this.Remove : System.Xml.Schema.XmlSchema -&gt; System.Xml.Schema.XmlSchema" Usage="xmlSchemaSet.Remove schema" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schema" Type="System.Xml.Schema.XmlSchema" />
      </Parameters>
      <Docs>
        <param name="schema">要从 <see cref="T:System.Xml.Schema.XmlSchema" /> 中移除的 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 对象。</param>
        <summary>从 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 移除指定的 XML 架构定义语言 (XSD) 架构。</summary>
        <returns>从 <see cref="T:System.Xml.Schema.XmlSchema" /> 中移除的 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 对象，或如果在 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 中未找到该架构，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从中移除架构会 <xref:System.Xml.Schema.XmlSchemaSet> 将 <xref:System.Xml.Schema.XmlSchemaSet.IsCompiled%2A> 属性设置为 `false` 。  
  
   
  
## Examples  
 下面的示例演示如何将多个架构添加到 <xref:System.Xml.Schema.XmlSchemaSet> ，然后使用方法删除其中一个架构 <xref:System.Xml.Schema.XmlSchemaSet.Remove%2A> 。  
  
```vb  
Dim schemaSet As XmlSchemaSet = New XmlSchemaSet()  
schemaSet.Add("http://www.contoso.com/retail", "http://www.contoso.com/retail.xsd")  
schemaSet.Add("http://www.contoso.com/books", "http://www.contoso.com/books.xsd")  
schemaSet.Add("http://www.contoso.com/music", "http://www.contoso.com/music.xsd")  
  
Dim schema As XmlSchema  
  
For Each schema In schemaSet.Schemas()  
  
    If schema.TargetNamespace = "http://www.contoso.com/music" Then  
        schemaSet.Remove(schema)  
    End If  
  
Next  
```  
  
```csharp  
XmlSchemaSet schemaSet = new XmlSchemaSet();  
schemaSet.Add("http://www.contoso.com/retail", "http://www.contoso.com/retail.xsd");  
schemaSet.Add("http://www.contoso.com/books", "http://www.contoso.com/books.xsd");  
schemaSet.Add("http://www.contoso.com/music", "http://www.contoso.com/music.xsd");  
  
foreach (XmlSchema schema in schemaSet.Schemas())  
{  
    if (schema.TargetNamespace == "http://www.contoso.com/music")  
    {  
        schemaSet.Remove(schema);  
    }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaException">此架构不是有效的架构。</exception>
        <exception cref="T:System.ArgumentNullException">作为参数传递的 <see cref="T:System.Xml.Schema.XmlSchema" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveRecursive">
      <MemberSignature Language="C#" Value="public bool RemoveRecursive (System.Xml.Schema.XmlSchema schemaToRemove);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveRecursive(class System.Xml.Schema.XmlSchema schemaToRemove) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.XmlSchemaSet.RemoveRecursive(System.Xml.Schema.XmlSchema)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveRecursive (schemaToRemove As XmlSchema) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveRecursive(System::Xml::Schema::XmlSchema ^ schemaToRemove);" />
      <MemberSignature Language="F#" Value="member this.RemoveRecursive : System.Xml.Schema.XmlSchema -&gt; bool" Usage="xmlSchemaSet.RemoveRecursive schemaToRemove" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaToRemove" Type="System.Xml.Schema.XmlSchema" />
      </Parameters>
      <Docs>
        <param name="schemaToRemove">要从 <see cref="T:System.Xml.Schema.XmlSchema" /> 中移除的 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 对象。</param>
        <summary>从 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 中移除指定的 XML 架构定义语言 (XSD) 架构和它导入的所有架构。</summary>
        <returns>如果已成功移除 <see cref="T:System.Xml.Schema.XmlSchema" /> 对象和其导入的所有内容，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此 <xref:System.Xml.Schema.XmlSchemaSet.RemoveRecursive%2A> 方法从中删除指定的架构及其导入的所有架构 <xref:System.Xml.Schema.XmlSchemaSet> ，前提是架构或其导入的架构没有依赖项。 如果架构中存在依赖项或在中导入的架构 <xref:System.Xml.Schema.XmlSchemaSet> ，则不会删除任何内容，并 <xref:System.Xml.Schema.XmlSchemaSet.RemoveRecursive%2A> 返回 `false` 。 如果 `false` 返回了并定义了，则会将 <xref:System.Xml.Schema.XmlSchemaSet.ValidationEventHandler> 警告发送到描述依赖项的事件处理程序。  
  
 如果指定的架构导入了其他架构，并且以前通过方法移除了指定的架构 <xref:System.Xml.Schema.XmlSchemaSet.Remove%2A> ，则该 <xref:System.Xml.Schema.XmlSchemaSet.RemoveRecursive%2A> 方法将不会删除导入的架构并且将返回 `false` 。 例如，如果 `parentSchema` imports `childSchema1` 和 `childSchema2` 以下代码将仅删除 `parentSchema` ，而不会删除导入的 `childSchema1` 和 `childSchema2` 架构：  
  
```  
XmlSchemaSet ss = new XmlSchemaSet();  
XmlSchema xs = XmlSchema.Read(XmlReader.Create("parentSchema.xsd"), null);  
ss.Add(xs);  
ss.Compile();  
ss.Remove(xs);  
ss.Compile();  
ss.RemoveRecursive(xs);  
ss.Compile();  
```  
  
 下面的代码将删除 `parentSchema` 和导入的架构：  
  
```  
XmlSchemaSet ss = new XmlSchemaSet();  
XmlSchema xs = XmlSchema.Read(XmlReader.Create("parentSchema.xsd"), null);  
ss.Add(xs);  
ss.Compile();  
ss.RemoveRecursive(xs);  
ss.Compile();  
```  
  
 此 <xref:System.Xml.Schema.XmlSchemaSet.RemoveRecursive%2A> 方法对属性的状态没有影响 <xref:System.Xml.Schema.XmlSchemaSet.IsCompiled%2A> 。  
  
   
  
## Examples  
 下面的代码示例演示如何将多个架构添加到 <xref:System.Xml.Schema.XmlSchemaSet> ，然后使用方法删除其中一个架构及其导入的所有架构 <xref:System.Xml.Schema.XmlSchemaSet.RemoveRecursive%2A> 。  
  
```vb  
Dim schemaSet As XmlSchemaSet = New XmlSchemaSet()  
schemaSet.Add("http://www.contoso.com/retail", "http://www.contoso.com/retail.xsd")  
schemaSet.Add("http://www.contoso.com/books", "http://www.contoso.com/books.xsd")  
schemaSet.Add("http://www.contoso.com/music", "http://www.contoso.com/music.xsd")  
  
Dim schema As XmlSchema  
  
For Each schema In schemaSet.Schemas()  
  
    If schema.TargetNamespace = "http://www.contoso.com/music" Then  
        schemaSet.RemoveRecursive(schema)  
    End If  
  
Next  
```  
  
```csharp  
XmlSchemaSet schemaSet = new XmlSchemaSet();  
schemaSet.Add("http://www.contoso.com/retail", "http://www.contoso.com/retail.xsd");  
schemaSet.Add("http://www.contoso.com/books", "http://www.contoso.com/books.xsd");  
schemaSet.Add("http://www.contoso.com/music", "http://www.contoso.com/music.xsd");  
  
foreach (XmlSchema schema in schemaSet.Schemas())  
{  
    if (schema.TargetNamespace == "http://www.contoso.com/music")  
    {  
        schemaSet.RemoveRecursive(schema);  
    }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">作为参数传递的 <see cref="T:System.Xml.Schema.XmlSchema" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Reprocess">
      <MemberSignature Language="C#" Value="public System.Xml.Schema.XmlSchema Reprocess (System.Xml.Schema.XmlSchema schema);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.Schema.XmlSchema Reprocess(class System.Xml.Schema.XmlSchema schema) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.XmlSchemaSet.Reprocess(System.Xml.Schema.XmlSchema)" />
      <MemberSignature Language="VB.NET" Value="Public Function Reprocess (schema As XmlSchema) As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::Schema::XmlSchema ^ Reprocess(System::Xml::Schema::XmlSchema ^ schema);" />
      <MemberSignature Language="F#" Value="member this.Reprocess : System.Xml.Schema.XmlSchema -&gt; System.Xml.Schema.XmlSchema" Usage="xmlSchemaSet.Reprocess schema" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schema" Type="System.Xml.Schema.XmlSchema" />
      </Parameters>
      <Docs>
        <param name="schema">要重新处理的架构。</param>
        <summary>重新处理已经存在于 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 中的 XML 架构定义语言 (XSD) 架构。</summary>
        <returns>如果架构有效，则为 <see cref="T:System.Xml.Schema.XmlSchema" /> 对象。 如果架构无效且指定了 <see cref="T:System.Xml.Schema.ValidationEventHandler" />，则将返回 <see langword="null" /> 并引发适当的验证事件。 否则会引发 <see cref="T:System.Xml.Schema.XmlSchemaException" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重新处理架构将在调用方法时执行对架构执行的所有预处理步骤 <xref:System.Xml.Schema.XmlSchemaSet.Add%2A> 。 如果对的调用 <xref:System.Xml.Schema.XmlSchemaSet.Reprocess%2A> 成功，则将 <xref:System.Xml.Schema.XmlSchemaSet.IsCompiled%2A> 属性设置为 `false` 。  
  
 重新处理方法应在已修改中的架构之后 <xref:System.Xml.Schema.XmlSchemaSet> 、 <xref:System.Xml.Schema.XmlSchemaSet> 执行编译后使用。  
  
> [!NOTE]
>  <xref:System.Xml.Schema.XmlSchemaSet.Reprocess%2A>如果在将架构添加到之后更改了架构 (或它的其中一个包含/导入) ，则需要调用方法 <xref:System.Xml.Schema.XmlSchemaSet> 。 <xref:System.Xml.Schema.XmlSchemaSet.Reprocess%2A>根据 W3C XML 架构的规则，方法将检查架构的结构有效性。 但是，它不会执行完全验证检查。 它还将解析对内部和外部架构组件的引用。 已成功检索的任何导入或包含的架构也会添加到中 <xref:System.Xml.Schema.XmlSchemaSet> 。 导入的架构将作为单独的对象添加， <xref:System.Xml.Schema.XmlSchema> 同时包含的架构将成为包括在内的部分 <xref:System.Xml.Schema.XmlSchema> 。 如果对重新处理的调用成功，则将 <xref:System.Xml.Schema.XmlSchemaSet.IsCompiled%2A> 属性设置为 false。  
  
   
  
## Examples  
 下面的示例演示如何重新处理添加到中的架构 <xref:System.Xml.Schema.XmlSchemaSet> 。 <xref:System.Xml.Schema.XmlSchemaSet>使用 <xref:System.Xml.Schema.XmlSchemaSet.Compile%2A> 方法编译并修改添加到的架构后 <xref:System.Xml.Schema.XmlSchemaSet> ， <xref:System.Xml.Schema.XmlSchemaSet.IsCompiled%2A> 即使中的架构已修改，属性也将设置为 `true` <xref:System.Xml.Schema.XmlSchemaSet> 。 调用 <xref:System.Xml.Schema.XmlSchemaSet.Reprocess%2A> 方法将执行方法执行的所有预处理 <xref:System.Xml.Schema.XmlSchemaSet.Add%2A> ，并将属性设置 <xref:System.Xml.Schema.XmlSchemaSet.IsCompiled%2A> 为 `false` 。  
  
```vb  
Dim schemaSet As XmlSchemaSet = New XmlSchemaSet()  
Dim schema As XmlSchema = schemaSet.Add("http://www.contoso.com/books", "http://www.contoso.com/books.xsd")  
schemaSet.Compile()  
  
Dim element As XmlSchemaElement = New XmlSchemaElement()  
schema.Items.Add(element)  
element.Name = "book"  
element.SchemaTypeName = New XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema")  
  
schemaSet.Reprocess(schema)  
```  
  
```csharp  
XmlSchemaSet schemaSet = new XmlSchemaSet();  
XmlSchema schema = schemaSet.Add("http://www.contoso.com/books", "http://www.contoso.com/books.xsd");  
schemaSet.Compile();  
  
XmlSchemaElement element = new XmlSchemaElement();  
schema.Items.Add(element);  
element.Name = "book";  
element.SchemaTypeName = new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema");  
  
schemaSet.Reprocess(schema);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaException">该架构无效。</exception>
        <exception cref="T:System.ArgumentNullException">作为参数传递的 <see cref="T:System.Xml.Schema.XmlSchema" /> 对象为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">作为参数传递的 <see cref="T:System.Xml.Schema.XmlSchema" /> 对象并不存在于 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 中。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Schemas">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 中 XML 架构定义语言 (XSD) 架构的集合。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Schemas">
      <MemberSignature Language="C#" Value="public System.Collections.ICollection Schemas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ICollection Schemas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.XmlSchemaSet.Schemas" />
      <MemberSignature Language="VB.NET" Value="Public Function Schemas () As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ICollection ^ Schemas();" />
      <MemberSignature Language="F#" Value="member this.Schemas : unit -&gt; System.Collections.ICollection" Usage="xmlSchemaSet.Schemas " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 中所有 XML 架构定义语言 (XSD) 架构的集合。</summary>
        <returns><see cref="T:System.Collections.ICollection" /> 对象，它包含已添加到 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 中的所有架构。 如果没有架构添加到 <see cref="T:System.Xml.Schema.XmlSchemaSet" />，则返回空的 <see cref="T:System.Collections.ICollection" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回间接添加到中的架构， <xref:System.Xml.Schema.XmlSchemaSet> 因为它们已被导入。  
  
> [!NOTE]
>  <xref:System.Xml.Schema.XmlSchemaSet.Schemas%2A>方法等效于已 <xref:System.Xml.Schema.XmlSchemaCollection.GetEnumerator%2A> 过时的方法 <xref:System.Xml.Schema.XmlSchemaCollection> 。  
  
   
  
## Examples  
 下面的示例演示如何循环访问中的所有架构 <xref:System.Xml.Schema.XmlSchemaSet> 。  
  
```vb  
Dim schemaSet As XmlSchemaSet = New XmlSchemaSet  
schemaSet.Add("http://www.contoso.com/books", "http://www.contoso.com/books.xsd")  
  
Dim schema As XmlSchema  
  
For Each schema In schemaSet.Schemas()  
  
    schema.Write(Console.Out)  
  
Next  
```  
  
```csharp  
XmlSchemaSet schemaSet = new XmlSchemaSet();  
schemaSet.Add("http://www.contoso.com/books", "http://www.contoso.com/books.xsd");  
  
foreach (XmlSchema schema in schemaSet.Schemas())  
{  
    schema.Write(Console.Out);  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Schemas">
      <MemberSignature Language="C#" Value="public System.Collections.ICollection Schemas (string targetNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ICollection Schemas(string targetNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.XmlSchemaSet.Schemas(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Schemas (targetNamespace As String) As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ICollection ^ Schemas(System::String ^ targetNamespace);" />
      <MemberSignature Language="F#" Value="member this.Schemas : string -&gt; System.Collections.ICollection" Usage="xmlSchemaSet.Schemas targetNamespace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetNamespace">架构 <paramref name="targetNamespace" /> 属性。</param>
        <summary>返回 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 中属于给定命名空间的所有 XML 架构定义语言 (XSD) 架构的集合。</summary>
        <returns><see cref="T:System.Collections.ICollection" /> 对象，它包含已添加到 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 的中的属于给定命名空间的所有架构。 如果没有架构添加到 <see cref="T:System.Xml.Schema.XmlSchemaSet" />，则返回空的 <see cref="T:System.Collections.ICollection" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `targetNamespace` 参数为 `null` 或 <xref:System.String.Empty> ，则返回不含命名空间的所有架构。  
  
 此方法返回间接添加到中的架构， <xref:System.Xml.Schema.XmlSchemaSet> 因为它们已被导入。  
  
> [!NOTE]
>  <xref:System.Xml.Schema.XmlSchemaSet.Schemas%2A>方法等效于已 <xref:System.Xml.Schema.XmlSchemaCollection.Item%2A> 过时的方法 <xref:System.Xml.Schema.XmlSchemaCollection> 。  
  
   
  
## Examples  
 下面的示例演示如何循环访问 `http://www.contoso.com/books` 中命名空间中的所有架构 <xref:System.Xml.Schema.XmlSchemaSet> 。  
  
```vb  
Dim schemaSet As XmlSchemaSet = New XmlSchemaSet  
schemaSet.Add("http://www.contoso.com/books", "http://www.contoso.com/books.xsd")  
  
Dim schema As XmlSchema  
  
For Each schema In schemaSet.Schemas("http://www.contoso.com/books")  
  
    schema.Write(Console.Out)  
  
Next  
```  
  
```csharp  
XmlSchemaSet schemaSet = new XmlSchemaSet();  
schemaSet.Add("http://www.contoso.com/books", "http://www.contoso.com/books.xsd");  
  
foreach (XmlSchema schema in schemaSet.Schemas("http://www.contoso.com/books"))  
{  
    schema.Write(Console.Out);  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidationEventHandler">
      <MemberSignature Language="C#" Value="public event System.Xml.Schema.ValidationEventHandler ValidationEventHandler;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.Schema.ValidationEventHandler ValidationEventHandler" />
      <MemberSignature Language="DocId" Value="E:System.Xml.Schema.XmlSchemaSet.ValidationEventHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::Schema::ValidationEventHandler ^ ValidationEventHandler;" />
      <MemberSignature Language="F#" Value="member this.ValidationEventHandler : System.Xml.Schema.ValidationEventHandler " Usage="member this.ValidationEventHandler : System.Xml.Schema.ValidationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.ValidationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定一个事件处理程序，用于接收有关 XML 架构定义语言 (XSD) 架构验证错误的信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置一个事件处理程序，用于在调用的或方法时接收有关架构验证错误的信息 <xref:System.Xml.Schema.XmlSchemaSet.Add%2A> <xref:System.Xml.Schema.XmlSchemaSet.Compile%2A> <xref:System.Xml.Schema.XmlSchemaSet> 。  
  
 如果未定义事件处理程序，则会 <xref:System.Xml.Schema.XmlSchemaException> 在为的任何验证错误上引发 <xref:System.Xml.Schema.XmlSeverityType> <xref:System.Xml.Schema.XmlSeverityType.Error> 。 对于具有的的验证错误，不会引发异常 <xref:System.Xml.Schema.XmlSeverityType> <xref:System.Xml.Schema.XmlSeverityType.Warning> 。  
  
   
  
## Examples  
 下面的代码示例演示如何添加 <xref:System.Xml.Schema.XmlSchemaSet.ValidationEventHandler> 以便在针对架构验证 XML 文档时捕获错误和警告。  
  
 [!code-cpp[XmlSchemaSetOverall Example#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlSchemaSetOverall Example/CPP/xmlschemasetexample.cpp#1)]
 [!code-csharp[XmlSchemaSetOverall Example#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlSchemaSetOverall Example/CS/xmlschemasetexample.cs#1)]
 [!code-vb[XmlSchemaSetOverall Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlSchemaSetOverall Example/VB/xmlschemasetexample.vb#1)]  
  
 该示例使用 books.xml 文件作为输入。  
  
 [!code-xml[XmlSchemaSetOverall Example#2](~/samples/snippets/xml/VS_Snippets_Data/XmlSchemaSetOverall Example/XML/books.xml#2)]  
  
 该示例使用 books.xml 文件作为输入。  
  
 [!code-xml[XmlSchemaSetOverall Example#3](~/samples/snippets/xml/VS_Snippets_Data/XmlSchemaSetOverall Example/XML/books.xsd#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="XmlResolver">
      <MemberSignature Language="C#" Value="public System.Xml.XmlResolver XmlResolver { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlResolver XmlResolver" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Schema.XmlSchemaSet.XmlResolver" />
      <MemberSignature Language="VB.NET" Value="Public Property XmlResolver As XmlResolver" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlResolver ^ XmlResolver {  void set(System::Xml::XmlResolver ^ value); };" />
      <MemberSignature Language="F#" Value="member this.XmlResolver : System.Xml.XmlResolver" Usage="System.Xml.Schema.XmlSchemaSet.XmlResolver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlResolver</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>设置用于解析在架构的包含和导入元素中引用的命名空间或位置的 <see cref="T:System.Xml.XmlResolver" />。</summary>
        <value><see cref="T:System.Xml.XmlResolver" />，用于解析在架构的包含和导入元素中引用的命名空间或位置。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当 <xref:System.Xml.XmlResolver> <xref:System.Xml.Schema.XmlSchemaSet> 使用或方法添加架构时，将用于解析在架构的包含和导入元素中引用的命名空间或位置 <xref:System.Xml.Schema.XmlSchemaSet.Add%2A> <xref:System.Xml.Schema.XmlSchemaSet.Reprocess%2A> 。  
  
> [!IMPORTANT]
>  在架构的包含、导入和重新定义元素中引用的外部命名空间或位置是根据包含或导入这些元素的架构的基本 URI 解析的。 例如，如果包含或导入架构的基本 URI 为空或 `null` ，则相对于当前目录解析外部位置。 <xref:System.Xml.XmlUrlResolver>默认情况下，类用于解析外部架构。 若要对架构的 include、import 和 redefine 元素禁用解析，请将 <xref:System.Xml.Schema.XmlSchemaSet.XmlResolver%2A> 属性设置为 `null` 。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlResolver" />
      </Docs>
    </Member>
  </Members>
</Type>
