<Type Name="TaskScheduler" FullName="System.Threading.Tasks.TaskScheduler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c4869ee0487ec4c25a687d3f782027429a727958" /><Meta Name="ms.sourcegitcommit" Value="45d7745d094b38af5ccba8a4ca47efe84a312ef0" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="10/27/2020" /><Meta Name="ms.locfileid" Value="92685376" /></Metadata><TypeSignature Language="C#" Value="public abstract class TaskScheduler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TaskScheduler extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskScheduler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TaskScheduler" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskScheduler abstract" />
  <TypeSignature Language="F#" Value="type TaskScheduler = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Threading.Tasks" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Threading.Tasks" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Threading.Tasks" FromVersion="4.1.0.0" To="System.Runtime" ToVersion="4.2.0.0" FrameworkAlternate="netcore-2.0" />
    <TypeForwarding From="System.Threading.Tasks" FromVersion="4.1.1.0" To="System.Runtime" ToVersion="4.2.1.0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
    <TypeForwarding From="System.Threading.Tasks" FromVersion="4.1.2.0" To="System.Runtime" ToVersion="4.2.2.0" FrameworkAlternate="netcore-3.1" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Diagnostics.DebuggerDisplay("Id={Id}")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerDisplay("Id={Id}")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView))&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="5dc02-101">表示一个处理将任务排队到线程中的低级工作的对象。</span><span class="sxs-lookup"><span data-stu-id="5dc02-101">Represents an object that handles the low-level work of queuing tasks onto threads.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5dc02-102">类的实例 <xref:System.Threading.Tasks.TaskScheduler> 表示任务计划程序。</span><span class="sxs-lookup"><span data-stu-id="5dc02-102">An instance of the <xref:System.Threading.Tasks.TaskScheduler> class represents a task scheduler.</span></span> <span data-ttu-id="5dc02-103">任务计划程序确保最终执行任务作业。</span><span class="sxs-lookup"><span data-stu-id="5dc02-103">A task scheduler ensures that the work of a task is eventually executed.</span></span>  
  
 <span data-ttu-id="5dc02-104">默认的任务计划程序基于 .NET Framework 4 线程池，提供工作窃取实现负载平衡、线程注入/退出以实现最大吞吐量，并提供整体卓越性能。</span><span class="sxs-lookup"><span data-stu-id="5dc02-104">The default task scheduler is based on the .NET Framework 4 thread pool, which provides work-stealing for load-balancing, thread injection/retirement for maximum throughput, and overall good performance.</span></span> <span data-ttu-id="5dc02-105">它应足以满足大多数方案。</span><span class="sxs-lookup"><span data-stu-id="5dc02-105">It should be sufficient for most scenarios.</span></span>  
  
 <span data-ttu-id="5dc02-106"><xref:System.Threading.Tasks.TaskScheduler>类还可作为所有可自定义计划逻辑的扩展点。</span><span class="sxs-lookup"><span data-stu-id="5dc02-106">The <xref:System.Threading.Tasks.TaskScheduler> class also serves as the extension point for all customizable scheduling logic.</span></span>  <span data-ttu-id="5dc02-107">这包括一些机制，例如如何计划任务的执行，以及应如何向调试器公开计划任务。</span><span class="sxs-lookup"><span data-stu-id="5dc02-107">This includes mechanisms such as how to schedule a task for execution, and how scheduled tasks should be exposed to debuggers.</span></span> <span data-ttu-id="5dc02-108">如果需要特殊的功能，可以创建自定义计划程序，并为特定的任务或查询启用该计划程序。</span><span class="sxs-lookup"><span data-stu-id="5dc02-108">If you require special functionality, you can create a custom scheduler and enable it for specific tasks or queries.</span></span>  
  
 <span data-ttu-id="5dc02-109">本主题内容：</span><span class="sxs-lookup"><span data-stu-id="5dc02-109">In this topic:</span></span>  
[<span data-ttu-id="5dc02-110">默认的任务计划程序和线程池</span><span class="sxs-lookup"><span data-stu-id="5dc02-110">The default task scheduler and the thread pool</span></span>](#Default)  
 [<span data-ttu-id="5dc02-111">全局队列与本地队列</span><span class="sxs-lookup"><span data-stu-id="5dc02-111">The global queue vs. local queues</span></span>](#Queues)  
 [<span data-ttu-id="5dc02-112">工作偷窃</span><span class="sxs-lookup"><span data-stu-id="5dc02-112">Work stealing</span></span>](#Stealing)  
 [<span data-ttu-id="5dc02-113">长时间运行的任务</span><span class="sxs-lookup"><span data-stu-id="5dc02-113">Long-running tasks</span></span>](#LongRunning)  
 [<span data-ttu-id="5dc02-114">任务内联</span><span class="sxs-lookup"><span data-stu-id="5dc02-114">Task inlining</span></span>](#Inlining)  
[<span data-ttu-id="5dc02-115">指定同步上下文</span><span class="sxs-lookup"><span data-stu-id="5dc02-115">Specifying a synchronization context</span></span>](#Sync)  
  
<a name="Default"></a>   
## <a name="the-default-task-scheduler-and-the-thread-pool"></a><span data-ttu-id="5dc02-116">默认的任务计划程序和线程池</span><span class="sxs-lookup"><span data-stu-id="5dc02-116">The default task scheduler and the thread pool</span></span>  
 <span data-ttu-id="5dc02-117">任务并行库和 PLINQ 的默认计划程序使用由类表示的 .NET Framework 线程池 <xref:System.Threading.ThreadPool> 来排队和执行工作。</span><span class="sxs-lookup"><span data-stu-id="5dc02-117">The default scheduler for the Task Parallel Library and PLINQ uses the .NET Framework thread pool, which is represented by the <xref:System.Threading.ThreadPool> class, to queue and execute work.</span></span> <span data-ttu-id="5dc02-118">线程池使用类型提供的信息 <xref:System.Threading.Tasks.Task> 来有效地支持细化并行性 (生存期较短的工作单元) 并行任务和查询通常表示。</span><span class="sxs-lookup"><span data-stu-id="5dc02-118">The thread pool uses the information that is provided by the <xref:System.Threading.Tasks.Task> type to efficiently     support the fine-grained parallelism (short-lived units of work) that parallel tasks and queries often represent.</span></span>  
  
<a name="Queues"></a>   
### <a name="the-global-queue-vs-local-queues"></a><span data-ttu-id="5dc02-119">全局队列与本地队列</span><span class="sxs-lookup"><span data-stu-id="5dc02-119">The global queue vs. local queues</span></span>  
 <span data-ttu-id="5dc02-120">线程池为每个应用程序域中的线程维护全局 FIFO (先进先出) 工作队列。</span><span class="sxs-lookup"><span data-stu-id="5dc02-120">The thread pool maintains a global FIFO (first-in, first-out) work queue for threads in each application domain.</span></span> <span data-ttu-id="5dc02-121">每当程序调用 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (或 <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) 方法时，工作就会置于此共享队列上，并最终取消排队到下一个可用线程。</span><span class="sxs-lookup"><span data-stu-id="5dc02-121">Whenever a program calls the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (or <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) method, the work is put on this shared queue and eventually de-queued onto the next thread that becomes available.</span></span> <span data-ttu-id="5dc02-122">从 .NET Framework 4 开始，此队列已进行了改进，可使用类似于类的无锁算法 <xref:System.Collections.Concurrent.ConcurrentQueue%601> 。</span><span class="sxs-lookup"><span data-stu-id="5dc02-122">Starting with the .NET Framework 4, this queue has been improved to use a lock-free algorithm that resembles the <xref:System.Collections.Concurrent.ConcurrentQueue%601> class.</span></span> <span data-ttu-id="5dc02-123">通过使用此无锁实现，线程池在对工作项进行排队和取消排队时花费更少的时间。</span><span class="sxs-lookup"><span data-stu-id="5dc02-123">By using this lock-free implementation, the thread pool spends less time when it queues and de-queues work items.</span></span> <span data-ttu-id="5dc02-124">此性能优势适用于所有使用线程池的程序。</span><span class="sxs-lookup"><span data-stu-id="5dc02-124">This performance benefit is available to all programs that use the thread pool.</span></span>  
  
 <span data-ttu-id="5dc02-125">最高级任务（即不在其他任务的上下文中创建的任务）与任何其他工作项一样放在全局队列上。</span><span class="sxs-lookup"><span data-stu-id="5dc02-125">Top-level tasks, which are tasks that are not created in the context of another task, are put on the global queue just like any other work item.</span></span> <span data-ttu-id="5dc02-126">但是，嵌套任务或子任务（在其他任务的上下文中创建）的处理方式大不相同。</span><span class="sxs-lookup"><span data-stu-id="5dc02-126">However, nested or child tasks, which are created in the context of another task, are handled quite differently.</span></span> <span data-ttu-id="5dc02-127">子任务或嵌套任务放置在特定于执行父任务的线程的本地队列上。</span><span class="sxs-lookup"><span data-stu-id="5dc02-127">A child or nested task is put on a local queue that is specific to the thread on which the parent task is executing.</span></span> <span data-ttu-id="5dc02-128">父任务可能是最高级任务，也可能是其他任务的子任务。</span><span class="sxs-lookup"><span data-stu-id="5dc02-128">The parent task may be a top-level task or it also may be the child of another task.</span></span> <span data-ttu-id="5dc02-129">当此线程准备好执行更多工作时，首先查看本地队列。</span><span class="sxs-lookup"><span data-stu-id="5dc02-129">When this thread is ready for more work, it first looks in the local queue.</span></span> <span data-ttu-id="5dc02-130">如果工作项在此处等待，即可快速访问它们。</span><span class="sxs-lookup"><span data-stu-id="5dc02-130">If work items are waiting there, they can be accessed quickly.</span></span> <span data-ttu-id="5dc02-131">本地队列按后进先出的顺序 (LIFO) 进行访问，以保留缓存区域并减少争用情况。</span><span class="sxs-lookup"><span data-stu-id="5dc02-131">The local queues are accessed in last-in, first-out order (LIFO) to preserve cache locality and reduce contention.</span></span> <span data-ttu-id="5dc02-132">有关子任务和嵌套任务的详细信息，请参阅 [附加和分离的子任务](/dotnet/standard/parallel-programming/attached-and-detached-child-tasks)。</span><span class="sxs-lookup"><span data-stu-id="5dc02-132">For more information about child tasks and nested tasks, see [Attached and Detached Child Tasks](/dotnet/standard/parallel-programming/attached-and-detached-child-tasks).</span></span>  
  
 <span data-ttu-id="5dc02-133">使用本地队列不仅会降低全局队列压力，还可以利用数据位置。</span><span class="sxs-lookup"><span data-stu-id="5dc02-133">The use of local queues not only reduces pressure on the global queue, but also takes advantage of data locality.</span></span> <span data-ttu-id="5dc02-134">本地队列中的工作项经常引用数据结构，这些结构在内存中以物理方式彼此接近。</span><span class="sxs-lookup"><span data-stu-id="5dc02-134">Work items in the local queue frequently reference data structures that are physically near one another in memory.</span></span> <span data-ttu-id="5dc02-135">在这些情况下，数据在第一项任务运行后已在缓存中，可以快速访问。</span><span class="sxs-lookup"><span data-stu-id="5dc02-135">In these cases, the data is already in the cache after the first task has run and can be accessed quickly.</span></span> <span data-ttu-id="5dc02-136">[并行 LINQ (PLINQ) ](/dotnet/standard/parallel-programming/parallel-linq-plinq)并且 <xref:System.Threading.Tasks.Parallel> 类广泛使用嵌套任务和子任务，并通过使用本地工作队列实现重要的加速。</span><span class="sxs-lookup"><span data-stu-id="5dc02-136">Both [Parallel LINQ (PLINQ)](/dotnet/standard/parallel-programming/parallel-linq-plinq) and the <xref:System.Threading.Tasks.Parallel> class use nested tasks and child tasks extensively, and achieve significant speedups by using the local work queues.</span></span>  
  
<a name="Stealing"></a>   
### <a name="work-stealing"></a><span data-ttu-id="5dc02-137">工作偷窃</span><span class="sxs-lookup"><span data-stu-id="5dc02-137">Work stealing</span></span>  
 <span data-ttu-id="5dc02-138">从 .NET Framework 4 开始，线程池还具有工作窃取算法，以帮助确保没有线程处于空闲状态，而其他线程仍在队列中工作。</span><span class="sxs-lookup"><span data-stu-id="5dc02-138">Starting with the .NET Framework 4, the thread pool also features a work-stealing algorithm to help make sure that no threads are sitting idle while others still have work in their queues.</span></span> <span data-ttu-id="5dc02-139">当线程池线程准备好执更多工作时，首先查看其本地队列的开头，再查看全局队列，然后查看其他线程的本地队列。</span><span class="sxs-lookup"><span data-stu-id="5dc02-139">When a thread-pool thread is ready for more work, it first looks at the head of its local queue, then in the global queue, and then in the local queues of other threads.</span></span> <span data-ttu-id="5dc02-140">如果在其他线程的本地队列中找到工作项，它会先应用试探法以确保可有效运行工作。</span><span class="sxs-lookup"><span data-stu-id="5dc02-140">If it finds a work item in the local queue of another thread, it first applies heuristics to make sure that it can run the work efficiently.</span></span> <span data-ttu-id="5dc02-141">如果可有效运行，则将（按 FIFO 顺序）从结尾处取消工作项的排队。</span><span class="sxs-lookup"><span data-stu-id="5dc02-141">If it can, it de-queues the work item from the tail (in FIFO order).</span></span> <span data-ttu-id="5dc02-142">这样可以减少每个本地队列上的争用并保留数据位置。</span><span class="sxs-lookup"><span data-stu-id="5dc02-142">This reduces contention on each local queue and preserves data locality.</span></span> <span data-ttu-id="5dc02-143">与以前的版本相比，此体系结构可帮助提高线程池的负载平衡工作效率。</span><span class="sxs-lookup"><span data-stu-id="5dc02-143">This architecture helps the thread pool load-balance work more efficiently than past versions did.</span></span>  
  
<a name="LongRunning"></a>   
### <a name="long-running-tasks"></a><span data-ttu-id="5dc02-144">长时间运行的任务</span><span class="sxs-lookup"><span data-stu-id="5dc02-144">Long-running tasks</span></span>  
 <span data-ttu-id="5dc02-145">可能想要显式防止将任务放到本地队列上。</span><span class="sxs-lookup"><span data-stu-id="5dc02-145">You may want to explicitly prevent a task from being put on a local queue.</span></span> <span data-ttu-id="5dc02-146">例如，你可能知道特定工作项将运行相对长的时间并可能阻塞本地队列中的所有其他工作项。</span><span class="sxs-lookup"><span data-stu-id="5dc02-146">For example, you may know that a particular work item will run for a relatively long time and is likely to block all other work items on the local queue.</span></span> <span data-ttu-id="5dc02-147">在这种情况下，可指定 <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> 选项，它提示附加线程执行任务时可能需要计划程序，以使此任务不阻塞本地队列中其他线程或工作项的向前推动。</span><span class="sxs-lookup"><span data-stu-id="5dc02-147">In this case, you can specify the <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> option, which provides a hint to the scheduler that an additional thread might be required for the task so that it does not block the forward progress of other threads or work items on the local queue.</span></span> <span data-ttu-id="5dc02-148">使用此选项可完全避免使用线程池，包括全局队列和本地队列。</span><span class="sxs-lookup"><span data-stu-id="5dc02-148">By using this option you avoid the thread pool completely, including the global and local queues.</span></span>  
  
<a name="Inlining"></a>   
### <a name="task-inlining"></a><span data-ttu-id="5dc02-149">任务内联</span><span class="sxs-lookup"><span data-stu-id="5dc02-149">Task inlining</span></span>  
 <span data-ttu-id="5dc02-150">在某些情况下 <xref:System.Threading.Tasks.Task> ，当等待时，它可能会在执行等待操作的线程上同步执行。</span><span class="sxs-lookup"><span data-stu-id="5dc02-150">In some cases when a <xref:System.Threading.Tasks.Task> is waited on, it may be executed synchronously on the thread that is performing the wait operation.</span></span> <span data-ttu-id="5dc02-151">这可以防止需要额外的线程，而是使用现有线程，否则会阻止其他线程。</span><span class="sxs-lookup"><span data-stu-id="5dc02-151">This enhances performance by preventing the need for an additional thread and instead using the existing thread, which would have blocked otherwise.</span></span> <span data-ttu-id="5dc02-152">为了防止重入导致的错误，仅当在相关线程的本地队列中找到等待目标时才会发生任务内联。</span><span class="sxs-lookup"><span data-stu-id="5dc02-152">To prevent errors due to reentrancy, task inlining only occurs when the wait target is found in the relevant thread's local queue.</span></span>  
  
<a name="Sync"></a>   
## <a name="specifying-a-synchronization-context"></a><span data-ttu-id="5dc02-153">指定同步上下文</span><span class="sxs-lookup"><span data-stu-id="5dc02-153">Specifying a synchronization context</span></span>  
 <span data-ttu-id="5dc02-154">可使用 <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> 方法指定任务应计划在特定线程上运行。</span><span class="sxs-lookup"><span data-stu-id="5dc02-154">You can use the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> method to specify that a task should be scheduled to run on a particular thread.</span></span> <span data-ttu-id="5dc02-155">在 Windows 窗体和 Windows Presentation Foundation 等框架中此操作非常有用，在此类框架中对用户界面对象的访问限制为只可访问在创建 UI 对象的同一线程上运行的代码。</span><span class="sxs-lookup"><span data-stu-id="5dc02-155">This is useful in frameworks such as Windows Forms and Windows Presentation Foundation where access to user interface objects is often restricted to code that is running on the same thread on which the UI object was created.</span></span>  
  
 <span data-ttu-id="5dc02-156">下面的示例使用 <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> Windows Presentation Foundation 中的方法 (WPF) 应用程序将任务计划在用户界面 (UI) 控件创建到的同一线程上。</span><span class="sxs-lookup"><span data-stu-id="5dc02-156">The following example uses the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> method in a Windows Presentation Foundation (WPF) app to schedule a task on the same thread that the user interface (UI) control was created on.</span></span>   <span data-ttu-id="5dc02-157">该示例创建了一个在指定目录中随机选择的图像马赛克。</span><span class="sxs-lookup"><span data-stu-id="5dc02-157">The example creates a mosaic of images that are randomly selected from a specified directory.</span></span> <span data-ttu-id="5dc02-158">WPF 对象用于加载图像并调整图像大小。</span><span class="sxs-lookup"><span data-stu-id="5dc02-158">The WPF objects are used to load and resize the images.</span></span> <span data-ttu-id="5dc02-159">然后将原始像素传递到一个任务，该任务使用 <xref:System.Threading.Tasks.Parallel.For%2A> 循环将像素数据写入到大的单字节数组中。</span><span class="sxs-lookup"><span data-stu-id="5dc02-159">The raw pixels are then passed to a task that uses a <xref:System.Threading.Tasks.Parallel.For%2A> loop to write the pixel data into a large single-byte array.</span></span> <span data-ttu-id="5dc02-160">无需同步，因为没有两个磁贴占用相同的数组元素。</span><span class="sxs-lookup"><span data-stu-id="5dc02-160">No synchronization is required because no two tiles occupy the same array elements.</span></span> <span data-ttu-id="5dc02-161">还可以按任意顺序编写磁贴，因为这些磁贴的位置独立于任何其他磁贴进行计算。</span><span class="sxs-lookup"><span data-stu-id="5dc02-161">The tiles can also be written in any order because their position is calculated independently of any other tile.</span></span> <span data-ttu-id="5dc02-162">然后，将大数组传递给在 UI 线程上运行的任务，在此任务中，像素数据加载到图像控件中。</span><span class="sxs-lookup"><span data-stu-id="5dc02-162">The large array is then passed to a task that runs on the UI thread, where the pixel data is loaded into an Image control.</span></span>  
  
 <span data-ttu-id="5dc02-163">该示例将数据移出 UI 线程，通过使用并行循环和对象对其进行修改， <xref:System.Threading.Tasks.Task> 然后将其传递回在 UI 线程上运行的任务。</span><span class="sxs-lookup"><span data-stu-id="5dc02-163">The example moves data off the UI thread, modifies it by using parallel loops and <xref:System.Threading.Tasks.Task> objects, and then passes it back to a task that runs on the UI thread.</span></span> <span data-ttu-id="5dc02-164">当你必须使用任务并行库来执行 WPF API 不支持的操作或没有足够的速度时，此方法非常有用。</span><span class="sxs-lookup"><span data-stu-id="5dc02-164">This approach is useful when you have to use the Task Parallel Library to perform operations that either are not supported by the WPF API, or are not sufficiently fast.</span></span> <span data-ttu-id="5dc02-165">在 WPF 中创建图像马赛克的另一种方法是使用 <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> 控件并向其中添加图像。</span><span class="sxs-lookup"><span data-stu-id="5dc02-165">Another way to create an image mosaic in WPF is to use a <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> control and add images to it.</span></span> <span data-ttu-id="5dc02-166"><xref:System.Windows.Controls.WrapPanel>处理磁贴的定位工作。</span><span class="sxs-lookup"><span data-stu-id="5dc02-166">The <xref:System.Windows.Controls.WrapPanel> handles the work of positioning the tiles.</span></span> <span data-ttu-id="5dc02-167">但是，只能在 UI 线程上执行此操作。</span><span class="sxs-lookup"><span data-stu-id="5dc02-167">However, this work can only be performed on the UI thread.</span></span>  
  
 [!code-csharp[TPL_SyncContext#01](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)]
 [!code-vb[TPL_SyncContext#01](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)]  
  
 <span data-ttu-id="5dc02-168">若要创建该示例，请在 Visual Studio 中创建一个 WPF 应用程序项目，并将其命名为 c # WPF 项目的 WPF_CS1 () 或 (WPF 项目 Visual Basic 的 WPF_VB1) 。</span><span class="sxs-lookup"><span data-stu-id="5dc02-168">To create the example, create a WPF application project in Visual Studio and name it WPF_CS1 (for a C# WPF project) or WPF_VB1 (for a Visual Basic WPF project).</span></span> <span data-ttu-id="5dc02-169">然后执行以下操作：</span><span class="sxs-lookup"><span data-stu-id="5dc02-169">Then do the following:</span></span>  
  
1. <span data-ttu-id="5dc02-170">在 "设计" 视图中，将 <xref:System.Windows.Controls.Image> 控件从 " **工具箱** " 拖动到设计图面的左上角。</span><span class="sxs-lookup"><span data-stu-id="5dc02-170">In design view, drag an <xref:System.Windows.Controls.Image> control from the **Toolbox** onto the upper left corner of the design surface.</span></span> <span data-ttu-id="5dc02-171">在 " **属性** " 窗口的 " **名称** " 文本框中，将控件命名为 "image"。</span><span class="sxs-lookup"><span data-stu-id="5dc02-171">In the **Name** textbox of the **Properties** window, name the control "image".</span></span>    
  
2. <span data-ttu-id="5dc02-172">将 <xref:System.Windows.Controls.Button> 控件从 " **工具箱** " 拖动到应用程序窗口的左下部分。</span><span class="sxs-lookup"><span data-stu-id="5dc02-172">Drag a <xref:System.Windows.Controls.Button> control from the **Toolbox** to the lower left part of the application window.</span></span> <span data-ttu-id="5dc02-173">在 XAML 视图中， <xref:System.Windows.Controls.ContentControl.Content%2A> 将按钮的属性指定为 "创建马赛克"，并将其 <xref:System.Windows.FrameworkElement.Width> 属性指定为 "100"。</span><span class="sxs-lookup"><span data-stu-id="5dc02-173">In XAML view, specify the <xref:System.Windows.Controls.ContentControl.Content%2A> property of the button as "Make a mosaic", and specify its <xref:System.Windows.FrameworkElement.Width> property as "100".</span></span> <span data-ttu-id="5dc02-174"><xref:System.Windows.Controls.Primitives.ButtonBase.Click> `button_Click` 通过将添加到元素，将事件与示例的代码中定义的事件处理程序连接 `Click="button_Click"` `<Button>` 。</span><span class="sxs-lookup"><span data-stu-id="5dc02-174">Connect the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event with the `button_Click` event handler defined in the example's code by adding `Click="button_Click"` to the `<Button>` element.</span></span> <span data-ttu-id="5dc02-175">在 " **属性** " 窗口的 " **名称** " 文本框中，将控件命名为 "button"。</span><span class="sxs-lookup"><span data-stu-id="5dc02-175">In the **Name** textbox of the **Properties** window, name the control "button".</span></span>  
  
3. <span data-ttu-id="5dc02-176">将 MainWindow.xaml.cs 或 Mainwindow.xaml 文件的全部内容替换为此示例中的代码。</span><span class="sxs-lookup"><span data-stu-id="5dc02-176">Replace the entire contents of the MainWindow.xaml.cs or MainWindow.xaml.vb file with the code from this example.</span></span> <span data-ttu-id="5dc02-177">对于 c # WPF 项目，请确保工作区的名称与项目名称匹配。</span><span class="sxs-lookup"><span data-stu-id="5dc02-177">For a C# WPF project, make sure that the name of the workspace matches the project name.</span></span> 
  
4. <span data-ttu-id="5dc02-178">该示例从名为 C:\Users\Public\Pictures\Sample 的目录中读取 JPEG 图像 \\ 。</span><span class="sxs-lookup"><span data-stu-id="5dc02-178">The example reads JPEG images from a directory named C:\Users\Public\Pictures\Sample Pictures\\.</span></span> <span data-ttu-id="5dc02-179">创建目录并将某些图像放入其中，或更改路径以引用包含图像的其他目录。</span><span class="sxs-lookup"><span data-stu-id="5dc02-179">Either create the directory and place some images in it, or change the path to refer to some other directory that contains images.</span></span> 
  
<span data-ttu-id="5dc02-180">此示例有一些限制。</span><span class="sxs-lookup"><span data-stu-id="5dc02-180">This example has some limitations.</span></span> <span data-ttu-id="5dc02-181">例如，仅支持32位/像素的图像;在调整大小操作过程中，对象会损坏其他格式的图像 <xref:System.Windows.Media.Imaging.BitmapImage> 。</span><span class="sxs-lookup"><span data-stu-id="5dc02-181">For example, only 32-bits-per-pixel images are supported; images in other formats are corrupted by the <xref:System.Windows.Media.Imaging.BitmapImage> object during the resizing operation.</span></span> <span data-ttu-id="5dc02-182">此外，源映像必须都大于磁贴大小。</span><span class="sxs-lookup"><span data-stu-id="5dc02-182">Also, the source images must all be larger than the tile size.</span></span> <span data-ttu-id="5dc02-183">作为进一步的练习，您可以添加处理多个像素格式和文件大小的功能。</span><span class="sxs-lookup"><span data-stu-id="5dc02-183">As a further exercise, you can add functionality to handle multiple pixel formats and file sizes.</span></span>  
  
## Examples  
 <span data-ttu-id="5dc02-184">下面的示例摘自 MSDN 代码库网站上的 [.NET Framework 4 进行并行编程](https://go.microsoft.com/fwlink/?LinkID=165717) 的示例。</span><span class="sxs-lookup"><span data-stu-id="5dc02-184">The following example is taken from the [Samples for Parallel Programming with the .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717) on the MSDN Code Gallery Web site.</span></span>  <span data-ttu-id="5dc02-185">它会创建一个自定义任务计划程序，该计划程序限制应用程序使用的线程数。</span><span class="sxs-lookup"><span data-stu-id="5dc02-185">It creates a custom task scheduler that limits the number of threads used by the app.</span></span> <span data-ttu-id="5dc02-186">然后，它将启动两组任务并显示有关任务和执行任务的线程的信息。</span><span class="sxs-lookup"><span data-stu-id="5dc02-186">It then launches two sets of tasks and displays information about the task and the thread on which the task is executing.</span></span>  
  
 [!code-csharp[TPL_Schedulers#02](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_schedulers/cs/limitex1.cs#02)]
 [!code-vb[TPL_Schedulers#02](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_schedulers/vb/module2.vb#02)]  
  
 <span data-ttu-id="5dc02-187">此外，代码库上提供了几个示例任务计划 [程序：使用 .NET Framework 4 进行并行编程的示例](https://go.microsoft.com/fwlink/?LinkID=165717)。</span><span class="sxs-lookup"><span data-stu-id="5dc02-187">In addition, several sample task schedulers are available on Code Gallery: [Samples for Parallel Programming with the .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717).</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="5dc02-188">抽象类型的所有成员 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 都是线程安全的，可同时从多个线程使用。</span><span class="sxs-lookup"><span data-stu-id="5dc02-188">All members of the abstract <see cref="T:System.Threading.Tasks.TaskScheduler" /> type are thread-safe and may be used from multiple threads concurrently.</span></span></threadsafe>
    <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
    <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="5dc02-189">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="5dc02-189">Task Parallel Library (TPL)</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TaskScheduler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5dc02-190">初始化 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="5dc02-190">Initializes the <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="5dc02-191">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="5dc02-191">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Current" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Current { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5dc02-192">获取与当前正在执行的任务关联的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="5dc02-192">Gets the <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the currently executing task.</span></span></summary>
        <value><span data-ttu-id="5dc02-193">返回与当前正在执行的任务关联的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="5dc02-193">Returns the <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the currently executing task.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5dc02-194">如果不是从任务中调用， <xref:System.Threading.Tasks.TaskScheduler.Current%2A> 将返回 <xref:System.Threading.Tasks.TaskScheduler.Default%2A> 计划程序。</span><span class="sxs-lookup"><span data-stu-id="5dc02-194">When not called from within a task, <xref:System.Threading.Tasks.TaskScheduler.Current%2A> will return the <xref:System.Threading.Tasks.TaskScheduler.Default%2A> scheduler.</span></span>  
  
 <span data-ttu-id="5dc02-195">有关详细信息，请参阅 <xref:System.Threading.Tasks.TaskScheduler>。</span><span class="sxs-lookup"><span data-stu-id="5dc02-195">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="5dc02-196">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="5dc02-196">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Default" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Default { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5dc02-197">获取由 .NET 提供的默认 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 实例。</span><span class="sxs-lookup"><span data-stu-id="5dc02-197">Gets the default <see cref="T:System.Threading.Tasks.TaskScheduler" /> instance that is provided by .NET.</span></span></summary>
        <value><span data-ttu-id="5dc02-198">返回默认的 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 实例。</span><span class="sxs-lookup"><span data-stu-id="5dc02-198">Returns the default <see cref="T:System.Threading.Tasks.TaskScheduler" /> instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5dc02-199">有关详细信息，请参阅 <xref:System.Threading.Tasks.TaskScheduler>。</span><span class="sxs-lookup"><span data-stu-id="5dc02-199">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="5dc02-200">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="5dc02-200">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TaskScheduler ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="taskScheduler.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5dc02-201">释放与此计划程序关联的所有资源。</span><span class="sxs-lookup"><span data-stu-id="5dc02-201">Frees all resources associated with this scheduler.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromCurrentSynchronizationContext">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromCurrentSynchronizationContext () As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::TaskScheduler ^ FromCurrentSynchronizationContext();" />
      <MemberSignature Language="F#" Value="static member FromCurrentSynchronizationContext : unit -&gt; System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5dc02-202">创建与当前 <see cref="T:System.Threading.SynchronizationContext" /> 关联的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="5dc02-202">Creates a <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the current <see cref="T:System.Threading.SynchronizationContext" />.</span></span></summary>
        <returns><span data-ttu-id="5dc02-203">与当前 <see cref="T:System.Threading.SynchronizationContext" /> 关联的 <see cref="T:System.Threading.Tasks.TaskScheduler" />，由 <see cref="P:System.Threading.SynchronizationContext.Current" /> 确定。</span><span class="sxs-lookup"><span data-stu-id="5dc02-203">A <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the current <see cref="T:System.Threading.SynchronizationContext" />, as determined by <see cref="P:System.Threading.SynchronizationContext.Current" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5dc02-204"><xref:System.Threading.Tasks.Task>将通过对该上下文的方法的调用来执行所有排队等待返回的计划程序的实例 <xref:System.Threading.SynchronizationContext.Post%2A> 。</span><span class="sxs-lookup"><span data-stu-id="5dc02-204">All <xref:System.Threading.Tasks.Task> instances queued to the returned scheduler will be executed through a call to the <xref:System.Threading.SynchronizationContext.Post%2A> method on that context.</span></span>  
  
 <span data-ttu-id="5dc02-205">有关详细信息，请参阅 <xref:System.Threading.Tasks.TaskScheduler>。</span><span class="sxs-lookup"><span data-stu-id="5dc02-205">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5dc02-206">当前的 SynchronizationContext 不能用作 TaskScheduler。</span><span class="sxs-lookup"><span data-stu-id="5dc02-206">The current SynchronizationContext may not be used as a TaskScheduler.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="5dc02-207">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="5dc02-207">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetScheduledTasks">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; GetScheduledTasks ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; GetScheduledTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScheduledTasks () As IEnumerable(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ GetScheduledTasks();" />
      <MemberSignature Language="F#" Value="abstract member GetScheduledTasks : unit -&gt; seq&lt;System.Threading.Tasks.Task&gt;" Usage="taskScheduler.GetScheduledTasks " />
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;? GetScheduledTasks ();" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5dc02-208">仅对于调试器支持，生成当前排队到计划程序中等待执行的 <see cref="T:System.Threading.Tasks.Task" /> 实例的枚举。</span><span class="sxs-lookup"><span data-stu-id="5dc02-208">For debugger support only, generates an enumerable of <see cref="T:System.Threading.Tasks.Task" /> instances currently queued to the scheduler waiting to be executed.</span></span></summary>
        <returns><span data-ttu-id="5dc02-209">一个允许调试器遍历当前排队到此计划程序中的任务的枚举。</span><span class="sxs-lookup"><span data-stu-id="5dc02-209">An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5dc02-210">派生自的类 <xref:System.Threading.Tasks.TaskScheduler> 实现此方法以支持与调试器的集成。</span><span class="sxs-lookup"><span data-stu-id="5dc02-210">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method in order to support integration with debuggers.</span></span> <span data-ttu-id="5dc02-211">仅当调试器请求对数据的访问权限时，.NET Framework 才会调用此方法。</span><span class="sxs-lookup"><span data-stu-id="5dc02-211">This method will only be invoked by the .NET Framework when the debugger requests access to the data.</span></span> <span data-ttu-id="5dc02-212">将通过调试实用程序遍历返回的可枚举，以访问当前排队到此计划程序的任务，使调试器能够在用户界面中提供此信息的表示形式。</span><span class="sxs-lookup"><span data-stu-id="5dc02-212">The enumerable returned will be traversed by debugging utilities to access the tasks currently queued to this scheduler, enabling the debugger to provide a representation of this information in the user interface.</span></span>  
  
 <span data-ttu-id="5dc02-213">请务必注意，调用此方法时，进程中的所有其他线程都将被冻结。</span><span class="sxs-lookup"><span data-stu-id="5dc02-213">It is important to note that, when this method is called, all other threads in the process will be frozen.</span></span> <span data-ttu-id="5dc02-214">因此，请务必避免与可能导致阻塞的其他线程同步。</span><span class="sxs-lookup"><span data-stu-id="5dc02-214">Therefore, it's important to avoid synchronization with other threads that may lead to blocking.</span></span> <span data-ttu-id="5dc02-215">如果需要同步，且无法获取此方法中的锁，则应该引发异常，以便调试器不会阻止。</span><span class="sxs-lookup"><span data-stu-id="5dc02-215">If synchronization is necessary, and you are unable to acquire the lock in this method, then you should throw an exception so that the debugger does not block.</span></span> <span data-ttu-id="5dc02-216">下面的示例演示了 c # 中的一种可能的方法：</span><span class="sxs-lookup"><span data-stu-id="5dc02-216">The following example shows one possible approach in C#:</span></span>
  
```csharp
protected override IEnumerable<Task> GetScheduledTasks()  
{  
    bool lockTaken = false;  
    try  
    {  
        Monitor.TryEnter(_syncObj, ref lockTaken);  
        if (lockTaken)  
        {  
            return _tasks.ToArray();  
        }  
        else throw new NotSupportedException();  
    }  
    finally  
    {  
    if (lockTaken) Monitor.Exit(_syncObj);  
    }}  
```  
  
 <span data-ttu-id="5dc02-217">此外，此方法和返回的可枚举不能修改任何全局可见状态。</span><span class="sxs-lookup"><span data-stu-id="5dc02-217">Additionally, this method and the enumerable returned must not modify any globally visible state.</span></span>  
  
 <span data-ttu-id="5dc02-218">返回的可枚举不应为 null。</span><span class="sxs-lookup"><span data-stu-id="5dc02-218">The returned enumerable should never be null.</span></span> <span data-ttu-id="5dc02-219">如果当前没有排队的任务，则应改为返回空的可枚举。</span><span class="sxs-lookup"><span data-stu-id="5dc02-219">If there are currently no queued tasks, an empty enumerable should be returned instead.</span></span>  
  
 <span data-ttu-id="5dc02-220">实现自定义调试器的开发人员不应直接调用此方法，而应改用内部包装方法 `GetScheduledTasksForDebugger` ： `internal Task[] GetScheduledTasksForDebugger()` 。</span><span class="sxs-lookup"><span data-stu-id="5dc02-220">Developers who are implementing custom debuggers shouldn't call this method directly, but should use the internal wrapper method `GetScheduledTasksForDebugger` instead: `internal Task[] GetScheduledTasksForDebugger()`.</span></span> <span data-ttu-id="5dc02-221">此包装方法返回一个任务数组，而不是一个可枚举的。</span><span class="sxs-lookup"><span data-stu-id="5dc02-221">This wrapper method returns an array of tasks instead of an enumerable.</span></span> <span data-ttu-id="5dc02-222">若要检索活动计划程序的列表，请使用 internal 方法 `internal static TaskScheduler[] GetTaskSchedulersForDebugger()` 。</span><span class="sxs-lookup"><span data-stu-id="5dc02-222">To retrieve a list of active schedulers, use the internal method `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`.</span></span> <span data-ttu-id="5dc02-223">此静态方法返回所有活动实例的数组 <xref:System.Threading.Tasks.TaskScheduler> 。</span><span class="sxs-lookup"><span data-stu-id="5dc02-223">This static method returns an array of all active <xref:System.Threading.Tasks.TaskScheduler> instances.</span></span> <span data-ttu-id="5dc02-224">然后，你可以 `GetScheduledTasksForDebugger` 在每个计划程序实例上使用来检索其计划任务的列表。</span><span class="sxs-lookup"><span data-stu-id="5dc02-224">You can then use `GetScheduledTasksForDebugger` on each scheduler instance to retrieve its list of scheduled tasks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5dc02-225">此计划程序无法在此时生成排队任务的列表。</span><span class="sxs-lookup"><span data-stu-id="5dc02-225">This scheduler is unable to generate a list of queued tasks at this time.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="5dc02-226">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="5dc02-226">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.TaskScheduler.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5dc02-227">获取此 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 的唯一 ID。</span><span class="sxs-lookup"><span data-stu-id="5dc02-227">Gets the unique ID for this <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
        <value><span data-ttu-id="5dc02-228">返回此 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 的唯一 ID。</span><span class="sxs-lookup"><span data-stu-id="5dc02-228">Returns the unique ID for this <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5dc02-229">有关详细信息，请参阅 <xref:System.Threading.Tasks.TaskScheduler>。</span><span class="sxs-lookup"><span data-stu-id="5dc02-229">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="5dc02-230">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="5dc02-230">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MaximumConcurrencyLevel">
      <MemberSignature Language="C#" Value="public virtual int MaximumConcurrencyLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumConcurrencyLevel" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MaximumConcurrencyLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaximumConcurrencyLevel { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumConcurrencyLevel : int" Usage="System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5dc02-231">指示此 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 能够支持的最大并发级别。</span><span class="sxs-lookup"><span data-stu-id="5dc02-231">Indicates the maximum concurrency level this <see cref="T:System.Threading.Tasks.TaskScheduler" /> is able to support.</span></span></summary>
        <value><span data-ttu-id="5dc02-232">返回表示最大并发级别的一个整数。</span><span class="sxs-lookup"><span data-stu-id="5dc02-232">Returns an integer that represents the maximum concurrency level.</span></span> <span data-ttu-id="5dc02-233">默认计划程序返回 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="5dc02-233">The default scheduler returns <see cref="F:System.Int32.MaxValue" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5dc02-234">有关详细信息，请参阅 <xref:System.Threading.Tasks.TaskScheduler>。</span><span class="sxs-lookup"><span data-stu-id="5dc02-234">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="5dc02-235">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="5dc02-235">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="QueueTask">
      <MemberSignature Language="C#" Value="protected internal abstract void QueueTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void QueueTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Sub QueueTask (task As Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void QueueTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member QueueTask : System.Threading.Tasks.Task -&gt; unit" Usage="taskScheduler.QueueTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task"><span data-ttu-id="5dc02-236">要排队的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="5dc02-236">The <see cref="T:System.Threading.Tasks.Task" /> to be queued.</span></span></param>
        <summary><span data-ttu-id="5dc02-237">将 <see cref="T:System.Threading.Tasks.Task" /> 排队到计划程序中。</span><span class="sxs-lookup"><span data-stu-id="5dc02-237">Queues a <see cref="T:System.Threading.Tasks.Task" /> to the scheduler.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5dc02-238">派生自的类 <xref:System.Threading.Tasks.TaskScheduler> 实现此方法，以接受计划在计划程序上的任务。</span><span class="sxs-lookup"><span data-stu-id="5dc02-238">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method to accept tasks being scheduled on the scheduler.</span></span>  
  
 <span data-ttu-id="5dc02-239">典型的实现会将任务存储在内部数据结构中，这种情况下，可能会在将来某个时间执行这些任务的线程提供服务。</span><span class="sxs-lookup"><span data-stu-id="5dc02-239">A typical implementation would store the task in an internal data structure, which would be serviced by threads that would execute those tasks at some time in the future.</span></span>  
  
 <span data-ttu-id="5dc02-240">此方法仅由 .NET Framework 调用，不应由派生类直接调用。</span><span class="sxs-lookup"><span data-stu-id="5dc02-240">This method is only meant to be called by the .NET Framework and should not be called directly by the derived class.</span></span> <span data-ttu-id="5dc02-241">这对于维护系统的一致性是必需的。</span><span class="sxs-lookup"><span data-stu-id="5dc02-241">This is necessary for maintaining the consistency of the system.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5dc02-242"><paramref name="task" /> 参数为 null。</span><span class="sxs-lookup"><span data-stu-id="5dc02-242">The <paramref name="task" /> argument is null.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="5dc02-243">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="5dc02-243">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="protected internal virtual bool TryDequeue (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool TryDequeue(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function TryDequeue (task As Task) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool TryDequeue(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member TryDequeue : System.Threading.Tasks.Task -&gt; bool&#xA;override this.TryDequeue : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryDequeue task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task"><span data-ttu-id="5dc02-244">要取消排队的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="5dc02-244">The <see cref="T:System.Threading.Tasks.Task" /> to be dequeued.</span></span></param>
        <summary><span data-ttu-id="5dc02-245">尝试将以前排队到此计划程序中的 <see cref="T:System.Threading.Tasks.Task" /> 取消排队。</span><span class="sxs-lookup"><span data-stu-id="5dc02-245">Attempts to dequeue a <see cref="T:System.Threading.Tasks.Task" /> that was previously queued to this scheduler.</span></span></summary>
        <returns><span data-ttu-id="5dc02-246">一个布尔值，该值指示是否已成功地将 <paramref name="task" /> 参数取消排队。</span><span class="sxs-lookup"><span data-stu-id="5dc02-246">A Boolean denoting whether the <paramref name="task" /> argument was successfully dequeued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5dc02-247">有关详细信息，请参阅 <xref:System.Threading.Tasks.TaskScheduler>。</span><span class="sxs-lookup"><span data-stu-id="5dc02-247">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 <span data-ttu-id="5dc02-248">此方法可能在 finally 块中执行;因此，它应尽快返回，以便可以及时释放任何资源（例如 <xref:System.Threading.CancellationTokenRegistration> 对象）。</span><span class="sxs-lookup"><span data-stu-id="5dc02-248">This method may execute in a finally block; therefore it should return as quickly as possible so that any resources such as <xref:System.Threading.CancellationTokenRegistration> objects can be disposed of in a timely manner.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5dc02-249"><paramref name="task" /> 参数为 null。</span><span class="sxs-lookup"><span data-stu-id="5dc02-249">The <paramref name="task" /> argument is null.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="5dc02-250">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="5dc02-250">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTask">
      <MemberSignature Language="C#" Value="protected bool TryExecuteTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool TryExecuteTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="VB.NET" Value="Protected Function TryExecuteTask (task As Task) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool TryExecuteTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="member this.TryExecuteTask : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryExecuteTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task"><span data-ttu-id="5dc02-251">要执行的 <see cref="T:System.Threading.Tasks.Task" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="5dc02-251">A <see cref="T:System.Threading.Tasks.Task" /> object to be executed.</span></span></param>
        <summary><span data-ttu-id="5dc02-252">尝试在此计划程序上执行提供的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="5dc02-252">Attempts to execute the provided <see cref="T:System.Threading.Tasks.Task" /> on this scheduler.</span></span></summary>
        <returns><span data-ttu-id="5dc02-253">一个布尔值，如果成功执行了 <paramref name="task" />，则该值为 true；如果未成功执行，则该值为 false。</span><span class="sxs-lookup"><span data-stu-id="5dc02-253">A Boolean that is true if <paramref name="task" /> was successfully executed, false if it was not.</span></span> <span data-ttu-id="5dc02-254">执行失败的常见原因是，该任务先前已经执行或者位于正在由另一个线程执行的进程中。</span><span class="sxs-lookup"><span data-stu-id="5dc02-254">A common reason for execution failure is that the task had previously been executed or is in the process of being executed by another thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5dc02-255">计划程序实现与 <xref:System.Threading.Tasks.Task> 通过 <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> 方法或方法执行的实例一起提供 <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> 。</span><span class="sxs-lookup"><span data-stu-id="5dc02-255">Scheduler implementations are provided with <xref:System.Threading.Tasks.Task> instances to be executed through either the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method or the <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> method.</span></span> <span data-ttu-id="5dc02-256">当计划程序认为合适运行提供的任务时， <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> 应使用此方法。</span><span class="sxs-lookup"><span data-stu-id="5dc02-256">When the scheduler deems it appropriate to run the provided task, <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> should be used to do so.</span></span> <span data-ttu-id="5dc02-257">TryExecuteTask 处理执行任务的所有方面，包括操作调用、异常处理、状态管理和生命周期控制。</span><span class="sxs-lookup"><span data-stu-id="5dc02-257">TryExecuteTask handles all aspects of executing a task, including action invocation, exception handling, state management, and lifecycle control.</span></span>  
  
 <span data-ttu-id="5dc02-258"><xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> 必须仅用于 .NET Framework 基础结构向此计划程序提供的任务。</span><span class="sxs-lookup"><span data-stu-id="5dc02-258"><xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> must only be used for tasks provided to this scheduler by the .NET Framework infrastructure.</span></span> <span data-ttu-id="5dc02-259">不应使用它来执行通过自定义机制获得的任意任务。</span><span class="sxs-lookup"><span data-stu-id="5dc02-259">It should not be used to execute arbitrary tasks obtained through custom mechanisms.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5dc02-260"><paramref name="task" /> 与此计划程序无关联。</span><span class="sxs-lookup"><span data-stu-id="5dc02-260">The <paramref name="task" /> is not associated with this scheduler.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="5dc02-261">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="5dc02-261">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTaskInline">
      <MemberSignature Language="C#" Value="protected abstract bool TryExecuteTaskInline (System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryExecuteTaskInline(class System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function TryExecuteTaskInline (task As Task, taskWasPreviouslyQueued As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryExecuteTaskInline(System::Threading::Tasks::Task ^ task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="F#" Value="abstract member TryExecuteTaskInline : System.Threading.Tasks.Task * bool -&gt; bool" Usage="taskScheduler.TryExecuteTaskInline (task, taskWasPreviouslyQueued)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
        <Parameter Name="taskWasPreviouslyQueued" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="task"><span data-ttu-id="5dc02-262">要执行的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="5dc02-262">The <see cref="T:System.Threading.Tasks.Task" /> to be executed.</span></span></param>
        <param name="taskWasPreviouslyQueued"><span data-ttu-id="5dc02-263">一个布尔值，该值指示任务之前是否已排队。</span><span class="sxs-lookup"><span data-stu-id="5dc02-263">A Boolean denoting whether or not task has previously been queued.</span></span> <span data-ttu-id="5dc02-264">如果此参数为 True，则该任务以前可能已排队（已计划）；如果为 False，则已知该任务尚未排队，此时将执行此调用，以便以内联方式执行该任务，而不用将其排队。</span><span class="sxs-lookup"><span data-stu-id="5dc02-264">If this parameter is True, then the task may have been previously queued (scheduled); if False, then the task is known not to have been queued, and this call is being made in order to execute the task inline without queuing it.</span></span></param>
        <summary><span data-ttu-id="5dc02-265">确定是否可以在此调用中同步执行提供的 <see cref="T:System.Threading.Tasks.Task" />，如果可以，将执行该任务。</span><span class="sxs-lookup"><span data-stu-id="5dc02-265">Determines whether the provided <see cref="T:System.Threading.Tasks.Task" /> can be executed synchronously in this call, and if it can, executes it.</span></span></summary>
        <returns><span data-ttu-id="5dc02-266">一个布尔值，该值指示是否已以内联方式执行该任务。</span><span class="sxs-lookup"><span data-stu-id="5dc02-266">A Boolean value indicating whether the task was executed inline.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5dc02-267">派生自的类 <xref:System.Threading.Tasks.TaskScheduler> 实现此函数，以支持在启动任务对象等待的线程上内联执行任务。</span><span class="sxs-lookup"><span data-stu-id="5dc02-267">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this function to support inline execution of a task on a thread that initiates a wait on that task object.</span></span> <span data-ttu-id="5dc02-268">"内联执行" 是可选的，并且通过返回 false 可能会拒绝该请求。</span><span class="sxs-lookup"><span data-stu-id="5dc02-268">Inline execution is optional, and the request may be rejected by returning false.</span></span> <span data-ttu-id="5dc02-269">但是，可以内联的任务越多，计划程序的缩放就越好。</span><span class="sxs-lookup"><span data-stu-id="5dc02-269">However, the more tasks that can be inlined, the better the scheduler will scale.</span></span> <span data-ttu-id="5dc02-270">事实上，inlines 太少的计划程序可能容易发生死锁。</span><span class="sxs-lookup"><span data-stu-id="5dc02-270">In fact, a scheduler that inlines too little may be prone to deadlocks.</span></span> <span data-ttu-id="5dc02-271">正确的实现应确保在由计划程序保证的策略下执行的请求可以成功内联。</span><span class="sxs-lookup"><span data-stu-id="5dc02-271">A proper implementation should ensure that a request executing under the policies guaranteed by the scheduler can successfully inline.</span></span> <span data-ttu-id="5dc02-272">例如，如果计划程序使用专用线程来执行任务，则该线程的任何内联请求都应成功。</span><span class="sxs-lookup"><span data-stu-id="5dc02-272">For example, if a scheduler uses a dedicated thread to execute tasks, any inlining requests from that thread should succeed.</span></span>  
  
 <span data-ttu-id="5dc02-273">如果计划程序决定执行内联执行，则应通过 <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> 使用提供的任务对象调用基 TaskScheduler 的方法，传播返回值来执行此操作。</span><span class="sxs-lookup"><span data-stu-id="5dc02-273">If a scheduler decides to perform the inline execution, it should do so by calling to the base TaskScheduler's <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> method with the provided task object, propagating the return value.</span></span> <span data-ttu-id="5dc02-274">如果计划器决定遵循内联请求，则它可能还适用于计划程序从其内部数据结构中删除内联的任务。</span><span class="sxs-lookup"><span data-stu-id="5dc02-274">It may also be appropriate for the scheduler to remove an inlined task from its internal data structures if it decides to honor the inlining request.</span></span> <span data-ttu-id="5dc02-275">但请注意，在某些情况下，可能会要求计划程序将以前没有提供给它的任务内联到该 <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="5dc02-275">Note, however, that under some circumstances a scheduler may be asked to inline a task that was not previously provided to it with the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method.</span></span>  
  
 <span data-ttu-id="5dc02-276">派生计划程序负责确保调用线程适用于其自己的计划和执行策略所涉及的任务。</span><span class="sxs-lookup"><span data-stu-id="5dc02-276">The derived scheduler is responsible for making sure that the calling thread is suitable for executing the given task as far as its own scheduling and execution policies are concerned.</span></span>  
  
 <span data-ttu-id="5dc02-277">有关详细信息，请参阅 <xref:System.Threading.Tasks.TaskScheduler>。</span><span class="sxs-lookup"><span data-stu-id="5dc02-277">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5dc02-278"><paramref name="task" /> 参数为 null。</span><span class="sxs-lookup"><span data-stu-id="5dc02-278">The <paramref name="task" /> argument is null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5dc02-279">已执行的 <paramref name="task" />。</span><span class="sxs-lookup"><span data-stu-id="5dc02-279">The <paramref name="task" /> was already executed.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="5dc02-280">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="5dc02-280">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnobservedTaskException">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException;" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException" />
      <MemberSignature Language="DocId" Value="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UnobservedTaskException As EventHandler(Of UnobservedTaskExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Threading::Tasks::UnobservedTaskExceptionEventArgs ^&gt; ^ UnobservedTaskException;" />
      <MemberSignature Language="F#" Value="member this.UnobservedTaskException : EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " Usage="member this.UnobservedTaskException : System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " />
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt;? UnobservedTaskException;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[add: System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;add: System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[remove: System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;remove: System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5dc02-281">出错的任务中未观察到的异常将触发异常呈报策略时出现，默认情况下会终止进程。</span><span class="sxs-lookup"><span data-stu-id="5dc02-281">Occurs when a faulted task's unobserved exception is about to trigger exception escalation policy, which, by default, would terminate the process.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5dc02-282">此应用程序域范围内的事件提供一种机制来防止异常升级策略 (默认情况下，它会终止进程) 触发。</span><span class="sxs-lookup"><span data-stu-id="5dc02-282">This application domain-wide event provides a mechanism to prevent exception escalation policy (which, by default, terminates the process) from triggering.</span></span>  
  
 <span data-ttu-id="5dc02-283">为了使开发人员可以更轻松地根据任务编写异步代码， [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 更改了未观察到异常的默认异常行为。</span><span class="sxs-lookup"><span data-stu-id="5dc02-283">To make it easier for developers to write asynchronous code based on tasks, the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] changes the default exception behavior for unobserved exceptions.</span></span> <span data-ttu-id="5dc02-284">尽管未观察到异常仍会引发 <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> 异常，但默认情况下该过程不会终止。</span><span class="sxs-lookup"><span data-stu-id="5dc02-284">Although unobserved exceptions still raise the <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> exception, the process does not terminate by default.</span></span> <span data-ttu-id="5dc02-285">相反，引发事件后，运行时将处理异常，而不管事件处理程序是否观察到异常。</span><span class="sxs-lookup"><span data-stu-id="5dc02-285">Instead, the exception is handled by the runtime after the event is raised, regardless of whether an event handler observes the exception.</span></span> <span data-ttu-id="5dc02-286">可以配置此行为。</span><span class="sxs-lookup"><span data-stu-id="5dc02-286">This behavior can be configured.</span></span> <span data-ttu-id="5dc02-287">从开始 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] ，可以使用 [`<ThrowUnobservedTaskExceptions>`](/dotnet/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element) 配置元素恢复到的行为 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，并终止进程：</span><span class="sxs-lookup"><span data-stu-id="5dc02-287">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], you can use the [`<ThrowUnobservedTaskExceptions>`](/dotnet/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element) configuration element to revert to the behavior of the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] and terminate the process:</span></span>  
  
```xml  
<configuration>   
   <runtime>   
      <ThrowUnobservedTaskExceptions enabled="true"/>   
   </runtime>   
</configuration>  
  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="5dc02-288">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="5dc02-288">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="/dotnet/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element"><span data-ttu-id="5dc02-289">&lt;ThrowUnobservedTaskExceptions &gt; 元素</span><span class="sxs-lookup"><span data-stu-id="5dc02-289">&lt;ThrowUnobservedTaskExceptions&gt; Element</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
