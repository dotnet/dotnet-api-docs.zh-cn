<Type Name="Task&lt;TResult&gt;" FullName="System.Threading.Tasks.Task&lt;TResult&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c7d85213452544ae6d0c0b03d1409a50681c6818" /><Meta Name="ms.sourcegitcommit" Value="a8ca33e500a87229bed50d12e09b1347df519648" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="10/09/2020" /><Meta Name="ms.locfileid" Value="91924759" /></Metadata><TypeSignature Language="C#" Value="public class Task&lt;TResult&gt; : System.Threading.Tasks.Task" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Task`1&lt;TResult&gt; extends System.Threading.Tasks.Task" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Task`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Task(Of TResult)&#xA;Inherits Task" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TResult&gt;&#xA;public ref class Task : System::Threading::Tasks::Task" />
  <TypeSignature Language="F#" Value="type Task&lt;'Result&gt; = class&#xA;    inherit Task" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Threading.Tasks" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Threading.Tasks" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Threading.Tasks" FromVersion="4.1.0.0" To="System.Runtime" ToVersion="4.2.0.0" FrameworkAlternate="netcore-2.0" />
    <TypeForwarding From="System.Threading.Tasks" FromVersion="4.1.1.0" To="System.Runtime" ToVersion="4.2.1.0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
    <TypeForwarding From="System.Threading.Tasks" FromVersion="4.1.2.0" To="System.Runtime" ToVersion="4.2.2.0" FrameworkAlternate="netcore-3.1" />
  </TypeForwardingChain>
  <TypeParameters>
    <TypeParameter Name="TResult" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Threading.Tasks.Task</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Diagnostics.DebuggerDisplay("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}, Result = {DebuggerDisplayResultDescription}")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerDisplay("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}, Result = {DebuggerDisplayResultDescription}")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.SystemThreadingTasks_FutureDebugView`1))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.SystemThreadingTasks_FutureDebugView`1))&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TResult"><span data-ttu-id="f59e4-101">此 <see cref="T:System.Threading.Tasks.Task`1" /> 生成的结果的类型。</span><span class="sxs-lookup"><span data-stu-id="f59e4-101">The type of the result produced by this <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></typeparam>
    <summary><span data-ttu-id="f59e4-102">表示一个可以返回值的异步操作。</span><span class="sxs-lookup"><span data-stu-id="f59e4-102">Represents an asynchronous operation that can return a value.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-103"><xref:System.Threading.Tasks.Task%601>类表示单个操作，该操作返回一个值并且通常以异步方式执行。</span><span class="sxs-lookup"><span data-stu-id="f59e4-103">The <xref:System.Threading.Tasks.Task%601> class represents a single operation that returns a value and that usually executes asynchronously.</span></span> <span data-ttu-id="f59e4-104"><xref:System.Threading.Tasks.Task%601> 对象是在 .NET Framework 4 中首次引入的 [基于任务的异步模式](/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap) 的中心组件之一。</span><span class="sxs-lookup"><span data-stu-id="f59e4-104"><xref:System.Threading.Tasks.Task%601> objects are one of the central components of the [task-based asynchronous pattern](/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap) first introduced in the .NET Framework 4.</span></span> <span data-ttu-id="f59e4-105">由于对象执行的工作 <xref:System.Threading.Tasks.Task%601> 通常在线程池线程上异步执行，而不是在主应用程序线程上同步执行，因此可以使用 <xref:System.Threading.Tasks.Task.Status%2A> 属性以及 <xref:System.Threading.Tasks.Task.IsCanceled%2A> 、 <xref:System.Threading.Tasks.Task.IsCompleted%2A> 和 <xref:System.Threading.Tasks.Task.IsFaulted%2A> 属性来确定任务的状态。</span><span class="sxs-lookup"><span data-stu-id="f59e4-105">Because the work performed by a <xref:System.Threading.Tasks.Task%601> object typically executes asynchronously on a thread pool thread rather than synchronously on the main application thread, you can use the <xref:System.Threading.Tasks.Task.Status%2A> property, as well as the <xref:System.Threading.Tasks.Task.IsCanceled%2A>, <xref:System.Threading.Tasks.Task.IsCompleted%2A>, and <xref:System.Threading.Tasks.Task.IsFaulted%2A> properties, to determine the   state of a task.</span></span> <span data-ttu-id="f59e4-106">通常，lambda 表达式用于指定任务要执行的工作。</span><span class="sxs-lookup"><span data-stu-id="f59e4-106">Most commonly, a lambda expression is used to specify the work that the task is to perform.</span></span>  
  
 <span data-ttu-id="f59e4-107"><xref:System.Threading.Tasks.Task%601> 可以通过多种方式创建实例。</span><span class="sxs-lookup"><span data-stu-id="f59e4-107"><xref:System.Threading.Tasks.Task%601> instances may be created in a variety of ways.</span></span> <span data-ttu-id="f59e4-108">从开始，最常见的方法 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 是调用静态 <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> 或 <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="f59e4-108">The most common approach, which is available starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], is to call the static <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> or <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f59e4-109">这些方法提供了一种简单的方法来通过使用默认值来启动任务，而无需获取其他参数。</span><span class="sxs-lookup"><span data-stu-id="f59e4-109">These methods provide a simple way to start a task by using default values and without acquiring additional parameters.</span></span> <span data-ttu-id="f59e4-110">下面的示例使用 <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> 方法来启动任务，该任务将循环，并显示循环迭代次数：</span><span class="sxs-lookup"><span data-stu-id="f59e4-110">The following example uses the <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> method to start a task that loops and then displays the number of loop iterations:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task\`1#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task`1/cs/run1.cs#6)]
 [!code-vb[System.Threading.Tasks.Task\`1#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task`1/vb/run1.vb#6)]  
  
 <span data-ttu-id="f59e4-111">另一种方法是在中启动任务的最常见方法 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 是调用静态 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> 或 <xref:System.Threading.Tasks.TaskFactory%601.StartNew%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="f59e4-111">An alternative, and the most common way to start a task in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], is to call the static <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> or <xref:System.Threading.Tasks.TaskFactory%601.StartNew%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f59e4-112"><xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType>属性返回一个 <xref:System.Threading.Tasks.TaskFactory> 对象， <xref:System.Threading.Tasks.Task%601.Factory%2A?displayProperty=nameWithType> 属性返回一个 <xref:System.Threading.Tasks.TaskFactory%601> 对象。</span><span class="sxs-lookup"><span data-stu-id="f59e4-112">The <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> property returns a <xref:System.Threading.Tasks.TaskFactory> object, and the <xref:System.Threading.Tasks.Task%601.Factory%2A?displayProperty=nameWithType> property returns a <xref:System.Threading.Tasks.TaskFactory%601> object.</span></span> <span data-ttu-id="f59e4-113">使用其方法的重载 `StartNew` 可传递参数、定义任务创建选项，并指定任务计划程序。</span><span class="sxs-lookup"><span data-stu-id="f59e4-113">Overloads of their `StartNew` method let you pass arguments, define task creation options, and specify a task scheduler.</span></span> <span data-ttu-id="f59e4-114">下面的示例使用 <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7B%600%7D%29?displayProperty=nameWithType> 方法来启动任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-114">The following example uses the <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7B%600%7D%29?displayProperty=nameWithType> method to start a task.</span></span> <span data-ttu-id="f59e4-115">它在功能上等效于上一示例中的代码。</span><span class="sxs-lookup"><span data-stu-id="f59e4-115">It is functionally equivalent to the code in the previous example.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task\`1#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task`1/cs/startnew1.cs#7)]
 [!code-vb[System.Threading.Tasks.Task\`1#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task`1/vb/startnew1.vb#7)]  
  
 <span data-ttu-id="f59e4-116">有关更完整的示例，请参阅 [基于任务的异步编程](/dotnet/standard/parallel-programming/task-based-asynchronous-programming)。</span><span class="sxs-lookup"><span data-stu-id="f59e4-116">For more complete examples, see [Task-based Asynchronous Programming](/dotnet/standard/parallel-programming/task-based-asynchronous-programming).</span></span>  
  
 <span data-ttu-id="f59e4-117"><xref:System.Threading.Tasks.Task%601>类还提供了初始化任务的构造函数，但未计划执行该任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-117">The <xref:System.Threading.Tasks.Task%601> class also provides constructors that initialize the task but that do not schedule it for execution.</span></span> <span data-ttu-id="f59e4-118">出于性能原因， <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> 和 `Task.Factory.StartNew` 方法是用于创建和计划计算任务的首选机制，但对于必须分隔任务创建和计划的情况，可以使用构造函数，然后可以使用该任务的 <xref:System.Threading.Tasks.Task.Start%2A> 方法来计划任务以便以后执行。</span><span class="sxs-lookup"><span data-stu-id="f59e4-118">For performance reasons, the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> and `Task.Factory.StartNew` methods are the preferred mechanisms for creating and scheduling computational tasks, but for scenarios where task creation and scheduling must be separated, the constructors may be used, and the task's <xref:System.Threading.Tasks.Task.Start%2A> method may then be used to schedule the task for execution at a later time.</span></span>  
  
 <span data-ttu-id="f59e4-119">从面向的桌面应用程序开始 [!INCLUDE[net_v46](~/includes/net-v46-md.md)] ，创建和调用任务的线程的区域性将成为线程上下文的一部分。</span><span class="sxs-lookup"><span data-stu-id="f59e4-119">Starting with desktop apps that target the [!INCLUDE[net_v46](~/includes/net-v46-md.md)], the culture of the thread that creates and invokes a task becomes part of the thread's context.</span></span> <span data-ttu-id="f59e4-120">也就是说，无论执行任务的线程的当前区域性如何，任务的当前区域性都是调用线程的区域性。</span><span class="sxs-lookup"><span data-stu-id="f59e4-120">That is, regardless of the current culture of the thread on which the task executes, the current culture of the task is the culture of the calling thread.</span></span> <span data-ttu-id="f59e4-121">对于面向之前的 .NET Framework 版本的应用 [!INCLUDE[net_v46](~/includes/net-v46-md.md)] ，任务的区域性是执行任务的线程的区域性。</span><span class="sxs-lookup"><span data-stu-id="f59e4-121">For apps that target versions of the .NET Framework prior to the [!INCLUDE[net_v46](~/includes/net-v46-md.md)], the culture of the task is the culture of the thread on which the task executes.</span></span> <span data-ttu-id="f59e4-122">有关详细信息，请参阅主题中的 "区域性和基于任务的异步操作" 一节 <xref:System.Globalization.CultureInfo> 。</span><span class="sxs-lookup"><span data-stu-id="f59e4-122">For more information, see the "Culture and task-based asynchronous operations" section in the <xref:System.Globalization.CultureInfo> topic.</span></span> <span data-ttu-id="f59e4-123">请注意，应用商店应用按照设置和获取默认区域性中的 Windows 运行时。</span><span class="sxs-lookup"><span data-stu-id="f59e4-123">Note that Store apps follow the Windows Runtime in setting and getting the default culture.</span></span>  
  
<span data-ttu-id="f59e4-124">对于不返回值的操作，请使用 <xref:System.Threading.Tasks.Task> 类。</span><span class="sxs-lookup"><span data-stu-id="f59e4-124">For operations that do not return a value, you use the <xref:System.Threading.Tasks.Task> class.</span></span> <span data-ttu-id="f59e4-125">从 c # 7.0 开始，对于作为值类型而不是引用类型的轻量级任务，请使用 <xref:System.Threading.Tasks.ValueTask%601?displayProperty=nameWithType> 结构。</span><span class="sxs-lookup"><span data-stu-id="f59e4-125">Starting with C# 7.0, for a more lightweight task that is a value type rather than a reference type, use the <xref:System.Threading.Tasks.ValueTask%601?displayProperty=nameWithType> structure.</span></span> 
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="f59e4-126">除之外的所有成员 <see cref="T:System.Threading.Tasks.Task`1" /> <see cref="M:System.Threading.Tasks.Task.Dispose" /> 都是线程安全的，可同时从多个线程使用。</span><span class="sxs-lookup"><span data-stu-id="f59e4-126">All members of <see cref="T:System.Threading.Tasks.Task`1" />, except for <see cref="M:System.Threading.Tasks.Task.Dispose" />, are thread-safe and may be used from multiple threads concurrently.</span></span></threadsafe>
    <altmember cref="T:System.Threading.Tasks.Task" />
    <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="f59e4-127">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="f59e4-127">Task Parallel Library (TPL)</span></span></related>
    <related type="Article" href="/dotnet/standard/parallel-programming/task-based-asynchronous-programming"><span data-ttu-id="f59e4-128">基于任务的异步编程</span><span class="sxs-lookup"><span data-stu-id="f59e4-128">Task-based Asynchronous Programming</span></span></related>
    <related type="ExternalDocumentation" href="https://aka.ms/dotnet-parallel-samples"><span data-ttu-id="f59e4-129">用于与 .NET Core 和 .NET Standard 并行编程的示例</span><span class="sxs-lookup"><span data-stu-id="f59e4-129">Samples for Parallel Programming with the .NET Core and .NET Standard</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f59e4-130">初始化新的 <see cref="T:System.Threading.Tasks.Task`1" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="f59e4-130">Initializes a new <see cref="T:System.Threading.Tasks.Task`1" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (function As Func(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;TResult&gt; ^ function);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; function" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <param name="function"><span data-ttu-id="f59e4-131">表示要在任务中执行的代码的委托。</span><span class="sxs-lookup"><span data-stu-id="f59e4-131">The delegate that represents the code to execute in the task.</span></span> <span data-ttu-id="f59e4-132">在完成此函数后，该任务的 <see cref="P:System.Threading.Tasks.Task`1.Result" /> 属性将设置为返回此函数的结果值。</span><span class="sxs-lookup"><span data-stu-id="f59e4-132">When the function has completed, the task's <see cref="P:System.Threading.Tasks.Task`1.Result" /> property will be set to return the result value of the function.</span></span></param>
        <summary><span data-ttu-id="f59e4-133">使用指定的函数初始化新的 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-133">Initializes a new <see cref="T:System.Threading.Tasks.Task`1" /> with the specified function.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-134">此构造函数只应在需要分离任务的创建和启动的高级方案中使用。</span><span class="sxs-lookup"><span data-stu-id="f59e4-134">This constructor should only be used in advanced scenarios where it is required that the creation and starting of the task is separated.</span></span>  
  
 <span data-ttu-id="f59e4-135">不是调用此构造函数，实例化 <xref:System.Threading.Tasks.Task%601> 对象和启动任务的最常见方法是调用静态 <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> 和 <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7B%600%7D%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="f59e4-135">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task%601> object and launch a task is by calling the static <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> and <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7B%600%7D%29?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="f59e4-136">如果只是为了让 API 的使用者有权等待某些内容而不需要执行任何操作的任务，则 <xref:System.Threading.Tasks.TaskCompletionSource%601> 应使用。</span><span class="sxs-lookup"><span data-stu-id="f59e4-136">If a task with no action is needed just for the consumer of an API to have something to await, a <xref:System.Threading.Tasks.TaskCompletionSource%601> should be used.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f59e4-137">下面的示例对表示已发布书籍的文本文件中的单词的近似数目进行计数。</span><span class="sxs-lookup"><span data-stu-id="f59e4-137">The following example counts the approximate number of words in text files that represent published books.</span></span> <span data-ttu-id="f59e4-138">每个任务都负责打开文件，异步读取其全部内容，并使用正则表达式计算单词计数。</span><span class="sxs-lookup"><span data-stu-id="f59e4-138">Each task is responsible for opening a file, reading its entire contents asynchronously, and calculating the word count by using a regular expression.</span></span> <span data-ttu-id="f59e4-139"><xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType>调用方法以确保所有任务都已完成，然后在控制台中显示每本书的字数。</span><span class="sxs-lookup"><span data-stu-id="f59e4-139">The <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> method is called to ensure that all tasks have completed before displaying the word count of each book to the console.</span></span>  
  
 <span data-ttu-id="f59e4-140">在此示例中，对象实例化与对象执行分离，因此，该示例可以确保每个文件存在。</span><span class="sxs-lookup"><span data-stu-id="f59e4-140">Object instantiation is separated from object execution in this example so that the example can ensure that each file exists.</span></span> <span data-ttu-id="f59e4-141">否则，将显示缺少的文件的名称。</span><span class="sxs-lookup"><span data-stu-id="f59e4-141">If they do not,  it displays the name of the missing file.</span></span> <span data-ttu-id="f59e4-142">否则，它会调用 <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> 方法来启动每个任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-142">Otherwise, it calls the <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> method to launch each task.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/run3.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/run3.vb#2)]  
  
 <span data-ttu-id="f59e4-143">正则表达式模式 `\p{P}*\s+` 匹配后跟一个或多个空白字符的零个、一个或多个标点符号字符。</span><span class="sxs-lookup"><span data-stu-id="f59e4-143">The regular expression pattern `\p{P}*\s+` matches zero, one, or more punctuation characters followed by one or more white-space characters.</span></span> <span data-ttu-id="f59e4-144">它假定匹配项总数等于大致单词计数。</span><span class="sxs-lookup"><span data-stu-id="f59e4-144">It assumes that the total number of matches equals the approximate word count.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f59e4-145"><paramref name="function" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-145">The <paramref name="function" /> argument is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="f59e4-146">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="f59e4-146">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-based-asynchronous-programming"><span data-ttu-id="f59e4-147">基于任务的异步编程</span><span class="sxs-lookup"><span data-stu-id="f59e4-147">Task-based Asynchronous Programming</span></span></related>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f59e4-148"><paramref name="function" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-148">The <paramref name="function" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;object,TResult&gt; function, object state);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`2&lt;object, !TResult&gt; function, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (function As Func(Of Object, TResult), state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;obj, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, state)" />
      <MemberSignature Language="C#" Value="public Task (Func&lt;object,TResult&gt;? function, object state);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="function"><span data-ttu-id="f59e4-149">表示要在任务中执行的代码的委托。</span><span class="sxs-lookup"><span data-stu-id="f59e4-149">The delegate that represents the code to execute in the task.</span></span> <span data-ttu-id="f59e4-150">在完成此函数后，该任务的 <see cref="P:System.Threading.Tasks.Task`1.Result" /> 属性将设置为返回此函数的结果值。</span><span class="sxs-lookup"><span data-stu-id="f59e4-150">When the function has completed, the task's <see cref="P:System.Threading.Tasks.Task`1.Result" /> property will be set to return the result value of the function.</span></span></param>
        <param name="state"><span data-ttu-id="f59e4-151">一个表示由该操作使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="f59e4-151">An object representing data to be used by the action.</span></span></param>
        <summary><span data-ttu-id="f59e4-152">使用指定的函数和状态初始化新的 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-152">Initializes a new <see cref="T:System.Threading.Tasks.Task`1" /> with the specified function and state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-153">要实例化对象并启动任务，最常见的方法 <xref:System.Threading.Tasks.Task%601> 是调用静态方法，而不是调用此构造函数 <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7BSystem.Object%2C%600%7D%2CSystem.Object%29?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f59e4-153">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task%601> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7BSystem.Object%2C%600%7D%2CSystem.Object%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f59e4-154">此构造函数提供的唯一优点是它允许将对象实例化与任务调用分离。</span><span class="sxs-lookup"><span data-stu-id="f59e4-154">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f59e4-155"><paramref name="function" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-155">The <paramref name="function" /> argument is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="f59e4-156">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="f59e4-156">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-based-asynchronous-programming"><span data-ttu-id="f59e4-157">基于任务的异步编程</span><span class="sxs-lookup"><span data-stu-id="f59e4-157">Task-based Asynchronous Programming</span></span></related>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f59e4-158"><paramref name="function" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-158">The <paramref name="function" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (function As Func(Of TResult), cancellationToken As CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="function"><span data-ttu-id="f59e4-159">表示要在任务中执行的代码的委托。</span><span class="sxs-lookup"><span data-stu-id="f59e4-159">The delegate that represents the code to execute in the task.</span></span> <span data-ttu-id="f59e4-160">在完成此函数后，该任务的 <see cref="P:System.Threading.Tasks.Task`1.Result" /> 属性将设置为返回此函数的结果值。</span><span class="sxs-lookup"><span data-stu-id="f59e4-160">When the function has completed, the task's <see cref="P:System.Threading.Tasks.Task`1.Result" /> property will be set to return the result value of the function.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f59e4-161">将指派给此任务的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-161">The <see cref="T:System.Threading.CancellationToken" /> to be assigned to this task.</span></span></param>
        <summary><span data-ttu-id="f59e4-162">使用指定的函数初始化新的 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-162">Initializes a new <see cref="T:System.Threading.Tasks.Task`1" /> with the specified function.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-163">不是调用此构造函数，实例化 <xref:System.Threading.Tasks.Task%601> 对象和启动任务的最常见方法是调用静态 <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> 和 <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7B%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="f59e4-163">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task%601> object and launch a task is by calling the static <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> and <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7B%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="f59e4-164">此构造函数提供的唯一优点是它允许将对象实例化与任务调用分离。</span><span class="sxs-lookup"><span data-stu-id="f59e4-164">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f59e4-165">创建了 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" /> 已经被释放。</span><span class="sxs-lookup"><span data-stu-id="f59e4-165">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f59e4-166"><paramref name="function" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-166">The <paramref name="function" /> argument is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="f59e4-167">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="f59e4-167">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-based-asynchronous-programming"><span data-ttu-id="f59e4-168">基于任务的异步编程</span><span class="sxs-lookup"><span data-stu-id="f59e4-168">Task-based Asynchronous Programming</span></span></related>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f59e4-169"><paramref name="function" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-169">The <paramref name="function" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;TResult&gt; function, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!TResult&gt; function, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (function As Func(Of TResult), creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;TResult&gt; ^ function, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;'Result&gt; * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="function"><span data-ttu-id="f59e4-170">表示要在任务中执行的代码的委托。</span><span class="sxs-lookup"><span data-stu-id="f59e4-170">The delegate that represents the code to execute in the task.</span></span> <span data-ttu-id="f59e4-171">在完成此函数后，该任务的 <see cref="P:System.Threading.Tasks.Task`1.Result" /> 属性将设置为返回此函数的结果值。</span><span class="sxs-lookup"><span data-stu-id="f59e4-171">When the function has completed, the task's <see cref="P:System.Threading.Tasks.Task`1.Result" /> property will be set to return the result value of the function.</span></span></param>
        <param name="creationOptions"><span data-ttu-id="f59e4-172">用于自定义任务的行为的 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-172">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to customize the task's behavior.</span></span></param>
        <summary><span data-ttu-id="f59e4-173">使用指定的函数和创建选项初始化新的 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-173">Initializes a new <see cref="T:System.Threading.Tasks.Task`1" /> with the specified function and creation options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-174">要实例化对象并启动任务，最常见的方法 <xref:System.Threading.Tasks.Task%601> 是调用静态方法，而不是调用此构造函数 <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7B%600%7D%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f59e4-174">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task%601> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7B%600%7D%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f59e4-175">此构造函数提供的唯一优点是它允许将对象实例化与任务调用分离。</span><span class="sxs-lookup"><span data-stu-id="f59e4-175">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f59e4-176"><paramref name="creationOptions" /> 参数为 <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> 指定无效值。</span><span class="sxs-lookup"><span data-stu-id="f59e4-176">The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f59e4-177"><paramref name="function" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-177">The <paramref name="function" /> argument is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="f59e4-178">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="f59e4-178">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-based-asynchronous-programming"><span data-ttu-id="f59e4-179">基于任务的异步编程</span><span class="sxs-lookup"><span data-stu-id="f59e4-179">Task-based Asynchronous Programming</span></span></related>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f59e4-180"><paramref name="function" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-180">The <paramref name="function" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`2&lt;object, !TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (function As Func(Of Object, TResult), state As Object, cancellationToken As CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;obj, 'Result&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, state, cancellationToken)" />
      <MemberSignature Language="C#" Value="public Task (Func&lt;object,TResult&gt;? function, object state, System.Threading.CancellationToken cancellationToken);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="function"><span data-ttu-id="f59e4-181">表示要在任务中执行的代码的委托。</span><span class="sxs-lookup"><span data-stu-id="f59e4-181">The delegate that represents the code to execute in the task.</span></span> <span data-ttu-id="f59e4-182">在完成此函数后，该任务的 <see cref="P:System.Threading.Tasks.Task`1.Result" /> 属性将设置为返回此函数的结果值。</span><span class="sxs-lookup"><span data-stu-id="f59e4-182">When the function has completed, the task's <see cref="P:System.Threading.Tasks.Task`1.Result" /> property will be set to return the result value of the function.</span></span></param>
        <param name="state"><span data-ttu-id="f59e4-183">一个表示将由此函数使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="f59e4-183">An object representing data to be used by the function.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f59e4-184">将指派给此新任务的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-184">The <see cref="T:System.Threading.CancellationToken" /> to be assigned to the new task.</span></span></param>
        <summary><span data-ttu-id="f59e4-185">使用指定的操作、状态和选项初始化新的 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-185">Initializes a new <see cref="T:System.Threading.Tasks.Task`1" /> with the specified action, state, and options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-186">要实例化对象并启动任务，最常见的方法 <xref:System.Threading.Tasks.Task%601> 是调用静态方法，而不是调用此构造函数 <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7BSystem.Object%2C%600%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f59e4-186">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task%601> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7BSystem.Object%2C%600%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f59e4-187">此构造函数提供的唯一优点是它允许将对象实例化与任务调用分离。</span><span class="sxs-lookup"><span data-stu-id="f59e4-187">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f59e4-188">创建了 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" /> 已经被释放。</span><span class="sxs-lookup"><span data-stu-id="f59e4-188">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f59e4-189"><paramref name="function" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-189">The <paramref name="function" /> argument is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="f59e4-190">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="f59e4-190">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-based-asynchronous-programming"><span data-ttu-id="f59e4-191">基于任务的异步编程</span><span class="sxs-lookup"><span data-stu-id="f59e4-191">Task-based Asynchronous Programming</span></span></related>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f59e4-192"><paramref name="function" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-192">The <paramref name="function" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;object,TResult&gt; function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`2&lt;object, !TResult&gt; function, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (function As Func(Of Object, TResult), state As Object, creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;obj, 'Result&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, state, creationOptions)" />
      <MemberSignature Language="C#" Value="public Task (Func&lt;object,TResult&gt;? function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="function"><span data-ttu-id="f59e4-193">表示要在任务中执行的代码的委托。</span><span class="sxs-lookup"><span data-stu-id="f59e4-193">The delegate that represents the code to execute in the task.</span></span> <span data-ttu-id="f59e4-194">在完成此函数后，该任务的 <see cref="P:System.Threading.Tasks.Task`1.Result" /> 属性将设置为返回此函数的结果值。</span><span class="sxs-lookup"><span data-stu-id="f59e4-194">When the function has completed, the task's <see cref="P:System.Threading.Tasks.Task`1.Result" /> property will be set to return the result value of the function.</span></span></param>
        <param name="state"><span data-ttu-id="f59e4-195">一个表示将由此函数使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="f59e4-195">An object representing data to be used by the function.</span></span></param>
        <param name="creationOptions"><span data-ttu-id="f59e4-196">用于自定义任务的行为的 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-196">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to customize the task's behavior.</span></span></param>
        <summary><span data-ttu-id="f59e4-197">使用指定的操作、状态和选项初始化新的 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-197">Initializes a new <see cref="T:System.Threading.Tasks.Task`1" /> with the specified action, state, and options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-198">要实例化对象并启动任务，最常见的方法 <xref:System.Threading.Tasks.Task%601> 是调用静态方法，而不是调用此构造函数 <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7BSystem.Object%2C%600%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f59e4-198">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task%601> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7BSystem.Object%2C%600%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f59e4-199">此构造函数提供的唯一优点是它允许将对象实例化与任务调用分离。</span><span class="sxs-lookup"><span data-stu-id="f59e4-199">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f59e4-200"><paramref name="creationOptions" /> 参数为 <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> 指定无效值。</span><span class="sxs-lookup"><span data-stu-id="f59e4-200">The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f59e4-201"><paramref name="function" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-201">The <paramref name="function" /> argument is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="f59e4-202">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="f59e4-202">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-based-asynchronous-programming"><span data-ttu-id="f59e4-203">基于任务的异步编程</span><span class="sxs-lookup"><span data-stu-id="f59e4-203">Task-based Asynchronous Programming</span></span></related>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f59e4-204"><paramref name="function" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-204">The <paramref name="function" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (function As Func(Of TResult), cancellationToken As CancellationToken, creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="function"><span data-ttu-id="f59e4-205">表示要在任务中执行的代码的委托。</span><span class="sxs-lookup"><span data-stu-id="f59e4-205">The delegate that represents the code to execute in the task.</span></span> <span data-ttu-id="f59e4-206">在完成此函数后，该任务的 <see cref="P:System.Threading.Tasks.Task`1.Result" /> 属性将设置为返回此函数的结果值。</span><span class="sxs-lookup"><span data-stu-id="f59e4-206">When the function has completed, the task's <see cref="P:System.Threading.Tasks.Task`1.Result" /> property will be set to return the result value of the function.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f59e4-207">将指派给新任务的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-207">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new task.</span></span></param>
        <param name="creationOptions"><span data-ttu-id="f59e4-208">用于自定义任务的行为的 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-208">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to customize the task's behavior.</span></span></param>
        <summary><span data-ttu-id="f59e4-209">使用指定的函数和创建选项初始化新的 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-209">Initializes a new <see cref="T:System.Threading.Tasks.Task`1" /> with the specified function and creation options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-210">要实例化对象并启动任务，最常见的方法 <xref:System.Threading.Tasks.Task%601> 是调用静态方法，而不是调用此构造函数 <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f59e4-210">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task%601> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> method.</span></span>  <span data-ttu-id="f59e4-211">此构造函数提供的唯一优点是它允许将对象实例化与任务调用分离。</span><span class="sxs-lookup"><span data-stu-id="f59e4-211">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f59e4-212">创建了 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" /> 已经被释放。</span><span class="sxs-lookup"><span data-stu-id="f59e4-212">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f59e4-213"><paramref name="creationOptions" /> 参数为 <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> 指定无效值。</span><span class="sxs-lookup"><span data-stu-id="f59e4-213">The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f59e4-214"><paramref name="function" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-214">The <paramref name="function" /> argument is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="f59e4-215">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="f59e4-215">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-based-asynchronous-programming"><span data-ttu-id="f59e4-216">基于任务的异步编程</span><span class="sxs-lookup"><span data-stu-id="f59e4-216">Task-based Asynchronous Programming</span></span></related>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f59e4-217"><paramref name="function" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-217">The <paramref name="function" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`2&lt;object, !TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (function As Func(Of Object, TResult), state As Object, cancellationToken As CancellationToken, creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;obj, 'Result&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, state, cancellationToken, creationOptions)" />
      <MemberSignature Language="C#" Value="public Task (Func&lt;object,TResult&gt;? function, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="function"><span data-ttu-id="f59e4-218">表示要在任务中执行的代码的委托。</span><span class="sxs-lookup"><span data-stu-id="f59e4-218">The delegate that represents the code to execute in the task.</span></span> <span data-ttu-id="f59e4-219">在完成此函数后，该任务的 <see cref="P:System.Threading.Tasks.Task`1.Result" /> 属性将设置为返回此函数的结果值。</span><span class="sxs-lookup"><span data-stu-id="f59e4-219">When the function has completed, the task's <see cref="P:System.Threading.Tasks.Task`1.Result" /> property will be set to return the result value of the function.</span></span></param>
        <param name="state"><span data-ttu-id="f59e4-220">一个表示将由此函数使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="f59e4-220">An object representing data to be used by the function.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f59e4-221">将指派给此新任务的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-221">The <see cref="T:System.Threading.CancellationToken" /> to be assigned to the new task.</span></span></param>
        <param name="creationOptions"><span data-ttu-id="f59e4-222">用于自定义任务的行为的 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-222">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to customize the task's behavior.</span></span></param>
        <summary><span data-ttu-id="f59e4-223">使用指定的操作、状态和选项初始化新的 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-223">Initializes a new <see cref="T:System.Threading.Tasks.Task`1" /> with the specified action, state, and options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-224">要实例化对象并启动任务，最常见的方法 <xref:System.Threading.Tasks.Task%601> 是调用静态方法，而不是调用此构造函数 <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7BSystem.Object%2C%600%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f59e4-224">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task%601> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7BSystem.Object%2C%600%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f59e4-225">此构造函数提供的唯一优点是它允许将对象实例化与任务调用分离。</span><span class="sxs-lookup"><span data-stu-id="f59e4-225">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f59e4-226">创建了 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" /> 已经被释放。</span><span class="sxs-lookup"><span data-stu-id="f59e4-226">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f59e4-227"><paramref name="creationOptions" /> 参数为 <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> 指定无效值。</span><span class="sxs-lookup"><span data-stu-id="f59e4-227">The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f59e4-228"><paramref name="function" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-228">The <paramref name="function" /> argument is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="f59e4-229">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="f59e4-229">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-based-asynchronous-programming"><span data-ttu-id="f59e4-230">基于任务的异步编程</span><span class="sxs-lookup"><span data-stu-id="f59e4-230">Task-based Asynchronous Programming</span></span></related>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f59e4-231"><paramref name="function" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-231">The <paramref name="function" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ConfigureAwait">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.ConfiguredTaskAwaitable&lt;TResult&gt; ConfigureAwait (bool continueOnCapturedContext);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1&lt;!TResult&gt; ConfigureAwait(bool continueOnCapturedContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ConfigureAwait(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConfigureAwait (continueOnCapturedContext As Boolean) As ConfiguredTaskAwaitable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::ConfiguredTaskAwaitable&lt;TResult&gt; ConfigureAwait(bool continueOnCapturedContext);" />
      <MemberSignature Language="F#" Value="override this.ConfigureAwait : bool -&gt; System.Runtime.CompilerServices.ConfiguredTaskAwaitable&lt;'Result&gt;" Usage="task.ConfigureAwait continueOnCapturedContext" />
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.ConfiguredTaskAwaitable&lt;TResult&gt;? ConfigureAwait (bool continueOnCapturedContext);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.ConfiguredTaskAwaitable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continueOnCapturedContext" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continueOnCapturedContext"><span data-ttu-id="f59e4-232">尝试将延续任务封送回原始上下文，则为 true；否则为 false。</span><span class="sxs-lookup"><span data-stu-id="f59e4-232">true to attempt to marshal the continuation back to the original context captured; otherwise, false.</span></span></param>
        <summary><span data-ttu-id="f59e4-233">配置用于等待此 <see cref="T:System.Threading.Tasks.Task`1" />的 awaiter。</span><span class="sxs-lookup"><span data-stu-id="f59e4-233">Configures an awaiter used to await this <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></summary>
        <returns><span data-ttu-id="f59e4-234">用于的等待此任务的对象。</span><span class="sxs-lookup"><span data-stu-id="f59e4-234">An object used to await this task.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWith">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f59e4-235">创建当另一任务完成时可以执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-235">Creates a continuation task that executes when another task completes.</span></span></summary>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="f59e4-236">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="f59e4-236">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-based-asynchronous-programming"><span data-ttu-id="f59e4-237">基于任务的异步编程</span><span class="sxs-lookup"><span data-stu-id="f59e4-237">Task-based Asynchronous Programming</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks"><span data-ttu-id="f59e4-238">使用延续任务来链接任务</span><span class="sxs-lookup"><span data-stu-id="f59e4-238">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult))) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith continuationAction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="f59e4-239">在 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时要运行的操作。</span><span class="sxs-lookup"><span data-stu-id="f59e4-239">An action to run when the antecedent <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="f59e4-240">在运行时，委托将作为一个自变量传递给完成的任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-240">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <summary><span data-ttu-id="f59e4-241">创建一个在目标任务完成时异步执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-241">Creates a continuation that executes asynchronously when the target task completes.</span></span></summary>
        <returns><span data-ttu-id="f59e4-242">一个新的延续任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-242">A new continuation task.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-243">返回的 <xref:System.Threading.Tasks.Task> 将不会计划执行，直到当前任务已完成，该任务是否已完成，因为该任务已成功完成、是否由于未经处理的异常而出错，或由于被取消而导致退出。</span><span class="sxs-lookup"><span data-stu-id="f59e4-243">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting early due to being canceled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f59e4-244">下面的示例创建一个前面的任务，该任务使用尼斯筛法的埃拉托色计算1与用户输入的值之间的质数。</span><span class="sxs-lookup"><span data-stu-id="f59e4-244">The following example creates an antecedent task that uses the Sieve of Eratosthenes to calculate the prime numbers between 1 and a value entered by the user.</span></span> <span data-ttu-id="f59e4-245">数组用于保存有关质数的信息。</span><span class="sxs-lookup"><span data-stu-id="f59e4-245">An array is used to hold information about the prime numbers.</span></span> <span data-ttu-id="f59e4-246">数组索引表示该数字，并且该元素的值指示该数字是复合的 (其值是 `true`) 还是质数 (其值 `false`) 。</span><span class="sxs-lookup"><span data-stu-id="f59e4-246">The array index represents the number, and the element's value indicates whether that number is composite (its value is `true`) or prime (its value is `false`).</span></span> <span data-ttu-id="f59e4-247">然后，将此任务传递到延续任务，该任务负责从整数数组中提取质数并显示它们。</span><span class="sxs-lookup"><span data-stu-id="f59e4-247">This task is then passed to a continuation task, which is responsible for extracting the prime numbers from the integer array and displaying them.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task\`1.ContinueWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/cs/continue2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task\`1.ContinueWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/vb/continue2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f59e4-248">已释放了 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-248">The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f59e4-249"><paramref name="continuationAction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-249">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="f59e4-250">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="f59e4-250">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-based-asynchronous-programming"><span data-ttu-id="f59e4-251">基于任务的异步编程</span><span class="sxs-lookup"><span data-stu-id="f59e4-251">Task-based Asynchronous Programming</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks"><span data-ttu-id="f59e4-252">使用延续任务来链接任务</span><span class="sxs-lookup"><span data-stu-id="f59e4-252">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt; continuationAction, object state);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object&gt; continuationAction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult), Object), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt;? continuationAction, object? state);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="f59e4-253">在 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时要运行的操作。</span><span class="sxs-lookup"><span data-stu-id="f59e4-253">An action to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="f59e4-254">运行时，委托作为一个自变量传递给完成的任务和调用方提供的状态对象。</span><span class="sxs-lookup"><span data-stu-id="f59e4-254">When run, the delegate is   passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="f59e4-255">一个表示由该延续操作使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="f59e4-255">An object representing data to be used by the continuation action.</span></span></param>
        <summary><span data-ttu-id="f59e4-256">创建一个传递有状态信息并在目标 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时执行的延续。</span><span class="sxs-lookup"><span data-stu-id="f59e4-256">Creates a continuation that is passed state information and that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="f59e4-257">一个新的延续 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-257">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-258">返回的 <xref:System.Threading.Tasks.Task> 将不会计划执行，直到当前任务已完成，该任务是否已完成，因为该任务已成功完成、是否由于未经处理的异常而发生故障，或由于被取消而发生错误。</span><span class="sxs-lookup"><span data-stu-id="f59e4-258">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f59e4-259">下面的示例创建一个任务，该任务被传递一个介于2和20之间的整数，并返回一个数组，其中包含前10个指数 (从 n<sup>1</sup> 到 n<sup>10</sup>) 该数字。</span><span class="sxs-lookup"><span data-stu-id="f59e4-259">The following example creates a task that is passed an integer between 2 and 20 and returns an array that contains the first ten exponents (from n<sup>1</sup> to n<sup>10</sup>) of that number.</span></span> <span data-ttu-id="f59e4-260">然后，延续任务负责显示指数。</span><span class="sxs-lookup"><span data-stu-id="f59e4-260">A continuation task is then responsible for displaying the exponents.</span></span> <span data-ttu-id="f59e4-261">它同时传递前面的任务和前面的任务生成的初始数字。</span><span class="sxs-lookup"><span data-stu-id="f59e4-261">It is passed both the antecedent and the original number whose exponents the antecedent generates.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task\`1.ContinueWith#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/cs/continuewith3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task\`1.ContinueWith#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/vb/continuewith3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f59e4-262"><paramref name="continuationAction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-262">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks"><span data-ttu-id="f59e4-263">使用延续任务来链接任务</span><span class="sxs-lookup"><span data-stu-id="f59e4-263">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult)), cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="f59e4-264">在 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时要运行的操作。</span><span class="sxs-lookup"><span data-stu-id="f59e4-264">An action to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="f59e4-265">在运行时，委托作为一个参数传递给完成的任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-265">When run, the delegate is passed the completed task as an argument.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f59e4-266">传递给新的延续任务的取消标记。</span><span class="sxs-lookup"><span data-stu-id="f59e4-266">The cancellation token that is passed to the new continuation task.</span></span></param>
        <summary><span data-ttu-id="f59e4-267">创建一个在目标 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时异步执行的可取消延续任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-267">Creates a cancelable continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="f59e4-268">一个新的延续任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-268">A new continuation task.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-269">返回的 <xref:System.Threading.Tasks.Task> 将不会计划执行，直到当前任务已完成，该任务是否已完成，因为该任务已成功完成、是否由于未经处理的异常而发生故障，或由于被取消而发生错误。</span><span class="sxs-lookup"><span data-stu-id="f59e4-269">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f59e4-270">下面的示例创建一个前面的任务，该任务使用尼斯筛法的埃拉托色计算1与用户输入的值之间的质数。</span><span class="sxs-lookup"><span data-stu-id="f59e4-270">The following example creates an antecedent task that uses the Sieve of Eratosthenes to calculate the prime numbers between 1 and a value entered by the user.</span></span> <span data-ttu-id="f59e4-271">数组用于保存有关质数的信息。</span><span class="sxs-lookup"><span data-stu-id="f59e4-271">An array is used to hold information about the prime numbers.</span></span> <span data-ttu-id="f59e4-272">数组索引表示该数字，并且该元素的值指示该数字是复合的 (其值是 `true`) 还是质数 (其值 `false`) 。</span><span class="sxs-lookup"><span data-stu-id="f59e4-272">The array index represents the number, and the element's value indicates whether that number is composite (its value is `true`) or prime (its value is `false`).</span></span> <span data-ttu-id="f59e4-273">然后，将此任务传递到延续任务，该任务负责从整数数组中提取质数并显示它们。</span><span class="sxs-lookup"><span data-stu-id="f59e4-273">This task is then passed to a continuation task, which is responsible for extracting the prime numbers from the integer array and displaying them.</span></span>  
  
 <span data-ttu-id="f59e4-274">取消标记将同时传递到前面的任务和延续任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-274">A cancellation token is passed to both the antecedent and the continuation task.</span></span> <span data-ttu-id="f59e4-275"><xref:System.Timers.Timer?displayProperty=nameWithType>对象用于定义的超时值为100毫秒。</span><span class="sxs-lookup"><span data-stu-id="f59e4-275">A <xref:System.Timers.Timer?displayProperty=nameWithType> object is used to define a timeout value of 100 milliseconds.</span></span> <span data-ttu-id="f59e4-276">如果事件激发，将 <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> 调用方法，并且取消标记用于请求取消任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-276">If the event fires, the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method is called, and the cancellation token is used to request cancellation of the tasks.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task\`1.ContinueWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/cs/continue1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task\`1.ContinueWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/vb/continue1.vb#1)]  
  
 <span data-ttu-id="f59e4-277">通常，提供约100000的值会导致超时间隔过期，并 <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> 引发事件以及要设置的取消请求。</span><span class="sxs-lookup"><span data-stu-id="f59e4-277">Typically, supplying a value of about 100,000 causes the timeout interval to expire and the <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> event to fire, and the cancellation request to be set.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f59e4-278">已释放了 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-278">The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.</span></span>  
  
<span data-ttu-id="f59e4-279">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f59e4-279">-or-</span></span> 
<span data-ttu-id="f59e4-280">创建了 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" /> 已经被释放。</span><span class="sxs-lookup"><span data-stu-id="f59e4-280">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f59e4-281"><paramref name="continuationAction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-281">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="f59e4-282">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="f59e4-282">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-based-asynchronous-programming"><span data-ttu-id="f59e4-283">基于任务的异步编程</span><span class="sxs-lookup"><span data-stu-id="f59e4-283">Task-based Asynchronous Programming</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks"><span data-ttu-id="f59e4-284">使用延续任务来链接任务</span><span class="sxs-lookup"><span data-stu-id="f59e4-284">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult)), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="f59e4-285">在 <paramref name="continuationOptions" /> 中指定的条件的操作。</span><span class="sxs-lookup"><span data-stu-id="f59e4-285">An action to according the condition specified in <paramref name="continuationOptions" />.</span></span> <span data-ttu-id="f59e4-286">在运行时，委托将作为一个自变量传递给完成的任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-286">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="f59e4-287">用于设置计划延续任务的时间以及延续任务的工作方式的选项。</span><span class="sxs-lookup"><span data-stu-id="f59e4-287">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="f59e4-288">这包括条件（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />）和执行选项（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />）。</span><span class="sxs-lookup"><span data-stu-id="f59e4-288">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <summary><span data-ttu-id="f59e4-289">创建根据 <paramref name="continuationOptions" /> 中指定的条件加以执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-289">Creates a continuation that executes according the condition specified in <paramref name="continuationOptions" />.</span></span></summary>
        <returns><span data-ttu-id="f59e4-290">一个新的延续 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-290">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-291"><xref:System.Threading.Tasks.Task>直到当前任务完成后，才会安排返回的执行。</span><span class="sxs-lookup"><span data-stu-id="f59e4-291">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="f59e4-292">如果未满足通过参数指定的继续条件 `continuationOptions` ，则将取消延续任务，而不是计划。</span><span class="sxs-lookup"><span data-stu-id="f59e4-292">If the continuation criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 <span data-ttu-id="f59e4-293">有关详细信息，请参阅[使用延续任务链接任务](/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks)。</span><span class="sxs-lookup"><span data-stu-id="f59e4-293">For more information, see [Chaining Tasks by Using Continuation Tasks](/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f59e4-294">已释放了 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-294">The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f59e4-295"><paramref name="continuationAction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-295">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f59e4-296"><paramref name="continuationOptions" /> 参数为 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 指定无效值。</span><span class="sxs-lookup"><span data-stu-id="f59e4-296">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="f59e4-297">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="f59e4-297">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-based-asynchronous-programming"><span data-ttu-id="f59e4-298">基于任务的异步编程</span><span class="sxs-lookup"><span data-stu-id="f59e4-298">Task-based Asynchronous Programming</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks"><span data-ttu-id="f59e4-299">使用延续任务来链接任务</span><span class="sxs-lookup"><span data-stu-id="f59e4-299">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; continuationAction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;&gt; continuationAction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult)), scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ continuationAction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="f59e4-300">在 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时要运行的操作。</span><span class="sxs-lookup"><span data-stu-id="f59e4-300">An action to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="f59e4-301">在运行时，委托将作为一个自变量传递给完成的任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-301">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="scheduler"><span data-ttu-id="f59e4-302">要与延续任务关联并用于其执行过程的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-302">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="f59e4-303">创建一个在目标 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时异步执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-303">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="f59e4-304">一个新的延续 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-304">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-305">返回的 <xref:System.Threading.Tasks.Task> 将不会计划执行，直到当前任务已完成，该任务是否已完成，因为该任务已成功完成、是否由于未经处理的异常而发生故障，或由于被取消而发生错误。</span><span class="sxs-lookup"><span data-stu-id="f59e4-305">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f59e4-306">已释放了 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-306">The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f59e4-307"><paramref name="continuationAction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-307">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f59e4-308">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f59e4-308">-or-</span></span> 
<span data-ttu-id="f59e4-309"><paramref name="scheduler" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-309">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="f59e4-310">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="f59e4-310">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-based-asynchronous-programming"><span data-ttu-id="f59e4-311">基于任务的异步编程</span><span class="sxs-lookup"><span data-stu-id="f59e4-311">Task-based Asynchronous Programming</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks"><span data-ttu-id="f59e4-312">使用延续任务来链接任务</span><span class="sxs-lookup"><span data-stu-id="f59e4-312">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult), Object), state As Object, cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt;? continuationAction, object? state, System.Threading.CancellationToken cancellationToken);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="f59e4-313">在 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时要运行的操作。</span><span class="sxs-lookup"><span data-stu-id="f59e4-313">An action to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="f59e4-314">运行时，将传递委托，如完成的任务一样，调用方提供的状态对象（如自变量）。</span><span class="sxs-lookup"><span data-stu-id="f59e4-314">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="f59e4-315">一个表示由该延续操作使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="f59e4-315">An object representing data to be used by the continuation action.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f59e4-316">将指派给新的延续任务的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-316">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <summary><span data-ttu-id="f59e4-317">创建一个在目标 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-317">Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="f59e4-318">一个新的延续 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-318">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-319">返回的 <xref:System.Threading.Tasks.Task> 将不会计划执行，直到当前任务已完成，该任务是否已完成，因为该任务已成功完成、是否由于未经处理的异常而发生故障，或由于被取消而发生错误。</span><span class="sxs-lookup"><span data-stu-id="f59e4-319">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f59e4-320"><paramref name="continuationAction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-320">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f59e4-321">已释放提供的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-321">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks"><span data-ttu-id="f59e4-322">使用延续任务来链接任务</span><span class="sxs-lookup"><span data-stu-id="f59e4-322">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt; continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object&gt; continuationAction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult), Object), state As Object, continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, continuationOptions)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt;? continuationAction, object? state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="f59e4-323">在 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时要运行的操作。</span><span class="sxs-lookup"><span data-stu-id="f59e4-323">An action to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="f59e4-324">运行时，将传递委托，如完成的任务一样，调用方提供的状态对象（如自变量）。</span><span class="sxs-lookup"><span data-stu-id="f59e4-324">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="f59e4-325">一个表示由该延续操作使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="f59e4-325">An object representing data to be used by the continuation action.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="f59e4-326">用于设置计划延续任务的时间以及延续任务的工作方式的选项。</span><span class="sxs-lookup"><span data-stu-id="f59e4-326">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="f59e4-327">这包括条件（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />）和执行选项（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />）。</span><span class="sxs-lookup"><span data-stu-id="f59e4-327">This includes criteria, such  as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <summary><span data-ttu-id="f59e4-328">创建一个在目标 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-328">Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="f59e4-329">一个新的延续 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-329">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-330"><xref:System.Threading.Tasks.Task>直到当前任务完成后，才会安排返回的执行。</span><span class="sxs-lookup"><span data-stu-id="f59e4-330">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="f59e4-331">如果未满足通过参数指定的继续条件 `continuationOptions` ，则将取消延续任务，而不是计划。</span><span class="sxs-lookup"><span data-stu-id="f59e4-331">If the continuation criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f59e4-332"><paramref name="continuationAction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-332">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f59e4-333"><paramref name="continuationOptions" /> 参数为 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 指定无效值。</span><span class="sxs-lookup"><span data-stu-id="f59e4-333">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks"><span data-ttu-id="f59e4-334">使用延续任务来链接任务</span><span class="sxs-lookup"><span data-stu-id="f59e4-334">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt; continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object&gt; continuationAction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult), Object), state As Object, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, scheduler)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt;? continuationAction, object? state, System.Threading.Tasks.TaskScheduler scheduler);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="f59e4-335">在 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时要运行的操作。</span><span class="sxs-lookup"><span data-stu-id="f59e4-335">An action to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="f59e4-336">运行时，将传递委托，如完成的任务一样，调用方提供的状态对象（如参数）。</span><span class="sxs-lookup"><span data-stu-id="f59e4-336">When run, the delegate will be passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="f59e4-337">一个表示由该延续操作使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="f59e4-337">An object representing data to be used by the continuation action.</span></span></param>
        <param name="scheduler"><span data-ttu-id="f59e4-338">要与延续任务关联并用于其执行过程的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-338">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="f59e4-339">创建一个在目标 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-339">Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="f59e4-340">一个新的延续 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-340">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-341">返回的 <xref:System.Threading.Tasks.Task> 将不会计划执行，直到当前任务已完成，该任务是否已完成，因为该任务已成功完成、是否由于未经处理的异常而发生故障，或由于被取消而发生错误。</span><span class="sxs-lookup"><span data-stu-id="f59e4-341">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f59e4-342"><paramref name="scheduler" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-342">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks"><span data-ttu-id="f59e4-343">使用延续任务来链接任务</span><span class="sxs-lookup"><span data-stu-id="f59e4-343">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult)), cancellationToken As CancellationToken, continuationOptions As TaskContinuationOptions, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="f59e4-344">根据在 <paramref name="continuationOptions" /> 中指定的条件运行的操作。</span><span class="sxs-lookup"><span data-stu-id="f59e4-344">An action to run according the condition specified in <paramref name="continuationOptions" />.</span></span> <span data-ttu-id="f59e4-345">在运行时，委托将作为一个自变量传递给完成的任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-345">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f59e4-346">将指派给新的延续任务的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-346">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="f59e4-347">用于设置计划延续任务的时间以及延续任务的工作方式的选项。</span><span class="sxs-lookup"><span data-stu-id="f59e4-347">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="f59e4-348">这包括条件（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />）和执行选项（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />）。</span><span class="sxs-lookup"><span data-stu-id="f59e4-348">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <param name="scheduler"><span data-ttu-id="f59e4-349">要与延续任务关联并用于其执行过程的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-349">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="f59e4-350">创建根据 <paramref name="continuationOptions" /> 中指定的条件加以执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-350">Creates a continuation that executes according the condition specified in <paramref name="continuationOptions" />.</span></span></summary>
        <returns><span data-ttu-id="f59e4-351">一个新的延续 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-351">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-352"><xref:System.Threading.Tasks.Task>直到当前任务完成后，才会安排返回的执行。</span><span class="sxs-lookup"><span data-stu-id="f59e4-352">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="f59e4-353">如果未满足通过参数指定的条件 `continuationOptions` ，则将取消延续任务，而不是计划。</span><span class="sxs-lookup"><span data-stu-id="f59e4-353">If the criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span> <span data-ttu-id="f59e4-354">有关详细信息，请参阅[使用延续任务链接任务](/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks)。</span><span class="sxs-lookup"><span data-stu-id="f59e4-354">For more information, see [Chaining Tasks by Using Continuation Tasks](/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f59e4-355">已释放了 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-355">The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.</span></span>  
  
<span data-ttu-id="f59e4-356">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f59e4-356">-or-</span></span> 
<span data-ttu-id="f59e4-357">创建了 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" /> 已经被释放。</span><span class="sxs-lookup"><span data-stu-id="f59e4-357">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f59e4-358"><paramref name="continuationAction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-358">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f59e4-359">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f59e4-359">-or-</span></span> 
<span data-ttu-id="f59e4-360"><paramref name="scheduler" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-360">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f59e4-361"><paramref name="continuationOptions" /> 参数为 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 指定无效值。</span><span class="sxs-lookup"><span data-stu-id="f59e4-361">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="f59e4-362">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="f59e4-362">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-based-asynchronous-programming"><span data-ttu-id="f59e4-363">基于任务的异步编程</span><span class="sxs-lookup"><span data-stu-id="f59e4-363">Task-based Asynchronous Programming</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks"><span data-ttu-id="f59e4-364">使用延续任务来链接任务</span><span class="sxs-lookup"><span data-stu-id="f59e4-364">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult), Object), state As Object, cancellationToken As CancellationToken, continuationOptions As TaskContinuationOptions, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt;? continuationAction, object? state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="4" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="f59e4-365">在 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时要运行的操作。</span><span class="sxs-lookup"><span data-stu-id="f59e4-365">An action to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="f59e4-366">运行时，将传递委托，如完成的任务一样，调用方提供的状态对象（如自变量）。</span><span class="sxs-lookup"><span data-stu-id="f59e4-366">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="f59e4-367">一个表示由该延续操作使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="f59e4-367">An object representing data to be used by the continuation action.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f59e4-368">将指派给新的延续任务的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-368">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="f59e4-369">用于设置计划延续任务的时间以及延续任务的工作方式的选项。</span><span class="sxs-lookup"><span data-stu-id="f59e4-369">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="f59e4-370">这包括条件（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />）和执行选项（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />）。</span><span class="sxs-lookup"><span data-stu-id="f59e4-370">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as  well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <param name="scheduler"><span data-ttu-id="f59e4-371">要与延续任务关联并用于其执行过程的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-371">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its  execution.</span></span></param>
        <summary><span data-ttu-id="f59e4-372">创建一个在目标 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-372">Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="f59e4-373">一个新的延续 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-373">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-374"><xref:System.Threading.Tasks.Task>直到当前任务完成后，才会安排返回的执行。</span><span class="sxs-lookup"><span data-stu-id="f59e4-374">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has  completed.</span></span> <span data-ttu-id="f59e4-375">如果未满足通过参数指定的条件 `continuationOptions` ，则将取消延续任务，而不是计划。</span><span class="sxs-lookup"><span data-stu-id="f59e4-375">If the criteria specified through the `continuationOptions` parameter  are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f59e4-376"><paramref name="scheduler" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-376">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f59e4-377"><paramref name="continuationOptions" /> 参数为 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 指定无效值。</span><span class="sxs-lookup"><span data-stu-id="f59e4-377">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f59e4-378">已释放提供的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-378">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks"><span data-ttu-id="f59e4-379">使用延续任务来链接任务</span><span class="sxs-lookup"><span data-stu-id="f59e4-379">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, !!TNewResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), TNewResult)) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, TNewResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, 'NewResult&gt; -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith continuationFunction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult"><span data-ttu-id="f59e4-380">延续任务生成的结果的类型。</span><span class="sxs-lookup"><span data-stu-id="f59e4-380">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="f59e4-381">在 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时要运行的函数。</span><span class="sxs-lookup"><span data-stu-id="f59e4-381">A function to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="f59e4-382">在运行时，委托将作为一个自变量传递给完成的任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-382">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <summary><span data-ttu-id="f59e4-383">创建一个在目标 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时异步执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-383">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="f59e4-384">一个新的延续 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-384">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-385">返回的 <xref:System.Threading.Tasks.Task%601> 将不会计划执行，直到当前任务已完成，该任务是否已完成，因为该任务已成功完成、是否由于未经处理的异常而发生故障，或由于被取消而发生错误。</span><span class="sxs-lookup"><span data-stu-id="f59e4-385">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f59e4-386">已释放了 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-386">The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f59e4-387"><paramref name="continuationFunction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-387">The <paramref name="continuationFunction" /> argument is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="f59e4-388">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="f59e4-388">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-based-asynchronous-programming"><span data-ttu-id="f59e4-389">基于任务的异步编程</span><span class="sxs-lookup"><span data-stu-id="f59e4-389">Task-based Asynchronous Programming</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks"><span data-ttu-id="f59e4-390">使用延续任务来链接任务</span><span class="sxs-lookup"><span data-stu-id="f59e4-390">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt; continuationFunction, object state);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object, !!TNewResult&gt; continuationFunction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), Object, TNewResult), state As Object) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^, TNewResult&gt; ^ continuationFunction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj, 'NewResult&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, state)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt;? ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt;? continuationFunction, object state);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object,TNewResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult"><span data-ttu-id="f59e4-391">延续任务生成的结果的类型。</span><span class="sxs-lookup"><span data-stu-id="f59e4-391">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="f59e4-392">在 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时要运行的函数。</span><span class="sxs-lookup"><span data-stu-id="f59e4-392">A function to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="f59e4-393">运行时，将传递委托，如完成的任务一样，调用方提供的状态对象（如参数）。</span><span class="sxs-lookup"><span data-stu-id="f59e4-393">When run, the delegate will be passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="f59e4-394">一个表示由该延续功能使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="f59e4-394">An object representing data to be used by the continuation function.</span></span></param>
        <summary><span data-ttu-id="f59e4-395">创建一个在目标 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-395">Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="f59e4-396">一个新的延续 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-396">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-397">返回的 <xref:System.Threading.Tasks.Task%601> 将不会计划执行，直到当前任务已完成，该任务是否已完成，因为该任务已成功完成、是否由于未经处理的异常而发生故障，或由于被取消而发生错误。</span><span class="sxs-lookup"><span data-stu-id="f59e4-397">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current  task has completed, whether it completes due to running to completion successfully, faulting due  to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f59e4-398">下面的示例创建一个延续任务链。</span><span class="sxs-lookup"><span data-stu-id="f59e4-398">The following example creates a chain of continuation tasks.</span></span> <span data-ttu-id="f59e4-399">每个任务都为方法的状态参数提供当前时间，即 <xref:System.DateTime> 对象 <xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%2CSystem.Object%7D%2CSystem.Object%29> 。</span><span class="sxs-lookup"><span data-stu-id="f59e4-399">Each task provides the current time, a <xref:System.DateTime> object, for the state argument of the <xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%2CSystem.Object%7D%2CSystem.Object%29> method.</span></span> <span data-ttu-id="f59e4-400">每个 <xref:System.DateTime> 值都表示创建继续任务的时间。</span><span class="sxs-lookup"><span data-stu-id="f59e4-400">Each <xref:System.DateTime> value represents the time at which the continue task is created.</span></span> <span data-ttu-id="f59e4-401">每个任务都将生成一个 <xref:System.DateTime> 表示任务完成时间的第二个值。</span><span class="sxs-lookup"><span data-stu-id="f59e4-401">Each task produces as its result a second <xref:System.DateTime> value that represents the time at which the task finishes.</span></span> <span data-ttu-id="f59e4-402">所有任务完成后，该示例将显示每个延续任务的开始和结束日期和时间。</span><span class="sxs-lookup"><span data-stu-id="f59e4-402">After all tasks finish, the example displays the date and times at which each continuation task starts and finishes.</span></span>  
  
 [!code-csharp[TPL_ContinuationState#1](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_continuationstate/cs/continuationstate.cs#1)]
 [!code-vb[TPL_ContinuationState#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuationstate/vb/continuationstate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f59e4-403"><paramref name="continuationFunction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-403">The <paramref name="continuationFunction" /> argument is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks"><span data-ttu-id="f59e4-404">使用延续任务来链接任务</span><span class="sxs-lookup"><span data-stu-id="f59e4-404">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, !!TNewResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), TNewResult), cancellationToken As CancellationToken) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, TNewResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, 'NewResult&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult"><span data-ttu-id="f59e4-405">延续任务生成的结果的类型。</span><span class="sxs-lookup"><span data-stu-id="f59e4-405">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="f59e4-406">在 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时要运行的函数。</span><span class="sxs-lookup"><span data-stu-id="f59e4-406">A function to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="f59e4-407">在运行时，委托将作为一个自变量传递给完成的任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-407">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f59e4-408">将指派给新任务的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-408">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new task.</span></span></param>
        <summary><span data-ttu-id="f59e4-409">创建一个在目标 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时异步执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-409">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="f59e4-410">一个新的延续 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-410">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-411">返回的 <xref:System.Threading.Tasks.Task%601> 将不会计划执行，直到当前任务已完成，该任务是否已完成，因为该任务已成功完成、是否由于未经处理的异常而发生故障，或由于被取消而发生错误。</span><span class="sxs-lookup"><span data-stu-id="f59e4-411">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f59e4-412">已释放了 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-412">The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.</span></span>  
  
<span data-ttu-id="f59e4-413">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f59e4-413">-or-</span></span> 
<span data-ttu-id="f59e4-414">创建了 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" /> 已经被释放。</span><span class="sxs-lookup"><span data-stu-id="f59e4-414">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f59e4-415"><paramref name="continuationFunction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-415">The <paramref name="continuationFunction" /> argument is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="f59e4-416">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="f59e4-416">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-based-asynchronous-programming"><span data-ttu-id="f59e4-417">基于任务的异步编程</span><span class="sxs-lookup"><span data-stu-id="f59e4-417">Task-based Asynchronous Programming</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks"><span data-ttu-id="f59e4-418">使用延续任务来链接任务</span><span class="sxs-lookup"><span data-stu-id="f59e4-418">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, !!TNewResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), TNewResult), continuationOptions As TaskContinuationOptions) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, TNewResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, 'NewResult&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult"><span data-ttu-id="f59e4-419">延续任务生成的结果的类型。</span><span class="sxs-lookup"><span data-stu-id="f59e4-419">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="f59e4-420">根据 <paramref name="continuationOptions" /> 中指定的条件运行函数。</span><span class="sxs-lookup"><span data-stu-id="f59e4-420">A function to run according the condition specified in <paramref name="continuationOptions" />.</span></span>  
  
<span data-ttu-id="f59e4-421">在运行时，委托将作为一个自变量传递给完成的任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-421">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="f59e4-422">用于设置计划延续任务的时间以及延续任务的工作方式的选项。</span><span class="sxs-lookup"><span data-stu-id="f59e4-422">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="f59e4-423">这包括条件（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />）和执行选项（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />）。</span><span class="sxs-lookup"><span data-stu-id="f59e4-423">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <summary><span data-ttu-id="f59e4-424">创建根据 <paramref name="continuationOptions" /> 中指定的条件加以执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-424">Creates a continuation that executes according the condition specified in <paramref name="continuationOptions" />.</span></span></summary>
        <returns><span data-ttu-id="f59e4-425">一个新的延续 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-425">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-426">返回的 <xref:System.Threading.Tasks.Task%601> 将不会计划执行，直到当前任务已完成，该任务是否已完成，因为该任务已成功完成、是否由于未经处理的异常而发生故障，或由于被取消而发生错误。</span><span class="sxs-lookup"><span data-stu-id="f59e4-426">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 <span data-ttu-id="f59e4-427">在 `continuationFunction` 执行时，应返回 <xref:System.Threading.Tasks.Task%601> 。</span><span class="sxs-lookup"><span data-stu-id="f59e4-427">The `continuationFunction`, when executed, should return a <xref:System.Threading.Tasks.Task%601>.</span></span> 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f59e4-428">已释放了 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-428">The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f59e4-429"><paramref name="continuationFunction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-429">The <paramref name="continuationFunction" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f59e4-430"><paramref name="continuationOptions" /> 参数为 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 指定无效值。</span><span class="sxs-lookup"><span data-stu-id="f59e4-430">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="f59e4-431">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="f59e4-431">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-based-asynchronous-programming"><span data-ttu-id="f59e4-432">基于任务的异步编程</span><span class="sxs-lookup"><span data-stu-id="f59e4-432">Task-based Asynchronous Programming</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks"><span data-ttu-id="f59e4-433">使用延续任务来链接任务</span><span class="sxs-lookup"><span data-stu-id="f59e4-433">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt; continuationFunction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, !!TNewResult&gt; continuationFunction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), TNewResult), scheduler As TaskScheduler) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, TNewResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, 'NewResult&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult"><span data-ttu-id="f59e4-434">延续任务生成的结果的类型。</span><span class="sxs-lookup"><span data-stu-id="f59e4-434">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="f59e4-435">在 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时要运行的函数。</span><span class="sxs-lookup"><span data-stu-id="f59e4-435">A function to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="f59e4-436">在运行时，委托将作为一个自变量传递给完成的任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-436">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="scheduler"><span data-ttu-id="f59e4-437">要与延续任务关联并用于其执行过程的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-437">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="f59e4-438">创建一个在目标 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时异步执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-438">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="f59e4-439">一个新的延续 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-439">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-440">返回的 <xref:System.Threading.Tasks.Task%601> 将不会计划执行，直到当前任务已完成，该任务是否已完成，因为该任务已成功完成、是否由于未经处理的异常而发生故障，或由于被取消而发生错误。</span><span class="sxs-lookup"><span data-stu-id="f59e4-440">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f59e4-441">已释放了 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-441">The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f59e4-442"><paramref name="continuationFunction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-442">The <paramref name="continuationFunction" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f59e4-443">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f59e4-443">-or-</span></span> 
<span data-ttu-id="f59e4-444"><paramref name="scheduler" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-444">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="f59e4-445">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="f59e4-445">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-based-asynchronous-programming"><span data-ttu-id="f59e4-446">基于任务的异步编程</span><span class="sxs-lookup"><span data-stu-id="f59e4-446">Task-based Asynchronous Programming</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks"><span data-ttu-id="f59e4-447">使用延续任务来链接任务</span><span class="sxs-lookup"><span data-stu-id="f59e4-447">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object, !!TNewResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), Object, TNewResult), state As Object, cancellationToken As CancellationToken) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^, TNewResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj, 'NewResult&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt;? ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt;? continuationFunction, object state, System.Threading.CancellationToken cancellationToken);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object,TNewResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult"><span data-ttu-id="f59e4-448">延续任务生成的结果的类型。</span><span class="sxs-lookup"><span data-stu-id="f59e4-448">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="f59e4-449">在 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时要运行的函数。</span><span class="sxs-lookup"><span data-stu-id="f59e4-449">A function to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="f59e4-450">运行时，将传递委托，如完成的任务一样，调用方提供的状态对象（如参数）。</span><span class="sxs-lookup"><span data-stu-id="f59e4-450">When run, the delegate will be passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="f59e4-451">一个表示由该延续功能使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="f59e4-451">An object representing data to be used by the continuation function.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f59e4-452">将指派给新任务的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-452">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new task.</span></span></param>
        <summary><span data-ttu-id="f59e4-453">创建一个在目标 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-453">Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="f59e4-454">一个新的延续 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-454">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-455">返回的 <xref:System.Threading.Tasks.Task%601> 将不会计划执行，直到当前任务已完成，该任务是否已完成，因为该任务已成功完成、是否由于未经处理的异常而发生故障，或由于被取消而发生错误。</span><span class="sxs-lookup"><span data-stu-id="f59e4-455">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current  task has completed, whether it completes due to running to completion successfully, faulting due  to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f59e4-456"><paramref name="continuationFunction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-456">The <paramref name="continuationFunction" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f59e4-457">已释放提供的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-457">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks"><span data-ttu-id="f59e4-458">使用延续任务来链接任务</span><span class="sxs-lookup"><span data-stu-id="f59e4-458">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object, !!TNewResult&gt; continuationFunction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), Object, TNewResult), state As Object, continuationOptions As TaskContinuationOptions) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^, TNewResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj, 'NewResult&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, state, continuationOptions)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt;? ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt;? continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object,TNewResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult"><span data-ttu-id="f59e4-459">延续任务生成的结果的类型。</span><span class="sxs-lookup"><span data-stu-id="f59e4-459">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="f59e4-460">在 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时要运行的函数。</span><span class="sxs-lookup"><span data-stu-id="f59e4-460">A function to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="f59e4-461">运行时，委托将作为一个自变量传递给完成的任务和调用方提供的状态对象。</span><span class="sxs-lookup"><span data-stu-id="f59e4-461">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="f59e4-462">一个表示由该延续功能使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="f59e4-462">An object representing data to be used by the continuation function.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="f59e4-463">用于设置计划延续任务的时间以及延续任务的工作方式的选项。</span><span class="sxs-lookup"><span data-stu-id="f59e4-463">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="f59e4-464">这包括条件（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />）和执行选项（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />）。</span><span class="sxs-lookup"><span data-stu-id="f59e4-464">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <summary><span data-ttu-id="f59e4-465">创建一个在目标 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-465">Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="f59e4-466">一个新的延续 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-466">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-467">返回的 <xref:System.Threading.Tasks.Task%601> 将不会计划执行，直到当前任务已完成，该任务是否已完成，因为该任务已成功完成、是否由于未经处理的异常而发生故障，或由于被取消而发生错误。</span><span class="sxs-lookup"><span data-stu-id="f59e4-467">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current  task has completed, whether it completes due to running to completion successfully, faulting due  to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 <span data-ttu-id="f59e4-468">在 `continuationFunction` 执行时，应返回 <xref:System.Threading.Tasks.Task%601> 。</span><span class="sxs-lookup"><span data-stu-id="f59e4-468">The `continuationFunction`, when executed, should return a <xref:System.Threading.Tasks.Task%601>.</span></span> <span data-ttu-id="f59e4-469">此任务的完成状态将传输到从 System.threading.tasks.task.continuewith 调用返回的任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-469">This task's completion state will be transferred to the task returned from the ContinueWith call.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f59e4-470"><paramref name="continuationFunction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-470">The <paramref name="continuationFunction" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f59e4-471"><paramref name="continuationOptions" /> 参数为 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 指定无效值。</span><span class="sxs-lookup"><span data-stu-id="f59e4-471">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks"><span data-ttu-id="f59e4-472">使用延续任务来链接任务</span><span class="sxs-lookup"><span data-stu-id="f59e4-472">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object, !!TNewResult&gt; continuationFunction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), Object, TNewResult), state As Object, scheduler As TaskScheduler) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^, TNewResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj, 'NewResult&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, state, scheduler)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt;? continuationFunction, object? state, System.Threading.Tasks.TaskScheduler scheduler);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object,TNewResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult"><span data-ttu-id="f59e4-473">延续任务生成的结果的类型。</span><span class="sxs-lookup"><span data-stu-id="f59e4-473">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="f59e4-474">在 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时要运行的函数。</span><span class="sxs-lookup"><span data-stu-id="f59e4-474">A function to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="f59e4-475">运行时，将传递委托，如完成的任务一样，调用方提供的状态对象（如参数）。</span><span class="sxs-lookup"><span data-stu-id="f59e4-475">When run, the delegate will be passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="f59e4-476">一个表示由该延续功能使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="f59e4-476">An object representing data to be used by the continuation function.</span></span></param>
        <param name="scheduler"><span data-ttu-id="f59e4-477">要与延续任务关联并用于其执行过程的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-477">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="f59e4-478">创建一个在目标 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-478">Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="f59e4-479">一个新的延续 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-479">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-480">返回的 <xref:System.Threading.Tasks.Task%601> 将不会计划执行，直到当前任务已完成，该任务是否已完成，因为该任务已成功完成、是否由于未经处理的异常而发生故障，或由于被取消而发生错误。</span><span class="sxs-lookup"><span data-stu-id="f59e4-480">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f59e4-481"><paramref name="scheduler" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-481">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks"><span data-ttu-id="f59e4-482">使用延续任务来链接任务</span><span class="sxs-lookup"><span data-stu-id="f59e4-482">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, !!TNewResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), TNewResult), cancellationToken As CancellationToken, continuationOptions As TaskContinuationOptions, scheduler As TaskScheduler) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, TNewResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, 'NewResult&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult"><span data-ttu-id="f59e4-483">延续任务生成的结果的类型。</span><span class="sxs-lookup"><span data-stu-id="f59e4-483">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="f59e4-484">根据 <paramref name="continuationOptions" /> 中指定的条件运行函数。</span><span class="sxs-lookup"><span data-stu-id="f59e4-484">A function to run according the condition specified in <paramref name="continuationOptions" />.</span></span>  
  
<span data-ttu-id="f59e4-485">在运行时，委托将作为一个参数传递给此完成的任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-485">When run, the delegate will be passed as an argument this completed task.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f59e4-486">将指派给新任务的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-486">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new task.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="f59e4-487">用于设置计划延续任务的时间以及延续任务的工作方式的选项。</span><span class="sxs-lookup"><span data-stu-id="f59e4-487">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="f59e4-488">这包括条件（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />）和执行选项（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />）。</span><span class="sxs-lookup"><span data-stu-id="f59e4-488">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <param name="scheduler"><span data-ttu-id="f59e4-489">要与延续任务关联并用于其执行过程的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-489">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="f59e4-490">创建根据 <paramref name="continuationOptions" /> 中指定的条件加以执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-490">Creates a continuation that executes according the condition specified in <paramref name="continuationOptions" />.</span></span></summary>
        <returns><span data-ttu-id="f59e4-491">一个新的延续 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-491">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-492">返回的 <xref:System.Threading.Tasks.Task%601> 将不会计划执行，直到当前任务已完成，该任务是否已完成，因为该任务已成功完成、是否由于未经处理的异常而发生故障，或由于被取消而发生错误。</span><span class="sxs-lookup"><span data-stu-id="f59e4-492">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 <span data-ttu-id="f59e4-493">在 `continuationFunction` 执行时，应返回 <xref:System.Threading.Tasks.Task%601> 。</span><span class="sxs-lookup"><span data-stu-id="f59e4-493">The `continuationFunction`, when executed, should return a <xref:System.Threading.Tasks.Task%601>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f59e4-494">已释放了 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-494">The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.</span></span>  
  
<span data-ttu-id="f59e4-495">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f59e4-495">-or-</span></span> 
<span data-ttu-id="f59e4-496">创建了 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" /> 已经被释放。</span><span class="sxs-lookup"><span data-stu-id="f59e4-496">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f59e4-497"><paramref name="continuationFunction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-497">The <paramref name="continuationFunction" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f59e4-498">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f59e4-498">-or-</span></span> 
<span data-ttu-id="f59e4-499"><paramref name="scheduler" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-499">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f59e4-500"><paramref name="continuationOptions" /> 参数为 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 指定无效值。</span><span class="sxs-lookup"><span data-stu-id="f59e4-500">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="f59e4-501">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="f59e4-501">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-based-asynchronous-programming"><span data-ttu-id="f59e4-502">基于任务的异步编程</span><span class="sxs-lookup"><span data-stu-id="f59e4-502">Task-based Asynchronous Programming</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks"><span data-ttu-id="f59e4-503">使用延续任务来链接任务</span><span class="sxs-lookup"><span data-stu-id="f59e4-503">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object, !!TNewResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), Object, TNewResult), state As Object, cancellationToken As CancellationToken, continuationOptions As TaskContinuationOptions, scheduler As TaskScheduler) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^, TNewResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj, 'NewResult&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt;? continuationFunction, object? state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object,TNewResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="4" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult"><span data-ttu-id="f59e4-504">延续任务生成的结果的类型。</span><span class="sxs-lookup"><span data-stu-id="f59e4-504">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="f59e4-505">在 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时要运行的函数。</span><span class="sxs-lookup"><span data-stu-id="f59e4-505">A function to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="f59e4-506">运行时，委托将作为一个自变量传递给完成的任务和调用方提供的状态对象。</span><span class="sxs-lookup"><span data-stu-id="f59e4-506">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="f59e4-507">一个表示由该延续功能使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="f59e4-507">An object representing data to be used by the continuation function.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f59e4-508">将指派给新任务的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-508">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new task.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="f59e4-509">用于设置计划延续任务的时间以及延续任务的工作方式的选项。</span><span class="sxs-lookup"><span data-stu-id="f59e4-509">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="f59e4-510">这包括条件（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />）和执行选项（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />）。</span><span class="sxs-lookup"><span data-stu-id="f59e4-510">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <param name="scheduler"><span data-ttu-id="f59e4-511">要与延续任务关联并用于其执行过程的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-511">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="f59e4-512">创建一个在目标 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-512">Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="f59e4-513">一个新的延续 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-513">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-514">返回的 <xref:System.Threading.Tasks.Task%601> 将不会计划执行，直到当前任务已完成，该任务是否已完成，因为该任务已成功完成、是否由于未经处理的异常而发生故障，或由于被取消而发生错误。</span><span class="sxs-lookup"><span data-stu-id="f59e4-514">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 <span data-ttu-id="f59e4-515">在 `continuationFunction` 执行时，应返回 <xref:System.Threading.Tasks.Task%601> 。</span><span class="sxs-lookup"><span data-stu-id="f59e4-515">The `continuationFunction`, when executed, should return a <xref:System.Threading.Tasks.Task%601>.</span></span> <span data-ttu-id="f59e4-516">此任务的完成状态将传输到从调用返回的任务 <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f59e4-516">This task's completion state will be transferred to the task returned from the <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> call.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f59e4-517"><paramref name="scheduler" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-517">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f59e4-518"><paramref name="continuationOptions" /> 参数为 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 指定无效值。</span><span class="sxs-lookup"><span data-stu-id="f59e4-518">The  <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f59e4-519">已释放提供的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="f59e4-519">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks"><span data-ttu-id="f59e4-520">使用延续任务来链接任务</span><span class="sxs-lookup"><span data-stu-id="f59e4-520">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Factory">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskFactory&lt;TResult&gt; Factory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskFactory`1&lt;!TResult&gt; Factory" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task`1.Factory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Factory As TaskFactory(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskFactory&lt;TResult&gt; ^ Factory { System::Threading::Tasks::TaskFactory&lt;TResult&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Factory : System.Threading.Tasks.TaskFactory&lt;'Result&gt;" Usage="System.Threading.Tasks.Task&lt;'Result&gt;.Factory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskFactory&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f59e4-521">提供对用于创建和配置 <see cref="T:System.Threading.Tasks.Task`1" /> 实例的工厂方法的访问。</span><span class="sxs-lookup"><span data-stu-id="f59e4-521">Provides access to factory methods for creating and configuring <see cref="T:System.Threading.Tasks.Task`1" /> instances.</span></span></summary>
        <value><span data-ttu-id="f59e4-522">一个工厂对象，可创建多种 <see cref="T:System.Threading.Tasks.Task`1" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="f59e4-522">A factory object that can create a variety of <see cref="T:System.Threading.Tasks.Task`1" /> objects.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-523">此属性返回类的默认实例，该实例与 <xref:System.Threading.Tasks.TaskFactory%601> 通过调用无参数构造函数创建的实例相同 <xref:System.Threading.Tasks.TaskFactory%601.%23ctor?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f59e4-523">This property returns a default instance of the <xref:System.Threading.Tasks.TaskFactory%601> class that is identical to the one created by calling the parameterless <xref:System.Threading.Tasks.TaskFactory%601.%23ctor?displayProperty=nameWithType> constructor.</span></span> <span data-ttu-id="f59e4-524">它具有以下属性值：</span><span class="sxs-lookup"><span data-stu-id="f59e4-524">It has the following property values:</span></span>  
  
|<span data-ttu-id="f59e4-525">Property</span><span class="sxs-lookup"><span data-stu-id="f59e4-525">Property</span></span>|<span data-ttu-id="f59e4-526">“值”</span><span class="sxs-lookup"><span data-stu-id="f59e4-526">Value</span></span>|  
|--------------|-----------|  
|<xref:System.Threading.Tasks.TaskFactory%601.CancellationToken%2A?displayProperty=nameWithType>|<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory%601.ContinuationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskContinuationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory%601.CreationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskCreationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory%601.Scheduler%2A?displayProperty=nameWithType>|<span data-ttu-id="f59e4-527">`null`、或 <xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="f59e4-527">`null`, or <xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType></span></span>|  
  
 <span data-ttu-id="f59e4-528">此属性的最常见用途是在一次调用方法时创建并启动一个新任务 <xref:System.Threading.Tasks.TaskFactory%601.StartNew%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f59e4-528">The most common use of this property is to create and start a new task in a single call to the <xref:System.Threading.Tasks.TaskFactory%601.StartNew%2A?displayProperty=nameWithType> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f59e4-529">从开始 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] ， <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> 方法提供了 <xref:System.Threading.Tasks.Task%601> 使用默认配置值创建对象的最简单方法。</span><span class="sxs-lookup"><span data-stu-id="f59e4-529">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method provides the easiest way to create a <xref:System.Threading.Tasks.Task%601> object with default configuration values.</span></span>  
  
 <span data-ttu-id="f59e4-530">下面的示例使用静态 <xref:System.Threading.Tasks.Task%601.Factory%2A> 属性对方法进行三次调用 <xref:System.Threading.Tasks.TaskFactory%601.StartNew%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f59e4-530">The following example uses the static <xref:System.Threading.Tasks.Task%601.Factory%2A> property to make three calls to the <xref:System.Threading.Tasks.TaskFactory%601.StartNew%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f59e4-531">第一个启动一个 `Task<Int32>` 对象，该对象执行返回1的 lambda 表达式。</span><span class="sxs-lookup"><span data-stu-id="f59e4-531">The first starts a `Task<Int32>` object, which executes a lambda expression that returns 1.</span></span> <span data-ttu-id="f59e4-532">第二个启动 `Task<Test>` 对象，该对象执行实例化新实例的 lambda 表达式 `Test` 。</span><span class="sxs-lookup"><span data-stu-id="f59e4-532">The second starts a `Task<Test>` object, which executes a lambda expression that instantiates a new `Test` instance.</span></span> <span data-ttu-id="f59e4-533">第三个启动一个 `Task<String[]>` 对象，该对象枚举 C:\Users\Public\Pictures\Sample Pictures \ 目录中的文件。</span><span class="sxs-lookup"><span data-stu-id="f59e4-533">The third starts a `Task<String[]>` object, which enumerates the files in the C:\Users\Public\Pictures\Sample Pictures\ directory.</span></span> <span data-ttu-id="f59e4-534"> (请注意，成功执行该示例需要目录存在，并且该目录包含文件。</span><span class="sxs-lookup"><span data-stu-id="f59e4-534">(Note that successful execution of the example requires that the directory exist and that it contain files.</span></span>  
  
 [!code-csharp[TPL#10](~/samples/snippets/csharp/VS_Snippets_Misc/tpl/cs/returnavalue10.cs#10)]
 [!code-vb[TPL#10](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl/vb/10_returnavalue.vb#10)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="f59e4-535">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="f59e4-535">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-based-asynchronous-programming"><span data-ttu-id="f59e4-536">基于任务的异步编程</span><span class="sxs-lookup"><span data-stu-id="f59e4-536">Task-based Asynchronous Programming</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetAwaiter">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.TaskAwaiter&lt;TResult&gt; GetAwaiter ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.TaskAwaiter`1&lt;!TResult&gt; GetAwaiter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.GetAwaiter" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAwaiter () As TaskAwaiter(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::TaskAwaiter&lt;TResult&gt; GetAwaiter();" />
      <MemberSignature Language="F#" Value="override this.GetAwaiter : unit -&gt; System.Runtime.CompilerServices.TaskAwaiter&lt;'Result&gt;" Usage="task.GetAwaiter " />
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.TaskAwaiter&lt;TResult&gt;? GetAwaiter ();" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.TaskAwaiter&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f59e4-537">获取用于等待此 <see cref="T:System.Threading.Tasks.Task`1" /> 的 awaiter。</span><span class="sxs-lookup"><span data-stu-id="f59e4-537">Gets an awaiter used to await this <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></summary>
        <returns><span data-ttu-id="f59e4-538">一个 awaiter 实例。</span><span class="sxs-lookup"><span data-stu-id="f59e4-538">An awaiter instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-539">此方法适用于编译器用户，而不是直接在代码中使用。</span><span class="sxs-lookup"><span data-stu-id="f59e4-539">This method is intended for compiler user rather than use directly in code.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Result">
      <MemberSignature Language="C#" Value="public TResult Result { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TResult Result" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task`1.Result" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Result As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TResult Result { TResult get(); };" />
      <MemberSignature Language="F#" Value="member this.Result : 'Result" Usage="System.Threading.Tasks.Task&lt;'Result&gt;.Result" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f59e4-540">获取此 <see cref="T:System.Threading.Tasks.Task`1" /> 的结果值。</span><span class="sxs-lookup"><span data-stu-id="f59e4-540">Gets the result value of this <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></summary>
        <value><span data-ttu-id="f59e4-541">此的结果值 <see cref="T:System.Threading.Tasks.Task`1" /> ，其类型与任务的类型参数相同。</span><span class="sxs-lookup"><span data-stu-id="f59e4-541">The result value of this <see cref="T:System.Threading.Tasks.Task`1" />, which is of the same type as the task's type parameter.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f59e4-542">访问属性的 get 访问器会阻止调用线程，直到异步操作完成;它等效于调用 <xref:System.Threading.Tasks.Task.Wait%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f59e4-542">Accessing the property's get accessor blocks the calling thread until the asynchronous operation is complete; it is equivalent to calling the <xref:System.Threading.Tasks.Task.Wait%2A> method.</span></span>  
  
 <span data-ttu-id="f59e4-543">操作结果可用后，它将被存储并在对属性的后续调用后立即返回 <xref:System.Threading.Tasks.Task%601.Result%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f59e4-543">Once the result of an operation is available, it is stored and is returned immediately on subsequent calls to the <xref:System.Threading.Tasks.Task%601.Result%2A> property.</span></span> <span data-ttu-id="f59e4-544">请注意，如果在任务的操作过程中发生异常，或者如果任务已取消，则 <xref:System.Threading.Tasks.Task%601.Result%2A> 属性不会返回值。</span><span class="sxs-lookup"><span data-stu-id="f59e4-544">Note that, if an exception occurred during the operation of the task, or if the task has been cancelled, the <xref:System.Threading.Tasks.Task%601.Result%2A> property does not return a value.</span></span> <span data-ttu-id="f59e4-545">相反，尝试访问属性值会引发 <xref:System.AggregateException> 异常。</span><span class="sxs-lookup"><span data-stu-id="f59e4-545">Instead, attempting to access the property value throws an <xref:System.AggregateException> exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f59e4-546">下面的示例是一个命令行实用工具，该实用工具计算每个目录中的文件中其名称作为命令行参数传递的字节数。</span><span class="sxs-lookup"><span data-stu-id="f59e4-546">The following example is a command-line utility that calculates the number of bytes in the files in each directory whose name is passed as a command-line argument.</span></span> <span data-ttu-id="f59e4-547">如果目录包含文件，它将执行一个 lambda 表达式，该表达式 <xref:System.IO.FileStream> 为目录中的每个文件实例化对象，并检索其属性的值 <xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f59e4-547">If the directory contains files, it executes a lambda expression that instantiates a <xref:System.IO.FileStream> object for each file in the directory and retrieves the value of its <xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="f59e4-548">如果目录不包含任何文件，它只需调用 <xref:System.Threading.Tasks.Task.FromResult%2A> 方法来创建其 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 属性为零的任务 (0) 。</span><span class="sxs-lookup"><span data-stu-id="f59e4-548">If a directory contains no files, it simply calls the <xref:System.Threading.Tasks.Task.FromResult%2A> method to create a task whose <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property is zero (0).</span></span> <span data-ttu-id="f59e4-549">任务完成后，可从属性获取所有目录文件中的总字节数 <xref:System.Threading.Tasks.Task%601.Result%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f59e4-549">When the tasks finish, the total number of bytes in all a directory's files is available from the <xref:System.Threading.Tasks.Task%601.Result%2A> property.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AggregateException"><span data-ttu-id="f59e4-550">已取消任务。</span><span class="sxs-lookup"><span data-stu-id="f59e4-550">The task was canceled.</span></span> <span data-ttu-id="f59e4-551"><see cref="P:System.AggregateException.InnerExceptions" /> 集合包含 <see cref="T:System.Threading.Tasks.TaskCanceledException" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="f59e4-551">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains a <see cref="T:System.Threading.Tasks.TaskCanceledException" /> object.</span></span>  
  
<span data-ttu-id="f59e4-552">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f59e4-552">-or-</span></span> 
<span data-ttu-id="f59e4-553">执行任务期间引发了一个异常。</span><span class="sxs-lookup"><span data-stu-id="f59e4-553">An exception was thrown during the execution of the task.</span></span> <span data-ttu-id="f59e4-554"><see cref="P:System.AggregateException.InnerExceptions" /> 集合包含一个或多个异常的相关信息。</span><span class="sxs-lookup"><span data-stu-id="f59e4-554">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains information about the exception or exceptions.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="f59e4-555">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="f59e4-555">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-based-asynchronous-programming"><span data-ttu-id="f59e4-556">基于任务的异步编程</span><span class="sxs-lookup"><span data-stu-id="f59e4-556">Task-based Asynchronous Programming</span></span></related>
        <related type="Article" href="/dotnet/standard/parallel-programming/how-to-return-a-value-from-a-task"><span data-ttu-id="f59e4-557">如何：从任务中返回值</span><span class="sxs-lookup"><span data-stu-id="f59e4-557">How to: Return a Value from a Task</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
