<Type Name="Parallel" FullName="System.Threading.Tasks.Parallel">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0256aa033058d650742dbc338401fc02014d41ad" /><Meta Name="ms.sourcegitcommit" Value="a8ca33e500a87229bed50d12e09b1347df519648" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="10/09/2020" /><Meta Name="ms.locfileid" Value="91910583" /></Metadata><TypeSignature Language="C#" Value="public static class Parallel" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Parallel extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Parallel" />
  <TypeSignature Language="VB.NET" Value="Public Class Parallel" />
  <TypeSignature Language="C++ CLI" Value="public ref class Parallel abstract sealed" />
  <TypeSignature Language="F#" Value="type Parallel = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.0.4.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Threading.Tasks.Parallel" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Threading.Tasks.Parallel" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>提供对并行循环和区域的支持。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Parallel>类为常见操作（如 for 循环、每个循环和执行一组语句）提供了基于库的数据并行替换。  
  
   
  
## Examples  
 此示例演示了使用多个语言构造实现并行循环的几种方法。  
  
 [!code-csharp[System.Threading.Tasks.Parallel#07](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelintro.cs#07)]
 [!code-vb[System.Threading.Tasks.Parallel#07](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelintro.vb#07)]  
  
 ]]></format>
    </remarks>
    <threadsafe>的所有公共和受保护的成员 <see cref="T:System.Threading.Tasks.Parallel" /> 都是线程安全的，可从多个线程并发使用。</threadsafe>
    <related type="Article" href="/dotnet/standard/parallel-programming/data-parallelism-task-parallel-library">数据并行（任务并行库）</related>
    <related type="ExternalDocumentation" href="https://aka.ms/dotnet-parallel-samples">用于与 .NET Core 和 .NET Standard 并行编程的示例</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="For">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>执行 <see langword="for" /> 循环，其中可能会并行运行迭代。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">开始索引（含）。</param>
        <param name="toExclusive">结束索引（不含）。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行 <see langword="for" /> 循环，其中可能会并行运行迭代，而且可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`对于迭代范围 (的每个值调用一次委托 `fromInclusive` ， `toExclusive`) 。 提供两个参数：  
  
-   一个 <xref:System.Int32> 值，该值表示迭代次数。  
  
-   <xref:System.Threading.Tasks.ParallelLoopState>可用于提前中断循环的实例。 <xref:System.Threading.Tasks.ParallelLoopState>对象是由编译器创建的; 它不能在用户代码中实例化。  
  
 调用 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 方法会通知 `for` 操作，在当前的迭代之后，无需执行迭代。 不过，如果所有迭代尚未执行，则仍必须执行当前的所有迭代。  
  
 因此，调用 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 类似于 `for` c # 等语言中的传统循环内的中断操作，但它并不是完美的替代方法：例如，无法保证当前的迭代不会执行。  
  
 如果在不需要当前迭代之前执行所有迭代，请使用方法，而不是 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> 使用 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 。 调用 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> 会通知 `for` 循环，它可能会放弃所有剩余迭代，而不管它们是在当前迭代之前还是之后，因为所有必需的工作都已完成。 但是，与一样 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> ，不能保证不会执行其他迭代。  
  
 如果某个循环过早结束，则 <xref:System.Threading.Tasks.ParallelLoopResult> 返回的结构将包含有关该循环完成的相关信息。  
  
 如果 `fromInclusive` 大于或等于 `toExclusive` ，则该方法立即返回，而不执行任何迭代。  
  
   
  
## Examples  
 下面的示例并行执行最多100迭代的循环。 每个迭代都将暂停1到1000毫秒的随机间隔。 随机生成的值确定调用方法的循环迭代 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> 。 如示例的输出所示，在调用方法后，索引大于属性值的任何迭代都不会 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> 开始 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> 。  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 由于调用方法时循环的迭代仍可能会执行，因此 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> 每次迭代都会调用 <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A?displayProperty=nameWithType> 属性来检查其他迭代是否已调用 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> 方法。 如果属性值为 `true` ，则迭代会检查属性的值， <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> 如果该值大于当前迭代的索引值，则会立即返回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <altmember cref="T:System.Threading.Tasks.ParallelLoopState" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">开始索引（含）。</param>
        <param name="toExclusive">结束索引（不含）。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行 <see langword="for" /> 循环，其中可能会并行运行迭代。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`对于迭代范围 (的每个值调用一次委托 `fromInclusive` ， `toExclusive`) 。 提供迭代计数 (<xref:System.Int32>) 为参数。  
  
 如果 `fromInclusive` 大于或等于 `toExclusive` ，则该方法立即返回，而不执行任何迭代。  
  
   
  
## Examples  
 下面的示例将 <xref:System.Threading.Tasks.Parallel.For%2A> 方法用于100调用的委托，该委托生成随机字节值并计算其总和。  
  
 [!code-csharp[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/cs/for1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/vb/for1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">开始索引（含）。</param>
        <param name="toExclusive">结束索引（不含）。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行具有 64 位索引的 <see langword="for" /> 循环，其中可能会并行运行迭代，而且可以监视和操作循环的状态。</summary>
        <returns>一个 <see cref="T:System.Threading.Tasks.ParallelLoopResult" /> 结构，其中包含有关已完成的循环部分的信息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`对于迭代范围 (的每个值调用一次委托 `fromInclusive` ， `toExclusive`) 。 提供了以下参数：迭代计数 (<xref:System.Int64>) ，以及 <xref:System.Threading.Tasks.ParallelLoopState> 可能用于提前跳出循环的实例。  
  
 调用 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 方法会通知 `for` 操作：在当前的迭代之后无需执行迭代，而在当前迭代之前的所有迭代都将执行。  
  
 因此，调用 Break 类似于 `for` c # 等语言中的传统循环内的中断操作，但它并不是完美的替代方法：例如，无法保证当前的迭代不会执行。  
  
 如果在不需要当前迭代之前执行所有迭代，请使用方法，而不是 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> 使用 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 。 调用 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> 会通知 `for` 循环，它可能会放弃所有剩余迭代，而不管它们是在当前迭代之前还是之后，因为所有必需的工作都已完成。 但是，与一样 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> ，不能保证不会执行其他迭代。  
  
 如果某个循环过早结束，则 <xref:System.Threading.Tasks.ParallelLoopResult> 返回的结构将包含有关该循环完成的相关信息。  
  
 如果 `fromInclusive` 大于或等于 `toExclusive` ，则方法立即返回，而不执行任何迭代。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">开始索引（含）。</param>
        <param name="toExclusive">结束索引（不含）。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行具有 64 位索引的 <see langword="for" /> 循环，其中可能会并行运行迭代，而且可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`对于迭代范围 (的每个值调用一次委托 `fromInclusive` ， `toExclusive`) 。 提供迭代计数 (<xref:System.Int64>) 为参数。  
  
 如果 `fromInclusive` 大于或等于 `toExclusive` ，则该方法立即返回，而不执行任何迭代。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, parallelOptions As ParallelOptions, body As Action(Of Integer, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">开始索引（含）。</param>
        <param name="toExclusive">结束索引（不含）。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行 <see langword="for" /> 循环，其中可能会并行运行迭代，而且可以配置循环选项，可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`对于迭代范围 (的每个值调用一次委托 `fromInclusive` ， `toExclusive`) 。 提供了以下参数：迭代计数 (<xref:System.Int32>) ，以及 <xref:System.Threading.Tasks.ParallelLoopState> 可能用于提前跳出循环的实例。  
  
 如果 `fromInclusive` 大于或等于 `toExclusive` ，则该方法立即返回，而不执行任何迭代。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" /> 参数。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, parallelOptions As ParallelOptions, body As Action(Of Integer)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">开始索引（含）。</param>
        <param name="toExclusive">结束索引（不含）。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行 <see langword="for" /> 循环，其中可能会并行运行迭代，而且可以配置循环选项。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`对于迭代范围 (的每个值调用一次委托 `fromInclusive` ， `toExclusive`) 。 提供迭代计数 (<xref:System.Int32>) 为参数。  
  
 如果 `fromInclusive` 大于或等于 `toExclusive` ，则方法立即返回，而不执行任何迭代。  
  
   
  
## Examples  
 下面的示例演示如何取消并行循环：  
  
 [!code-csharp[System.Threading.Tasks.Parallel#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforcancel.cs#05)]
 [!code-vb[System.Threading.Tasks.Parallel#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforcancel.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" /> 参数。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, parallelOptions As ParallelOptions, body As Action(Of Long, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">开始索引（含）。</param>
        <param name="toExclusive">结束索引（不含）。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行具有 64 位索引的 <see langword="for" /> 循环，其中可能会并行运行迭代，而且可以配置循环选项，可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`对于迭代范围 (的每个值调用一次委托 `fromInclusive` ， `toExclusive`) 。 提供了以下参数：迭代计数 (<xref:System.Int64>) ，以及 <xref:System.Threading.Tasks.ParallelLoopState> 可能用于提前跳出循环的实例。  
  
 如果 `fromInclusive` 大于或等于 `toExclusive` ，则该方法立即返回，而不执行任何迭代。  
  
   
  
## Examples  
 下面的示例演示如何将方法用于 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> <xref:System.Threading.Tasks.ParallelOptions> 对象：  
  
 [!code-csharp[System.Threading.Tasks.Parallel#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelfor.cs#03)]
 [!code-vb[System.Threading.Tasks.Parallel#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelfor.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" /> 参数。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, parallelOptions As ParallelOptions, body As Action(Of Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">开始索引（含）。</param>
        <param name="toExclusive">结束索引（不含）。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行具有 64 位索引的 <see langword="for" /> 循环，其中可能会并行运行迭代，而且可以配置循环选项。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 支持64位索引。 `body`对于迭代范围 (的每个值调用一次委托 `fromInclusive` ， `toExclusive`) 。 提供迭代计数 (<xref:System.Int64>) 为参数。  
  
 如果 `fromInclusive` 大于或等于 `toExclusive` ，则方法立即返回，而不执行任何迭代。  
  
   
  
## Examples  
 下面的示例演示如何使用 <xref:System.Threading.Tasks.ParallelOptions> 来指定自定义任务计划程序：  
  
 [!code-csharp[System.Threading.Tasks.Parallel#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforwithscheduler.cs#06)]
 [!code-vb[System.Threading.Tasks.Parallel#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforwithscheduler.vb#06)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" /> 参数。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Integer, toExclusive As Integer, localInit As Func(Of TLocal), body As Func(Of Integer, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">线程本地数据的类型。</typeparam>
        <param name="fromInclusive">开始索引（含）。</param>
        <param name="toExclusive">结束索引（不含）。</param>
        <param name="localInit">用于返回每个任务的本地数据的初始状态的函数委托。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <param name="localFinally">用于对每个任务的本地状态执行一个最终操作的委托。</param>
        <summary>执行具有线程本地数据的 <see langword="for" /> 循环，其中可能会并行运行迭代，而且可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`对于迭代范围 (的每个值调用一次委托 `fromInclusive` ， `toExclusive`) 。 提供了以下参数：迭代计数 (<xref:System.Int32>) 、 <xref:System.Threading.Tasks.ParallelLoopState> 可能用于提前跳出循环的实例，以及可能在同一线程上执行的迭代之间共享的某种本地状态。  
  
 `localInit`对于参与循环执行的每个任务，将调用该委托一次，并返回这些任务的初始本地状态。 这些初始状态将传递给每个任务的第一次 `body` 调用。 然后，每个后续的主体调用都将返回一个可能修改的状态值，并将其传递给下一个主体调用。 最后，每个任务的最后一个主体调用返回传递给委托的状态值 `localFinally` 。 每 `localFinally` 个任务调用一次委托，以便对每个任务的本地状态执行最后一个操作。 可对多个任务同时调用此委托;因此，必须同步对任何共享变量的访问。  
  
 此 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> 方法在其执行生存期内使用的任务比线程多，因为现有任务完成并被新任务取代。 这使基础 <xref:System.Threading.Tasks.TaskScheduler> 对象有机会添加、更改或删除为循环提供服务的线程。  
  
 如果 `fromInclusive` 大于或等于 `toExclusive` ，则方法立即返回，而不执行任何迭代。  
  
 有关使用此方法的示例，请参阅 how [to： Write a Parallel For Loop with Thread-Local Variables](/dotnet/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="localInit" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="localFinally" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Long, toExclusive As Long, localInit As Func(Of TLocal), body As Func(Of Long, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">线程本地数据的类型。</typeparam>
        <param name="fromInclusive">开始索引（含）。</param>
        <param name="toExclusive">结束索引（不含）。</param>
        <param name="localInit">用于返回每个任务的本地数据的初始状态的函数委托。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <param name="localFinally">用于对每个任务的本地状态执行一个最终操作的委托。</param>
        <summary>执行具有 64 位索引和线程本地数据的 <see langword="for" /> 循环，其中可能会并行运行迭代，而且可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`对于迭代范围 (的每个值调用一次委托 `fromInclusive` ， `toExclusive`) 。 提供了以下参数：迭代计数 (<xref:System.Int64>) 、 <xref:System.Threading.Tasks.ParallelLoopState> 可能用于提前跳出循环的实例，以及可能在同一任务上执行的迭代之间共享的某种本地状态。  
  
 `localInit`对于参与循环执行的每个任务，将调用该委托一次，并返回这些任务的初始本地状态。 这些初始状态将传递给每个任务的第一次 `body` 调用。 然后，每个后续的主体调用都将返回一个可能修改的状态值，并将其传递给下一个主体调用。 最后，每个任务的最后一个主体调用返回传递给委托的状态值 `localFinally` 。 每 `localFinally` 个任务调用一次委托，以便对每个任务的本地状态执行最后一个操作。 可对多个任务同时调用此委托;因此，必须同步对任何共享变量的访问。  
  
 此 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> 方法在其执行生存期内使用的任务比线程多，因为现有任务完成并被新任务取代。 这使基础 <xref:System.Threading.Tasks.TaskScheduler> 对象有机会添加、更改或删除为循环提供服务的线程。  
  
 如果 `fromInclusive` 大于或等于 `toExclusive` ，则方法立即返回，而不执行任何迭代。  
  
 有关使用此方法的示例，请参阅 how [to： Write a Parallel For Loop with Thread-Local Variables](/dotnet/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="localInit" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="localFinally" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Integer, toExclusive As Integer, parallelOptions As ParallelOptions, localInit As Func(Of TLocal), body As Func(Of Integer, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">线程本地数据的类型。</typeparam>
        <param name="fromInclusive">开始索引（含）。</param>
        <param name="toExclusive">结束索引（不含）。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="localInit">用于返回每个任务的本地数据的初始状态的函数委托。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <param name="localFinally">用于对每个任务的本地状态执行一个最终操作的委托。</param>
        <summary>执行具有线程本地数据的 <see langword="for" /> 循环，其中可能会并行运行迭代，而且可以配置循环选项，可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`对于迭代范围 (的每个值调用一次委托 `fromInclusive` ， `toExclusive`) 。 提供了以下参数：迭代计数 (<xref:System.Int32>) 、 <xref:System.Threading.Tasks.ParallelLoopState> 可能用于提前跳出循环的实例，以及可能在同一任务上执行的迭代之间共享的某种本地状态。  
  
 `localInit`对于参与循环执行的每个任务，将调用该委托一次，并返回这些任务的初始本地状态。 这些初始状态将传递给每个任务的第一次 `body` 调用。 然后，每个后续的主体调用都将返回一个可能修改的状态值，并将其传递给下一个主体调用。 最后，每个任务的最后一个主体调用返回传递给委托的状态值 `localFinally` 。 每 `localFinally` 个任务调用一次委托，以便对每个任务的本地状态执行最后一个操作。 可以在多个线程上同时调用此委托;因此，必须同步对任何共享变量的访问。  
  
 此 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> 方法在其执行生存期内使用的任务比线程多，因为现有任务完成并被新任务取代。 这使基础 <xref:System.Threading.Tasks.TaskScheduler> 对象有机会添加、更改或删除为循环提供服务的线程。  
  
 如果 `fromInclusive` 大于或等于 `toExclusive` ，则方法立即返回，而不执行任何迭代。  
  
   
  
## Examples  
 下面的示例使用线程本地变量来计算许多长运算的结果之和。 此示例将并行度限制为四。  
  
 [!code-csharp[System.Threading.Tasks.Parallel#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/threadlocalforwithoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Parallel#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/threadlocalforwithoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="localInit" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="localFinally" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" /> 参数。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Long, toExclusive As Long, parallelOptions As ParallelOptions, localInit As Func(Of TLocal), body As Func(Of Long, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">线程本地数据的类型。</typeparam>
        <param name="fromInclusive">开始索引（含）。</param>
        <param name="toExclusive">结束索引（不含）。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="localInit">用于返回每个线程的本地数据的初始状态的函数委托。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <param name="localFinally">用于对每个线程的本地状态执行一个最终操作的委托。</param>
        <summary>执行具有 64 位索引和线程本地数据的 <see langword="for" /> 循环，其中可能会并行运行迭代，而且可以配置循环选项，可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`对于迭代范围 (的每个值调用一次委托 `fromInclusive` ， `toExclusive`) 。 提供了以下参数：迭代计数 (<xref:System.Int64>) 、 <xref:System.Threading.Tasks.ParallelLoopState> 可能用于提前跳出循环的实例，以及可能在同一线程上执行的迭代之间共享的某种本地状态。  
  
 将 `localInit` 为参与循环执行的每个线程调用一次委托，并返回每个线程的初始本地状态。 这些初始状态将传递到 `body` 每个线程上的第一次调用。 然后，每个后续的主体调用都将返回一个可能修改的状态值，并将其传递给下一个主体调用。 最后，每个线程上的最后一个主体调用返回传递给委托的状态值 `localFinally` 。 每 `localFinally` 个线程调用一次委托，以便对每个线程的本地状态执行最后一个操作。 可以在多个线程上同时调用此委托;因此，必须同步对任何共享变量的访问。  
  
 此 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> 方法在其执行生存期内使用的任务比线程多，因为现有任务完成并被新任务取代。 这使基础 <xref:System.Threading.Tasks.TaskScheduler> 对象有机会添加、更改或删除为循环提供服务的线程。  
  
 如果 `fromInclusive` 大于或等于 `toExclusive` ，则方法立即返回，而不执行任何迭代。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="localInit" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="localFinally" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" /> 参数。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ForEach&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>执行 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each " />）操作，其中可能会并行运行迭代。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As OrderablePartitioner(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" /> 中的元素的类型。</typeparam>
        <param name="source">包含原始数据源的可排序分区程序。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> 中可能会并行运行迭代，而且可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要重写默认分区方案，则会提供此重载。 例如，小型循环主体可能会受益于对范围进行分区。 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法要求自定义分区程序以支持动态分区。 有关详细信息，请参阅 [用于 PLINQ 和 TPL 的自定义分区程序](/dotnet/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl) 和 [如何：实现动态分区](/dotnet/standard/parallel-programming/how-to-implement-dynamic-partitions)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在 <paramref name="source" /> 可排序的分区程序的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 属性返回 <see langword="false" />。  
  
- 或 - 
在 <see langword="false" /> 可排序的分区程序的 <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> 属性返回 。  
  
- 或 - 
在源可排序的分区程序的所有方法都返回 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">从其中某个指定委托引发的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" /> 中的元素的类型。</typeparam>
        <param name="source">包含原始数据源的分区程序。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.Concurrent.Partitioner" /> 中可能会并行运行迭代，而且可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要重写默认分区方案，则会提供此重载。 例如，小型循环主体可能会受益于对范围进行分区。 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法要求自定义分区程序以支持动态分区。 有关详细信息，请参阅 [用于 PLINQ 和 TPL 的自定义分区程序](/dotnet/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl) 和 [如何：实现动态分区](/dotnet/standard/parallel-programming/how-to-implement-dynamic-partitions)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在 <paramref name="source" /> 的分区程序的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 属性返回 <see langword="false" />。  
  
- 或 - 
<paramref name="source" /> 分区程序中的方法返回 <see langword="null" />。  
  
- 或 - 
<paramref name="source" /> 分区程序中的 <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> 方法未返回正确的分区数时引发的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
        <exception cref="T:System.AggregateException">因包含从指定的委托之一引发的异常而引发的异常。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" /> 中的元素的类型。</typeparam>
        <param name="source">包含原始数据源的分区程序。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.Concurrent.Partitioner" /> 上可能会并行运行迭代。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要重写默认分区方案，则会提供此重载。 例如，小型循环主体可能会受益于对范围进行分区。 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法要求自定义分区程序以支持动态分区。 有关详细信息，请参阅 [用于 PLINQ 和 TPL 的自定义分区程序](/dotnet/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl) 和 [如何：实现动态分区](/dotnet/standard/parallel-programming/how-to-implement-dynamic-partitions)。  
  
   
  
## Examples  
 下面的示例演示如何实现用于的范围分区程序 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> ：  
  
 [!code-csharp[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/cs/rangepartitioner.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/vb/rangepart.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在 <paramref name="source" /> 的分区程序的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 属性返回 <see langword="false" />。  
  
- 或 - 
在 <paramref name="source" /> 分区程序中的任何方法返回 <see langword="null" /> 时引发的异常。  
  
- 或 - 
<paramref name="source" /> 分区程序中的 <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> 方法未返回正确的分区数时引发的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
        <exception cref="T:System.AggregateException">因包含从指定的委托之一引发的异常而引发的异常。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">源中数据的类型。</typeparam>
        <param name="source">可枚举的数据源。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行具有 64 位索引的 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.IEnumerable" /> 上可能会并行运行迭代，而且可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`为可枚举中的每个元素调用一次委托 `source` 。 提供了以下参数：当前元素、 <xref:System.Threading.Tasks.ParallelLoopState> 可能用于提前跳出循环的实例，以及当前元素的索引 (<xref:System.Int64>) 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">源中数据的类型。</typeparam>
        <param name="source">可枚举的数据源。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.IEnumerable" /> 中可能会并行运行迭代，而且可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`为可枚举中的每个元素调用一次委托 `source` 。 它附带了以下参数：当前元素和 <xref:System.Threading.Tasks.ParallelLoopState> 可用于提前中断循环的实例的实例。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">源中数据的类型。</typeparam>
        <param name="source">可枚举的数据源。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.IEnumerable" /> 上可能会并行运行迭代。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`为可枚举中的每个元素调用一次委托 `source` 。 它以当前元素作为参数提供。  
  
   
  
## Examples  
 下面的示例使用 <xref:System.Threading.Tasks.Parallel.ForEach%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Action%7B%60%600%7D%29> 方法对文本文件中元音和非空白字符的数目进行计数。 在这种情况下，将 <xref:System.Threading.Tasks.ParallelLoopResult> 忽略方法返回的值。 请注意，由于操作可以并行运行，因此必须确保递增计数器变量是原子操作，并且多个线程不会尝试同时访问计数器变量。 为此，该示例使用了 `lock` c # 中的语句 () 和 `SyncLock` Visual Basic 中 () 。  
  
 [!code-csharp[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/cs/foreach1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/vb/foreach1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As OrderablePartitioner(Of TSource), parallelOptions As ParallelOptions, body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" /> 中的元素的类型。</typeparam>
        <param name="source">包含原始数据源的可排序分区程序。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> 中可能会并行运行迭代，而且可以配置循环选项，可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要重写默认分区方案，则会提供此重载。 例如，小型循环主体可能会受益于对范围进行分区。 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法要求自定义分区程序以支持动态分区。 有关详细信息，请参阅 [用于 PLINQ 和 TPL 的自定义分区程序](/dotnet/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl) 和 [如何：实现动态分区](/dotnet/standard/parallel-programming/how-to-implement-dynamic-partitions)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" />参数。 </exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <exception cref="T:System.InvalidOperationException">在 <paramref name="source" /> 可排序的分区程序的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 属性返回 <see langword="false" />。  
  
- 或 - 
在 <paramref name="source" /> 可排序的分区程序的 <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> 属性返回 <see langword="false" />。  
  
- 或 - 
当 <paramref name="source" /> 可排序分区程序中的任何方法返回 <see langword="null" /> 时引发的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
        <exception cref="T:System.AggregateException">因包含从指定的委托之一引发的异常而引发的异常。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), parallelOptions As ParallelOptions, body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" /> 中的元素的类型。</typeparam>
        <param name="source">包含原始数据源的分区程序。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.Concurrent.Partitioner" /> 中可能会并行运行迭代，而且可以配置循环选项，可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要重写默认分区方案，则会提供此重载。 例如，小型循环主体可能会受益于对范围进行分区。 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法要求自定义分区程序以支持动态分区。 有关详细信息，请参阅 [用于 PLINQ 和 TPL 的自定义分区程序](/dotnet/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl) 和 [如何：实现动态分区](/dotnet/standard/parallel-programming/how-to-implement-dynamic-partitions)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" /> 参数。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在 <paramref name="source" /> 的分区程序的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 属性返回 <see langword="false" />。  
  
- 或 - 
在 <paramref name="source" /> 分区程序中的任何方法返回 <see langword="null" /> 时引发的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
        <exception cref="T:System.AggregateException">因包含从指定的委托之一引发的异常而引发的异常。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), parallelOptions As ParallelOptions, body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" /> 中的元素的类型。</typeparam>
        <param name="source">包含原始数据源的分区程序。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.Concurrent.Partitioner" /> 中可能会并行运行迭代，而且可以配置循环选项。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要重写默认分区方案，则会提供此重载。 例如，小型循环主体可能会受益于对范围进行分区。 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法要求自定义分区程序以支持动态分区。 有关详细信息，请参阅 [用于 PLINQ 和 TPL 的自定义分区程序](/dotnet/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl) 和 [如何：实现动态分区](/dotnet/standard/parallel-programming/how-to-implement-dynamic-partitions)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" /> 参数。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在 <paramref name="source" /> 的分区程序的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 属性返回 <see langword="false" />。  
  
- 或 - 
在 <paramref name="source" /> 分区程序中的任何方法返回 <see langword="null" /> 时引发的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
        <exception cref="T:System.AggregateException">因包含从指定的委托之一引发的异常而引发的异常。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), parallelOptions As ParallelOptions, body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">源中数据的类型。</typeparam>
        <param name="source">可枚举的数据源。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行具有 64 位索引的 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.IEnumerable" /> 上可能会并行运行迭代，而且可以配置循环选项，可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`为可枚举中的每个元素调用一次委托 `source` 。 提供了以下参数：当前元素、 <xref:System.Threading.Tasks.ParallelLoopState> 可能用于提前跳出循环的实例，以及当前元素的索引 (<xref:System.Int64>) 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" />参数。 </exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), parallelOptions As ParallelOptions, body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">源中数据的类型。</typeparam>
        <param name="source">可枚举的数据源。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.IEnumerable" /> 中可能会并行运行迭代，而且可以配置循环选项，可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`为可枚举中的每个元素调用一次委托 `source` 。 它附带了以下参数：当前元素和 <xref:System.Threading.Tasks.ParallelLoopState> 可用于提前中断循环的实例的实例。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" />参数。 </exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), parallelOptions As ParallelOptions, body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">源中数据的类型。</typeparam>
        <param name="source">可枚举的数据源。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.IEnumerable" /> 中可能会并行运行迭代，而且可以匹配配置循环选项。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`为可枚举中的每个元素调用一次委托 `source` 。 它以当前元素作为参数提供。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" />参数。 </exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As OrderablePartitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" /> 中的元素的类型。</typeparam>
        <typeparam name="TLocal">线程本地数据的类型。</typeparam>
        <param name="source">包含原始数据源的可排序分区程序。</param>
        <param name="localInit">用于返回每个任务的本地数据的初始状态的函数委托。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <param name="localFinally">用于对每个任务的本地状态执行一个最终操作的委托。</param>
        <summary>执行具有线程本地数据的 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> 上可能会并行运行迭代，而且可以配置循环选项，可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要重写默认分区方案，则会提供此重载。 例如，小型循环主体可能会受益于对范围进行分区。 <xref:System.Threading.Tasks.Parallel.ForEach%2A>方法要求自定义分区程序以支持动态分区。 有关详细信息，请参阅 [用于 PLINQ 和 TPL 的自定义分区程序](/dotnet/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl) 和 [如何：实现动态分区](/dotnet/standard/parallel-programming/how-to-implement-dynamic-partitions)。  
  
 `localInit`对于参与循环执行的每个任务，将调用该委托一次，并返回这些任务的初始本地状态。 这些初始状态将传递给每个任务的第一次 `body` 调用。 然后，每个后续的主体调用都将返回一个可能修改的状态值，并将其传递给下一个主体调用。 最后，每个任务的最后一个主体调用返回传递给委托的状态值 `localFinally` 。 每 `localFinally` 个任务调用一次委托，以便对每个任务的本地状态执行最后一个操作。 可对多个任务同时调用此委托;因此，必须同步对任何共享变量的访问。  
  
 此 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 方法在其执行生存期内使用的任务比线程多，因为现有任务完成并被新任务取代。 这使基础 <xref:System.Threading.Tasks.TaskScheduler> 对象有机会添加、更改或删除为循环提供服务的线程。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="body" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="localInit" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="localFinally" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> 中的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 属性返回 <see langword="false" />，或者分区程序返回 <see langword="null" /> 分区。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As Partitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" /> 中的元素的类型。</typeparam>
        <typeparam name="TLocal">线程本地数据的类型。</typeparam>
        <param name="source">包含原始数据源的分区程序。</param>
        <param name="localInit">用于返回每个任务的本地数据的初始状态的函数委托。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <param name="localFinally">用于对每个任务的本地状态执行一个最终操作的委托。</param>
        <summary>执行具有线程本地数据的 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.Concurrent.Partitioner" /> 上可能会并行运行迭代，而且可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要重写默认分区方案，则会提供此重载。 例如，小型循环主体可能会受益于对范围进行分区。 <xref:System.Threading.Tasks.Parallel.ForEach%2A>方法要求自定义分区程序以支持动态分区。 有关详细信息，请参阅 [用于 PLINQ 和 TPL 的自定义分区程序](/dotnet/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl) 和 [如何：实现动态分区](/dotnet/standard/parallel-programming/how-to-implement-dynamic-partitions)。  
  
 将 `localInit` 为参与循环执行的每个线程调用一次委托，并返回每个任务的初始本地状态。 这些初始状态将传递给每个任务的第一次 `body` 调用。 然后，每个后续的主体调用都将返回一个可能修改的状态值，并将其传递给下一个主体调用。 最后，每个任务的最后一个主体调用返回传递给委托的状态值 `localFinally` 。 每 `localFinally` 个任务调用一次委托，以便对每个任务的本地状态执行最后一个操作。 可对多个任务同时调用此委托;因此，必须同步对任何共享变量的访问。  
  
 此 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 方法在其执行生存期内使用的任务比线程多，因为现有任务完成并被新任务取代。 这使基础 <xref:System.Threading.Tasks.TaskScheduler> 对象有机会添加、更改或删除为循环提供服务的线程。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="body" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="localInit" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="localFinally" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> 中的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 属性返回 <see langword="false" />，或者分区程序返回 <see langword="null" /> 分区。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">源中数据的类型。</typeparam>
        <typeparam name="TLocal">线程本地数据的类型。</typeparam>
        <param name="source">可枚举的数据源。</param>
        <param name="localInit">用于返回每个任务的本地数据的初始状态的函数委托。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <param name="localFinally">用于对每个任务的本地状态执行一个最终操作的委托。</param>
        <summary>执行具有线程本地数据的 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.IEnumerable" /> 上可能会并行运行迭代，而且可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`为可枚举中的每个元素调用一次委托 `source` 。 提供了以下参数：当前元素、 <xref:System.Threading.Tasks.ParallelLoopState> 可能用于提前跳出循环的实例、当前元素的索引 (<xref:System.Int64>) ，以及可能在同一线程上执行的迭代之间共享的某些本地状态。  
  
 `localInit`对于参与循环执行的每个任务，将调用该委托一次，并返回这些任务的初始本地状态。 这些初始状态将传递给每个任务的第一次 `body` 调用。 然后，每个后续的主体调用都将返回一个可能修改的状态值，并将其传递给下一个主体调用。 最后，每个任务的最后一个主体调用返回传递给委托的状态值 `localFinally` 。 每 `localFinally` 个任务调用一次委托，以便对每个任务的本地状态执行最后一个操作。 可对多个任务同时调用此委托;因此，必须同步对任何共享变量的访问。  
  
 此 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 方法在其执行生存期内使用的任务比线程多，因为现有任务完成并被新任务取代。 这使基础 <xref:System.Threading.Tasks.TaskScheduler> 对象有机会添加、更改或删除为循环提供服务的线程。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="body" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="localInit" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="localFinally" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">源中数据的类型。</typeparam>
        <typeparam name="TLocal">线程本地数据的类型。</typeparam>
        <param name="source">可枚举的数据源。</param>
        <param name="localInit">用于返回每个任务的本地数据的初始状态的函数委托。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <param name="localFinally">用于对每个任务的本地状态执行一个最终操作的委托。</param>
        <summary>执行具有线程本地数据的 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.IEnumerable" /> 上可能会并行运行迭代，而且可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`为可枚举中的每个元素调用一次委托 `source` 。 提供了以下参数：当前元素、 <xref:System.Threading.Tasks.ParallelLoopState> 可能用于提前跳出循环的实例，以及可能在同一线程上执行的迭代之间共享的某种本地状态。  
  
 `localInit`对于参与循环执行的每个任务，将调用该委托一次，并返回这些任务的初始本地状态。 这些初始状态将传递给每个任务的第一次 `body` 调用。 然后，每个后续的主体调用都将返回一个可能修改的状态值，并将其传递给下一个主体调用。 最后，每个任务的最后一个主体调用返回传递给委托的状态值 `localFinally` 。 `localFinally`每个线程调用一次委托，以便对每个任务的本地状态执行最后一个操作。 可对多个任务同时调用此委托;因此，必须同步对任何共享变量的访问。  
  
 此 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 方法在其执行生存期内使用的任务比线程多，因为现有任务完成并被新任务取代。 这使基础 <xref:System.Threading.Tasks.TaskScheduler> 对象有机会添加、更改或删除为循环提供服务的线程。  
  
   
  
## Examples  
 下面的示例演示如何使用 <xref:System.Threading.Tasks.Parallel.ForEach%2A> 具有本地状态的方法：  
  
 [!code-csharp[System.Threading.Tasks.Parallel#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforeach.cs#02)]
 [!code-vb[System.Threading.Tasks.Parallel#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforeach.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="body" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="localInit" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="localFinally" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As OrderablePartitioner(Of TSource), parallelOptions As ParallelOptions, localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" /> 中的元素的类型。</typeparam>
        <typeparam name="TLocal">线程本地数据的类型。</typeparam>
        <param name="source">包含原始数据源的可排序分区程序。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="localInit">用于返回每个任务的本地数据的初始状态的函数委托。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <param name="localFinally">用于对每个任务的本地状态执行一个最终操作的委托。</param>
        <summary>执行具有 64 位索引和线程本地数据的 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> 上可能会并行运行迭代，而且可以配置循环选项，可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要重写默认分区方案，则会提供此重载。 例如，小型循环主体可能会受益于对范围进行分区。 <xref:System.Threading.Tasks.Parallel.ForEach%2A>方法要求自定义分区程序以支持动态分区。 有关详细信息，请参阅 [用于 PLINQ 和 TPL 的自定义分区程序](/dotnet/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl) 和 [如何：实现动态分区](/dotnet/standard/parallel-programming/how-to-implement-dynamic-partitions)。  
  
 `localInit`对于参与循环执行的每个任务，将调用该委托一次，并返回这些任务的初始本地状态。 这些初始状态将传递给每个任务的第一次 `body` 调用。 然后，每个后续的主体调用都将返回一个可能修改的状态值，并将其传递给下一个主体调用。 最后，每个线程上的最后一个主体调用返回传递给委托的状态值 `localFinally` 。 每 `localFinally` 个任务调用一次委托，以便对每个任务的本地状态执行最后一个操作。 可对多个任务同时调用此委托;因此，必须同步对任何共享变量的访问。  
  
 此 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 方法在其执行生存期内使用的任务比线程多，因为现有任务完成并被新任务取代。 这使基础 <xref:System.Threading.Tasks.TaskScheduler> 对象有机会添加、更改或删除为循环提供服务的线程。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="body" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="localInit" /> 或 <paramref name="localFinally" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> 中的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 属性返回 <see langword="false" />，或者分区程序返回 <see langword="null" /> 分区。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" /> 参数。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As Partitioner(Of TSource), parallelOptions As ParallelOptions, localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" /> 中的元素的类型。</typeparam>
        <typeparam name="TLocal">线程本地数据的类型。</typeparam>
        <param name="source">包含原始数据源的分区程序。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="localInit">用于返回每个任务的本地数据的初始状态的函数委托。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <param name="localFinally">用于对每个任务的本地状态执行一个最终操作的委托。</param>
        <summary>执行具有线程本地数据的 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.Concurrent.Partitioner" /> 上可能会并行运行迭代，而且可以配置循环选项，可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要重写默认分区方案，则会提供此重载。 例如，小型循环主体可能会受益于对范围进行分区。 <xref:System.Threading.Tasks.Parallel.ForEach%2A>方法要求自定义分区程序以支持动态分区。 此重载适用于具有小型循环主体的方案，这可能会受益于静态范围分区。 分区程序必须支持动态分区。  有关详细信息，请参阅 [用于 PLINQ 和 TPL 的自定义分区程序](/dotnet/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl) 和 [如何：实现动态分区](/dotnet/standard/parallel-programming/how-to-implement-dynamic-partitions)。  
  
 `localInit`对于参与循环执行的每个任务，将调用该委托一次，并返回这些任务的初始本地状态。 这些初始状态将传递给每个任务的第一次 `body` 调用。 然后，每个后续的主体调用都将返回一个可能修改的状态值，并将其传递给下一个主体调用。 最后，每个任务的最后一个主体调用返回传递给委托的状态值 `localFinally` 。 每 `localFinally` 个任务调用一次委托，以便对每个任务的本地状态执行最后一个操作。 可对多个任务同时调用此委托;因此，必须同步对任何共享变量的访问。  
  
 此 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 方法在其执行生存期内使用的任务比线程多，因为现有任务完成并被新任务取代。 这使基础 <xref:System.Threading.Tasks.TaskScheduler> 对象有机会添加、更改或删除为循环提供服务的线程。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="body" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="localInit" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="localFinally" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> 中的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 属性返回 <see langword="false" />，或者分区程序返回 <see langword="null" /> 分区。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" /> 参数。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), parallelOptions As ParallelOptions, localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">源中数据的类型。</typeparam>
        <typeparam name="TLocal">线程本地数据的类型。</typeparam>
        <param name="source">可枚举的数据源。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="localInit">用于返回每个任务的本地数据的初始状态的函数委托。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <param name="localFinally">用于对每个任务的本地状态执行一个最终操作的委托。</param>
        <summary>执行具有线程本地数据和 64 位索引的 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.IEnumerable" /> 上可能会并行运行迭代，而且可以配置循环选项，可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`为可枚举中的每个元素调用一次委托 `source` 。 提供了以下参数：当前元素、 <xref:System.Threading.Tasks.ParallelLoopState> 可能用于提前跳出循环的实例、当前元素的索引 (<xref:System.Int64>) ，以及可能在同一线程上执行的迭代之间共享的某些本地状态。  
  
 `localInit`对于参与循环执行的每个任务，将调用该委托一次，并返回这些任务的初始本地状态。 这些初始状态将传递给每个任务的第一次 `body` 调用。 然后，每个后续的主体调用都将返回一个可能修改的状态值，并将其传递给下一个主体调用。 最后，每个任务的最后一个主体调用返回传递给委托的状态值 `localFinally` 。 `localFinally`每个线程调用一次委托，以便对每个任务的本地状态执行最后一个操作。 可对多个任务同时调用此委托;因此，必须同步对任何共享变量的访问。  
  
 此 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 方法在其执行生存期内使用的任务比线程多，因为现有任务完成并被新任务取代。 这使基础 <xref:System.Threading.Tasks.TaskScheduler> 对象有机会添加、更改或删除为循环提供服务的线程。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="body" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="localInit" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="localFinally" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" /> 参数。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), parallelOptions As ParallelOptions, localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">源中数据的类型。</typeparam>
        <typeparam name="TLocal">线程本地数据的类型。</typeparam>
        <param name="source">可枚举的数据源。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="localInit">用于返回每个任务的本地数据的初始状态的函数委托。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <param name="localFinally">用于对每个任务的本地状态执行一个最终操作的委托。</param>
        <summary>执行具有线程本地数据的 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.IEnumerable" /> 上可能会并行运行迭代，而且可以配置循环选项，可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`为可枚举中的每个元素调用一次委托 `source` 。 提供了以下参数：当前元素、 <xref:System.Threading.Tasks.ParallelLoopState> 可能用于提前跳出循环的实例，以及可能在同一线程上执行的迭代之间共享的某种本地状态。  
  
 `localInit`对于参与循环执行的每个任务，将调用该委托一次，并返回这些任务的初始本地状态。 这些初始状态将传递给每个任务的第一次 `body` 调用。 然后，每个后续的主体调用都将返回一个可能修改的状态值，并将其传递给下一个主体调用。 最后，每个任务的最后一个主体调用返回传递给委托的状态值 `localFinally` 。 `localFinally`每个线程调用一次委托，以便对每个任务的本地状态执行最后一个操作。 可对多个任务同时调用此委托;因此，必须同步对任何共享变量的访问。  
  
 此 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 方法在其执行生存期内使用的任务比线程多，因为现有任务完成并被新任务取代。 这使基础 <xref:System.Threading.Tasks.TaskScheduler> 对象有机会添加、更改或删除为循环提供服务的线程。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="body" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="localInit" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="localFinally" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" /> 参数。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>尽可能并行执行提供的每个操作。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Action[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invoke (ParamArray actions As Action())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke actions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="actions">要执行的 <see cref="T:System.Action" /> 数组。</param>
        <summary>尽可能并行执行提供的每个操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可用于执行可能并行执行的一组操作。  
  
 不保证执行操作的顺序，或是否并行执行操作。 此方法在每个提供的操作都已完成后才会返回，无论是由于正常终止还是异常终止而发生。  
  
 有关详细信息，请参阅[如何：使用 Parallel.Invoke 来执行并行操作](/dotnet/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations)。  
  
   
  
## Examples  
 此示例演示如何将 <xref:System.Threading.Tasks.Parallel.Invoke%2A> 方法与其他方法、匿名委托和 lambda 表达式一起使用。  
  
 [!code-csharp[System.Threading.Tasks.Parallel#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelinvoke.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelinvoke.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="actions" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">当 <paramref name="actions" /> 数组中的任何操作引发异常时引发的异常。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="actions" />数组包含 <see langword="null" /> 个元素。</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (System.Threading.Tasks.ParallelOptions parallelOptions, params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Threading.Tasks.ParallelOptions,System.Action[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invoke (parallelOptions As ParallelOptions, ParamArray actions As Action())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(System::Threading::Tasks::ParallelOptions ^ parallelOptions, ... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Threading.Tasks.ParallelOptions * Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke (parallelOptions, actions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="actions">要执行的操作数组。</param>
        <summary>执行所提供的每个操作，而且尽可能并行运行，除非用户取消了操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可用于执行可能并行执行的一组操作。 与结构一起传入的取消标记 <xref:System.Threading.Tasks.ParallelOptions> 允许调用方取消整个操作。 有关详细信息，请参阅[托管线程中的取消](/dotnet/standard/threading/cancellation-in-managed-threads)。  
  
 不保证执行操作的顺序，或是否并行执行操作。 此方法在每个提供的操作都已完成后才会返回，无论是由于正常终止还是异常终止而发生。  
  
 有关详细信息，请参阅[如何：使用 Parallel.Invoke 来执行并行操作](/dotnet/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> 处于 <paramref name="parallelOptions" /> 设置。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="actions" /> 参数为 <see langword="null" />。  
  
- 或 - 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">当 <paramref name="actions" /> 数组中的任何操作引发异常时引发的异常。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="actions" />数组包含 <see langword="null" /> 个元素。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
