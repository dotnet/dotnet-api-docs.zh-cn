<Type Name="Regex" FullName="System.Text.RegularExpressions.Regex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7e70e8da7008ddf17403b0eb0d84b80de64def70" /><Meta Name="ms.sourcegitcommit" Value="943c8cdbe5b47c6c296a6f4b73038bbd43da0dd2" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="02/12/2021" /><Meta Name="ms.locfileid" Value="100314542" /></Metadata><TypeSignature Language="C#" Value="public class Regex" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Regex extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="DocId" Value="T:System.Text.RegularExpressions.Regex" />
  <TypeSignature Language="VB.NET" Value="Public Class Regex" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="C++ CLI" Value="public ref class Regex" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="F#" Value="type Regex = class" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="C#" Value="public class Regex : System.Runtime.Serialization.ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Regex extends System.Object implements class System.Runtime.Serialization.ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="VB.NET" Value="Public Class Regex&#xA;Implements ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class Regex : System::Runtime::Serialization::ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Regex = class&#xA;    interface ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Regex extends System.Object implements class System.Runtime.Serialization.ISerializable" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Text.RegularExpressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System" FromVersion="4.0.0.0" To="System.Text.RegularExpressions" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Text.RegularExpressions" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示不可变的正则表达式。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex>类表示 .NET Framework 的正则表达式引擎。 它可用于快速分析大量文本以找到特定的字符模式;提取、编辑、替换或删除文本子字符串;和将提取的字符串添加到集合以生成报告。  
  
> [!NOTE]
>  如果你的主要兴趣是通过确定是否符合特定模式来验证字符串，则可以使用 <xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType> 类。  
  
 若要使用正则表达式，可以使用 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)中记录的语法来定义要在文本流中标识的模式。 接下来，你可以根据需要实例化 <xref:System.Text.RegularExpressions.Regex> 对象。 最后，调用执行某种操作的方法，例如替换与正则表达式模式匹配的文本，或标识模式匹配。  
  
> [!NOTE]
>  有关某些常见正则表达式模式，请参阅 [正则表达式示例](/dotnet/standard/base-types/regular-expression-examples)。 还有多个正则表达式模式的联机库，如 [Regular-Expressions.info](https://www.regular-expressions.info/examples.html)。  
  
<a name="remarks"></a> 有关使用类的详细信息 <xref:System.Text.RegularExpressions.Regex> ，请参阅本主题中的以下部分：  
  
-   [Regex 与 String 方法](#regex_vs_string)  
  
-   [静态方法与实例方法](#static_vs_instance)  
  
-   [执行正则表达式运算](#regex_ops)  
  
-   [定义 Time-Out 值](#define_timeout)  
  
 若要详细了解正则表达式语言，请参阅[正则表达式语言 - 快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)，或下载和打印下面的小册子之一：  
  
 [快速参考（Word (.docx) 格式）](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)  
 [快速参考（PDF (.pdf) 格式）](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)  
  
<a name="regex_vs_string"></a>   
## <a name="regex-vs-string-methods"></a>Regex 与 String 方法  
 <xref:System.String?displayProperty=nameWithType>类包含若干搜索和比较方法，您可以使用这些方法来执行与文本的模式匹配。 例如， <xref:System.String.Contains%2A?displayProperty=nameWithType> 、 <xref:System.String.EndsWith%2A?displayProperty=nameWithType> 和 <xref:System.String.StartsWith%2A?displayProperty=nameWithType> 方法确定字符串实例是否包含指定的子字符串; <xref:System.String.IndexOf%2A?displayProperty=nameWithType> 、、 <xref:System.String.IndexOfAny%2A?displayProperty=nameWithType> <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> 和 <xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType> 方法返回指定子字符串在字符串中的起始位置。 <xref:System.String?displayProperty=nameWithType>搜索特定字符串时，请使用类的方法。 <xref:System.Text.RegularExpressions.Regex>搜索字符串中的特定模式时，请使用类。 有关详细信息和示例，请参阅 [.NET Framework 正则表达式](/dotnet/standard/base-types/regular-expressions)。  
  
 [返回到备注](#remarks)  
  
<a name="static_vs_instance"></a>   
## <a name="static-vs-instance-methods"></a>静态方法与实例方法  
 定义正则表达式模式后，可以通过以下两种方式之一将其提供给正则表达式引擎：  
  
-   通过实例化 <xref:System.Text.RegularExpressions.Regex> 表示正则表达式的对象。 为此，请将正则表达式模式传递到 <xref:System.Text.RegularExpressions.Regex.%23ctor%2A> 构造函数。 <xref:System.Text.RegularExpressions.Regex>对象是不可变的; 当 <xref:System.Text.RegularExpressions.Regex> 使用正则表达式实例化对象时，无法更改该对象的正则表达式。  
  
-   通过同时提供正则表达式和文本来搜索 `static` `Shared` Visual Basic) 方法中的 (<xref:System.Text.RegularExpressions.Regex> 。 这使你可以使用正则表达式，而无需显式创建 <xref:System.Text.RegularExpressions.Regex> 对象。  
  
 所有 <xref:System.Text.RegularExpressions.Regex> 模式标识方法均包括静态和实例重载。  
  
 正则表达式引擎必须先编译特定模式，然后才能使用该模式。 由于 <xref:System.Text.RegularExpressions.Regex> 对象是不可变的，因此这是一个在 <xref:System.Text.RegularExpressions.Regex> 调用类构造函数或静态方法时发生的一次性过程。 为了消除重复编译单个正则表达式的需要，正则表达式引擎会缓存静态方法调用中使用的已编译正则表达式。 因此，正则表达式模式匹配方法为静态和实例方法提供了相当的性能。  
  
> [!IMPORTANT]
>  在 .NET Framework 版本1.0 和1.1 中，已缓存所有已编译的正则表达式，无论它们是在实例中使用还是静态方法调用。 从 .NET Framework 2.0 开始，仅缓存静态方法调用中使用的正则表达式。  
  
 但是，在以下两种情况下，缓存可能会对性能产生负面影响：  
  
-   当使用带有大量正则表达式的静态方法调用时。 默认情况下，正则表达式引擎会缓存15个最近使用的静态正则表达式。 如果应用程序使用15个以上的静态正则表达式，则必须重新编译某些正则表达式。 若要防止这种重新编译，可以增加 <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> 属性。  
  
-   <xref:System.Text.RegularExpressions.Regex>使用之前已编译的正则表达式实例化新的对象时。 例如，下面的代码定义了一个正则表达式来查找文本流中的重复单词。 尽管该示例使用单个正则表达式，但它将实例化一个新的 <xref:System.Text.RegularExpressions.Regex> 对象来处理每行文本。 这会导致在循环的每次迭代时重新编译正则表达式。  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#1)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#1)]  
  
     若要防止重新编译，应实例化单个 <xref:System.Text.RegularExpressions.Regex> 对象，该对象可由需要它的所有代码访问，如下面的重写示例中所示。  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#2)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#2)]  
  
 [返回到备注](#remarks)  
  
<a name="regex_ops"></a>   
## <a name="performing-regular-expression-operations"></a>执行正则表达式运算  
 无论你决定要实例化 <xref:System.Text.RegularExpressions.Regex> 对象并调用其方法或调用静态方法， <xref:System.Text.RegularExpressions.Regex> 类都提供以下模式匹配功能：  
  
-   验证匹配项。 调用 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> 方法以确定是否存在匹配项。  
  
-   检索单个匹配项。 调用 <xref:System.Text.RegularExpressions.Regex.Match%2A> 方法以检索一个 <xref:System.Text.RegularExpressions.Match> 对象，该对象表示字符串中的第一个匹配项或字符串的一部分。 可以通过调用方法来检索后续匹配项 <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> 。  
  
-   检索所有匹配项。 调用 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 方法可检索 <xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType> 对象，该对象表示在字符串或字符串的一部分中找到的所有匹配项。  
  
-   替换匹配文本。 调用 <xref:System.Text.RegularExpressions.Regex.Replace%2A> 方法以替换匹配的文本。 替换文本还可以由正则表达式定义。 此外，某些 <xref:System.Text.RegularExpressions.Regex.Replace%2A> 方法还包括一个 <xref:System.Text.RegularExpressions.MatchEvaluator> 参数，使你能够以编程方式定义替换文本。  
  
-   创建一个字符串数组，该数组由输入字符串的各个部分组成。 调用 <xref:System.Text.RegularExpressions.Regex.Split%2A> 方法以在由正则表达式定义的位置拆分输入字符串。  
  
 除了其模式匹配方法以外， <xref:System.Text.RegularExpressions.Regex> 类还包括几种特殊用途的方法：  
  
-   <xref:System.Text.RegularExpressions.Regex.Escape%2A>方法将可解释为正则表达式或输入字符串中的正则表达式运算符的任何字符转义。  
  
-   <xref:System.Text.RegularExpressions.Regex.Unescape%2A>方法删除这些转义字符。  
  
-   <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A>方法创建包含预定义的正则表达式的程序集。 .NET Framework 包含命名空间中这些特殊用途程序集的示例 <xref:System.Web.RegularExpressions?displayProperty=nameWithType> 。  
  
 [返回到备注](#remarks)  
  
<a name="define_timeout"></a>   
## <a name="defining-a-time-out-value"></a>定义 Time-Out 值  
 .NET Framework 支持功能完备的正则表达式语言，可在模式匹配中提供强大的功能和灵活性。 不过，功能和灵活性的代价是：性能不佳的风险。 很难创建的正则表达式非常简单。 在某些情况下，在处理与正则表达式模式大致匹配的文本时，依赖于过度回溯的正则表达式操作可能会停止响应。 有关 .NET Framework 正则表达式引擎的详细信息，请参阅 [正则表达式行为的详细](/dotnet/standard/base-types/details-of-regular-expression-behavior)信息。 有关过量回溯的详细信息，请参阅 [回溯](/dotnet/standard/base-types/backtracking-in-regular-expressions)。  
  
 从开始 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] ，您可以定义正则表达式匹配的超时间隔。 如果正则表达式引擎无法在此时间间隔内标识匹配项，则匹配操作将引发 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 异常。 在大多数情况下，这样可以防止正则表达式引擎尝试匹配与正则表达式模式近似匹配的文本，从而使处理能力浪费。 但这也可能表示超时间隔设置得太低，或当前计算机负荷导致总体性能下降。  
  
 处理异常的方式取决于异常的原因。 如果发生异常的原因是超时间隔设置得太低或计算机负载过多，则可以增加超时间隔，然后重试匹配操作。 如果发生异常的原因是正则表达式依赖过多回溯，则可以假定不存在匹配项，并且可以选择记录有助于修改正则表达式模式的信息。  
  
 在 <xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)> 实例化正则表达式对象时，可以通过调用构造函数来设置超时间隔。 对于静态方法，你可以通过调用具有参数的匹配方法的重载来设置超时间隔 `matchTimeout` 。 如果未显式设置超时值，则按如下方式确定默认超时值：  
  
-   使用应用程序范围的超时值（如果存在）。 这可以是任何应用于在其中实例化对象的应用程序域 <xref:System.Text.RegularExpressions.Regex> 或进行静态方法调用的超时值。 通过调用 <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> 方法将值的字符串表示形式分配给 <xref:System.TimeSpan> "REGEX_DEFAULT_MATCH_TIMEOUT" 属性，可以设置应用程序范围的超时值。  
  
-   <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>如果未设置应用程序范围的超时值，则使用值。  
  
> [!IMPORTANT]
>  建议在所有正则表达式模式匹配操作中设置超时值。 有关详细信息，请参阅 [正则表达式的最佳实践](/dotnet/standard/base-types/best-practices)。  
  
 [返回到备注](#remarks)  
  
   
  
## Examples  
 下面的示例使用正则表达式检查字符串中重复出现的单词。 正则表达式 `\b(?<word>\w+)\s+(\k<word>)\b` 可以解释为下表中所示。  
  
|模式|说明|  
|-------------|-----------------|  
|`\b`|在单词边界处开始匹配。|  
|`(?<word>\w+)`|匹配一个或多个单词字符，最多一个字边界。 将此捕获的组命名为 `word` 。|  
|`\s+`|匹配一个或多个空白字符。|  
|`(\k<word>)`|匹配名为的捕获组 `word` 。|  
|`\b`|与字边界匹配。|  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/Regex_Words/CPP/words.cpp" id="Snippet0":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Regex_Words/CS/words.cs" interactive="try-dotnet" id="Snippet0":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex_Words/VB/words.vb" id="Snippet0"::: 
  
 下面的示例演示如何使用正则表达式来检查字符串是表示货币值，还是具有表示货币值的正确格式。 在这种情况下，将从 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType> <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A> <xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType> <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> 用户的当前区域性的、、、和属性动态生成正则表达式。 如果系统的当前区域性为 en-us，则生成的正则表达式是 `^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$` 。 此正则表达式可以解释为下表中所示。  
  
|模式|说明|  
|-------------|-----------------|  
|`^`|从字符串的开头开始。|  
|`\s*`|匹配零个或多个空白字符。|  
|`[\+-]?`|匹配正号或负号的零个或一个匹配项。|  
|`\s?`|匹配零个或一个空白字符。|  
|`\$?`|匹配美元符号的零个或一个匹配项。|  
|`\s?`|匹配零个或一个空白字符。|  
|`\d*`|匹配零个或多个十进制数字。|  
|`\.?`|匹配零个或一个小数点符号。|  
|`\d{2}?`|匹配两个十进制数字零次或一次。|  
|`(\d*\.?\d{2}?){1}`|匹配由小数点符号分隔的整数和小数位的模式（至少一次）。|  
|`$`|与字符串的末尾匹配。|  
  
 在这种情况下，正则表达式假定有效的货币字符串不包含组分隔符符号，并且它没有小数位数或当前区域性的属性定义的小数位数 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A> 。  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/cs/regex_example1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/vb/regex_example1.vb" id="Snippet1"::: 
  
 由于此示例中的正则表达式是动态生成的，因此，在设计时不知道当前区域性的货币符号、十进制符号或正负号是否可能被正则表达式引擎错误地解释为正则表达式语言运算符。 为了防止任何误解，此示例将每个动态生成的字符串传递给 <xref:System.Text.RegularExpressions.Regex.Escape%2A> 方法。  
  
 ]]></format>
    </remarks>
    <threadsafe><see cref="T:System.Text.RegularExpressions.Regex" />该类 (只读) 并且是线程安全的不可变的。 <see cref="T:System.Text.RegularExpressions.Regex" /> 可以在任何线程上创建对象并在线程之间共享。 有关详细信息，请参阅 [线程安全](/dotnet/standard/base-types/thread-safety-in-regular-expressions)。</threadsafe>
    <altmember cref="T:System.Configuration.RegexStringValidator" />
    <related type="Article" href="/dotnet/standard/base-types/regular-expressions">.NET Framework 正则表达式</related>
    <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言元素</related>
    <related type="ExternalDocumentation" href="https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx">正则表达式 — 快速参考（以 Word 格式下载）</related>
    <related type="ExternalDocumentation" href="https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf">正则表达式 — 快速参考（以 PDF 格式下载）</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 类的新实例。</summary>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言元素</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请注意，此构造函数是受保护的;它只能由派生自类的类调用 <xref:System.Text.RegularExpressions.Regex> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex pattern" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <summary>为指定的正则表达式初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern`参数包含符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅 [.NET Framework 正则表达式](/dotnet/standard/base-types/regular-expressions) 和 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference) 主题。  
  
 调用 <xref:System.Text.RegularExpressions.Regex.%23ctor(System.String)> 构造函数等效于 <xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions)> 使用参数的值调用构造函数 <xref:System.Text.RegularExpressions.RegexOptions.None> `options` 。  
  
 <xref:System.Text.RegularExpressions.Regex>对象是不可变的，这意味着它只能用于在创建时定义的匹配模式。 但是，无需重新编译即可使用任意次。  
  
 此构造函数实例化一个正则表达式对象，该对象尝试区分大小写匹配在中定义的任何字母字符 `pattern` 。 对于不区分大小写的匹配项，请使用 <xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions)?displayProperty=nameWithType> 构造函数。  
  
   
  
## Examples  
 下面的示例演示如何使用此构造函数实例化一个与任何以字母 "a" 或 "t" 开头的单词匹配的正则表达式。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/constructors1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/constructors1.vb" id="Snippet1":::
  
 请注意，正则表达式模式无法匹配文本开头的单词 "the"，因为默认情况下比较区分大小写。 有关不区分大小写的比较的示例，请参见 <xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions)> 构造函数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>此构造函数将创建一个 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象，该对象使用在其中创建它的应用程序域的默认超时值。 如果尚未为应用程序域定义超时值，则 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象将使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> ，这会阻止操作超时。用于创建对象的推荐构造函数 <see cref="T:System.Text.RegularExpressions.Regex" /> 是 <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /> ，可用于设置超时间隔。</para></block>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="info">包含串行化模式和 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 信息的对象。</param>
        <param name="context">此序列化的目标。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>使用序列化数据初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> 包含的模式为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="info" /> 包含无效的 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 标志。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="options">修改正则表达式的枚举值的按位组合。</param>
        <summary>使用修改模式的选项为指定的正则表达式初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern`参数包含符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅 [.NET Framework 正则表达式](/dotnet/standard/base-types/regular-expressions) 和 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference) 主题。  
  
 <xref:System.Text.RegularExpressions.Regex>对象是不可变的，这意味着它只能用于在创建时定义的匹配参数。 但是，无需重新编译即可使用任意次。  
  
   
  
## Examples  
 下面的示例演示如何使用此构造函数实例化一个与任何以字母 "a" 或 "t" 开头的单词匹配的正则表达式。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/Constructors2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/Constructors2.vb" id="Snippet2":::
  
 请注意，match 集合包含开始文本的 "the" 一词，因为该 `options` 参数定义了不区分大小写的比较。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 包含无效标志。</exception>
        <block subset="none" type="usage"><para>此构造函数将创建一个 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象，该对象使用在其中创建它的应用程序域的默认超时值。 如果尚未为应用程序域定义超时值，则 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象将使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> ，这会阻止操作超时。用于创建对象的推荐构造函数 <see cref="T:System.Text.RegularExpressions.Regex" /> 是 <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /> ，可用于设置超时间隔。</para></block>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions, matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options, matchTimeout)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="options">修改正则表达式的枚举值的按位组合。</param>
        <param name="matchTimeout">超时间隔；若要指示该方法不应超时，则为 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</param>
        <summary>使用修改模式的选项和指定在超时前多久模式匹配方法应进行匹配尝试的值为指定正则表达式初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern`参数包含符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅 [.NET Framework 正则表达式](/dotnet/standard/base-types/regular-expressions) 和 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference) 主题。  
  
 <xref:System.Text.RegularExpressions.Regex>对象是不可变的，这意味着它只能用于在创建时定义的匹配模式。 但是，无需重新编译即可使用任意次。  
  
 `matchTimeout`参数指定模式匹配方法在超时前应尝试找到匹配项的时间长度。如果在该时间间隔内未找到匹配项，则模式匹配方法会引发 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 异常。 `matchTimeout` 重写为在其中创建对象的应用程序域定义的任何默认超时值 <xref:System.Text.RegularExpressions.Regex> 。 观察超时间隔的实例模式匹配方法 `matchTimeout` 包括：  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%2A>  
  
-   <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>  
  
 设置超时间隔可防止正则表达式在处理包含接近匹配项的输入时，这些表达式会出现依赖于过量回溯的正则表达式停止响应。 有关详细信息，请参阅[正则表达式和回溯的最佳实践](/dotnet/standard/base-types/best-practices)。 [](/dotnet/standard/base-types/backtracking-in-regular-expressions) 若要设置合理的超时间隔，请考虑以下因素：  
  
-   正则表达式模式的长度和复杂性。 较长和更复杂的正则表达式所需的时间比较短且更简单。  
  
-   预期的计算机负载。 在 CPU 和内存利用率较高的系统上处理需要更多时间。  
  
   
  
## Examples  
 下面的示例调用 <xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)> 构造函数来实例化 <xref:System.Text.RegularExpressions.Regex> 超时值为1秒的对象。 正则表达式模式 `(a+)+$`（与行尾的一个或多个“a”字符的一个或多个序列匹配）受过度回溯的约束。 如果 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 引发了，则该示例会将超时值增大到最大值三秒。 否则，它会放弃与模式匹配的尝试。  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb" id="Snippet1"::: 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是有效的 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值。  
  
- 或 - 
 <paramref name="matchTimeout" /> 为负、零或大于 24 天左右。</exception>
        <block subset="none" type="usage"><para>建议将 <paramref name="matchTimeout" /> 参数设置为适当的值，例如两秒钟。 如果通过指定禁用超时 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> ，则正则表达式引擎可提供略微更好的性能。 但是，只应在以下条件下禁用超时： 
-正则表达式处理的输入派生自已知的和受信任的源，或由静态文本组成。 这不包括用户动态输入的文本。  
  
-对正则表达式模式进行了全面测试，以确保它有效地处理匹配、不匹配和接近匹配项。  
  
-当正则表达式模式不包含已知的语言元素时，这些元素会导致在处理接近的匹配时导致过度回溯。</para></block>
        <related type="Article" href="/dotnet/standard/base-types/backtracking-in-regular-expressions">正则表达式中的回溯</related>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="CacheSize">
      <MemberSignature Language="C#" Value="public static int CacheSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CacheSize" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CacheSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CacheSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CacheSize : int with get, set" Usage="System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置已编译的正则表达式的当前静态缓存中的最大项数。</summary>
        <value>静态缓存中的最大项数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex>类维护静态方法调用中使用的已编译正则表达式的内部缓存。 如果在 set 操作中指定的值小于当前的缓存大小，则会丢弃缓存项，直到缓存大小等于指定值。  
  
 默认情况下，缓存保存15个已编译的静态正则表达式。 应用程序通常不需要修改缓存大小。 <xref:System.Text.RegularExpressions.Regex.CacheSize%2A>仅当你想要关闭缓存或遇到非常大的缓存时才使用属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">集运算中的值小于零。</exception>
        <block subset="none" type="usage"><para>在 .NET Framework 前面的中 [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)] ，将缓存静态和实例方法调用中使用的正则表达式。 从开始 [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)] ，仅缓存静态方法调用中使用的正则表达式。</para></block>
      </Docs>
    </Member>
    <Member MemberName="capnames">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable? capnames;" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable capnames" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capnames" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capnames As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ capnames;" />
      <MemberSignature Language="F#" Value="val mutable capnames : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.capnames" />
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable capnames;" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法生成的 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CapNames">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary? CapNames { get; set; }" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary CapNames" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CapNames" />
      <MemberSignature Language="VB.NET" Value="Protected Property CapNames As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ CapNames { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CapNames : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.CapNames" />
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary CapNames { get; set; }" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置将命名捕获组映射到其索引值的字典。</summary>
        <value>将命名捕获组映射到其索引值的字典。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请注意，此属性是受保护的;它只能从类派生的类中访问 <xref:System.Text.RegularExpressions.Regex> 。  
  
 设置操作尝试将分配给该属性的值转换为 <xref:System.Collections.Hashtable> 对象; 如果此转换失败，它将调用 <xref:System.Collections.Hashtable.%23ctor(System.Collections.IDictionary)?displayProperty=nameWithType> 构造函数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">向设置操作中的 <see cref="P:System.Text.RegularExpressions.Regex.CapNames" /> 属性分配的值是 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="caps">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable? caps;" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable caps" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.caps" />
      <MemberSignature Language="VB.NET" Value="Protected Friend caps As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ caps;" />
      <MemberSignature Language="F#" Value="val mutable caps : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.caps" />
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable caps;" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法生成的 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Caps">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary? Caps { get; set; }" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Caps" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Caps" />
      <MemberSignature Language="VB.NET" Value="Protected Property Caps As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ Caps { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Caps : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.Caps" />
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary Caps { get; set; }" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置将编号捕获组映射到其索引值的字典。</summary>
        <value>将编号捕获组映射到其索引值的字典。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请注意，此属性是受保护的;它只能从类派生的类中访问 <xref:System.Text.RegularExpressions.Regex> 。  
  
 设置操作尝试将分配给该属性的值转换为 <xref:System.Collections.Hashtable> 对象; 如果此转换失败，它将调用 <xref:System.Collections.Hashtable.%23ctor(System.Collections.IDictionary)?displayProperty=nameWithType> 构造函数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">向设置操作中的 <see cref="P:System.Text.RegularExpressions.Regex.Caps" /> 属性分配的值是 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="capsize">
      <MemberSignature Language="C#" Value="protected internal int capsize;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly int32 capsize" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capsize" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capsize As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected public: int capsize;" />
      <MemberSignature Language="F#" Value="val mutable capsize : int" Usage="System.Text.RegularExpressions.Regex.capsize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法生成的 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="capslist">
      <MemberSignature Language="C#" Value="protected internal string[]? capslist;" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string[] capslist" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capslist" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capslist As String() " />
      <MemberSignature Language="C++ CLI" Value="protected public: cli::array &lt;System::String ^&gt; ^ capslist;" />
      <MemberSignature Language="F#" Value="val mutable capslist : string[]" Usage="System.Text.RegularExpressions.Regex.capslist" />
      <MemberSignature Language="C#" Value="protected internal string[] capslist;" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法生成的 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompileToAssembly">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>编译正则表达式，并将其保存到单个程序集的磁盘中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

在 .NET Core 中，对方法的调用将 `Regex.CompileToAssembly` 引发 <xref:System.PlatformNotSupportedException> ; 不支持写出程序集。
  
       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CompileToAssembly (regexinfos As RegexCompilationInfo(), assemblyname As AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="regexinfos">描述要编译的正则表达式的数组。</param>
        <param name="assemblyname">程序集的文件名。</param>
        <summary>将一个或多个指定的 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象编译为命名程序集。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo%5B%5D,System.Reflection.AssemblyName)>方法生成一个 .NET Framework 程序集，其中在数组中定义的每个正则表达式 `regexinfos` 由一个类表示。 通常， <xref:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo%5B%5D,System.Reflection.AssemblyName)> 方法是从生成已编译的正则表达式的程序集的单独的应用程序中调用的。 程序集中包含的每个正则表达式具有以下特征：  
  
-   它派生自 <xref:System.Text.RegularExpressions.Regex> 类。  
  
-   为它分配由 `fullnamespace` 其对应对象的和参数定义的完全限定名称 `name` <xref:System.Text.RegularExpressions.RegexCompilationInfo> 。  
  
-   它具有默认 (或无参数) 构造函数。  
  
 通常，在独立于创建程序集的代码的程序集或应用程序中，会找到实例化并使用已编译的正则表达式的代码。  
  
   
  
## Examples  
 下面的示例创建一个名为 RegexLib.dll 的程序集。 程序集包括两个已编译的正则表达式。 第一个是， `Utilities.RegularExpressions.DuplicatedString` 匹配两个相同的连续单词。 第二个 `Utilities.RegularExpressions.EmailAddress` 检查字符串的格式是否正确，是否为电子邮件地址。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile1.vb#1)]  
  
 然后，使用正则表达式来检查字符串中是否存在重复的单词，并将其用于以下示例。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 成功编译第二个示例需要引用 RegexLib.dll () 添加到项目中的第一个示例所创建的程序集。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyname" /> 参数的 <see cref="P:System.Reflection.AssemblyName.Name" /> 属性值是一个空字符串或 null。  
  
- 或 - 
<paramref name="regexinfos" /> 中的一个或多个对象的正则表达式模式包含无效语法。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyname" /> 或 <paramref name="regexinfos" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.PlatformNotSupportedException">仅限 .NET 5 及更高版本和 .NET Core：不支持创建已编译的正则表达式的程序集。</exception>
        <block subset="none" type="usage"><para>如果要在 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 安装了或其单点版本的系统上进行开发，则需要 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 以为目标，并使用 <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> 方法创建包含已编译的正则表达式的程序集。 尝试在已引发异常的系统上，使用该程序集中的某个正则表达式 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 。 若要解决此问题，可执行下列操作之一： 
-在 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 安装了而不是更高版本的系统上生成包含已编译的正则表达式的程序集。  
  
-在 <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> <see cref="T:System.Text.RegularExpressions.Regex" /> <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> 实例化 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象或调用正则表达式模式匹配方法时，请使用带有选项的静态方法或实例方法，而不是从程序集调用和检索已编译的正则表达式。</para></block>
        <related type="Article" href="/dotnet/standard/base-types/compilation-and-reuse-in-regular-expressions">编译和重复使用</related>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[]? attributes);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CompileToAssembly (regexinfos As RegexCompilationInfo(), assemblyname As AssemblyName, attributes As CustomAttributeBuilder())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes)" />
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="regexinfos">描述要编译的正则表达式的数组。</param>
        <param name="assemblyname">程序集的文件名。</param>
        <param name="attributes">定义要应用于程序集的特性的数组。</param>
        <summary>将一个或多个指定的 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象编译为具有指定特性的命名程序集。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo%5B%5D,System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder%5B%5D)>方法生成一个 .NET Framework 程序集，其中在数组中定义的每个正则表达式 `regexinfos` 由一个类表示。 通常， <xref:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo%5B%5D,System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder%5B%5D)> 方法是从生成已编译的正则表达式的程序集的单独的应用程序中调用的。 程序集中包含的每个正则表达式具有以下特征：  
  
-   它派生自 <xref:System.Text.RegularExpressions.Regex> 类。  
  
-   为它分配由 `fullnamespace` 其对应对象的和参数定义的完全限定名称 `name` <xref:System.Text.RegularExpressions.RegexCompilationInfo> 。  
  
-   它具有默认 (或无参数) 构造函数。  
  
 通常，在独立于创建程序集的代码的程序集或应用程序中，会找到实例化并使用已编译的正则表达式的代码。  
  
 由于 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> 方法从方法调用生成 .NET Framework 程序集，而不是使用特定语言的类定义关键字，如 c # 中的 (`class` 或 `Class` ... `End Class` 在 Visual Basic) 中，它不允许使用开发语言的标准特性语法将 .NET Framework 特性分配给程序集。 `attributes`参数提供了一种替代方法，用于定义应用于程序集的特性。 对于要应用于程序集的每个属性，请执行以下操作：  
  
1.  创建对象的数组，这些 <xref:System.Type> 对象表示要调用的特性构造函数的参数类型。  
  
2.  检索一个 <xref:System.Type> 对象，该对象表示要应用于新程序集的特性类。  
  
3.  调用 <xref:System.Type.GetConstructor%2A> attribute 对象的方法 <xref:System.Type> 以检索一个对象，该 <xref:System.Reflection.ConstructorInfo> 对象表示要调用的特性构造函数。 <xref:System.Type.GetConstructor%2A>向方法传递 <xref:System.Type> 表示构造函数的参数类型的对象数组。  
  
4.  创建一个 <xref:System.Object> 数组，该数组定义要传递给该特性的构造函数的参数。  
  
5.  <xref:System.Reflection.Emit.CustomAttributeBuilder>通过将对象的构造函数传递给在第 <xref:System.Reflection.ConstructorInfo> 3 步中检索的对象以及 <xref:System.Object> 在步骤4中创建的数组来实例化对象。  
  
 然后，可以将这些对象的数组 <xref:System.Reflection.Emit.CustomAttributeBuilder> （而非参数）传递 `attributes` 给 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo%5B%5D,System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder%5B%5D)?displayProperty=nameWithType> 方法。  
  
   
  
## Examples  
 下面的示例创建一个名为 RegexLib.dll 的程序集，并将该特性应用于该程序集 <xref:System.Reflection.AssemblyTitleAttribute> 。 程序集包括两个已编译的正则表达式。 第一个是， `Utilities.RegularExpressions.DuplicatedString` 匹配两个相同的连续单词。 第二个 `Utilities.RegularExpressions.EmailAddress` 检查字符串的格式是否正确，是否为电子邮件地址。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile3.vb#3)]  
  
 可以 <xref:System.Reflection.AssemblyTitleAttribute> 通过使用类型为的反射实用程序来检查程序集是否已应用于该程序集。  
  
 然后，使用正则表达式来检查字符串中是否存在重复的单词，并将其用于以下示例。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 成功编译第二个示例需要引用 RegexLib.dll () 添加到项目中的第一个示例所创建的程序集。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyname" /> 参数的 <see cref="P:System.Reflection.AssemblyName.Name" /> 属性值是一个空字符串或 null。  
  
- 或 - 
<paramref name="regexinfos" /> 中的一个或多个对象的正则表达式模式包含无效语法。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyname" /> 或 <paramref name="regexinfos" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.PlatformNotSupportedException">仅限 .NET 5 及更高版本和 .NET Core：不支持创建已编译的正则表达式的程序集。</exception>
        <block subset="none" type="usage"><para>如果要在 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 安装了或其单点版本的系统上进行开发，则需要 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 以为目标，并使用 <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> 方法创建包含已编译的正则表达式的程序集。 尝试在已引发异常的系统上，使用该程序集中的某个正则表达式 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 。 若要解决此问题，可执行下列操作之一： 
-在 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 安装了而不是更高版本的系统上生成包含已编译的正则表达式的程序集。  
  
-在 <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> <see cref="T:System.Text.RegularExpressions.Regex" /> <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> 实例化 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象或调用正则表达式模式匹配方法时，请使用带有选项的静态方法或实例方法，而不是从程序集调用和检索已编译的正则表达式。</para></block>
        <related type="Article" href="/dotnet/standard/base-types/compilation-and-reuse-in-regular-expressions">编译和重复使用</related>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[]? attributes, string? resourceFile);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CompileToAssembly (regexinfos As RegexCompilationInfo(), assemblyname As AssemblyName, attributes As CustomAttributeBuilder(), resourceFile As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes, System::String ^ resourceFile);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] * string -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes, resourceFile)" />
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="resourceFile" Type="System.String" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="regexinfos">描述要编译的正则表达式的数组。</param>
        <param name="assemblyname">程序集的文件名。</param>
        <param name="attributes">定义要应用于程序集的特性的数组。</param>
        <param name="resourceFile">要包含在程序集中的 Win32 资源文件的名称。</param>
        <summary>将一个或多个指定的 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象和一个指定的资源文件编译为具有指定特性的命名程序集。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo%5B%5D,System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder%5B%5D,System.String)>方法生成一个 .NET Framework 程序集，其中在数组中定义的每个正则表达式 `regexinfos` 由一个类表示。 通常， <xref:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo%5B%5D,System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder%5B%5D,System.String)> 方法是从生成已编译的正则表达式的程序集的单独的应用程序中调用的。 程序集中包含的每个正则表达式具有以下特征：  
  
-   它派生自 <xref:System.Text.RegularExpressions.Regex> 类。  
  
-   为它分配由 `fullnamespace` 其对应对象的和参数定义的完全限定名称 `name` <xref:System.Text.RegularExpressions.RegexCompilationInfo> 。  
  
-   它具有默认 (或无参数) 构造函数。  
  
 通常，在独立于创建程序集的代码的程序集或应用程序中，会找到实例化并使用已编译的正则表达式的代码。  
  
 由于 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> 方法从方法调用生成 .NET Framework 程序集，而不是使用特定语言的类定义关键字，如 c # 中的 (`class` 或 `Class` ... `End Class` 在 Visual Basic) 中，它不允许使用开发语言的标准特性语法将 .NET Framework 特性分配给程序集。 `attributes`参数提供了一种替代方法，用于定义应用于程序集的特性。 对于要应用于程序集的每个属性，请执行以下操作：  
  
1.  创建对象的数组，这些 <xref:System.Type> 对象表示要调用的特性构造函数的参数类型。  
  
2.  检索一个 <xref:System.Type> 对象，该对象表示要应用于新程序集的特性类。  
  
3.  调用 <xref:System.Type.GetConstructor%2A> attribute 对象的方法 <xref:System.Type> 以检索一个对象，该 <xref:System.Reflection.ConstructorInfo> 对象表示要调用的特性构造函数。 <xref:System.Type.GetConstructor%2A>向方法传递 <xref:System.Type> 表示构造函数的参数类型的对象数组  
  
4.  创建一个 <xref:System.Object> 数组，该数组定义要传递给该特性的构造函数的参数。  
  
5.  <xref:System.Reflection.Emit.CustomAttributeBuilder>通过将对象的构造函数传递给在第 <xref:System.Reflection.ConstructorInfo> 3 步中检索的对象以及 <xref:System.Object> 在步骤4中创建的数组来实例化对象。  
  
 然后，可以将这些对象的数组 <xref:System.Reflection.Emit.CustomAttributeBuilder> （而非参数）传递 `attributes` 给 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo%5B%5D,System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder%5B%5D,System.String)> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyname" /> 参数的 <see cref="P:System.Reflection.AssemblyName.Name" /> 属性值是一个空字符串或 null。  
  
- 或 - 
<paramref name="regexinfos" /> 中的一个或多个对象的正则表达式模式包含无效语法。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyname" /> 或 <paramref name="regexinfos" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><paramref name="resourceFile" /> 参数指定了无效的 Win32 资源文件。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="resourceFile" /> 参数指定的文件。</exception>
        <exception cref="T:System.PlatformNotSupportedException">仅限 .NET 5 及更高版本和 .NET Core：不支持创建已编译的正则表达式的程序集。</exception>
        <block subset="none" type="usage"><para>如果要在 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 安装了或其单点版本的系统上进行开发，则需要 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 以为目标，并使用 <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> 方法创建包含已编译的正则表达式的程序集。 尝试在已引发异常的系统上，使用该程序集中的某个正则表达式 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 。 若要解决此问题，可执行下列操作之一： 
-在 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 安装了而不是更高版本的系统上生成包含已编译的正则表达式的程序集。  
  
-在 <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> <see cref="T:System.Text.RegularExpressions.Regex" /> <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> 实例化 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象或调用正则表达式模式匹配方法时，请使用带有选项的静态方法或实例方法，而不是从程序集调用和检索已编译的正则表达式。</para></block>
        <related type="Article" href="/dotnet/standard/base-types/compilation-and-reuse-in-regular-expressions">编译和重复使用</related>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="public static string Escape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Escape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Escape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Escape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Escape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Escape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">包含要转换的文本的输入字符串。</param>
        <summary>通过替换为转义码来转义最小的字符集（\\、*、+、?、|、{、[、(、)、^、$、.、# 和空白）。 这将指示正则表达式引擎按原义解释这些字符而不是解释为元字符。</summary>
        <returns>由转换为转义形式的元字符组成的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Escape%2A> 转换字符串，以便正则表达式引擎会将它可能包含的任何元字符解释为字符文本。 例如，请考虑一个正则表达式，该表达式旨在提取由直接左括号和右括号分隔的注释， ( [和] 从文本 ) 。 在下面的示例中，正则表达式 "[ (. *？ ) ]" 被解释为字符类。 正则表达式匹配每个左括号或右括号、句点、星号或问号，而不是匹配输入文本中嵌入的注释。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#1)]  
  
 但是，如果通过将左大括号传递给方法对其进行转义 <xref:System.Text.RegularExpressions.Regex.Escape%2A> ，则正则表达式成功匹配嵌入到输入字符串中的注释。 下面的示例对此进行了演示。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#2)]  
  
 在使用静态文本定义的正则表达式中，通过在其前面加上反斜杠符号（ (\\) ，以及通过调用方法），可以转义要按原义解释的字符而不是作为元字符的字符 <xref:System.Text.RegularExpressions.Regex.Escape%2A> 。 在使用设计时未知的字符动态定义的正则表达式中，调用 <xref:System.Text.RegularExpressions.Regex.Escape%2A> 方法对于确保正则表达式引擎将单个字符解释为文本而不是作为元字符非常重要。  
  
> [!NOTE]
>  如果正则表达式模式包含数字符号 ( # ) 或文本空白字符，则如果在启用选项的情况下分析输入文本，则必须对这些字符进行转义 <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> 。  
  
 虽然<xref:System.Text.RegularExpressions.Regex.Escape%2A>方法可转义直接打开方括号 ([)，并打开大括号 （{） 字符，它未转义其对应的结束字符 (] 和})。 在大多数情况下，不需要进行转义。 如果右大括号或大括号前面没有相应的开始字符，则正则表达式引擎将按原义解释它。 如果左大括号或大括号解释为元字符，则正则表达式引擎会将第一个对应的结束字符解释为元字符。 如果这不是所需的行为，则应通过显式地将反斜杠 () 字符来转义右大括号或大括号 \\ 。 有关说明，请参阅 "示例" 部分。  
  
   
  
## Examples  
 下面的示例从文本中提取注释。 它假定注释由开始注释符号和用户选择的结束注释符号分隔。 由于注释符号按字面解释，因此传递给 <xref:System.Text.RegularExpressions.Regex.Escape%2A> 方法以确保它们不会被错误地解释为元字符。 此外，该示例显式检查用户输入的结束注释符号是否为右方括号 (] ) 或大括号 (} ) 。 如果为，则在括号或大括号前面加上一个反斜杠字符 (\\) ，以便按原义解释该字符。 请注意，此示例还使用 <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> 集合仅显示注释，而不是显示注释以及其开始和结束注释符号。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言 - 快速参考</related>
        <related type="Article" href="/dotnet/standard/base-types/character-escapes-in-regular-expressions">正则表达式中的字符转义</related>
      </Docs>
    </Member>
    <Member MemberName="factory">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexRunnerFactory? factory;" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Text.RegularExpressions.RegexRunnerFactory factory" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.factory" />
      <MemberSignature Language="VB.NET" Value="Protected Friend factory As RegexRunnerFactory " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexRunnerFactory ^ factory;" />
      <MemberSignature Language="F#" Value="val mutable factory : System.Text.RegularExpressions.RegexRunnerFactory" Usage="System.Text.RegularExpressions.Regex.factory" />
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexRunnerFactory factory;" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexRunnerFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法生成的 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Regex ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="regex.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>此成员替代 <see cref="M:System.Object.Finalize" /> 且该主题可能包括更完整的文档。

允许 <see cref="T:System.Object" /> 在"垃圾回收"回收 <see cref="T:System.Object" /> 之前尝试释放资源并执行其他清理操作。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNames">
      <MemberSignature Language="C#" Value="public string[] GetGroupNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetGroupNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetGroupNames();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNames : unit -&gt; string[]" Usage="regex.GetGroupNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回正则表达式的捕获组名数组。</summary>
        <returns>组名的字符串数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 组名的集合包含用于对表达式中的捕获组进行命名的字符串集。 即使捕获组未显式命名，它们也会自动分配数字名称 ( "0"、"1"、"2"、"3" 等) 。 "0" 命名组表示由正则表达式模式匹配的所有文本。 编号组位于集合中的显式命名组之前，命名组按其在正则表达式模式中定义的顺序出现。  
  
 您可以使用 <xref:System.Array.Length%2A> 此方法返回的数组中的属性来确定正则表达式中的组数。  
  
   
  
## Examples  
 下面的示例定义了一个常规用途 `ShowMatches` 方法，该方法显示正则表达式组的名称及其匹配文本。  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/cs/getgroupnames1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/vb/getgroupnames1.vb" id="Snippet1":::
  
 在这种情况下，正则表达式模式 `\b(?<FirstWord>\w+)\s?((\w+)\s)*(?<LastWord>\w+)?(?<Punctuation>\p{Po})` 旨在分析简单的句子，并识别它的第一个单词、上一个词和结束标点符号。 下表显示了如何解释正则表达式模式：  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|在单词边界处开始匹配。|  
|`(?<FirstWord>\w+)`|匹配一个或多个单词字符。 这是 `FirstWord` 命名组。|  
|\s?|匹配零个或一个空白字符。|  
|(\w+)|匹配一个或多个单词字符。 这是第二个捕获组。|  
|\s|与空白字符匹配。|  
| ( ( \w +) \s) *|匹配一个或多个单词字符后跟一个空格的零个或多个匹配项。 这是第一个捕获组。|  
| (？ \<LastWord>\w +) ？|匹配一个或多个单词字符的零个或一个匹配项。 这是 `LastWord` 命名组。|  
| (？ \<Punctuation>\p{Po} ) |匹配 Unicode 类别为标点符号的字符。 这是 `Punctuation` 命名组。|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <related type="Article" href="/dotnet/standard/base-types/grouping-constructs-in-regular-expressions">正则表达式中的分组构造</related>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNumbers">
      <MemberSignature Language="C#" Value="public int[] GetGroupNumbers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] GetGroupNumbers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNumbers () As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ GetGroupNumbers();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNumbers : unit -&gt; int[]" Usage="regex.GetGroupNumbers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回与数组中的组名相对应的捕获组号的数组。</summary>
        <returns>组号的整数数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 未命名的捕获组和命名捕获组都可按编号访问。 未命名的组从1开始从左到右进行编号。  (索引0中的捕获组 (零) 表示整个匹配项 ) 。然后从左到右对命名组进行编号，以大于未命名捕获组数的数字开头。  
  
 按其编号而不是按字符串名称引用组可以提供更快的访问速度。  
  
   
  
## Examples  
 下面的示例定义了与句子匹配的正则表达式 `\b((?<word>\w+)\s*)+(?<end>[.?!])` 。 正则表达式包括三个捕获组：一个未命名组，用于捕获单独的单词，还包含一个可跟随的空格字符;名为 `word` 的组，用于捕获句子中的各个单词; 名为的组， `end` 用于捕获结束句子的标点。 该示例调用 <xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A> 方法以获取所有捕获组的数目，然后显示其捕获的字符串。 此外， <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> 方法用于指示特定编号组是否对应于命名组。  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/cs/getgroupnumbers1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/vb/getgroupnumbers1.vb" id="Snippet1":::
  
 正则表达式模式可以解释为下表中所示内容。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|在单词边界处开始匹配。|  
|`(?<word>\w+)`|匹配一个或多个单词字符，并将匹配的字符串分配给名为的组 `word` 。|  
|`\s*`|匹配零个或多个空白字符。|  
|`((?<word>\w+)\s*)`|将 `word` 后跟任何捕获的空白字符的捕获组分配给第一个捕获的组。|  
|`((?<word>\w+)\s*)+`|一次或多次匹配一个或多个单词字符后跟任意空白字符的模式。|  
|`(?<end>[.?!])`|匹配句号、问号或感叹号。 将匹配的字符分配给 `end` 捕获组。|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <related type="Article" href="/dotnet/standard/base-types/grouping-constructs-in-regular-expressions">正则表达式中的分组构造</related>
      </Docs>
    </Member>
    <Member MemberName="GroupNameFromNumber">
      <MemberSignature Language="C#" Value="public string GroupNameFromNumber (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GroupNameFromNumber(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNameFromNumber (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GroupNameFromNumber(int i);" />
      <MemberSignature Language="F#" Value="member this.GroupNameFromNumber : int -&gt; string" Usage="regex.GroupNameFromNumber i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">要转换为相应组名的组号。</param>
        <summary>获取与指定组号相对应的组名。</summary>
        <returns>包含与指定组号关联的组名的字符串。 如果没有与 <paramref name="i" /> 对应的组名，此方法会返回 <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 正则表达式模式可以包含已命名或已编号的捕获组，这些组描绘了模式匹配中的子表达式。 编号组由 (*子表达式*) 的语法进行分隔，并根据其在正则表达式中的顺序为其赋值。 命名组由语法 ( `<` 分隔：*名称* `>`*子表达式*) 或 (？ "*name*'*子表达式*) ，其中 *name* 是用于标识子表达式的名称。  (有关详细信息，请参阅 [分组构造](/dotnet/standard/base-types/grouping-constructs-in-regular-expressions)。 ) <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> 方法通过其在正则表达式中的序号位置来标识命名组和编号组。 序号位置零始终表示整个正则表达式。 然后，在命名组之前对所有编号组进行计数，而不考虑它们在正则表达式模式中的实际位置。  
  
 如果 `i` 是命名组的编号，则方法返回组的名称。 如果 `i` 是未命名组的编号，则方法返回该数字的字符串表示形式。 例如，如果 `i` 为1，则方法返回 "1"。 如果不 `i` 是捕获组的编号，则该方法返回 <xref:System.String.Empty?displayProperty=nameWithType> 。  
  
 如果找到了模式匹配项，则可使用此方法返回的值 <xref:System.Text.RegularExpressions.Group> 从属性中检索表示捕获的组的对象 <xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType> 。 <xref:System.Text.RegularExpressions.GroupCollection>对象由 <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> 属性返回。  
  
   
  
## Examples  
 下面的示例定义一个正则表达式模式，该模式与包含美国城市名称、省/市/自治区名称和邮政编码的地址行匹配。 该示例使用 <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> 方法检索捕获组的名称。 然后，它使用这些名称检索对应的捕获组以进行匹配。  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/cs/groupnamefromnumberex.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/vb/groupnamefromnumberex.vb" id="Snippet1"::: 
  
 正则表达式模式由以下表达式定义：  
  
 `(?<city>[A-Za-z\s]+), (?<state>[A-Za-z]{2}) (?<zip>\d{5}(-\d{4})?)`  
  
 下表演示了如何解释正则表达式模式。  
  
|模式|说明|  
|-------------|-----------------|  
|`(?<city>[A-Za-z\s]+)`|匹配一个或多个字母或空白字符。 为此捕获的组指定名称 `city` 。|  
|`,`|匹配逗号 (，) 后跟一个空白字符。|  
|`(?<state>[A-Za-z]{2})`|匹配两个字母字符。 为此捕获的组指定名称 `state` 。 此组后面应跟一个空白字符。|  
|`(?<zip>\d{5}(-\d{4})?)`|匹配后跟零个或一个连字符后跟四位数的数字。 为此捕获的组指定名称 `zip` 。|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
        <related type="Article" href="/dotnet/standard/base-types/grouping-constructs-in-regular-expressions">正则表达式中的分组构造</related>
      </Docs>
    </Member>
    <Member MemberName="GroupNumberFromName">
      <MemberSignature Language="C#" Value="public int GroupNumberFromName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GroupNumberFromName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNumberFromName (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GroupNumberFromName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GroupNumberFromName : string -&gt; int" Usage="regex.GroupNumberFromName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要转换为相应组号的组名。</param>
        <summary>返回与指定组名相对应的组号。</summary>
        <returns>与指定组名相对应的组号，如果 <paramref name="name" /> 不是有效组名，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 正则表达式模式可以包含已命名或已编号的捕获组，这些组描绘了模式匹配中的子表达式。 编号组由 (*子表达式*) 的语法进行分隔，并根据其在正则表达式中的顺序为其赋值。 命名组由语法 ( `<` 分隔：*名称* `>`*子表达式*) 或 (？ "*name*'*子表达式*) ，其中 *name* 是用于标识子表达式的名称。  (有关详细信息，请参阅 [分组构造](/dotnet/standard/base-types/grouping-constructs-in-regular-expressions)。 ) <xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A> 方法通过其在正则表达式中的序号位置来标识命名组和编号组。 序号位置零始终表示整个正则表达式。 然后，在命名组之前对所有编号组进行计数，而不考虑它们在正则表达式模式中的实际位置。  
  
 如果 `name` 是正则表达式模式中出现的组号的字符串表示形式，则此方法将返回该数字。 如果 `name` 对应于正则表达式模式中存在的命名捕获组，则该方法返回其对应的数字。 `name`与组名称的比较区分大小写。 如果与 `name` 捕获组的名称或捕获组编号的字符串表示形式不对应，则该方法将返回-1。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
        <related type="Article" href="/dotnet/standard/base-types/grouping-constructs-in-regular-expressions">正则表达式中的分组构造</related>
      </Docs>
    </Member>
    <Member MemberName="InfiniteMatchTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定模式匹配操作不应超时。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)>类构造函数和多个静态匹配方法使用 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> 常数指示查找模式匹配项的尝试不会超时。  
  
> [!WARNING]
>  将正则表达式引擎的超时值设置为 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> 可能会导致依赖过多回溯的正则表达式似乎在处理与正则表达式模式几乎匹配的文本时停止响应。 如果禁用超时，则应确保正则表达式不依赖于过度回溯，并处理与正则表达式模式几乎匹配的文本。  
>   
>  有关如何处理回溯的详细信息，请参阅 [回溯](/dotnet/standard/base-types/backtracking-in-regular-expressions)。  
  
 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>可以将常量作为以下成员的参数值提供 `matchTimeout` ：  
  
-   <xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)>  
  
-   <xref:System.Text.RegularExpressions.RegexCompilationInfo.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.String,System.String,System.Boolean,System.TimeSpan)?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      </Docs>
    </Member>
    <Member MemberName="InitializeReferences">
      <MemberSignature Language="C#" Value="protected void InitializeReferences ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeReferences() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.InitializeReferences" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeReferences ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeReferences();" />
      <MemberSignature Language="F#" Value="member this.InitializeReferences : unit -&gt; unit" Usage="regex.InitializeReferences " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法生成的 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象使用。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">引用已初始化。</exception>
      </Docs>
    </Member>
    <Member MemberName="internalMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.TimeSpan internalMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend internalMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="protected public: TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="F#" Value="val mutable internalMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.Serialization.OptionalField(VersionAdded=2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Serialization.OptionalField(VersionAdded=2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>操作超时之前在一个模式匹配操作中可以经过的最长时间。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsMatch">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指示正则表达式在输入字符串中是否找到匹配项。</summary>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言 - 快速参考</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string -&gt; bool" Usage="regex.IsMatch input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <summary>指示 <see cref="T:System.Text.RegularExpressions.Regex" /> 构造函数中指定的正则表达式在指定的输入字符串中是否找到了匹配项。</summary>
        <returns>如果正则表达式找到匹配项，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>方法通常用于验证字符串或确保字符串符合特定模式，而不检索该字符串进行后续操作。 如果要确定一个或多个字符串是否与正则表达式模式匹配，然后检索它们以供后续操作，请调用 <xref:System.Text.RegularExpressions.Regex.Match%2A> 或 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 方法。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果匹配操作的执行时间超过了构造函数指定的超时间隔，则会引发异常 <xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)?displayProperty=nameWithType> 。 如果在调用构造函数时未设置超时间隔，则当操作超过在其中创建对象的应用程序域的任何超时值时，将引发异常 <xref:System.Text.RegularExpressions.Regex> 。 如果在 <xref:System.Text.RegularExpressions.Regex> 构造函数调用或应用程序域的属性中没有定义超时，或者超时值为 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ，则不会引发异常。  
  
   
  
## Examples  
 下面的示例演示 <xref:System.Text.RegularExpressions.Regex.IsMatch(System.String)> 如何使用方法来确定字符串是否是有效的部件号。 正则表达式假定部件号具有特定的格式，该格式包含三组由连字符分隔的字符。 包含四个字符的第一个集必须包含一个字母数字字符，后跟两个数字字符后跟一个字母数字字符。 由三个字符组成的第二个集必须为数字。 第三个集由四个字符组成，必须有三个数字字符后跟一个字母数字字符。  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch2.vb" id="Snippet2":::
  
 正则表达式模式为：  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 下表演示了如何解释正则表达式模式。  
  
|模式|说明|  
|-------------|-----------------|  
|`^`|从行的开头开始匹配。|  
|`[a-zA-Z0-9]`|匹配单个字母字符 (`a` 到 `z` 或 `A` 通过 `Z`) 或数字字符。|  
|`\d{2}`|匹配两个数字字符。|  
|`[a-zA-Z0-9]`|匹配单个字母字符 (`a` 到 `z` 或 `A` 通过 `Z`) 或数字字符。|  
|`-`|匹配连字符。|  
|`\d{3}`|正好匹配三个数字字符。|  
|`(-\d{3}){2}`|查找后跟三个数字字符的连字符，并匹配此模式的两个匹配项。|  
|`[a-zA-Z0-9]`|匹配单个字母字符 (`a` 到 `z` 或 `A` 通过 `Z`) 或数字字符。|  
|`$`|在行的末尾结束匹配。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String, startat As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string * int -&gt; bool" Usage="regex.IsMatch (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="startat">开始搜索的字符位置。</param>
        <summary>指示 <see cref="T:System.Text.RegularExpressions.Regex" /> 构造函数中指定的正则表达式在指定的输入字符串中，从该字符串中的指定起始位置开始是否找到了匹配项。</summary>
        <returns>如果正则表达式找到匹配项，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>方法通常用于验证字符串或确保字符串符合特定模式，而不检索该字符串进行后续操作。 如果要确定一个或多个字符串是否与正则表达式模式匹配，然后检索它们以供后续操作，请调用 <xref:System.Text.RegularExpressions.Regex.Match%2A> 或 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 方法。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果匹配操作的执行时间超过了构造函数指定的超时间隔，则会引发异常 <xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)?displayProperty=nameWithType> 。 如果在调用构造函数时未设置超时间隔，则当操作超过在其中创建对象的应用程序域的任何超时值时，将引发异常 <xref:System.Text.RegularExpressions.Regex> 。 如果在 <xref:System.Text.RegularExpressions.Regex> 构造函数调用或应用程序域的属性中没有定义超时，或者超时值为 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ，则不会引发异常。  
  
   
  
## Examples  
 下面的示例演示 <xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)> 如何使用方法来确定字符串是否是有效的部件号。 它会搜索后面跟有冒号 (： ) 字符的部件号。 <xref:System.String.IndexOf(System.Char)>方法用于确定冒号字符的位置，然后将其传递给 <xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)> 方法。 正则表达式假定部件号具有特定的格式，该格式包含三组由连字符分隔的字符。 包含四个字符的第一个集必须包含一个字母数字字符，后跟两个数字字符后跟一个字母数字字符。 由三个字符组成的第二个集必须为数字。 第三个集由四个字符组成，必须有三个数字字符后跟一个字母数字字符。  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch3.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch3.vb" id="Snippet3":::
  
 正则表达式模式为：  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 下表演示了如何解释正则表达式模式。  
  
|模式|说明|  
|-------------|-----------------|  
|`[a-zA-Z0-9]`|匹配单个字母字符 (`a` 到 `z` 或 `A` 通过 `Z`) 或数字字符。|  
|`\d{2}`|匹配两个数字字符。|  
|`[a-zA-Z0-9]`|匹配单个字母字符 (`a` 到 `z` 或 `A` 通过 `Z`) 或数字字符。|  
|`-`|匹配连字符。|  
|`\d{3}`|正好匹配三个数字字符。|  
|`(-\d{3}){2}`|查找后跟三个数字字符的连字符，并匹配此模式的两个匹配项。|  
|`[a-zA-Z0-9]`|匹配单个字母字符 (`a` 到 `z` 或 `A` 通过 `Z`) 或数字字符。|  
|`$`|在行的末尾结束匹配。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> 小于零或大于 <paramref name="input" /> 的长度。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <summary>指示所指定的正则表达式在指定的输入字符串中是否找到了匹配项。</summary>
        <returns>如果正则表达式找到匹配项，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>方法通常用于验证字符串或确保字符串符合特定模式，而不检索该字符串进行后续操作。 如果要确定一个或多个字符串是否与正则表达式模式匹配，然后检索它们以供后续操作，请调用 <xref:System.Text.RegularExpressions.Regex.Match%2A> 或 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 方法。  
  
 静态 <xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)> 方法等效于 <xref:System.Text.RegularExpressions.Regex> 使用指定的正则表达式模式构造对象 `pattern` ，并调用 <xref:System.Text.RegularExpressions.Regex.IsMatch(System.String)> 实例方法。 此正则表达式模式将缓存，以便正则表达式引擎进行快速检索。  
  
 `pattern`参数包含符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅 [.NET Framework 正则表达式](/dotnet/standard/base-types/regular-expressions) 和 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果匹配操作的执行时间超过为其调用该方法的应用程序域指定的超时间隔，则会引发异常。 如果在应用程序域的属性中没有定义超时，或者超时值为 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ，则不会引发异常。  
  
   
  
## Examples  
 下面的示例演示 <xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)> 如何使用方法来确定字符串是否是有效的部件号。 正则表达式假定部件号具有特定的格式，该格式包含三组由连字符分隔的字符。 包含四个字符的第一个集必须包含一个字母数字字符，后跟两个数字字符后跟一个字母数字字符。 由三个字符组成的第二个集必须为数字。 第三个集由四个字符组成，必须有三个数字字符后跟一个字母数字字符。  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch1.vb" id="Snippet1":::
  
 正则表达式模式为：  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 下表演示了如何解释正则表达式模式。  
  
|模式|说明|  
|-------------|-----------------|  
|`^`|从行的开头开始匹配。|  
|`[a-zA-Z0-9]`|匹配单个字母字符 (`a` 到 `z` 或 `A` 通过 `Z`) 或数字字符。|  
|`\d{2}`|匹配两个数字字符。|  
|`[a-zA-Z0-9]`|匹配单个字母字符 (`a` 到 `z` 或 `A` 通过 `Z`) 或数字字符。|  
|`-`|匹配连字符。|  
|`\d{3}`|正好匹配三个数字字符。|  
|`(-\d{3}){2}`|查找后跟三个数字字符的连字符，并匹配此模式的两个匹配项。|  
|`[a-zA-Z0-9]`|匹配单个字母字符 (`a` 到 `z` 或 `A` 通过 `Z`) 或数字字符。|  
|`$`|在行的末尾结束匹配。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <block subset="none" type="usage"><para>此方法在与调用方法的应用程序域的默认超时值相等的时间间隔后超时。 如果尚未为应用程序域定义超时值，则将 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> 使用该值来阻止方法超时。 建议用于验证模式匹配的静态方法是 <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /> ，它允许您设置超时间隔。</para></block>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="options">枚举值的一个按位组合，这些枚举值提供匹配选项。</param>
        <summary>指示所指定的正则表达式是否使用指定的匹配选项在指定的输入字符串中找到了匹配项。</summary>
        <returns>如果正则表达式找到匹配项，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>方法通常用于验证字符串或确保字符串符合特定模式，而不检索该字符串进行后续操作。 如果要确定一个或多个字符串是否与正则表达式模式匹配，然后检索它们以供后续操作，请调用 <xref:System.Text.RegularExpressions.Regex.Match%2A> 或 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 方法。  
  
 静态 <xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)> 方法等效于 <xref:System.Text.RegularExpressions.Regex> 使用指定的正则表达式模式构造对象 `pattern` ，并使用指定的正则表达式选项 `options` 调用 <xref:System.Text.RegularExpressions.Regex.IsMatch(System.String)> 实例方法。 此正则表达式模式将缓存，以便正则表达式引擎进行快速检索。  
  
 `pattern`参数包含符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅 [.NET Framework 正则表达式](/dotnet/standard/base-types/regular-expressions) 和 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果匹配操作的执行时间超过为其调用该方法的应用程序域指定的超时间隔，则会引发异常。 如果在应用程序域的属性中没有定义超时，或者超时值为 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ，则不会引发异常。  
  
   
  
## Examples  
 下面的示例演示 <xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)> 如何使用方法来确定字符串是否是有效的部件号。 正则表达式假定部件号具有特定的格式，该格式包含三组由连字符分隔的字符。 包含四个字符的第一个集必须包含一个字母数字字符，后跟两个数字字符后跟一个字母数字字符。 由三个字符组成的第二个集必须为数字。 第三个集由四个字符组成，必须有三个数字字符后跟一个字母数字字符。  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch4.cs" interactive="try-dotnet" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch4.vb" id="Snippet4":::
  
 正则表达式模式为：  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 下表演示了如何解释正则表达式模式。  
  
|模式|描述|  
|-------------|-----------------|  
|`^`|从字符串开头开始匹配。|  
|`[A-Z0-9]`|匹配任何单个字母字符 `A` ，从到 `Z` 或任意数字字符。|  
|`\d{2}`|匹配两个数字字符。|  
|`[A-Z0-9]`|匹配任何单个字母字符 `A` ，从到 `Z` 或任意数字字符。|  
|`-`|匹配连字符。|  
|`\d{3}`|正好匹配三个数字字符。|  
|`(-\d{3}){2}`|查找后跟三个数字字符的连字符，并匹配此模式的两个匹配项。|  
|`[A-Z0-9]`|匹配任何单个字母字符 `A` ，从到 `Z` 或任意数字字符。|  
|`$`|在字符串的结尾结束匹配。|  
  
 调用 <xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)> 方法并将 `options` 参数设置为 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 相当于定义以下正则表达式：  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 若要进行比较，请参阅方法的示例 <xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是有效的 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <block subset="none" type="usage"><para>此方法在与调用该方法的应用程序域的默认超时值相等的时间间隔后超时。 如果尚未为应用程序域定义超时值，则将 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> 使用该值来阻止方法超时。 建议用于验证模式匹配的静态方法是 <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /> ，它允许您设置超时间隔。</para></block>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="options">枚举值的一个按位组合，这些枚举值提供匹配选项。</param>
        <param name="matchTimeout">超时间隔；若要指示该方法不应超时，则为 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</param>
        <summary>指示所指定的正则表达式是否使用指定的匹配选项和超时间隔在指定的输入字符串中找到了匹配项。</summary>
        <returns>如果正则表达式找到匹配项，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>方法通常用于验证字符串或确保字符串符合特定模式，而不检索该字符串进行后续操作。 如果要确定一个或多个字符串是否与正则表达式模式匹配，然后检索它们以供后续操作，请调用 <xref:System.Text.RegularExpressions.Regex.Match%2A> 或 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 方法。  
  
 静态 <xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)> 方法等效于 <xref:System.Text.RegularExpressions.Regex> 使用指定的正则表达式模式构造对象 `pattern` ，并使用指定的正则表达式选项 `options` 调用 <xref:System.Text.RegularExpressions.Regex.IsMatch(System.String)> 实例方法。 此正则表达式模式将缓存，以便正则表达式引擎进行快速检索。  
  
 `pattern`参数包含符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅 [.NET Framework 正则表达式](/dotnet/standard/base-types/regular-expressions) 和 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)。  
  
 `matchTimeout`参数指定模式匹配方法在超时之前应尝试找到匹配项的时间长度。设置超时间隔可防止正则表达式在处理包含接近匹配项的输入时，这些表达式会出现依赖于过量回溯的正则表达式停止响应。 有关详细信息，请参阅[正则表达式和回溯的最佳实践](/dotnet/standard/base-types/best-practices)。 [](/dotnet/standard/base-types/backtracking-in-regular-expressions) 如果在该时间间隔内未找到匹配项，则该方法将引发 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 异常。 `matchTimeout` 重写为在其中执行该方法的应用程序域定义的任何默认超时值。  
  
   
  
## Examples  
 下面的示例演示 <xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)> 如何使用方法来确定字符串是否是有效的部件号。 正则表达式假定部件号具有特定的格式，该格式包含三组由连字符分隔的字符。 包含四个字符的第一个集必须包含一个字母数字字符，后跟两个数字字符后跟一个字母数字字符。 由三个字符组成的第二个集必须为数字。 第三个集由四个字符组成，必须有三个数字字符后跟一个字母数字字符。 匹配正则表达式模式应涉及到最小搜索输入字符串，因此该方法将超时间隔设置为500毫秒。  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch5.cs" interactive="try-dotnet" id="Snippet5":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch5.vb" id="Snippet5":::
  
 正则表达式模式为：  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 下表演示了如何解释正则表达式模式。  
  
|模式|描述|  
|-------------|-----------------|  
|`^`|从字符串开头开始匹配。|  
|`[A-Z0-9]`|匹配任何单个字母字符 `A` ，从到 `Z` 或任意数字字符。|  
|`\d{2}`|匹配两个数字字符。|  
|`[A-Z0-9]`|匹配任何单个字母字符 `A` ，从到 `Z` 或任意数字字符。|  
|`-`|匹配连字符。|  
|`\d{3}`|正好匹配三个数字字符。|  
|`(-\d{3}){2}`|查找后跟三个数字字符的连字符，并匹配此模式的两个匹配项。|  
|`[A-Z0-9]`|匹配任何单个字母字符 `A` ，从到 `Z` 或任意数字字符。|  
|`$`|在字符串的结尾结束匹配。|  
  
 调用 <xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)> 方法并将 `options` 参数设置为 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 相当于定义以下正则表达式：  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 若要进行比较，请参阅方法的示例 <xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是有效的 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值。  
  
- 或 - 
 <paramref name="matchTimeout" /> 为负、零或大于 24 天左右。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。</exception>
        <block subset="none" type="usage"><para>建议将 <paramref name="matchTimeout" /> 参数设置为适当的值，例如两秒钟。 如果通过指定禁用超时 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> ，则正则表达式引擎可提供略微更好的性能。 但是，只应在以下条件下禁用超时： 
-正则表达式处理的输入派生自已知的和受信任的源，或由静态文本组成。 这不包括用户动态输入的文本。  
  
-对正则表达式模式进行了全面测试，以确保它有效地处理匹配、不匹配和接近匹配项。  
  
-当正则表达式模式不包含已知的语言元素时，这些元素会导致在处理接近的匹配时导致过度回溯。</para></block>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言元素</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Match">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在输入字符串中搜索匹配正则表达式模式的子字符串，并将第一个匹配项作为单个 <see cref="T:System.Text.RegularExpressions.Match" /> 对象返回。</summary>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言 - 快速参考</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Match : string -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <summary>在指定的输入字符串中搜索 <see cref="T:System.Text.RegularExpressions.Regex" /> 构造函数中指定的正则表达式的第一个匹配项。</summary>
        <returns>一个包含有关匹配的信息的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match(System.String)>方法返回输入字符串中与正则表达式模式匹配的第一个子字符串。 有关用于生成正则表达式模式的语言元素的信息，请参阅 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)。  
  
 您可以通过检查返回对象的属性的值来确定是否在输入字符串中找到了正则表达式模式 <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Group.Success%2A> 。 如果找到匹配项，则返回的 <xref:System.Text.RegularExpressions.Match> 对象的 <xref:System.Text.RegularExpressions.Capture.Value%2A> 属性包含与 `input` 正则表达式模式匹配的子字符串。 如果未找到匹配项，则其值为 <xref:System.String.Empty?displayProperty=nameWithType> 。  
  
 此方法将返回中 `input` 与正则表达式模式匹配的第一个子字符串。 您可以通过重复调用返回对象的方法来检索后续匹配项 <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> 。 还可以通过调用方法来检索单个方法调用中的所有匹配项 <xref:System.Text.RegularExpressions.Regex.Matches(System.String)?displayProperty=nameWithType> 。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果匹配操作的执行时间超过了构造函数指定的超时间隔，则会引发异常 <xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)?displayProperty=nameWithType> 。 如果在调用构造函数时未设置超时间隔，则当操作超过在其中创建对象的应用程序域的任何超时值时，将引发异常 <xref:System.Text.RegularExpressions.Regex> 。 如果在 <xref:System.Text.RegularExpressions.Regex> 构造函数调用或应用程序域的属性中没有定义超时，或者超时值为 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ，则不会引发异常。  
  
   
  
## Examples  
 下面的示例查找字符串中的正则表达式模式匹配，然后列出匹配的组、捕获和捕获位置。  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cpp/snippet8.cpp" id="Snippet8":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cs/snippet8.cs" interactive="try-dotnet" id="Snippet8":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/regex match, nextmatch, groups, captures/vb/snippet8.vb" id="Snippet8":::
  
 正则表达式模式 `(\w+)\s+(car)` 匹配单词 "car" 和其前面的单词。 它被解释如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`(\w+)`|匹配一个或多个单词字符。 这是第一个捕获组。|  
|`\s+`|匹配一个或多个空白字符。|  
| (汽车) |匹配文本字符串 "car"。 这是第二个捕获组。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言 - 快速参考</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, startat As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="startat">开始搜索的字符位置（从零开始）。</param>
        <summary>从输入字符串中的指定起始位置开始，在该字符串中搜索正则表达式的第一个匹配项。</summary>
        <returns>一个包含有关匹配的信息的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)>方法返回一个匹配正则表达式模式的第一个子字符串，该模式从 `startat` 字符位置或字符位置之后的输入字符串中开始。 有关用于生成正则表达式模式的语言元素的信息，请参阅 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)。  
  
 方法搜索的正则表达式模式 <xref:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)> 由对一个 <xref:System.Text.RegularExpressions.Regex> 类构造函数的调用定义。 有关可形成正则表达式模式的元素的详细信息，请参阅 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)。  
  
 您可以根据需要使用参数指定字符串中的起始位置 `startat` 。 正则表达式引擎从左到右进行分析时 (默认) ，匹配和扫描从右移中指定的字符开始 `startat` 。 当正则表达式引擎从右到左进行分析时 (如果正则表达式模式是通过 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> 选项) 构造的，则匹配和扫描将按相反方向移动，并以 `startat` -1 开头。 如果未指定起始位置，搜索将从默认 `startat` 位置开始。 如果正则表达式从左到右搜索，则默认 `startat` 位置位于的左侧 `input` ; 如果从右到左搜索，则默认 `startat` 位置位于的右端 `input` 。  
  
 如果要限制匹配，使其在字符串中的特定字符位置开始，并且正则表达式引擎不会扫描字符串的剩余部分以查找匹配项，请使用左侧 `\G` 的 (定位于左到右模式，或从右到左的模式) 右侧定位正则表达式。 这会限制匹配项，因此它必须正好从开始 `startat` 。  
  
 您可以通过检查返回对象的属性的值来确定是否在输入字符串中找到了正则表达式模式 <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Group.Success%2A> 。 如果找到匹配项，则返回的 <xref:System.Text.RegularExpressions.Match> 对象的 <xref:System.Text.RegularExpressions.Capture.Value%2A> 属性包含与 `input` 正则表达式模式匹配的子字符串。 如果未找到匹配项，则其值为 <xref:System.String.Empty?displayProperty=nameWithType> 。  
  
 此方法返回在 `startat` 中 `input` 与正则表达式模式匹配的字符位置处找到的第一个子字符串。 您可以通过重复调用返回对象的方法来检索后续匹配项 <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> 。 还可以通过调用方法来检索单个方法调用中的所有匹配项 <xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)?displayProperty=nameWithType> 。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果匹配操作的执行时间超过了构造函数指定的超时间隔，则会引发异常 <xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)?displayProperty=nameWithType> 。 如果在调用构造函数时未设置超时间隔，则当操作超过在其中创建对象的应用程序域的任何超时值时，将引发异常 <xref:System.Text.RegularExpressions.Regex> 。 如果在 <xref:System.Text.RegularExpressions.Regex> 构造函数调用或应用程序域的属性中没有定义超时，或者超时值为 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ，则不会引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> 小于零或大于 <paramref name="input" /> 的长度。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言 - 快速参考</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Match : string * string -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <summary>在指定的输入字符串中搜索指定的正则表达式的第一个匹配项。</summary>
        <returns>一个包含有关匹配的信息的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String)>方法返回输入字符串中与正则表达式模式匹配的第一个子字符串。 有关用于生成正则表达式模式的语言元素的信息，请参阅 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)。  
  
 静态 <xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String)> 方法等效于 <xref:System.Text.RegularExpressions.Regex> 使用指定的正则表达式模式构造对象，并调用实例 <xref:System.Text.RegularExpressions.Regex.Match(System.String)> 方法。 在这种情况下，正则表达式引擎会缓存正则表达式模式。  
  
 `pattern`参数包含符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅 [.NET Framework 正则表达式](/dotnet/standard/base-types/regular-expressions) 和 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)。  
  
 您可以通过检查返回对象的属性的值来确定是否在输入字符串中找到了正则表达式模式 <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Group.Success%2A> 。 如果找到匹配项，则返回的 <xref:System.Text.RegularExpressions.Match> 对象的 <xref:System.Text.RegularExpressions.Capture.Value%2A> 属性包含与 `input` 正则表达式模式匹配的子字符串。 如果未找到匹配项，则其值为 <xref:System.String.Empty?displayProperty=nameWithType> 。  
  
 此方法将返回中 `input` 与正则表达式模式匹配的第一个子字符串。 您可以通过重复调用返回对象的方法来检索后续匹配项 <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> 。 还可以通过调用方法来检索单个方法调用中的所有匹配项 <xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)?displayProperty=nameWithType> 。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果匹配操作的执行时间超过为其调用该方法的应用程序域指定的超时间隔，则会引发异常。 如果在应用程序域的属性中没有定义超时，或者超时值为 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ，则不会引发异常。  
  
   
  
## Examples  
 下面的示例调用 <xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String)> 方法查找至少包含一个字符的第一个单词 `z` ，然后调用 <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> 方法查找任何其他匹配项。  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match1.vb" id="Snippet1":::  
  
 正则表达式模式 `\b\w*z+\w*\b` 的含义如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|在单词边界处开始匹配。|  
|`\w*`|匹配零个、一个或多个单词字符。|  
|`z+`|匹配一个或多个字符匹配项 `z` 。|  
|`\w*`|匹配零个、一个或多个单词字符。|  
|`\b`|在单词边界处结束匹配。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <block subset="none" type="usage"><para>此方法在与调用该方法的应用程序域的默认超时值相等的时间间隔后超时。 如果尚未为应用程序域定义超时值，则将 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> 使用该值来阻止方法超时。 用于检索模式匹配项的建议静态方法是 <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" /> ，它允许您设置超时间隔。</para></block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言 - 快速参考</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int beginning, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 beginning, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, beginning As Integer, length As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int beginning, int length);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, beginning, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="beginning" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="beginning">输入字符串中从零开始的字符位置，它定义要搜索的最左侧的位置。</param>
        <param name="length">子字符串中包含在搜索中的字符数。</param>
        <summary>从指定的起始位置开始，在输入字符串中搜索正则表达式的第一个匹配项，并且仅搜索指定数量的字符。</summary>
        <returns>一个包含有关匹配的信息的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)>方法返回在输入字符串的一部分中与正则表达式模式匹配的第一个子字符串。 有关用于生成正则表达式模式的语言元素的信息，请参阅 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)。  
  
 方法搜索的正则表达式模式 <xref:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)> 由对一个 <xref:System.Text.RegularExpressions.Regex> 类构造函数的调用定义。 有关可形成正则表达式模式的元素的详细信息，请参阅 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)。  
  
 <xref:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)>方法在 `input` 由和参数定义的部分中搜索 `beginning` `length` 正则表达式模式。 `beginning` 始终定义要包括在搜索中的最左侧字符的索引，并 `length` 定义要搜索的最大字符数。 它们共同定义搜索范围。 如果从左到右 (默认) 进行搜索，则正则表达式引擎将从索引处的字符搜索 `beginning` 到索引 `beginning`  +  `length` -1 处的字符。 如果正则表达式引擎是通过使用选项进行实例化的 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> ，以便从右到左进行搜索，则正则表达式引擎将从位于索引-1 的字符搜索 `beginning`  +  `length` 到索引处的字符 `beginning` 。 此方法返回它在此范围内找到的第一个匹配项。 您可以通过重复调用返回对象的方法来检索后续匹配项 <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> 。  
  
 您可以通过检查返回对象的属性的值来确定是否在输入字符串中找到了正则表达式模式 <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Group.Success%2A> 。 如果找到匹配项，则返回的 <xref:System.Text.RegularExpressions.Match> 对象的 <xref:System.Text.RegularExpressions.Capture.Value%2A> 属性包含与 `input` 正则表达式模式匹配的子字符串。 如果未找到匹配项，则其值为 <xref:System.String.Empty?displayProperty=nameWithType> 。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果匹配操作的执行时间超过了构造函数指定的超时间隔，则会引发异常 <xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)?displayProperty=nameWithType> 。 如果在调用构造函数时未设置超时值，则在操作超过在其中创建对象的应用程序域的任何超时值时，将引发异常 <xref:System.Text.RegularExpressions.Regex> 。 如果在 <xref:System.Text.RegularExpressions.Regex> 构造函数调用或应用程序域的属性中没有定义超时，或者超时值为 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ，则不会引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="beginning" /> 小于零或大于 <paramref name="input" /> 的长度。  
  
- 或 - 
 <paramref name="length" /> 小于零或大于 <paramref name="input" /> 的长度。  
  
- 或 - 
 <paramref name="beginning" /><see langword="+" /><paramref name="length" /><see langword="-1" /> 表示 <paramref name="input" /> 范围外的某个位置。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言 - 快速参考</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="options">枚举值的一个按位组合，这些枚举值提供匹配选项。</param>
        <summary>使用指定的匹配选项在输入字符串中搜索指定的正则表达式的第一个匹配项。</summary>
        <returns>一个包含有关匹配的信息的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)>方法返回输入字符串中与正则表达式模式匹配的第一个子字符串。 有关用于生成正则表达式模式的语言元素的信息，请参阅 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)。  
  
 静态 <xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)> 方法等效于 <xref:System.Text.RegularExpressions.Regex> 使用 <xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions)> 构造函数构造对象和调用实例 <xref:System.Text.RegularExpressions.Regex.Match(System.String)> 方法。  
  
 `pattern`参数包含符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅 [.NET Framework 正则表达式](/dotnet/standard/base-types/regular-expressions) 和 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)。  
  
 您可以通过检查返回对象的属性的值来确定是否在输入字符串中找到了正则表达式模式 <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Group.Success%2A> 。 如果找到匹配项，则返回的 <xref:System.Text.RegularExpressions.Match> 对象的 <xref:System.Text.RegularExpressions.Capture.Value%2A> 属性包含与 `input` 正则表达式模式匹配的子字符串。 如果未找到匹配项，则其值为 <xref:System.String.Empty?displayProperty=nameWithType> 。  
  
 此方法返回中找到 `input` 的与正则表达式模式匹配的第一个子字符串。 您可以通过重复调用返回对象的方法来检索后续匹配项 <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Match.NextMatch%2A> 。 还可以通过调用方法来检索单个方法调用中的所有匹配项 <xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)?displayProperty=nameWithType> 。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果匹配操作的执行时间超过为其调用该方法的应用程序域指定的超时间隔，则会引发异常。 如果在应用程序域的属性中没有定义超时，或者超时值为 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ，则不会引发异常。  
  
   
  
## Examples  
 下面的示例定义一个正则表达式，该正则表达式匹配以字母 "a" 开头的单词。 它使用 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 选项来确保正则表达式查找以大写 "a" 和小写 "a" 开头的单词。  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match2.vb" id="Snippet2":::
  
 正则表达式模式 `\ba\w*\b` 的含义如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|在单词边界处开始匹配。|  
|`a`|匹配 "a" 字符。|  
|`\w*`|匹配零个、一个或多个单词字符。|  
|`\b`|在单词边界处结束匹配。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效按位组合。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <block subset="none" type="usage"><para>此方法在与调用该方法的应用程序域的默认超时值相等的时间间隔后超时。 如果尚未为应用程序域定义超时值，则将 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> 使用该值来阻止方法超时。 用于检索模式匹配项的建议静态方法是 <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" /> ，它允许您设置超时间隔。</para></block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言 - 快速参考</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="options">枚举值的一个按位组合，这些枚举值提供匹配选项。</param>
        <param name="matchTimeout">超时间隔；若要指示该方法不应超时，则为 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</param>
        <summary>使用指定的匹配选项和超时间隔在输入字符串中搜索指定的正则表达式的第一个匹配项。</summary>
        <returns>一个包含有关匹配的信息的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)>方法返回输入字符串中与正则表达式模式匹配的第一个子字符串。 有关用于生成正则表达式模式的语言元素的信息，请参阅 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)。  
  
 静态 <xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)> 方法等效于 <xref:System.Text.RegularExpressions.Regex> 使用 <xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)> 构造函数构造对象和调用实例 <xref:System.Text.RegularExpressions.Regex.Match(System.String)> 方法。  
  
 `pattern`参数包含符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅 [.NET Framework 正则表达式](/dotnet/standard/base-types/regular-expressions) 和 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)。  
  
 您可以通过检查返回对象的属性的值来确定是否在输入字符串中找到了正则表达式模式 <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Group.Success%2A> 。 如果找到匹配项，则返回的 <xref:System.Text.RegularExpressions.Match> 对象的 <xref:System.Text.RegularExpressions.Capture.Value%2A> 属性包含与 `input` 正则表达式模式匹配的子字符串。 如果未找到匹配项，则其值为 <xref:System.String.Empty?displayProperty=nameWithType> 。  
  
 此方法返回中找到 `input` 的与正则表达式模式匹配的第一个子字符串。 您可以通过重复调用返回对象的方法来检索后续匹配项 <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Match.NextMatch%2A> 。 还可以通过调用方法来检索单个方法调用中的所有匹配项 <xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)?displayProperty=nameWithType> 。  
  
 `matchTimeout`参数指定模式匹配方法在超时之前应尝试找到匹配项的时间长度。设置超时间隔可防止正则表达式在处理包含接近匹配项的输入时，这些表达式会出现依赖于过量回溯的正则表达式停止响应。 有关详细信息，请参阅[正则表达式和回溯的最佳实践](/dotnet/standard/base-types/best-practices)。 [](/dotnet/standard/base-types/backtracking-in-regular-expressions) 如果在该时间间隔内未找到匹配项，则该方法将引发 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 异常。 `matchTimeout` 重写为在其中执行该方法的应用程序域定义的任何默认超时值。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效按位组合。  
  
- 或 - 
 <paramref name="matchTimeout" /> 为负、零或大于 24 天左右。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <block subset="none" type="usage"><para>建议将 <paramref name="matchTimeout" /> 参数设置为适当的值，例如两秒钟。 如果通过指定禁用超时 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> ，则正则表达式引擎可提供略微更好的性能。 但是，只应在以下条件下禁用超时： 
-正则表达式处理的输入派生自已知的和受信任的源，或由静态文本组成。 这不包括用户动态输入的文本。  
  
-对正则表达式模式进行了全面测试，以确保它有效地处理匹配、不匹配和接近匹配项。  
  
-当正则表达式模式不包含已知的语言元素时，这些元素会导致在处理接近的匹配时导致过度回溯。</para></block>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言 - 快速参考</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Matches">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在输入字符串中搜索正则表达式的所有匹配项并返回所有匹配。</summary>
        <block subset="none" type="usage"><para>当通过调用方法重复匹配尝试时 <see cref="Overload:System.Text.RegularExpressions.Regex.Matches" /> ，正则表达式引擎将提供空匹配特殊处理。 通常，正则表达式引擎会开始搜索下一个匹配项的精确位置。 但是，在空匹配项后，正则表达式引擎在尝试下一个匹配项之前前进一个字符。 此行为可确保正则表达式引擎将通过字符串进行。 否则，由于空匹配不会导致任何向前移动，因此下一个匹配项将与上一个匹配项完全相同的位置开始，并且它将重复匹配相同的空字符串。  
  
在下面的示例中，正则表达式模式 <c>a *</c> 在字符串 "abaabb" 中搜索字母 "a" 的零个或多个匹配项。 如示例的输出所示，生成的 <see cref="T:System.Text.RegularExpressions.MatchCollection" /> 对象包含六个 <see cref="T:System.Text.RegularExpressions.Match" /> 对象。 第一个匹配尝试查找第一个 "a"。 第二个匹配从第一个匹配结束的位置开始，在第一个 b 之前开始;它查找 "a" 的零次，并返回一个空字符串。 第三个匹配项并不完全从第二个匹配项结束的位置开始，因为第二个匹配项返回空字符串。 相反，它会在后面的第一个 "b" 后开始一个字符。 第三个匹配项查找 "a" 的两个匹配项，并返回 "aa"。 第四个匹配尝试从第三个匹配项的第二个匹配项的第二个 "b" 之前开始，并返回一个空字符串。 第五次匹配尝试再次推进一个字符，以使其在第三个 "b" 之前开始，并返回一个空字符串。 第六个匹配项的开头为 "b"，并再次返回空字符串。  
  
[！ code-csharp[system.text.regularexpressions # 9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/emptymatches1.cs#9)][！ code-vb[system.text.regularexpressions # 9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/emptymatches1.vb#9)]</para></block>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言 - 快速参考</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Matches : string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <summary>在指定的输入字符串中搜索正则表达式的所有匹配项。</summary>
        <returns>搜索操作找到的 <see cref="T:System.Text.RegularExpressions.Match" /> 对象的集合。 如果未找到匹配项，则此方法将返回一个空集合对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches(System.String)>方法与 <xref:System.Text.RegularExpressions.Regex.Match(System.String)> 方法类似，不同之处在于，它返回在输入字符串中找到的所有匹配项的相关信息，而不是一个匹配项。 它等效于以下代码：  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#5)]  
  
 集合仅包含匹配项，并且在第一个不匹配时终止。  
  
 方法搜索的正则表达式模式 <xref:System.Text.RegularExpressions.Regex.Matches(System.String)> 由对一个 <xref:System.Text.RegularExpressions.Regex> 类构造函数的调用定义。 有关可形成正则表达式模式的元素的详细信息，请参阅 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)。  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A>方法使用延迟计算来填充返回的 <xref:System.Text.RegularExpressions.MatchCollection> 对象。 访问此集合的成员（如 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 和）将 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> 导致立即填充该集合。 若要充分利用延迟计算，应使用构造（如 `foreach` c # 中的和 `For Each` ... `Next` in Visual Basic）来循环访问集合。  
  
 由于其延迟计算，调用方法不 <xref:System.Text.RegularExpressions.Regex.Matches(System.String)> 会引发 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 异常。 但是，如果在此方法返回的对象上执行操作时引发了异常，则为 <xref:System.Text.RegularExpressions.MatchCollection> ; 如果 <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> 属性不为 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ，并且匹配操作超过超时间隔，则会引发异常。  
  
   
  
## Examples  
 下面的示例使用 <xref:System.Text.RegularExpressions.Regex.Matches(System.String)> 方法来识别句子中以 "es" 结尾的所有单词。  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches1.vb" id="Snippet1"::: 
  
 正则表达式模式 `\b\w+es\b` 的定义如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|在单词边界处开始匹配。|  
|`\w+`|匹配一个或多个单词字符。|  
|`es`|匹配文本字符串 "es"。|  
|`\b`|在单词边界处结束匹配。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String, startat As Integer) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Matches : string * int -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="startat">在输入字符串中开始搜索的字符位置。</param>
        <summary>从字符串中的指定起始位置开始，在指定的输入字符串中搜索正则表达式的所有匹配项。</summary>
        <returns>搜索操作找到的 <see cref="T:System.Text.RegularExpressions.Match" /> 对象的集合。 如果未找到匹配项，则此方法将返回一个空集合对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)>方法与 <xref:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)> 方法类似，不同之处在于，它返回在输入字符串中找到的所有匹配项的相关信息，而不是一个匹配项。 它等效于以下代码：  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#6)]  
  
 方法搜索的正则表达式模式 <xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)> 由对一个 <xref:System.Text.RegularExpressions.Regex> 类构造函数的调用定义。 有关可形成正则表达式模式的元素的详细信息，请参阅 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)。  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A>方法使用延迟计算来填充返回的 <xref:System.Text.RegularExpressions.MatchCollection> 对象。 访问此集合的成员（如 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 和）将 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> 导致立即填充该集合。 若要充分利用延迟计算，应使用构造（如 `foreach` c # 中的和 `For Each` ... `Next` in Visual Basic）来循环访问集合。  
  
 由于其延迟计算，调用方法不 <xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)> 会引发 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 异常。 但是，如果在此方法返回的对象上执行操作时引发了异常，则为 <xref:System.Text.RegularExpressions.MatchCollection> ; 如果 <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> 属性不为 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ，并且匹配操作超过超时间隔，则会引发异常。 
  
   
  
## Examples  
 下面的示例使用 <xref:System.Text.RegularExpressions.Regex.Match(System.String)> 方法来查找句子中以 "es" 结尾的第一个单词，然后调用 <xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)> 方法以识别以 "es" 结尾的任何其他单词。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches3.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches3.vb" id="Snippet3"::: 
  
 正则表达式模式 `\b\w+es\b` 的定义如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|在单词边界处开始匹配。|  
|`\w+`|匹配一个或多个单词字符。|  
|`es`|匹配文本字符串 "es"。|  
|`\b`|在单词边界处结束匹配。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> 小于零或大于 <paramref name="input" /> 的长度。</exception>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <summary>在指定的输入字符串中搜索指定的正则表达式的所有匹配项。</summary>
        <returns>搜索操作找到的 <see cref="T:System.Text.RegularExpressions.Match" /> 对象的集合。 如果未找到匹配项，则此方法将返回一个空集合对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)>方法与 <xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String)> 方法类似，不同之处在于，它返回在输入字符串中找到的所有匹配项的相关信息，而不是一个匹配项。 它等效于以下代码：  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#7)]  
  
 静态 `Matches` 方法等效于 <xref:System.Text.RegularExpressions.Regex> 使用指定的正则表达式模式构造对象并调用实例方法 `Matches` 。  
  
 `pattern`参数包含符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅 [.NET Framework 正则表达式](/dotnet/standard/base-types/regular-expressions) 和 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)。  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A>方法使用延迟计算来填充返回的 <xref:System.Text.RegularExpressions.MatchCollection> 对象。 访问此集合的成员（如 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 和）将 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> 导致立即填充该集合。 若要充分利用延迟计算，应使用构造（如 `foreach` c # 中的和 `For Each` ... `Next` in Visual Basic）来循环访问集合。  
  
 由于其延迟计算，调用方法不 <xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)> 会引发 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 异常。 但是， <xref:System.Text.RegularExpressions.MatchCollection> 如果在当前应用程序域的 "REGEX_DEFAULT_MATCH_TIMEOUT" 属性定义了超时间隔并且匹配操作超过此超时间隔，则在此方法返回的对象上执行操作时将引发异常。  
  
   
  
## Examples  
 下面的示例使用 <xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)> 方法标识句子中以 "es" 结尾的任何单词。  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches2.vb" id="Snippet2"::: 
  
 正则表达式模式 `\b\w+es\b` 的定义如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|在单词边界处开始匹配。|  
|`\w+`|匹配一个或多个单词字符。|  
|`es`|匹配文本字符串 "es"。|  
|`\b`|在单词边界处结束匹配。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>此方法在与调用该方法的应用程序域的默认超时值相等的时间间隔后超时。 如果尚未为应用程序域定义超时值，则将 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> 使用该值来阻止方法超时。 用于检索多个模式匹配项的建议静态方法为 <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /> ，可让你指定超时间隔。</para></block>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="options">枚举值的按位组合，这些枚举值指定用于匹配的选项。</param>
        <summary>使用指定的匹配选项在指定的输入字符串中搜索指定的正则表达式的所有匹配项。</summary>
        <returns>搜索操作找到的 <see cref="T:System.Text.RegularExpressions.Match" /> 对象的集合。 如果未找到匹配项，则此方法将返回一个空集合对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)>方法与 <xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)> 方法类似，不同之处在于，它返回在输入字符串中找到的所有匹配项的相关信息，而不是一个匹配项。 它等效于以下代码：  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#8)]  
  
 静态 `Matches` 方法等效于 <xref:System.Text.RegularExpressions.Regex> 使用指定的正则表达式模式构造对象并调用实例方法 `Matches` 。  
  
 `pattern`参数包含符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅 [.NET Framework 正则表达式](/dotnet/standard/base-types/regular-expressions) 和 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)。  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A>方法使用延迟计算来填充返回的 <xref:System.Text.RegularExpressions.MatchCollection> 对象。 访问此集合的成员（如 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 和）将 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> 导致立即填充该集合。 若要充分利用延迟计算，应使用构造（如 `foreach` c # 中的和 `For Each` ... `Next` in Visual Basic）来循环访问集合。  
  
 由于其延迟计算，调用方法不 <xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)> 会引发 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 异常。 但是， <xref:System.Text.RegularExpressions.MatchCollection> 如果在当前应用程序域的 "REGEX_DEFAULT_MATCH_TIMEOUT" 属性定义了超时间隔并且匹配操作超过此超时间隔，则在此方法返回的对象上执行操作时将引发异常。  
  
   
  
## Examples  
 下面的示例调用 <xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)> 方法来标识句子中以 "es" 结尾的任何单词，然后调用 <xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)> 方法以使用输入字符串执行不区分大小写的模式比较。 如输出所示，这两个方法返回不同的结果。  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches4.cs" interactive="try-dotnet" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches4.vb" id="Snippet4":::
  
 正则表达式模式 `\b\w+es\b` 的定义如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|在单词边界处开始匹配。|  
|`\w+`|匹配一个或多个单词字符。|  
|`es`|匹配文本字符串 "es"。|  
|`\b`|在单词边界处结束匹配。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效按位组合。</exception>
        <block subset="none" type="usage"><para>此方法在与调用该方法的应用程序域的默认超时值相等的时间间隔后超时。 如果尚未为应用程序域定义超时值，则将 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> 使用该值来阻止方法超时。 用于检索多个模式匹配项的建议静态方法是 <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /> ，它允许您设置超时间隔。</para></block>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="options">枚举值的按位组合，这些枚举值指定用于匹配的选项。</param>
        <param name="matchTimeout">超时间隔；若要指示该方法不应超时，则为 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</param>
        <summary>使用指定的匹配选项和超时间隔在指定的输入字符串中搜索指定的正则表达式的所有匹配项。</summary>
        <returns>搜索操作找到的 <see cref="T:System.Text.RegularExpressions.Match" /> 对象的集合。 如果未找到匹配项，则此方法将返回一个空集合对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)>方法与 <xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)> 方法类似，不同之处在于，它返回在输入字符串中找到的所有匹配项的相关信息，而不是一个匹配项。 它等效于以下代码：  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#10)]  
  
 静态 `Matches` 方法等效于 <xref:System.Text.RegularExpressions.Regex> 使用指定的正则表达式模式构造对象并调用实例方法 `Matches` 。  
  
 `pattern`参数包含符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅 [.NET Framework 正则表达式](/dotnet/standard/base-types/regular-expressions) 和 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)。  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A>方法使用延迟计算来填充返回的 <xref:System.Text.RegularExpressions.MatchCollection> 对象。 访问此集合的成员（如 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 和）将 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> 导致立即填充该集合。 若要充分利用延迟计算，应使用构造（如 `foreach` c # 中的和 `For Each` ... `Next` in Visual Basic）来循环访问集合。  
  
 由于其延迟计算，调用方法不 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 会引发 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 异常。 但是， <xref:System.Text.RegularExpressions.MatchCollection> 如果匹配操作超过参数所指定的超时间隔，则在此方法返回的对象上执行操作时，将引发异常 `matchTimeout` 。  
  
   
  
## Examples  
 下面的示例调用 <xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)> 方法来执行区分大小写的比较，匹配以 "es" 结尾的句子中的任何单词。 然后，它调用 <xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)> 方法，以使用输入字符串执行不区分大小写的模式比较。 在这两种情况下，超时间隔设置为1秒。 如输出所示，这两个方法返回不同的结果。  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches5.cs" interactive="try-dotnet" id="Snippet11":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches5.vb" id="Snippet11":::
  
 正则表达式模式 `\b\w+es\b` 的定义如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|在单词边界处开始匹配。|  
|`\w+`|匹配一个或多个单词字符。|  
|`es`|匹配文本字符串 "es"。|  
|`\b`|在单词边界处结束匹配。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效按位组合。  
  
- 或 - 
 <paramref name="matchTimeout" /> 为负、零或大于 24 天左右。</exception>
        <block subset="none" type="usage"><para>建议将 <paramref name="matchTimeout" /> 参数设置为适当的值，例如两秒钟。 如果通过指定禁用超时 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> ，则正则表达式引擎可提供略微更好的性能。 但是，只应在以下条件下禁用超时： 
-正则表达式处理的输入派生自已知的和受信任的源，或由静态文本组成。 这不包括用户动态输入的文本。  
  
-对正则表达式模式进行了全面测试，以确保它有效地处理匹配、不匹配和接近匹配项。  
  
-当正则表达式模式不包含已知的语言元素时，这些元素会导致在处理接近的匹配时导致过度回溯。</para></block>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="MatchTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan MatchTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MatchTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MatchTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MatchTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前实例的超时间隔。</summary>
        <value>在 <see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" /> 引发之前或如果时间超期被禁用 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> ，在样式匹配操作符中可以经过的最长时间间隔。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A>属性定义 <xref:System.Text.RegularExpressions.Regex> 实例在操作超时前执行单个匹配操作的近似最大时间间隔。在超时间隔结束后，正则表达式引擎将 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 在其下一次计时检查期间引发异常。 这可以防止正则表达式引擎处理需要过多回溯的输入字符串。 有关详细信息，请[](/dotnet/standard/base-types/backtracking-in-regular-expressions)参阅[正则表达式的回溯和最佳实践](/dotnet/standard/base-types/best-practices)。  
  
 此属性为只读。 您可以通过调用构造函数为单个对象显式设置其值，也 <xref:System.Text.RegularExpressions.Regex> <xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)?displayProperty=nameWithType> 可以 <xref:System.Text.RegularExpressions.Regex> 通过调用方法并提供 "REGEX_DEFAULT_MATCH_TIMEOUT" 属性的值，为应用程序域中的所有匹配操作设置其值 <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> <xref:System.TimeSpan> ，如下面的示例所示。  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/cs/regexmatchtimeout1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/vb/regexmatchtimeout1.vb" id="Snippet1":::
  
 如果未显式设置超时间隔，则使用默认值 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ，并且匹配操作不会超时。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.RegexOptions Options { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.RegularExpressions.RegexOptions Options" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Options" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Options As RegexOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::RegularExpressions::RegexOptions Options { System::Text::RegularExpressions::RegexOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.Options : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.Options" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取传递给 <see cref="T:System.Text.RegularExpressions.Regex" /> 构造函数的选项。</summary>
        <value><see cref="T:System.Text.RegularExpressions.RegexOptions" /> 枚举 的一个或多个成员表示传递至 <see cref="T:System.Text.RegularExpressions.Regex" /> 构造函数的选项。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性的值 <xref:System.Text.RegularExpressions.Regex.Options%2A> 由一个或多个枚举成员组成 <xref:System.Text.RegularExpressions.RegexOptions> 。 如果类构造函数中未定义任何选项 <xref:System.Text.RegularExpressions.Regex> ，则其值为 <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> 。 [正则表达式选项](/dotnet/standard/base-types/regular-expression-options)主题中详细讨论了可用选项。  
  
 请注意，该 <xref:System.Text.RegularExpressions.Regex.Options%2A> 属性不反映正则表达式模式本身中定义的内联选项。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> 方法创建的正则表达式的基类 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 。 这些已编译的正则表达式使用属性的基类实现 <see cref="P:System.Text.RegularExpressions.Regex.Options" /> 。 如果是从派生类调用的，则 <see cref="P:System.Text.RegularExpressions.Regex.Options" /> 属性返回传递给 <paramref name="options" /> <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> 用于定义正则表达式的类构造函数的参数的选项。</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-options">正则表达式选项</related>
      </Docs>
    </Member>
    <Member MemberName="pattern">
      <MemberSignature Language="C#" Value="protected internal string? pattern;" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string pattern" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.pattern" />
      <MemberSignature Language="VB.NET" Value="Protected Friend pattern As String " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::String ^ pattern;" />
      <MemberSignature Language="F#" Value="val mutable pattern : string" Usage="System.Text.RegularExpressions.Regex.pattern" />
      <MemberSignature Language="C#" Value="protected internal string pattern;" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法生成的 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在指定的输入字符串内，使用指定的替换字符串替换与某个正则表达式模式匹配的字符串。</summary>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言 - 快速参考</related>
        <related type="Article" href="/dotnet/standard/base-types/substitutions-in-regular-expressions">正则表达式中的替代</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="regex.Replace (input, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="replacement">替换字符串。</param>
        <summary>在指定的输入字符串内，使用指定的替换字符串替换与某个正则表达式模式匹配的所有的字符串。</summary>
        <returns>一个与输入字符串基本相同的新字符串，唯一的差别在于，其中的每个匹配字符串已被替换字符串代替。 如果正则表达式模式与当前实例不匹配，则此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜索匹配项从字符串的开头开始 `input` 。 正则表达式是由当前对象的构造函数定义的模式 <xref:System.Text.RegularExpressions.Regex> 。  
  
 `replacement`参数指定要在其中替换每个匹配项的字符串 `input` 。 `replacement` 可以包含文字文本和 [替换](/dotnet/standard/base-types/substitutions-in-regular-expressions)的任意组合。 例如，替换模式 `a*${test}b` 插入字符串 "a *"，后面跟有捕获组匹配的子字符串 `test` （如果有），后跟字符串 "b"。 在替换模式中不将 * 字符识别为元字符。  
  
> [!NOTE]
>  替换是替换模式中唯一识别的正则表达式语言元素。 所有其他正则表达式语言元素（包括 [字符转义](/dotnet/standard/base-types/character-escapes-in-regular-expressions)）仅在正则表达式模式中允许，在替换模式下不能识别。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果替换操作的执行时间超过了构造函数指定的超时间隔，则会引发异常 <xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)?displayProperty=nameWithType> 。 如果在调用构造函数时未设置超时间隔，则当操作超过在其中创建对象的应用程序域的任何超时值时，将引发异常 <xref:System.Text.RegularExpressions.Regex> 。 如果在 <xref:System.Text.RegularExpressions.Regex> 构造函数调用或应用程序域的属性中没有定义超时，或者超时值为 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ，则不会引发异常  
  
 因为如果没有匹配项，则此方法返回 `input` 不变，你可以使用 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 方法来确定该方法是否已对输入字符串进行任何替换。  
  
   
  
## Examples  
 下面的示例定义了 `\s+` 一个与一个或多个空白字符匹配的正则表达式。 替换字符串 "" 会将它们替换为单个空格字符。  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample5.cs" interactive="try-dotnet" id="Snippet5":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample5.vb" id="Snippet5":::
  
 下面的示例定义了一个正则表达式， `(\p{Sc}\s?)?(\d+\.?((?<=\.)\d+)?)(?(1)|\s?\p{Sc})?` 以及一个 `$2` 从数值中删除前导或尾随货币符号的替换模式。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample7.cs" interactive="try-dotnet" id="Snippet7":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample7.vb" id="Snippet7"::: 
  
 正则表达式模式可以解释为下表中所示内容。  
  
|模式|说明|  
|-------------|-----------------|  
|`\p{Sc}`|匹配货币符号。 `{Sc}` 表示作为 Unicode 符号、货币类别的成员的任何字符。|  
|`\s?`|匹配零个或一个空白字符。|  
|`(\p{Sc}\s?)?`|匹配后跟零个或一个空白字符的货币符号组合的零个或一个匹配项。 这是第一个捕获组。|  
|`\d+`|匹配一个或多个十进制数字。|  
|`\.?`|将一个句点的零个或一个匹配项 (用作小数点分隔符) 。|  
|`((?<=\.)\d+)?`|如果句点是前一个字符，则匹配一个或多个十进制数字。 此模式可以匹配零次或一次。|  
|`(\d+\.?((?<=\.)\d+)?)`|匹配一个或多个十进制数字的模式，后跟可选的句点和其他十进制数字。 这是第二个捕获组。 调用 <xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)> 方法会将整个匹配替换为此捕获组的值。|  
|<code>(?(1)&#124;\s?\p{Sc})?</code>|如果第一个捕获组存在，则匹配空字符串。 否则，匹配后跟货币符号的零个或一个空白字符。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="replacement" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言 - 快速参考</related>
        <related type="Article" href="/dotnet/standard/base-types/substitutions-in-regular-expressions">正则表达式中的替代</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="regex.Replace (input, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="evaluator">一个自定义方法，该方法检查每个匹配项，然后返回原始的匹配字符串或替换字符串。</param>
        <summary>在指定的输入字符串中，使用由 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委托返回的字符串替换与指定的正则表达式匹配的所有字符串。</summary>
        <returns>一个与输入字符串基本相同的新字符串，唯一的差别在于，其中的每个匹配字符串已被一个替换字符串代替。 如果正则表达式模式与当前实例不匹配，则此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)?displayProperty=nameWithType>如果满足以下任一条件，则方法可用于替换正则表达式匹配：  
  
-   正则表达式替换模式无法轻易指定替换字符串。  
  
-   替换字符串是对匹配的字符串执行的一些处理导致的。  
  
-   从条件处理中得到的替换字符串。  
  
 方法等效于调用 <xref:System.Text.RegularExpressions.Regex.Matches(System.String)?displayProperty=nameWithType> 方法并 <xref:System.Text.RegularExpressions.Match> 将返回集合中的每个对象传递 <xref:System.Text.RegularExpressions.MatchCollection> 给 `evaluator` 委托。  
  
 正则表达式是由当前对象的构造函数定义的模式 <xref:System.Text.RegularExpressions.Regex> 。  
  
 `evaluator`参数是你定义的用于检查每个匹配项的自定义方法的委托。 自定义方法必须具有以下签名才能匹配 <xref:System.Text.RegularExpressions.MatchEvaluator> 委托。  
 
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
   
 自定义方法返回替换匹配输入的字符串。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果替换操作的执行时间超过了构造函数指定的超时间隔，则会引发异常 <xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)?displayProperty=nameWithType> 。 如果在调用构造函数时未设置超时间隔，则当操作超过在其中创建对象的应用程序域的任何超时值时，将引发异常 <xref:System.Text.RegularExpressions.Regex> 。 如果在 <xref:System.Text.RegularExpressions.Regex> 构造函数调用或应用程序域的属性中没有定义超时，或者超时值为 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ，则不会引发异常  
  
 因为如果没有匹配项，则此方法返回 `input` 不变，你可以使用 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 方法来确定该方法是否已对输入字符串进行任何替换。  
  
   
  
## Examples  
 下面的代码示例将显示原始字符串中的每个单词，并将每个匹配项的第一个字符转换为大写，然后显示转换后的字符串。  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Regex.Replace-Instance/cs/sample.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex.Replace-Instance/vb/sample.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="evaluator" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="/dotnet/standard/base-types/substitutions-in-regular-expressions">正则表达式中的替代</related>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言 - 快速参考</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int -&gt; string" Usage="regex.Replace (input, replacement, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="replacement">替换字符串。</param>
        <param name="count">可进行替换的最大次数。</param>
        <summary>在指定输入字符串内，使用指定替换字符串替换与某个正则表达式模式匹配的字符串（其数目为指定的最大数目）。</summary>
        <returns>一个与输入字符串基本相同的新字符串，唯一的差别在于，其中的每个匹配字符串已被替换字符串代替。 如果正则表达式模式与当前实例不匹配，则此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜索匹配项从字符串的开头开始 `input` 。 正则表达式是由当前对象的构造函数定义的模式 <xref:System.Text.RegularExpressions.Regex> 。 如果 `count` 为负，则替换将继续到字符串的末尾。 如果 `count` 超过匹配项的数目，则将替换所有匹配项。  
  
 `replacement`参数指定要替换中第一个匹配项的字符串 `count` `input` 。 `replacement` 可以包含文字文本和 [替换](/dotnet/standard/base-types/substitutions-in-regular-expressions)的任意组合。 例如，替换模式 `a*${test}b` 插入字符串 "a *"，后面跟有捕获组匹配的子字符串 `test` （如果有），后跟字符串 "b"。 在替换模式中不将 * 字符识别为元字符。  
  
> [!NOTE]
>  替换是替换模式中唯一识别的正则表达式语言元素。 所有其他正则表达式语言元素（包括 [字符转义](/dotnet/standard/base-types/character-escapes-in-regular-expressions)）仅在正则表达式模式中允许，在替换模式下不能识别。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果替换操作的执行时间超过了构造函数指定的超时间隔，则会引发异常 <xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)?displayProperty=nameWithType> 。 如果在调用构造函数时未设置超时间隔，则当操作超过在其中创建对象的应用程序域的任何超时值时，将引发异常 <xref:System.Text.RegularExpressions.Regex> 。 如果在 <xref:System.Text.RegularExpressions.Regex> 构造函数调用或应用程序域的属性中没有定义超时，或者超时值为 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ，则不会引发异常  
  
 因为如果没有匹配项，则此方法返回 `input` 不变，你可以使用 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 方法来确定该方法是否已对输入字符串进行任何替换。  
  
   
  
## Examples  
 下面的示例将重复字符的前五个匹配项替换为单个字符。 正则表达式模式 `(\w)\1` 匹配单个字符连续出现的次数，并将第一个匹配项赋给第一个捕获组。 替换模式会 `$1` 将整个匹配项替换为第一个捕获的组。  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample8.cs" interactive="try-dotnet" id="Snippet8":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample8.vb" id="Snippet8":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="replacement" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言 - 快速参考</related>
        <related type="Article" href="/dotnet/standard/base-types/substitutions-in-regular-expressions">正则表达式中的替代</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="replacement">替换字符串。</param>
        <summary>在指定的输入字符串内，使用指定的替换字符串替换与指定正则表达式匹配的所有字符串。</summary>
        <returns>一个与输入字符串基本相同的新字符串，唯一的差别在于，其中的每个匹配字符串已被替换字符串代替。 如果 <paramref name="pattern" /> 与当前实例不匹配，则此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 静态 `Replace` 方法等效于 <xref:System.Text.RegularExpressions.Regex> 使用指定的正则表达式模式构造对象并调用实例方法 `Replace` 。  
  
 `pattern`参数包含符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅 [.NET Framework 正则表达式](/dotnet/standard/base-types/regular-expressions) 和 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)。 搜索匹配项从字符串的开头开始 `input` 。  
  
 `replacement`参数指定要在其中替换每个匹配项的字符串 `input` 。 `replacement` 可以包含文字文本和 [替换](/dotnet/standard/base-types/substitutions-in-regular-expressions)的任意组合。 例如，替换模式 `a*${test}b` 插入字符串 "a *"，后面跟有捕获组匹配的子字符串 `test` （如果有），后跟字符串 "b"。 在替换模式中不将 * 字符识别为元字符。  
  
> [!NOTE]
>  替换是替换模式中唯一识别的正则表达式语言元素。 所有其他正则表达式语言元素（包括 [字符转义](/dotnet/standard/base-types/character-escapes-in-regular-expressions)）仅在正则表达式模式中允许，在替换模式下不能识别。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果替换操作的执行时间超过为其调用该方法的应用程序域指定的超时间隔，则会引发异常。 如果在应用程序域的属性中没有定义超时，或者超时值为 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ，则不会引发异常。  
  
 因为如果没有匹配项，则此方法返回 `input` 不变，你可以使用 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 方法来确定该方法是否已对输入字符串进行任何替换。  
  
   
  
## Examples  
 下面的示例定义了 `\s+` 一个与一个或多个空白字符匹配的正则表达式。 替换字符串 "" 会将它们替换为单个空格字符。  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample6.cs" interactive="try-dotnet" id="Snippet6":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample6.vb" id="Snippet6"::: 
  
 下面的示例使用 <xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)> 方法将 UNC 路径中的本地计算机和驱动器名称替换为本地文件路径。 正则表达式使用 <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> 属性包含本地计算机的名称，并使用 <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> 方法来包含逻辑驱动器的名称。 若要成功运行此示例，应将文本字符串 "MyMachine" 替换为本地计算机名称。  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace3.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace3.vb" id="Snippet3":::
  
 正则表达式模式由以下表达式定义：  
  
 `"\\\\(?i:" + Environment.MachineName + ")(?:\.\w+)*\\((?i:[" + driveNames + "]))\$"`  
  
 下表演示了如何解释正则表达式模式。  
  
|模式|说明|  
|-------------|-----------------|  
|`\\\\`|匹配两个连续的反斜杠 (`\`) 字符。 因为反斜杠字符被解释为转义字符，所以每个反斜杠都必须用另一个反斜杠进行转义。|  
|`(?i:" + Environment.MachineName + ")`|执行属性返回的字符串的不区分大小写的匹配项 <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> 。|  
|`(?:\.\w+)*`|匹配句点 (`.`) 字符后跟一个或多个单词字符。 此匹配可以出现零次或多次。 不捕获匹配的子表达式。|  
|`\\`|匹配反斜杠 (`\`) 字符。|  
|`((?i:[" + driveNames + "]))`|执行由单个驱动器号组成的字符类的不区分大小写的匹配项。 此匹配是第一个捕获的子表达式。|  
|`\$`|匹配文本美元符号 (`$`) 字符。|  
  
 替换模式将 `$1` 整个匹配项替换为第一个捕获的子表达式。 也就是说，它将 UNC 计算机和驱动器名称替换为驱动器号。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />、<paramref name="pattern" /> 或 <paramref name="replacement" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <block subset="none" type="usage"><para>此方法在与调用该方法的应用程序域的默认超时值相等的时间间隔后超时。 如果尚未为应用程序域定义超时值，则将 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> 使用该值来阻止方法超时。 建议用于替换模式匹配的静态方法是 <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /> ，这使你可以设置超时间隔。</para></block>
        <related type="Article" href="/dotnet/standard/base-types/substitutions-in-regular-expressions">正则表达式中的替代</related>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="evaluator">一个自定义方法，该方法检查每个匹配项，然后返回原始的匹配字符串或替换字符串。</param>
        <summary>在指定的输入字符串中，使用由 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委托返回的字符串替换与指定的正则表达式匹配的所有字符串。</summary>
        <returns>一个与输入字符串基本相同的新字符串，唯一的差别在于，其中的每个匹配字符串已被一个替换字符串代替。 如果 <paramref name="pattern" /> 与当前实例不匹配，则此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)?displayProperty=nameWithType>如果满足以下任一条件，则方法可用于替换正则表达式匹配：  
  
-   正则表达式替换模式无法轻易指定替换字符串。  
  
-   替换字符串是对匹配的字符串执行的一些处理导致的。  
  
-   从条件处理中得到的替换字符串。  
  
 方法等效于调用 <xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)?displayProperty=nameWithType> 方法并 <xref:System.Text.RegularExpressions.Match> 将返回集合中的每个对象传递 <xref:System.Text.RegularExpressions.MatchCollection> 给 `evaluator` 委托。  
  
 `pattern`参数包含符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅 [.NET Framework 正则表达式](/dotnet/standard/base-types/regular-expressions) 和 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)。  
  
 `evaluator`参数是你定义的用于检查每个匹配项的自定义方法的委托。 自定义方法必须具有以下签名才能匹配 <xref:System.Text.RegularExpressions.MatchEvaluator> 委托。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 自定义方法返回替换匹配输入的字符串。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果替换操作的执行时间超过为其调用该方法的应用程序域指定的超时间隔，则会引发异常。 如果在应用程序域的属性中没有定义超时，或者超时值为 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ，则不会引发异常。  
  
 因为如果没有匹配项，则此方法返回 `input` 不变，你可以使用 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 方法来确定该方法是否已对输入字符串进行任何替换。  
  
   
  
## Examples  
 下面的示例使用正则表达式从字符串中提取各个单词，然后使用 <xref:System.Text.RegularExpressions.MatchEvaluator> 委托调用一个名为 `WordScramble` 的方法，该方法对单词中的各个字母进行编码。 为此， `WordScramble` 方法会创建一个包含匹配项中的字符的数组。 它还会创建一个并行数组，该数组使用随机浮点数填充。 通过调用方法对数组进行排序 <xref:System.Array.Sort%60%602(%60%600%5B%5D,%60%601%5B%5D,System.Collections.Generic.IComparer%7B%60%600%7D)?displayProperty=nameWithType> ，并将排序的数组作为参数提供给 <xref:System.String> 类构造函数。 然后，该方法将返回这个新创建的字符串 `WordScramble` 。 正则表达式模式 `\w+` 匹配一个或多个单词字符; 正则表达式引擎将继续向匹配项添加字符，直到遇到非单词字符，例如空白字符。  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace5.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace5.vb" id="Snippet2":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />、<paramref name="pattern" /> 或 <paramref name="evaluator" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <block subset="none" type="usage"><para>此方法在与调用该方法的应用程序域的默认超时值相等的时间间隔后超时。 如果尚未为应用程序域定义超时值，则将 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> 使用该值来阻止方法超时。 用于计算和替换模式匹配的推荐静态方法是 <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /> ，这使你可以设置超时间隔。</para></block>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="/dotnet/standard/base-types/substitutions-in-regular-expressions">正则表达式中的替代</related>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int -&gt; string" Usage="regex.Replace (input, evaluator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="evaluator">一个自定义方法，该方法检查每个匹配项，然后返回原始的匹配字符串或替换字符串。</param>
        <param name="count">进行替换的最大次数。</param>
        <summary>在指定的输入字符串内，使用 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委托返回的字符串替换与某个正则表达式模式匹配的字符串（其数目为指定的最大数目）。</summary>
        <returns>一个与输入字符串基本相同的新字符串，唯一的差别在于，其中的每个匹配字符串已被一个替换字符串代替。 如果正则表达式模式与当前实例不匹配，则此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)?displayProperty=nameWithType>如果满足以下任一条件，则方法可用于替换正则表达式匹配：  
  
-   正则表达式替换模式无法轻易指定替换字符串。  
  
-   替换字符串是对匹配的字符串执行的一些处理导致的。  
  
-   从条件处理中得到的替换字符串。  
  
 方法等效于调用 <xref:System.Text.RegularExpressions.Regex.Matches(System.String)?displayProperty=nameWithType> 方法，并将 `count` <xref:System.Text.RegularExpressions.Match> 返回集合中的第一个对象传递 <xref:System.Text.RegularExpressions.MatchCollection> 到 `evaluator` 委托。  
  
 正则表达式是由当前对象的构造函数定义的模式 <xref:System.Text.RegularExpressions.Regex> 。  
  
 `evaluator`参数是你定义的用于检查每个匹配项的自定义方法的委托。 自定义方法必须具有以下签名才能匹配 <xref:System.Text.RegularExpressions.MatchEvaluator> 委托。  

 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
    
 自定义方法返回替换匹配输入的字符串。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果替换操作的执行时间超过了构造函数指定的超时间隔，则会引发异常 <xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)?displayProperty=nameWithType> 。 如果在调用构造函数时未设置超时间隔，则当操作超过在其中创建对象的应用程序域的任何超时值时，将引发异常 <xref:System.Text.RegularExpressions.Regex> 。 如果在 <xref:System.Text.RegularExpressions.Regex> 构造函数调用或应用程序域的属性中没有定义超时，或者超时值为 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ，则不会引发异常  
  
 因为如果没有匹配项，则此方法返回 `input` 不变，你可以使用 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 方法来确定该方法是否已对输入字符串进行任何替换。  
  
   
  
## Examples  
 下面的示例使用正则表达式来特意拼错列表中的半个单词。 它使用正则表达式 `\w*(ie|ei)\w*` 来匹配包含字符 "ie" 或 "ei" 的单词。 它将匹配单词的前半部分传递给 `ReverseLetter` 方法，该方法反过来使用 <xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)> 方法反转匹配字符串中的 "i" 和 "e"。 其余单词保持不变。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace7.cs" interactive="try-dotnet" id="Snippet11":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace7.vb" id="Snippet11":::  
  
 正则表达式 `\w*(ie|ei)\w*` 的定义如下表所示。  
  
|模式|说明|  
|-------------|-----------------|  
|`\w*`|匹配零个或多个单词字符。|  
|<code>(ie&#124;ei)</code>|匹配 "ie" 或 "ei"。|  
|`\w*`|匹配零个或多个单词字符。|  
  
 方法中的正则表达式模式 `([ie])([ie])` `ReverseLetter` 匹配 diphthong "ie" 或 "ei" 中的第一个 "i" 或 "e"，并将该字母分配给第一个捕获组。 它与第二个 "i" 或 "e" 匹配，并将该字母分配给第二个捕获组。 然后通过使用替换模式调用方法来反转两个字符 <xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)> `$2$1` 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="evaluator" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="/dotnet/standard/base-types/substitutions-in-regular-expressions">正则表达式中的替代</related>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言 - 快速参考</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; string" Usage="regex.Replace (input, replacement, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="replacement">替换字符串。</param>
        <param name="count">可进行替换的最大次数。</param>
        <param name="startat">输入字符串中开始执行搜索的字符位置。</param>
        <summary>在指定输入子字符串内，使用指定替换字符串替换与某个正则表达式模式匹配的字符串（其数目为指定的最大数目）。</summary>
        <returns>一个与输入字符串基本相同的新字符串，唯一的差别在于，其中的每个匹配字符串已被替换字符串代替。 如果正则表达式模式与当前实例不匹配，则此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜索匹配项从 `input` 参数指定的位置处的字符串开始 `startat` 。 正则表达式是由当前对象的构造函数定义的模式 <xref:System.Text.RegularExpressions.Regex> 。 如果 `count` 为负，则替换将继续到字符串的末尾。 如果 `count` 超过匹配项的数目，则将替换所有匹配项。  
  
 `replacement`参数指定要在其中替换每个匹配项的字符串 `input` 。 `replacement` 可以包含文字文本和 [替换](/dotnet/standard/base-types/substitutions-in-regular-expressions)的任意组合。 例如，替换模式 `a*${test}b` 插入字符串 "a *"，后面跟有捕获组匹配的子字符串 `test` （如果有），后跟字符串 "b"。 在替换模式中不将 * 字符识别为元字符。  
  
> [!NOTE]
>  替换是替换模式中唯一识别的正则表达式语言元素。 所有其他正则表达式语言元素（包括 [字符转义](/dotnet/standard/base-types/character-escapes-in-regular-expressions)）仅在正则表达式模式中允许，在替换模式下不能识别。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果替换操作的执行时间超过了构造函数指定的超时间隔，则会引发异常 <xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)?displayProperty=nameWithType> 。 如果在调用构造函数时未设置超时间隔，则当操作超过在其中创建对象的应用程序域的任何超时值时，将引发异常 <xref:System.Text.RegularExpressions.Regex> 。 如果在 <xref:System.Text.RegularExpressions.Regex> 构造函数调用或应用程序域的属性中没有定义超时，或者超时值为 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ，则不会引发异常  
  
 因为如果没有匹配项，则此方法返回 `input` 不变，你可以使用 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 方法来确定该方法是否已对输入字符串进行任何替换。  
  
   
  
## Examples  
 下面的示例在字符串的第一行之外的所有字符都是双空格。 它定义了与文本行匹配的正则表达式模式， `^.*$` 调用 <xref:System.Text.RegularExpressions.Regex.Match(System.String)> 方法与字符串的第一行匹配，并使用 `Match.Index` 和 `Match.Count` 属性来确定第二行的起始位置。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample9.cs" interactive="try-dotnet" id="Snippet9":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample9.vb" id="Snippet9"::: 
  
 正则表达式模式 `^.*$` 的定义如下表所示。  
  
|模式|说明|  
|-------------|-----------------|  
|`^`|匹配行的开头。  (请注意， <xref:System.Text.RegularExpressions.Regex> 对象已使用选项进行实例化 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> ; 否则，此字符类将仅匹配输入字符串的开头。 ) |  
|`.*`|零次或多次匹配任何字符。|  
|`$`|匹配行尾。  (请注意， <xref:System.Text.RegularExpressions.Regex> 对象已使用选项进行实例化 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> ; 否则，此字符类将仅匹配输入字符串的开头。 ) |  
  
 在 c # 中，替换字符串 (`vbCrLf + "$&"` 在 Visual Basic 中 `"\n$&"` ) 在匹配的字符串之前添加新行。 请注意， `\n` 在 c # 示例中，c # 编译器将解释为换行符，它不表示正则表达式字符转义。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="replacement" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> 小于零或大于 <paramref name="input" /> 的长度。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <related type="Article" href="/dotnet/standard/base-types/substitutions-in-regular-expressions">正则表达式中的替代</related>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言 - 快速参考</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="replacement">替换字符串。</param>
        <param name="options">枚举值的一个按位组合，这些枚举值提供匹配选项。</param>
        <summary>在指定的输入字符串内，使用指定的替换字符串替换与指定正则表达式匹配的所有字符串。 指定的选项将修改匹配操作。</summary>
        <returns>一个与输入字符串基本相同的新字符串，唯一的差别在于，其中的每个匹配字符串已被替换字符串代替。 如果 <paramref name="pattern" /> 与当前实例不匹配，则此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 静态 `Replace` 方法等效于 <xref:System.Text.RegularExpressions.Regex> 使用指定的正则表达式模式构造对象并调用实例方法 `Replace` 。  
  
 `pattern`参数包含符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅 [.NET Framework 正则表达式](/dotnet/standard/base-types/regular-expressions) 和 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)。 如果 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> 为 `options` 参数指定，则搜索匹配项将从输入字符串的末尾开始，并向左移动; 否则，搜索将从输入字符串的开头开始向右移动。  
  
 `replacement`参数指定要在其中替换每个匹配项的字符串 `input` 。 `replacement` 可以包含文字文本和 [替换](/dotnet/standard/base-types/substitutions-in-regular-expressions)的任意组合。 例如，替换模式 `a*${test}b` 插入字符串 "a *"，后面跟有捕获组匹配的子字符串 `test` （如果有），后跟字符串 "b"。 在替换模式中不将 * 字符识别为元字符。  
  
> [!NOTE]
>  替换是替换模式中唯一识别的正则表达式语言元素。 所有其他正则表达式语言元素（包括 [字符转义](/dotnet/standard/base-types/character-escapes-in-regular-expressions)）仅在正则表达式模式中允许，在替换模式下不能识别。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果替换操作的执行时间超过为其调用该方法的应用程序域指定的超时间隔，则会引发异常。 如果在应用程序域的属性中没有定义超时，或者超时值为 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ，则不会引发异常。  
  
 因为如果没有匹配项，则此方法返回 `input` 不变，你可以使用 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 方法来确定该方法是否已对输入字符串进行任何替换。  
  
   
  
## Examples  
 下面的示例使用 <xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)> 方法将 UNC 路径中的本地计算机和驱动器名称替换为本地文件路径。 正则表达式使用 <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> 属性包含本地计算机的名称，并使用 <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> 方法来包含逻辑驱动器的名称。 所有正则表达式字符串比较都不区分大小写。 若要成功运行此示例，应将文本字符串 "MyMachine" 替换为本地计算机名称。  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace4.cs" interactive="try-dotnet" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace4.vb" id="Snippet4":::
  
 正则表达式模式由以下表达式定义：  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 下表演示了如何解释正则表达式模式。  
  
|模式|说明|  
|-------------|-----------------|  
|`\\\\`|匹配两个连续的反斜杠 (`\`) 字符。 因为反斜杠字符被解释为转义字符，所以每个反斜杠都必须用另一个反斜杠进行转义。|  
|`+ Environment.MachineName +`|与属性返回的字符串匹配 <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> 。|  
|`(?:\.\w+)*`|匹配句点 (`.`) 字符后跟一个或多个单词字符。 此匹配可以出现零次或多次。 不捕获匹配的子表达式。|  
|`\\`|匹配反斜杠 (`\`) 字符。|  
|`([" + driveNames + "])`|匹配由单个驱动器号组成的字符类。 此匹配是第一个捕获的子表达式。|  
|`\$`|匹配文本美元符号 (`$`) 字符。|  
  
 替换模式将 `$1` 整个匹配项替换为第一个捕获的子表达式。 也就是说，它将 UNC 计算机和驱动器名称替换为驱动器号。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />、<paramref name="pattern" /> 或 <paramref name="replacement" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效按位组合。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <block subset="none" type="usage"><para>此方法在与调用该方法的应用程序域的默认超时值相等的时间间隔后超时。 如果尚未为应用程序域定义超时值，则将 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> 使用该值来阻止方法超时。 建议用于替换模式匹配的静态方法是 <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /> ，这使你可以设置超时间隔。</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="/dotnet/standard/base-types/substitutions-in-regular-expressions">正则表达式中的替代</related>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="evaluator">一个自定义方法，该方法检查每个匹配项，然后返回原始的匹配字符串或替换字符串。</param>
        <param name="options">枚举值的一个按位组合，这些枚举值提供匹配选项。</param>
        <summary>在指定的输入字符串中，使用由 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委托返回的字符串替换与指定的正则表达式匹配的所有字符串。 指定的选项将修改匹配操作。</summary>
        <returns>一个与输入字符串基本相同的新字符串，唯一的差别在于，其中的每个匹配字符串已被一个替换字符串代替。 如果 <paramref name="pattern" /> 与当前实例不匹配，则此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)?displayProperty=nameWithType>如果满足以下任一条件，则方法可用于替换中的正则表达式匹配：  
  
-   正则表达式替换模式无法轻易指定替换字符串。  
  
-   替换字符串是对匹配的字符串执行的一些处理导致的。  
  
-   从条件处理中得到的替换字符串。  
  
 方法等效于调用 <xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)?displayProperty=nameWithType> 方法并 <xref:System.Text.RegularExpressions.Match> 将返回集合中的每个对象传递 <xref:System.Text.RegularExpressions.MatchCollection> 给 `evaluator` 委托。  
  
 `pattern`参数包含符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅 [.NET Framework 正则表达式](/dotnet/standard/base-types/regular-expressions) 和 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)。  
  
 `evaluator`参数是你定义的用于检查每个匹配项的自定义方法的委托。 自定义方法必须具有以下签名才能匹配 <xref:System.Text.RegularExpressions.MatchEvaluator> 委托。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
   
 自定义方法返回替换匹配输入的字符串。  
  
 如果 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> 为 `options` 参数指定，则搜索匹配项将从输入字符串的末尾开始，并向左移动; 否则，搜索将从输入字符串的开头开始向右移动。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果替换操作的执行时间超过为其调用该方法的应用程序域指定的超时间隔，则会引发异常。 如果在应用程序域的属性中没有定义超时，或者超时值为 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ，则不会引发异常。  
  
 因为如果没有匹配项，则此方法返回 `input` 不变，你可以使用 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 方法来确定该方法是否已对输入字符串进行任何替换。  
  
   
  
## Examples  
 下面的示例使用正则表达式从字符串中提取各个单词，然后使用 <xref:System.Text.RegularExpressions.MatchEvaluator> 委托调用一个名为 `WordScramble` 的方法，该方法对单词中的各个字母进行编码。 为此， `WordScramble` 方法会创建一个包含匹配项中的字符的数组。 它还会创建一个并行数组，该数组使用随机浮点数填充。 通过调用方法对数组进行排序 <xref:System.Array.Sort%60%602(%60%600%5B%5D,%60%601%5B%5D,System.Collections.Generic.IComparer%7B%60%600%7D)?displayProperty=nameWithType> ，并将排序的数组作为参数提供给 <xref:System.String> 类构造函数。 然后，该方法将返回这个新创建的字符串 `WordScramble` 。 正则表达式模式 `\w+` 匹配一个或多个单词字符; 正则表达式引擎将继续向匹配项添加字符，直到遇到非单词字符，例如空白字符。 对方法的调用 <xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)> 包括 <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> 选项，以便正则表达式引擎将忽略正则表达式模式中的注释 `\w+  # Matches all the characters in a word.` 。  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace6.cs" interactive="try-dotnet" id="Snippet10":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace6.vb" id="Snippet10"::: 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />、<paramref name="pattern" /> 或 <paramref name="evaluator" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效按位组合。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="/dotnet/standard/base-types/substitutions-in-regular-expressions">正则表达式中的替代</related>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int * int -&gt; string" Usage="regex.Replace (input, evaluator, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="evaluator">一个自定义方法，该方法检查每个匹配项，然后返回原始的匹配字符串或替换字符串。</param>
        <param name="count">进行替换的最大次数。</param>
        <param name="startat">输入字符串中开始执行搜索的字符位置。</param>
        <summary>在指定的输入子字符串内，使用 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委托返回的字符串替换与某个正则表达式模式匹配的字符串（其数目为指定的最大数目）。</summary>
        <returns>一个与输入字符串基本相同的新字符串，唯一的差别在于，其中的每个匹配字符串已被一个替换字符串代替。 如果正则表达式模式与当前实例不匹配，则此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)?displayProperty=nameWithType>如果满足以下任一条件，则方法可用于替换正则表达式匹配：  
  
-   正则表达式替换模式无法轻易指定替换字符串。  
  
-   替换字符串是对匹配的字符串执行的一些处理导致的。  
  
-   从条件处理中得到的替换字符串。  
  
 方法等效于调用 <xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)?displayProperty=nameWithType> 方法，并将 `count` <xref:System.Text.RegularExpressions.Match> 返回集合中的第一个对象传递 <xref:System.Text.RegularExpressions.MatchCollection> 到 `evaluator` 委托。  
  
 正则表达式是由当前对象的构造函数定义的模式 <xref:System.Text.RegularExpressions.Regex> 。  
  
 `evaluator`参数是你定义的用于检查每个匹配项的自定义方法的委托。 自定义方法必须具有以下签名才能匹配 <xref:System.Text.RegularExpressions.MatchEvaluator> 委托。  
 
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
   
 自定义方法返回替换匹配输入的字符串。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果替换操作的执行时间超过了构造函数指定的超时间隔，则会引发异常 <xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)?displayProperty=nameWithType> 。 如果在调用构造函数时未设置超时间隔，则当操作超过在其中创建对象的应用程序域的任何超时值时，将引发异常 <xref:System.Text.RegularExpressions.Regex> 。 如果在 <xref:System.Text.RegularExpressions.Regex> 构造函数调用或应用程序域的属性中没有定义超时，或者超时值为 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ，则不会引发异常  
  
 因为如果没有匹配项，则此方法返回 `input` 不变，你可以使用 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 方法来确定该方法是否已对输入字符串进行任何替换。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="evaluator" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> 小于零或大于 <paramref name="input" /> 的长度。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="/dotnet/standard/base-types/substitutions-in-regular-expressions">正则表达式中的替代</related>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言 - 快速参考</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="replacement" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="4" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="replacement">替换字符串。</param>
        <param name="options">枚举值的一个按位组合，这些枚举值提供匹配选项。</param>
        <param name="matchTimeout">超时间隔；若要指示该方法不应超时，则为 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</param>
        <summary>在指定的输入字符串内，使用指定的替换字符串替换与指定正则表达式匹配的所有字符串。 如果未找到匹配项，则其他参数指定修改匹配操作的选项和超时间隔。</summary>
        <returns>一个与输入字符串基本相同的新字符串，唯一的差别在于，其中的每个匹配字符串已被替换字符串代替。 如果 <paramref name="pattern" /> 与当前实例不匹配，则此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 静态 `Replace` 方法等效于 <xref:System.Text.RegularExpressions.Regex> 使用指定的正则表达式模式构造对象并调用实例方法 `Replace` 。  
  
 `pattern`参数包含符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅 [.NET Framework 正则表达式](/dotnet/standard/base-types/regular-expressions) 和 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)。 如果 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> 为 `options` 参数指定，则搜索匹配项将从输入字符串的末尾开始，并向左移动; 否则，搜索将从输入字符串的开头开始向右移动。  
  
 `replacement`参数指定要在其中替换每个匹配项的字符串 `input` 。 `replacement` 可以包含文字文本和 [替换](/dotnet/standard/base-types/substitutions-in-regular-expressions)的任意组合。 例如，替换模式 `a*${test}b` 插入字符串 "a *"，后面跟有捕获组匹配的子字符串 `test` （如果有），后跟字符串 "b"。 在替换模式中不将 * 字符识别为元字符。  
  
> [!NOTE]
>  替换是替换模式中唯一识别的正则表达式语言元素。 所有其他正则表达式语言元素（包括 [字符转义](/dotnet/standard/base-types/character-escapes-in-regular-expressions)）仅在正则表达式模式中允许，在替换模式下不能识别。  
  
 `matchTimeout`参数指定模式匹配方法在超时之前应尝试找到匹配项的时间长度。设置超时间隔可防止正则表达式在处理包含接近匹配项的输入时，这些表达式会出现依赖于过量回溯的正则表达式停止响应。 有关详细信息，请参阅[正则表达式和回溯的最佳实践](/dotnet/standard/base-types/best-practices)。 [](/dotnet/standard/base-types/backtracking-in-regular-expressions) 如果在该时间间隔内未找到匹配项，则该方法将引发 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 异常。 `matchTimeout` 重写为在其中执行该方法的应用程序域定义的任何默认超时值。  
  
 因为如果没有匹配项，则此方法返回 `input` 不变，你可以使用 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 方法来确定该方法是否已对输入字符串进行任何替换。  
  
   
  
## Examples  
 下面的示例使用 <xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)> 方法将 UNC 路径中的本地计算机和驱动器名称替换为本地文件路径。 正则表达式使用 <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> 属性包含本地计算机的名称，并使用 <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> 方法来包含逻辑驱动器的名称。 所有正则表达式字符串比较都不区分大小写，并且如果在0.5 秒内找不到匹配项，则任何单个替换操作都将超时。 若要成功运行此示例，应将文本字符串 "MyMachine" 替换为本地计算机名称。  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace12.cs" interactive="try-dotnet" id="Snippet12":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace12.vb" id="Snippet12"::: 
  
 正则表达式模式由以下表达式定义：  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 下表演示了如何解释正则表达式模式。  
  
|模式|说明|  
|-------------|-----------------|  
|`\\\\`|匹配两个连续的反斜杠 (`\`) 字符。 因为反斜杠字符被解释为转义字符，所以每个反斜杠都必须用另一个反斜杠进行转义。|  
|`+ Environment.MachineName +`|与属性返回的字符串匹配 <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> 。|  
|`(?:\.\w+)*`|匹配句点 (`.`) 字符后跟一个或多个单词字符。 此匹配可以出现零次或多次。 不捕获匹配的子表达式。|  
|`\\`|匹配反斜杠 (`\`) 字符。|  
|`([" + driveNames + "])`|匹配由单个驱动器号组成的字符类。 此匹配是第一个捕获的子表达式。|  
|`\$`|匹配文本美元符号 (`$`) 字符。|  
  
 替换模式将 `$1` 整个匹配项替换为第一个捕获的子表达式。 也就是说，它将 UNC 计算机和驱动器名称替换为驱动器号。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />、<paramref name="pattern" /> 或 <paramref name="replacement" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效按位组合。  
  
- 或 - 
 <paramref name="matchTimeout" /> 为负、零或大于 24 天左右。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <block subset="none" type="usage"><para>建议将 <paramref name="matchTimeout" /> 参数设置为适当的值，例如两秒钟。 如果通过指定禁用超时 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> ，则正则表达式引擎可提供略微更好的性能。 但是，只应在以下条件下禁用超时： 
-正则表达式处理的输入派生自已知的和受信任的源，或由静态文本组成。 这不包括用户动态输入的文本。  
  
-对正则表达式模式进行了全面测试，以确保它有效地处理匹配、不匹配和接近匹配项。  
  
-当正则表达式模式不包含已知的语言元素时，这些元素会导致在处理接近的匹配时导致过度回溯。</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="/dotnet/standard/base-types/substitutions-in-regular-expressions">正则表达式中的替代</related>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言元素</related>
        <related type="Article" href="/dotnet/standard/base-types/backtracking-in-regular-expressions">正则表达式中的回溯</related>
        <related type="Article" href="/dotnet/standard/base-types/best-practices">.NET 中的正则表达式最佳做法</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="4" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="evaluator">一个自定义方法，该方法检查每个匹配项，然后返回原始的匹配字符串或替换字符串。</param>
        <param name="options">枚举值的一个按位组合，这些枚举值提供匹配选项。</param>
        <param name="matchTimeout">超时间隔；若要指示该方法不应超时，则为 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</param>
        <summary>在指定的输入字符串中，使用由 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委托返回的字符串替换与指定的正则表达式匹配的所有子字符串。 如果未找到匹配项，则其他参数指定修改匹配操作的选项和超时间隔。</summary>
        <returns>一个与输入字符串基本相同的新字符串，唯一的差别在于，其中的每个匹配字符串已被替换字符串代替。 如果 <paramref name="pattern" /> 与当前实例不匹配，则此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)?displayProperty=nameWithType>如果满足以下任一条件，则方法可用于替换正则表达式匹配：  
  
-   如果正则表达式替换模式无法轻松指定替换字符串。  
  
-   如果替换字符串是对匹配的字符串执行的某些处理导致的。  
  
-   如果替换字符串是通过条件处理导致的。  
  
 方法等效于调用 <xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)?displayProperty=nameWithType> 方法并 <xref:System.Text.RegularExpressions.Match> 将返回集合中的每个对象传递 <xref:System.Text.RegularExpressions.MatchCollection> 给 `evaluator` 委托。  
  
 `pattern`参数包含符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅 [.NET Framework 正则表达式](/dotnet/standard/base-types/regular-expressions) 和 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)。  
  
 `evaluator`参数是你定义的用于检查每个匹配项的自定义方法的委托。 自定义方法必须具有以下签名才能匹配 <xref:System.Text.RegularExpressions.MatchEvaluator> 委托。  
 
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
   
 自定义方法返回替换匹配输入的字符串。  
  
 如果 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> 为 `options` 参数指定，则搜索匹配项将从输入字符串的末尾开始，并向左移动; 否则，搜索将从输入字符串的开头开始向右移动。  
  
 `matchTimeout`参数指定模式匹配方法在超时之前应尝试找到匹配项的时间长度。设置超时间隔可防止正则表达式依赖于过量回溯，使其在处理包含接近匹配项的输入时停止响应。 有关详细信息，请参阅[正则表达式和回溯的最佳实践](/dotnet/standard/base-types/best-practices)。 [](/dotnet/standard/base-types/backtracking-in-regular-expressions) 如果在该时间间隔内未找到匹配项，则该方法将引发 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 异常。 `matchTimeout` 重写为在其中执行该方法的应用程序域定义的任何默认超时值。  
  
 因为如果没有匹配项，则此方法返回 `input` 不变，你可以使用 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 方法来确定该方法是否已对输入字符串进行任何替换。  
  
   
  
## Examples  
 下面的示例使用正则表达式从字符串中提取各个单词，然后使用 <xref:System.Text.RegularExpressions.MatchEvaluator> 委托调用一个名为 `WordScramble` 的方法，该方法对单词中的各个字母进行编码。 为此， `WordScramble` 方法会创建一个包含匹配项中的字符的数组。 它还会创建一个并行数组，该数组使用随机浮点数填充。 通过调用方法对数组进行排序 <xref:System.Array.Sort%60%602(%60%600%5B%5D,%60%601%5B%5D,System.Collections.Generic.IComparer%7B%60%600%7D)?displayProperty=nameWithType> ，并将排序的数组作为参数提供给 <xref:System.String> 类构造函数。 然后，该方法将返回这个新创建的字符串 `WordScramble` 。 正则表达式模式 `\w+` 匹配一个或多个单词字符; 正则表达式引擎将继续向匹配项添加字符，直到遇到非单词字符，例如空白字符。 对方法的调用 <xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)> 包括 <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> 选项，以便正则表达式引擎将忽略正则表达式模式中的注释 `\w+  # Matches all the characters in a word.` 。  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace13.cs" interactive="try-dotnet" id="Snippet13":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace13.vb" id="Snippet13"::: 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />、<paramref name="pattern" /> 或 <paramref name="evaluator" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效按位组合。  
  
- 或 - 
 <paramref name="matchTimeout" /> 为负、零或大于 24 天左右。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <block subset="none" type="usage"><para>建议将 <paramref name="matchTimeout" /> 参数设置为适当的值，例如两秒钟。 如果通过指定禁用超时 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> ，则正则表达式引擎可提供略微更好的性能。 但是，只应在以下条件下禁用超时： 
-正则表达式处理的输入派生自已知的和受信任的源，或由静态文本组成。 这不包括用户动态输入的文本。  
  
-对正则表达式模式进行了全面测试，以确保它有效地处理匹配、不匹配和接近匹配项。  
  
-当正则表达式模式不包含已知的语言元素时，这些元素会导致在处理接近的匹配时导致过度回溯。</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="/dotnet/standard/base-types/substitutions-in-regular-expressions">正则表达式中的替代</related>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言元素</related>
        <related type="Article" href="/dotnet/standard/base-types/backtracking-in-regular-expressions">正则表达式中的回溯</related>
        <related type="Article" href="/dotnet/standard/base-types/best-practices">.NET 中的正则表达式最佳做法</related>
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public bool RightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RightToLeft { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : bool" Usage="System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示正则表达式是否从右向左进行搜索。</summary>
        <value>如果正则表达式从右向左进行搜索，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.RightToLeft%2A>`true`如果该 <xref:System.Text.RegularExpressions.Regex> 实例是通过选项创建的，则为 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="roptions">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexOptions roptions;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.Text.RegularExpressions.RegexOptions roptions" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.roptions" />
      <MemberSignature Language="VB.NET" Value="Protected Friend roptions As RegexOptions " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexOptions roptions;" />
      <MemberSignature Language="F#" Value="val mutable roptions : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.roptions" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法生成的 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在由正则表达式匹配定义的位置将输入字符串拆分为一个子字符串数组。</summary>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言 - 快速参考</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Split : string -&gt; string[]" Usage="regex.Split input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">要拆分的字符串。</param>
        <summary>在由 <see cref="T:System.Text.RegularExpressions.Regex" /> 构造函数指定的正则表达式模式所定义的位置，将输入字符串拆分为子字符串数组。</summary>
        <returns>字符串数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法与 <xref:System.String.Split(System.Char%5B%5D)?displayProperty=nameWithType> 方法类似，只是 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 在由正则表达式（而不是一组字符）确定的分隔符处拆分字符串。 尽可能多地拆分字符串。 如果未找到分隔符，则返回值将包含一个值为原始输入字符串的元素。  
  
 如果多个匹配项彼此相邻，则将空字符串插入到数组中。 例如，将字符串拆分为单个连字符会导致返回的数组在找到两个相邻连字符的位置包含空字符串，如以下代码所示。  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split1.vb" id="Snippet1"::: 
  
 如果在输入字符串的开头或末尾找到了匹配项，则返回数组的开头或结尾处将包含空字符串。 下面的示例使用正则表达式模式 `\d+` 对数字字符拆分输入字符串。 因为字符串以匹配的数字字符开始和结束，所以返回数组的第一个元素和最后一个元素的值为 <xref:System.String.Empty?displayProperty=nameWithType> 。  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split21.cs" interactive="try-dotnet" id="Snippet21":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split21.vb" id="Snippet21"::: 
  
 如果在表达式中使用捕获括号 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> ，则生成的字符串数组中将包括任何捕获的文本。 例如，如果在放在捕获括号内的连字符处拆分字符串 "plum"，则返回的数组包含一个包含连字符的字符串元素。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split2.vb" id="Snippet2":::
  
 但是，当正则表达式模式包含多组捕获括号时，此方法的行为取决于 .NET Framework 的版本。 在 .NET Framework 1.0 和1.1 中，如果在第一组捕获括号中找不到匹配项，则不会在返回的数组中包含从其他捕获括号中捕获的文本。 从 .NET Framework 2.0 开始，所有捕获的文本也会添加到返回的数组中。 例如，下面的代码使用两组捕获括号从日期字符串提取日期的元素，包括日期分隔符。 第一组捕获括号捕获连字符，第二组捕获的是正斜杠。 如果在 .NET Framework 1.0 或1.1 下编译并运行示例代码，它将排除斜杠字符;如果编译并在 .NET Framework 2.0 或更高版本下运行，则它将包含它们。  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split3.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split3.vb" id="Snippet3"::: 
  
 如果正则表达式可以匹配空字符串，则 <xref:System.Text.RegularExpressions.Regex.Split(System.String)> 会将字符串拆分为单字符字符串数组，因为可以在每个位置找到空字符串分隔符。 例如：  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split11.cs" interactive="try-dotnet" id="Snippet11":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split11.vb" id="Snippet11"::: 
  
 请注意，返回的数组还在数组的开头和结尾包含空字符串。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果 split 操作的执行时间超过了构造函数指定的超时间隔，则会引发异常 <xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)?displayProperty=nameWithType> 。 如果在调用构造函数时未设置超时间隔，则当操作超过在其中创建对象的应用程序域的任何超时值时，将引发异常 <xref:System.Text.RegularExpressions.Regex> 。 如果在 <xref:System.Text.RegularExpressions.Regex> 构造函数调用或应用程序域的属性中没有定义超时，或者超时值为 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ，则不会引发异常  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言 - 快速参考</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int -&gt; string[]" Usage="regex.Split (input, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">要拆分的字符串。</param>
        <param name="count">可拆分的最大次数。</param>
        <summary>在由 <see cref="T:System.Text.RegularExpressions.Regex" /> 构造函数中指定的正则表达式定义的位置，将输入字符串拆分为子字符串数组指定的最大次数。</summary>
        <returns>字符串数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法与 <xref:System.String.Split%2A?displayProperty=nameWithType> 方法类似，只是 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 在由正则表达式（而不是一组字符）确定的分隔符处拆分字符串。 `count`参数指定可将字符串拆分到其中的子字符串的最大数量 `input` ; 最后一个字符串包含字符串的撤消余数。 如果 `count` 值为零，则提供尽可能多的拆分的默认行为。  
  
 如果多个匹配项彼此相邻，或者如果在的开头或末尾找到了匹配项 `input` ，并且找到的匹配项的数目至少小于，则会将 `count` 空字符串插入到数组中。 也就是说，在确定匹配的子字符串的数目是否等于时，将计算从输入字符串的开头或结尾处的相邻匹配项或从匹配项中产生的空字符串 `count` 。 在下面的示例中，正则表达式 `/d+` 用于将包含一个或多个十进制数字的输入字符串拆分为最多三个子字符串。 由于输入字符串的开头与正则表达式模式匹配，因此第一个数组元素包含 <xref:System.String.Empty?displayProperty=nameWithType> ，第二个数组元素包含输入字符串中的第一组字母字符，第三个元素包含第三个匹配项后的字符串的剩余部分。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split25.cs" interactive="try-dotnet" id="Snippet25":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split25.vb" id="Snippet25":::  
  
 如果正则表达式中使用了捕获括号，则任何捕获的文本都将包含在拆分字符串数组中。 但是，任何包含捕获文本的数组元素都不会在确定是否已达到匹配项的数量时进行计数 `count` 。 例如，将字符串 "apricot-plum-香蕉" 拆分为最多四个子字符串会生成一个7元素数组，如以下代码所示。  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split4.cs" interactive="try-dotnet" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split4.vb" id="Snippet4":::
  
 但是，当正则表达式模式包含多组捕获括号时，此方法的行为取决于 .NET Framework 的版本。 在 .NET Framework 1.0 和1.1 中，只在返回的数组中包含从第一组捕获括号中捕获的文本。 从 .NET Framework 2.0 开始，所有捕获的文本都将添加到返回的数组中。 但是，在确定匹配的子字符串的数目是否等于时，不会对返回的数组中包含捕获的文本的元素进行计数 `count` 。 例如，在下面的代码中，正则表达式使用两组捕获括号从日期字符串提取日期的元素。 第一组捕获括号捕获连字符，第二组捕获的是正斜杠。 然后调用方法，在 <xref:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)> 返回的数组中指定最多两个元素。 如果在 .NET Framework 1.0 或1.1 下编译并运行示例代码，则该方法将返回一个双元素字符串数组。 如果编译并在 .NET Framework 2.0 或更高版本下运行，则该方法将返回一个由三个元素组成的字符串数组。  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split5.cs" interactive="try-dotnet" id="Snippet5":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split5.vb" id="Snippet5":::
  
 如果正则表达式可以匹配空字符串，则 <xref:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)> 会将字符串拆分为单字符字符串数组，因为可以在每个位置找到空字符串分隔符。 下面的示例将字符串 "字符" 拆分为与输入字符串中的元素数量相同的元素。 由于 null 字符串与输入字符串的开头匹配，因此将在返回的数组的开头插入一个空字符串。 这将导致第十个元素由输入字符串末尾的两个字符组成。  
  
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split12.vb" id="Snippet12":::  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果 split 操作的执行时间超过了构造函数指定的超时间隔，则会引发异常 <xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)?displayProperty=nameWithType> 。 如果在调用构造函数时未设置超时间隔，则当操作超过在其中创建对象的应用程序域的任何超时值时，将引发异常 <xref:System.Text.RegularExpressions.Regex> 。 如果在 <xref:System.Text.RegularExpressions.Regex> 构造函数调用或应用程序域的属性中没有定义超时，或者超时值为 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ，则不会引发异常  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言 - 快速参考</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Split : string * string -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">要拆分的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <summary>在由正则表达式模式定义的位置将输入字符串拆分为一个子字符串数组。</summary>
        <returns>字符串数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法与 <xref:System.String.Split%2A?displayProperty=nameWithType> 方法类似，只是 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 在由正则表达式（而不是一组字符）确定的分隔符处拆分字符串。 尽可能 `input` 多地拆分字符串。 如果 `pattern` 在字符串中找不到 `input` ，则返回值将包含一个值为原始字符串的元素 `input` 。  
  
 `pattern`参数包含符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅 [.NET Framework 正则表达式](/dotnet/standard/base-types/regular-expressions) 和 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)。  
  
> [!IMPORTANT]
>  将自动缓存用于静态方法调用中的已编译正则表达式 <xref:System.Text.RegularExpressions.Regex.Split%2A> 。 若要自行管理已编译的正则表达式的生存期，请使用实例 <xref:System.Text.RegularExpressions.Regex.Split%2A> 方法。  
  
 如果多个匹配项彼此相邻，则将空字符串插入到数组中。 例如，将字符串拆分为单个连字符会导致返回的数组在找到两个相邻连字符的位置包含空字符串，如以下代码所示。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split8.cs" interactive="try-dotnet" id="Snippet8":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split8.vb" id="Snippet8":::  
  
 如果在输入字符串的开头或末尾找到了匹配项，则返回数组的开头或结尾处将包含空字符串。 下面的示例使用正则表达式模式 `\d+` 对数字字符拆分输入字符串。 因为字符串以匹配的数字字符开始和结束，所以返回数组的第一个元素和最后一个元素的值为 <xref:System.String.Empty?displayProperty=nameWithType> 。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split22.cs" interactive="try-dotnet" id="Snippet22":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split22.vb" id="Snippet22"::: 
  
 如果在表达式中使用捕获括号 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> ，则生成的字符串数组中将包括任何捕获的文本。 例如，如果在放在捕获括号内的连字符处拆分字符串 "plum"，则返回的数组包含一个包含连字符的字符串元素。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs" interactive="try-dotnet" id="Snippet9":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb" id="Snippet9":::
  
 但是，当正则表达式模式包含多组捕获括号时，此方法的行为取决于 .NET Framework 的版本。 在 .NET Framework 1.0 和1.1 中，如果在第一组捕获括号中找不到匹配项，则不会在返回的数组中包含从其他捕获括号中捕获的文本。 从 .NET Framework 2.0 开始，所有捕获的文本也会添加到返回的数组中。 例如，下面的代码使用两组捕获括号从日期字符串提取日期的元素，包括日期分隔符。 第一组捕获括号捕获连字符，第二组捕获的是正斜杠。 如果在 .NET Framework 1.0 或1.1 下编译并运行示例代码，它将排除斜杠字符;如果编译并在 .NET Framework 2.0 或更高版本下运行，则它将包含它们。  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs" interactive="try-dotnet" id="Snippet10":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb" id="Snippet10":::
  
 如果正则表达式可以匹配空字符串，则 <xref:System.Text.RegularExpressions.Regex.Split%2A> 会将字符串拆分为单字符字符串数组，因为可以在每个位置找到空字符串分隔符。 例如：  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split13.cs" interactive="try-dotnet" id="Snippet13":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split13.vb" id="Snippet13":::
  
 请注意，返回的数组还在数组的开头和结尾包含空字符串。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果拆分操作的执行时间超过为其调用该方法的应用程序域指定的超时间隔，则会引发异常。 如果在应用程序域的属性中没有定义超时，或者超时值为 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ，则不会引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <block subset="none" type="usage"><para>此方法在与调用方法的应用程序域的默认超时值相等的时间间隔后超时。 如果尚未为应用程序域定义超时值，则将 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> 使用该值来阻止方法超时。 用于在模式匹配时拆分文本的建议静态方法是 <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /> ，这使你可以设置超时间隔。</para></block>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer, startat As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * int -&gt; string[]" Usage="regex.Split (input, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">要拆分的字符串。</param>
        <param name="count">可拆分的最大次数。</param>
        <param name="startat">输入字符串中将开始搜索的字符位置。</param>
        <summary>在由 <see cref="T:System.Text.RegularExpressions.Regex" /> 构造函数中指定的正则表达式定义的位置，将输入字符串拆分为子字符串数组指定的最大次数。 从输入字符串的指定字符位置开始搜索正则表达式模式。</summary>
        <returns>字符串数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法与 <xref:System.String.Split%2A?displayProperty=nameWithType> 方法类似，只是 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 在由正则表达式（而不是一组字符）确定的分隔符处拆分字符串。 `count`参数指定将字符串拆分到其中的子字符串的最大数量 `input` ; 最后一个字符串包含字符串的撤消余数。 如果 `count` 值为零，则提供尽可能多的拆分的默认行为。 `startat`参数定义开始搜索第一个分隔符 (此点可以用于跳过前导空白) 。  
  
 如果 `count` 在字符串的 + 1 位置中找不到匹配项，则该方法将返回包含该字符串的单元素数组 `input` 。 如果找到一个或多个匹配项，则返回数组的第一个元素包含字符串的第一部分，该字符串的第一个部分中的第一个字符到匹配项前一个字符。  
  
 如果多个匹配项彼此相邻并且找到的匹配项的数量至少小于两个，则将 `count` 空字符串插入到数组中。 同样，如果在中找到了匹配项 `startat` （字符串中的第一个字符），则返回数组的第一个元素为空字符串。 也就是说，将在确定匹配的子字符串的数目是否相等时，计算相邻匹配项产生的空字符串 `count` 。 在下面的示例中，正则表达式 `\d+` 用于查找字符串中数字字符的第一个子字符串的起始位置，然后从该位置开始最多拆分字符串三次。 由于正则表达式模式与输入字符串的开头匹配，因此返回的字符串数组包含空字符串、5个字符的字母字符串和字符串的其余部分。  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split26.cs" interactive="try-dotnet" id="Snippet26":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split26.vb" id="Snippet26":::  
  
 如果正则表达式中使用了捕获括号，则任何捕获的文本都将包含在拆分字符串数组中。 但是，任何包含捕获文本的数组元素都不会在确定是否已达到匹配项的数量时进行计数 `count` 。 例如，将字符串 "" apple-apricot-plum-石榴-pineapple-粉 "拆分为最多四个子字符串，从字符串中的字符15开始，如以下代码所示。  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split6.cs" interactive="try-dotnet" id="Snippet6"::: 
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split6.vb" id="Snippet6"::: 
  
 但是，当正则表达式模式包含多组捕获括号时，此方法的行为取决于 .NET Framework 的版本。 在 .NET Framework 1.0 和1.1 中，如果在第一组捕获括号中找不到匹配项，则不会在返回的数组中包含从其他捕获括号中捕获的文本。 从 .NET Framework 2.0 开始，所有捕获的文本也会添加到返回的数组中。 例如，下面的代码使用两组捕获括号来提取字符串中的各个单词。 第一组捕获括号捕获连字符，第二组捕获竖线。 如果在 .NET Framework 1.0 或1.1 下编译并运行示例代码，它将排除竖线字符;如果编译并在 .NET Framework 2.0 或更高版本下运行，则它将包含它们。  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split7.cs" interactive="try-dotnet" id="Snippet7":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split7.vb" id="Snippet7"::: 
  
 如果正则表达式可以匹配空字符串，则 <xref:System.Text.RegularExpressions.Regex.Split%2A> 会将字符串拆分为单字符字符串数组，因为可以在每个位置找到空字符串分隔符。 下面的示例将字符串 "字符" 拆分为输入字符串中包含的多个元素，以字符 "a" 开头。 由于 null 字符串与输入字符串的末尾匹配，因此将在返回的数组的末尾插入一个空字符串。  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split14.cs" interactive="try-dotnet" id="Snippet14":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split14.vb" id="Snippet14"::: 
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果 split 操作的执行时间超过了构造函数指定的超时间隔，则会引发异常 <xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)?displayProperty=nameWithType> 。 如果在调用构造函数时未设置超时间隔，则当操作超过在其中创建对象的应用程序域的任何超时值时，将引发异常 <xref:System.Text.RegularExpressions.Regex> 。 如果在 <xref:System.Text.RegularExpressions.Regex> 构造函数调用或应用程序域的属性中没有定义超时，或者超时值为 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ，则不会引发异常  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> 小于零或大于 <paramref name="input" /> 的长度。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言 - 快速参考</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">要拆分的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="options">枚举值的一个按位组合，这些枚举值提供匹配选项。</param>
        <summary>在由指定正则表达式模式定义的位置将输入字符串拆分为一个子字符串数组。 指定的选项将修改匹配操作。</summary>
        <returns>字符串数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法与 <xref:System.String.Split(System.Char%5B%5D)?displayProperty=nameWithType> 方法类似，只是 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 在由正则表达式（而不是一组字符）确定的分隔符处拆分字符串。 尽可能多地拆分字符串。 如果未找到分隔符，则返回值将包含一个值为原始字符串的元素 `input` 。  
  
 `pattern`参数包含符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅 [.NET Framework 正则表达式](/dotnet/standard/base-types/regular-expressions) 和 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)。  
  
> [!IMPORTANT]
>  将自动缓存用于静态方法调用中的已编译正则表达式 <xref:System.Text.RegularExpressions.Regex.Split%2A> 。 若要自行管理已编译的正则表达式的生存期，请使用实例 <xref:System.Text.RegularExpressions.Regex.Split%2A> 方法。  
  
 如果多个匹配项彼此相邻，则将空字符串插入到数组中。 例如，将字符串拆分为单个连字符会导致返回的数组在找到两个相邻连字符的位置包含空字符串。  
  
 如果在输入字符串的开头或末尾找到了匹配项，则返回数组的开头或结尾处将包含空字符串。 下面的示例使用正则表达式模式 `[a-z]+` 对任意大写或小写字母字符拆分输入字符串。 因为字符串以匹配的字母字符开头和结尾，所以返回数组的第一个元素和最后一个元素的值为 <xref:System.String.Empty?displayProperty=nameWithType> 。  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split24.cs" interactive="try-dotnet" id="Snippet24":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split24.vb" id="Snippet24"::: 
  
 如果在表达式中使用捕获括号 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> ，则生成的字符串数组中将包括任何捕获的文本。 例如，如果在放在捕获括号内的连字符处拆分字符串 "plum"，则返回的数组包含一个包含连字符的字符串元素。  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs" interactive="try-dotnet" id="Snippet9":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb" id="Snippet9"::: 
  
 但是，当正则表达式模式包含多组捕获括号时，此方法的行为取决于 .NET Framework 的版本。 在 .NET Framework 1.0 和1.1 中，如果在第一组捕获括号中找不到匹配项，则不会在返回的数组中包含从其他捕获括号中捕获的文本。 从 .NET Framework 2.0 开始，所有捕获的文本也会添加到返回的数组中。 例如，下面的代码使用两组捕获括号从日期字符串提取日期的元素，包括日期分隔符。 第一组捕获括号捕获连字符，第二组捕获的是正斜杠。 如果在 .NET Framework 1.0 或1.1 下编译并运行示例代码，它将排除斜杠字符;如果编译并在 .NET Framework 2.0 或更高版本下运行，则它将包含它们。  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs" interactive="try-dotnet" id="Snippet10":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb" id="Snippet10":::  
  
 如果正则表达式可以匹配空字符串，则 <xref:System.Text.RegularExpressions.Regex.Split%2A> 会将字符串拆分为单字符字符串数组，因为可以在每个位置找到空字符串分隔符。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果拆分操作的执行时间超过为其调用该方法的应用程序域指定的超时间隔，则会引发异常。 如果在应用程序域的属性中没有定义超时，或者超时值为 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ，则不会引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效按位组合。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <block subset="none" type="usage"><para>此方法在与调用方法的应用程序域的默认超时值相等的时间间隔后超时。 如果尚未为应用程序域定义超时值，则将 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> 使用该值来阻止方法超时。 用于在模式匹配时拆分文本的建议静态方法是 <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /> ，这使你可以设置超时间隔。</para></block>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">要拆分的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="options">枚举值的一个按位组合，这些枚举值提供匹配选项。</param>
        <param name="matchTimeout">超时间隔；若要指示该方法不应超时，则为 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</param>
        <summary>在由指定正则表达式模式定义的位置将输入字符串拆分为一个子字符串数组。 如果未找到匹配项，则其他参数指定修改匹配操作的选项和超时间隔。</summary>
        <returns>字符串数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法与 <xref:System.String.Split(System.Char%5B%5D)?displayProperty=nameWithType> 方法类似，只是 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 在由正则表达式（而不是一组字符）确定的分隔符处拆分字符串。 尽可能多地拆分字符串。 如果未找到分隔符，则返回值将包含一个值为原始字符串的元素 `input` 。  
  
 `pattern`参数包含符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅 [.NET Framework 正则表达式](/dotnet/standard/base-types/regular-expressions) 和 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)。  
  
> [!IMPORTANT]
>  将自动缓存用于静态方法调用中的已编译正则表达式 <xref:System.Text.RegularExpressions.Regex.Split%2A> 。 若要自行管理已编译的正则表达式的生存期，请使用实例 <xref:System.Text.RegularExpressions.Regex.Split%2A> 方法。  
  
 如果多个匹配项彼此相邻，则将空字符串插入到数组中。 例如，将字符串拆分为单个连字符会导致返回的数组在找到两个相邻连字符的位置包含空字符串。  
  
 如果在输入字符串的开头或末尾找到了匹配项，则返回数组的开头或结尾处将包含空字符串。 下面的示例使用正则表达式模式 `[a-z]+` 对任意大写或小写字母字符拆分输入字符串。 因为字符串以匹配的字母字符开头和结尾，所以返回数组的第一个元素和最后一个元素的值为 <xref:System.String.Empty?displayProperty=nameWithType> 。  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split23.cs" interactive="try-dotnet" id="Snippet23":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split23.vb" id="Snippet23":::
  
 如果在表达式中使用捕获括号 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> ，则生成的字符串数组中将包括任何捕获的文本。 例如，如果在放在捕获括号内的连字符处拆分字符串 "plum"，则返回的数组包含一个包含连字符的字符串元素。  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs" interactive="try-dotnet" id="Snippet9":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb" id="Snippet9":::  
  
 但是，当正则表达式模式包含多组捕获括号时，此方法的行为取决于 .NET Framework 的版本。 在 .NET Framework 1.0 和1.1 中，如果在第一组捕获括号中找不到匹配项，则不会在返回的数组中包含从其他捕获括号中捕获的文本。 从 .NET Framework 2.0 开始，所有捕获的文本也会添加到返回的数组中。 例如，下面的代码使用两组捕获括号从日期字符串提取日期的元素，包括日期分隔符。 第一组捕获括号捕获连字符，第二组捕获的是正斜杠。 如果在 .NET Framework 1.0 或1.1 下编译并运行示例代码，它将排除斜杠字符;如果编译并在 .NET Framework 2.0 或更高版本下运行，则它将包含它们。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs" interactive="try-dotnet" id="Snippet10":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb" id="Snippet10"::: 
  
 如果正则表达式可以匹配空字符串，则 <xref:System.Text.RegularExpressions.Regex.Split%2A> 会将字符串拆分为单字符字符串数组，因为可以在每个位置找到空字符串分隔符。  
  
 `matchTimeout`参数指定模式匹配方法在超时之前应尝试找到匹配项的时间长度。设置超时间隔可防止正则表达式在处理包含接近匹配项的输入时，这些表达式会出现依赖于过量回溯的正则表达式停止响应。 有关详细信息，请参阅[正则表达式和回溯的最佳实践](/dotnet/standard/base-types/best-practices)。 [](/dotnet/standard/base-types/backtracking-in-regular-expressions) 如果在该时间间隔内未找到匹配项，则该方法将引发 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 异常。 `matchTimeout` 重写为在其中执行该方法的应用程序域定义的任何默认超时值。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效按位组合。  
  
- 或 - 
 <paramref name="matchTimeout" /> 为负、零或大于 24 天左右。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <block subset="none" type="usage"><para>建议将 <paramref name="matchTimeout" /> 参数设置为适当的值，例如两秒钟。 如果通过指定禁用超时 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> ，则正则表达式引擎可提供略微更好的性能。 但是，只应在以下条件下禁用超时： 
-正则表达式处理的输入派生自已知的和受信任的源，或由静态文本组成。 这不包括用户动态输入的文本。  
  
-对正则表达式模式进行了全面测试，以确保它有效地处理匹配、不匹配和接近匹配项。  
  
-当正则表达式模式不包含已知的语言元素时，这些元素会导致在处理接近的匹配时导致过度回溯。</para></block>
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.Serialization.ISerializable.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.System.Runtime.Serialization.ISerializable.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="regex.System.Runtime.Serialization.ISerializable.GetObjectData (si, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="si">要用序列化信息填充的对象。</param>
        <param name="context">存储和检索序列化数据的位置。 此参数留待将来使用。</param>
        <summary>使用所需的数据填充 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象来反序列化当前 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<xref:System.Runtime.Serialization.SerializationInfo>格式化程序会自动跟踪和序列化中包含的所有对象。   
 调用的代码 <xref:System.Runtime.Serialization.ISerializable.GetObjectData%2A> 需要 <xref:System.Security.Permissions.SecurityPermission> 提供序列化服务的。 关联的枚举：<xref:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter?displayProperty=nameWithType>。   
 > [!NOTE] 
 >  不保证在序列化过程中每个对象实例只调用一次此方法。 因此，方法应以这样一种方式实现：无论调用多少次，方法的行为都是相同的。   
 
          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="regex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回传入 <see langword="Regex" /> 构造函数的正则表达式模式。</summary>
        <returns>传入 <see langword="Regex" /> 构造函数的 <paramref name="pattern" /> 参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern`参数包含符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅 [.NET Framework 正则表达式](/dotnet/standard/base-types/regular-expressions) 和 [正则表达式语言-快速参考](/dotnet/standard/base-types/regular-expression-language-quick-reference)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> 方法创建的正则表达式的基类 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 。 这些已编译的正则表达式使用 <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> 基类的实现。 如果是从派生类调用的，则 <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> 方法将返回传递给 <paramref name="pattern" /> <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> 用于定义正则表达式的类构造函数的参数的字符串。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="public static string Unescape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Unescape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unescape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Unescape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Unescape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Unescape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">包含要转换的文本的输入字符串。</param>
        <summary>转换输入字符串中的任何转义字符。</summary>
        <returns>包含任何转换为非转义形式的转义字符的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Unescape%2A>方法执行以下两种转换之一：  
  
-   它 <xref:System.Text.RegularExpressions.Regex.Escape%2A> 通过 \\ 从该方法转义的每个字符中删除转义符 ( "" ) ，来反转方法所执行的转换。 其中包括 \\ 、*、+、？、&#124;、{、[、 (、) 、^、$、.、# 和空格字符。 此外，该 <xref:System.Text.RegularExpressions.Regex.Unescape%2A> 方法 unescapes 右方括号 (] ) 和右大括号 (} ) 个字符。  
  
> [!NOTE]
>  <xref:System.Text.RegularExpressions.Regex.Unescape%2A> 无法完全反转转义字符串，因为它无法准确推导转义的字符。  
  
-   它将原义字符串文本中的十六进制值替换为实际的可打印字符。 例如，它将替换 @"\x07" 为 "\a" 或 @"\x0A" "\n"。 它转换为支持的转义字符，如 \a、\b、\e、\n、\r、\f、\t、\v 和字母数字字符。
  
 如果该 <xref:System.Text.RegularExpressions.Regex.Unescape%2A> 方法遇到无法转换的其他转义序列（如 \w 或 \s），则它将引发 <xref:System.ArgumentException> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="str" /> 包括无法识别的转义序列。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
        <related type="Article" href="/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式语言 - 快速参考</related>
      </Docs>
    </Member>
    <Member MemberName="UseOptionC">
      <MemberSignature Language="C#" Value="protected bool UseOptionC ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionC() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionC" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionC () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionC();" />
      <MemberSignature Language="F#" Value="member this.UseOptionC : unit -&gt; bool" Usage="regex.UseOptionC " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法生成的 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象使用。</summary>
        <returns>如果 <see cref="P:System.Text.RegularExpressions.Regex.Options" /> 属性包含 <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> 选项，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseOptionR">
      <MemberSignature Language="C#" Value="protected internal bool UseOptionR ();" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance bool UseOptionR() cil managed" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionR" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function UseOptionR () As Boolean" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; bool UseOptionR();" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="F#" Value="member this.UseOptionR : unit -&gt; bool" Usage="regex.UseOptionR " />
      <MemberSignature Language="C#" Value="protected bool UseOptionR ();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionR() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionR () As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionR();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法生成的 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象使用。</summary>
        <returns>如果 <see cref="P:System.Text.RegularExpressions.Regex.Options" /> 属性包含 <see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" /> 选项，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal static void ValidateMatchTimeout (TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig void ValidateMatchTimeout(valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Sub ValidateMatchTimeout (matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static void ValidateMatchTimeout(TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member ValidateMatchTimeout : TimeSpan -&gt; unit" Usage="System.Text.RegularExpressions.Regex.ValidateMatchTimeout matchTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="matchTimeout">要检查的超时间隔。</param>
        <summary>检查超时间隔是否在可接受的范围内。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">指定的超时不在有效范围内。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
