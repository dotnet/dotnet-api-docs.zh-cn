<Type Name="PerformanceCounter" FullName="System.Diagnostics.PerformanceCounter">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6e8eb1c6253cba0280465acf0d44e80f7624905b" /><Meta Name="ms.sourcegitcommit" Value="9506e50ec7beb4fa30206b9840dc546b035a6600" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/23/2020" /><Meta Name="ms.locfileid" Value="86984758" /></Metadata><TypeSignature Language="C#" Value="public sealed class PerformanceCounter : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit PerformanceCounter extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.PerformanceCounter" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class PerformanceCounter&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class PerformanceCounter sealed : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type PerformanceCounter = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName Language="C#">[System.ComponentModel.Designer("Microsoft.VisualStudio.Install.PerformanceCounterDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.Designer("Microsoft.VisualStudio.Install.PerformanceCounterDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName Language="C#">[System.ComponentModel.InstallerType("System.Diagnostics.PerformanceCounterInstaller,System.Configuration.Install, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.InstallerType("System.Diagnostics.PerformanceCounterInstaller,System.Configuration.Install, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName Language="C#">[System.ComponentModel.InstallerType("System.Diagnostics.PerformanceCounterInstaller,System.Configuration.Install, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.InstallerType("System.Diagnostics.PerformanceCounterInstaller,System.Configuration.Install, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName Language="C#">[System.ComponentModel.InstallerType("System.Diagnostics.PerformanceCounterInstaller,System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.InstallerType("System.Diagnostics.PerformanceCounterInstaller,System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName Language="C#">[System.ComponentModel.InstallerType(typeof(System.Diagnostics.PerformanceCounterInstaller))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.InstallerType(typeof(System.Diagnostics.PerformanceCounterInstaller))&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示 Windows NT 性能计数器组件。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.PerformanceCounter>组件可用于读取现有预定义或自定义计数器，并将) 性能数据 (写入自定义计数器。  
  
 Windows 性能监视器的 " [添加计数器" 对话框](https://go.microsoft.com/fwlink/p/?LinkId=257854)中列出了许多预定义的计数器。 若要了解 .NET Framework 性能计数器，请参阅 [性能计数器](/dotnet/framework/debug-trace-profile/performance-counters)。  
  
 此类型实现 <xref:System.IDisposable> 接口。 在使用完类型后，您应直接或间接释放类型。 若要直接释放类型，请在 `try`/`catch` 块中调用其 <xref:System.IDisposable.Dispose%2A> 方法。 若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。 有关详细信息，请参阅 <xref:System.IDisposable> 接口主题中的“使用实现 IDisposable 的对象”一节。  
  
> [!IMPORTANT]
>  在 .NET Framework 版本1.0 和1.1 中，此类要求直接调用方完全受信任。 从 .NET Framework 版本2.0 开始，此类需要 <xref:System.Diagnostics.PerformanceCounterPermission> 执行特定操作。 强烈建议 <xref:System.Diagnostics.PerformanceCounterPermission> 不要将其授予完全信任的代码。  读取和写入性能计数器的功能允许代码执行一些操作，例如枚举执行进程和获取有关它们的信息。  
>   
>  此外， <xref:System.Diagnostics.PerformanceCounter> 将对象传递给不受信任的代码可能会导致安全问题。 永远不会将性能计数器对象（例如 <xref:System.Diagnostics.PerformanceCounterCategory> 或 <xref:System.Diagnostics.PerformanceCounter> ）传递给不太受信任的代码。  
  
 若要从性能计数器读取，请创建类的实例 <xref:System.Diagnostics.PerformanceCounter> ，设置 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> 、 <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> 和，还可以选择 <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> 或 <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> 属性，然后调用 <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> 方法以执行性能计数器读取。  
  
 若要发布性能计数器数据，请使用方法创建一个或多个自定义计数器 <xref:System.Diagnostics.PerformanceCounterCategory.Create%2A?displayProperty=nameWithType> ，创建类的实例 <xref:System.Diagnostics.PerformanceCounter> ，设置 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> 、（ <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> 可选） <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> 或 <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> 属性，然后调用 <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A> 、 <xref:System.Diagnostics.PerformanceCounter.Increment%2A> 或 <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> 方法，或设置 <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> 属性以更改自定义计数器的值。  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>、 <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A> 和 <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> 方法使用 interlocks 更新计数器值。 这有助于在多线程或多进程方案中保持计数器值的准确性，但也会导致性能下降。 如果不需要联锁操作提供的准确性，可以 <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> 直接更新属性，使性能提高5倍。  但在多线程方案中，对计数器值的某些更新可能会被忽略，导致数据不准确。  
  
 计数器是收集性能数据时所依据的机制。 注册表存储所有计数器的名称，其中每个计数器都与系统功能的特定区域相关。 例如，处理器的繁忙时间、内存使用情况或通过网络连接接收的字节数。  
  
 每个计数器都是通过其名称和位置唯一标识的。 与文件路径包含驱动器、目录、一个或多个子目录以及文件名一样，计数器信息由以下四个元素组成： "计算机"、"类别"、"类别实例" 和 "计数器名称"。  
  
 计数器信息必须包含计数器测量数据的类别或性能对象。 计算机的类别包括物理组件，如处理器、磁盘和内存。 还有系统类别，如进程和线程。 每个类别都与计算机内的某个功能元素相关，并为其分配了一组标准计数器。 这些对象列在 Windows 2000 系统监视器中 "添加计数器" 对话框的 "性能对象" 下拉列表中，并且必须将它们包含在计数器路径中。 性能数据按与其相关的类别进行分组。  
  
 在某些情况下，可能存在同一类别的多个副本。 例如，多个进程和线程同时运行，某些计算机则包含多个处理器。 类别副本称为类别实例，每个实例都有一组分配给它的标准计数器。 如果一个类别可以有多个实例，则计数器信息中必须包括一个实例规范。  
  
 若要获取需要初始值或前一个值来执行必要计算的计数器的性能数据，请调用 <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> 方法两次，并使用根据应用程序需要返回的信息。  
  
> [!NOTE]
>  随一起安装的性能计数器类别 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] 使用单独的共享内存，每个性能计数器类别都有自己的内存。 可以通过在注册表项 HKEY_LOCAL_MACHINE \SYSTEM\CurrentControlSet\Services \Performance. 中创建一个名为 FileMappingSize 的 DWORD 来指定单独共享内存的大小。 \\ *\<category name>* FileMappingSize 值设置为类别的共享内存大小。 默认大小为131072。 如果 FileMappingSize 值不存在，则 `fileMappingSize` `performanceCounters` 使用 Machine.config 文件中指定的元素的属性值，从而导致配置文件处理出现额外的开销。 可以通过在注册表中设置文件映射大小来实现对应用程序启动的性能改进。 有关文件映射大小的详细信息，请参阅[ &lt; performanceCounters &gt; ](/dotnet/framework/configure-apps/file-schema/trace-debug/performancecounters-element)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Diagnostics.PerformanceCounter> 类创建和使用 <xref:System.Diagnostics.PerformanceCounterType.AverageCount64> 计数器类型。 该示例创建类别、设置计数器、收集计数器中的数据，并调用 <xref:System.Diagnostics.CounterSampleCalculator> 类来解释性能计数器数据。 中间结果和最终结果将显示在控制台窗口中。 有关其他性能计数器类型的其他示例，请参阅 <xref:System.Diagnostics.PerformanceCounterType> 枚举。  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#1)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#1)]
 [!code-vb[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.PerformanceCounterType" />
    <altmember cref="T:System.Diagnostics.CounterCreationData" />
    <altmember cref="T:System.Diagnostics.CounterCreationDataCollection" />
    <altmember cref="T:System.Diagnostics.CounterSample" />
    <altmember cref="T:System.Diagnostics.CounterSampleCalculator" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Diagnostics.PerformanceCounter" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Diagnostics.PerformanceCounter" /> 类的新的只读实例，但不将该实例与任何系统性能计数器或自定义性能计数器关联。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 构造函数的此重载将 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> 、 <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> 和属性设置 <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> 为空字符串 ( "" ) ，并将属性设置 <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> 为本地计算机， ( "。") 。  
  
 此构造函数不会初始化性能计数器，因此它不会将该实例与本地计算机上的现有计数器关联。 若要指向特定的性能计数器，请在 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> 读取任何其他属性或尝试读取计数器之前，设置、和（可选）和属性。 若要写入性能计数器，请将 <xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A> 属性设置为 `false` 。  
  
> [!NOTE]
>  <xref:System.Security.Permissions.HostProtectionAttribute>应用于此成员的特性具有以下 <xref:System.Security.Permissions.HostProtectionAttribute.Resources%2A> 属性值： <xref:System.Security.Permissions.HostProtectionResource.Synchronization> &#124; <xref:System.Security.Permissions.HostProtectionResource.SharedState> 。 <xref:System.Security.Permissions.HostProtectionAttribute> 不影响桌面应用程序（通常通过双击图标、键入命令或在浏览器中输入 URL 来启动这些应用程序）。 有关详细信息，请参阅 <xref:System.Security.Permissions.HostProtectionAttribute> 类或 [SQL Server 编程和宿主保护特性](/dotnet/framework/performance/sql-server-programming-and-host-protection-attributes)。  
  
   
  
## Examples  
 下面的代码示例创建类的默认实例 <xref:System.Diagnostics.PerformanceCounter> 。 创建实例后， <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> 将设置、和属性值，并显示对方法的调用结果 <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> 。  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">此性能计数器关联的性能计数器类别（性能对象）的名称。</param>
        <param name="counterName">性能计数器的名称。</param>
        <summary>初始化 <see cref="T:System.Diagnostics.PerformanceCounter" /> 类的新的只读实例，并将其与本地计算机上指定的系统性能计数器或自定义性能计数器关联。 此构造函数要求该类别包含单个实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参数字符串不区分大小写。  
  
 使用此重载来访问本地计算机上的计数器，该计数器属于包含单个性能计数器类别实例的类别。 如果尝试使用此构造函数将此实例指向 <xref:System.Diagnostics.PerformanceCounter> 包含多个实例的类别，则构造函数将引发异常。 此重载可以访问任何只读或读/写计数器，但会在只读模式下进行访问。 <xref:System.Diagnostics.PerformanceCounter>使用此重载创建的实例不能写入该计数器，即使该计数器本身是可读/写的。  
  
 此构造函数的重载将 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> 和 <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> 属性设置为传入的值，将 <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> 属性设置为本地计算机 "."，并将属性设置 <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> 为空字符串 ( "" ) 。  
  
 此构造函数初始化性能计数器，并将该实例与现有的计数器关联 (系统或) 本地计算机上的自定义计数器。 为和属性传入的值 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> 必须指向本地计算机上的现有性能计数器。  
  
> [!NOTE]
>  若要从 Windows Vista 和更高版本、Windows XP Professional x64 Edition 或 Windows Server 2003 中的非交互式登录会话读取性能计数器，你必须是 "性能监视器用户" 组的成员或具有管理权限。  
>   
>  若要避免提升权限来访问 Windows Vista 中的性能计数器，请将自己添加到性能监视器用户组。  
>   
>  在 Windows Vista 中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问性能计数器的代码，必须首先将你的特权从标准用户提升到管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="categoryName" /> 为空字符串 ("")。  
  
- 或 - 
 <paramref name="counterName" /> 为空字符串 ("")。  
  
- 或 - 
指定的类别不存在。  
  
- 或 - 
指定的类别被标记为多实例，并且要求使用实例名称创建性能计数器。  
  
- 或 - 
 <paramref name="categoryName" /> 和 <paramref name="counterName" /> 已本地化为不同的语言。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="categoryName" /> 或 <paramref name="counterName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">访问 API 时出错。</exception>
        <exception cref="T:System.UnauthorizedAccessException">以不具有管理特权的用户身份正在执行的代码尝试读取性能计数器。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, bool readOnly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, bool readOnly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, readOnly As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, bool readOnly);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string * bool -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName, readOnly)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="readOnly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="categoryName">此性能计数器关联的性能计数器类别（性能对象）的名称。</param>
        <param name="counterName">性能计数器的名称。</param>
        <param name="readOnly">若要以只读模式访问计数器（但计数器本身可能是可读/写的），则为 <see langword="true" />；若要以读/写模式访问计数器，则为 <see langword="false" />。</param>
        <summary>初始化 <see cref="T:System.Diagnostics.PerformanceCounter" /> 类的新的只读或读/写实例，并将其与本地计算机上指定的系统性能计数器或自定义性能计数器关联。 此构造函数要求该类别包含单个实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参数字符串不区分大小写。  
  
 使用此重载访问本地计算机上的只读或读/写计数器，该计数器属于包含单个性能计数器类别实例的类别。 如果尝试使用此构造函数将此实例指向 <xref:System.Diagnostics.PerformanceCounter> 包含多个实例的类别，则构造函数将引发异常。  
  
 构造函数的此重载将 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> 、 <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> 和属性设置 <xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A> 为传入的值，将 <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> 属性设置为本地计算机 "."，并将 <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> 属性设置为空字符串 ( "" ) 。  
  
 此构造函数初始化性能计数器，并将该实例与现有的计数器关联 (系统或) 本地计算机上的自定义计数器。 为和属性传入的值 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> 必须指向本地计算机上的现有性能计数器。 如果指向的性能计数器实例无效，则调用构造函数将引发异常。  
  
> [!NOTE]
>  您可以使用此重载连接到系统计数器，但无法写入系统计数器。 因此， `readOnly` `false` 在连接到系统计数器时，将设置为会导致构造函数引发异常。  
  
> [!NOTE]
>  若要从 Windows Vista 和更高版本、Windows XP Professional x64 Edition 或 Windows Server 2003 中的非交互式登录会话读取性能计数器，你必须是 "性能监视器用户" 组的成员或具有管理权限。  
>   
>  若要避免提升权限来访问 Windows Vista 中的性能计数器，请将自己添加到性能监视器用户组。  
>   
>  在 Windows Vista 中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问性能计数器的代码，必须首先将你的特权从标准用户提升到管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
   
  
## Examples  
 下面的代码示例创建类的一个实例 <xref:System.Diagnostics.PerformanceCounter> 。 该示例传入类别名称、计数器名称和指示计数器不是只读的标志值。 此代码示例是类的更大示例的一部分 <xref:System.Diagnostics.PerformanceCounter> 。  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#2](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#2)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#2](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#2)]
 [!code-vb[PerformanceCounterType.AverageCounter64#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="categoryName" /> 是空字符串 ("")。  
  
- 或 - 
<paramref name="counterName" /> 是空字符串 ("")。  
  
- 或 - 
指定的类别不存在。 （如果 <paramref name="readOnly" /> 为 <see langword="true" />）。  
  
- 或 - 
指定的类别不是 .NET Framework 自定义类别（如果 <paramref name="readOnly" /> 为 <see langword="false" />）。  
  
- 或 - 
指定的类别被标记为多实例，并且要求使用实例名称创建性能计数器。  
  
- 或 - 
 <paramref name="categoryName" /> 和 <paramref name="counterName" /> 已本地化为不同的语言。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="categoryName" /> 或 <paramref name="counterName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">访问 API 时出错。</exception>
        <exception cref="T:System.UnauthorizedAccessException">以不具有管理特权的用户身份正在执行的代码尝试读取性能计数器。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, string instanceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, string instanceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, instanceName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, System::String ^ instanceName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string * string -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName, instanceName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="instanceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">此性能计数器关联的性能计数器类别（性能对象）的名称。</param>
        <param name="counterName">性能计数器的名称。</param>
        <param name="instanceName">性能计数器类别实例的名称，或者为空字符串 ("")（如果该类别包含单个实例）。</param>
        <summary>初始化 <see cref="T:System.Diagnostics.PerformanceCounter" /> 类的新的只读实例，并将其与本地计算机上指定的系统性能计数器或自定义性能计数器及类别实例关联。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参数字符串不区分大小写。  
  
 构造函数的此重载将 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> 、 <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> 和属性设置 <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> 为传入的值，并将 <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> 属性设置为本地计算机 "."。  
  
 此构造函数初始化性能计数器，并将该实例与现有的计数器关联 (系统或) 本地计算机上的自定义计数器。 为 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> 、和属性传入的值 <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> 必须指向本地计算机上的现有性能计数器。 如果指向的性能计数器实例无效，则调用构造函数将引发异常。  
  
 此重载可以访问任何只读或读/写计数器，但会在只读模式下进行访问。 <xref:System.Diagnostics.PerformanceCounter>使用此重载创建的实例不能写入该计数器，即使该计数器本身是可读/写的。  
  
 若要创建性能类别实例，请 `instanceName` 在 <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> 构造函数上指定。 如果由指定的类别实例 `instanceName` 已存在，则新的对象将引用现有的类别实例。  
  
> [!NOTE]
>  若要在 Windows Vista、Windows XP Professional x64 Edition 或 Windows Server 2003 中读取性能计数器，你必须是 "性能监视器用户" 组的成员或具有管理权限。  
>   
>  若要避免提升权限来访问 Windows Vista 中的性能计数器，请将自己添加到性能监视器用户组。  
>   
>  在 Windows Vista 中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问性能计数器的代码，必须首先将你的特权从标准用户提升到管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="categoryName" /> 为空字符串 ("")。  
  
- 或 - 
 <paramref name="counterName" /> 为空字符串 ("")。  
  
- 或 - 
指定的类别无效。  
  
- 或 - 
指定的类别被标记为多实例，并且要求使用实例名称创建性能计数器。  
  
- 或 - 
 <paramref name="instanceName" /> 的长度超过 127 个字符。  
  
- 或 - 
 <paramref name="categoryName" /> 和 <paramref name="counterName" /> 已本地化为不同的语言。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="categoryName" /> 或 <paramref name="counterName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">访问 API 时出错。</exception>
        <exception cref="T:System.UnauthorizedAccessException">以不具有管理特权的用户身份正在执行的代码尝试读取性能计数器。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, string instanceName, bool readOnly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, string instanceName, bool readOnly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, instanceName As String, readOnly As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, System::String ^ instanceName, bool readOnly);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string * string * bool -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName, instanceName, readOnly)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="instanceName" Type="System.String" />
        <Parameter Name="readOnly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="categoryName">此性能计数器关联的性能计数器类别（性能对象）的名称。</param>
        <param name="counterName">性能计数器的名称。</param>
        <param name="instanceName">性能计数器类别实例的名称，或者为空字符串 ("")（如果该类别包含单个实例）。</param>
        <param name="readOnly">若要以只读模式访问计数器，则为 <see langword="true" />；若要以读/写模式访问计数器，则为 <see langword="false" />。</param>
        <summary>初始化 <see cref="T:System.Diagnostics.PerformanceCounter" /> 类的新的只读实例或读/写实例，并将其与本地计算机上指定的系统性能计数器或自定义性能计数器及类别实例关联。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参数字符串不区分大小写。  
  
 使用此重载可以在只读模式或读/写模式下访问性能计数器。  
  
 构造函数的此重载将 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> 、 <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> 和属性设置 <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> 为传入的值，并将 <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> 属性设置为本地计算机 "."。  
  
 此构造函数初始化性能计数器，并将该实例与现有的计数器关联 (系统或) 本地计算机上的自定义计数器。 为 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> 、和属性传入的值 <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> 必须指向本地计算机上的现有性能计数器。 如果指向的性能计数器实例无效，则调用构造函数将引发异常。  
  
> [!NOTE]
>  您可以使用此重载连接到系统计数器，但无法写入系统计数器。 因此， `readOnly` `false` 在连接到系统计数器时，将设置为会导致构造函数引发异常。  
  
 若要创建性能类别实例，请 `instanceName` 在 <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> 构造函数上指定。 如果由指定的类别实例 `instanceName` 已存在，则新的对象将引用现有的类别实例。  
  
> [!NOTE]
>  若要在 Windows Vista、Windows XP Professional x64 Edition 或 Windows Server 2003 中读取性能计数器，你必须是 "性能监视器用户" 组的成员或具有管理权限。  
>   
>  若要避免提升权限来访问 Windows Vista 中的性能计数器，请将自己添加到性能监视器用户组。  
>   
>  在 Windows Vista 中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问性能计数器的代码，必须首先将你的特权从标准用户提升到管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="categoryName" /> 为空字符串 ("")。  
  
- 或 - 
 <paramref name="counterName" /> 为空字符串 ("")。  
  
- 或 - 
请求的读/写权限设置对此计数器无效。  
  
- 或 - 
指定的类别不存在（如果 <paramref name="readOnly" /> 为 <see langword="true" />）。  
  
- 或 - 
指定的类别不是 .NET Framework 自定义类别（如果 <paramref name="readOnly" /> 为 <see langword="false" />）。  
  
- 或 - 
指定的类别被标记为多实例，并且要求使用实例名称创建性能计数器。  
  
- 或 - 
 <paramref name="instanceName" /> 的长度超过 127 个字符。  
  
- 或 - 
 <paramref name="categoryName" /> 和 <paramref name="counterName" /> 已本地化为不同的语言。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="categoryName" /> 或 <paramref name="counterName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">访问 API 时出错。</exception>
        <exception cref="T:System.UnauthorizedAccessException">以不具有管理特权的用户身份正在执行的代码尝试读取性能计数器。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, string instanceName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, string instanceName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, instanceName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, System::String ^ instanceName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string * string * string -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName, instanceName, machineName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="instanceName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">此性能计数器关联的性能计数器类别（性能对象）的名称。</param>
        <param name="counterName">性能计数器的名称。</param>
        <param name="instanceName">性能计数器类别实例的名称，或者为空字符串 ("")（如果该类别包含单个实例）。</param>
        <param name="machineName">性能计数器及其关联的类别所在的计算机。</param>
        <summary>初始化 <see cref="T:System.Diagnostics.PerformanceCounter" /> 类的新的只读实例，并将其与指定计算机上指定的系统性能计数器或自定义性能计数器及类别实例关联。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参数字符串不区分大小写。  
  
 构造函数的此重载将 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> 、 <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> 、 <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> 和属性设置 <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> 为传入的值。  
  
 此构造函数初始化性能计数器，并将该实例与现有计数器关联， (系统或自定义计数器在指定计算机上) 。 为 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> 、和属性传入的值 <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> 必须指向现有性能计数器。 如果指向的性能计数器实例无效，则调用构造函数将引发异常。 此重载可以访问任何只读或读/写计数器，但会在只读模式下进行访问。 <xref:System.Diagnostics.PerformanceCounter>使用此重载创建的实例不能写入该计数器，即使该计数器本身是可读/写的。  
  
> [!NOTE]
>  不能写入远程性能计数器。 无重载允许您指定 <xref:System.Diagnostics.PerformanceCounter> 连接到远程计算机的类的读/写实例。  
  
 若要创建性能类别实例，请 `instanceName` 在 <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> 构造函数上指定。 如果由指定的类别实例 `instanceName` 已存在，则新的对象将引用现有的类别实例。  
  
> [!NOTE]
>  若要在 Windows Vista、Windows XP Professional x64 Edition 或 Windows Server 2003 中读取性能计数器，你必须是 "性能监视器用户" 组的成员或具有管理权限。  
>   
>  若要避免提升权限来访问 Windows Vista 中的性能计数器，请将自己添加到性能监视器用户组。  
>   
>  在 Windows Vista 中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问性能计数器的代码，必须首先将你的特权从标准用户提升到管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
> [!NOTE]
>  在 Windows Vista 中，当远程计算机是工作组的成员时，您可能需要禁用 UAC，以便不筛选本地用户帐户，并将其提升为管理员帐户。 出于安全原因，禁用 UAC 应该是最后一种手段。 有关禁用 UAC 的信息，请参阅 [用户帐户控制和 WMI](https://go.microsoft.com/fwlink/?LinkId=91617)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="categoryName" /> 为空字符串 ("")。  
  
- 或 - 
 <paramref name="counterName" /> 为空字符串 ("")。  
  
- 或 - 
请求的读/写权限设置对此计数器无效。  
  
- 或 - 
指定的计算机上不存在该计数器。  
  
- 或 - 
指定的类别被标记为多实例，并且要求使用实例名称创建性能计数器。  
  
- 或 - 
 <paramref name="instanceName" /> 的长度超过 127 个字符。  
  
- 或 - 
 <paramref name="categoryName" /> 和 <paramref name="counterName" /> 已本地化为不同的语言。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> 参数无效。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="categoryName" /> 或 <paramref name="counterName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">访问 API 时出错。</exception>
        <exception cref="T:System.UnauthorizedAccessException">以不具有管理特权的用户身份正在执行的代码尝试读取性能计数器。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="performanceCounter.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>开始初始化在窗体上使用或由另一个组件使用的 <see cref="T:System.Diagnostics.PerformanceCounter" /> 实例。 此初始化在运行时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]设计环境使用此方法开始初始化在窗体上使用或由另一个组件使用的组件。 <xref:System.Diagnostics.PerformanceCounter.EndInit%2A>方法结束初始化。 使用 <xref:System.Diagnostics.PerformanceCounter.BeginInit%2A> 和 <xref:System.Diagnostics.PerformanceCounter.EndInit%2A> 方法可防止在完全初始化组件之前使用该组件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CategoryName">
      <MemberSignature Language="C#" Value="public string CategoryName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CategoryName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CategoryName" />
      <MemberSignature Language="VB.NET" Value="Public Property CategoryName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CategoryName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CategoryName : string with get, set" Usage="System.Diagnostics.PerformanceCounter.CategoryName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue("")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue("")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.RecommendedAsConfigurable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.RecommendedAsConfigurable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter("System.Diagnostics.Design.CategoryValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter("System.Diagnostics.Design.CategoryValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter("System.Diagnostics.Design.CategoryValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter("System.Diagnostics.Design.CategoryValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.SettingsBindable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.SettingsBindable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter("System.Diagnostics.Design.CategoryValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter("System.Diagnostics.Design.CategoryValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置此性能计数器的性能计数器类别的名称。</summary>
        <value>此性能计数器关联的性能计数器类别（性能对象）的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>穦 `Performance Object`字段的性能计数器管理器 MMC 管理单元中的`Add Counter`对话框。  
  
 性能计数器监视计算机上类别或性能对象的行为。 类别包括物理组件 (如处理器、磁盘和内存) 和系统对象 (如进程和线程) 。 与相同性能对象相关的系统计数器将分组到一个指示它们常见焦点的类别。 当您创建类的实例时 <xref:System.Diagnostics.PerformanceCounter> ，您首先指示组件将与之交互的类别，然后从该类别中选择一个计数器。  
  
 例如，一个 Windows 计数器类别为内存类别。 此类别中的系统计数器跟踪内存数据，如可用字节数和缓存的字节数。 如果要处理缓存在应用程序中的字节，则需创建组件的实例 <xref:System.Diagnostics.PerformanceCounter> ，将其连接到内存类别，然后选择相应的计数器 (在本例中，从该类别缓存的字节) 。  
  
 尽管你的系统提供了更多的计数器类别，但你可能会经常与之交互的类别包括缓存、内存、对象、PhysicalDisk、进程、处理器、服务器、系统和线程类别。  
  
   
  
## Examples  
 下面的代码示例创建类的默认实例 <xref:System.Diagnostics.PerformanceCounter> 。 创建实例后， <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> 将设置、和属性值，并显示对方法的调用结果 <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> 。  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Diagnostics.PerformanceCounter.CategoryName" /> 为 <see langword="null" />。</exception>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="performanceCounter.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭性能计数器并释放由此性能计数器实例分配的所有资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将此 <xref:System.Diagnostics.PerformanceCounter> 实例与驻留在服务器上的性能计数器相关联时，系统会初始化实例并分配内存以包含计数器示例信息。 <xref:System.Diagnostics.PerformanceCounter.Close%2A>方法释放由对象分配的资源。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseSharedResources">
      <MemberSignature Language="C#" Value="public static void CloseSharedResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CloseSharedResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.CloseSharedResources" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CloseSharedResources ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CloseSharedResources();" />
      <MemberSignature Language="F#" Value="static member CloseSharedResources : unit -&gt; unit" Usage="System.Diagnostics.PerformanceCounter.CloseSharedResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放由计数器分配的性能计数器库共享状态。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CounterHelp">
      <MemberSignature Language="C#" Value="public string CounterHelp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CounterHelp" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CounterHelp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CounterHelp As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CounterHelp { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CounterHelp : string" Usage="System.Diagnostics.PerformanceCounter.CounterHelp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Diagnostics.MonitoringDescription("PC_CounterHelp")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.MonitoringDescription("PC_CounterHelp")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName Language="C#">[System.Diagnostics.MonitoringDescription("A description describing the counter.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.MonitoringDescription("A description describing the counter.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName Language="C#">[System.MonoTODO]</AttributeName>
          <AttributeName Language="F#">[&lt;System.MonoTODO&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此性能计数器的说明。</summary>
        <value>此性能计数器测量的项或数量的说明。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 性能计数器管理器 MMC 管理单元的 "添加计数器" 对话框在 <xref:System.Diagnostics.PerformanceCounter.CounterHelp%2A> 用户从计数器列表中选择计数器并单击 "说明" 按钮时显示文本。  
  
 创建新计数器时，请使用 <xref:System.Diagnostics.PerformanceCounter.CounterHelp%2A> 文本来描述计数器监视器的操作，以便用户可以确定是否将计数器添加到系统监视器的显示内容中。  
  
> [!NOTE]
>  如果属性的值 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 为 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> ，并且性能计数器类别是使用 .NET Framework 版本1.0 或1.1 创建的，则 <xref:System.InvalidOperationException> 会引发。 使用早期版本创建的性能计数器类别使用全局共享内存，并且的值 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 必须是 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global> 。 如果在 .NET Framework 的版本1.0 或1.1 上运行的应用程序未使用该类别，请删除并重新创建该类别。  
  
> [!NOTE]
>  若要在 Windows Vista、Windows XP Professional x64 Edition 或 Windows Server 2003 中读取性能计数器，你必须是 "性能监视器用户" 组的成员或具有管理权限。  
>   
>  若要避免提升权限来访问 Windows Vista 中的性能计数器，请将自己添加到性能监视器用户组。  
>   
>  在 Windows Vista 中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问性能计数器的代码，必须首先将你的特权从标准用户提升到管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Diagnostics.PerformanceCounter" /> 实例未与性能计数器关联。  
  
- 或 - 
使用全局共享内存时，<see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> 属性设置为 <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />。</exception>
        <exception cref="T:System.UnauthorizedAccessException">以不具有管理特权的用户身份正在执行的代码尝试读取性能计数器。</exception>
      </Docs>
    </Member>
    <Member MemberName="CounterName">
      <MemberSignature Language="C#" Value="public string CounterName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CounterName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CounterName" />
      <MemberSignature Language="VB.NET" Value="Public Property CounterName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CounterName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CounterName : string with get, set" Usage="System.Diagnostics.PerformanceCounter.CounterName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue("")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue("")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.RecommendedAsConfigurable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.RecommendedAsConfigurable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter("System.Diagnostics.Design.CounterNameConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter("System.Diagnostics.Design.CounterNameConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter("System.Diagnostics.Design.CounterNameConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter("System.Diagnostics.Design.CounterNameConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.SettingsBindable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.SettingsBindable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter("System.Diagnostics.Design.CounterNameConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter("System.Diagnostics.Design.CounterNameConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置与此 <see cref="T:System.Diagnostics.PerformanceCounter" /> 实例关联的性能计数器的名称。</summary>
        <value>计数器的名称，它一般描述计数的数量。 此名称显示在性能计数器管理器 MMC 管理单元的“添加计数器”对话框的计数器列表中。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以从 Windows 性能管理器的 " [添加计数器" 对话框](https://go.microsoft.com/fwlink/p/?LinkId=257854)获取可用的预先存在的计数器的列表。  
  
   
  
## Examples  
 下面的代码示例演示如何将属性设置 <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> 为典型计数器名称。  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Diagnostics.PerformanceCounter.CounterName" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="CounterType">
      <MemberSignature Language="C#" Value="public System.Diagnostics.PerformanceCounterType CounterType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.PerformanceCounterType CounterType" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CounterType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CounterType As PerformanceCounterType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::PerformanceCounterType CounterType { System::Diagnostics::PerformanceCounterType get(); };" />
      <MemberSignature Language="F#" Value="member this.CounterType : System.Diagnostics.PerformanceCounterType" Usage="System.Diagnostics.PerformanceCounter.CounterType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Diagnostics.MonitoringDescription("PC_CounterType")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.MonitoringDescription("PC_CounterType")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName Language="C#">[System.Diagnostics.MonitoringDescription("The type of the counter.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.MonitoringDescription("The type of the counter.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联的性能计数器的计数器类型。</summary>
        <value><see cref="T:System.Diagnostics.PerformanceCounterType" />，它既描述计数器如何与监视应用程序交互，又描述计数器包含的值的特性（例如计算所得和非计算所得）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.PerformanceCounterType>枚举包含可与之交互的性能计数器的类型。 某些计数器类型表示计算所得的值，例如系统所采用的计数器度量值的平均值。 其他类型表示原始值或未计算的值。 下表显示了将与最常交互的计数器类型。  
  
|计数器的责任|PerformanceCounterType 值|示例|  
|------------------------------|----------------------------------|-------------|  
|维护项或操作的简单计数。|`NumberOfItems32`|跟踪作为32位整数收到的订单数。|  
|维护更高容量的简单计数。|`NumberOfItems64`|跟踪容量非常大、存储为64位整数的站点的订单数。|  
|跟踪每秒项或操作的数量。|`RateOfCountsPerSecond32`|跟踪站点上每秒接收的订单数。|  
|跟踪每秒更大容量的项或操作。|`RateOfCountsPerSecond64`|跟踪每秒在容量非常大的站点上收到的订单。|  
|计算执行进程或处理项的平均时间|`AverageTimer32`|计算订单处理的平均时间。|  
  
 如果创建的计数器的类型需要使用相应的基本计数器，则必须在传入方法的中声明计数器和基 <xref:System.Diagnostics.CounterCreationDataCollection> <xref:System.Diagnostics.PerformanceCounterCategory.Create%2A?displayProperty=nameWithType> 。  
  
> [!NOTE]
>  如果属性的值 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 为 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> ，并且性能计数器类别是使用 .NET Framework 版本1.0 或1.1 创建的，则 <xref:System.InvalidOperationException> 会引发。 使用早期版本创建的性能计数器类别使用全局共享内存，并且的值 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 必须是 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global> 。 如果在 .NET Framework 的版本1.0 或1.1 上运行的应用程序未使用该类别，请删除并重新创建该类别。  
  
> [!NOTE]
>  若要在 Windows Vista、Windows XP Professional x64 Edition 或 Windows Server 2003 中读取性能计数器，你必须是 "性能监视器用户" 组的成员或具有管理权限。  
>   
>  若要避免提升权限来访问 Windows Vista 中的性能计数器，请将自己添加到性能监视器用户组。  
>   
>  在 Windows Vista 中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问性能计数器的代码，必须首先将你的特权从标准用户提升到管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例未与性能计数器正确关联。  
  
- 或 - 
使用全局共享内存时，<see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> 属性设置为 <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />。</exception>
        <exception cref="T:System.UnauthorizedAccessException">以不具有管理特权的用户身份正在执行的代码尝试读取性能计数器。</exception>
        <altmember cref="T:System.Diagnostics.PerformanceCounterType" />
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public long Decrement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Decrement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Decrement" />
      <MemberSignature Language="VB.NET" Value="Public Function Decrement () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Decrement();" />
      <MemberSignature Language="F#" Value="member this.Decrement : unit -&gt; int64" Usage="performanceCounter.Decrement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通过有效的原子操作使关联的性能计数器减一。</summary>
        <returns>减少后的计数器值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只能写入自定义计数器。 所有系统计数器均为只读。  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>、 <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A> 和 <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> 方法使用 interlocks 更新计数器值。 这有助于在多线程或多进程方案中保持计数器值的准确性，但也会导致性能下降。 如果不需要联锁操作提供的准确性，可以 <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> 直接更新属性，使性能提高5倍。  但在多线程方案中，对计数器值的某些更新可能会被忽略，导致数据不准确。  
  
> [!NOTE]
>  如果属性的值 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 为 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> ，并且性能计数器类别是使用 .NET Framework 版本1.0 或1.1 创建的，则 <xref:System.InvalidOperationException> 会引发。 使用早期版本创建的性能计数器类别使用全局共享内存，并且的值 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 必须是 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global> 。 如果在 .NET Framework 的版本1.0 或1.1 上运行的应用程序未使用该类别，请删除并重新创建该类别。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">该计数器是只读的，因而应用程序无法使之减少。  
  
- 或 - 
此实例未与性能计数器正确关联。  
  
- 或 - 
使用全局共享内存时，<see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> 属性设置为 <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">访问 API 时出错。</exception>
        <threadsafe>此方法是线程安全的。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="DefaultFileMappingSize">
      <MemberSignature Language="C#" Value="public static int DefaultFileMappingSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static int32 DefaultFileMappingSize" />
      <MemberSignature Language="DocId" Value="F:System.Diagnostics.PerformanceCounter.DefaultFileMappingSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared DefaultFileMappingSize As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static int DefaultFileMappingSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultFileMappingSize : int" Usage="System.Diagnostics.PerformanceCounter.DefaultFileMappingSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Obsolete("This field has been deprecated and is not used.  Use machine.config or an application configuration file to set the size of the PerformanceCounter file mapping.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("This field has been deprecated and is not used.  Use machine.config or an application configuration file to set the size of the PerformanceCounter file mapping.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName Language="C#">[System.Obsolete]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定由性能计数器共享的全局内存的大小（以字节为单位）。 默认大小为 524,288 个字节。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="performanceCounter.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="performanceCounter.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>结束在窗体上使用或由另一组件使用的 <see cref="T:System.Diagnostics.PerformanceCounter" /> 实例的初始化。 此初始化在运行时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]设计环境使用此方法来结束在窗体上使用或由另一个组件使用的组件的初始化。 <xref:System.Diagnostics.PerformanceCounter.BeginInit%2A>方法启动初始化。 使用 <xref:System.Diagnostics.PerformanceCounter.BeginInit%2A> 和 <xref:System.Diagnostics.PerformanceCounter.EndInit%2A> 方法可防止在完全初始化组件之前使用该组件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public long Increment ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Increment() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Increment" />
      <MemberSignature Language="VB.NET" Value="Public Function Increment () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Increment();" />
      <MemberSignature Language="F#" Value="member this.Increment : unit -&gt; int64" Usage="performanceCounter.Increment " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通过有效的原子操作使关联的性能计数器增加一。</summary>
        <returns>增加后的计数器值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只能写入自定义计数器。 所有系统计数器均为只读。  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>、 <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A> 和 <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> 方法使用 interlocks 更新计数器值。 这有助于在多线程或多进程方案中保持计数器值的准确性，但也会导致性能下降。 如果不需要联锁操作提供的准确性，可以 <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> 直接更新属性，使性能提高5倍。  但在多线程方案中，对计数器值的某些更新可能会被忽略，导致数据不准确。  
  
> [!NOTE]
>  如果属性的值 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 为 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> ，并且性能计数器类别是使用 .NET Framework 版本1.0 或1.1 创建的，则 <xref:System.InvalidOperationException> 会引发。 使用早期版本创建的性能计数器类别使用全局共享内存，并且的值 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 必须是 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global> 。 如果在 .NET Framework 的版本1.0 或1.1 上运行的应用程序未使用该类别，请删除并重新创建该类别。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">该计数器是只读的，因此应用程序无法递增它的值。  
  
- 或 - 
此实例未与性能计数器正确关联。  
  
- 或 - 
使用全局共享内存时，<see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> 属性设置为 <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">访问 API 时出错。</exception>
        <threadsafe>此方法是线程安全的。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="IncrementBy">
      <MemberSignature Language="C#" Value="public long IncrementBy (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 IncrementBy(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.IncrementBy(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function IncrementBy (value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long IncrementBy(long value);" />
      <MemberSignature Language="F#" Value="member this.IncrementBy : int64 -&gt; int64" Usage="performanceCounter.IncrementBy value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">要增加的值。 （负值使计数器减少。）</param>
        <summary>通过有效的原子操作，使关联的性能计数器的值增加或减少指定的量。</summary>
        <returns>新的计数器值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只能写入自定义计数器。 所有系统计数器均为只读。  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>、 <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A> 和 <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> 方法使用 interlocks 更新计数器值。 这有助于在多线程或多进程方案中保持计数器值的准确性，但也会导致性能下降。 如果不需要联锁操作提供的准确性，可以 <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> 直接更新属性，使性能提高5倍。  但在多线程方案中，对计数器值的某些更新可能会被忽略，导致数据不准确。  
  
> [!NOTE]
>  如果属性的值 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 为 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> ，并且性能计数器类别是使用 .NET Framework 版本1.0 或1.1 创建的，则 <xref:System.InvalidOperationException> 会引发。 使用早期版本创建的性能计数器类别使用全局共享内存，并且的值 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 必须是 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global> 。 如果在 .NET Framework 的版本1.0 或1.1 上运行的应用程序未使用该类别，请删除并重新创建该类别。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A> 方法将增量添加到计数器。 此代码示例是类的更大示例的一部分 <xref:System.Diagnostics.PerformanceCounter> 。  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#3)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#3)]
 [!code-vb[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">该计数器是只读的，因此应用程序无法递增它的值。  
  
- 或 - 
此实例未与性能计数器正确关联。  
  
- 或 - 
使用全局共享内存时，<see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> 属性设置为 <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">访问 API 时出错。</exception>
        <threadsafe>此方法是线程安全的。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="InstanceLifetime">
      <MemberSignature Language="C#" Value="public System.Diagnostics.PerformanceCounterInstanceLifetime InstanceLifetime { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.PerformanceCounterInstanceLifetime InstanceLifetime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceLifetime As PerformanceCounterInstanceLifetime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::PerformanceCounterInstanceLifetime InstanceLifetime { System::Diagnostics::PerformanceCounterInstanceLifetime get(); void set(System::Diagnostics::PerformanceCounterInstanceLifetime value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceLifetime : System.Diagnostics.PerformanceCounterInstanceLifetime with get, set" Usage="System.Diagnostics.PerformanceCounter.InstanceLifetime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName Language="C#">[System.MonoTODO]</AttributeName>
          <AttributeName Language="F#">[&lt;System.MonoTODO&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterInstanceLifetime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置进程的生存期。</summary>
        <value><see cref="T:System.Diagnostics.PerformanceCounterInstanceLifetime" /> 值之一。 默认为 <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Global" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用 .NET Framework 版本1.0 或1.1 创建性能计数器类别，则它将使用全局共享内存，并且的值 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 必须为 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global> 。 如果在 .NET Framework 的版本1.0 或1.1 上运行的应用程序未使用该类别，请删除并重新创建该类别。  
  
> [!NOTE]
>  如果属性的值 <xref:System.Diagnostics.PerformanceCounter.CounterType%2A> 为，则该 <xref:System.Diagnostics.PerformanceCounterCategoryType.SingleInstance> <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 性能计数器的值必须为 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">设置的值不是 <see cref="T:System.Diagnostics.PerformanceCounterInstanceLifetime" /> 枚举的成员。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> 是在初始化 <see cref="T:System.Diagnostics.PerformanceCounter" /> 后设置的。</exception>
      </Docs>
    </Member>
    <Member MemberName="InstanceName">
      <MemberSignature Language="C#" Value="public string InstanceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InstanceName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.InstanceName" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ InstanceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceName : string with get, set" Usage="System.Diagnostics.PerformanceCounter.InstanceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue("")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue("")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.ReadOnly(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ReadOnly(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.RecommendedAsConfigurable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.RecommendedAsConfigurable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter("System.Diagnostics.Design.InstanceNameConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter("System.Diagnostics.Design.InstanceNameConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter("System.Diagnostics.Design.InstanceNameConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter("System.Diagnostics.Design.InstanceNameConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.SettingsBindable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.SettingsBindable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter("System.Diagnostics.Design.InstanceNameConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter("System.Diagnostics.Design.InstanceNameConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置此性能计数器的实例名称。</summary>
        <value>性能计数器类别实例的名称，或者为空字符串 ("")（如果该计数器是单实例计数器）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  实例名称长度必须少于128个字符。  
  
 在某些情况下，类别将细分为多个实例，这些实例跟踪与类别相关的对象的多个匹配项的数据。 实例作为整体应用于类别，而不是应用于单个计数器。 类别中的每个计数器都有为该类别定义的每个实例。 例如，"进程" 类别包含名为 "空闲" 和 "系统" 的实例。 进程类别中的每个计数器都包含每个实例的数据，并显示有关空闲进程或系统进程的信息。  
  
 许多类别不包含多个实例，因此您可以将此属性保留为空，以指示没有实例与该类别关联。  
  
 如果此 <xref:System.Diagnostics.PerformanceCounter> 实例指向非自定义类别，则只能从现有类别实例中进行选择。 您只能在自定义类别中创建新类别实例，这允许您根据需要定义任意数量的计数器和类别实例。  
  
 若要创建性能类别实例，请 `instanceName` 在 <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> 构造函数上指定。 如果由指定的类别实例 `instanceName` 已存在，则新的对象将引用现有的类别实例。  
  
> [!NOTE]
>  在实例名称中不要使用字符 " ("、") "、"#"、" \\ " 或 "/"。 如果使用其中任何一个字符，则性能控制台 (参阅 [运行时分析](/dotnet/framework/debug-trace-profile/runtime-profiling)) 可能无法正确显示实例值。  
  
 如果实例名称是自动生成的，并且可能包含字符 " ("、") "、"#"、" \\ " 或 "/"，请使用下表中的字符映射。  
  
|字符|映射字符|  
|---------------|----------------------|  
|(|[|  
|)|]|  
|#|_|  
|\|_|  
|/|_|  
  
 <xref:System.AppDomain.FriendlyName%2A> <xref:System.AppDomain> 从属性获取的对象的属性 <xref:System.AppDomain.CurrentDomain%2A?displayProperty=nameWithType> 是可以包含无效字符的实例名称的常见源。  
  
   
  
## Examples  
 下面的代码示例创建类的默认实例 <xref:System.Diagnostics.PerformanceCounter> 。 创建实例后， <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> 将设置、和属性值，并显示对方法的调用结果 <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> 。  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Diagnostics.PerformanceCounter.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(".")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(".")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.RecommendedAsConfigurable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.RecommendedAsConfigurable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.SettingsBindable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.SettingsBindable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName Language="C#">[System.MonoTODO("What's the machine name format?")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.MonoTODO("What's the machine name format?")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置此性能计数器的计算机名。</summary>
        <value>性能计数器及其关联的类别所在的服务器。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您只能向驻留在本地计算机上的计数器写入值。 但是，你可以从企业中具有访问权限的任何计算机读取计数器值。  
  
 将 <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> 属性设置为指向远程计算机时， <xref:System.Diagnostics.PerformanceCounter> 实例将尝试打开该计算机上的计数器。 如果该计数器不存在，则设置此属性将引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.PerformanceCounter.MachineName" /> 格式无效。</exception>
      </Docs>
    </Member>
    <Member MemberName="NextSample">
      <MemberSignature Language="C#" Value="public System.Diagnostics.CounterSample NextSample ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Diagnostics.CounterSample NextSample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.NextSample" />
      <MemberSignature Language="VB.NET" Value="Public Function NextSample () As CounterSample" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Diagnostics::CounterSample NextSample();" />
      <MemberSignature Language="F#" Value="member this.NextSample : unit -&gt; System.Diagnostics.CounterSample" Usage="performanceCounter.NextSample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.CounterSample</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取计数器样本，并为其返回原始值（即未经过计算的值）。</summary>
        <returns>一个 <see cref="T:System.Diagnostics.CounterSample" />，它代表系统为此计数器获取的下一原始值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法通常用于包含未计算的值的计数器。  
  
> [!NOTE]
>  如果属性的值 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 为 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> ，并且性能计数器类别是使用 .NET Framework 版本1.0 或1.1 创建的，则 <xref:System.InvalidOperationException> 会引发。 使用早期版本创建的性能计数器类别使用全局共享内存，并且的值 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 必须是 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global> 。 如果在 .NET Framework 的版本1.0 或1.1 上运行的应用程序未使用该类别，请删除并重新创建该类别。  
  
> [!NOTE]
>  若要在 Windows Vista、Windows XP Professional x64 Edition 或 Windows Server 2003 中读取性能计数器，你必须是 "性能监视器用户" 组的成员或具有管理权限。  
>   
>  若要避免提升权限来访问 Windows Vista 中的性能计数器，请将自己添加到性能监视器用户组。  
>   
>  在 Windows Vista 中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问性能计数器的代码，必须首先将你的特权从标准用户提升到管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Diagnostics.PerformanceCounter.NextSample%2A> 方法来获取计数器的下一个未计算值。 此代码示例是类的更大示例的一部分 <xref:System.Diagnostics.PerformanceCounter> 。  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#3)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#3)]
 [!code-vb[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例未与性能计数器正确关联。  
  
- 或 - 
使用全局共享内存时，<see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> 属性设置为 <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">访问 API 时出错。</exception>
        <exception cref="T:System.UnauthorizedAccessException">以不具有管理特权的用户身份正在执行的代码尝试读取性能计数器。</exception>
      </Docs>
    </Member>
    <Member MemberName="NextValue">
      <MemberSignature Language="C#" Value="public float NextValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float32 NextValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.NextValue" />
      <MemberSignature Language="VB.NET" Value="Public Function NextValue () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; float NextValue();" />
      <MemberSignature Language="F#" Value="member this.NextValue : unit -&gt; single" Usage="performanceCounter.NextValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取计数器样本并为其返回计算所得值。</summary>
        <returns>系统为此计数器获取的下一计算所得值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如果计数器的计算值依赖于两个计数器读取，则第一个读取操作将返回0.0。 重置性能计数器属性以指定另一个计数器等效于创建新的性能计数器，并且第一个使用新属性的读取操作返回0.0。 建议调用方法之间的延迟时间 <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> 为1秒，以允许计数器执行下一个增量读取。  
  
> [!NOTE]
>  若要读取性能计数器，必须具有管理权限。 在 Windows Vista 中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问性能计数器的代码，必须首先将你的特权从标准用户提升到管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
   
  
## Examples  
 下面的代码示例创建一个 <xref:System.Diagnostics.PerformanceCounterType.ElapsedTime> 计数器，并使用 <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> 方法在某个时间段内显示计数器的值。  
  
 [!code-cpp[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/CPP/elapsedtime.cpp#2)]
 [!code-csharp[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/CS/elapsedtime.cs#2)]
 [!code-vb[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/VB/elapsedtime.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例未与性能计数器正确关联。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">访问 API 时出错。</exception>
        <exception cref="T:System.UnauthorizedAccessException">以不具有管理特权的用户身份正在执行的代码尝试读取性能计数器。</exception>
      </Docs>
    </Member>
    <Member MemberName="RawValue">
      <MemberSignature Language="C#" Value="public long RawValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 RawValue" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.RawValue" />
      <MemberSignature Language="VB.NET" Value="Public Property RawValue As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long RawValue { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.RawValue : int64 with get, set" Usage="System.Diagnostics.PerformanceCounter.RawValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Diagnostics.MonitoringDescription("PC_RawValue")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.MonitoringDescription("PC_RawValue")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName Language="C#">[System.Diagnostics.MonitoringDescription("The raw value of the counter.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.MonitoringDescription("The raw value of the counter.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置此计数器的原始值（即未经过计算的值）。</summary>
        <value>计数器的原始值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果计数器类型为32位，并且您尝试将此属性设置为一个太大而无法容纳的值，该属性会将该值截断为32位。 在本地计算机上读取自定义计数器时，如果 <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> 原始值足够，则使用属性而不是计算值可以显著提高性能。  
  
 如果要读取的计数器是只读的，则获取属性将在 <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> 调用属性时采样计数器。 此操作等效于初始调用 <xref:System.Diagnostics.PerformanceCounter.NextSample%2A> 方法。 如果随后调用 <xref:System.Diagnostics.PerformanceCounter.NextSample%2A> ，则可以对两个调用返回的值执行计算。  
  
 由于系统计数器是只读的，因此可以获取但不能设置其原始值。  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>、 <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A> 和 <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> 方法使用 interlocks 更新计数器值。 这有助于在多线程或多进程方案中保持计数器值的准确性，但也会导致性能下降。 如果不需要联锁操作提供的准确性，可以 <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> 直接更新属性，使性能提高5倍。  但在多线程方案中，对计数器值的某些更新可能会被忽略，导致数据不准确。  
  
> [!NOTE]
>  如果属性的值 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 为 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> ，并且性能计数器类别是使用 .NET Framework 版本1.0 或1.1 创建的，则 <xref:System.InvalidOperationException> 会引发。 使用早期版本创建的性能计数器类别使用全局共享内存，并且的值 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 必须是 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global> 。 如果在 .NET Framework 的版本1.0 或1.1 上运行的应用程序未使用该类别，请删除并重新创建该类别。  
  
> [!NOTE]
>  若要在 Windows Vista、Windows XP Professional x64 Edition 或 Windows Server 2003 中读取性能计数器，你必须是 "性能监视器用户" 组的成员或具有管理权限。  
>   
>  若要避免提升权限来访问 Windows Vista 中的性能计数器，请将自己添加到性能监视器用户组。  
>   
>  在 Windows Vista 中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问性能计数器的代码，必须首先将你的特权从标准用户提升到管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
   
  
## Examples  
 下面的示例使用 <xref:System.Diagnostics.CounterSample> 类显示计数器的属性的值 <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> 。  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#1)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#1)]
 [!code-vb[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">您尝试设置计数器的原始值，但该计数器是只读的。  
  
- 或 - 
此实例未与性能计数器正确关联。  
  
- 或 - 
使用全局共享内存时，<see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> 属性设置为 <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">访问 API 时出错。</exception>
        <exception cref="T:System.UnauthorizedAccessException">以不具有管理特权的用户身份正在执行的代码尝试读取性能计数器。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool with get, set" Usage="System.Diagnostics.PerformanceCounter.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Diagnostics.MonitoringDescription("PC_ReadOnly")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.MonitoringDescription("PC_ReadOnly")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName Language="C#">[System.Diagnostics.MonitoringDescription("The accessability level of the counter.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.MonitoringDescription("The accessability level of the counter.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示此 <see cref="T:System.Diagnostics.PerformanceCounter" /> 实例是否处于只读模式。</summary>
        <value>如果 <see cref="T:System.Diagnostics.PerformanceCounter" /> 实例为只读模式（即使计数器本身为自定义 .NET Framework 计数器），则为 <see langword="true" />；如果它为读/写模式，则为 <see langword="false" />。 默认值为构造函数设置的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于系统计数器， <xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A> 应始终为 `true` 。 不能写入系统计数器。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveInstance">
      <MemberSignature Language="C#" Value="public void RemoveInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.RemoveInstance" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveInstance ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveInstance();" />
      <MemberSignature Language="F#" Value="member this.RemoveInstance : unit -&gt; unit" Usage="performanceCounter.RemoveInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName Language="C#">[System.MonoTODO]</AttributeName>
          <AttributeName Language="F#">[&lt;System.MonoTODO&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>删除由 <see cref="T:System.Diagnostics.PerformanceCounter" /> 对象的 <see cref="P:System.Diagnostics.PerformanceCounter.InstanceName" /> 属性指定的类别实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只能删除自定义计数器的实例。 所有系统计数器都是只读的，因此尝试删除其中一个计数器会引发异常。  
  
> [!NOTE]
>  若要避免在释放性能计数器共享内存时可能出现争用情况，建议 <xref:System.Diagnostics.PerformanceCounter.RemoveInstance%2A> 从 <xref:System.AppDomain.DomainUnload> 事件处理程序调用方法。  
  
 若要创建性能类别实例，请 `instanceName` 在 <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> 构造函数上指定。 如果由指定的类别实例 `instanceName` 已存在，则新的对象将引用现有的类别实例。  
  
> [!NOTE]
>  如果属性的值 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 为 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> ，并且性能计数器类别是使用 .NET Framework 版本1.0 或1.1 创建的，则 <xref:System.InvalidOperationException> 会引发。 使用早期版本创建的性能计数器类别使用全局共享内存，并且的值 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 必须是 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global> 。 如果在 .NET Framework 的版本1.0 或1.1 上运行的应用程序未使用该类别，请删除并重新创建该类别。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此计数器为只读，因而不能移除与该类别关联的任何实例。  
  
- 或 - 
此实例未与性能计数器正确关联。  
  
- 或 - 
使用全局共享内存时，<see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> 属性设置为 <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">访问 API 时出错。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
