<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata><Meta Name="ms.openlocfilehash" Value="28c36fa650f85ead403b657b4a626a81e2e96fb6" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83956197" /></Metadata><TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component, IDisposable" FrameworkAlternate="net-5.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component implements class System.IDisposable" FrameworkAlternate="net-5.0" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component&#xA;Implements IDisposable" FrameworkAlternate="net-5.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component, IDisposable" FrameworkAlternate="net-5.0" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    inherit Component&#xA;    interface IDisposable" FrameworkAlternate="net-5.0" />
  <TypeSignature Language="C#" Value="public class Process : IDisposable" FrameworkAlternate="netcore-1.0;netcore-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.Object implements class System.IDisposable" FrameworkAlternate="netcore-1.0;netcore-1.1" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Implements IDisposable" FrameworkAlternate="netcore-1.0;netcore-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : IDisposable" FrameworkAlternate="netcore-1.0;netcore-1.1" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    interface IDisposable" FrameworkAlternate="netcore-1.0;netcore-1.1" />
  <TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    inherit Component" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Diagnostics.Process" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netcore-1.0;netcore-1.1">System.Object</BaseTypeName>
  </Base>
  <Interfaces>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("ProcessDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="970a2-101">提供对本地和远程进程的访问权限并使你能够启动和停止本地系统进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-101">Provides access to local and remote processes and enables you to start and stop local system processes.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-102"><xref:System.Diagnostics.Process> 组件提供对计算机上运行的进程的访问。</span><span class="sxs-lookup"><span data-stu-id="970a2-102">A <xref:System.Diagnostics.Process> component provides access to a process that is running on a computer.</span></span> <span data-ttu-id="970a2-103">最简单的过程是正在运行的应用程序。</span><span class="sxs-lookup"><span data-stu-id="970a2-103">A process, in the simplest terms, is a running app.</span></span> <span data-ttu-id="970a2-104">线程是操作系统向其分配处理器时间的基本单元。</span><span class="sxs-lookup"><span data-stu-id="970a2-104">A thread is the basic unit to which the operating system allocates processor time.</span></span> <span data-ttu-id="970a2-105">线程可以执行进程的任何代码部分，包括当前由另一个线程执行的部分。</span><span class="sxs-lookup"><span data-stu-id="970a2-105">A thread can execute any part of the code of the process, including parts currently being executed by another thread.</span></span>  
  
 <span data-ttu-id="970a2-106"><xref:System.Diagnostics.Process> 组件是用于启动、停止、控制和监视应用程序的有用工具。</span><span class="sxs-lookup"><span data-stu-id="970a2-106">The <xref:System.Diagnostics.Process> component is a useful tool for starting, stopping, controlling, and monitoring apps.</span></span> <span data-ttu-id="970a2-107">您可以使用 <xref:System.Diagnostics.Process> 组件获取正在运行的进程的列表，也可以启动新的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-107">You can use the <xref:System.Diagnostics.Process> component, to obtain a list of the processes that are running, or you can start a new process.</span></span> <span data-ttu-id="970a2-108"><xref:System.Diagnostics.Process> 组件用于访问系统进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-108">A <xref:System.Diagnostics.Process> component is used to access system processes.</span></span> <span data-ttu-id="970a2-109">初始化 <xref:System.Diagnostics.Process> 组件后，可以使用它来获取有关正在运行的进程的信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-109">After a <xref:System.Diagnostics.Process> component has been initialized, it can be used to obtain information about the running process.</span></span> <span data-ttu-id="970a2-110">此类信息包括一组线程、已加载的模块（.dll 和 .exe 文件）以及性能信息，如进程正在使用的内存量。</span><span class="sxs-lookup"><span data-stu-id="970a2-110">Such information includes the set of threads, the loaded modules (.dll and .exe files), and performance information such as the amount of memory the process is using.</span></span>  
  
 <span data-ttu-id="970a2-111">此类型实现 <xref:System.IDisposable> 接口。</span><span class="sxs-lookup"><span data-stu-id="970a2-111">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="970a2-112">在使用完类型后，您应直接或间接释放类型。</span><span class="sxs-lookup"><span data-stu-id="970a2-112">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="970a2-113">若要直接释放类型，请在 `try`/`finally` 块中调用其 <xref:System.IDisposable.Dispose%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="970a2-113">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`finally` block.</span></span> <span data-ttu-id="970a2-114">若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。</span><span class="sxs-lookup"><span data-stu-id="970a2-114">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="970a2-115">有关详细信息，请参阅 <xref:System.IDisposable> 接口主题中的“使用实现 IDisposable 的对象”一节。</span><span class="sxs-lookup"><span data-stu-id="970a2-115">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-116">32位进程无法访问64位进程的模块。</span><span class="sxs-lookup"><span data-stu-id="970a2-116">32-bit processes cannot access the modules of a 64-bit process.</span></span> <span data-ttu-id="970a2-117">如果尝试从32位进程获取有关64位进程的信息，将会出现 <xref:System.ComponentModel.Win32Exception> 异常。</span><span class="sxs-lookup"><span data-stu-id="970a2-117">If you try to get information about a 64-bit process from a 32-bit process, you will get a <xref:System.ComponentModel.Win32Exception> exception.</span></span> <span data-ttu-id="970a2-118">另一方面，64位进程可以访问32位进程的模块。</span><span class="sxs-lookup"><span data-stu-id="970a2-118">A 64-bit process, on the other hand, can access the modules of a 32-bit process.</span></span>  
  
 <span data-ttu-id="970a2-119">进程组件同时获取有关一组属性的信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-119">The process component obtains information about a group of properties all at once.</span></span> <span data-ttu-id="970a2-120">在 <xref:System.Diagnostics.Process> 组件获取了有关任何组中的一个成员的信息后，它将缓存该组中其他属性的值，而不获取有关组中其他成员的新信息，直到您调用 <xref:System.Diagnostics.Process.Refresh%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="970a2-120">After the <xref:System.Diagnostics.Process> component has obtained information about one member of any group, it will cache the values for the other properties in that group and not obtain new information about the other members of the group until you call the <xref:System.Diagnostics.Process.Refresh%2A> method.</span></span> <span data-ttu-id="970a2-121">因此，属性值不能保证比最后一次调用 <xref:System.Diagnostics.Process.Refresh%2A> 方法更新。</span><span class="sxs-lookup"><span data-stu-id="970a2-121">Therefore, a property value is not guaranteed to be any newer than the last call to the <xref:System.Diagnostics.Process.Refresh%2A> method.</span></span> <span data-ttu-id="970a2-122">组细目依赖于操作系统。</span><span class="sxs-lookup"><span data-stu-id="970a2-122">The group breakdowns are operating-system dependent.</span></span>  
  
 <span data-ttu-id="970a2-123">如果在系统中使用引号声明了路径变量，则在启动在该位置找到的任何进程时必须完全限定该路径。</span><span class="sxs-lookup"><span data-stu-id="970a2-123">If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location.</span></span> <span data-ttu-id="970a2-124">否则，系统将找不到该路径。</span><span class="sxs-lookup"><span data-stu-id="970a2-124">Otherwise, the system will not find the path.</span></span> <span data-ttu-id="970a2-125">例如，如果 `c:\mypath` 不在你的路径中，而你使用引号添加它： `path = %path%;"c:\mypath"`，则在启动时必须完全限定 `c:\mypath` 中的任何进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-125">For example, if `c:\mypath` is not in your path, and you add it using quotation marks: `path = %path%;"c:\mypath"`, you must fully qualify any process in `c:\mypath` when starting it.</span></span>  
  
 <span data-ttu-id="970a2-126">系统进程通过其进程标识符在系统上唯一标识。</span><span class="sxs-lookup"><span data-stu-id="970a2-126">A system process is uniquely identified on the system by its process identifier.</span></span> <span data-ttu-id="970a2-127">与许多 Windows 资源一样，进程也由其句柄标识，该进程在计算机上可能不唯一。</span><span class="sxs-lookup"><span data-stu-id="970a2-127">Like many Windows resources, a process is also identified by its handle, which might not be unique on the computer.</span></span> <span data-ttu-id="970a2-128">句柄是资源标识符的一般术语。</span><span class="sxs-lookup"><span data-stu-id="970a2-128">A handle is the generic term for an identifier of a resource.</span></span> <span data-ttu-id="970a2-129">操作系统将保留进程句柄，该句柄通过 <xref:System.Diagnostics.Process> 组件的 <xref:System.Diagnostics.Process.Handle%2A> 属性访问，即使进程已退出也是如此。</span><span class="sxs-lookup"><span data-stu-id="970a2-129">The operating system persists the process handle, which is accessed through the <xref:System.Diagnostics.Process.Handle%2A> property of the <xref:System.Diagnostics.Process> component, even when the process has exited.</span></span> <span data-ttu-id="970a2-130">因此，你可以获取进程的管理信息，例如 <xref:System.Diagnostics.Process.ExitCode%2A> （通常为零表示成功或非零错误代码）和 <xref:System.Diagnostics.Process.ExitTime%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-130">Thus, you can get the process's administrative information, such as the <xref:System.Diagnostics.Process.ExitCode%2A> (usually either zero for success or a nonzero error code) and the <xref:System.Diagnostics.Process.ExitTime%2A>.</span></span> <span data-ttu-id="970a2-131">句柄是一个极其宝贵的资源，因此泄漏句柄比泄漏内存更 virulent。</span><span class="sxs-lookup"><span data-stu-id="970a2-131">Handles are an extremely valuable resource, so leaking handles is more virulent than leaking memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-132">此类包含应用于所有成员的类级别的链接要求和继承要求。</span><span class="sxs-lookup"><span data-stu-id="970a2-132">This class contains a link demand and an inheritance demand at the class level that applies to all members.</span></span> <span data-ttu-id="970a2-133">当直接调用方或派生类不具有完全信任权限时，将引发 <xref:System.Security.SecurityException>。</span><span class="sxs-lookup"><span data-stu-id="970a2-133">A <xref:System.Security.SecurityException> is thrown when either the immediate caller or the derived class does not have full-trust permission.</span></span> <span data-ttu-id="970a2-134">有关安全要求的详细信息，请参阅[链接需求](/dotnet/framework/misc/link-demands)。</span><span class="sxs-lookup"><span data-stu-id="970a2-134">For details about security demands, see [Link Demands](/dotnet/framework/misc/link-demands).</span></span>  
  
<a name="Core"></a>   
## <a name="net_core-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] <span data-ttu-id="970a2-135">说明</span><span class="sxs-lookup"><span data-stu-id="970a2-135">Notes</span></span>  
 <span data-ttu-id="970a2-136">在 .NET Framework 中，<xref:System.Diagnostics.Process> 类在默认情况下使用 <xref:System.Console> 编码，通常为输入、输出和错误流的代码页编码。</span><span class="sxs-lookup"><span data-stu-id="970a2-136">In the .NET Framework, the <xref:System.Diagnostics.Process> class by default uses <xref:System.Console> encodings, which are typically code page encodings, for the input, output, and error streams.</span></span> <span data-ttu-id="970a2-137">例如，在区域性为英语（美国）的系统上，代码页437是 <xref:System.Console> 类的默认编码。</span><span class="sxs-lookup"><span data-stu-id="970a2-137">For example code, on systems whose culture is English (United States), code page 437 is the default encoding for the <xref:System.Console> class.</span></span> <span data-ttu-id="970a2-138">但 [!INCLUDE[net_core](~/includes/net-core-md.md)] 只能提供这些编码的有限子集。</span><span class="sxs-lookup"><span data-stu-id="970a2-138">However, [!INCLUDE[net_core](~/includes/net-core-md.md)] may make only a limited subset of these encodings available.</span></span> <span data-ttu-id="970a2-139">如果是这种情况，它将使用 <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> 作为默认编码。</span><span class="sxs-lookup"><span data-stu-id="970a2-139">If this is the case, it uses <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> as the default encoding.</span></span>  
  
 <span data-ttu-id="970a2-140">如果 <xref:System.Diagnostics.Process> 对象依赖于特定的代码页编码，仍可以在调用任何 <xref:System.Diagnostics.Process> 方法*之前*执行以下操作，使其可用：</span><span class="sxs-lookup"><span data-stu-id="970a2-140">If a <xref:System.Diagnostics.Process> object depends on specific code page encodings, you can still make them available by doing the following *before* you call any <xref:System.Diagnostics.Process> methods:</span></span>  
  
1.  <span data-ttu-id="970a2-141">将对代码页程序集的引用添加到你的项目。</span><span class="sxs-lookup"><span data-stu-id="970a2-141">Add a reference to the System.Text.Encoding.CodePages.dll assembly to your project.</span></span>  
  
2.  <span data-ttu-id="970a2-142">检索 <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> 属性中的 <xref:System.Text.EncodingProvider> 对象。</span><span class="sxs-lookup"><span data-stu-id="970a2-142">Retrieve the <xref:System.Text.EncodingProvider> object from the <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> property.</span></span>  
  
3.  <span data-ttu-id="970a2-143">将 <xref:System.Text.EncodingProvider> 对象传递到 <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> 方法，以使编码提供程序支持的其他编码可用。</span><span class="sxs-lookup"><span data-stu-id="970a2-143">Pass the <xref:System.Text.EncodingProvider> object to the <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> method to make the additional encodings supported by the encoding provider available.</span></span>  
  
 <span data-ttu-id="970a2-144">如果在调用任何 <xref:System.Diagnostics.Process> 方法之前已注册了编码提供程序，则 <xref:System.Diagnostics.Process> 类将自动使用默认系统编码，而不是 UTF8。</span><span class="sxs-lookup"><span data-stu-id="970a2-144">The <xref:System.Diagnostics.Process> class will then automatically use the default system encoding rather than UTF8, provided that you have registered the encoding provider before calling any <xref:System.Diagnostics.Process> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-145">下面的示例使用 <xref:System.Diagnostics.Process> 类的实例来启动进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-145">The following example uses an instance of the <xref:System.Diagnostics.Process> class to start a process.</span></span>  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 <span data-ttu-id="970a2-146">下面的示例使用 <xref:System.Diagnostics.Process> 类本身和静态 <xref:System.Diagnostics.Process.Start%2A> 方法来启动进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-146">The following example uses the <xref:System.Diagnostics.Process> class itself and a static <xref:System.Diagnostics.Process.Start%2A> method to start a process.</span></span>  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb)]  
  
 <span data-ttu-id="970a2-147">下面F#的示例定义了一个 `runProc` 函数，该函数启动进程、捕获所有输出和错误信息，并记录进程已运行的毫秒数。</span><span class="sxs-lookup"><span data-stu-id="970a2-147">The following F# example defines a `runProc` function that starts a process, captures all output and error information, and records the number of milliseconds that the process has run.</span></span>  <span data-ttu-id="970a2-148">`runProc` 函数有三个参数：要启动的应用程序的名称、要为应用程序提供的参数以及起始目录。</span><span class="sxs-lookup"><span data-stu-id="970a2-148">The `runProc` function has three parameters: the name of application to launch, the arguments to supply to the application, and the starting directory.</span></span>  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 <span data-ttu-id="970a2-149">`runProc` 函数的代码由[ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment)编写，并在[Microsoft 公共许可证](https://opensource.org/licenses/ms-pl)下提供。</span><span class="sxs-lookup"><span data-stu-id="970a2-149">The code for the `runProc` function was written by [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) and is available under the [Microsoft Public License](https://opensource.org/licenses/ms-pl).</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/windowsdesktop/Using-the-NET-Process-Class-d70597ef"><span data-ttu-id="970a2-150">使用 .NET 进程类</span><span class="sxs-lookup"><span data-stu-id="970a2-150">Using the .NET Process Class</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="970a2-151">初始化 <see cref="T:System.Diagnostics.Process" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="970a2-151">Initializes a new instance of the <see cref="T:System.Diagnostics.Process" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-152">如果未指定 <xref:System.Diagnostics.Process.MachineName%2A> 属性，则默认为本地计算机（"."）。</span><span class="sxs-lookup"><span data-stu-id="970a2-152">If you do not specify the <xref:System.Diagnostics.Process.MachineName%2A> property, the default is the local computer, (".").</span></span>  
  
 <span data-ttu-id="970a2-153">有两个选项可用于将新的 <xref:System.Diagnostics.Process> 组件与计算机上的进程相关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-153">You have two options for associating a new <xref:System.Diagnostics.Process> component with a process on the computer.</span></span> <span data-ttu-id="970a2-154">第一种方法是使用构造函数创建 <xref:System.Diagnostics.Process> 组件、设置 <xref:System.Diagnostics.Process.StartInfo%2A> 属性的相应成员并调用 <xref:System.Diagnostics.Process.Start%2A>，将 <xref:System.Diagnostics.Process> 与新的系统进程相关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-154">The first option is to use the constructor to create the <xref:System.Diagnostics.Process> component, set the appropriate members of the <xref:System.Diagnostics.Process.StartInfo%2A> property and call <xref:System.Diagnostics.Process.Start%2A> to associate the <xref:System.Diagnostics.Process> with a new system process.</span></span> <span data-ttu-id="970a2-155">第二种方法是使用 <xref:System.Diagnostics.Process.GetProcessById%2A> 或 <xref:System.Diagnostics.Process.GetProcesses%2A> 返回值之一将 <xref:System.Diagnostics.Process> 与正在运行的系统进程关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-155">The second option is to associate the <xref:System.Diagnostics.Process> with a running system process by using <xref:System.Diagnostics.Process.GetProcessById%2A> or one of the <xref:System.Diagnostics.Process.GetProcesses%2A> return values.</span></span>  
  
 <span data-ttu-id="970a2-156">如果你使用 <xref:System.Diagnostics.Process.Start%2A> 方法的 `static` 重载来启动新系统进程，则该方法将创建新的 <xref:System.Diagnostics.Process> 组件并将其与进程关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-156">If you use a `static` overload of the <xref:System.Diagnostics.Process.Start%2A> method to start a new system process, the method creates a new <xref:System.Diagnostics.Process> component and associates it with the process.</span></span>  
  
 <span data-ttu-id="970a2-157">如果将 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> 属性设置为其默认值，则 `true`，你可以以与使用 Windows `Start` 菜单的 `Run` 对话框相同的方式启动应用程序和文档。</span><span class="sxs-lookup"><span data-stu-id="970a2-157">When the <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> property is set to its default value, `true`, you can start applications and documents in a way that is similar to using the `Run` dialog box of the Windows `Start` menu.</span></span> <span data-ttu-id="970a2-158">`false`<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> 时，只能启动可执行文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-158">When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> is `false`, you can start only executables.</span></span>  
  
 <span data-ttu-id="970a2-159">可以通过以下两种方式之一来启动可从命令行调用的可执行文件：设置 <xref:System.Diagnostics.Process.StartInfo%2A> 属性的相应成员并调用不带参数的 <xref:System.Diagnostics.Process.Start%2A> 方法，或通过将相应参数传递到 `static`<xref:System.Diagnostics.Process.Start%2A> 成员。</span><span class="sxs-lookup"><span data-stu-id="970a2-159">Any executable file that you can call from the command line can be started in one of two ways: by setting the appropriate members of the <xref:System.Diagnostics.Process.StartInfo%2A> property and calling the <xref:System.Diagnostics.Process.Start%2A> method with no parameters, or by passing the appropriate parameter to the `static`<xref:System.Diagnostics.Process.Start%2A> member.</span></span>  
  
 <span data-ttu-id="970a2-160">您可以通过使用构造函数、静态 <xref:System.Diagnostics.Process.Start%2A> 重载之一或任意 <xref:System.Diagnostics.Process.GetProcessById%2A>、<xref:System.Diagnostics.Process.GetProcesses%2A>或 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 方法创建 <xref:System.Diagnostics.Process> 组件。</span><span class="sxs-lookup"><span data-stu-id="970a2-160">You can create a <xref:System.Diagnostics.Process> component by using the constructor, one of the static <xref:System.Diagnostics.Process.Start%2A> overloads, or any of the <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, or <xref:System.Diagnostics.Process.GetProcessesByName%2A> methods.</span></span> <span data-ttu-id="970a2-161">完成此操作后，就可以查看关联的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-161">After you have done so, you have a view into the associated process.</span></span> <span data-ttu-id="970a2-162">这不是动态视图，当进程属性在内存中更改时，它会自动更新自身。</span><span class="sxs-lookup"><span data-stu-id="970a2-162">This is not a dynamic view that updates itself automatically when the process properties have changed in memory.</span></span> <span data-ttu-id="970a2-163">相反，你必须为组件调用 <xref:System.Diagnostics.Process.Refresh%2A>，以更新应用程序中的 <xref:System.Diagnostics.Process> 属性信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-163">Instead, you must call <xref:System.Diagnostics.Process.Refresh%2A> for the component to update the <xref:System.Diagnostics.Process> property information in your application.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.Process.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessBasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-164">获取关联进程的基本优先级。</span><span class="sxs-lookup"><span data-stu-id="970a2-164">Gets the base priority of the associated process.</span></span></summary>
        <value><span data-ttu-id="970a2-165">基本优先级，从关联进程的 <see cref="P:System.Diagnostics.Process.PriorityClass" /> 计算。</span><span class="sxs-lookup"><span data-stu-id="970a2-165">The base priority, which is computed from the <see cref="P:System.Diagnostics.Process.PriorityClass" /> of the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-166">进程的 <xref:System.Diagnostics.Process.BasePriority%2A> 是在关联进程中创建的线程的启动优先级。</span><span class="sxs-lookup"><span data-stu-id="970a2-166">The <xref:System.Diagnostics.Process.BasePriority%2A> of the process is the starting priority for threads created within the associated process.</span></span> <span data-ttu-id="970a2-167">你可以通过系统监视器的优先级基准计数器查看有关基本优先级的信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-167">You can view information about the base priority through the System Monitor's Priority Base counter.</span></span>  
  
 <span data-ttu-id="970a2-168">根据所用的时间或其他提升，操作系统可以在进程应置于其他位置时更改基本优先级。</span><span class="sxs-lookup"><span data-stu-id="970a2-168">Based on the time elapsed or other boosts, the operating system can change the base priority when a process should be placed ahead of others.</span></span>  
  
 <span data-ttu-id="970a2-169">利用 <xref:System.Diagnostics.Process.BasePriority%2A> 属性，您可以查看分配给进程的启动优先级。</span><span class="sxs-lookup"><span data-stu-id="970a2-169">The <xref:System.Diagnostics.Process.BasePriority%2A> property lets you view the starting priority assigned to a process.</span></span> <span data-ttu-id="970a2-170">但是，因为它是只读的，所以不能使用 <xref:System.Diagnostics.Process.BasePriority%2A> 来设置进程的优先级。</span><span class="sxs-lookup"><span data-stu-id="970a2-170">However, because it is read-only, you cannot use the <xref:System.Diagnostics.Process.BasePriority%2A> to set the priority of the process.</span></span> <span data-ttu-id="970a2-171">若要更改优先级，请使用 <xref:System.Diagnostics.Process.PriorityClass%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-171">To change the priority, use the <xref:System.Diagnostics.Process.PriorityClass%2A> property.</span></span> <span data-ttu-id="970a2-172">使用系统监视器可查看 <xref:System.Diagnostics.Process.BasePriority%2A>，而 <xref:System.Diagnostics.Process.PriorityClass%2A> 则不可见。</span><span class="sxs-lookup"><span data-stu-id="970a2-172">The <xref:System.Diagnostics.Process.BasePriority%2A> is viewable using the System Monitor, while the <xref:System.Diagnostics.Process.PriorityClass%2A> is not.</span></span> <span data-ttu-id="970a2-173">可以通过编程方式查看 <xref:System.Diagnostics.Process.BasePriority%2A> 和 <xref:System.Diagnostics.Process.PriorityClass%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-173">Both the <xref:System.Diagnostics.Process.BasePriority%2A> and the <xref:System.Diagnostics.Process.PriorityClass%2A> can be viewed programmatically.</span></span> <span data-ttu-id="970a2-174">下表显示 <xref:System.Diagnostics.Process.BasePriority%2A> 值和 <xref:System.Diagnostics.Process.PriorityClass%2A> 值之间的关系。</span><span class="sxs-lookup"><span data-stu-id="970a2-174">The following table shows the relationship between <xref:System.Diagnostics.Process.BasePriority%2A> values and <xref:System.Diagnostics.Process.PriorityClass%2A> values.</span></span>  
  
|<span data-ttu-id="970a2-175">BasePriority</span><span class="sxs-lookup"><span data-stu-id="970a2-175">BasePriority</span></span>|<span data-ttu-id="970a2-176">PriorityClass</span><span class="sxs-lookup"><span data-stu-id="970a2-176">PriorityClass</span></span>|  
|------------------|-------------------|  
|<span data-ttu-id="970a2-177">4</span><span class="sxs-lookup"><span data-stu-id="970a2-177">4</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|<span data-ttu-id="970a2-178">8</span><span class="sxs-lookup"><span data-stu-id="970a2-178">8</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|<span data-ttu-id="970a2-179">13</span><span class="sxs-lookup"><span data-stu-id="970a2-179">13</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|<span data-ttu-id="970a2-180">24</span><span class="sxs-lookup"><span data-stu-id="970a2-180">24</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 <span data-ttu-id="970a2-181">下面的示例启动记事本的实例。</span><span class="sxs-lookup"><span data-stu-id="970a2-181">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="970a2-182">然后，该示例检索并显示关联进程的各种属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-182">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="970a2-183">该示例在进程退出时进行检测，并显示该进程的退出代码。</span><span class="sxs-lookup"><span data-stu-id="970a2-183">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-184">该进程已退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-184">The process has exited.</span></span>  
  
 <span data-ttu-id="970a2-185">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-185">-or-</span></span>  
  
 <span data-ttu-id="970a2-186">尚未启动进程，因此没有进程 ID。</span><span class="sxs-lookup"><span data-stu-id="970a2-186">The process has not started, so there is no process ID.</span></span></exception>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginErrorReadLine : unit -&gt; unit" Usage="process.BeginErrorReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="970a2-187">在应用程序的重定向 <see cref="P:System.Diagnostics.Process.StandardError" /> 流上开始进行异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-187">Begins asynchronous read operations on the redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream of the application.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-188"><xref:System.Diagnostics.Process.StandardError%2A> 流可以同步或异步读取。</span><span class="sxs-lookup"><span data-stu-id="970a2-188">The <xref:System.Diagnostics.Process.StandardError%2A> stream can be read synchronously or asynchronously.</span></span> <span data-ttu-id="970a2-189"><xref:System.IO.StreamReader.Read%2A>、<xref:System.IO.StreamReader.ReadLine%2A>和 <xref:System.IO.StreamReader.ReadToEnd%2A> 等方法执行进程的错误输出流上的同步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-189">Methods such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, and <xref:System.IO.StreamReader.ReadToEnd%2A> perform synchronous read operations on the error output stream of the process.</span></span> <span data-ttu-id="970a2-190">在关联的 <xref:System.Diagnostics.Process> 写入其 <xref:System.Diagnostics.Process.StandardError%2A> 流或关闭流之前，这些同步读取操作不会完成。</span><span class="sxs-lookup"><span data-stu-id="970a2-190">These synchronous read operations do not complete until the associated <xref:System.Diagnostics.Process> writes to its <xref:System.Diagnostics.Process.StandardError%2A> stream, or closes the stream.</span></span>  
  
 <span data-ttu-id="970a2-191">与此相反，<xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 会对 <xref:System.Diagnostics.Process.StandardError%2A> 流启动异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-191">In contrast, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> starts asynchronous read operations on the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span> <span data-ttu-id="970a2-192">此方法将为流输出启用指定的事件处理程序，并立即返回到调用方，当流输出定向到事件处理程序时，该处理程序可以执行其他操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-192">This method enables the designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</span></span>  
  
 <span data-ttu-id="970a2-193">按照以下步骤对 <xref:System.Diagnostics.Process> 的 <xref:System.Diagnostics.Process.StandardError%2A> 执行异步读取操作：</span><span class="sxs-lookup"><span data-stu-id="970a2-193">Follow these steps to perform asynchronous read operations on <xref:System.Diagnostics.Process.StandardError%2A> for a <xref:System.Diagnostics.Process> :</span></span>  
  
1.  <span data-ttu-id="970a2-194">将 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 设置为 `false`。</span><span class="sxs-lookup"><span data-stu-id="970a2-194">Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</span></span>  
  
2.  <span data-ttu-id="970a2-195">将 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> 设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="970a2-195">Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> to `true`.</span></span>  
  
3.  <span data-ttu-id="970a2-196">向 <xref:System.Diagnostics.Process.ErrorDataReceived> 事件添加事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="970a2-196">Add your event handler to the <xref:System.Diagnostics.Process.ErrorDataReceived> event.</span></span> <span data-ttu-id="970a2-197">事件处理程序必须与 <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> 委托签名匹配。</span><span class="sxs-lookup"><span data-stu-id="970a2-197">The event handler must match the <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> delegate signature.</span></span>  
  
4.  <span data-ttu-id="970a2-198">启动 <xref:System.Diagnostics.Process>。</span><span class="sxs-lookup"><span data-stu-id="970a2-198">Start the <xref:System.Diagnostics.Process>.</span></span>  
  
5.  <span data-ttu-id="970a2-199">为 <xref:System.Diagnostics.Process>调用 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-199">Call <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> for the <xref:System.Diagnostics.Process>.</span></span> <span data-ttu-id="970a2-200">此调用启动 <xref:System.Diagnostics.Process.StandardError%2A>上的异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-200">This call starts asynchronous read operations on <xref:System.Diagnostics.Process.StandardError%2A>.</span></span>  
  
 <span data-ttu-id="970a2-201">当异步读取操作开始时，每次关联 <xref:System.Diagnostics.Process> 将一行文本写入其 <xref:System.Diagnostics.Process.StandardError%2A> 流时，将调用事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="970a2-201">When asynchronous read operations start, the event handler is called each time the associated <xref:System.Diagnostics.Process> writes a line of text to its <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
 <span data-ttu-id="970a2-202">可以通过调用 <xref:System.Diagnostics.Process.CancelErrorRead%2A>取消异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-202">You can cancel an asynchronous read operation by calling <xref:System.Diagnostics.Process.CancelErrorRead%2A>.</span></span> <span data-ttu-id="970a2-203">读取操作可由调用方或事件处理程序取消。</span><span class="sxs-lookup"><span data-stu-id="970a2-203">The read operation can be canceled by the caller or by the event handler.</span></span> <span data-ttu-id="970a2-204">取消后，可以再次调用 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 以恢复异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-204">After canceling, you can call <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> again to resume asynchronous read operations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-205">不能对重定向的流混合使用异步和同步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-205">You cannot mix asynchronous and synchronous read operations on a redirected stream.</span></span> <span data-ttu-id="970a2-206">在异步或同步模式下打开 <xref:System.Diagnostics.Process> 的重定向流后，对该流进行的所有进一步读取操作都必须处于相同的模式下。</span><span class="sxs-lookup"><span data-stu-id="970a2-206">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="970a2-207">例如，不要在 <xref:System.Diagnostics.Process.StandardError%2A> 流的 <xref:System.IO.StreamReader.ReadLine%2A> 调用 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>，反之亦然。</span><span class="sxs-lookup"><span data-stu-id="970a2-207">For example, do not follow <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> with a call to <xref:System.IO.StreamReader.ReadLine%2A> on the <xref:System.Diagnostics.Process.StandardError%2A> stream, or vice versa.</span></span> <span data-ttu-id="970a2-208">但是，可以在不同模式下读取两个不同的流。</span><span class="sxs-lookup"><span data-stu-id="970a2-208">However, you can read two different streams in different modes.</span></span> <span data-ttu-id="970a2-209">例如，可以调用 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>，然后调用 <xref:System.Diagnostics.Process.StandardOutput%2A> 流的 <xref:System.IO.StreamReader.ReadLine%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-209">For example, you can call <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> and then call <xref:System.IO.StreamReader.ReadLine%2A> for the <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-210">以下示例使用 `net view` 命令列出远程计算机上可用的网络资源。</span><span class="sxs-lookup"><span data-stu-id="970a2-210">The following example uses the `net view` command to list the available network resources on a remote computer.</span></span> <span data-ttu-id="970a2-211">用户以命令行参数的形式提供目标计算机名称。</span><span class="sxs-lookup"><span data-stu-id="970a2-211">The user supplies the target computer name as a command-line argument.</span></span> <span data-ttu-id="970a2-212">用户还可以提供错误输出的文件名。</span><span class="sxs-lookup"><span data-stu-id="970a2-212">The user can also supply a file name for error output.</span></span> <span data-ttu-id="970a2-213">该示例收集 net 命令的输出，等待进程完成，然后将输出结果写入控制台。</span><span class="sxs-lookup"><span data-stu-id="970a2-213">The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console.</span></span> <span data-ttu-id="970a2-214">如果用户提供了可选的错误文件，则该示例会将错误写入文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-214">If the user supplies the optional error file, the example writes errors to the file.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-215"><see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 属性为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-215">The <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> property is <see langword="false" />.</span></span>  
  
<span data-ttu-id="970a2-216">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-216">-or-</span></span> 
<span data-ttu-id="970a2-217"><see cref="P:System.Diagnostics.Process.StandardError" /> 流上已在进行异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-217">An asynchronous read operation is already in progress on the <see cref="P:System.Diagnostics.Process.StandardError" /> stream.</span></span>  
  
<span data-ttu-id="970a2-218">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-218">-or-</span></span> 
<span data-ttu-id="970a2-219">同步读取操作已使用 <see cref="P:System.Diagnostics.Process.StandardError" /> 流。</span><span class="sxs-lookup"><span data-stu-id="970a2-219">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has been used by a synchronous read operation.</span></span></exception>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginOutputReadLine : unit -&gt; unit" Usage="process.BeginOutputReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="970a2-220">在应用程序的重定向 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 流上开始进行异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-220">Begins asynchronous read operations on the redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream of the application.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-221"><xref:System.Diagnostics.Process.StandardOutput%2A> 流可以同步或异步读取。</span><span class="sxs-lookup"><span data-stu-id="970a2-221">The <xref:System.Diagnostics.Process.StandardOutput%2A> stream can be read synchronously or asynchronously.</span></span> <span data-ttu-id="970a2-222"><xref:System.IO.StreamReader.Read%2A>、<xref:System.IO.StreamReader.ReadLine%2A>和 <xref:System.IO.StreamReader.ReadToEnd%2A> 等方法在进程的输出流上执行同步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-222">Methods such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, and <xref:System.IO.StreamReader.ReadToEnd%2A> perform synchronous read operations on the output stream of the process.</span></span> <span data-ttu-id="970a2-223">在关联的 <xref:System.Diagnostics.Process> 写入其 <xref:System.Diagnostics.Process.StandardOutput%2A> 流或关闭流之前，这些同步读取操作不会完成。</span><span class="sxs-lookup"><span data-stu-id="970a2-223">These synchronous read operations do not complete until the associated <xref:System.Diagnostics.Process> writes to its <xref:System.Diagnostics.Process.StandardOutput%2A> stream, or closes the stream.</span></span>  
  
 <span data-ttu-id="970a2-224">与此相反，<xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 会对 <xref:System.Diagnostics.Process.StandardOutput%2A> 流启动异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-224">In contrast, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> starts asynchronous read operations on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="970a2-225">此方法将为流输出启用指定的事件处理程序，并立即返回到调用方，当流输出定向到事件处理程序时，该处理程序可以执行其他操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-225">This method enables a designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</span></span>  
  
 <span data-ttu-id="970a2-226">按照以下步骤对 <xref:System.Diagnostics.Process> 的 <xref:System.Diagnostics.Process.StandardOutput%2A> 执行异步读取操作：</span><span class="sxs-lookup"><span data-stu-id="970a2-226">Follow these steps to perform asynchronous read operations on <xref:System.Diagnostics.Process.StandardOutput%2A> for a <xref:System.Diagnostics.Process> :</span></span>  
  
1.  <span data-ttu-id="970a2-227">将 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 设置为 `false`。</span><span class="sxs-lookup"><span data-stu-id="970a2-227">Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</span></span>  
  
2.  <span data-ttu-id="970a2-228">将 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> 设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="970a2-228">Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> to `true`.</span></span>  
  
3.  <span data-ttu-id="970a2-229">向 <xref:System.Diagnostics.Process.OutputDataReceived> 事件添加事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="970a2-229">Add your event handler to the <xref:System.Diagnostics.Process.OutputDataReceived> event.</span></span> <span data-ttu-id="970a2-230">事件处理程序必须与 <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> 委托签名匹配。</span><span class="sxs-lookup"><span data-stu-id="970a2-230">The event handler must match the <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> delegate signature.</span></span>  
  
4.  <span data-ttu-id="970a2-231">启动 <xref:System.Diagnostics.Process>。</span><span class="sxs-lookup"><span data-stu-id="970a2-231">Start the <xref:System.Diagnostics.Process>.</span></span>  
  
5.  <span data-ttu-id="970a2-232">为 <xref:System.Diagnostics.Process>调用 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-232">Call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> for the <xref:System.Diagnostics.Process>.</span></span> <span data-ttu-id="970a2-233">此调用启动 <xref:System.Diagnostics.Process.StandardOutput%2A>上的异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-233">This call starts asynchronous read operations on <xref:System.Diagnostics.Process.StandardOutput%2A>.</span></span>  
  
 <span data-ttu-id="970a2-234">当异步读取操作开始时，每次关联 <xref:System.Diagnostics.Process> 将一行文本写入其 <xref:System.Diagnostics.Process.StandardOutput%2A> 流时，将调用事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="970a2-234">When asynchronous read operations start, the event handler is called each time the associated <xref:System.Diagnostics.Process> writes a line of text to its <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span>  
  
 <span data-ttu-id="970a2-235">可以通过调用 <xref:System.Diagnostics.Process.CancelOutputRead%2A>取消异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-235">You can cancel an asynchronous read operation by calling <xref:System.Diagnostics.Process.CancelOutputRead%2A>.</span></span> <span data-ttu-id="970a2-236">读取操作可由调用方或事件处理程序取消。</span><span class="sxs-lookup"><span data-stu-id="970a2-236">The read operation can be canceled by the caller or by the event handler.</span></span> <span data-ttu-id="970a2-237">取消后，可以再次调用 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 以恢复异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-237">After canceling, you can call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> again to resume asynchronous read operations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-238">不能对重定向的流混合使用异步和同步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-238">You cannot mix asynchronous and synchronous read operations on a redirected stream.</span></span> <span data-ttu-id="970a2-239">在异步或同步模式下打开 <xref:System.Diagnostics.Process> 的重定向流后，对该流进行的所有进一步读取操作都必须处于相同的模式下。</span><span class="sxs-lookup"><span data-stu-id="970a2-239">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="970a2-240">例如，不要在 <xref:System.Diagnostics.Process.StandardOutput%2A> 流的 <xref:System.IO.StreamReader.ReadLine%2A> 调用 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，反之亦然。</span><span class="sxs-lookup"><span data-stu-id="970a2-240">For example, do not follow <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> with a call to <xref:System.IO.StreamReader.ReadLine%2A> on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream, or vice versa.</span></span> <span data-ttu-id="970a2-241">但是，可以在不同模式下读取两个不同的流。</span><span class="sxs-lookup"><span data-stu-id="970a2-241">However, you can read two different streams in different modes.</span></span> <span data-ttu-id="970a2-242">例如，可以调用 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，然后调用 <xref:System.Diagnostics.Process.StandardError%2A> 流的 <xref:System.IO.StreamReader.ReadLine%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-242">For example, you can call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> and then call <xref:System.IO.StreamReader.ReadLine%2A> for the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-243">下面的示例演示如何对 `sort` 命令的重定向 <xref:System.Diagnostics.Process.StandardOutput%2A> 流执行异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-243">The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `sort` command.</span></span> <span data-ttu-id="970a2-244">`sort` 命令是一种控制台应用程序，用于读取和排序文本输入。</span><span class="sxs-lookup"><span data-stu-id="970a2-244">The `sort` command is a console application that reads and sorts text input.</span></span>  
  
 <span data-ttu-id="970a2-245">该示例创建 `SortOutputHandler` 事件处理程序的事件委托，并将其与 <xref:System.Diagnostics.Process.OutputDataReceived> 事件关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-245">The example creates an event delegate for the `SortOutputHandler` event handler and associates it with the <xref:System.Diagnostics.Process.OutputDataReceived> event.</span></span> <span data-ttu-id="970a2-246">事件处理程序从重定向的 <xref:System.Diagnostics.Process.StandardOutput%2A> 流接收文本行，设置文本格式，并将文本写入屏幕。</span><span class="sxs-lookup"><span data-stu-id="970a2-246">The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and writes the text to the screen.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-247"><see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 属性为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-247">The <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> property is <see langword="false" />.</span></span>  
  
<span data-ttu-id="970a2-248">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-248">-or-</span></span> 
<span data-ttu-id="970a2-249"><see cref="P:System.Diagnostics.Process.StandardOutput" /> 流上已在进行异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-249">An asynchronous read operation is already in progress on the <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream.</span></span>  
  
<span data-ttu-id="970a2-250">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-250">-or-</span></span> 
<span data-ttu-id="970a2-251">同步读取操作已使用 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 流。</span><span class="sxs-lookup"><span data-stu-id="970a2-251">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has been used by a synchronous read operation.</span></span></exception>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberSignature Language="F#" Value="member this.CancelErrorRead : unit -&gt; unit" Usage="process.CancelErrorRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="970a2-252">取消在应用程序的重定向 <see cref="P:System.Diagnostics.Process.StandardError" /> 流上执行的异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-252">Cancels the asynchronous read operation on the redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream of an application.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-253"><xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 对 <xref:System.Diagnostics.Process.StandardError%2A> 流启动异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-253"><xref:System.Diagnostics.Process.BeginErrorReadLine%2A> starts an asynchronous read operation on the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span> <span data-ttu-id="970a2-254"><xref:System.Diagnostics.Process.CancelErrorRead%2A> 结束异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-254"><xref:System.Diagnostics.Process.CancelErrorRead%2A> ends the asynchronous read operation.</span></span>  
  
 <span data-ttu-id="970a2-255">取消后，可以通过再次调用 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 恢复异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-255">After canceling, you can resume the asynchronous read operation by calling <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> again.</span></span>  
  
 <span data-ttu-id="970a2-256">调用 <xref:System.Diagnostics.Process.CancelErrorRead%2A>时，将完成 <xref:System.Diagnostics.Process.StandardError%2A> 的所有正在进行的读取操作，并禁用事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="970a2-256">When you call <xref:System.Diagnostics.Process.CancelErrorRead%2A>, all in-progress read operations for <xref:System.Diagnostics.Process.StandardError%2A> are completed and then the event handler is disabled.</span></span> <span data-ttu-id="970a2-257">将丢失所有进一步的重定向输出到 <xref:System.Diagnostics.Process.StandardError%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-257">All further redirected output to <xref:System.Diagnostics.Process.StandardError%2A> will be lost.</span></span> <span data-ttu-id="970a2-258">如果通过调用 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>重新启用事件处理程序，则会恢复异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-258">If you re-enable the event handler with a call to <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, asynchronous read operations resume.</span></span> <span data-ttu-id="970a2-259">如果要在恢复异步读取操作之前更改事件处理程序，则必须先删除现有的事件处理程序，然后再添加新的事件处理程序：</span><span class="sxs-lookup"><span data-stu-id="970a2-259">If you want to change the event handler before resuming asynchronous read operations, you must remove the existing event handler before adding the new event handler:</span></span>  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  <span data-ttu-id="970a2-260">不能对重定向的 <xref:System.Diagnostics.Process.StandardError%2A> 流混合使用异步和同步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-260">You cannot mix asynchronous and synchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span> <span data-ttu-id="970a2-261">在异步或同步模式下打开 <xref:System.Diagnostics.Process> 的重定向流后，对该流进行的所有进一步读取操作都必须处于相同的模式下。</span><span class="sxs-lookup"><span data-stu-id="970a2-261">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="970a2-262">如果取消对 <xref:System.Diagnostics.Process.StandardError%2A> 的异步读取操作，然后需要重新读取流，则必须使用 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 才能恢复异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-262">If you cancel an asynchronous read operation on <xref:System.Diagnostics.Process.StandardError%2A> and then need to read from the stream again, you must use <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> to resume asynchronous read operations.</span></span> <span data-ttu-id="970a2-263">不要跟随 <xref:System.Diagnostics.Process.CancelErrorRead%2A> 调用 <xref:System.Diagnostics.Process.StandardError%2A> 的同步读取方法，如 <xref:System.IO.StreamReader.Read%2A>、<xref:System.IO.StreamReader.ReadLine%2A>或 <xref:System.IO.StreamReader.ReadToEnd%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-263">Do not follow <xref:System.Diagnostics.Process.CancelErrorRead%2A> with a call to the synchronous read methods of <xref:System.Diagnostics.Process.StandardError%2A> such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, or <xref:System.IO.StreamReader.ReadToEnd%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-264">下面的示例用用户提供的参数启动 `nmake` 命令。</span><span class="sxs-lookup"><span data-stu-id="970a2-264">The following example starts the `nmake` command with user supplied arguments.</span></span> <span data-ttu-id="970a2-265">异步读取错误和输出流;收集的文本行将显示到控制台并写入日志文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-265">The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file.</span></span> <span data-ttu-id="970a2-266">如果命令输出超过指定的行数，则将取消异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-266">If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-267">未针对异步读取操作启用 <see cref="P:System.Diagnostics.Process.StandardError" /> 流。</span><span class="sxs-lookup"><span data-stu-id="970a2-267">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream is not enabled for asynchronous read operations.</span></span></exception>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberSignature Language="F#" Value="member this.CancelOutputRead : unit -&gt; unit" Usage="process.CancelOutputRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="970a2-268">取消在应用程序的重定向 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 流上执行的异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-268">Cancels the asynchronous read operation on the redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream of an application.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-269"><xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 对 <xref:System.Diagnostics.Process.StandardOutput%2A> 流启动异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-269"><xref:System.Diagnostics.Process.BeginOutputReadLine%2A> starts an asynchronous read operation on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="970a2-270"><xref:System.Diagnostics.Process.CancelOutputRead%2A> 结束异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-270"><xref:System.Diagnostics.Process.CancelOutputRead%2A> ends the asynchronous read operation.</span></span>  
  
 <span data-ttu-id="970a2-271">取消后，可以通过再次调用 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 恢复异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-271">After canceling, you can resume asynchronous read operations by calling <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> again.</span></span>  
  
 <span data-ttu-id="970a2-272">调用 <xref:System.Diagnostics.Process.CancelOutputRead%2A>时，将完成 <xref:System.Diagnostics.Process.StandardOutput%2A> 的所有正在进行的读取操作，并禁用事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="970a2-272">When you call <xref:System.Diagnostics.Process.CancelOutputRead%2A>, all in-progress read operations for <xref:System.Diagnostics.Process.StandardOutput%2A> are completed and then the event handler is disabled.</span></span> <span data-ttu-id="970a2-273">所有进一步的重定向输出到 <xref:System.Diagnostics.Process.StandardOutput%2A> 都保存在一个缓冲区中。</span><span class="sxs-lookup"><span data-stu-id="970a2-273">All further redirected output to <xref:System.Diagnostics.Process.StandardOutput%2A> is saved in a buffer.</span></span> <span data-ttu-id="970a2-274">如果使用对 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>重新启用事件处理程序，则会将保存的输出发送到事件处理程序，并恢复异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-274">If you re-enable the event handler with a call to <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, the saved output is sent to the event handler and asynchronous read operations resume.</span></span> <span data-ttu-id="970a2-275">如果要在恢复异步读取操作之前更改事件处理程序，则必须先删除现有的事件处理程序，然后再添加新的事件处理程序：</span><span class="sxs-lookup"><span data-stu-id="970a2-275">If you want to change the event handler before resuming asynchronous read operations, you must remove the existing event handler before adding the new event handler:</span></span>  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  <span data-ttu-id="970a2-276">不能对重定向的 <xref:System.Diagnostics.Process.StandardOutput%2A> 流混合使用异步和同步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-276">You cannot mix asynchronous and synchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="970a2-277">在异步或同步模式下打开 <xref:System.Diagnostics.Process> 的重定向流后，对该流进行的所有进一步读取操作都必须处于相同的模式下。</span><span class="sxs-lookup"><span data-stu-id="970a2-277">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="970a2-278">如果取消对 <xref:System.Diagnostics.Process.StandardOutput%2A> 的异步读取操作，然后需要重新读取流，则必须使用 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 才能恢复异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-278">If you cancel an asynchronous read operation on <xref:System.Diagnostics.Process.StandardOutput%2A> and then need to read from the stream again, you must use <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> to resume asynchronous read operations.</span></span> <span data-ttu-id="970a2-279">不要跟随 <xref:System.Diagnostics.Process.CancelOutputRead%2A> 调用 <xref:System.Diagnostics.Process.StandardOutput%2A> 的同步读取方法，如 <xref:System.IO.StreamReader.Read%2A>、<xref:System.IO.StreamReader.ReadLine%2A>或 <xref:System.IO.StreamReader.ReadToEnd%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-279">Do not follow <xref:System.Diagnostics.Process.CancelOutputRead%2A> with a call to the synchronous read methods of <xref:System.Diagnostics.Process.StandardOutput%2A> such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, or <xref:System.IO.StreamReader.ReadToEnd%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-280">下面的示例用用户提供的参数启动 `nmake` 命令。</span><span class="sxs-lookup"><span data-stu-id="970a2-280">The following example starts the `nmake` command with user supplied arguments.</span></span> <span data-ttu-id="970a2-281">异步读取错误和输出流;收集的文本行将显示到控制台并写入日志文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-281">The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file.</span></span> <span data-ttu-id="970a2-282">如果命令输出超过指定的行数，则将取消异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-282">If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-283">未针对异步读取操作启用 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 流。</span><span class="sxs-lookup"><span data-stu-id="970a2-283">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream is not enabled for asynchronous read operations.</span></span></exception>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="process.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="970a2-284">释放与此组件关联的所有资源。</span><span class="sxs-lookup"><span data-stu-id="970a2-284">Frees all the resources that are associated with this component.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-285"><xref:System.Diagnostics.Process.Close%2A> 方法会使进程在等待时停止等待退出，并关闭进程句柄，并清除特定于进程的属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-285">The <xref:System.Diagnostics.Process.Close%2A> method causes the process to stop waiting for exit if it was waiting, closes the process handle, and clears process-specific properties.</span></span> <span data-ttu-id="970a2-286"><xref:System.Diagnostics.Process.Close%2A> 不会在外部引用标准输出、输入和错误读取器和编写器时关闭它们。</span><span class="sxs-lookup"><span data-stu-id="970a2-286"><xref:System.Diagnostics.Process.Close%2A> does not close the standard output, input, and error readers and writers in case they are being referenced externally.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-287"><xref:System.Diagnostics.Process.Dispose%2A> 方法调用 <xref:System.Diagnostics.Process.Close%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-287">The <xref:System.Diagnostics.Process.Dispose%2A> method calls <xref:System.Diagnostics.Process.Close%2A>.</span></span> <span data-ttu-id="970a2-288">将 <xref:System.Diagnostics.Process> 对象置于 `using` 块会释放资源，而无需调用 <xref:System.Diagnostics.Process.Close%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-288">Placing the <xref:System.Diagnostics.Process> object in a `using` block disposes of resources without the need to call <xref:System.Diagnostics.Process.Close%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-289">下面的示例启动记事本的实例。</span><span class="sxs-lookup"><span data-stu-id="970a2-289">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="970a2-290">然后，它会以2秒的间隔检索关联进程的物理内存使用率，最大值为10秒。</span><span class="sxs-lookup"><span data-stu-id="970a2-290">It then retrieves the physical memory usage of the associated process at 2-second intervals for a maximum of 10 seconds.</span></span> <span data-ttu-id="970a2-291">该示例检测进程是否在10秒后退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-291">The example detects whether the process exits before 10 seconds have elapsed.</span></span> <span data-ttu-id="970a2-292">如果10秒后仍在运行，则此示例将关闭进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-292">The example closes the process if it is still running after 10 seconds.</span></span>  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberSignature Language="F#" Value="member this.CloseMainWindow : unit -&gt; bool" Usage="process.CloseMainWindow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="970a2-293">通过向进程的主窗口发送关闭消息来关闭拥有用户界面的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-293">Closes a process that has a user interface by sending a close message to its main window.</span></span></summary>
        <returns><span data-ttu-id="970a2-294">如果成功发送了关闭消息，则为 <see langword="true" />；如果关联进程没有主窗口或禁用了主窗口(例如，如果当前显示模式对话框)，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-294"><see langword="true" /> if the close message was successfully sent; <see langword="false" /> if the associated process does not have a main window or if the main window is disabled (for example if a modal dialog is being shown).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-295">进程执行时，其消息循环处于等待状态。</span><span class="sxs-lookup"><span data-stu-id="970a2-295">When a process is executing, its message loop is in a wait state.</span></span> <span data-ttu-id="970a2-296">每次操作系统将 Windows 消息发送到该进程时，消息循环都会执行。</span><span class="sxs-lookup"><span data-stu-id="970a2-296">The message loop executes every time a Windows message is sent to the process by the operating system.</span></span> <span data-ttu-id="970a2-297">调用 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 将发送一个请求来关闭主窗口，该窗口在格式正确的应用程序中将关闭子窗口，并为应用程序撤消所有正在运行的消息循环。</span><span class="sxs-lookup"><span data-stu-id="970a2-297">Calling <xref:System.Diagnostics.Process.CloseMainWindow%2A> sends a request to close the main window, which, in a well-formed application, closes child windows and revokes all running message loops for the application.</span></span> <span data-ttu-id="970a2-298">通过调用 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 退出进程的请求不会强制应用程序退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-298">The request to exit the process by calling <xref:System.Diagnostics.Process.CloseMainWindow%2A> does not force the application to quit.</span></span> <span data-ttu-id="970a2-299">应用程序可以在退出前要求用户进行验证，也可以拒绝退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-299">The application can ask for user verification before quitting, or it can refuse to quit.</span></span> <span data-ttu-id="970a2-300">若要强制退出应用程序，请使用 <xref:System.Diagnostics.Process.Kill%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="970a2-300">To force the application to quit, use the <xref:System.Diagnostics.Process.Kill%2A> method.</span></span> <span data-ttu-id="970a2-301"><xref:System.Diagnostics.Process.CloseMainWindow%2A> 的行为与用户使用系统菜单关闭应用程序的主窗口的行为相同。</span><span class="sxs-lookup"><span data-stu-id="970a2-301">The behavior of <xref:System.Diagnostics.Process.CloseMainWindow%2A> is identical to that of a user closing an application's main window using the system menu.</span></span> <span data-ttu-id="970a2-302">因此，通过关闭主窗口来退出进程的请求不会强制立即退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-302">Therefore, the request to exit the process by closing the main window does not force the application to quit immediately.</span></span>  
  
 <span data-ttu-id="970a2-303">如果调用 <xref:System.Diagnostics.Process.Kill%2A>，则进程编辑的数据或分配给进程的资源可能会丢失。</span><span class="sxs-lookup"><span data-stu-id="970a2-303">Data edited by the process or resources allocated to the process can be lost if you call <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="970a2-304"><xref:System.Diagnostics.Process.Kill%2A> 导致异常进程终止，只应在必要时使用。</span><span class="sxs-lookup"><span data-stu-id="970a2-304"><xref:System.Diagnostics.Process.Kill%2A> causes an abnormal process termination, and should be used only when necessary.</span></span> <span data-ttu-id="970a2-305"><xref:System.Diagnostics.Process.CloseMainWindow%2A> 可以有序终止进程，并关闭所有窗口，因此更适合使用接口的应用程序。</span><span class="sxs-lookup"><span data-stu-id="970a2-305"><xref:System.Diagnostics.Process.CloseMainWindow%2A> enables an orderly termination of the process and closes all windows, so it is preferable for applications with an interface.</span></span> <span data-ttu-id="970a2-306">如果 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 失败，则可以使用 <xref:System.Diagnostics.Process.Kill%2A> 终止进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-306">If <xref:System.Diagnostics.Process.CloseMainWindow%2A> fails, you can use <xref:System.Diagnostics.Process.Kill%2A> to terminate the process.</span></span> <span data-ttu-id="970a2-307"><xref:System.Diagnostics.Process.Kill%2A> 是终止没有图形界面的进程的唯一方法。</span><span class="sxs-lookup"><span data-stu-id="970a2-307"><xref:System.Diagnostics.Process.Kill%2A> is the only way to terminate processes that do not have graphical interfaces.</span></span>  
  
 <span data-ttu-id="970a2-308">只能对在本地计算机上运行的进程调用 <xref:System.Diagnostics.Process.Kill%2A> 和 <xref:System.Diagnostics.Process.CloseMainWindow%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-308">You can call <xref:System.Diagnostics.Process.Kill%2A> and <xref:System.Diagnostics.Process.CloseMainWindow%2A> only for processes that are running on the local computer.</span></span> <span data-ttu-id="970a2-309">不能使远程计算机上的进程退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-309">You cannot cause processes on remote computers to exit.</span></span> <span data-ttu-id="970a2-310">只能查看远程计算机上运行的进程的信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-310">You can only view information for processes running on remote computers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-311">下面的示例启动记事本的实例。</span><span class="sxs-lookup"><span data-stu-id="970a2-311">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="970a2-312">然后，它以2秒的间隔检索关联进程的物理内存使用率，最大值为10秒。</span><span class="sxs-lookup"><span data-stu-id="970a2-312">It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds.</span></span> <span data-ttu-id="970a2-313">该示例检测进程是否在10秒后退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-313">The example detects whether the process exits before 10 seconds have elapsed.</span></span> <span data-ttu-id="970a2-314">如果10秒后仍在运行，则此示例将关闭进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-314">The example closes the process if it is still running after 10 seconds.</span></span>  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-315">已经退出该进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-315">The process has already exited.</span></span>  
  
<span data-ttu-id="970a2-316">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-316">-or-</span></span> 
<span data-ttu-id="970a2-317">没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-317">No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="process.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="970a2-318">执行与释放或重置非托管资源关联的应用程序定义的任务。</span><span class="sxs-lookup"><span data-stu-id="970a2-318">Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="970a2-319">若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-319"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="970a2-320">释放此进程使用的所有资源。</span><span class="sxs-lookup"><span data-stu-id="970a2-320">Release all resources used by this process.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessEnableRaisingEvents")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-321">获取或设置在进程终止时是否应引发 <see cref="E:System.Diagnostics.Process.Exited" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="970a2-321">Gets or sets whether the <see cref="E:System.Diagnostics.Process.Exited" /> event should be raised when the process terminates.</span></span></summary>
        <value><span data-ttu-id="970a2-322">如果关联的进程终止（通过退出或者调用<see langword="true" /> ）时应引发 <see cref="E:System.Diagnostics.Process.Exited" /> 事件，则为 <see cref="M:System.Diagnostics.Process.Kill" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-322"><see langword="true" /> if the <see cref="E:System.Diagnostics.Process.Exited" /> event should be raised when the associated process is terminated (through either an exit or a call to <see cref="M:System.Diagnostics.Process.Kill" />); otherwise, <see langword="false" />.</span></span> <span data-ttu-id="970a2-323">默认值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-323">The default is <see langword="false" />.</span></span> <span data-ttu-id="970a2-324">请注意，即使在用户执行 <see cref="P:System.Diagnostics.Process.HasExited" /> 检查的过程中，当进程退出时 <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> 的值 <see langword="false" />，也会引发 <see cref="E:System.Diagnostics.Process.Exited" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="970a2-324">Note that the <see cref="E:System.Diagnostics.Process.Exited" /> event is raised even if the value of <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> is <see langword="false" /> when the process exits during or before the user performs a <see cref="P:System.Diagnostics.Process.HasExited" /> check.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
<span data-ttu-id="970a2-325"><xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 属性建议在操作系统关闭进程时是否应通知组件。</span><span class="sxs-lookup"><span data-stu-id="970a2-325">The <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property suggests whether the component should be notified when the operating system has shut down a process.</span></span> <span data-ttu-id="970a2-326"><xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 属性用于异步处理，以通知应用程序进程已退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-326">The <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property is used in asynchronous processing to notify your application that a process has exited.</span></span> <span data-ttu-id="970a2-327">若要强制您的应用程序以同步方式等待退出事件（这会中断应用程序的处理，直到发生退出事件），请使用 <xref:System.Diagnostics.Process.WaitForExit%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="970a2-327">To force your application to synchronously wait for an exit event (which interrupts processing of the application until the exit event has occurred), use the <xref:System.Diagnostics.Process.WaitForExit%2A> method.</span></span>

> [!NOTE]
> <span data-ttu-id="970a2-328">如果使用的是 Visual Studio 并双击项目中的 <xref:System.Diagnostics.Process> 组件，将自动生成 <xref:System.Diagnostics.Process.Exited> 事件委托和事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="970a2-328">If you're using Visual Studio and double-click a <xref:System.Diagnostics.Process> component in your project, an <xref:System.Diagnostics.Process.Exited> event delegate and event handler are automatically generated.</span></span> <span data-ttu-id="970a2-329">其他代码将 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 属性设置为 `false`。</span><span class="sxs-lookup"><span data-stu-id="970a2-329">Additional code sets the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property to `false`.</span></span> <span data-ttu-id="970a2-330">您必须将此属性更改为 `true`，以便事件处理程序在关联进程退出时执行。</span><span class="sxs-lookup"><span data-stu-id="970a2-330">You must change this property to `true` for your event handler to execute when the associated process exits.</span></span>

<span data-ttu-id="970a2-331">如果组件的 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 值为 `true`，或者当 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> `false` 并且组件调用了 <xref:System.Diagnostics.Process.HasExited%2A> 检查时，该组件可以访问关联进程的管理信息，该信息仍由操作系统存储。</span><span class="sxs-lookup"><span data-stu-id="970a2-331">If the component's <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> value is `true`, or when <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> is `false` and a <xref:System.Diagnostics.Process.HasExited%2A> check is invoked by the component, the component can access the administrative information for the associated process, which remains stored by the operating system.</span></span> <span data-ttu-id="970a2-332">此类信息包括 <xref:System.Diagnostics.Process.ExitTime%2A> 和 <xref:System.Diagnostics.Process.ExitCode%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-332">Such information includes the <xref:System.Diagnostics.Process.ExitTime%2A> and the <xref:System.Diagnostics.Process.ExitCode%2A>.</span></span>

<span data-ttu-id="970a2-333">关联进程退出后，该组件的 <xref:System.Diagnostics.Process.Handle%2A> 将不再指向现有进程资源。</span><span class="sxs-lookup"><span data-stu-id="970a2-333">After the associated process exits, the <xref:System.Diagnostics.Process.Handle%2A> of the component no longer points to an existing process resource.</span></span> <span data-ttu-id="970a2-334">相反，它只能用于访问有关进程资源的操作系统的信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-334">Instead, it can only be used to access the operating system's information about the process resource.</span></span> <span data-ttu-id="970a2-335">操作系统会注意到，存在已被 <xref:System.Diagnostics.Process> 组件释放的退出进程的句柄，因此它会将 <xref:System.Diagnostics.Process.ExitTime%2A> 和 <xref:System.Diagnostics.Process.Handle%2A> 信息保留在内存中。</span><span class="sxs-lookup"><span data-stu-id="970a2-335">The operating system is aware that there are handles to exited processes that haven't been released by <xref:System.Diagnostics.Process> components, so it keeps the <xref:System.Diagnostics.Process.ExitTime%2A> and <xref:System.Diagnostics.Process.Handle%2A> information in memory.</span></span>

<span data-ttu-id="970a2-336">监视进程退出会产生相关费用。</span><span class="sxs-lookup"><span data-stu-id="970a2-336">There's a cost associated with watching for a process to exit.</span></span> <span data-ttu-id="970a2-337">如果 `true`<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>，则在关联进程终止时，将引发 <xref:System.Diagnostics.Process.Exited> 事件。</span><span class="sxs-lookup"><span data-stu-id="970a2-337">If <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> is `true`, the <xref:System.Diagnostics.Process.Exited> event is raised when the associated process terminates.</span></span> <span data-ttu-id="970a2-338">此时将运行 <xref:System.Diagnostics.Process.Exited> 事件的过程。</span><span class="sxs-lookup"><span data-stu-id="970a2-338">Your procedures for the <xref:System.Diagnostics.Process.Exited> event run at that time.</span></span>

<span data-ttu-id="970a2-339">有时，应用程序会启动进程，但不需要通知结束。</span><span class="sxs-lookup"><span data-stu-id="970a2-339">Sometimes, your application starts a process but doesn't require notification of its closure.</span></span> <span data-ttu-id="970a2-340">例如，你的应用程序可以启动记事本，以允许用户执行文本编辑，但不会再进一步使用记事本应用程序。</span><span class="sxs-lookup"><span data-stu-id="970a2-340">For example, your application can start Notepad to allow the user to perform text editing but make no further use of the Notepad application.</span></span> <span data-ttu-id="970a2-341">你可以选择在进程退出时避免通知，因为它与你的应用程序的继续操作无关。</span><span class="sxs-lookup"><span data-stu-id="970a2-341">You can choose to avoid notification when the process exits because it's not relevant to the continued operation of your application.</span></span> <span data-ttu-id="970a2-342">将 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 设置为 `false` 可以保存系统资源。</span><span class="sxs-lookup"><span data-stu-id="970a2-342">Setting <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> to `false` can save system resources.</span></span>

## Examples  
<span data-ttu-id="970a2-343">下面的代码示例创建打印文件的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-343">The following code example creates a process that prints a file.</span></span> <span data-ttu-id="970a2-344">它设置 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 属性，使进程在退出时引发 <xref:System.Diagnostics.Process.Exited> 事件。</span><span class="sxs-lookup"><span data-stu-id="970a2-344">It sets the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property to cause the process to raise the <xref:System.Diagnostics.Process.Exited> event when it exits.</span></span> <span data-ttu-id="970a2-345"><xref:System.Diagnostics.Process.Exited> 事件处理程序显示进程信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-345">The <xref:System.Diagnostics.Process.Exited> event handler displays process information.</span></span>

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberSignature Language="F#" Value="static member EnterDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.EnterDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="970a2-346">通过启用当前线程的本机属性 <see cref="T:System.Diagnostics.Process" />，将 <see langword="SeDebugPrivilege" /> 组件置于与以特殊模式运行的操作系统进程交互的状态。</span><span class="sxs-lookup"><span data-stu-id="970a2-346">Puts a <see cref="T:System.Diagnostics.Process" /> component in state to interact with operating system processes that run in a special mode by enabling the native property <see langword="SeDebugPrivilege" /> on the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-347">某些操作系统进程以特殊模式运行。</span><span class="sxs-lookup"><span data-stu-id="970a2-347">Some operating system processes run in a special mode.</span></span> <span data-ttu-id="970a2-348">如果在组件上调用了 <xref:System.Diagnostics.Process.EnterDebugMode%2A>，则不可能尝试读取或附加到这些进程的属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-348">Attempting to read properties of or attach to these processes is not possible unless you have called <xref:System.Diagnostics.Process.EnterDebugMode%2A> on the component.</span></span> <span data-ttu-id="970a2-349">如果不再需要访问以特殊模式运行的这些进程，请调用 <xref:System.Diagnostics.Process.LeaveDebugMode%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-349">Call <xref:System.Diagnostics.Process.LeaveDebugMode%2A> when you no longer need access to these processes that run in special mode.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event ErrorDataReceived As DataReceivedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-350">当应用程序写入其重定向 <see cref="P:System.Diagnostics.Process.StandardError" /> 流中时发生。</span><span class="sxs-lookup"><span data-stu-id="970a2-350">Occurs when an application writes to its redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-351"><xref:System.Diagnostics.Process.ErrorDataReceived> 事件指示关联进程已写入其重定向的 <xref:System.Diagnostics.Process.StandardError%2A> 流。</span><span class="sxs-lookup"><span data-stu-id="970a2-351">The <xref:System.Diagnostics.Process.ErrorDataReceived> event indicates that the associated process has written to its redirected <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
 <span data-ttu-id="970a2-352">此事件仅在 <xref:System.Diagnostics.Process.StandardError%2A>的异步读取操作过程中发生。</span><span class="sxs-lookup"><span data-stu-id="970a2-352">The event only occurs during asynchronous read operations on <xref:System.Diagnostics.Process.StandardError%2A>.</span></span> <span data-ttu-id="970a2-353">若要启动异步读取操作，必须重定向 <xref:System.Diagnostics.Process>的 <xref:System.Diagnostics.Process.StandardError%2A> 流，将事件处理程序添加到 <xref:System.Diagnostics.Process.ErrorDataReceived> 事件，并调用 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-353">To start asynchronous read operations, you must redirect the <xref:System.Diagnostics.Process.StandardError%2A> stream of a <xref:System.Diagnostics.Process>, add your event handler to the <xref:System.Diagnostics.Process.ErrorDataReceived> event, and call <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>.</span></span> <span data-ttu-id="970a2-354">此后，每次进程将行写入重定向的 <xref:System.Diagnostics.Process.StandardError%2A> 流时，<xref:System.Diagnostics.Process.ErrorDataReceived> 事件都会发出信号，直到进程退出或调用 <xref:System.Diagnostics.Process.CancelErrorRead%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-354">Thereafter, the <xref:System.Diagnostics.Process.ErrorDataReceived> event signals each time the process writes a line to the redirected <xref:System.Diagnostics.Process.StandardError%2A> stream, until the process exits or calls <xref:System.Diagnostics.Process.CancelErrorRead%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-355">处理异步输出的应用程序应调用 <xref:System.Diagnostics.Process.WaitForExit> 方法，以确保刷新了输出缓冲区。</span><span class="sxs-lookup"><span data-stu-id="970a2-355">The application that is processing the asynchronous output should call the <xref:System.Diagnostics.Process.WaitForExit> method to ensure that the output buffer has been flushed.</span></span> <span data-ttu-id="970a2-356">请注意，通过使用 <xref:System.Diagnostics.Process.WaitForExit(System.Int32)> 重载来指定超时*不*会确保输出缓冲区已刷新。</span><span class="sxs-lookup"><span data-stu-id="970a2-356">Note that specifying a timeout by using the <xref:System.Diagnostics.Process.WaitForExit(System.Int32)> overload does *not* ensure the output buffer has been flushed.</span></span>
  
   
  
## Examples  
 <span data-ttu-id="970a2-357">以下示例使用 `net view` 命令列出远程计算机上可用的网络资源。</span><span class="sxs-lookup"><span data-stu-id="970a2-357">The following example uses the `net view` command to list the available network resources on a remote computer.</span></span> <span data-ttu-id="970a2-358">用户以命令行参数的形式提供目标计算机名称。</span><span class="sxs-lookup"><span data-stu-id="970a2-358">The user supplies the target computer name as a command-line argument.</span></span> <span data-ttu-id="970a2-359">用户还可以提供错误输出的文件名。</span><span class="sxs-lookup"><span data-stu-id="970a2-359">The user can also supply a file name for error output.</span></span> <span data-ttu-id="970a2-360">该示例收集 net 命令的输出，等待进程完成，然后将输出结果写入控制台。</span><span class="sxs-lookup"><span data-stu-id="970a2-360">The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console.</span></span> <span data-ttu-id="970a2-361">如果用户提供了可选的错误文件，则该示例会将错误写入文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-361">If the user supplies the optional error file, the example writes errors to the file.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int" Usage="System.Diagnostics.Process.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitCode")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-362">获取关联进程终止时指定的值。</span><span class="sxs-lookup"><span data-stu-id="970a2-362">Gets the value that the associated process specified when it terminated.</span></span></summary>
        <value><span data-ttu-id="970a2-363">关联进程终止时指定的代码。</span><span class="sxs-lookup"><span data-stu-id="970a2-363">The code that the associated process specified when it terminated.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-364">使用 <xref:System.Diagnostics.Process.ExitCode%2A> 获取系统进程在退出时返回的状态。</span><span class="sxs-lookup"><span data-stu-id="970a2-364">Use <xref:System.Diagnostics.Process.ExitCode%2A> to get the status that the system process returned when it exited.</span></span> <span data-ttu-id="970a2-365">您可以使用退出代码，这与 `main()` 过程中的整数返回值非常类似。</span><span class="sxs-lookup"><span data-stu-id="970a2-365">You can use the exit code much like an integer return value from a `main()` procedure.</span></span>  
  
 <span data-ttu-id="970a2-366">进程的 <xref:System.Diagnostics.Process.ExitCode%2A> 值反映了该进程的应用程序开发人员实现的特定约定。</span><span class="sxs-lookup"><span data-stu-id="970a2-366">The <xref:System.Diagnostics.Process.ExitCode%2A> value for a process reflects the specific convention implemented by the application developer for that process.</span></span> <span data-ttu-id="970a2-367">如果使用退出代码值在代码中做出决策，请确保了解应用程序进程使用的退出代码约定。</span><span class="sxs-lookup"><span data-stu-id="970a2-367">If you use the exit code value to make decisions in your code, be sure that you know the exit code convention used by the application process.</span></span>  
  
 <span data-ttu-id="970a2-368">开发人员通常会指示 <xref:System.Diagnostics.Process.ExitCode%2A> 值为零的成功退出，并通过非零值指定错误，调用方法可以使用该值来识别异常进程终止的原因。</span><span class="sxs-lookup"><span data-stu-id="970a2-368">Developers usually indicate a successful exit by an <xref:System.Diagnostics.Process.ExitCode%2A> value of zero, and designate errors by nonzero values that the calling method can use to identify the cause of an abnormal process termination.</span></span> <span data-ttu-id="970a2-369">不需要遵循这些准则，但它们是约定。</span><span class="sxs-lookup"><span data-stu-id="970a2-369">It is not necessary to follow these guidelines, but they are the convention.</span></span>  
  
 <span data-ttu-id="970a2-370">如果尝试在进程退出之前获取 <xref:System.Diagnostics.Process.ExitCode%2A>，尝试会引发异常。</span><span class="sxs-lookup"><span data-stu-id="970a2-370">If you try to get the <xref:System.Diagnostics.Process.ExitCode%2A> before the process has exited, the attempt throws an exception.</span></span> <span data-ttu-id="970a2-371">首先检查 <xref:System.Diagnostics.Process.HasExited%2A> 属性以验证关联的进程是否已终止。</span><span class="sxs-lookup"><span data-stu-id="970a2-371">Examine the <xref:System.Diagnostics.Process.HasExited%2A> property first to verify whether the associated process has terminated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-372">将标准输出重定向到异步事件处理程序后，在 <xref:System.Diagnostics.Process.HasExited%2A> 返回 `true`时，输出处理可能不会完成。</span><span class="sxs-lookup"><span data-stu-id="970a2-372">When standard output has been redirected to asynchronous event handlers, it is possible that output processing will not have completed when <xref:System.Diagnostics.Process.HasExited%2A> returns `true`.</span></span> <span data-ttu-id="970a2-373">若要确保异步事件处理已完成，请在检查 <xref:System.Diagnostics.Process.HasExited%2A>之前调用不带任何参数的 <xref:System.Diagnostics.Process.WaitForExit> 重载。</span><span class="sxs-lookup"><span data-stu-id="970a2-373">To ensure that asynchronous event handling has been completed, call the <xref:System.Diagnostics.Process.WaitForExit> overload that takes no parameter before checking <xref:System.Diagnostics.Process.HasExited%2A>.</span></span>  
  
 <span data-ttu-id="970a2-374">您可以使用 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 或 <xref:System.Diagnostics.Process.Kill%2A> 方法来使关联进程退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-374">You can use the <xref:System.Diagnostics.Process.CloseMainWindow%2A> or the <xref:System.Diagnostics.Process.Kill%2A> method to cause an associated process to exit.</span></span>  
  
 <span data-ttu-id="970a2-375">关联进程退出时，有两种通知方式：同步和异步。</span><span class="sxs-lookup"><span data-stu-id="970a2-375">There are two ways of being notified when the associated process exits: synchronously and asynchronously.</span></span> <span data-ttu-id="970a2-376">同步通知依赖于调用 <xref:System.Diagnostics.Process.WaitForExit%2A> 方法来暂停应用程序的处理，直到关联的组件退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-376">Synchronous notification relies on calling the <xref:System.Diagnostics.Process.WaitForExit%2A> method to pause the processing of your application until the associated component exits.</span></span> <span data-ttu-id="970a2-377">异步通知依赖于 <xref:System.Diagnostics.Process.Exited> 事件。</span><span class="sxs-lookup"><span data-stu-id="970a2-377">Asynchronous notification relies on the <xref:System.Diagnostics.Process.Exited> event.</span></span> <span data-ttu-id="970a2-378">使用异步通知时，必须将 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 设置为 `true`，才能让 <xref:System.Diagnostics.Process> 组件收到进程已退出的通知。</span><span class="sxs-lookup"><span data-stu-id="970a2-378">When using asynchronous notification, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> must be set to `true` for the <xref:System.Diagnostics.Process> component to receive notification that the process has exited.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-379">下面的示例启动记事本的实例。</span><span class="sxs-lookup"><span data-stu-id="970a2-379">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="970a2-380">然后，该示例检索并显示关联进程的各种属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-380">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="970a2-381">该示例在进程退出时进行检测，并显示该进程的退出代码。</span><span class="sxs-lookup"><span data-stu-id="970a2-381">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-382">进程尚未退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-382">The process has not exited.</span></span>  
  
<span data-ttu-id="970a2-383">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-383">-or-</span></span> 
<span data-ttu-id="970a2-384">进程 <see cref="P:System.Diagnostics.Process.Handle" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="970a2-384">The process <see cref="P:System.Diagnostics.Process.Handle" /> is not valid.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="970a2-385">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.ExitCode" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-385">You are trying to access the <see cref="P:System.Diagnostics.Process.ExitCode" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="970a2-386">此属性仅可用于本地计算机上运行的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-386">This property is available only for processes that are running on the local computer.</span></span></exception>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberSignature Language="F#" Value="member this.Exited : EventHandler " Usage="member this.Exited : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExited")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-387">在进程退出时发生。</span><span class="sxs-lookup"><span data-stu-id="970a2-387">Occurs when a process exits.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-388"><xref:System.Diagnostics.Process.Exited> 事件指示关联进程已退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-388">The <xref:System.Diagnostics.Process.Exited> event indicates that the associated process exited.</span></span> <span data-ttu-id="970a2-389">此事件表示进程已终止（中止）或已成功关闭。</span><span class="sxs-lookup"><span data-stu-id="970a2-389">This occurrence means either that the process terminated (aborted) or successfully closed.</span></span> <span data-ttu-id="970a2-390">仅当 `true`<xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 属性的值时，才会发生此事件。</span><span class="sxs-lookup"><span data-stu-id="970a2-390">This event can occur only if the value of the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property is `true`.</span></span>  
  
 <span data-ttu-id="970a2-391">关联进程退出时，有两种通知方式：同步和异步。</span><span class="sxs-lookup"><span data-stu-id="970a2-391">There are two ways of being notified when the associated process exits: synchronously and asynchronously.</span></span> <span data-ttu-id="970a2-392">同步通知意味着调用 <xref:System.Diagnostics.Process.WaitForExit%2A> 方法阻止当前线程，直到进程退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-392">Synchronous notification means calling the <xref:System.Diagnostics.Process.WaitForExit%2A> method to block the current thread until the process exits.</span></span> <span data-ttu-id="970a2-393">异步通知使用 <xref:System.Diagnostics.Process.Exited> 事件，该事件允许调用线程同时继续执行。</span><span class="sxs-lookup"><span data-stu-id="970a2-393">Asynchronous notification uses the <xref:System.Diagnostics.Process.Exited> event, which allows the calling thread to continue execution in the meantime.</span></span> <span data-ttu-id="970a2-394">在后一种情况下，<xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 必须设置为 `true` 以便调用应用程序接收退出的事件。</span><span class="sxs-lookup"><span data-stu-id="970a2-394">In the latter case, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> must be set to `true` for the calling application to receive the Exited event.</span></span>  
  
 <span data-ttu-id="970a2-395">当操作系统关闭进程时，它会通知所有其他进程已退出事件的已注册处理程序。</span><span class="sxs-lookup"><span data-stu-id="970a2-395">When the operating system shuts down a process, it notifies all other processes that have registered handlers for the Exited event.</span></span> <span data-ttu-id="970a2-396">目前，可以使用刚刚退出的进程的句柄来访问某些属性（如 <xref:System.Diagnostics.Process.ExitTime%2A>），并 <xref:System.Diagnostics.Process.HasExited%2A> 操作系统维护，直到它完全释放该句柄。</span><span class="sxs-lookup"><span data-stu-id="970a2-396">At this time, the handle of the process that just exited can be used to access some properties such as  <xref:System.Diagnostics.Process.ExitTime%2A> and <xref:System.Diagnostics.Process.HasExited%2A> that the operating system maintains until it releases that handle completely.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-397">即使您具有已退出进程的句柄，也不能再次调用 <xref:System.Diagnostics.Process.Start%2A> 来重新连接到同一进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-397">Even if you have a handle to an exited process, you cannot call <xref:System.Diagnostics.Process.Start%2A> again to reconnect to the same process.</span></span> <span data-ttu-id="970a2-398">调用 <xref:System.Diagnostics.Process.Start%2A> 会自动释放关联的进程，并使用同一文件而不是全新的 <xref:System.Diagnostics.Process.Handle%2A>连接到进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-398">Calling <xref:System.Diagnostics.Process.Start%2A> automatically releases the associated process and connects to a process with the same file but an entirely new <xref:System.Diagnostics.Process.Handle%2A>.</span></span>  
  
 <span data-ttu-id="970a2-399">有关在 Windows 窗体应用程序中使用 <xref:System.Diagnostics.Process.Exited> 事件的详细信息，请参阅 <xref:System.Diagnostics.Process.SynchronizingObject%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-399">For more information about the use of the <xref:System.Diagnostics.Process.Exited> event in Windows Forms applications, see the <xref:System.Diagnostics.Process.SynchronizingObject%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-400">下面的代码示例创建打印文件的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-400">The following code example creates a process that prints a file.</span></span> <span data-ttu-id="970a2-401">此方法在进程退出时引发 <xref:System.Diagnostics.Process.Exited> 事件，因为在创建进程时设置了 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-401">It raises the <xref:System.Diagnostics.Process.Exited> event when the process exits because the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property was set when the process was created.</span></span> <span data-ttu-id="970a2-402"><xref:System.Diagnostics.Process.Exited> 事件处理程序显示进程信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-402">The <xref:System.Diagnostics.Process.Exited> event handler displays process information.</span></span>  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitTime : DateTime" Usage="System.Diagnostics.Process.ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-403">获取关联进程退出的时间。</span><span class="sxs-lookup"><span data-stu-id="970a2-403">Gets the time that the associated process exited.</span></span></summary>
        <value><span data-ttu-id="970a2-404"><see cref="T:System.DateTime" />，它指示关联进程终止的时间。</span><span class="sxs-lookup"><span data-stu-id="970a2-404">A <see cref="T:System.DateTime" /> that indicates when the associated process was terminated.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-405">如果进程尚未终止，尝试检索 <xref:System.Diagnostics.Process.ExitTime%2A> 属性会引发异常。</span><span class="sxs-lookup"><span data-stu-id="970a2-405">If the process has not terminated, attempting to retrieve the <xref:System.Diagnostics.Process.ExitTime%2A> property throws an exception.</span></span> <span data-ttu-id="970a2-406">请在获取 <xref:System.Diagnostics.Process.ExitTime%2A> 属性之前使用 <xref:System.Diagnostics.Process.HasExited%2A> 来确定关联进程是否已终止。</span><span class="sxs-lookup"><span data-stu-id="970a2-406">Use <xref:System.Diagnostics.Process.HasExited%2A> before getting the <xref:System.Diagnostics.Process.ExitTime%2A> property to determine whether the associated process has terminated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-407">下面的代码示例创建打印文件的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-407">The following code example creates a process that prints a file.</span></span> <span data-ttu-id="970a2-408">进程在退出时引发 <xref:System.Diagnostics.Process.Exited> 事件，事件处理程序显示 <xref:System.Diagnostics.Process.ExitTime%2A> 属性和其他进程信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-408">The process raises the <xref:System.Diagnostics.Process.Exited> event when it exits, and the event handler displays the <xref:System.Diagnostics.Process.ExitTime%2A> property and other process information.</span></span>  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="970a2-409">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.ExitTime" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-409">You are trying to access the <see cref="P:System.Diagnostics.Process.ExitTime" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="970a2-410">此属性仅可用于本地计算机上运行的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-410">This property is available only for processes that are running on the local computer.</span></span></exception>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcess : unit -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetCurrentProcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="970a2-411">获取新的 <see cref="T:System.Diagnostics.Process" /> 组件并将其与当前活动的进程关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-411">Gets a new <see cref="T:System.Diagnostics.Process" /> component and associates it with the currently active process.</span></span></summary>
        <returns><span data-ttu-id="970a2-412">与运行调用应用程序的进程资源关联的新的 <see cref="T:System.Diagnostics.Process" /> 组件。</span><span class="sxs-lookup"><span data-stu-id="970a2-412">A new <see cref="T:System.Diagnostics.Process" /> component associated with the process resource that is running the calling application.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-413">使用此方法创建新的 <xref:System.Diagnostics.Process> 实例，并将其与本地计算机上的进程资源关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-413">Use this method to create a new <xref:System.Diagnostics.Process> instance and associate it with the process resource on the local computer.</span></span>  
  
 <span data-ttu-id="970a2-414">与类似的 <xref:System.Diagnostics.Process.GetProcessById%2A>，<xref:System.Diagnostics.Process.GetProcessesByName%2A>和 <xref:System.Diagnostics.Process.GetProcesses%2A> 方法一样，<xref:System.Diagnostics.Process.GetCurrentProcess%2A> 将现有资源与新的 <xref:System.Diagnostics.Process> 组件相关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-414">Like the similar <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, and <xref:System.Diagnostics.Process.GetProcesses%2A> methods, <xref:System.Diagnostics.Process.GetCurrentProcess%2A> associates an existing resource with a new <xref:System.Diagnostics.Process> component.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-415">下面的示例检索当前进程的信息、在本地计算机上运行的进程、在本地计算机上运行的所有 Notepad 实例，以及本地计算机上的特定进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-415">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="970a2-416">然后，它将检索远程计算机上相同进程的信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-416">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="970a2-417">创建新的 <see cref="T:System.Diagnostics.Process" /> 组件，并将其与您指定的现有进程资源关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-417">Creates a new <see cref="T:System.Diagnostics.Process" /> component, and associates it with the existing process resource that you specify.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById processId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId"><span data-ttu-id="970a2-418">进程资源的系统唯一标识符。</span><span class="sxs-lookup"><span data-stu-id="970a2-418">The system-unique identifier of a process resource.</span></span></param>
        <summary><span data-ttu-id="970a2-419">返回新的 <see cref="T:System.Diagnostics.Process" /> 组件(给定本地计算机上某个进程的标识符)。</span><span class="sxs-lookup"><span data-stu-id="970a2-419">Returns a new <see cref="T:System.Diagnostics.Process" /> component, given the identifier of a process on the local computer.</span></span></summary>
        <returns><span data-ttu-id="970a2-420">与 <paramref name="processId" /> 参数标识的本地进程资源关联的 <see cref="T:System.Diagnostics.Process" /> 组件。</span><span class="sxs-lookup"><span data-stu-id="970a2-420">A <see cref="T:System.Diagnostics.Process" /> component that is associated with the local process resource identified by the <paramref name="processId" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-421">使用此方法创建新的 <xref:System.Diagnostics.Process> 组件，并将其与本地计算机上的进程资源关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-421">Use this method to create a new <xref:System.Diagnostics.Process> component and associate it with a process resource on the local computer.</span></span> <span data-ttu-id="970a2-422">进程资源必须已存在于计算机上，因为 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> 不会创建系统资源，而是将资源与应用程序生成的 <xref:System.Diagnostics.Process> 组件相关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-422">The process resource must already exist on the computer, because <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> does not create a system resource, but rather associates a resource with an application-generated <xref:System.Diagnostics.Process> component.</span></span> <span data-ttu-id="970a2-423">只能为当前在计算机上运行的进程检索进程 <xref:System.Diagnostics.Process.Id%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-423">A process <xref:System.Diagnostics.Process.Id%2A> can be retrieved only for a process that is currently running on the computer.</span></span> <span data-ttu-id="970a2-424">进程终止后，如果向其传递的是过期标识符，<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> 会引发异常。</span><span class="sxs-lookup"><span data-stu-id="970a2-424">After the process terminates, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> throws an exception if you pass it an expired identifier.</span></span>  
  
 <span data-ttu-id="970a2-425">在任何特定计算机上，进程的标识符都是唯一的。</span><span class="sxs-lookup"><span data-stu-id="970a2-425">On any particular computer, the identifier of a process is unique.</span></span> <span data-ttu-id="970a2-426"><xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> 最多返回一个进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-426"><xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> returns one process at most.</span></span> <span data-ttu-id="970a2-427">如果要获取运行特定应用程序的所有进程，请使用 <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>。</span><span class="sxs-lookup"><span data-stu-id="970a2-427">If you want to get all the processes running a particular application, use <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>.</span></span> <span data-ttu-id="970a2-428">如果运行指定应用程序的计算机上存在多个进程，<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> 将返回包含所有关联进程的数组。</span><span class="sxs-lookup"><span data-stu-id="970a2-428">If multiple processes exist on the computer running the specified application, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> returns an array containing all the associated processes.</span></span> <span data-ttu-id="970a2-429">你可以依次查询每个进程的标识符。</span><span class="sxs-lookup"><span data-stu-id="970a2-429">You can query each of these processes in turn for its identifier.</span></span> <span data-ttu-id="970a2-430">可以在 Windows 任务管理器的 "`Processes`" 面板中查看进程标识符。</span><span class="sxs-lookup"><span data-stu-id="970a2-430">The process identifier can be viewed in the `Processes` panel of the Windows Task Manager.</span></span> <span data-ttu-id="970a2-431">"`PID`" 列显示分配给进程的进程标识符。</span><span class="sxs-lookup"><span data-stu-id="970a2-431">The `PID` column displays the process identifier that is assigned to a process.</span></span>  
  
 <span data-ttu-id="970a2-432">`processId` 参数是一个 <xref:System.Int32> （32位有符号整数），尽管基础 Windows API 对类似的 Api 使用 `DWORD` （无符号32位整数）。</span><span class="sxs-lookup"><span data-stu-id="970a2-432">The `processId` parameter is an <xref:System.Int32> (a 32-bit signed integer), although the underlying Windows API uses a `DWORD` (an unsigned 32-bit integer) for similar APIs.</span></span> <span data-ttu-id="970a2-433">这是出于历史原因。</span><span class="sxs-lookup"><span data-stu-id="970a2-433">This is for historical reasons.</span></span>
  
## Examples  
 <span data-ttu-id="970a2-434">下面的示例检索当前进程的信息、在本地计算机上运行的进程、在本地计算机上运行的所有 Notepad 实例，以及本地计算机上的特定进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-434">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="970a2-435">然后，它将检索远程计算机上相同进程的信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-435">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="970a2-436"><paramref name="processId" /> 参数指定的进程未运行。</span><span class="sxs-lookup"><span data-stu-id="970a2-436">The process specified by the <paramref name="processId" /> parameter is not running.</span></span> <span data-ttu-id="970a2-437">此标识符可能已过期。</span><span class="sxs-lookup"><span data-stu-id="970a2-437">The identifier might be expired.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-438">此对象未启动该进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-438">The process was not started by this object.</span></span></exception>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById (processId, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId"><span data-ttu-id="970a2-439">进程资源的系统唯一标识符。</span><span class="sxs-lookup"><span data-stu-id="970a2-439">The system-unique identifier of a process resource.</span></span></param>
        <param name="machineName"><span data-ttu-id="970a2-440">网络上计算机的名称。</span><span class="sxs-lookup"><span data-stu-id="970a2-440">The name of a computer on the network.</span></span></param>
        <summary><span data-ttu-id="970a2-441">返回新的 <see cref="T:System.Diagnostics.Process" /> 组件(给定进程标识符和网络中计算机的名称)。</span><span class="sxs-lookup"><span data-stu-id="970a2-441">Returns a new <see cref="T:System.Diagnostics.Process" /> component, given a process identifier and the name of a computer on the network.</span></span></summary>
        <returns><span data-ttu-id="970a2-442">与 <paramref name="processId" /> 参数标识的远程进程资源关联的 <see cref="T:System.Diagnostics.Process" /> 组件。</span><span class="sxs-lookup"><span data-stu-id="970a2-442">A <see cref="T:System.Diagnostics.Process" /> component that is associated with a remote process resource identified by the <paramref name="processId" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-443">使用此方法创建新的 <xref:System.Diagnostics.Process> 组件，并将其与网络上远程计算机上的进程资源关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-443">Use this method to create a new <xref:System.Diagnostics.Process> component and associate it with a process resource on a remote computer on the network.</span></span> <span data-ttu-id="970a2-444">进程资源必须已存在于指定的计算机上，因为 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> 不会创建系统资源，而是将资源与应用程序生成的 <xref:System.Diagnostics.Process> 组件相关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-444">The process resource must already exist on the specified computer, because <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> does not create a system resource, but rather associates a resource with an application-generated <xref:System.Diagnostics.Process> component.</span></span> <span data-ttu-id="970a2-445">只能为当前在计算机上运行的进程检索进程 <xref:System.Diagnostics.Process.Id%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-445">A process <xref:System.Diagnostics.Process.Id%2A> can be retrieved only for a process that is currently running on the computer.</span></span> <span data-ttu-id="970a2-446">进程终止后，如果向其传递的是过期标识符，<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> 会引发异常。</span><span class="sxs-lookup"><span data-stu-id="970a2-446">After the process terminates, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> throws an exception if you pass it an expired identifier.</span></span>  
  
 <span data-ttu-id="970a2-447">在任何特定计算机上，进程的标识符都是唯一的。</span><span class="sxs-lookup"><span data-stu-id="970a2-447">On any particular computer, the identifier of a process is unique.</span></span> <span data-ttu-id="970a2-448"><xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> 最多返回一个进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-448"><xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> returns one process at most.</span></span> <span data-ttu-id="970a2-449">如果要获取运行特定应用程序的所有进程，请使用 <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>。</span><span class="sxs-lookup"><span data-stu-id="970a2-449">If you want to get all the processes running a particular application, use <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>.</span></span> <span data-ttu-id="970a2-450">如果运行指定应用程序的计算机上存在多个进程，<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> 将返回包含所有关联进程的数组。</span><span class="sxs-lookup"><span data-stu-id="970a2-450">If multiple processes exist on the computer running the specified application, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> returns an array containing all the associated processes.</span></span> <span data-ttu-id="970a2-451">你可以依次查询每个进程的标识符。</span><span class="sxs-lookup"><span data-stu-id="970a2-451">You can query each of these processes in turn for its identifier.</span></span> <span data-ttu-id="970a2-452">可以在 Windows 任务管理器的 "`Processes`" 面板中查看进程标识符。</span><span class="sxs-lookup"><span data-stu-id="970a2-452">The process identifier can be viewed in the `Processes` panel of the Windows Task Manager.</span></span> <span data-ttu-id="970a2-453">"`PID`" 列显示分配给进程的进程标识符。</span><span class="sxs-lookup"><span data-stu-id="970a2-453">The `PID` column displays the process identifier that is assigned to a process.</span></span>  
  
 <span data-ttu-id="970a2-454">如果未指定 `machineName`，则使用本地计算机。</span><span class="sxs-lookup"><span data-stu-id="970a2-454">If you do not specify a `machineName`, the local computer is used.</span></span> <span data-ttu-id="970a2-455">或者，您可以通过将 `machineName` 设置为值 "." 或空字符串（""）来指定本地计算机。</span><span class="sxs-lookup"><span data-stu-id="970a2-455">Alternatively, you can specify the local computer by setting `machineName` to the value "." or to an empty string ("").</span></span>  
  
 <span data-ttu-id="970a2-456">`processId` 参数是一个 <xref:System.Int32> （32位有符号整数），尽管基础 Windows API 对类似的 Api 使用 `DWORD` （无符号32位整数）。</span><span class="sxs-lookup"><span data-stu-id="970a2-456">The `processId` parameter is an <xref:System.Int32> (a 32-bit signed integer), although the underlying Windows API uses a `DWORD` (an unsigned 32-bit integer) for similar APIs.</span></span> <span data-ttu-id="970a2-457">这是出于历史原因。</span><span class="sxs-lookup"><span data-stu-id="970a2-457">This is for historical reasons.</span></span>   
  
## Examples  
 <span data-ttu-id="970a2-458">下面的示例检索当前进程的信息、在本地计算机上运行的进程、在本地计算机上运行的所有 Notepad 实例，以及本地计算机上的特定进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-458">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="970a2-459">然后，它将检索远程计算机上相同进程的信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-459">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="970a2-460"><paramref name="processId" /> 参数指定的进程未运行。</span><span class="sxs-lookup"><span data-stu-id="970a2-460">The process specified by the <paramref name="processId" /> parameter is not running.</span></span> <span data-ttu-id="970a2-461">此标识符可能已过期。</span><span class="sxs-lookup"><span data-stu-id="970a2-461">The identifier might be expired.</span></span>  
  
<span data-ttu-id="970a2-462">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-462">-or-</span></span> 
<span data-ttu-id="970a2-463"><paramref name="machineName" /> 参数的语法无效。</span><span class="sxs-lookup"><span data-stu-id="970a2-463">The <paramref name="machineName" /> parameter syntax is invalid.</span></span> <span data-ttu-id="970a2-464">名称的长度可能为零 (0)。</span><span class="sxs-lookup"><span data-stu-id="970a2-464">The name might have length zero (0).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="970a2-465"><paramref name="machineName" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-465">The <paramref name="machineName" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-466">此对象未启动该进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-466">The process was not started by this object.</span></span></exception>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="970a2-467">创建新的 <see cref="T:System.Diagnostics.Process" /> 组件的数组，并将它们与现有进程资源关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-467">Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with existing process resources.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberSignature Language="F#" Value="static member GetProcesses : unit -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="970a2-468">为本地计算机上的每个进程资源创建一个新的 <see cref="T:System.Diagnostics.Process" /> 组件。</span><span class="sxs-lookup"><span data-stu-id="970a2-468">Creates a new <see cref="T:System.Diagnostics.Process" /> component for each process resource on the local computer.</span></span></summary>
        <returns><span data-ttu-id="970a2-469">类型 <see cref="T:System.Diagnostics.Process" /> 的数组，表示本地计算机上运行的所有进程资源。</span><span class="sxs-lookup"><span data-stu-id="970a2-469">An array of type <see cref="T:System.Diagnostics.Process" /> that represents all the process resources running on the local computer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-470">使用此方法创建新的 <xref:System.Diagnostics.Process> 组件的数组，并将它们与本地计算机上的所有进程资源关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-470">Use this method to create an array of new <xref:System.Diagnostics.Process> components and associate them with all the process resources on the local computer.</span></span> <span data-ttu-id="970a2-471">进程资源必须已存在于本地计算机上，因为 <xref:System.Diagnostics.Process.GetProcesses%2A> 不会创建系统资源，而是将资源与应用程序生成的 <xref:System.Diagnostics.Process> 组件相关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-471">The process resources must already exist on the local computer, because <xref:System.Diagnostics.Process.GetProcesses%2A> does not create system resources but rather associates resources with application-generated <xref:System.Diagnostics.Process> components.</span></span> <span data-ttu-id="970a2-472">由于操作系统本身正在运行后台进程，此数组绝不会为空。</span><span class="sxs-lookup"><span data-stu-id="970a2-472">Because the operating system itself is running background processes, this array is never empty.</span></span>  
  
 <span data-ttu-id="970a2-473">如果您不想检索计算机上运行的所有进程，则可以使用 <xref:System.Diagnostics.Process.GetProcessById%2A> 或 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 方法来限制它们的数量。</span><span class="sxs-lookup"><span data-stu-id="970a2-473">If you do not want to retrieve all the processes running on the computer, you can restrict their number by using the <xref:System.Diagnostics.Process.GetProcessById%2A> or <xref:System.Diagnostics.Process.GetProcessesByName%2A> method.</span></span> <span data-ttu-id="970a2-474"><xref:System.Diagnostics.Process.GetProcessById%2A> 创建一个 <xref:System.Diagnostics.Process> 组件，该组件通过传递给方法的进程标识符与系统上标识的进程相关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-474"><xref:System.Diagnostics.Process.GetProcessById%2A> creates a <xref:System.Diagnostics.Process> component that is associated with the process identified on the system by the process identifier that you pass to the method.</span></span> <span data-ttu-id="970a2-475"><xref:System.Diagnostics.Process.GetProcessesByName%2A> 创建一个 <xref:System.Diagnostics.Process> 组件的数组，这些组件的关联进程资源共享你传递给方法的可执行文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-475"><xref:System.Diagnostics.Process.GetProcessesByName%2A> creates an array of <xref:System.Diagnostics.Process> components whose associated process resources share the executable file you pass to the method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-476">在服务主机进程（svchost.exe）的同一个实例中，可以加载多个 Windows 服务。</span><span class="sxs-lookup"><span data-stu-id="970a2-476">Multiple Windows services can be loaded within the same instance of the Service Host process (svchost.exe).</span></span> <span data-ttu-id="970a2-477">GetProcesses 不标识这些单独的服务;为此，请参阅 <xref:System.ServiceProcess.ServiceController.GetServices%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-477">GetProcesses does not identify those individual services; for that, see <xref:System.ServiceProcess.ServiceController.GetServices%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-478">下面的示例检索当前进程的信息、在本地计算机上运行的进程、在本地计算机上运行的所有 Notepad 实例，以及本地计算机上的特定进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-478">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="970a2-479">然后，它将检索远程计算机上相同进程的信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-479">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcesses : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName"><span data-ttu-id="970a2-480">从其中读取进程列表的计算机。</span><span class="sxs-lookup"><span data-stu-id="970a2-480">The computer from which to read the list of processes.</span></span></param>
        <summary><span data-ttu-id="970a2-481">为指定计算机上的每个进程资源创建一个新的 <see cref="T:System.Diagnostics.Process" /> 组件。</span><span class="sxs-lookup"><span data-stu-id="970a2-481">Creates a new <see cref="T:System.Diagnostics.Process" /> component for each process resource on the specified computer.</span></span></summary>
        <returns><span data-ttu-id="970a2-482">类型 <see cref="T:System.Diagnostics.Process" /> 的数组，表示指定计算机上运行的所有进程资源。</span><span class="sxs-lookup"><span data-stu-id="970a2-482">An array of type <see cref="T:System.Diagnostics.Process" /> that represents all the process resources running on the specified computer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-483">使用此方法创建新的 <xref:System.Diagnostics.Process> 组件的数组，并将它们与指定（通常为远程）计算机上的所有进程资源关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-483">Use this method to create an array of new <xref:System.Diagnostics.Process> components and associate them with all the process resources on the specified (usually remote) computer.</span></span> <span data-ttu-id="970a2-484">进程资源必须已存在于本地计算机上，因为 <xref:System.Diagnostics.Process.GetProcesses%2A> 不会创建系统资源，而是将资源与应用程序生成的 <xref:System.Diagnostics.Process> 组件相关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-484">The process resources must already exist on the local computer, because <xref:System.Diagnostics.Process.GetProcesses%2A> does not create system resources but rather associates resources with application-generated <xref:System.Diagnostics.Process> components.</span></span> <span data-ttu-id="970a2-485">由于操作系统本身正在运行后台进程，此数组绝不会为空。</span><span class="sxs-lookup"><span data-stu-id="970a2-485">Because the operating system itself is running background processes, this array is never empty.</span></span>  
  
 <span data-ttu-id="970a2-486">如果您不想检索计算机上运行的所有进程，则可以使用 <xref:System.Diagnostics.Process.GetProcessById%2A> 或 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 方法来限制它们的数量。</span><span class="sxs-lookup"><span data-stu-id="970a2-486">If you do not want to retrieve all the processes running on the computer, you can restrict their number by using the <xref:System.Diagnostics.Process.GetProcessById%2A> or <xref:System.Diagnostics.Process.GetProcessesByName%2A> method.</span></span> <span data-ttu-id="970a2-487"><xref:System.Diagnostics.Process.GetProcessById%2A> 创建一个 <xref:System.Diagnostics.Process> 组件，该组件通过传递给方法的进程标识符与系统上标识的进程相关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-487"><xref:System.Diagnostics.Process.GetProcessById%2A> creates a <xref:System.Diagnostics.Process> component that is associated with the process identified on the system by the process identifier that you pass to the method.</span></span> <span data-ttu-id="970a2-488"><xref:System.Diagnostics.Process.GetProcessesByName%2A> 创建一个 <xref:System.Diagnostics.Process> 组件的数组，这些组件的关联进程资源共享你传递给方法的可执行文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-488"><xref:System.Diagnostics.Process.GetProcessesByName%2A> creates an array of <xref:System.Diagnostics.Process> components whose associated process resources share the executable file you pass to the method.</span></span>  
  
 <span data-ttu-id="970a2-489"><xref:System.Diagnostics.Process.GetProcesses%2A> 方法的此重载通常用于检索在网络上的远程计算机上运行的进程资源的列表，但你可以通过传递 "." 来指定本地计算机。</span><span class="sxs-lookup"><span data-stu-id="970a2-489">This overload of the <xref:System.Diagnostics.Process.GetProcesses%2A> method is generally used to retrieve the list of process resources running on a remote computer on the network, but you can specify the local computer by passing ".".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-490">在服务主机进程（svchost.exe）的同一个实例中，可以加载多个 Windows 服务。</span><span class="sxs-lookup"><span data-stu-id="970a2-490">Multiple Windows services can be loaded within the same instance of the Service Host process (svchost.exe).</span></span> <span data-ttu-id="970a2-491">GetProcesses 不标识这些单独的服务;为此，请参阅 <xref:System.ServiceProcess.ServiceController.GetServices%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-491">GetProcesses does not identify those individual services; for that, see <xref:System.ServiceProcess.ServiceController.GetServices%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-492">下面的示例检索当前进程的信息、在本地计算机上运行的进程、在本地计算机上运行的所有 Notepad 实例，以及本地计算机上的特定进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-492">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="970a2-493">然后，它将检索远程计算机上相同进程的信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-493">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="970a2-494"><paramref name="machineName" /> 参数的语法无效。</span><span class="sxs-lookup"><span data-stu-id="970a2-494">The <paramref name="machineName" /> parameter syntax is invalid.</span></span> <span data-ttu-id="970a2-495">其长度可能为零 (0)。</span><span class="sxs-lookup"><span data-stu-id="970a2-495">It might have length zero (0).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="970a2-496"><paramref name="machineName" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-496">The <paramref name="machineName" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="970a2-497">操作系统平台不支持在远程计算机上进行此操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-497">The operating system platform does not support this operation on remote computers.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-498">访问用于获取进程信息的性能计数器 API 时遇到问题。</span><span class="sxs-lookup"><span data-stu-id="970a2-498">There are problems accessing the performance counter APIs used to get process information.</span></span> <span data-ttu-id="970a2-499">此异常特定于 Windows NT、Windows 2000 和 Windows XP。</span><span class="sxs-lookup"><span data-stu-id="970a2-499">This exception is specific to Windows NT, Windows 2000, and Windows XP.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="970a2-500">访问基础系统 API 时出现问题。</span><span class="sxs-lookup"><span data-stu-id="970a2-500">A problem occurred accessing an underlying system API.</span></span></exception>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="970a2-501">创建新的 <see cref="T:System.Diagnostics.Process" /> 组件的数组，并将它们与共享指定的进程名称的所有现有进程资源关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-501">Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with the existing process resources that all share the specified process name.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName processName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName"><span data-ttu-id="970a2-502">该进程的友好名称。</span><span class="sxs-lookup"><span data-stu-id="970a2-502">The friendly name of the process.</span></span></param>
        <summary><span data-ttu-id="970a2-503">创建新的 <see cref="T:System.Diagnostics.Process" /> 组件的数组，并将它们与本地计算机上共享指定的进程名称的所有进程资源关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-503">Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with all the process resources on the local computer that share the specified process name.</span></span></summary>
        <returns><span data-ttu-id="970a2-504">类型 <see cref="T:System.Diagnostics.Process" /> 的数组，表示运行指定应用程序或文件的进程资源。</span><span class="sxs-lookup"><span data-stu-id="970a2-504">An array of type <see cref="T:System.Diagnostics.Process" /> that represents the process resources running the specified application or file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-505">使用此方法创建新的 <xref:System.Diagnostics.Process> 组件的数组，并将它们与本地计算机上运行相同可执行文件的所有进程资源关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-505">Use this method to create an array of new <xref:System.Diagnostics.Process> components and associate them with all the process resources that are running the same executable file on the local computer.</span></span> <span data-ttu-id="970a2-506">进程资源必须已存在于计算机上，因为 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 不会创建系统资源，而是将它们与应用程序生成的 <xref:System.Diagnostics.Process> 组件相关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-506">The process resources must already exist on the computer, because <xref:System.Diagnostics.Process.GetProcessesByName%2A> does not create system resources but rather associates them with application-generated <xref:System.Diagnostics.Process> components.</span></span> <span data-ttu-id="970a2-507">可以为当前未在本地计算机上运行的可执行文件指定 `processName`，因此该方法返回的数组可能为空。</span><span class="sxs-lookup"><span data-stu-id="970a2-507">A `processName` can be specified for an executable file that is not currently running on the local computer, so the array the method returns can be empty.</span></span>  
  
 <span data-ttu-id="970a2-508">进程名称是进程（例如 Outlook）的友好名称，该名称不包括 .exe 扩展名或路径。</span><span class="sxs-lookup"><span data-stu-id="970a2-508">The process name is a friendly name for the process, such as Outlook, that does not include the .exe extension or the path.</span></span> <span data-ttu-id="970a2-509"><xref:System.Diagnostics.Process.GetProcessesByName%2A> 有助于获取和操作与相同可执行文件关联的所有进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-509"><xref:System.Diagnostics.Process.GetProcessesByName%2A> is helpful for getting and manipulating all the processes that are associated with the same executable file.</span></span> <span data-ttu-id="970a2-510">例如，可以将可执行文件名作为 `processName` 参数传递，以便关闭该可执行文件的所有正在运行的实例。</span><span class="sxs-lookup"><span data-stu-id="970a2-510">For example, you can pass an executable file name as the `processName` parameter, in order to shut down all the running instances of that executable file.</span></span>  
  
 <span data-ttu-id="970a2-511">尽管进程 <xref:System.Diagnostics.Process.Id%2A> 对于系统上的单个进程资源是唯一的，但本地计算机上的多个进程可以运行 `processName` 参数指定的应用程序。</span><span class="sxs-lookup"><span data-stu-id="970a2-511">Although a process <xref:System.Diagnostics.Process.Id%2A> is unique to a single process resource on the system, multiple processes on the local computer can be running the application specified by the `processName` parameter.</span></span> <span data-ttu-id="970a2-512">因此，<xref:System.Diagnostics.Process.GetProcessById%2A> 最多返回一个进程，但 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 返回包含所有关联进程的数组。</span><span class="sxs-lookup"><span data-stu-id="970a2-512">Therefore, <xref:System.Diagnostics.Process.GetProcessById%2A> returns one process at most, but <xref:System.Diagnostics.Process.GetProcessesByName%2A> returns an array containing all the associated processes.</span></span> <span data-ttu-id="970a2-513">如果需要使用标准 API 调用来操作进程，可以依次查询每个进程的标识符。</span><span class="sxs-lookup"><span data-stu-id="970a2-513">If you need to manipulate the process using standard API calls, you can query each of these processes in turn for its identifier.</span></span> <span data-ttu-id="970a2-514">你不能只通过进程名称访问进程资源，但一旦检索到与进程资源关联的 <xref:System.Diagnostics.Process> 组件数组，就可以启动、终止，并以其他方式处理系统资源。</span><span class="sxs-lookup"><span data-stu-id="970a2-514">You cannot access process resources through the process name alone but, once you have retrieved an array of <xref:System.Diagnostics.Process> components that have been associated with the process resources, you can start, terminate, and otherwise manipulate the system resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-515">下面的示例检索当前进程的信息、在本地计算机上运行的进程、在本地计算机上运行的所有 Notepad 实例，以及本地计算机上的特定进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-515">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="970a2-516">然后，它将检索远程计算机上相同进程的信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-516">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-517">访问用于获取进程信息的性能计数器 API 时遇到问题。</span><span class="sxs-lookup"><span data-stu-id="970a2-517">There are problems accessing the performance counter APIs used to get process information.</span></span> <span data-ttu-id="970a2-518">此异常特定于 Windows NT、Windows 2000 和 Windows XP。</span><span class="sxs-lookup"><span data-stu-id="970a2-518">This exception is specific to Windows NT, Windows 2000, and Windows XP.</span></span></exception>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string * string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName (processName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName"><span data-ttu-id="970a2-519">该进程的友好名称。</span><span class="sxs-lookup"><span data-stu-id="970a2-519">The friendly name of the process.</span></span></param>
        <param name="machineName"><span data-ttu-id="970a2-520">网络上计算机的名称。</span><span class="sxs-lookup"><span data-stu-id="970a2-520">The name of a computer on the network.</span></span></param>
        <summary><span data-ttu-id="970a2-521">创建新的 <see cref="T:System.Diagnostics.Process" /> 组件的数组，并将它们与远程计算机上共享指定进程名称的所有进程资源关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-521">Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with all the process resources on a remote computer that share the specified process name.</span></span></summary>
        <returns><span data-ttu-id="970a2-522">类型 <see cref="T:System.Diagnostics.Process" /> 的数组，表示运行指定应用程序或文件的进程资源。</span><span class="sxs-lookup"><span data-stu-id="970a2-522">An array of type <see cref="T:System.Diagnostics.Process" /> that represents the process resources running the specified application or file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-523">使用此方法创建新的 <xref:System.Diagnostics.Process> 组件的数组，并将其与在指定计算机上运行相同可执行文件的所有进程资源关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-523">Use this method to create an array of new <xref:System.Diagnostics.Process> components and associate them with all the process resources that are running the same executable file on the specified computer.</span></span> <span data-ttu-id="970a2-524">进程资源必须已存在于计算机上，因为 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 不会创建系统资源，而是将它们与应用程序生成的 <xref:System.Diagnostics.Process> 组件相关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-524">The process resources must already exist on the computer, because <xref:System.Diagnostics.Process.GetProcessesByName%2A> does not create system resources but rather associates them with application-generated <xref:System.Diagnostics.Process> components.</span></span> <span data-ttu-id="970a2-525">可以为当前未在本地计算机上运行的可执行文件指定 `processName`，因此该方法返回的数组可能为空。</span><span class="sxs-lookup"><span data-stu-id="970a2-525">A `processName` can be specified for an executable file that is not currently running on the local computer, so the array the method returns can be empty.</span></span>  
  
 <span data-ttu-id="970a2-526">进程名称是进程（例如 Outlook）的友好名称，该名称不包括 .exe 扩展名或路径。</span><span class="sxs-lookup"><span data-stu-id="970a2-526">The process name is a friendly name for the process, such as Outlook, that does not include the .exe extension or the path.</span></span> <span data-ttu-id="970a2-527"><xref:System.Diagnostics.Process.GetProcessesByName%2A> 有助于获取和操作与相同可执行文件关联的所有进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-527"><xref:System.Diagnostics.Process.GetProcessesByName%2A> is helpful for getting and manipulating all the processes that are associated with the same executable file.</span></span> <span data-ttu-id="970a2-528">例如，可以将可执行文件名作为 `processName` 参数传递，以便关闭该可执行文件的所有正在运行的实例。</span><span class="sxs-lookup"><span data-stu-id="970a2-528">For example, you can pass an executable file name as the `processName` parameter, in order to shut down all the running instances of that executable file.</span></span>  
  
 <span data-ttu-id="970a2-529">尽管进程 <xref:System.Diagnostics.Process.Id%2A> 对于系统上的单个进程资源是唯一的，但本地计算机上的多个进程可以运行 `processName` 参数指定的应用程序。</span><span class="sxs-lookup"><span data-stu-id="970a2-529">Although a process <xref:System.Diagnostics.Process.Id%2A> is unique to a single process resource on the system, multiple processes on the local computer can be running the application specified by the `processName` parameter.</span></span> <span data-ttu-id="970a2-530">因此，<xref:System.Diagnostics.Process.GetProcessById%2A> 最多返回一个进程，但 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 返回包含所有关联进程的数组。</span><span class="sxs-lookup"><span data-stu-id="970a2-530">Therefore, <xref:System.Diagnostics.Process.GetProcessById%2A> returns one process at most, but <xref:System.Diagnostics.Process.GetProcessesByName%2A> returns an array containing all the associated processes.</span></span> <span data-ttu-id="970a2-531">如果需要使用标准 API 调用来操作进程，可以依次查询每个进程的标识符。</span><span class="sxs-lookup"><span data-stu-id="970a2-531">If you need to manipulate the process using standard API calls, you can query each of these processes in turn for its identifier.</span></span> <span data-ttu-id="970a2-532">你不能只通过进程名称访问进程资源，但一旦检索到与进程资源关联的 <xref:System.Diagnostics.Process> 组件数组，就可以启动、终止，并以其他方式处理系统资源。</span><span class="sxs-lookup"><span data-stu-id="970a2-532">You cannot access process resources through the process name alone but, once you have retrieved an array of <xref:System.Diagnostics.Process> components that have been associated with the process resources, you can start, terminate, and otherwise manipulate the system resources.</span></span>  
  
 <span data-ttu-id="970a2-533">您可以使用此重载获取本地计算机以及远程计算机上的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-533">You can use this overload to get processes on the local computer as well as on a remote computer.</span></span> <span data-ttu-id="970a2-534">使用 "." 指定本地计算机。</span><span class="sxs-lookup"><span data-stu-id="970a2-534">Use "." to specify the local computer.</span></span> <span data-ttu-id="970a2-535">默认情况下，存在使用本地计算机的另一个重载。</span><span class="sxs-lookup"><span data-stu-id="970a2-535">Another overload exists that uses the local computer by default.</span></span>  
  
 <span data-ttu-id="970a2-536">您可以访问远程计算机上的进程，以便查看有关进程的信息（例如统计信息）。</span><span class="sxs-lookup"><span data-stu-id="970a2-536">You can access processes on remote computers only to view information, such as statistics, about the processes.</span></span> <span data-ttu-id="970a2-537">不能关闭、终止（使用 <xref:System.Diagnostics.Process.Kill%2A>）或启动远程计算机上的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-537">You cannot close, terminate (using <xref:System.Diagnostics.Process.Kill%2A>), or start processes on remote computers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-538">下面的示例检索当前进程的信息、在本地计算机上运行的进程、在本地计算机上运行的所有 Notepad 实例，以及本地计算机上的特定进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-538">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="970a2-539">然后，它将检索远程计算机上相同进程的信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-539">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="970a2-540"><paramref name="machineName" /> 参数的语法无效。</span><span class="sxs-lookup"><span data-stu-id="970a2-540">The <paramref name="machineName" /> parameter syntax is invalid.</span></span> <span data-ttu-id="970a2-541">其长度可能为零 (0)。</span><span class="sxs-lookup"><span data-stu-id="970a2-541">It might have length zero (0).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="970a2-542"><paramref name="machineName" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-542">The <paramref name="machineName" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="970a2-543">操作系统平台不支持在远程计算机上进行此操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-543">The operating system platform does not support this operation on remote computers.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-544">尝试连接到 <paramref name="machineName" /> 失败。</span><span class="sxs-lookup"><span data-stu-id="970a2-544">The attempt to connect to <paramref name="machineName" /> has failed.</span></span>

<span data-ttu-id="970a2-545">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-545">-or-</span></span> 
<span data-ttu-id="970a2-546">访问用于获取进程信息的性能计数器 API 时遇到问题。</span><span class="sxs-lookup"><span data-stu-id="970a2-546">There are problems accessing the performance counter APIs used to get process information.</span></span> <span data-ttu-id="970a2-547">此异常特定于 Windows NT、Windows 2000 和 Windows XP。</span><span class="sxs-lookup"><span data-stu-id="970a2-547">This exception is specific to Windows NT, Windows 2000, and Windows XP.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="970a2-548">访问基础系统 API 时出现问题。</span><span class="sxs-lookup"><span data-stu-id="970a2-548">A problem occurred accessing an underlying system API.</span></span></exception>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Diagnostics.Process.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-549">获取关联进程的本机句柄。</span><span class="sxs-lookup"><span data-stu-id="970a2-549">Gets the native handle of the associated process.</span></span></summary>
        <value><span data-ttu-id="970a2-550">进程启动时操作系统向关联进程分配的句柄。</span><span class="sxs-lookup"><span data-stu-id="970a2-550">The handle that the operating system assigned to the associated process when the process was started.</span></span> <span data-ttu-id="970a2-551">系统使用此句柄来跟踪进程特性。</span><span class="sxs-lookup"><span data-stu-id="970a2-551">The system uses this handle to keep track of process attributes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-552">应用程序可以获取进程的句柄，该句柄可用作多个进程信息和控制函数的参数。</span><span class="sxs-lookup"><span data-stu-id="970a2-552">An application can obtain a handle to a process that can be used as a parameter to many process-information and control functions.</span></span> <span data-ttu-id="970a2-553">您可以使用此句柄来初始化 <xref:System.Threading.WaitHandle> 或使用平台调用来调用本机方法。</span><span class="sxs-lookup"><span data-stu-id="970a2-553">You can use this handle to initialize a <xref:System.Threading.WaitHandle> or to call native methods with platform invoke.</span></span>  
  
 <span data-ttu-id="970a2-554">此进程句柄专用于应用程序，换言之，无法共享进程句柄。</span><span class="sxs-lookup"><span data-stu-id="970a2-554">This process handle is private to an application--in other words, process handles cannot be shared.</span></span> <span data-ttu-id="970a2-555">进程还具有一个与 <xref:System.Diagnostics.Process.Handle%2A>不同的进程 <xref:System.Diagnostics.Process.Id%2A>，因此它在整个系统中有效。</span><span class="sxs-lookup"><span data-stu-id="970a2-555">A process also has a process <xref:System.Diagnostics.Process.Id%2A> which, unlike the <xref:System.Diagnostics.Process.Handle%2A>, is unique and, therefore, valid throughout the system.</span></span>  
  
 <span data-ttu-id="970a2-556">只有通过对的调用启动的进程 <xref:System.Diagnostics.Process.Start%2A> 设置相应 <xref:System.Diagnostics.Process> 实例的 <xref:System.Diagnostics.Process.Handle%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-556">Only processes started through a call to <xref:System.Diagnostics.Process.Start%2A> set the <xref:System.Diagnostics.Process.Handle%2A> property of the corresponding <xref:System.Diagnostics.Process> instances.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-557">该进程尚未启动或已退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-557">The process has not been started or has exited.</span></span> <span data-ttu-id="970a2-558">不能读取 <see cref="P:System.Diagnostics.Process.Handle" /> 属性，因为没有与此 <see cref="T:System.Diagnostics.Process" /> 实例关联的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-558">The <see cref="P:System.Diagnostics.Process.Handle" /> property cannot be read because there is no process associated with this <see cref="T:System.Diagnostics.Process" /> instance.</span></span>  
  
<span data-ttu-id="970a2-559">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-559">-or-</span></span> 
<span data-ttu-id="970a2-560"><see cref="T:System.Diagnostics.Process" /> 实例已附加到正在运行的进程，但你没有获取具有完全访问权限的句柄所需的权限。</span><span class="sxs-lookup"><span data-stu-id="970a2-560">The <see cref="T:System.Diagnostics.Process" /> instance has been attached to a running process but you do not have the necessary permissions to get a handle with full access rights.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="970a2-561">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.Handle" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-561">You are trying to access the <see cref="P:System.Diagnostics.Process.Handle" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="970a2-562">此属性仅可用于本地计算机上运行的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-562">This property is available only for processes that are running on the local computer.</span></span></exception>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HandleCount : int" Usage="System.Diagnostics.Process.HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandleCount")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-563">获取由进程打开的句柄数。</span><span class="sxs-lookup"><span data-stu-id="970a2-563">Gets the number of handles opened by the process.</span></span></summary>
        <value><span data-ttu-id="970a2-564">进程打开的操作系统句柄数。</span><span class="sxs-lookup"><span data-stu-id="970a2-564">The number of operating system handles the process has opened.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-565">句柄为进程提供了引用对象的方法。</span><span class="sxs-lookup"><span data-stu-id="970a2-565">Handles provide a way for a process to refer to objects.</span></span> <span data-ttu-id="970a2-566">进程可以获取文件、资源、消息队列以及许多其他操作系统对象的句柄。</span><span class="sxs-lookup"><span data-stu-id="970a2-566">A process can obtain handles to files, resources, message queues, and many other operating system objects.</span></span> <span data-ttu-id="970a2-567">仅当句柄计数为零时，操作系统才回收与进程关联的内存。</span><span class="sxs-lookup"><span data-stu-id="970a2-567">The operating system reclaims the memory associated with the process only when the handle count is zero.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasExited : bool" Usage="System.Diagnostics.Process.HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTerminated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-568">获取指示关联进程是否已终止的值。</span><span class="sxs-lookup"><span data-stu-id="970a2-568">Gets a value indicating whether the associated process has been terminated.</span></span></summary>
        <value><span data-ttu-id="970a2-569">如果 <see cref="T:System.Diagnostics.Process" /> 组件引用的操作系统进程已终止，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-569"><see langword="true" /> if the operating system process referenced by the <see cref="T:System.Diagnostics.Process" /> component has terminated; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-570"><xref:System.Diagnostics.Process.HasExited%2A> 的 `true` 值指示关联进程已终止（正常或异常）。</span><span class="sxs-lookup"><span data-stu-id="970a2-570">A value of `true` for <xref:System.Diagnostics.Process.HasExited%2A> indicates that the associated process has terminated, either normally or abnormally.</span></span> <span data-ttu-id="970a2-571">可以通过调用 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 或 <xref:System.Diagnostics.Process.Kill%2A>来请求或强制关联进程退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-571">You can request or force the associated process to exit by calling <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="970a2-572">如果句柄已打开到进程，则在进程退出后，操作系统将释放进程内存，但会保留有关进程的管理信息，例如句柄、退出代码和退出时间。</span><span class="sxs-lookup"><span data-stu-id="970a2-572">If a handle is open to the process, the operating system releases the process memory when the process has exited, but retains administrative information about the process, such as the handle, exit code, and exit time.</span></span> <span data-ttu-id="970a2-573">若要获取此信息，可以使用 "<xref:System.Diagnostics.Process.ExitCode%2A>" 和 "<xref:System.Diagnostics.Process.ExitTime%2A>" 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-573">To get this information, you can use the <xref:System.Diagnostics.Process.ExitCode%2A> and <xref:System.Diagnostics.Process.ExitTime%2A> properties.</span></span> <span data-ttu-id="970a2-574">对于此组件启动的进程，会自动填充这些属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-574">These properties are populated automatically for processes that were started by this component.</span></span> <span data-ttu-id="970a2-575">当所有与系统进程关联的 <xref:System.Diagnostics.Process> 组件都被销毁并且不将更多的句柄保留到已退出的进程时，管理信息将被释放。</span><span class="sxs-lookup"><span data-stu-id="970a2-575">The administrative information is released when all the <xref:System.Diagnostics.Process> components that are associated with the system process are destroyed and hold no more handles to the exited process.</span></span>  
  
 <span data-ttu-id="970a2-576">进程可以独立于你的代码而终止。</span><span class="sxs-lookup"><span data-stu-id="970a2-576">A process can terminate independently of your code.</span></span> <span data-ttu-id="970a2-577">如果使用此组件启动了进程，则系统会自动更新 <xref:System.Diagnostics.Process.HasExited%2A> 的值，即使关联的进程独立退出也是如此。</span><span class="sxs-lookup"><span data-stu-id="970a2-577">If you started the process using this component, the system updates the value of <xref:System.Diagnostics.Process.HasExited%2A> automatically, even if the associated process exits independently.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-578">将标准输出重定向到异步事件处理程序后，当此属性返回 `true`时，输出处理可能不会完成。</span><span class="sxs-lookup"><span data-stu-id="970a2-578">When standard output has been redirected to asynchronous event handlers, it is possible that output processing will not have completed when this property returns `true`.</span></span> <span data-ttu-id="970a2-579">若要确保异步事件处理已完成，请在检查 <xref:System.Diagnostics.Process.HasExited%2A>之前调用不带任何参数的 <xref:System.Diagnostics.Process.WaitForExit> 重载。</span><span class="sxs-lookup"><span data-stu-id="970a2-579">To ensure that asynchronous event handling has been completed, call the <xref:System.Diagnostics.Process.WaitForExit> overload that takes no parameter before checking <xref:System.Diagnostics.Process.HasExited%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-580">下面的示例启动记事本的实例。</span><span class="sxs-lookup"><span data-stu-id="970a2-580">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="970a2-581">然后，它以2秒的间隔检索关联进程的物理内存使用率，最大值为10秒。</span><span class="sxs-lookup"><span data-stu-id="970a2-581">It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds.</span></span> <span data-ttu-id="970a2-582">该示例检测进程是否在10秒后退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-582">The example detects whether the process exits before 10 seconds have elapsed.</span></span> <span data-ttu-id="970a2-583">如果10秒后仍在运行，则此示例将关闭进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-583">The example closes the process if it is still running after 10 seconds.</span></span>  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-584">没有与此对象关联的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-584">There is no process associated with the object.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="970a2-585">无法检索该进程的退出代码。</span><span class="sxs-lookup"><span data-stu-id="970a2-585">The exit code for the process could not be retrieved.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="970a2-586">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.HasExited" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-586">You are trying to access the <see cref="P:System.Diagnostics.Process.HasExited" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="970a2-587">此属性仅可用于本地计算机上运行的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-587">This property is available only for processes that are running on the local computer.</span></span></exception>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.Process.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-588">获取关联进程的唯一标识符。</span><span class="sxs-lookup"><span data-stu-id="970a2-588">Gets the unique identifier for the associated process.</span></span></summary>
        <value><span data-ttu-id="970a2-589">此 <see cref="T:System.Diagnostics.Process" /> 实例引用的、由系统生成的进程的唯一标识符。</span><span class="sxs-lookup"><span data-stu-id="970a2-589">The system-generated unique identifier of the process that is referenced by this <see cref="T:System.Diagnostics.Process" /> instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-590">如果关联的进程未运行，则进程 <xref:System.Diagnostics.Process.Id%2A> 无效。</span><span class="sxs-lookup"><span data-stu-id="970a2-590">The process <xref:System.Diagnostics.Process.Id%2A> is not valid if the associated process is not running.</span></span> <span data-ttu-id="970a2-591">因此，在尝试检索 <xref:System.Diagnostics.Process.Id%2A> 属性之前，应确保该进程正在运行。</span><span class="sxs-lookup"><span data-stu-id="970a2-591">Therefore, you should ensure that the process is running before attempting to retrieve the <xref:System.Diagnostics.Process.Id%2A> property.</span></span> <span data-ttu-id="970a2-592">在进程终止之前，进程标识符唯一标识整个系统中的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-592">Until the process terminates, the process identifier uniquely identifies the process throughout the system.</span></span>  
  
 <span data-ttu-id="970a2-593">可以通过将进程标识符传递到 <xref:System.Diagnostics.Process.GetProcessById%2A> 方法，将本地或远程计算机上运行的进程连接到新的 <xref:System.Diagnostics.Process> 实例。</span><span class="sxs-lookup"><span data-stu-id="970a2-593">You can connect a process that is running on a local or remote computer to a new <xref:System.Diagnostics.Process> instance by passing the process identifier to the <xref:System.Diagnostics.Process.GetProcessById%2A> method.</span></span> <span data-ttu-id="970a2-594"><xref:System.Diagnostics.Process.GetProcessById%2A> 是一种 `static` 方法，该方法创建新的组件，并自动为新的 <xref:System.Diagnostics.Process> 实例设置 <xref:System.Diagnostics.Process.Id%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-594"><xref:System.Diagnostics.Process.GetProcessById%2A> is a `static` method that creates a new component and sets the <xref:System.Diagnostics.Process.Id%2A> property for the new <xref:System.Diagnostics.Process> instance automatically.</span></span>  
  
 <span data-ttu-id="970a2-595">系统可以重新使用进程标识符。</span><span class="sxs-lookup"><span data-stu-id="970a2-595">Process identifiers can be reused by the system.</span></span> <span data-ttu-id="970a2-596">仅当关联的进程正在运行时，<xref:System.Diagnostics.Process.Id%2A> 属性值才是唯一的。</span><span class="sxs-lookup"><span data-stu-id="970a2-596">The <xref:System.Diagnostics.Process.Id%2A> property value is unique only while the associated process is running.</span></span> <span data-ttu-id="970a2-597">进程终止后，系统可以为不相关的进程重用 <xref:System.Diagnostics.Process.Id%2A> 属性值。</span><span class="sxs-lookup"><span data-stu-id="970a2-597">After the process has terminated, the system can reuse the <xref:System.Diagnostics.Process.Id%2A> property value for an unrelated process.</span></span>  
  
 <span data-ttu-id="970a2-598">由于标识符在系统中是唯一的，因此你可以将其作为传递 <xref:System.Diagnostics.Process> 实例的替代方法传递给其他线程。</span><span class="sxs-lookup"><span data-stu-id="970a2-598">Because the identifier is unique on the system, you can pass it to other threads as an alternative to passing a <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="970a2-599">此操作可以保存系统资源，并保证正确地标识该进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-599">This action can save system resources yet guarantee that the process is correctly identified.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-600">下面的示例演示如何获取应用程序的所有正在运行的实例的 <xref:System.Diagnostics.Process.Id%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-600">The following example demonstrates how to obtain the <xref:System.Diagnostics.Process.Id%2A> for all running instances of an application.</span></span> <span data-ttu-id="970a2-601">该代码将创建一个新的记事本实例，列出记事本的所有实例，然后允许用户输入 <xref:System.Diagnostics.Process.Id%2A> 号以删除特定的实例。</span><span class="sxs-lookup"><span data-stu-id="970a2-601">The code creates a new instance of Notepad, lists all the instances of Notepad, and then allows the user to enter the <xref:System.Diagnostics.Process.Id%2A> number to remove a specific instance.</span></span>  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-602">尚未设置此进程的 <see cref="P:System.Diagnostics.Process.Id" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-602">The process's <see cref="P:System.Diagnostics.Process.Id" /> property has not been set.</span></span>  
  
<span data-ttu-id="970a2-603">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-603">-or-</span></span> 
<span data-ttu-id="970a2-604">没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-604">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span></exception>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Kill">
      <Docs>
        <summary><span data-ttu-id="970a2-605">强制终止基础进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-605">Forces termination of the underlying process.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="970a2-606">`Kill` 方法强制终止进程，而 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 只请求终止。</span><span class="sxs-lookup"><span data-stu-id="970a2-606">The `Kill` method forces a termination of the process, while <xref:System.Diagnostics.Process.CloseMainWindow%2A> only requests a termination.</span></span> <span data-ttu-id="970a2-607">当执行具有图形界面的进程时，其消息循环处于等待状态。</span><span class="sxs-lookup"><span data-stu-id="970a2-607">When a process with a graphical interface is executing, its message loop is in a wait state.</span></span> <span data-ttu-id="970a2-608">每次操作系统将 Windows 消息发送到该进程时，消息循环都会执行。</span><span class="sxs-lookup"><span data-stu-id="970a2-608">The message loop executes every time a Windows message is sent to the process by the operating system.</span></span> <span data-ttu-id="970a2-609">调用 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 将发送一个请求来关闭主窗口，该窗口在格式正确的应用程序中将关闭子窗口，并为应用程序撤消所有正在运行的消息循环。</span><span class="sxs-lookup"><span data-stu-id="970a2-609">Calling <xref:System.Diagnostics.Process.CloseMainWindow%2A> sends a request to close the main window, which, in a well-formed application, closes child windows and revokes all running message loops for the application.</span></span> <span data-ttu-id="970a2-610">通过调用 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 退出进程的请求不会强制应用程序退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-610">The request to exit the process by calling <xref:System.Diagnostics.Process.CloseMainWindow%2A> does not force the application to quit.</span></span>
<span data-ttu-id="970a2-611">应用程序可以在退出前要求用户进行验证，也可以拒绝退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-611">The application can ask for user verification before quitting, or it can refuse to quit.</span></span> <span data-ttu-id="970a2-612">若要强制退出应用程序，请使用 `Kill` 方法。</span><span class="sxs-lookup"><span data-stu-id="970a2-612">To force the application to quit, use the `Kill` method.</span></span>

<span data-ttu-id="970a2-613"><xref:System.Diagnostics.Process.CloseMainWindow%2A> 的行为与用户使用系统菜单关闭应用程序的主窗口的行为相同。</span><span class="sxs-lookup"><span data-stu-id="970a2-613">The behavior of <xref:System.Diagnostics.Process.CloseMainWindow%2A> is identical to that of a user closing an application's main window using the system menu.</span></span>
<span data-ttu-id="970a2-614">因此，通过关闭主窗口来退出进程的请求不会强制立即退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-614">Therefore, the request to exit the process by closing the main window does not force the application to quit immediately.</span></span>
  
> [!NOTE]
> <span data-ttu-id="970a2-615"><xref:System.Diagnostics.Process.Kill%2A> 方法以异步方式执行。</span><span class="sxs-lookup"><span data-stu-id="970a2-615">The <xref:System.Diagnostics.Process.Kill%2A> method executes asynchronously.</span></span> <span data-ttu-id="970a2-616">调用 `Kill` 方法后，调用 <xref:System.Diagnostics.Process.WaitForExit%2A> 方法以等待进程退出，或检查 <xref:System.Diagnostics.Process.HasExited%2A> 属性以确定进程是否已退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-616">After calling the `Kill` method, call the <xref:System.Diagnostics.Process.WaitForExit%2A> method to wait for the process to exit, or check the <xref:System.Diagnostics.Process.HasExited%2A> property to determine if the process has exited.</span></span>

> [!NOTE]
> <span data-ttu-id="970a2-617"><xref:System.Diagnostics.Process.WaitForExit%2A> 方法和 <xref:System.Diagnostics.Process.HasExited%2A> 属性不反映后代进程的状态。</span><span class="sxs-lookup"><span data-stu-id="970a2-617">The <xref:System.Diagnostics.Process.WaitForExit%2A> method and the <xref:System.Diagnostics.Process.HasExited%2A> property do not reflect the status of descendant processes.</span></span>
> <span data-ttu-id="970a2-618">使用 `Kill(entireProcessTree: true)` 时，<xref:System.Diagnostics.Process.WaitForExit%2A> 和 <xref:System.Diagnostics.Process.HasExited%2A> 将指示在给定进程退出后退出已完成，即使所有子代尚未退出也是如此。</span><span class="sxs-lookup"><span data-stu-id="970a2-618">When `Kill(entireProcessTree: true)` is used, <xref:System.Diagnostics.Process.WaitForExit%2A> and <xref:System.Diagnostics.Process.HasExited%2A> will indicate that exiting has completed after the given process exits, even if all descendants have not yet exited.</span></span>
  
<span data-ttu-id="970a2-619">如果调用 `Kill`，则进程编辑的数据或分配给进程的资源可能会丢失。</span><span class="sxs-lookup"><span data-stu-id="970a2-619">Data edited by the process or resources allocated to the process can be lost if you call `Kill`.</span></span> 
<span data-ttu-id="970a2-620">`Kill` 会导致异常进程终止，只应在必要时使用。</span><span class="sxs-lookup"><span data-stu-id="970a2-620">`Kill` causes an abnormal process termination and should be used only when necessary.</span></span>
<span data-ttu-id="970a2-621"><xref:System.Diagnostics.Process.CloseMainWindow%2A> 可以有序终止进程，并关闭所有窗口，因此更适合使用接口的应用程序。</span><span class="sxs-lookup"><span data-stu-id="970a2-621"><xref:System.Diagnostics.Process.CloseMainWindow%2A> enables an orderly termination of the process and closes all windows, so it is preferable for applications with an interface.</span></span> <span data-ttu-id="970a2-622">如果 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 失败，则可以使用 `Kill` 终止进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-622">If <xref:System.Diagnostics.Process.CloseMainWindow%2A> fails, you can use `Kill` to terminate the process.</span></span>
<span data-ttu-id="970a2-623">`Kill` 是终止没有图形界面的进程的唯一方法。</span><span class="sxs-lookup"><span data-stu-id="970a2-623">`Kill` is the only way to terminate processes that do not have graphical interfaces.</span></span>
  
<span data-ttu-id="970a2-624">只能对在本地计算机上运行的进程调用 `Kill` 和 <xref:System.Diagnostics.Process.CloseMainWindow%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-624">You can call `Kill` and <xref:System.Diagnostics.Process.CloseMainWindow%2A> only for processes that are running on the local computer.</span></span>
<span data-ttu-id="970a2-625">不能使远程计算机上的进程退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-625">You cannot cause processes on remote computers to exit.</span></span> <span data-ttu-id="970a2-626">只能查看远程计算机上运行的进程的信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-626">You can only view information for processes running on remote computers.</span></span>
  
> [!NOTE]
> <span data-ttu-id="970a2-627">如果在进程当前正在终止时对 `Kill` 方法的调用，则会引发 <xref:System.ComponentModel.Win32Exception>，拒绝访问。</span><span class="sxs-lookup"><span data-stu-id="970a2-627">If the call to the `Kill` method is made while the process is currently terminating, a <xref:System.ComponentModel.Win32Exception> is thrown for Access Denied.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberSignature Language="F#" Value="member this.Kill : unit -&gt; unit" Usage="process.Kill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="970a2-628">立即停止关联的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-628">Immediately stops the associated process.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="970a2-629">无法终止相关联的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-629">The associated process could not be terminated.</span></span>  
  
 <span data-ttu-id="970a2-630">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-630">-or-</span></span>  
  
 <span data-ttu-id="970a2-631">进程将终止。</span><span class="sxs-lookup"><span data-stu-id="970a2-631">The process is terminating.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="970a2-632">你正尝试为远程计算机上运行的进程调用 <see cref="M:System.Diagnostics.Process.Kill" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-632">You are attempting to call <see cref="M:System.Diagnostics.Process.Kill" /> for a process that is running on a remote computer.</span></span> <span data-ttu-id="970a2-633">该方法仅对本地计算机上运行的进程可用。</span><span class="sxs-lookup"><span data-stu-id="970a2-633">The method is available only for processes running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-634">已经退出该进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-634">The process has already exited.</span></span>  
  
<span data-ttu-id="970a2-635">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-635">-or-</span></span> 
<span data-ttu-id="970a2-636">没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-636">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span></exception>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill (bool entireProcessTree);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill(bool entireProcessTree) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (entireProcessTree As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill(bool entireProcessTree);" />
      <MemberSignature Language="F#" Value="member this.Kill : bool -&gt; unit" Usage="process.Kill entireProcessTree" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entireProcessTree" Type="System.Boolean" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="entireProcessTree"><span data-ttu-id="970a2-637"><see langword="true" /> 终止相关联进程及其后代；<see langword="false" /> 仅终止相关联进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-637"><see langword="true" /> to kill the associated process and its descendants; <see langword="false" /> to kill only the associated process.</span></span></param>
        <summary><span data-ttu-id="970a2-638">立即停止关联的进程，并可选择停止其子/后代进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-638">Immediately stops the associated process, and optionally its child/descendent processes.</span></span></summary>
        <remarks><span data-ttu-id="970a2-639">如果将 <paramref name="entireProcessTree" /> 设置为 <see langword="true" />，则在后代终止过程中，将自动跳过调用缺少查看详细信息的权限的进程，因为终止进程无法确定这些进程是否为后代。</span><span class="sxs-lookup"><span data-stu-id="970a2-639">When <paramref name="entireProcessTree" /> is set to <see langword="true" />, processes where the call lacks permissions to view details are silently skipped by the descendant termination process because the termination process is unable to determine whether those processes are descendants.</span></span></remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="970a2-640">无法终止相关联的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-640">The associated process could not be terminated.</span></span>  
  
 <span data-ttu-id="970a2-641">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-641">-or-</span></span>  
  
 <span data-ttu-id="970a2-642">进程将终止。</span><span class="sxs-lookup"><span data-stu-id="970a2-642">The process is terminating.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="970a2-643">你正尝试为远程计算机上运行的进程调用 <see cref="M:System.Diagnostics.Process.Kill" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-643">You are attempting to call <see cref="M:System.Diagnostics.Process.Kill" /> for a process that is running on a remote computer.</span></span> <span data-ttu-id="970a2-644">该方法仅对本地计算机上运行的进程可用。</span><span class="sxs-lookup"><span data-stu-id="970a2-644">The method is available only for processes running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-645">已经退出该进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-645">The process has already exited.</span></span>  
  
<span data-ttu-id="970a2-646">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-646">-or-</span></span>

<span data-ttu-id="970a2-647">没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-647">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span>

<span data-ttu-id="970a2-648">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-648">-or-</span></span>

<span data-ttu-id="970a2-649">调用进程是关联进程的后代树的成员。</span><span class="sxs-lookup"><span data-stu-id="970a2-649">The calling process is a member of the associated process' descendant tree.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="970a2-650">并非关联进程的后代树中的所有进程都可以终止。</span><span class="sxs-lookup"><span data-stu-id="970a2-650">Not all processes in the associated process' descendant tree could be terminated.</span></span></exception>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberSignature Language="F#" Value="static member LeaveDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.LeaveDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="970a2-651">使 <see cref="T:System.Diagnostics.Process" /> 组件离开允许它与以特殊模式运行的操作系统进程交互的状态。</span><span class="sxs-lookup"><span data-stu-id="970a2-651">Takes a <see cref="T:System.Diagnostics.Process" /> component out of the state that lets it interact with operating system processes that run in a special mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-652">某些操作系统进程以特殊模式运行。</span><span class="sxs-lookup"><span data-stu-id="970a2-652">Some operating system processes run in a special mode.</span></span> <span data-ttu-id="970a2-653">如果在组件上调用了 <xref:System.Diagnostics.Process.EnterDebugMode%2A>，则不可能尝试读取或附加到这些进程的属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-653">Attempting to read properties of or attach to these processes is not possible unless you have called <xref:System.Diagnostics.Process.EnterDebugMode%2A> on the component.</span></span> <span data-ttu-id="970a2-654">如果不再需要访问以特殊模式运行的这些进程，请调用 <xref:System.Diagnostics.Process.LeaveDebugMode%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-654">Call <xref:System.Diagnostics.Process.LeaveDebugMode%2A> when you no longer need access to these processes that run in special mode.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Diagnostics.Process.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-655">获取关联进程正在其上运行的计算机的名称。</span><span class="sxs-lookup"><span data-stu-id="970a2-655">Gets the name of the computer the associated process is running on.</span></span></summary>
        <value><span data-ttu-id="970a2-656">关联进程正在其上运行的计算机的名称。</span><span class="sxs-lookup"><span data-stu-id="970a2-656">The name of the computer that the associated process is running on.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-657">您可以查看远程计算机上运行的进程的统计数据和进程信息，但不能在远程计算机上调用 <xref:System.Diagnostics.Process.Start%2A>、<xref:System.Diagnostics.Process.CloseMainWindow%2A>或 <xref:System.Diagnostics.Process.Kill%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-657">You can view statistical data and process information for processes running on remote computers but you cannot call <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, or <xref:System.Diagnostics.Process.Kill%2A> on remote computers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-658">当关联的进程在本地计算机上执行时，此属性将为计算机名称返回句点（"."）。</span><span class="sxs-lookup"><span data-stu-id="970a2-658">When the associated process is executing on the local machine, this property returns a period (".") for the machine name.</span></span> <span data-ttu-id="970a2-659">应使用 <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> 属性来获取正确的计算机名称。</span><span class="sxs-lookup"><span data-stu-id="970a2-659">You should use the <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> property to get the correct machine name.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-660">若要使用下面的示例，必须首先在远程计算机上至少启动记事本的一个实例。</span><span class="sxs-lookup"><span data-stu-id="970a2-660">To use the following example you must first start at least one instance of Notepad on a remote computer.</span></span> <span data-ttu-id="970a2-661">该示例请求记事本正在其上运行的远程计算机的名称，然后显示每个实例各自的 <xref:System.Diagnostics.Process.ProcessName%2A>、<xref:System.Diagnostics.Process.Id%2A>和 <xref:System.Diagnostics.Process.MachineName%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-661">The example requests the name of the remote computer on which Notepad is running, and then displays the respective <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, and <xref:System.Diagnostics.Process.MachineName%2A> properties for each instance.</span></span>  
  
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-662">没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-662">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span></exception>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainModule : System.Diagnostics.ProcessModule" Usage="System.Diagnostics.Process.MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainModule")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-663">获取关联进程的主模块。</span><span class="sxs-lookup"><span data-stu-id="970a2-663">Gets the main module for the associated process.</span></span></summary>
        <value><span data-ttu-id="970a2-664">用于启动进程的 <see cref="T:System.Diagnostics.ProcessModule" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-664">The <see cref="T:System.Diagnostics.ProcessModule" /> that was used to start the process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-665">进程模块表示加载到特定进程中的 .dll 或 .exe 文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-665">A process module represents a.dll or .exe file that is loaded into a particular process.</span></span> <span data-ttu-id="970a2-666">利用 <xref:System.Diagnostics.Process.MainModule%2A> 属性，您可以查看用于启动进程的可执行文件的相关信息，包括模块名称、文件名和模块内存详细信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-666">The <xref:System.Diagnostics.Process.MainModule%2A> property lets you view information about the executable used to start the process, including the module name, file name, and module memory details.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="970a2-667">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.MainModule" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-667">You are trying to access the <see cref="P:System.Diagnostics.Process.MainModule" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="970a2-668">此属性仅可用于本地计算机上运行的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-668">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="970a2-669">32 位进程正尝试访问 64 位进程的模块。</span><span class="sxs-lookup"><span data-stu-id="970a2-669">A 32-bit process is trying to access the modules of a 64-bit process.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-670">进程 <see cref="P:System.Diagnostics.Process.Id" /> 不可用。</span><span class="sxs-lookup"><span data-stu-id="970a2-670">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span></span>  
  
<span data-ttu-id="970a2-671">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-671">-or-</span></span> 
<span data-ttu-id="970a2-672">该进程已退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-672">The process has exited.</span></span></exception>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowHandle : nativeint" Usage="System.Diagnostics.Process.MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-673">获取关联进程主窗口的窗口句柄。</span><span class="sxs-lookup"><span data-stu-id="970a2-673">Gets the window handle of the main window of the associated process.</span></span></summary>
        <value><span data-ttu-id="970a2-674">关联进程主窗口的系统生成的窗口句柄。</span><span class="sxs-lookup"><span data-stu-id="970a2-674">The system-generated window handle of the main window of the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-675">主窗口是由当前具有焦点的进程打开的窗口（<xref:System.Windows.Forms.Form.TopLevel%2A> 窗体）。</span><span class="sxs-lookup"><span data-stu-id="970a2-675">The main window is the window opened by the process that currently has the focus (the <xref:System.Windows.Forms.Form.TopLevel%2A> form).</span></span> <span data-ttu-id="970a2-676">如果已更改，则必须使用 <xref:System.Diagnostics.Process.Refresh%2A> 方法刷新 <xref:System.Diagnostics.Process> 对象以获取当前的主窗口句柄。</span><span class="sxs-lookup"><span data-stu-id="970a2-676">You must use the <xref:System.Diagnostics.Process.Refresh%2A> method to refresh the <xref:System.Diagnostics.Process> object to get the current main window handle if it has changed.</span></span> <span data-ttu-id="970a2-677">通常情况下，因为窗口句柄已缓存，所以请事先使用 <xref:System.Diagnostics.Process.Refresh%2A> 以保证检索当前句柄。</span><span class="sxs-lookup"><span data-stu-id="970a2-677">In general, because the window handle is cached, use <xref:System.Diagnostics.Process.Refresh%2A> beforehand to guarantee that you'll retrieve the current handle.</span></span>  
  
 <span data-ttu-id="970a2-678">只能获取本地计算机上运行的进程的 <xref:System.Diagnostics.Process.MainWindowHandle%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-678">You can get the <xref:System.Diagnostics.Process.MainWindowHandle%2A> property only for processes that are running on the local computer.</span></span> <span data-ttu-id="970a2-679"><xref:System.Diagnostics.Process.MainWindowHandle%2A> 属性是唯一标识与进程关联的窗口的值。</span><span class="sxs-lookup"><span data-stu-id="970a2-679">The <xref:System.Diagnostics.Process.MainWindowHandle%2A> property is a value that uniquely identifies the window that is associated with the process.</span></span>  
  
 <span data-ttu-id="970a2-680">仅当进程具有图形界面时，才有一个与之关联的主窗口。</span><span class="sxs-lookup"><span data-stu-id="970a2-680">A process has a main window associated with it only if the process has a graphical interface.</span></span> <span data-ttu-id="970a2-681">如果关联进程没有主窗口，则 <xref:System.Diagnostics.Process.MainWindowHandle%2A> 值为零。</span><span class="sxs-lookup"><span data-stu-id="970a2-681">If the associated process does not have a main window, the <xref:System.Diagnostics.Process.MainWindowHandle%2A> value is zero.</span></span> <span data-ttu-id="970a2-682">对于已隐藏的进程（即，任务栏中不显示的进程），值也为零。</span><span class="sxs-lookup"><span data-stu-id="970a2-682">The value is also zero for processes that have been hidden, that is, processes that are not visible in the taskbar.</span></span> <span data-ttu-id="970a2-683">这种情况可能会出现在通知区域中任务栏最右侧的图标。</span><span class="sxs-lookup"><span data-stu-id="970a2-683">This can be the case for processes that appear as icons in the notification area, at the far right of the taskbar.</span></span>  
  
 <span data-ttu-id="970a2-684">如果刚启动了一个进程，并想要使用其主窗口句柄，请考虑使用 <xref:System.Diagnostics.Process.WaitForInputIdle%2A> 方法来允许该进程开始，确保已创建了主窗口句柄。</span><span class="sxs-lookup"><span data-stu-id="970a2-684">If you have just started a process and want to use its main window handle, consider using the <xref:System.Diagnostics.Process.WaitForInputIdle%2A> method to allow the process to finish starting, ensuring that the main window handle has been created.</span></span> <span data-ttu-id="970a2-685">否则，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="970a2-685">Otherwise, an exception will be thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-686">未定义 <see cref="P:System.Diagnostics.Process.MainWindowHandle" />，因为已退出进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-686">The <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> is not defined because the process has exited.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="970a2-687">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-687">You are trying to access the <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="970a2-688">此属性仅可用于本地计算机上运行的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-688">This property is available only for processes that are running on the local computer.</span></span></exception>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowTitle : string" Usage="System.Diagnostics.Process.MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowTitle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-689">获取进程的主窗口标题。</span><span class="sxs-lookup"><span data-stu-id="970a2-689">Gets the caption of the main window of the process.</span></span></summary>
        <value><span data-ttu-id="970a2-690">进程的主窗口标题。</span><span class="sxs-lookup"><span data-stu-id="970a2-690">The main window title of the process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-691">仅当进程具有图形界面时，才有一个与之关联的主窗口。</span><span class="sxs-lookup"><span data-stu-id="970a2-691">A process has a main window associated with it only if the process has a graphical interface.</span></span> <span data-ttu-id="970a2-692">如果关联进程没有主窗口（因此 <xref:System.Diagnostics.Process.MainWindowHandle%2A> 为零），或者系统无法确定是否存在主窗口（例如，某些 Unix 平台上可能出现这种情况），则 <xref:System.Diagnostics.Process.MainWindowTitle%2A> 为空字符串（""）。</span><span class="sxs-lookup"><span data-stu-id="970a2-692">If the associated process does not have a main window (so that <xref:System.Diagnostics.Process.MainWindowHandle%2A> is zero), or if the system can't determine that there's a main window (such as may be the case on some Unix platforms), <xref:System.Diagnostics.Process.MainWindowTitle%2A> is an empty string ("").</span></span>
 
 <span data-ttu-id="970a2-693">如果刚启动了一个进程，并想要使用其主窗口标题，请考虑使用 <xref:System.Diagnostics.Process.WaitForInputIdle%2A> 方法来允许该过程开始，并确保已创建主窗口句柄。</span><span class="sxs-lookup"><span data-stu-id="970a2-693">If you have just started a process and want to use its main window title, consider using the <xref:System.Diagnostics.Process.WaitForInputIdle%2A> method to allow the process to finish starting, ensuring that the main window handle has been created.</span></span> <span data-ttu-id="970a2-694">否则，系统将引发异常。</span><span class="sxs-lookup"><span data-stu-id="970a2-694">Otherwise, the system throws an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-695">主窗口是当前具有焦点的窗口;请注意，这可能不是进程的主窗口。</span><span class="sxs-lookup"><span data-stu-id="970a2-695">The main window is the window that currently has the focus; note that this might not be the primary window for the process.</span></span> <span data-ttu-id="970a2-696">如果已更改，则必须使用 <xref:System.Diagnostics.Process.Refresh%2A> 方法刷新 <xref:System.Diagnostics.Process> 对象以获取当前的主窗口句柄。</span><span class="sxs-lookup"><span data-stu-id="970a2-696">You must use the <xref:System.Diagnostics.Process.Refresh%2A> method to refresh the <xref:System.Diagnostics.Process> object to get the current main window handle if it has changed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-697">下面的示例启动记事本实例，并检索进程主窗口的标题。</span><span class="sxs-lookup"><span data-stu-id="970a2-697">The following example starts an instance of Notepad and retrieves the caption of the main window of the process.</span></span>  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-698">未定义 <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> 属性，因为进程已退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-698">The <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> property is not defined because the process has exited.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="970a2-699">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-699">You are trying to access the <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="970a2-700">此属性仅可用于本地计算机上运行的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-700">This property is available only for processes that are running on the local computer.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMaxWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-701">获取或设置关联进程允许的最大工作集大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-701">Gets or sets the maximum allowable working set size, in bytes, for the associated process.</span></span></summary>
        <value><span data-ttu-id="970a2-702">内存中允许的进程的最大工作集大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-702">The maximum working set size that is allowed in memory for the process, in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-703">进程的工作集是当前对物理 RAM 内存中的进程可见的内存页集。</span><span class="sxs-lookup"><span data-stu-id="970a2-703">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="970a2-704">这些页是常驻的，可供应用程序使用，而不会触发页面错误。</span><span class="sxs-lookup"><span data-stu-id="970a2-704">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="970a2-705">工作集包括共享数据和私人数据。</span><span class="sxs-lookup"><span data-stu-id="970a2-705">The working set includes both shared and private data.</span></span> <span data-ttu-id="970a2-706">共享数据包括包含应用程序执行的所有说明的页面，包括 .dll 文件中的页面和系统 .dll 文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-706">The shared data includes the pages that contain all the instructions that your application executes, including the pages in your .dll files and the system.dll files.</span></span> <span data-ttu-id="970a2-707">随着工作集大小的增加，内存需求也会增加。</span><span class="sxs-lookup"><span data-stu-id="970a2-707">As the working set size increases, memory demand increases.</span></span>  
  
 <span data-ttu-id="970a2-708">进程具有最小和最大工作集大小。</span><span class="sxs-lookup"><span data-stu-id="970a2-708">A process has minimum and maximum working set sizes.</span></span> <span data-ttu-id="970a2-709">每次创建进程资源时，系统会保留相当于进程的最小工作集大小的内存量。</span><span class="sxs-lookup"><span data-stu-id="970a2-709">Each time a process resource is created, the system reserves an amount of memory equal to the minimum working set size for the process.</span></span> <span data-ttu-id="970a2-710">当进程处于活动状态时，虚拟内存管理器将尝试至少保留最少的内存，但不会超过最大大小。</span><span class="sxs-lookup"><span data-stu-id="970a2-710">The virtual memory manager attempts to keep at least the minimum amount of memory resident when the process is active, but it never keeps more than the maximum size.</span></span>  
  
 <span data-ttu-id="970a2-711">系统设置默认的工作集大小。</span><span class="sxs-lookup"><span data-stu-id="970a2-711">The system sets the default working set sizes.</span></span> <span data-ttu-id="970a2-712">您可以使用 <xref:System.Diagnostics.Process.MaxWorkingSet%2A> 和 <xref:System.Diagnostics.Process.MinWorkingSet%2A> 成员修改这些大小。</span><span class="sxs-lookup"><span data-stu-id="970a2-712">You can modify these sizes using the <xref:System.Diagnostics.Process.MaxWorkingSet%2A> and <xref:System.Diagnostics.Process.MinWorkingSet%2A> members.</span></span> <span data-ttu-id="970a2-713">但是，设置这些值不能保证保留或驻留内存。</span><span class="sxs-lookup"><span data-stu-id="970a2-713">However, setting these values does not guarantee that the memory will be reserved or resident.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-714">增大进程的工作集大小时，会从系统的其余部分中取出物理内存。</span><span class="sxs-lookup"><span data-stu-id="970a2-714">When you increase the working set size of a process, you take physical memory away from the rest of the system.</span></span> <span data-ttu-id="970a2-715">请确保未请求的最小或最大工作集大小太大，因为这样做可能会降低系统性能。</span><span class="sxs-lookup"><span data-stu-id="970a2-715">Ensure that you do not request a minimum or maximum working set size that is too large, because doing so can degrade system performance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="970a2-716">最大的工作集大小无效。</span><span class="sxs-lookup"><span data-stu-id="970a2-716">The maximum working set size is invalid.</span></span> <span data-ttu-id="970a2-717">它必须大于或等于最小的工作集大小。</span><span class="sxs-lookup"><span data-stu-id="970a2-717">It must be greater than or equal to the minimum working set size.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="970a2-718">无法从关联的进程资源中检索工作集信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-718">Working set information cannot be retrieved from the associated process resource.</span></span>  
  
 <span data-ttu-id="970a2-719">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-719">-or-</span></span>  
  
 <span data-ttu-id="970a2-720">进程标识符或进程句柄为零，因为尚未启动该进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-720">The process identifier or process handle is zero because the process has not been started.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="970a2-721">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-721">You are trying to access the <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="970a2-722">此属性仅可用于本地计算机上运行的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-722">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-723">进程 <see cref="P:System.Diagnostics.Process.Id" /> 不可用。</span><span class="sxs-lookup"><span data-stu-id="970a2-723">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span></span>  
  
<span data-ttu-id="970a2-724">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-724">-or-</span></span> 
<span data-ttu-id="970a2-725">该进程已退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-725">The process has exited.</span></span></exception>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MinWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMinWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-726">获取或设置关联进程允许的最小工作集大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-726">Gets or sets the minimum allowable working set size, in bytes, for the associated process.</span></span></summary>
        <value><span data-ttu-id="970a2-727">内存中进程所需的最小工作集大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-727">The minimum working set size that is required in memory for the process, in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-728">进程的工作集是当前对物理 RAM 内存中的进程可见的内存页集。</span><span class="sxs-lookup"><span data-stu-id="970a2-728">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="970a2-729">这些页是常驻的，可供应用程序使用，而不会触发页面错误。</span><span class="sxs-lookup"><span data-stu-id="970a2-729">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="970a2-730">工作集包括共享数据和私人数据。</span><span class="sxs-lookup"><span data-stu-id="970a2-730">The working set includes both shared and private data.</span></span> <span data-ttu-id="970a2-731">共享数据包括包含应用程序执行的所有说明的页面，包括 .dll 文件中的页面和系统 .dll 文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-731">The shared data includes the pages that contain all the instructions that your application executes, including the pages in your .dll files and the system.dll files.</span></span> <span data-ttu-id="970a2-732">随着工作集大小的增加，内存需求也会增加。</span><span class="sxs-lookup"><span data-stu-id="970a2-732">As the working set size increases, memory demand increases.</span></span>  
  
 <span data-ttu-id="970a2-733">进程具有最小和最大工作集大小。</span><span class="sxs-lookup"><span data-stu-id="970a2-733">A process has minimum and maximum working set sizes.</span></span> <span data-ttu-id="970a2-734">每次创建进程资源时，系统会保留相当于进程的最小工作集大小的内存量。</span><span class="sxs-lookup"><span data-stu-id="970a2-734">Each time a process resource is created, the system reserves an amount of memory equal to the minimum working set size for the process.</span></span> <span data-ttu-id="970a2-735">当进程处于活动状态时，虚拟内存管理器将尝试至少保留最少的内存，但不会超过最大大小。</span><span class="sxs-lookup"><span data-stu-id="970a2-735">The virtual memory manager attempts to keep at least the minimum amount of memory resident when the process is active, but it never keeps more than the maximum size.</span></span>  
  
 <span data-ttu-id="970a2-736">系统设置默认的工作集大小。</span><span class="sxs-lookup"><span data-stu-id="970a2-736">The system sets the default working set sizes.</span></span> <span data-ttu-id="970a2-737">您可以使用 <xref:System.Diagnostics.Process.MaxWorkingSet%2A> 和 <xref:System.Diagnostics.Process.MinWorkingSet%2A> 成员修改这些大小。</span><span class="sxs-lookup"><span data-stu-id="970a2-737">You can modify these sizes using the <xref:System.Diagnostics.Process.MaxWorkingSet%2A> and <xref:System.Diagnostics.Process.MinWorkingSet%2A> members.</span></span> <span data-ttu-id="970a2-738">但是，设置这些值不能保证保留或驻留内存。</span><span class="sxs-lookup"><span data-stu-id="970a2-738">However, setting these values does not guarantee that the memory will be reserved or resident.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-739">增大进程的工作集大小时，会从系统的其余部分中取出物理内存。</span><span class="sxs-lookup"><span data-stu-id="970a2-739">When you increase the working set size of a process, you take physical memory away from the rest of the system.</span></span> <span data-ttu-id="970a2-740">请确保未请求的最小或最大工作集大小太大，因为这样做可能会降低系统性能。</span><span class="sxs-lookup"><span data-stu-id="970a2-740">Ensure that you do not request a minimum or maximum working set size that is too large, because doing so can degrade system performance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="970a2-741">最小工作集大小无效。</span><span class="sxs-lookup"><span data-stu-id="970a2-741">The minimum working set size is invalid.</span></span> <span data-ttu-id="970a2-742">它必须小于或等于最大工作集大小。</span><span class="sxs-lookup"><span data-stu-id="970a2-742">It must be less than or equal to the maximum working set size.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="970a2-743">无法从关联的进程资源中检索工作集信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-743">Working set information cannot be retrieved from the associated process resource.</span></span>  
  
 <span data-ttu-id="970a2-744">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-744">-or-</span></span>  
  
 <span data-ttu-id="970a2-745">进程标识符或进程句柄为零，因为尚未启动该进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-745">The process identifier or process handle is zero because the process has not been started.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="970a2-746">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-746">You are trying to access the <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="970a2-747">此属性仅可用于本地计算机上运行的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-747">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-748">进程 <see cref="P:System.Diagnostics.Process.Id" /> 不可用。</span><span class="sxs-lookup"><span data-stu-id="970a2-748">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span></span>  
  
<span data-ttu-id="970a2-749">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-749">-or-</span></span> 
<span data-ttu-id="970a2-750">该进程已退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-750">The process has exited.</span></span></exception>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : System.Diagnostics.ProcessModuleCollection" Usage="System.Diagnostics.Process.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessModules")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-751">获取已由关联进程加载的模块。</span><span class="sxs-lookup"><span data-stu-id="970a2-751">Gets the modules that have been loaded by the associated process.</span></span></summary>
        <value><span data-ttu-id="970a2-752">类型 <see cref="T:System.Diagnostics.ProcessModule" /> 的数组，表示已由关联进程加载的模块。</span><span class="sxs-lookup"><span data-stu-id="970a2-752">An array of type <see cref="T:System.Diagnostics.ProcessModule" /> that represents the modules that have been loaded by the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-753">进程模块表示加载到特定进程中的 .dll 或 .exe 文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-753">A process module represents a.dll or .exe file that is loaded into a particular process.</span></span> <span data-ttu-id="970a2-754"><xref:System.Diagnostics.ProcessModule> 实例使你可以查看模块的相关信息，包括模块名称、文件名和模块内存详细信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-754">A <xref:System.Diagnostics.ProcessModule> instance lets you view information about a module, including the module name, file name, and module memory details.</span></span>  
  
 <span data-ttu-id="970a2-755">进程可以将多个模块加载到内存中。</span><span class="sxs-lookup"><span data-stu-id="970a2-755">A process can load multiple modules into memory.</span></span> <span data-ttu-id="970a2-756">例如，加载其他 .dll 文件的 .exe 文件具有多个模块。</span><span class="sxs-lookup"><span data-stu-id="970a2-756">For example,.exe files that load additional .dll files have multiple modules.</span></span>  
  
 <span data-ttu-id="970a2-757">启动进程后，在系统加载进程之前，此集合为空。</span><span class="sxs-lookup"><span data-stu-id="970a2-757">After starting the process, this collection is empty until the system has loaded the process.</span></span> <span data-ttu-id="970a2-758">如果该进程具有主窗口，您可以在检索此属性之前调用 <xref:System.Diagnostics.Process.WaitForInputIdle%2A>，以确保获取该列表时该集合是非空的。</span><span class="sxs-lookup"><span data-stu-id="970a2-758">If the process has a main window, you can call <xref:System.Diagnostics.Process.WaitForInputIdle%2A> before retrieving this property to ensure that the collection is nonempty when you get the list.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="970a2-759">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.Modules" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-759">You are attempting to access the <see cref="P:System.Diagnostics.Process.Modules" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="970a2-760">此属性仅可用于本地计算机上运行的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-760">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-761">进程 <see cref="P:System.Diagnostics.Process.Id" /> 不可用。</span><span class="sxs-lookup"><span data-stu-id="970a2-761">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="970a2-762">您尝试访问系统进程或 Idle 进程的 <see cref="P:System.Diagnostics.Process.Modules" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-762">You are attempting to access the <see cref="P:System.Diagnostics.Process.Modules" /> property for either the system process or the idle process.</span></span> <span data-ttu-id="970a2-763">这些进程没有模块。</span><span class="sxs-lookup"><span data-stu-id="970a2-763">These processes do not have modules.</span></span></exception>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize : int" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-764">获取为关联的进程分配的非分页系统内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-764">Gets the amount of nonpaged system memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="970a2-765">系统已为无法写入到虚拟内存分页文件的关联进程分配的内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-765">The amount of memory, in bytes, the system has allocated for the associated process that cannot be written to the virtual memory paging file.</span></span></value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-766">获取为关联的进程分配的非分页系统内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-766">Gets the amount of nonpaged system memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="970a2-767">为关联的进程分配的、不能写入虚拟内存分页文件中的系统内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-767">The amount of system memory, in bytes, allocated for the associated process that cannot be written to the virtual memory paging file.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-768">此属性返回的值表示进程使用的非分页系统内存的当前大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-768">The value returned by this property represents the current size of nonpaged system memory used by the process, in bytes.</span></span> <span data-ttu-id="970a2-769">系统内存是操作系统使用的物理内存，分为分页和非分页的池。</span><span class="sxs-lookup"><span data-stu-id="970a2-769">System memory is the physical memory used by the operating system, and is divided into paged and nonpaged pools.</span></span> <span data-ttu-id="970a2-770">非分页的内存分配将保留在系统内存中，并且不会分页到虚拟内存分页文件中。</span><span class="sxs-lookup"><span data-stu-id="970a2-770">Nonpaged memory allocations remain in system memory and are not paged out to the virtual memory paging file.</span></span>  
  
 <span data-ttu-id="970a2-771">此属性可用于监视包含32位处理器或64位处理器的计算机上的内存使用情况。</span><span class="sxs-lookup"><span data-stu-id="970a2-771">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="970a2-772">属性值等效于进程的 "**池非分页字节数**" 性能计数器。</span><span class="sxs-lookup"><span data-stu-id="970a2-772">The property value is equivalent to the **Pool Nonpaged Bytes** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-773">下面的代码示例启动记事本应用程序的实例。</span><span class="sxs-lookup"><span data-stu-id="970a2-773">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="970a2-774">然后，该示例检索并显示关联进程的各种属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-774">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="970a2-775">该示例在进程退出时进行检测，并显示其退出代码和高峰内存统计信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-775">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberSignature Language="F#" Value="member this.OnExited : unit -&gt; unit" Usage="process.OnExited " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="970a2-776">引发 <see cref="E:System.Diagnostics.Process.Exited" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="970a2-776">Raises the <see cref="E:System.Diagnostics.Process.Exited" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-777"><xref:System.Diagnostics.Process.OnExited%2A> 是引发 <xref:System.Diagnostics.Process.Exited> 事件的 API 方法。</span><span class="sxs-lookup"><span data-stu-id="970a2-777"><xref:System.Diagnostics.Process.OnExited%2A> is the API method that raises the <xref:System.Diagnostics.Process.Exited> event.</span></span> <span data-ttu-id="970a2-778">调用 <xref:System.Diagnostics.Process.OnExited%2A> 会导致 <xref:System.Diagnostics.Process.Exited> 事件发生，并且是使用 <xref:System.Diagnostics.Process> 组件引发事件的唯一方法。</span><span class="sxs-lookup"><span data-stu-id="970a2-778">Calling <xref:System.Diagnostics.Process.OnExited%2A> causes the <xref:System.Diagnostics.Process.Exited> event to occur and is the only way to raise the event using the <xref:System.Diagnostics.Process> component.</span></span> <span data-ttu-id="970a2-779"><xref:System.Diagnostics.Process.OnExited%2A> 主要在从组件派生类时使用。</span><span class="sxs-lookup"><span data-stu-id="970a2-779"><xref:System.Diagnostics.Process.OnExited%2A> is primarily used when deriving classes from the component.</span></span>  
  
 <span data-ttu-id="970a2-780">作为 <xref:System.Diagnostics.Process.OnExited%2A>的替代方法，可以编写自己的事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="970a2-780">As an alternative to <xref:System.Diagnostics.Process.OnExited%2A>, you can write your own event handler.</span></span> <span data-ttu-id="970a2-781">创建自己的事件处理程序委托和自己的事件处理方法。</span><span class="sxs-lookup"><span data-stu-id="970a2-781">You create your own event handler delegate and your own event-handling method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-782">如果你使用的是 Visual Studio 环境，则在将 <xref:System.Diagnostics.Process> 组件拖到窗体上并双击该图标时，将为你创建事件处理程序委托（AddOnExited）和事件处理方法（Process1_Exited）。</span><span class="sxs-lookup"><span data-stu-id="970a2-782">If you are using the Visual Studio environment, an event handler delegate (AddOnExited) and an event-handling method (Process1_Exited) are created for you when you drag a <xref:System.Diagnostics.Process> component onto a form and double-click the icon.</span></span> <span data-ttu-id="970a2-783">当 <xref:System.Diagnostics.Process.Exited> 事件发生时，你创建的代码将输入到 Process1_Exited 过程中。</span><span class="sxs-lookup"><span data-stu-id="970a2-783">The code you create to run when the <xref:System.Diagnostics.Process.Exited> event occurs is entered into the Process1_Exited procedure.</span></span> <span data-ttu-id="970a2-784">您无需创建 <xref:System.Diagnostics.Process.OnExited%2A> 成员，因为它是为您实现的。</span><span class="sxs-lookup"><span data-stu-id="970a2-784">You do not need to create the <xref:System.Diagnostics.Process.OnExited%2A> member, because it is implemented for you.</span></span>  
  
 <span data-ttu-id="970a2-785">引发事件时，将通过委托调用事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="970a2-785">Raising an event invokes the event handler through a delegate.</span></span> <span data-ttu-id="970a2-786">有关概述，请参阅[处理和引发事件](/dotnet/standard/events/)。</span><span class="sxs-lookup"><span data-stu-id="970a2-786">For an overview, see [Handling and Raising Events](/dotnet/standard/events/).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-787">下面的示例演示如何在派生类中使用 <xref:System.Diagnostics.Process.OnExited%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="970a2-787">The following example shows how to use the <xref:System.Diagnostics.Process.OnExited%2A> method in a derived class.</span></span>  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberSignature Language="F#" Value="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event OutputDataReceived As DataReceivedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-788">每次应用程序向其重定向 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 流中写入行时发生。</span><span class="sxs-lookup"><span data-stu-id="970a2-788">Occurs each time an application writes a line to its redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-789"><xref:System.Diagnostics.Process.OutputDataReceived> 事件指示关联的 <xref:System.Diagnostics.Process> 已写入一个行，并以换行符结尾，并将其重定向 <xref:System.Diagnostics.Process.StandardOutput%2A> 流中。</span><span class="sxs-lookup"><span data-stu-id="970a2-789">The <xref:System.Diagnostics.Process.OutputDataReceived> event indicates that the associated <xref:System.Diagnostics.Process> has written a line, terminating with a newline character, to its redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span>  
  
 <span data-ttu-id="970a2-790"><xref:System.Diagnostics.Process.StandardOutput%2A>上的异步读取操作期间，会启用该事件。</span><span class="sxs-lookup"><span data-stu-id="970a2-790">The event is enabled during asynchronous read operations on <xref:System.Diagnostics.Process.StandardOutput%2A>.</span></span> <span data-ttu-id="970a2-791">若要启动异步读取操作，必须重定向 <xref:System.Diagnostics.Process>的 <xref:System.Diagnostics.Process.StandardOutput%2A> 流，将事件处理程序添加到 <xref:System.Diagnostics.Process.OutputDataReceived> 事件，并调用 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-791">To start asynchronous read operations, you must redirect the <xref:System.Diagnostics.Process.StandardOutput%2A> stream of a <xref:System.Diagnostics.Process>, add your event handler to the <xref:System.Diagnostics.Process.OutputDataReceived> event, and call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>.</span></span> <span data-ttu-id="970a2-792">此后，每次进程将行写入重定向的 <xref:System.Diagnostics.Process.StandardOutput%2A> 流时，<xref:System.Diagnostics.Process.OutputDataReceived> 事件都会发出信号，直到进程退出或调用 <xref:System.Diagnostics.Process.CancelOutputRead%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-792">Thereafter, the <xref:System.Diagnostics.Process.OutputDataReceived> event signals each time the process writes a line to the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, until the process exits or calls <xref:System.Diagnostics.Process.CancelOutputRead%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-793">处理异步输出的应用程序应调用 <xref:System.Diagnostics.Process.WaitForExit%2A> 方法，以确保刷新了输出缓冲区。</span><span class="sxs-lookup"><span data-stu-id="970a2-793">The application that is processing the asynchronous output should call the <xref:System.Diagnostics.Process.WaitForExit%2A> method to ensure that the output buffer has been flushed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-794">下面的示例演示如何对 `ipconfig` 命令的重定向 <xref:System.Diagnostics.Process.StandardOutput%2A> 流执行异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-794">The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `ipconfig` command.</span></span>  
  
 <span data-ttu-id="970a2-795">该示例创建 `OutputHandler` 事件处理程序的事件委托，并将其与 <xref:System.Diagnostics.Process.OutputDataReceived> 事件关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-795">The example creates an event delegate for the `OutputHandler` event handler and associates it with the <xref:System.Diagnostics.Process.OutputDataReceived> event.</span></span> <span data-ttu-id="970a2-796">该事件处理程序从重定向的 <xref:System.Diagnostics.Process.StandardOutput%2A> 流接收文本行，设置文本的格式，并将其保存到稍后显示在此示例控制台窗口中的输出字符串。</span><span class="sxs-lookup"><span data-stu-id="970a2-796">The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and saves it in an output string that's later shown in the example's console window.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize : int" Usage="System.Diagnostics.Process.PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-797">获取为关联的进程分配的分页内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-797">Gets the amount of paged memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="970a2-798">由可写入到虚拟内存分页文件的关联进程分配的内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-798">The amount of memory, in bytes, allocated by the associated process that can be written to the virtual memory paging file.</span></span></value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-799">获取为关联的进程分配的分页内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-799">Gets the amount of paged memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="970a2-800">在虚拟内存分页文件中为关联进程分配的内存量(以字节为单位)。</span><span class="sxs-lookup"><span data-stu-id="970a2-800">The amount of memory, in bytes, allocated in the virtual memory paging file for the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-801">此属性返回的值表示进程使用的虚拟内存分页文件中的当前内存大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-801">The value returned by this property represents the current size of memory in the virtual memory paging file used by the process, in bytes.</span></span> <span data-ttu-id="970a2-802">操作系统将虚拟内存分页文件与物理内存一起使用，以管理每个进程的虚拟地址空间。</span><span class="sxs-lookup"><span data-stu-id="970a2-802">The operating system uses the virtual memory paging file in conjunction with physical memory to manage the virtual address space for each process.</span></span> <span data-ttu-id="970a2-803">当不可分页内存未使用时，可以将其传输到磁盘上的虚拟内存分页文件中。</span><span class="sxs-lookup"><span data-stu-id="970a2-803">When pageable memory is not in use, it can be transferred to the virtual memory paging file on disk.</span></span> <span data-ttu-id="970a2-804">若要获取由操作系统用于进程的内存大小，请使用 <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-804">To obtain the size of memory used by the operating system for the process, use the <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A> property.</span></span>  
  
 <span data-ttu-id="970a2-805">此属性可用于监视包含32位处理器或64位处理器的计算机上的内存使用情况。</span><span class="sxs-lookup"><span data-stu-id="970a2-805">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="970a2-806">属性值等效于进程的**Page File Bytes**性能计数器。</span><span class="sxs-lookup"><span data-stu-id="970a2-806">The property value is equivalent to the **Page File Bytes** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-807">下面的代码示例启动记事本应用程序的实例，然后检索并显示关联进程的各种属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-807">The following code example starts an instance of the Notepad application, and then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="970a2-808">该示例在进程退出时进行检测，并显示其退出代码和高峰内存统计信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-808">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize : int" Usage="System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-809">获取为关联进程分配的可分页系统内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-809">Gets the amount of pageable system memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="970a2-810">系统已为可写入到虚拟内存页面文件的关联进程分配的内存量(以字节为单位)。</span><span class="sxs-lookup"><span data-stu-id="970a2-810">The amount of memory, in bytes, the system has allocated for the associated process that can be written to the virtual memory paging file.</span></span></value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-811">获取为关联进程分配的可分页系统内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-811">Gets the amount of pageable system memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="970a2-812">为可写入虚拟内存分页文件的关联内存分配的系统内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-812">The amount of system memory, in bytes, allocated for the associated process that can be written to the virtual memory paging file.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-813">此属性值返回的值表示进程使用的可分页系统内存的当前大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-813">The value returned by this property value represents the current size of pageable system memory used by the process, in bytes.</span></span> <span data-ttu-id="970a2-814">系统内存是操作系统使用的物理内存，分为分页和非分页的池。</span><span class="sxs-lookup"><span data-stu-id="970a2-814">System memory is the physical memory used by the operating system, and is divided into paged and nonpaged pools.</span></span> <span data-ttu-id="970a2-815">当不可分页内存未使用时，可以将其传输到磁盘上的虚拟内存分页文件中。</span><span class="sxs-lookup"><span data-stu-id="970a2-815">When pageable memory is not in use, it can be transferred to the virtual memory paging file on disk.</span></span> <span data-ttu-id="970a2-816">若要获取进程使用的应用程序内存大小，请使用 <xref:System.Diagnostics.Process.PagedMemorySize64%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-816">To obtain the size of the application memory used by the process, use the <xref:System.Diagnostics.Process.PagedMemorySize64%2A> property.</span></span>  
  
 <span data-ttu-id="970a2-817">此属性可用于监视包含32位处理器或64位处理器的计算机上的内存使用情况。</span><span class="sxs-lookup"><span data-stu-id="970a2-817">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="970a2-818">属性值等效于进程的 "**池分页字节数**" 性能计数器。</span><span class="sxs-lookup"><span data-stu-id="970a2-818">The property value is equivalent to the **Pool Paged Bytes** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-819">下面的代码示例启动记事本应用程序的实例。</span><span class="sxs-lookup"><span data-stu-id="970a2-819">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="970a2-820">然后，该示例检索并显示关联进程的各种属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-820">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="970a2-821">该示例在进程退出时进行检测，并显示其退出代码和高峰内存统计信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-821">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize : int" Usage="System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-822">获取关联的进程使用的虚拟内存分页文件中的最大内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-822">Gets the maximum amount of memory in the virtual memory paging file, in bytes, used by the associated process.</span></span></summary>
        <value><span data-ttu-id="970a2-823">由可写入到虚拟内存分页文件的关联进程分配的最大内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-823">The maximum amount of memory, in bytes, allocated by the associated process that could be written to the virtual memory paging file.</span></span></value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-824">获取关联的进程使用的虚拟内存分页文件中的最大内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-824">Gets the maximum amount of memory in the virtual memory paging file, in bytes, used by the associated process.</span></span></summary>
        <value><span data-ttu-id="970a2-825">从启动关联的进程以来在为虚拟内存分页文件中关联进程分配的最大内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-825">The maximum amount of memory, in bytes, allocated in the virtual memory paging file for the associated process since it was started.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-826">此属性值返回的值表示进程自启动以来使用的虚拟内存分页文件中的最大内存大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-826">The value returned by this property value represents the maximum size of memory in the virtual memory paging file used by the process since it started, in bytes.</span></span> <span data-ttu-id="970a2-827">操作系统将虚拟内存分页文件与物理内存一起使用，以管理每个进程的虚拟地址空间。</span><span class="sxs-lookup"><span data-stu-id="970a2-827">The operating system uses the virtual memory paging file in conjunction with physical memory to manage the virtual address space for each process.</span></span> <span data-ttu-id="970a2-828">当不可分页内存未使用时，可以将其传输到磁盘上的虚拟内存分页文件中。</span><span class="sxs-lookup"><span data-stu-id="970a2-828">When pageable memory is not in use, it can be transferred to the virtual memory paging file on disk.</span></span>  
  
 <span data-ttu-id="970a2-829">此属性可用于监视包含32位处理器或64位处理器的计算机上的内存使用情况。</span><span class="sxs-lookup"><span data-stu-id="970a2-829">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="970a2-830">属性值等效于进程的 "**页文件字节峰值**" 性能计数器。</span><span class="sxs-lookup"><span data-stu-id="970a2-830">The property value is equivalent to the **Page File Bytes Peak** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-831">下面的代码示例启动记事本应用程序的实例。</span><span class="sxs-lookup"><span data-stu-id="970a2-831">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="970a2-832">然后，该示例检索并显示关联进程的各种属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-832">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="970a2-833">该示例在进程退出时进行检测，并显示其退出代码和高峰内存统计信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-833">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize : int" Usage="System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-834">获取关联进程使用的最大虚拟内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-834">Gets the maximum amount of virtual memory, in bytes, used by the associated process.</span></span></summary>
        <value><span data-ttu-id="970a2-835">关联进程请求的最大虚拟内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-835">The maximum amount of virtual memory, in bytes, that the associated process has requested.</span></span></value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-836">获取关联进程使用的最大虚拟内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-836">Gets the maximum amount of virtual memory, in bytes, used by the associated process.</span></span></summary>
        <value><span data-ttu-id="970a2-837">从关联进程启动以来为关联进程分配的最大虚拟内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-837">The maximum amount of virtual memory, in bytes, allocated for the associated process since it was started.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-838">此属性返回的值表示进程自启动以来使用的最大虚拟内存大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-838">The value returned by this property represents the maximum size of virtual memory used by the process since it started, in bytes.</span></span> <span data-ttu-id="970a2-839">操作系统将每个进程的虚拟地址空间映射到物理内存中加载的页，或映射到磁盘上的虚拟内存分页文件中存储的页。</span><span class="sxs-lookup"><span data-stu-id="970a2-839">The operating system maps the virtual address space for each process either to pages loaded in physical memory, or to pages stored in the virtual memory paging file on disk.</span></span>  
  
 <span data-ttu-id="970a2-840">此属性可用于监视包含32位处理器或64位处理器的计算机上的内存使用情况。</span><span class="sxs-lookup"><span data-stu-id="970a2-840">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="970a2-841">属性值等效于进程的 "**虚拟字节峰值**" 性能计数器。</span><span class="sxs-lookup"><span data-stu-id="970a2-841">The property value is equivalent to the **Virtual Bytes Peak** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-842">下面的代码示例启动记事本应用程序的实例。</span><span class="sxs-lookup"><span data-stu-id="970a2-842">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="970a2-843">然后，该示例检索并显示关联进程的各种属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-843">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="970a2-844">该示例在进程退出时进行检测，并显示其退出代码和高峰内存统计信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-844">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet : int" Usage="System.Diagnostics.Process.PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-845">获取关联进程的峰值工作集大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-845">Gets the peak working set size for the associated process, in bytes.</span></span></summary>
        <value><span data-ttu-id="970a2-846">关联进程一次所需的最大物理内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-846">The maximum amount of physical memory that the associated process has required all at once, in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-847">进程的工作集是当前对物理 RAM 内存中的进程可见的内存页集。</span><span class="sxs-lookup"><span data-stu-id="970a2-847">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="970a2-848">这些页是常驻的，可供应用程序使用，而不会触发页面错误。</span><span class="sxs-lookup"><span data-stu-id="970a2-848">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="970a2-849">工作集包括共享数据和私人数据。</span><span class="sxs-lookup"><span data-stu-id="970a2-849">The working set includes both shared and private data.</span></span> <span data-ttu-id="970a2-850">共享数据包括包含进程执行的所有说明的页面，包括进程模块和系统库。</span><span class="sxs-lookup"><span data-stu-id="970a2-850">The shared data includes the pages that contain all the instructions that the process executes, including process modules and the system libraries.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet64 : int64" Usage="System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-851">获取关联进程使用的最大物理内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-851">Gets the maximum amount of physical memory, in bytes, used by the associated process.</span></span></summary>
        <value><span data-ttu-id="970a2-852">从启动关联进程以来为关联进程分配的最大物理内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-852">The maximum amount of physical memory, in bytes, allocated for the associated process since it was started.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-853">此属性返回的值表示进程自启动以来使用的工作集内存的最大大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-853">The value returned by this property represents the maximum size of working set memory used by the process since it started, in bytes.</span></span> <span data-ttu-id="970a2-854">进程的工作集是当前对物理 RAM 内存中的进程可见的内存页集。</span><span class="sxs-lookup"><span data-stu-id="970a2-854">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="970a2-855">这些页是常驻的，可供应用程序使用，而不会触发页面错误。</span><span class="sxs-lookup"><span data-stu-id="970a2-855">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="970a2-856">工作集包括共享数据和私人数据。</span><span class="sxs-lookup"><span data-stu-id="970a2-856">The working set includes both shared and private data.</span></span> <span data-ttu-id="970a2-857">共享数据包括包含进程所执行的所有指令的页面，包括进程模块和系统库中的说明。</span><span class="sxs-lookup"><span data-stu-id="970a2-857">The shared data includes the pages that contain all the instructions that the process executes, including instructions from the process modules and the system libraries.</span></span>  
  
 <span data-ttu-id="970a2-858">此属性可用于监视包含32位处理器或64位处理器的计算机上的内存使用情况。</span><span class="sxs-lookup"><span data-stu-id="970a2-858">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="970a2-859">属性值等效于进程的 "**工作集峰值**" 性能计数器。</span><span class="sxs-lookup"><span data-stu-id="970a2-859">The property value is equivalent to the **Working Set Peak** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-860">下面的代码示例启动记事本应用程序的实例。</span><span class="sxs-lookup"><span data-stu-id="970a2-860">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="970a2-861">然后，该示例检索并显示关联进程的各种属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-861">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="970a2-862">该示例在进程退出时进行检测，并显示其退出代码和高峰内存统计信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-862">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityBoostEnabled")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-863">获取或设置一个值，该值指示主窗口拥有焦点时是否应由操作系统暂时提升关联进程优先级。</span><span class="sxs-lookup"><span data-stu-id="970a2-863">Gets or sets a value indicating whether the associated process priority should temporarily be boosted by the operating system when the main window has the focus.</span></span></summary>
        <value><span data-ttu-id="970a2-864">如果进程离开等待状态时应动态提升进程优先级别，则为<see langword="true" /> ；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-864"><see langword="true" /> if dynamic boosting of the process priority should take place for a process when it is taken out of the wait state; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="970a2-865">默认值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-865">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-866">当某个线程在优先级类具有一个或多个动态优先级枚举值（<xref:System.Diagnostics.ProcessPriorityClass.Normal>、<xref:System.Diagnostics.ProcessPriorityClass.High>或 <xref:System.Diagnostics.ProcessPriorityClass.RealTime>）的进程中运行时，系统会在该线程退出等待状态时暂时提升该线程的优先级。</span><span class="sxs-lookup"><span data-stu-id="970a2-866">When a thread runs in a process for which the priority class has one of the dynamic priority enumeration values (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, or <xref:System.Diagnostics.ProcessPriorityClass.RealTime>), the system temporarily boosts the thread's priority when it is taken out of a wait state.</span></span> <span data-ttu-id="970a2-867">此操作可防止其他进程中断当前线程的处理。</span><span class="sxs-lookup"><span data-stu-id="970a2-867">This action prevents other processes from interrupting the processing of the current thread.</span></span> <span data-ttu-id="970a2-868">"<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>" 设置会影响所有现有线程以及此进程随后创建的所有线程。</span><span class="sxs-lookup"><span data-stu-id="970a2-868">The <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> setting affects all the existing threads and any threads subsequently created by the process.</span></span> <span data-ttu-id="970a2-869">若要还原正常行为，请将 <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> 属性设置为 `false`。</span><span class="sxs-lookup"><span data-stu-id="970a2-869">To restore normal behavior, set the <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> property to `false`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-870">提升优先级过高可能会耗尽基本操作系统和网络功能的资源，导致其他操作系统任务出现问题。</span><span class="sxs-lookup"><span data-stu-id="970a2-870">Boosting the priority too high can drain resources from essential operating system and network functions, causing problems with other operating system tasks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="970a2-871">未能从关联的进程资源检索到优先级提升信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-871">Priority boost information could not be retrieved from the associated process resource.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="970a2-872">进程标识符或进程句柄为零。</span><span class="sxs-lookup"><span data-stu-id="970a2-872">The process identifier or process handle is zero.</span></span> <span data-ttu-id="970a2-873">（进程尚未启动。）</span><span class="sxs-lookup"><span data-stu-id="970a2-873">(The process has not been started.)</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="970a2-874">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-874">You are attempting to access the <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="970a2-875">此属性仅可用于本地计算机上运行的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-875">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-876">进程 <see cref="P:System.Diagnostics.Process.Id" /> 不可用。</span><span class="sxs-lookup"><span data-stu-id="970a2-876">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span></span></exception>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityClass : System.Diagnostics.ProcessPriorityClass with get, set" Usage="System.Diagnostics.Process.PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityClass")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-877">获取或设置关联进程的总体优先级类别。</span><span class="sxs-lookup"><span data-stu-id="970a2-877">Gets or sets the overall priority category for the associated process.</span></span></summary>
        <value><span data-ttu-id="970a2-878">关联进程的优先级类别，可从该类别计算进程的 <see cref="P:System.Diagnostics.Process.BasePriority" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-878">The priority category for the associated process, from which the <see cref="P:System.Diagnostics.Process.BasePriority" /> of the process is calculated.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-879">进程优先级类包含一系列线程优先级别。</span><span class="sxs-lookup"><span data-stu-id="970a2-879">A process priority class encompasses a range of thread priority levels.</span></span> <span data-ttu-id="970a2-880">进程中运行的具有不同优先级的线程相对于进程的优先级类运行。</span><span class="sxs-lookup"><span data-stu-id="970a2-880">Threads with different priorities that are running in the process run relative to the priority class of the process.</span></span> <span data-ttu-id="970a2-881">Win32 使用四个优先级类，每个类具有7个基本优先级别。</span><span class="sxs-lookup"><span data-stu-id="970a2-881">Win32 uses four priority classes with seven base priority levels per class.</span></span> <span data-ttu-id="970a2-882">这些进程优先级类在 <xref:System.Diagnostics.ProcessPriorityClass> 枚举中捕获，这使你可以将进程优先级设置为 <xref:System.Diagnostics.ProcessPriorityClass.Idle>、<xref:System.Diagnostics.ProcessPriorityClass.Normal>、<xref:System.Diagnostics.ProcessPriorityClass.High>、<xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>、<xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>或 <xref:System.Diagnostics.ProcessPriorityClass.RealTime>。</span><span class="sxs-lookup"><span data-stu-id="970a2-882">These process priority classes are captured in the <xref:System.Diagnostics.ProcessPriorityClass> enumeration, which lets you set the process priority to <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, or <xref:System.Diagnostics.ProcessPriorityClass.RealTime>.</span></span> <span data-ttu-id="970a2-883">根据所用的时间或其他提升，操作系统在需要将进程移到其他进程以访问处理器时，可以更改基本优先级级别。</span><span class="sxs-lookup"><span data-stu-id="970a2-883">Based on the time elapsed or other boosts, the base priority level can be changed by the operating system when a process needs to be put ahead of others for access to the processor.</span></span> <span data-ttu-id="970a2-884">此外，还可以设置 <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>，以暂时提升从等待状态中获取的线程的优先级。</span><span class="sxs-lookup"><span data-stu-id="970a2-884">In addition, you can set the <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> to temporarily boost the priority level of threads that have been taken out of the wait state.</span></span> <span data-ttu-id="970a2-885">当进程返回到等待状态时，将重置此优先级。</span><span class="sxs-lookup"><span data-stu-id="970a2-885">The priority is reset when the process returns to the wait state.</span></span>  
  
 <span data-ttu-id="970a2-886">利用 <xref:System.Diagnostics.Process.BasePriority%2A> 属性，您可以查看分配给进程的启动优先级。</span><span class="sxs-lookup"><span data-stu-id="970a2-886">The <xref:System.Diagnostics.Process.BasePriority%2A> property lets you view the starting priority that is assigned to a process.</span></span> <span data-ttu-id="970a2-887">但是，因为它是只读的，所以不能使用 <xref:System.Diagnostics.Process.BasePriority%2A> 属性设置进程的优先级。</span><span class="sxs-lookup"><span data-stu-id="970a2-887">However, because it is read-only, you cannot use the <xref:System.Diagnostics.Process.BasePriority%2A> property to set the priority of a process.</span></span> <span data-ttu-id="970a2-888">若要更改优先级，请使用 <xref:System.Diagnostics.Process.PriorityClass%2A> 属性，该属性可获取或设置进程的总体优先级类别。</span><span class="sxs-lookup"><span data-stu-id="970a2-888">To change the priority, use the <xref:System.Diagnostics.Process.PriorityClass%2A> property, which gets or sets the overall priority category for the process.</span></span>  
  
 <span data-ttu-id="970a2-889">无法使用系统监视器查看优先级类。</span><span class="sxs-lookup"><span data-stu-id="970a2-889">The priority class cannot be viewed using System Monitor.</span></span> <span data-ttu-id="970a2-890">下表显示 <xref:System.Diagnostics.Process.BasePriority%2A> 和 <xref:System.Diagnostics.Process.PriorityClass%2A> 值之间的关系。</span><span class="sxs-lookup"><span data-stu-id="970a2-890">The following table shows the relationship between the <xref:System.Diagnostics.Process.BasePriority%2A> and <xref:System.Diagnostics.Process.PriorityClass%2A> values.</span></span>  
  
|<span data-ttu-id="970a2-891">BasePriority</span><span class="sxs-lookup"><span data-stu-id="970a2-891">BasePriority</span></span>|<span data-ttu-id="970a2-892">PriorityClass</span><span class="sxs-lookup"><span data-stu-id="970a2-892">PriorityClass</span></span>|  
|------------------|-------------------|  
|<span data-ttu-id="970a2-893">4</span><span class="sxs-lookup"><span data-stu-id="970a2-893">4</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|<span data-ttu-id="970a2-894">8</span><span class="sxs-lookup"><span data-stu-id="970a2-894">8</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|<span data-ttu-id="970a2-895">13</span><span class="sxs-lookup"><span data-stu-id="970a2-895">13</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|<span data-ttu-id="970a2-896">24</span><span class="sxs-lookup"><span data-stu-id="970a2-896">24</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 <span data-ttu-id="970a2-897">下面的示例启动记事本的实例。</span><span class="sxs-lookup"><span data-stu-id="970a2-897">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="970a2-898">然后，该示例检索并显示关联进程的各种属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-898">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="970a2-899">该示例在进程退出时进行检测，并显示该进程的退出代码。</span><span class="sxs-lookup"><span data-stu-id="970a2-899">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="970a2-900">无法从关联的进程资源中设置或检索进程优先级信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-900">Process priority information could not be set or retrieved from the associated process resource.</span></span>  
  
 <span data-ttu-id="970a2-901">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-901">-or-</span></span>  
  
 <span data-ttu-id="970a2-902">进程标识符或进程句柄为零。</span><span class="sxs-lookup"><span data-stu-id="970a2-902">The process identifier or process handle is zero.</span></span> <span data-ttu-id="970a2-903">（进程尚未启动。）</span><span class="sxs-lookup"><span data-stu-id="970a2-903">(The process has not been started.)</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="970a2-904">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.PriorityClass" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-904">You are attempting to access the <see cref="P:System.Diagnostics.Process.PriorityClass" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="970a2-905">此属性仅可用于本地计算机上运行的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-905">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-906">进程 <see cref="P:System.Diagnostics.Process.Id" /> 不可用。</span><span class="sxs-lookup"><span data-stu-id="970a2-906">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="970a2-907">无法设置优先级类，因为它不使用有效的值，如 <see cref="T:System.Diagnostics.ProcessPriorityClass" /> 枚举中所定义。</span><span class="sxs-lookup"><span data-stu-id="970a2-907">Priority class cannot be set because it does not use a valid value, as defined in the <see cref="T:System.Diagnostics.ProcessPriorityClass" /> enumeration.</span></span></exception>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize : int" Usage="System.Diagnostics.Process.PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-908">获取为关联的进程分配的专用内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-908">Gets the amount of private memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="970a2-909">由关联的进程分配的、不能与其他进程共享的字节数。</span><span class="sxs-lookup"><span data-stu-id="970a2-909">The number of bytes allocated by the associated process that cannot be shared with other processes.</span></span></value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize64 : int64" Usage="System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-910">获取为关联的进程分配的专用内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-910">Gets the amount of private memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="970a2-911">为关联进程分配的不能与其他进程共享的内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-911">The amount of memory, in bytes, allocated for the associated process that cannot be shared with other processes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-912">此属性返回的值表示进程使用的内存的当前大小（以字节为单位），该内存大小不能与其他进程共享。</span><span class="sxs-lookup"><span data-stu-id="970a2-912">The value returned by this property represents the current size of memory used by the process, in bytes, that cannot be shared with other processes.</span></span>  
  
 <span data-ttu-id="970a2-913">此属性可用于监视包含32位处理器或64位处理器的计算机上的内存使用情况。</span><span class="sxs-lookup"><span data-stu-id="970a2-913">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="970a2-914">属性值等效于进程的**专用字节**性能计数器。</span><span class="sxs-lookup"><span data-stu-id="970a2-914">The property value is equivalent to the **Private Bytes** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-915">下面的代码示例启动记事本应用程序的实例。</span><span class="sxs-lookup"><span data-stu-id="970a2-915">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="970a2-916">然后，该示例检索并显示关联进程的各种属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-916">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="970a2-917">该示例在进程退出时进行检测，并显示其退出代码和高峰内存统计信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-917">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivilegedProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-918">获取此进程的特权处理器时间。</span><span class="sxs-lookup"><span data-stu-id="970a2-918">Gets the privileged processor time for this process.</span></span></summary>
        <value><span data-ttu-id="970a2-919"><see cref="T:System.TimeSpan" />，它指示进程在操作系统内核中运行代码所用的时间。</span><span class="sxs-lookup"><span data-stu-id="970a2-919">A <see cref="T:System.TimeSpan" /> that indicates the amount of time that the process has spent running code inside the operating system core.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="970a2-920">下面的示例启动记事本的实例。</span><span class="sxs-lookup"><span data-stu-id="970a2-920">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="970a2-921">然后，该示例检索并显示关联进程的各种属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-921">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="970a2-922">该示例在进程退出时进行检测，并显示该进程的退出代码。</span><span class="sxs-lookup"><span data-stu-id="970a2-922">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="970a2-923">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-923">You are attempting to access the <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="970a2-924">此属性仅可用于本地计算机上运行的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-924">This property is available only for processes that are running on the local computer.</span></span></exception>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessName : string" Usage="System.Diagnostics.Process.ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-925">获取该进程的名称。</span><span class="sxs-lookup"><span data-stu-id="970a2-925">Gets the name of the process.</span></span></summary>
        <value><span data-ttu-id="970a2-926">系统用以向用户标识该进程的名称。</span><span class="sxs-lookup"><span data-stu-id="970a2-926">The name that the system uses to identify the process to the user.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-927"><xref:System.Diagnostics.Process.ProcessName%2A> 属性保留一个可执行文件名（如 Outlook），该名称不包括 .exe 扩展名或路径。</span><span class="sxs-lookup"><span data-stu-id="970a2-927">The <xref:System.Diagnostics.Process.ProcessName%2A> property holds an executable file name, such as Outlook, that does not include the .exe extension or the path.</span></span> <span data-ttu-id="970a2-928">它有助于获取和操作与同一可执行文件关联的所有进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-928">It is helpful for getting and manipulating all the processes that are associated with the same executable file.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-929">在 [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] 操作系统上，如果无法获取进程模块信息，则 <xref:System.Diagnostics.Process.ProcessName%2A> 属性可能会被截断为15个字符。</span><span class="sxs-lookup"><span data-stu-id="970a2-929">On [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] operating systems, the <xref:System.Diagnostics.Process.ProcessName%2A> property may be truncated to 15 characters if the process module information cannot be obtained.</span></span>  
  
 <span data-ttu-id="970a2-930">可以调用 <xref:System.Diagnostics.Process.GetProcessesByName%2A>，并向其传递可执行文件的名称，以检索包含指定计算机上每个正在运行的实例的数组。</span><span class="sxs-lookup"><span data-stu-id="970a2-930">You can call <xref:System.Diagnostics.Process.GetProcessesByName%2A>, passing it an executable file name, to retrieve an array that contains every running instance on the specified computer.</span></span> <span data-ttu-id="970a2-931">例如，你可以使用此数组关闭可执行文件的所有正在运行的实例。</span><span class="sxs-lookup"><span data-stu-id="970a2-931">You can use this array, for example, to shut down all the running instances of the executable file.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-932">进程没有标识符，或者没有与 <see cref="T:System.Diagnostics.Process" /> 关联的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-932">The process does not have an identifier, or no process is associated with the <see cref="T:System.Diagnostics.Process" />.</span></span>  
  
<span data-ttu-id="970a2-933">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-933">-or-</span></span> 
<span data-ttu-id="970a2-934">关联进程已退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-934">The associated process has exited.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="970a2-935">进程不在此计算机上。</span><span class="sxs-lookup"><span data-stu-id="970a2-935">The process is not on this computer.</span></span></exception>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint with get, set" Usage="System.Diagnostics.Process.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessorAffinity")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-936">获取或设置一些处理器，此进程中的线程可以按计划在这些处理器上运行。</span><span class="sxs-lookup"><span data-stu-id="970a2-936">Gets or sets the processors on which the threads in this process can be scheduled to run.</span></span></summary>
        <value><span data-ttu-id="970a2-937">位掩码，表示关联进程内的线程可以在其上运行的处理器。</span><span class="sxs-lookup"><span data-stu-id="970a2-937">A bitmask representing the processors that the threads in the associated process can run on.</span></span> <span data-ttu-id="970a2-938">默认值取决于计算机上的处理器数。</span><span class="sxs-lookup"><span data-stu-id="970a2-938">The default depends on the number of processors on the computer.</span></span> <span data-ttu-id="970a2-939">默认值为 2 <sup>n</sup> -1，其中 n 是处理器数。</span><span class="sxs-lookup"><span data-stu-id="970a2-939">The default value is 2 <sup>n</sup> -1, where n is the number of processors.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-940">在 Windows 2000 和更高版本中，进程中的线程可以从处理器迁移到处理器，每次迁移都重新加载处理器缓存。</span><span class="sxs-lookup"><span data-stu-id="970a2-940">In Windows 2000 and later, a thread in a process can migrate from processor to processor, with each migration reloading the processor cache.</span></span> <span data-ttu-id="970a2-941">在负载过重的系统负载下，通过减少重新加载处理器缓存的次数来指定哪个处理器应运行特定的线程，从而提高性能。</span><span class="sxs-lookup"><span data-stu-id="970a2-941">Under heavy system loads, specifying which processor should run a specific thread can improve performance by reducing the number of times the processor cache is reloaded.</span></span> <span data-ttu-id="970a2-942">处理器和线程之间的关联称为处理器关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-942">The association between a processor and a thread is called the processor affinity.</span></span>  
  
 <span data-ttu-id="970a2-943">每个处理器都表示为一个位。</span><span class="sxs-lookup"><span data-stu-id="970a2-943">Each processor is represented as a bit.</span></span> <span data-ttu-id="970a2-944">位0为 processor one，位1为 processor 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="970a2-944">Bit 0 is processor one, bit 1 is processor two, and so forth.</span></span> <span data-ttu-id="970a2-945">如果将某个位设置为值1，则会为线程分配选择相应的处理器。</span><span class="sxs-lookup"><span data-stu-id="970a2-945">If you set a bit to the value 1, the corresponding processor is selected for thread assignment.</span></span> <span data-ttu-id="970a2-946">将 <xref:System.Diagnostics.Process.ProcessorAffinity%2A> 值设置为零时，操作系统的计划算法会设置线程的关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-946">When you set the <xref:System.Diagnostics.Process.ProcessorAffinity%2A> value to zero, the operating system's scheduling algorithms set the thread's affinity.</span></span> <span data-ttu-id="970a2-947">如果将 <xref:System.Diagnostics.Process.ProcessorAffinity%2A> 值设置为任何非零值，则该值将解释为指定可供选择的处理器的位掩码。</span><span class="sxs-lookup"><span data-stu-id="970a2-947">When the <xref:System.Diagnostics.Process.ProcessorAffinity%2A> value is set to any nonzero value, the value is interpreted as a bitmask that specifies those processors eligible for selection.</span></span>  
  
 <span data-ttu-id="970a2-948">下表显示了对八处理器系统的 <xref:System.Diagnostics.Process.ProcessorAffinity%2A> 值的选择。</span><span class="sxs-lookup"><span data-stu-id="970a2-948">The following table shows a selection of <xref:System.Diagnostics.Process.ProcessorAffinity%2A> values for an eight-processor system.</span></span>  
  
|<span data-ttu-id="970a2-949">位</span><span class="sxs-lookup"><span data-stu-id="970a2-949">Bitmask</span></span>|<span data-ttu-id="970a2-950">二进制值</span><span class="sxs-lookup"><span data-stu-id="970a2-950">Binary value</span></span>|<span data-ttu-id="970a2-951">合格处理器</span><span class="sxs-lookup"><span data-stu-id="970a2-951">Eligible processors</span></span>|  
|-------------|------------------|-------------------------|  
|<span data-ttu-id="970a2-952">0x0001</span><span class="sxs-lookup"><span data-stu-id="970a2-952">0x0001</span></span>|<span data-ttu-id="970a2-953">00000000 00000001</span><span class="sxs-lookup"><span data-stu-id="970a2-953">00000000 00000001</span></span>|<span data-ttu-id="970a2-954">1</span><span class="sxs-lookup"><span data-stu-id="970a2-954">1</span></span>|  
|<span data-ttu-id="970a2-955">0x0003</span><span class="sxs-lookup"><span data-stu-id="970a2-955">0x0003</span></span>|<span data-ttu-id="970a2-956">00000000 00000011</span><span class="sxs-lookup"><span data-stu-id="970a2-956">00000000 00000011</span></span>|<span data-ttu-id="970a2-957">1和2</span><span class="sxs-lookup"><span data-stu-id="970a2-957">1 and 2</span></span>|  
|<span data-ttu-id="970a2-958">0x0007</span><span class="sxs-lookup"><span data-stu-id="970a2-958">0x0007</span></span>|<span data-ttu-id="970a2-959">00000000 00000111</span><span class="sxs-lookup"><span data-stu-id="970a2-959">00000000 00000111</span></span>|<span data-ttu-id="970a2-960">1、2和3</span><span class="sxs-lookup"><span data-stu-id="970a2-960">1, 2 and 3</span></span>|  
|<span data-ttu-id="970a2-961">0x0009</span><span class="sxs-lookup"><span data-stu-id="970a2-961">0x0009</span></span>|<span data-ttu-id="970a2-962">00000000 00001001</span><span class="sxs-lookup"><span data-stu-id="970a2-962">00000000 00001001</span></span>|<span data-ttu-id="970a2-963">1和4</span><span class="sxs-lookup"><span data-stu-id="970a2-963">1 and 4</span></span>|  
|<span data-ttu-id="970a2-964">0x007F</span><span class="sxs-lookup"><span data-stu-id="970a2-964">0x007F</span></span>|<span data-ttu-id="970a2-965">00000000 01111111</span><span class="sxs-lookup"><span data-stu-id="970a2-965">00000000 01111111</span></span>|<span data-ttu-id="970a2-966">1、2、3、4、5、6和7</span><span class="sxs-lookup"><span data-stu-id="970a2-966">1, 2, 3, 4, 5, 6 and 7</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="970a2-967">未能从关联的进程资源设置或检索 <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> 信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-967"><see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> information could not be set or retrieved from the associated process resource.</span></span>  
  
<span data-ttu-id="970a2-968">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-968">-or-</span></span> 
<span data-ttu-id="970a2-969">进程标识符或进程句柄为零。</span><span class="sxs-lookup"><span data-stu-id="970a2-969">The process identifier or process handle is zero.</span></span> <span data-ttu-id="970a2-970">（进程尚未启动。）</span><span class="sxs-lookup"><span data-stu-id="970a2-970">(The process has not been started.)</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="970a2-971">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-971">You are attempting to access the <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="970a2-972">此属性仅可用于本地计算机上运行的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-972">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-973">进程 <see cref="P:System.Diagnostics.Process.Id" /> 不可用。</span><span class="sxs-lookup"><span data-stu-id="970a2-973">The process <see cref="P:System.Diagnostics.Process.Id" /> was not available.</span></span>  
  
<span data-ttu-id="970a2-974">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-974">-or-</span></span> 
<span data-ttu-id="970a2-975">该进程已退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-975">The process has exited.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="process.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="970a2-976">放弃已缓存到进程组件的关联仅存的任何相关信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-976">Discards any information about the associated process that has been cached inside the process component.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-977">调用 <xref:System.Diagnostics.Process.Refresh%2A> 后，有关每个属性的信息的第一个请求将导致进程组件从关联进程获取新值。</span><span class="sxs-lookup"><span data-stu-id="970a2-977">After <xref:System.Diagnostics.Process.Refresh%2A> is called, the first request for information about each property causes the process component to obtain a new value from the associated process.</span></span>  
  
 <span data-ttu-id="970a2-978">当 <xref:System.Diagnostics.Process> 组件与某个进程资源关联时，将根据关联进程的状态立即填充 <xref:System.Diagnostics.Process> 的属性值。</span><span class="sxs-lookup"><span data-stu-id="970a2-978">When a <xref:System.Diagnostics.Process> component is associated with a process resource, the property values of the <xref:System.Diagnostics.Process> are immediately populated according to the status of the associated process.</span></span> <span data-ttu-id="970a2-979">如果有关关联进程的信息随后发生更改，则这些更改不会反映在 <xref:System.Diagnostics.Process> 组件的缓存值中。</span><span class="sxs-lookup"><span data-stu-id="970a2-979">If the information about the associated process subsequently changes, those changes are not reflected in the <xref:System.Diagnostics.Process> component's cached values.</span></span> <span data-ttu-id="970a2-980"><xref:System.Diagnostics.Process> 组件是进程资源关联时的快照。</span><span class="sxs-lookup"><span data-stu-id="970a2-980">The <xref:System.Diagnostics.Process> component is a snapshot of the process resource at the time they are associated.</span></span> <span data-ttu-id="970a2-981">若要查看关联进程的当前值，请调用 <xref:System.Diagnostics.Process.Refresh%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="970a2-981">To view the current values for the associated process, call the <xref:System.Diagnostics.Process.Refresh%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-982">下面的示例启动记事本的实例。</span><span class="sxs-lookup"><span data-stu-id="970a2-982">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="970a2-983">然后，它以2秒的间隔检索关联进程的物理内存使用率，最大值为10秒。</span><span class="sxs-lookup"><span data-stu-id="970a2-983">It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds.</span></span> <span data-ttu-id="970a2-984">该示例检测进程是否在10秒后退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-984">The example detects whether the process exits before 10 seconds have elapsed.</span></span> <span data-ttu-id="970a2-985">如果10秒后仍在运行，则此示例将关闭进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-985">The example closes the process if it is still running after 10 seconds.</span></span>  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Responding : bool" Usage="System.Diagnostics.Process.Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessResponding")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-986">获取指示进程的用户界面当前是否响应的值。</span><span class="sxs-lookup"><span data-stu-id="970a2-986">Gets a value indicating whether the user interface of the process is responding.</span></span></summary>
        <value><span data-ttu-id="970a2-987">如果关联进程的用户界面当前响应系统，则为<see langword="true" /> ；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-987"><see langword="true" /> if the user interface of the associated process is responding to the system; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-988">如果某个进程具有用户界面，则 <xref:System.Diagnostics.Process.Responding%2A> 属性将与用户界面联系，以确定该进程是否正在响应用户输入。</span><span class="sxs-lookup"><span data-stu-id="970a2-988">If a process has a user interface, the <xref:System.Diagnostics.Process.Responding%2A> property contacts the user interface to determine whether the process is responding to user input.</span></span> <span data-ttu-id="970a2-989">如果接口未立即响应，则 <xref:System.Diagnostics.Process.Responding%2A> 属性将返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="970a2-989">If the interface does not respond immediately, the <xref:System.Diagnostics.Process.Responding%2A> property returns `false`.</span></span> <span data-ttu-id="970a2-990">使用此属性来确定关联进程的接口是否已停止响应。</span><span class="sxs-lookup"><span data-stu-id="970a2-990">Use this property to determine whether the interface of the associated process has stopped responding.</span></span>  
  
 <span data-ttu-id="970a2-991">如果该进程没有 <xref:System.Diagnostics.Process.MainWindowHandle%2A>，则此属性将返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="970a2-991">If the process does not have a <xref:System.Diagnostics.Process.MainWindowHandle%2A>, this property returns `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-992">下面的示例启动记事本的实例。</span><span class="sxs-lookup"><span data-stu-id="970a2-992">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="970a2-993">然后，该示例检索并显示关联进程的各种属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-993">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="970a2-994">该示例在进程退出时进行检测，并显示该进程的退出代码。</span><span class="sxs-lookup"><span data-stu-id="970a2-994">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-995">没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-995">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="970a2-996">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.Responding" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-996">You are attempting to access the <see cref="P:System.Diagnostics.Process.Responding" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="970a2-997">此属性仅可用于本地计算机上运行的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-997">This property is available only for processes that are running on the local computer.</span></span></exception>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : Microsoft.Win32.SafeHandles.SafeProcessHandle" Usage="System.Diagnostics.Process.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-998">获取此进程的本机句柄。</span><span class="sxs-lookup"><span data-stu-id="970a2-998">Gets the native handle to this process.</span></span></summary>
        <value><span data-ttu-id="970a2-999">此进程的本机句柄。</span><span class="sxs-lookup"><span data-stu-id="970a2-999">The native handle to this process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-1000">句柄仅在调用组件启动进程时可用。</span><span class="sxs-lookup"><span data-stu-id="970a2-1000">The handle is only available if the calling component started the process.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SessionId : int" Usage="System.Diagnostics.Process.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSessionId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-1001">获取关联进程的终端服务会话标识符。</span><span class="sxs-lookup"><span data-stu-id="970a2-1001">Gets the Terminal Services session identifier for the associated process.</span></span></summary>
        <value><span data-ttu-id="970a2-1002">关联进程的终端服务会话标识符。</span><span class="sxs-lookup"><span data-stu-id="970a2-1002">The Terminal Services session identifier for the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-1003"><xref:System.Diagnostics.Process.SessionId%2A> 属性标识当前正在其中运行应用程序的会话。</span><span class="sxs-lookup"><span data-stu-id="970a2-1003">The <xref:System.Diagnostics.Process.SessionId%2A> property identifies the session in which the application is currently running.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="970a2-1004">没有与此进程关联的会话。</span><span class="sxs-lookup"><span data-stu-id="970a2-1004">There is no session associated with this process.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-1005">没有与此会话标识符关联的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1005">There is no process associated with this session identifier.</span></span>  
  
 <span data-ttu-id="970a2-1006">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-1006">-or-</span></span>  
  
 <span data-ttu-id="970a2-1007">关联的进程不在此计算机上。</span><span class="sxs-lookup"><span data-stu-id="970a2-1007">The associated process is not on this machine.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardError : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardError")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-1008">获取用于读取应用程序错误输出的流。</span><span class="sxs-lookup"><span data-stu-id="970a2-1008">Gets a stream used to read the error output of the application.</span></span></summary>
        <value><span data-ttu-id="970a2-1009">可用于读取应用程序的标准错误流的 <see cref="T:System.IO.StreamReader" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-1009">A <see cref="T:System.IO.StreamReader" /> that can be used to read the standard error stream of the application.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-1010">当 <xref:System.Diagnostics.Process> 向其标准错误流写入文本时，该文本通常会显示在控制台上。</span><span class="sxs-lookup"><span data-stu-id="970a2-1010">When a <xref:System.Diagnostics.Process> writes text to its standard error stream, that text is normally displayed on the console.</span></span> <span data-ttu-id="970a2-1011">通过重定向 <xref:System.Diagnostics.Process.StandardError%2A> 流，你可以操作或取消进程的错误输出。</span><span class="sxs-lookup"><span data-stu-id="970a2-1011">By redirecting the <xref:System.Diagnostics.Process.StandardError%2A> stream, you can manipulate or suppress the error output of a process.</span></span> <span data-ttu-id="970a2-1012">例如，你可以筛选文本，以不同的方式对其进行格式设置，或者将输出写入控制台和指定的日志文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1012">For example, you can filter the text, format it differently, or write the output to both the console and a designated log file.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-1013">若要使用 <xref:System.Diagnostics.Process.StandardError%2A>，你必须将 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> 设置为 `false`，并且必须将 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType> 设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="970a2-1013">To use <xref:System.Diagnostics.Process.StandardError%2A>, you must set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> to `false`, and you must set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType> to `true`.</span></span> <span data-ttu-id="970a2-1014">否则，从 <xref:System.Diagnostics.Process.StandardError%2A> 流中读取会引发异常。</span><span class="sxs-lookup"><span data-stu-id="970a2-1014">Otherwise, reading from the <xref:System.Diagnostics.Process.StandardError%2A> stream throws an exception.</span></span>  
  
 <span data-ttu-id="970a2-1015">重定向的 <xref:System.Diagnostics.Process.StandardError%2A> 流可以同步或异步读取。</span><span class="sxs-lookup"><span data-stu-id="970a2-1015">The redirected <xref:System.Diagnostics.Process.StandardError%2A> stream can be read synchronously or asynchronously.</span></span> <span data-ttu-id="970a2-1016"><xref:System.IO.StreamReader.Read%2A>、<xref:System.IO.StreamReader.ReadLine%2A>和 <xref:System.IO.StreamReader.ReadToEnd%2A> 等方法执行进程的错误输出流上的同步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-1016">Methods such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, and <xref:System.IO.StreamReader.ReadToEnd%2A> perform synchronous read operations on the error output stream of the process.</span></span> <span data-ttu-id="970a2-1017">在关联的 <xref:System.Diagnostics.Process> 写入其 <xref:System.Diagnostics.Process.StandardError%2A> 流或关闭流之前，这些同步读取操作不会完成。</span><span class="sxs-lookup"><span data-stu-id="970a2-1017">These synchronous read operations do not complete until the associated <xref:System.Diagnostics.Process> writes to its <xref:System.Diagnostics.Process.StandardError%2A> stream, or closes the stream.</span></span>  
  
 <span data-ttu-id="970a2-1018">与此相反，<xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 会对 <xref:System.Diagnostics.Process.StandardError%2A> 流启动异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-1018">In contrast, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> starts asynchronous read operations on the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span> <span data-ttu-id="970a2-1019">此方法将为流输出启用指定的事件处理程序，并立即返回到调用方，当流输出定向到事件处理程序时，该处理程序可以执行其他操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-1019">This method enables a designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</span></span>  
  
 <span data-ttu-id="970a2-1020">同步读取操作会在调用方之间引入依赖关系，从 <xref:System.Diagnostics.Process.StandardError%2A> 流读取，子进程写入该流。</span><span class="sxs-lookup"><span data-stu-id="970a2-1020">Synchronous read operations introduce a dependency between the caller reading from the <xref:System.Diagnostics.Process.StandardError%2A> stream and the child process writing to that stream.</span></span> <span data-ttu-id="970a2-1021">这些依赖项可能会导致死锁情况。</span><span class="sxs-lookup"><span data-stu-id="970a2-1021">These dependencies can result in deadlock conditions.</span></span> <span data-ttu-id="970a2-1022">当调用方从子进程的重定向流中进行读取时，它依赖于子进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1022">When the caller reads from the redirected stream of a child process, it is dependent on the child.</span></span> <span data-ttu-id="970a2-1023">调用方等待读取操作，直到子级写入流或关闭流为止。</span><span class="sxs-lookup"><span data-stu-id="970a2-1023">The caller waits on the read operation until the child writes to the stream or closes the stream.</span></span> <span data-ttu-id="970a2-1024">当子进程写入足够的数据以填充其重定向流时，它依赖于父进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1024">When the child process writes enough data to fill its redirected stream, it is dependent on the parent.</span></span> <span data-ttu-id="970a2-1025">子进程将在下一次写入操作之前等待，直到父进程从整个流中读取或关闭流为止。</span><span class="sxs-lookup"><span data-stu-id="970a2-1025">The child process waits on the next write operation until the parent reads from the full stream or closes the stream.</span></span> <span data-ttu-id="970a2-1026">当调用方和子进程等待彼此完成操作时，会发生死锁条件，并且这两个情况都无法继续。</span><span class="sxs-lookup"><span data-stu-id="970a2-1026">The deadlock condition results when the caller and child process wait on each other to complete an operation, and neither can proceed.</span></span> <span data-ttu-id="970a2-1027">您可以通过计算调用方和子进程之间的依赖关系来避免死锁。</span><span class="sxs-lookup"><span data-stu-id="970a2-1027">You can avoid deadlocks by evaluating dependencies between the caller and child process.</span></span>  

<span data-ttu-id="970a2-1028">本节中的最后两个示例使用 <xref:System.Diagnostics.Process.Start%2A> 方法来启动一个名为*Write500Lines*的可执行文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1028">The last two examples in this section use the <xref:System.Diagnostics.Process.Start%2A> method to launch an executable named *Write500Lines.exe*.</span></span> <span data-ttu-id="970a2-1029">下面的示例包含它的源代码。</span><span class="sxs-lookup"><span data-stu-id="970a2-1029">The following example contains its source code.</span></span>

[!code-csharp[Executable launched by Process.Start](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/write500lines.cs)]
[!code-vb[Executable launched by Process.Start](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/write500lines.vb)]

<span data-ttu-id="970a2-1030">下面的示例演示如何从重定向的错误流中读取并等待子进程退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-1030">The following example shows how to read from a redirected error stream and wait for the child process to exit.</span></span> <span data-ttu-id="970a2-1031">它通过在 `p.WaitForExit`之前调用 `p.StandardError.ReadToEnd` 来避免死锁情况。</span><span class="sxs-lookup"><span data-stu-id="970a2-1031">It avoids a deadlock condition by calling `p.StandardError.ReadToEnd` before `p.WaitForExit`.</span></span> <span data-ttu-id="970a2-1032">如果父进程在 `p.StandardError.ReadToEnd` 之前调用了 `p.WaitForExit`，并且子进程写入足够多的文本以填充重定向的流，则会导致死锁情况。</span><span class="sxs-lookup"><span data-stu-id="970a2-1032">A deadlock condition can result if the parent process calls `p.WaitForExit` before `p.StandardError.ReadToEnd` and the child process writes enough text to fill the redirected stream.</span></span> <span data-ttu-id="970a2-1033">父进程会无限期地等待子进程退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-1033">The parent process would wait indefinitely for the child process to exit.</span></span> <span data-ttu-id="970a2-1034">子进程会无限期地等待父进程从完整的 <xref:System.Diagnostics.Process.StandardError%2A> 流中读取。</span><span class="sxs-lookup"><span data-stu-id="970a2-1034">The child process would wait indefinitely for the parent to read from the full <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>   

[!code-csharp[Reading from the error stream](~/samples/snippets/csharp/api/system.diagnostics/process/standarderror/stderror-sync.cs)]
[!code-vb[Reading from the error stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standarderror/stderror-sync.vb)]  

<span data-ttu-id="970a2-1035">从标准输出和标准错误流中读取所有文本时，会出现类似的问题。</span><span class="sxs-lookup"><span data-stu-id="970a2-1035">There is a similar issue when you read all text from both the standard output and standard error streams.</span></span> <span data-ttu-id="970a2-1036">下面的示例对两个流执行读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-1036">The following example performs a read operation on both streams.</span></span> <span data-ttu-id="970a2-1037">它通过对 <xref:System.Diagnostics.Process.StandardError%2A> 流执行异步读取操作来避免死锁情况。</span><span class="sxs-lookup"><span data-stu-id="970a2-1037">It avoids the deadlock condition by performing asynchronous read operations on the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span> <span data-ttu-id="970a2-1038">如果父进程调用 `p.StandardOutput.ReadToEnd` 后跟 `p.StandardError.ReadToEnd` 并且子进程写入足够多的文本以填充其错误流，则会导致死锁情况。</span><span class="sxs-lookup"><span data-stu-id="970a2-1038">A deadlock condition results if the parent process calls `p.StandardOutput.ReadToEnd` followed by `p.StandardError.ReadToEnd` and the child process writes enough text to fill its error stream.</span></span> <span data-ttu-id="970a2-1039">父进程会无限期地等待子进程关闭其 <xref:System.Diagnostics.Process.StandardOutput%2A> 流。</span><span class="sxs-lookup"><span data-stu-id="970a2-1039">The parent process would wait indefinitely for the child process to close its <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="970a2-1040">子进程会无限期地等待父进程从完整的 <xref:System.Diagnostics.Process.StandardError%2A> 流中读取。</span><span class="sxs-lookup"><span data-stu-id="970a2-1040">The child process would wait indefinitely for the parent to read from the full <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
[!code-csharp[Reading from both streams](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-async.cs)]
[!code-vb[Reading from both streams](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-async.vb)]  

<span data-ttu-id="970a2-1041">您可以使用异步读取操作来避免这些依赖项及其死锁。</span><span class="sxs-lookup"><span data-stu-id="970a2-1041">You can use asynchronous read operations to avoid these dependencies and their deadlock potential.</span></span> <span data-ttu-id="970a2-1042">或者，您可以通过创建两个线程并在单独的线程上读取每个流的输出来避免出现死锁情况。</span><span class="sxs-lookup"><span data-stu-id="970a2-1042">Alternately, you can avoid the deadlock condition by creating two threads and reading the output of each stream on a separate thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-1043">不能对重定向的流混合使用异步和同步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-1043">You cannot mix asynchronous and synchronous read operations on a redirected stream.</span></span> <span data-ttu-id="970a2-1044">在异步或同步模式下打开 <xref:System.Diagnostics.Process> 的重定向流后，对该流进行的所有进一步读取操作都必须处于相同的模式下。</span><span class="sxs-lookup"><span data-stu-id="970a2-1044">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="970a2-1045">例如，不要在 <xref:System.Diagnostics.Process.StandardError%2A> 流的 <xref:System.IO.StreamReader.ReadLine%2A> 调用 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>，反之亦然。</span><span class="sxs-lookup"><span data-stu-id="970a2-1045">For example, do not follow <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> with a call to <xref:System.IO.StreamReader.ReadLine%2A> on the <xref:System.Diagnostics.Process.StandardError%2A> stream, or vice versa.</span></span> <span data-ttu-id="970a2-1046">但是，可以在不同模式下读取两个不同的流。</span><span class="sxs-lookup"><span data-stu-id="970a2-1046">However, you can read two different streams in different modes.</span></span> <span data-ttu-id="970a2-1047">例如，可以调用 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，然后调用 <xref:System.Diagnostics.Process.StandardError%2A> 流的 <xref:System.IO.StreamReader.ReadLine%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-1047">For example, you can call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> and then call <xref:System.IO.StreamReader.ReadLine%2A> for the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-1048">下面的示例将 `net use` 命令与用户提供的参数一起使用，以映射网络资源。</span><span class="sxs-lookup"><span data-stu-id="970a2-1048">The following example uses the `net use` command together with a user supplied argument to map a network resource.</span></span> <span data-ttu-id="970a2-1049">然后，它读取 net 命令的标准错误流并将其写入控制台。</span><span class="sxs-lookup"><span data-stu-id="970a2-1049">It then reads the standard error stream of the net command and writes it to console.</span></span>  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-1050">尚未对 <see cref="P:System.Diagnostics.Process.StandardError" /> 流进行重定向定义；请确保 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 设置为 <see langword="true" /> 且 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 设置为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-1050">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has not been defined for redirection; ensure <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> is set to <see langword="true" /> and <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> is set to <see langword="false" />.</span></span>  
  
<span data-ttu-id="970a2-1051">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-1051">-or-</span></span> 
<span data-ttu-id="970a2-1052">已打开 <see cref="P:System.Diagnostics.Process.StandardError" /> 流，以使用 <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" /> 进行异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-1052">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has been opened for asynchronous read operations with <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" />.</span></span></exception>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardInput : System.IO.StreamWriter" Usage="System.Diagnostics.Process.StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardInput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-1053">获取用于写入应用程序输入的流。</span><span class="sxs-lookup"><span data-stu-id="970a2-1053">Gets a stream used to write the input of the application.</span></span></summary>
        <value><span data-ttu-id="970a2-1054"><see cref="T:System.IO.StreamWriter" />，可用于写入应用程序的标准输入流。</span><span class="sxs-lookup"><span data-stu-id="970a2-1054">A <see cref="T:System.IO.StreamWriter" /> that can be used to write the standard input stream of the application.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-1055"><xref:System.Diagnostics.Process> 可以从其标准输入流（通常是键盘）读取输入文本。</span><span class="sxs-lookup"><span data-stu-id="970a2-1055">A <xref:System.Diagnostics.Process> can read input text from its standard input stream, typically the keyboard.</span></span> <span data-ttu-id="970a2-1056">通过重定向 <xref:System.Diagnostics.Process.StandardInput%2A> 流，你可以通过编程方式指定输入。</span><span class="sxs-lookup"><span data-stu-id="970a2-1056">By redirecting the <xref:System.Diagnostics.Process.StandardInput%2A> stream, you can programmatically specify the input.</span></span> <span data-ttu-id="970a2-1057">例如，可以从指定文件的内容或其他应用程序的输出中提供文本，而不使用键盘输入。</span><span class="sxs-lookup"><span data-stu-id="970a2-1057">For example, instead of using keyboard input, you can provide text from the contents of a designated file or output from another application.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-1058">若要使用 <xref:System.Diagnostics.Process.StandardInput%2A>，你必须将 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> 设置为 `false`，并且必须将 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType> 设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="970a2-1058">To use <xref:System.Diagnostics.Process.StandardInput%2A>, you must set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> to `false`, and you must set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType> to `true`.</span></span> <span data-ttu-id="970a2-1059">否则，写入 <xref:System.Diagnostics.Process.StandardInput%2A> 流时将引发异常。</span><span class="sxs-lookup"><span data-stu-id="970a2-1059">Otherwise, writing to the <xref:System.Diagnostics.Process.StandardInput%2A> stream throws an exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-1060">下面的示例演示如何重定向进程的 <xref:System.Diagnostics.Process.StandardInput%2A> 流。</span><span class="sxs-lookup"><span data-stu-id="970a2-1060">The following example illustrates how to redirect the <xref:System.Diagnostics.Process.StandardInput%2A> stream of a process.</span></span> <span data-ttu-id="970a2-1061">该示例通过重定向的输入启动 `sort` 命令。</span><span class="sxs-lookup"><span data-stu-id="970a2-1061">The example starts the `sort` command with redirected input.</span></span> <span data-ttu-id="970a2-1062">然后，它会提示用户输入文本，并通过重定向的 <xref:System.Diagnostics.Process.StandardInput%2A> 流将其传递到 `sort` 进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1062">It then prompts the user for text, and passes that to the `sort` process by means of the redirected <xref:System.Diagnostics.Process.StandardInput%2A> stream.</span></span> <span data-ttu-id="970a2-1063">`sort` 结果在控制台上显示给用户。</span><span class="sxs-lookup"><span data-stu-id="970a2-1063">The `sort` results are displayed to the user on the console.</span></span>  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-1064"><see cref="P:System.Diagnostics.Process.StandardInput" /> 流尚未定义，因为 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> 设置为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-1064">The <see cref="P:System.Diagnostics.Process.StandardInput" /> stream has not been defined because <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> is set to <see langword="false" />.</span></span></exception>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutput : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardOutput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-1065">获取用于读取应用程序文本输出的流。</span><span class="sxs-lookup"><span data-stu-id="970a2-1065">Gets a stream used to read the textual output of the application.</span></span></summary>
        <value><span data-ttu-id="970a2-1066"><see cref="T:System.IO.StreamReader" />，可用于读取应用程序的标准输出流。</span><span class="sxs-lookup"><span data-stu-id="970a2-1066">A <see cref="T:System.IO.StreamReader" /> that can be used to read the standard output stream of the application.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-1067">当 <xref:System.Diagnostics.Process> 将文本写入其标准流时，该文本通常会显示在控制台上。</span><span class="sxs-lookup"><span data-stu-id="970a2-1067">When a <xref:System.Diagnostics.Process> writes text to its standard stream, that text is normally displayed on the console.</span></span> <span data-ttu-id="970a2-1068">通过重定向 <xref:System.Diagnostics.Process.StandardOutput%2A> 流，你可以操作或取消进程的输出。</span><span class="sxs-lookup"><span data-stu-id="970a2-1068">By redirecting the <xref:System.Diagnostics.Process.StandardOutput%2A> stream, you can manipulate or suppress the output of a process.</span></span> <span data-ttu-id="970a2-1069">例如，你可以筛选文本，以不同的方式对其进行格式设置，或者将输出写入控制台和指定的日志文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1069">For example, you can filter the text, format it differently, or write the output to both the console and a designated log file.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-1070">若要使用 <xref:System.Diagnostics.Process.StandardOutput%2A>，你必须将 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> 设置为 `false`，并且必须将 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType> 设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="970a2-1070">To use <xref:System.Diagnostics.Process.StandardOutput%2A>, you must set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> to `false`, and you must set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType> to `true`.</span></span> <span data-ttu-id="970a2-1071">否则，从 <xref:System.Diagnostics.Process.StandardOutput%2A> 流中读取会引发异常。</span><span class="sxs-lookup"><span data-stu-id="970a2-1071">Otherwise, reading from the <xref:System.Diagnostics.Process.StandardOutput%2A> stream throws an exception.</span></span>  
  
 <span data-ttu-id="970a2-1072">重定向的 <xref:System.Diagnostics.Process.StandardOutput%2A> 流可以同步或异步读取。</span><span class="sxs-lookup"><span data-stu-id="970a2-1072">The redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream can be read synchronously or asynchronously.</span></span> <span data-ttu-id="970a2-1073"><xref:System.IO.StreamReader.Read%2A>、<xref:System.IO.StreamReader.ReadLine%2A>和 <xref:System.IO.StreamReader.ReadToEnd%2A> 等方法在进程的输出流上执行同步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-1073">Methods such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, and <xref:System.IO.StreamReader.ReadToEnd%2A> perform synchronous read operations on the output stream of the process.</span></span> <span data-ttu-id="970a2-1074">在关联的 <xref:System.Diagnostics.Process> 写入其 <xref:System.Diagnostics.Process.StandardOutput%2A> 流或关闭流之前，这些同步读取操作不会完成。</span><span class="sxs-lookup"><span data-stu-id="970a2-1074">These synchronous read operations do not complete until the associated <xref:System.Diagnostics.Process> writes to its <xref:System.Diagnostics.Process.StandardOutput%2A> stream, or closes the stream.</span></span>  
  
 <span data-ttu-id="970a2-1075">与此相反，<xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 会对 <xref:System.Diagnostics.Process.StandardOutput%2A> 流启动异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-1075">In contrast, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> starts asynchronous read operations on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="970a2-1076">此方法将为流输出启用指定的事件处理程序，并立即返回到调用方，当流输出定向到事件处理程序时，该处理程序可以执行其他操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-1076">This method enables a designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</span></span>  
  
 <span data-ttu-id="970a2-1077">同步读取操作会在调用方之间引入依赖关系，从 <xref:System.Diagnostics.Process.StandardOutput%2A> 流读取，子进程写入该流。</span><span class="sxs-lookup"><span data-stu-id="970a2-1077">Synchronous read operations introduce a dependency between the caller reading from the <xref:System.Diagnostics.Process.StandardOutput%2A> stream and the child process writing to that stream.</span></span> <span data-ttu-id="970a2-1078">这些依赖项可能会导致死锁情况。</span><span class="sxs-lookup"><span data-stu-id="970a2-1078">These dependencies can result in deadlock conditions.</span></span> <span data-ttu-id="970a2-1079">当调用方从子进程的重定向流中进行读取时，它依赖于子进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1079">When the caller reads from the redirected stream of a child process, it is dependent on the child.</span></span> <span data-ttu-id="970a2-1080">调用方等待读取操作，直到子级写入流或关闭流为止。</span><span class="sxs-lookup"><span data-stu-id="970a2-1080">The caller waits on the read operation until the child writes to the stream or closes the stream.</span></span> <span data-ttu-id="970a2-1081">当子进程写入足够的数据以填充其重定向流时，它依赖于父进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1081">When the child process writes enough data to fill its redirected stream, it is dependent on the parent.</span></span> <span data-ttu-id="970a2-1082">子进程将在下一次写入操作之前等待，直到父进程从整个流中读取或关闭流为止。</span><span class="sxs-lookup"><span data-stu-id="970a2-1082">The child process waits on the next write operation until the parent reads from the full stream or closes the stream.</span></span> <span data-ttu-id="970a2-1083">当调用方和子进程等待彼此完成操作时，会发生死锁条件，并且这两个情况都无法继续。</span><span class="sxs-lookup"><span data-stu-id="970a2-1083">The deadlock condition results when the caller and child process wait on each other to complete an operation, and neither can proceed.</span></span> <span data-ttu-id="970a2-1084">您可以通过计算调用方和子进程之间的依赖关系来避免死锁。</span><span class="sxs-lookup"><span data-stu-id="970a2-1084">You can avoid deadlocks by evaluating dependencies between the caller and child process.</span></span>  

<span data-ttu-id="970a2-1085">本节中的最后两个示例使用 <xref:System.Diagnostics.Process.Start%2A> 方法来启动一个名为*Write500Lines*的可执行文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1085">The last two examples in this section use the <xref:System.Diagnostics.Process.Start%2A> method to launch an executable named *Write500Lines.exe*.</span></span> <span data-ttu-id="970a2-1086">下面的示例包含它的源代码。</span><span class="sxs-lookup"><span data-stu-id="970a2-1086">The following example contains its source code.</span></span>

[!code-csharp[Executable launched by Process.Start](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/write500lines.cs)]
[!code-vb[Executable launched by Process.Start](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/write500lines.vb)]

<span data-ttu-id="970a2-1087">下面的示例演示如何从重定向流中读取并等待子进程退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-1087">The following example shows how to read from a redirected stream and wait for the child process to exit.</span></span> <span data-ttu-id="970a2-1088">该示例通过在 `p.WaitForExit`之前调用 `p.StandardOutput.ReadToEnd` 来避免死锁情况。</span><span class="sxs-lookup"><span data-stu-id="970a2-1088">The example avoids a deadlock condition by calling `p.StandardOutput.ReadToEnd` before `p.WaitForExit`.</span></span> <span data-ttu-id="970a2-1089">如果父进程在 `p.StandardOutput.ReadToEnd` 之前调用了 `p.WaitForExit`，并且子进程写入足够多的文本以填充重定向的流，则会导致死锁情况。</span><span class="sxs-lookup"><span data-stu-id="970a2-1089">A deadlock condition can result if the parent process calls `p.WaitForExit` before `p.StandardOutput.ReadToEnd` and the child process writes enough text to fill the redirected stream.</span></span> <span data-ttu-id="970a2-1090">父进程会无限期地等待子进程退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-1090">The parent process would wait indefinitely for the child process to exit.</span></span> <span data-ttu-id="970a2-1091">子进程会无限期地等待父进程从完整的 <xref:System.Diagnostics.Process.StandardOutput%2A> 流中读取。</span><span class="sxs-lookup"><span data-stu-id="970a2-1091">The child process would wait indefinitely for the parent to read from the full <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span>  

[!code-csharp[Reading synchronously from a redirected output stream](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-sync.cs)]  
[!code-vb[Reading synchronously from a redirected output stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-sync.vb)]  

<span data-ttu-id="970a2-1092">从标准输出和标准错误流中读取所有文本时，会出现类似的问题。</span><span class="sxs-lookup"><span data-stu-id="970a2-1092">There is a similar issue when you read all text from both the standard output and standard error streams.</span></span> <span data-ttu-id="970a2-1093">下面的示例对两个流执行读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-1093">The following example performs a read operation on both streams.</span></span> <span data-ttu-id="970a2-1094">它通过对 <xref:System.Diagnostics.Process.StandardError%2A> 流执行异步读取操作来避免死锁情况。</span><span class="sxs-lookup"><span data-stu-id="970a2-1094">It avoids the deadlock condition by performing asynchronous read operations on the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span> <span data-ttu-id="970a2-1095">如果父进程调用 `p.StandardOutput.ReadToEnd` 后跟 `p.StandardError.ReadToEnd` 并且子进程写入足够多的文本以填充其错误流，则会导致死锁情况。</span><span class="sxs-lookup"><span data-stu-id="970a2-1095">A deadlock condition results if the parent process calls `p.StandardOutput.ReadToEnd` followed by `p.StandardError.ReadToEnd` and the child process writes enough text to fill its error stream.</span></span> <span data-ttu-id="970a2-1096">父进程会无限期地等待子进程关闭其 <xref:System.Diagnostics.Process.StandardOutput%2A> 流。</span><span class="sxs-lookup"><span data-stu-id="970a2-1096">The parent process would wait indefinitely for the child process to close its <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="970a2-1097">子进程会无限期地等待父进程从完整的 <xref:System.Diagnostics.Process.StandardError%2A> 流中读取。</span><span class="sxs-lookup"><span data-stu-id="970a2-1097">The child process would wait indefinitely for the parent to read from the full <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>   
[!code-csharp[Reading from a redirected output and error stream](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-async.cs)]  
[!code-vb[Reading from a redirected output and error stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-async.vb)]    
  
 <span data-ttu-id="970a2-1098">您可以使用异步读取操作来避免这些依赖项及其死锁。</span><span class="sxs-lookup"><span data-stu-id="970a2-1098">You can use asynchronous read operations to avoid these dependencies and their deadlock potential.</span></span> <span data-ttu-id="970a2-1099">或者，您可以通过创建两个线程并在单独的线程上读取每个流的输出来避免出现死锁情况。</span><span class="sxs-lookup"><span data-stu-id="970a2-1099">Alternately, you can avoid the deadlock condition by creating two threads and reading the output of each stream on a separate thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-1100">不能对重定向的流混合使用异步和同步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-1100">You cannot mix asynchronous and synchronous read operations on a redirected stream.</span></span> <span data-ttu-id="970a2-1101">在异步或同步模式下打开 <xref:System.Diagnostics.Process> 的重定向流后，对该流进行的所有进一步读取操作都必须处于相同的模式下。</span><span class="sxs-lookup"><span data-stu-id="970a2-1101">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="970a2-1102">例如，不要在 <xref:System.Diagnostics.Process.StandardOutput%2A> 流的 <xref:System.IO.StreamReader.ReadLine%2A> 调用 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，反之亦然。</span><span class="sxs-lookup"><span data-stu-id="970a2-1102">For example, do not follow <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> with a call to <xref:System.IO.StreamReader.ReadLine%2A> on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream, or vice versa.</span></span> <span data-ttu-id="970a2-1103">但是，可以在不同模式下读取两个不同的流。</span><span class="sxs-lookup"><span data-stu-id="970a2-1103">However, you can read two different streams in different modes.</span></span> <span data-ttu-id="970a2-1104">例如，可以调用 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，然后调用 <xref:System.Diagnostics.Process.StandardError%2A> 流的 <xref:System.IO.StreamReader.ReadLine%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-1104">For example, you can call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> and then call <xref:System.IO.StreamReader.ReadLine%2A> for the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-1105">下面的示例运行 ipconfig 命令，并将其标准输出重定向到该示例的控制台窗口。</span><span class="sxs-lookup"><span data-stu-id="970a2-1105">The following example runs the ipconfig.exe command and redirects its standard output to the example's console window.</span></span>  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-1106">尚未对 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 流进行重定向定义；请确保 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 设置为 <see langword="true" /> 且 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 设置为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-1106">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has not been defined for redirection; ensure <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> is set to <see langword="true" /> and <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> is set to <see langword="false" />.</span></span>  
  
<span data-ttu-id="970a2-1107">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-1107">-or-</span></span> 
<span data-ttu-id="970a2-1108">已打开 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 流，以使用 <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" /> 进行异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-1108">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has been opened for asynchronous read operations with <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" />.</span></span></exception>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="970a2-1109">启动进程资源并将其与 <see cref="T:System.Diagnostics.Process" /> 组件关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-1109">Starts a process resource and associates it with a <see cref="T:System.Diagnostics.Process" /> component.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; bool" Usage="process.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="970a2-1110">启动(或重用)此 <see cref="T:System.Diagnostics.Process" /> 组件的 <see cref="P:System.Diagnostics.Process.StartInfo" /> 属性指定的进程资源，并将其与该组件关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-1110">Starts (or reuses) the process resource that is specified by the <see cref="P:System.Diagnostics.Process.StartInfo" /> property of this <see cref="T:System.Diagnostics.Process" /> component and associates it with the component.</span></span></summary>
        <returns><span data-ttu-id="970a2-1111">如果启动了进程资源，则为 <see langword="true" />；如果没有启动新的进程资源(例如，如果重用了现有进程)，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-1111"><see langword="true" /> if a process resource is started; <see langword="false" /> if no new process resource is started (for example, if an existing process is reused).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-1112">使用此重载来启动进程资源，并将其与当前 <xref:System.Diagnostics.Process> 组件相关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-1112">Use this overload to start a process resource and associate it with the current <xref:System.Diagnostics.Process> component.</span></span> <span data-ttu-id="970a2-1113">返回值 `true` 指示已启动新的进程资源。</span><span class="sxs-lookup"><span data-stu-id="970a2-1113">The return value `true` indicates that a new process resource was started.</span></span> <span data-ttu-id="970a2-1114">如果 <xref:System.Diagnostics.Process.StartInfo%2A> 属性的 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 成员指定的进程资源已在计算机上运行，则不会启动其他进程资源。</span><span class="sxs-lookup"><span data-stu-id="970a2-1114">If the process resource specified by the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property is already running on the computer, no additional process resource is started.</span></span> <span data-ttu-id="970a2-1115">相反，将重用正在运行的进程资源并返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="970a2-1115">Instead, the running process resource is reused and `false` is returned.</span></span>  
  
 <span data-ttu-id="970a2-1116">可以通过指定最初安装应用程序的位置（例如，Web 地址）来启动 ClickOnce 应用程序。</span><span class="sxs-lookup"><span data-stu-id="970a2-1116">You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application.</span></span> <span data-ttu-id="970a2-1117">不要通过在硬盘驱动器上指定其安装位置来启动 ClickOnce 应用程序。</span><span class="sxs-lookup"><span data-stu-id="970a2-1117">Do not start a ClickOnce application by specifying its installed location on your hard drive.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-1118">如果使用的是 Visual Studio，则 <xref:System.Diagnostics.Process.Start%2A> 方法的重载是在将 <xref:System.Diagnostics.Process> 组件拖到设计器上后插入代码中的方法。</span><span class="sxs-lookup"><span data-stu-id="970a2-1118">If you are using Visual Studio, this overload of the <xref:System.Diagnostics.Process.Start%2A> method is the one that you insert into your code after you drag a <xref:System.Diagnostics.Process> component onto the designer.</span></span> <span data-ttu-id="970a2-1119">使用 "`Properties`" 窗口展开 "`StartInfo`" 类别，并将适当的值写入 `FileName` 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-1119">Use the `Properties` window to expand the `StartInfo` category and write the appropriate value into the `FileName` property.</span></span> <span data-ttu-id="970a2-1120">您所做的更改将显示在窗体的 `InitializeComponent` 过程中。</span><span class="sxs-lookup"><span data-stu-id="970a2-1120">Your changes will appear in the form's `InitializeComponent` procedure.</span></span>  
  
 <span data-ttu-id="970a2-1121"><xref:System.Diagnostics.Process.Start%2A> 的此重载不是 `static` 方法。</span><span class="sxs-lookup"><span data-stu-id="970a2-1121">This overload of <xref:System.Diagnostics.Process.Start%2A> is not a `static` method.</span></span> <span data-ttu-id="970a2-1122">必须从 <xref:System.Diagnostics.Process> 类的实例调用它。</span><span class="sxs-lookup"><span data-stu-id="970a2-1122">You must call it from an instance of the <xref:System.Diagnostics.Process> class.</span></span> <span data-ttu-id="970a2-1123">在调用 <xref:System.Diagnostics.Process.Start%2A>之前，必须先为此 <xref:System.Diagnostics.Process> 实例指定 <xref:System.Diagnostics.Process.StartInfo%2A> 属性信息，因为该信息用于确定要启动的进程资源。</span><span class="sxs-lookup"><span data-stu-id="970a2-1123">Before calling <xref:System.Diagnostics.Process.Start%2A>, you must first specify <xref:System.Diagnostics.Process.StartInfo%2A> property information for this <xref:System.Diagnostics.Process> instance, because that information is used to determine the process resource to start.</span></span>  
  
 <span data-ttu-id="970a2-1124"><xref:System.Diagnostics.Process.Start%2A> 方法的其他重载 `static` 成员。</span><span class="sxs-lookup"><span data-stu-id="970a2-1124">The other overloads of the <xref:System.Diagnostics.Process.Start%2A> method are `static` members.</span></span> <span data-ttu-id="970a2-1125">在调用方法的重载之前，无需创建 <xref:System.Diagnostics.Process> 组件的实例。</span><span class="sxs-lookup"><span data-stu-id="970a2-1125">You do not need to create an instance of the <xref:System.Diagnostics.Process> component before you call those overloads of the method.</span></span> <span data-ttu-id="970a2-1126">相反，你可以为 <xref:System.Diagnostics.Process> 类本身调用 <xref:System.Diagnostics.Process.Start%2A>，并在进程启动时创建新的 <xref:System.Diagnostics.Process> 组件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1126">Instead, you can call <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> class itself, and a new <xref:System.Diagnostics.Process> component is created if the process was started.</span></span> <span data-ttu-id="970a2-1127">或者，如果重复使用进程，则返回 `null`。</span><span class="sxs-lookup"><span data-stu-id="970a2-1127">Or, `null` is returned if a process was reused.</span></span> <span data-ttu-id="970a2-1128">进程资源与 <xref:System.Diagnostics.Process.Start%2A> 方法返回的新 <xref:System.Diagnostics.Process> 组件自动关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-1128">The process resource is automatically associated with the new <xref:System.Diagnostics.Process> component that is returned by the <xref:System.Diagnostics.Process.Start%2A> method.</span></span>  
  
 <span data-ttu-id="970a2-1129"><xref:System.Diagnostics.Process.StartInfo%2A> 成员可用于复制 Windows `Start` 菜单的 "`Run`" 对话框的功能。</span><span class="sxs-lookup"><span data-stu-id="970a2-1129">The <xref:System.Diagnostics.Process.StartInfo%2A> members can be used to duplicate the functionality of the `Run` dialog box of the Windows `Start` menu.</span></span> <span data-ttu-id="970a2-1130">可以通过在 "<xref:System.Diagnostics.Process.StartInfo%2A>" 属性中设置相应的值，来启动可键入到命令行中的任何内容。</span><span class="sxs-lookup"><span data-stu-id="970a2-1130">Anything that can be typed into a command line can be started by setting the appropriate values in the <xref:System.Diagnostics.Process.StartInfo%2A> property.</span></span> <span data-ttu-id="970a2-1131">唯一必须设置的 <xref:System.Diagnostics.Process.StartInfo%2A> 属性是 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-1131">The only <xref:System.Diagnostics.Process.StartInfo%2A> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property.</span></span> <span data-ttu-id="970a2-1132"><xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 属性不必是可执行文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1132">The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not have to be an executable file.</span></span> <span data-ttu-id="970a2-1133">它可以是其扩展插件与系统上安装的应用程序关联的任何文件类型。</span><span class="sxs-lookup"><span data-stu-id="970a2-1133">It can be of any file type for which the extension has been associated with an application that is installed on the system.</span></span> <span data-ttu-id="970a2-1134">例如，如果您已将文本文件与一个编辑器（如记事本）关联，则 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 属性可以具有 .txt 扩展名; 如果您已将 .doc 文件与 word 处理工具（如 Microsoft Word）关联，则它可能具有 .doc 扩展名。</span><span class="sxs-lookup"><span data-stu-id="970a2-1134">For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated .doc files with a word processing tool, such as Microsoft Word.</span></span>  
  
 <span data-ttu-id="970a2-1135">在命令行中，可以指定要对某些类型的文件执行的操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-1135">In the command line, you can specify actions to take for certain types of files.</span></span> <span data-ttu-id="970a2-1136">例如，可以打印文档或编辑文本文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1136">For example, you can print documents or edit text files.</span></span> <span data-ttu-id="970a2-1137">使用 <xref:System.Diagnostics.Process.StartInfo%2A> 属性的 <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> 成员指定这些操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-1137">Specify these actions using the <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property.</span></span> <span data-ttu-id="970a2-1138">对于其他类型的文件，您可以在从 "`Run`" 对话框启动文件时指定命令行参数。</span><span class="sxs-lookup"><span data-stu-id="970a2-1138">For other types of files, you can specify command-line arguments when you start the file from the `Run` dialog box.</span></span> <span data-ttu-id="970a2-1139">例如，如果将浏览器指定为 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>，则可以将 URL 作为参数传递。</span><span class="sxs-lookup"><span data-stu-id="970a2-1139">For example, you can pass a URL as an argument if you specify your browser as the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>.</span></span> <span data-ttu-id="970a2-1140">可以在 <xref:System.Diagnostics.Process.StartInfo%2A> 属性的 <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> 成员中指定这些参数。</span><span class="sxs-lookup"><span data-stu-id="970a2-1140">These arguments can be specified in the <xref:System.Diagnostics.Process.StartInfo%2A> property's <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> member.</span></span>  
  
 <span data-ttu-id="970a2-1141">如果在系统中使用引号声明了路径变量，则在启动在该位置找到的任何进程时必须完全限定该路径。</span><span class="sxs-lookup"><span data-stu-id="970a2-1141">If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location.</span></span> <span data-ttu-id="970a2-1142">否则，系统将找不到该路径。</span><span class="sxs-lookup"><span data-stu-id="970a2-1142">Otherwise, the system will not find the path.</span></span> <span data-ttu-id="970a2-1143">例如，如果 `c:\mypath` 不在你的路径中，而你使用引号添加它： `path = %path%;"c:\mypath"`，则在启动时必须完全限定 `c:\mypath` 中的任何进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1143">For example, if `c:\mypath` is not in your path, and you add it using quotation marks: `path = %path%;"c:\mypath"`, you must fully qualify any process in `c:\mypath` when starting it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-1144">ASP.NET 网页和服务器控制代码在 Web 服务器上的 ASP.NET 工作进程上下文中执行。</span><span class="sxs-lookup"><span data-stu-id="970a2-1144">ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.</span></span>  <span data-ttu-id="970a2-1145">如果在 ASP.NET 网页或服务器控件中使用 <xref:System.Diagnostics.Process.Start%2A> 方法，则新进程将在具有受限权限的 Web 服务器上执行。</span><span class="sxs-lookup"><span data-stu-id="970a2-1145">If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions.</span></span> <span data-ttu-id="970a2-1146">该进程不会在与客户端浏览器相同的上下文中启动，也不能访问用户桌面。</span><span class="sxs-lookup"><span data-stu-id="970a2-1146">The process does not start in the same context as the client browser, and does not have access to the user desktop.</span></span>  
  
 <span data-ttu-id="970a2-1147">无论何时使用 <xref:System.Diagnostics.Process.Start%2A> 来启动进程，都可能需要将其关闭或丢失系统资源。</span><span class="sxs-lookup"><span data-stu-id="970a2-1147">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="970a2-1148">使用 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 或 <xref:System.Diagnostics.Process.Kill%2A>关闭进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1148">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="970a2-1149">您可以使用其 <xref:System.Diagnostics.Process.HasExited%2A> 属性检查进程是否已关闭。</span><span class="sxs-lookup"><span data-stu-id="970a2-1149">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.</span></span>  
  
 <span data-ttu-id="970a2-1150">此处需要有关托管线程中的单元状态的说明。</span><span class="sxs-lookup"><span data-stu-id="970a2-1150">A note about apartment states in managed threads is necessary here.</span></span> <span data-ttu-id="970a2-1151">当在进程组件的 <xref:System.Diagnostics.Process.StartInfo%2A> 属性中 `true` <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 时，请确保已在应用程序上设置了线程模型，方法是在 `main()` 方法上设置属性 `[STAThread]`。</span><span class="sxs-lookup"><span data-stu-id="970a2-1151">When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method.</span></span> <span data-ttu-id="970a2-1152">否则，托管线程可以处于 `unknown` 状态或置于 `MTA` 状态，后者与 `true`的 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 发生冲突。</span><span class="sxs-lookup"><span data-stu-id="970a2-1152">Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`.</span></span> <span data-ttu-id="970a2-1153">某些方法要求单元状态不 `unknown`。</span><span class="sxs-lookup"><span data-stu-id="970a2-1153">Some methods require that the apartment state not be `unknown`.</span></span> <span data-ttu-id="970a2-1154">如果未显式设置该状态，则当应用程序遇到此类方法时，它默认为 `MTA`，一旦设置，将无法更改单元状态。</span><span class="sxs-lookup"><span data-stu-id="970a2-1154">If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed.</span></span> <span data-ttu-id="970a2-1155">但 `MTA` 会导致在操作系统 shell 管理线程时引发异常。</span><span class="sxs-lookup"><span data-stu-id="970a2-1155">However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-1156">下面的示例使用 <xref:System.Diagnostics.Process> 类的实例来启动进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1156">The following example uses an instance of the <xref:System.Diagnostics.Process> class to start a process.</span></span>  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-1157">在 <see cref="T:System.Diagnostics.Process" /> 组件的 <see cref="P:System.Diagnostics.Process.StartInfo" /> 中未指定任何文件名。</span><span class="sxs-lookup"><span data-stu-id="970a2-1157">No file name was specified in the <see cref="T:System.Diagnostics.Process" /> component's <see cref="P:System.Diagnostics.Process.StartInfo" />.</span></span>

<span data-ttu-id="970a2-1158">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-1158">-or-</span></span>

<span data-ttu-id="970a2-1159">当 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 、 <see cref="P:System.Diagnostics.Process.StartInfo" /> 或 <see langword="true" /> 的值为 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />时， <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />属性的 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 成员的值为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-1159">The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> member of the <see cref="P:System.Diagnostics.Process.StartInfo" /> property is <see langword="true" /> while <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />, or <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="970a2-1160">打开关联的文件时出错。</span><span class="sxs-lookup"><span data-stu-id="970a2-1160">There was an error in opening the associated file.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="970a2-1161">已释放此进程对象。</span><span class="sxs-lookup"><span data-stu-id="970a2-1161">The process object has already been disposed.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="970a2-1162">不支持 shell 的操作系统（如，仅适用于.NET Core 的 Nano Server）不支持此方法。</span><span class="sxs-lookup"><span data-stu-id="970a2-1162">Method not supported on operating systems without shell support such as Nano Server (.NET Core only).</span></span></exception>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberSignature Language="F#" Value="static member Start : System.Diagnostics.ProcessStartInfo -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start startInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo"><span data-ttu-id="970a2-1163"><see cref="T:System.Diagnostics.ProcessStartInfo" />，包含用于启动进程的信息(包括文件名和任何命令行参数)。</span><span class="sxs-lookup"><span data-stu-id="970a2-1163">The <see cref="T:System.Diagnostics.ProcessStartInfo" /> that contains the information that is used to start the process, including the file name and any command-line arguments.</span></span></param>
        <summary><span data-ttu-id="970a2-1164">启动由包含进程启动信息(例如，要启动的进程的文件名)的参数指定的进程资源，并将该资源与新的 <see cref="T:System.Diagnostics.Process" /> 组件关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-1164">Starts the process resource that is specified by the parameter containing process start information (for example, the file name of the process to start) and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</span></span></summary>
        <returns><span data-ttu-id="970a2-1165">与进程资源关联的新 <see cref="T:System.Diagnostics.Process" />，如果未启动进程资源，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-1165">A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started.</span></span> <span data-ttu-id="970a2-1166">请注意，伴随同一进程中已运行的实例而启动的新进程将独立于其他进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1166">Note that a new process that's started alongside already running instances of the same process will be independent from the others.</span></span> <span data-ttu-id="970a2-1167">此外，启动可能返回一个 <see cref="P:System.Diagnostics.Process.HasExited" /> 属性已设置为 <see langword="true" /> 的非 null 进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1167">In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />.</span></span> <span data-ttu-id="970a2-1168">在这种情况下，启动的进程可能已激活现有实例自身，然后退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-1168">In this case, the started process may have activated an existing instance of itself and then exited.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-1169">使用此重载通过指定 <xref:System.Diagnostics.ProcessStartInfo> 实例来启动进程资源。</span><span class="sxs-lookup"><span data-stu-id="970a2-1169">Use this overload to start a process resource by specifying a <xref:System.Diagnostics.ProcessStartInfo> instance.</span></span> <span data-ttu-id="970a2-1170">重载将资源与新的 <xref:System.Diagnostics.Process> 对象相关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-1170">The overload associates the resource with a new <xref:System.Diagnostics.Process> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-1171">如果要启动的可执行文件的地址是 URL，则该进程将不会启动，并且将返回 `null`。</span><span class="sxs-lookup"><span data-stu-id="970a2-1171">If the address of the executable file to start is a URL, the process is not started and `null` is returned.</span></span>  
  
 <span data-ttu-id="970a2-1172">此重载使你可以在不先创建新的 <xref:System.Diagnostics.Process> 实例的情况下启动进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1172">This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="970a2-1173">将此重载与 <xref:System.Diagnostics.ProcessStartInfo> 参数一起使用是创建新的 <xref:System.Diagnostics.Process> 实例、设置其 <xref:System.Diagnostics.Process.StartInfo%2A> 属性和调用 <xref:System.Diagnostics.Process> 实例的 <xref:System.Diagnostics.Process.Start%2A> 的显式步骤的替代方法。</span><span class="sxs-lookup"><span data-stu-id="970a2-1173">Using this overload with a <xref:System.Diagnostics.ProcessStartInfo> parameter is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting its <xref:System.Diagnostics.Process.StartInfo%2A> properties, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.</span></span>  
  
 <span data-ttu-id="970a2-1174">使用 <xref:System.Diagnostics.ProcessStartInfo> 实例作为参数，可以调用 <xref:System.Diagnostics.Process.Start%2A>，最大程度地控制传递到调用以启动进程的内容。</span><span class="sxs-lookup"><span data-stu-id="970a2-1174">Using a <xref:System.Diagnostics.ProcessStartInfo> instance as the parameter lets you call <xref:System.Diagnostics.Process.Start%2A> with the most control over what is passed into the call to start the process.</span></span> <span data-ttu-id="970a2-1175">如果需要只传递文件名或文件名和参数，则无需创建新的 <xref:System.Diagnostics.ProcessStartInfo> 实例，尽管这是一个选项。</span><span class="sxs-lookup"><span data-stu-id="970a2-1175">If you need to pass only a file name or a file name and arguments, it is not necessary to create a new <xref:System.Diagnostics.ProcessStartInfo> instance, although that is an option.</span></span> <span data-ttu-id="970a2-1176">唯一必须设置的 <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType> 属性是 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-1176">The only <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property.</span></span> <span data-ttu-id="970a2-1177"><xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 属性不需要表示可执行文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1177">The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not need to represent an executable file.</span></span> <span data-ttu-id="970a2-1178">它可以是其扩展插件与系统上安装的应用程序关联的任何文件类型。</span><span class="sxs-lookup"><span data-stu-id="970a2-1178">It can be of any file type for which the extension has been associated with an application that is installed on the system.</span></span> <span data-ttu-id="970a2-1179">例如，如果您已将文本文件与一个编辑器（如记事本）关联，则 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 属性可以具有 .txt 扩展名; 如果您已将 .doc 文件与 word 处理工具（如 Microsoft Word）关联，则它可能具有 .doc 扩展名。</span><span class="sxs-lookup"><span data-stu-id="970a2-1179">For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated .doc files with a word processing tool, such as Microsoft Word.</span></span>  
  
 <span data-ttu-id="970a2-1180">可以通过指定最初安装应用程序的位置（例如，Web 地址）来启动 ClickOnce 应用程序。</span><span class="sxs-lookup"><span data-stu-id="970a2-1180">You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application.</span></span> <span data-ttu-id="970a2-1181">不要通过在硬盘驱动器上指定其安装位置来启动 ClickOnce 应用程序。</span><span class="sxs-lookup"><span data-stu-id="970a2-1181">Do not start a ClickOnce application by specifying its installed location on your hard drive.</span></span>  
  
 <span data-ttu-id="970a2-1182">如果设置了 <xref:System.Diagnostics.Process.StartInfo%2A> 实例的 <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> 和 <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> 属性，则会调用非托管 `CreateProcessWithLogonW` 函数，这将在新窗口中启动该进程，即使 <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> 属性值 `true` 或 <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType> 属性值 <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>也是如此。</span><span class="sxs-lookup"><span data-stu-id="970a2-1182">If the <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> and <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> properties of the <xref:System.Diagnostics.Process.StartInfo%2A> instance are set, the unmanaged `CreateProcessWithLogonW` function is called, which starts the process in a new window even if the <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> property value is `true` or the <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType> property value is <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>.</span></span> <span data-ttu-id="970a2-1183">如果 `null`<xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType> 属性，<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> 属性必须为 UPN 格式，*用户*@*DNS_domain_name*。</span><span class="sxs-lookup"><span data-stu-id="970a2-1183">If the <xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType> property is `null`, the <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> property must be in UPN format, *user*@*DNS_domain_name*.</span></span>   
  
 <span data-ttu-id="970a2-1184">与其他重载不同，没有参数的 <xref:System.Diagnostics.Process.Start%2A> 的重载不是 `static` 成员。</span><span class="sxs-lookup"><span data-stu-id="970a2-1184">Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member.</span></span> <span data-ttu-id="970a2-1185">如果已创建 <xref:System.Diagnostics.Process> 实例和指定的开始信息（包括文件名），并且想要启动进程资源并将其与现有 <xref:System.Diagnostics.Process> 实例相关联，请使用此重载。</span><span class="sxs-lookup"><span data-stu-id="970a2-1185">Use that overload when you have already created a <xref:System.Diagnostics.Process> instance and specified start information (including the file name), and you want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="970a2-1186">若要创建新的 <xref:System.Diagnostics.Process> 组件，而不是为现有组件启动进程，请使用 `static` 重载之一。</span><span class="sxs-lookup"><span data-stu-id="970a2-1186">Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component.</span></span> <span data-ttu-id="970a2-1187">此重载和没有参数的重载都允许使用 <xref:System.Diagnostics.ProcessStartInfo> 实例指定进程资源的启动信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-1187">Both this overload and the overload that has no parameters allow you to specify the start information for the process resource by using a <xref:System.Diagnostics.ProcessStartInfo> instance.</span></span>  
  
 <span data-ttu-id="970a2-1188">如果在系统中使用引号声明了路径变量，则在启动在该位置找到的任何进程时必须完全限定该路径。</span><span class="sxs-lookup"><span data-stu-id="970a2-1188">If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location.</span></span> <span data-ttu-id="970a2-1189">否则，系统将找不到该路径。</span><span class="sxs-lookup"><span data-stu-id="970a2-1189">Otherwise, the system will not find the path.</span></span> <span data-ttu-id="970a2-1190">例如，如果 `c:\mypath` 不在你的路径中，而你使用引号添加它： `path = %path%;"c:\mypath"`，则在启动时必须完全限定 `c:\mypath` 中的任何进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1190">For example, if `c:\mypath` is not in your path, and you add it using quotation marks: `path = %path%;"c:\mypath"`, you must fully qualify any process in `c:\mypath` when starting it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-1191">ASP.NET 网页和服务器控制代码在 Web 服务器上的 ASP.NET 工作进程上下文中执行。</span><span class="sxs-lookup"><span data-stu-id="970a2-1191">ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.</span></span>  <span data-ttu-id="970a2-1192">如果在 ASP.NET 网页或服务器控件中使用 <xref:System.Diagnostics.Process.Start%2A> 方法，则新进程将在具有受限权限的 Web 服务器上执行。</span><span class="sxs-lookup"><span data-stu-id="970a2-1192">If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions.</span></span> <span data-ttu-id="970a2-1193">该进程不会在与客户端浏览器相同的上下文中启动，也不能访问用户桌面。</span><span class="sxs-lookup"><span data-stu-id="970a2-1193">The process does not start in the same context as the client browser, and does not have access to the user desktop.</span></span>  
  
 <span data-ttu-id="970a2-1194">无论何时使用 <xref:System.Diagnostics.Process.Start%2A> 来启动进程，都可能需要将其关闭或丢失系统资源。</span><span class="sxs-lookup"><span data-stu-id="970a2-1194">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="970a2-1195">使用 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 或 <xref:System.Diagnostics.Process.Kill%2A>关闭进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1195">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="970a2-1196">您可以使用其 <xref:System.Diagnostics.Process.HasExited%2A> 属性检查进程是否已关闭。</span><span class="sxs-lookup"><span data-stu-id="970a2-1196">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.</span></span>  
  
 <span data-ttu-id="970a2-1197">此处需要有关托管线程中的单元状态的说明。</span><span class="sxs-lookup"><span data-stu-id="970a2-1197">A note about apartment states in managed threads is necessary here.</span></span> <span data-ttu-id="970a2-1198">当 `true` `startInfo` 参数上 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 时，请确保已在应用程序上设置了线程模型，方法是在 `main()` 方法上设置属性 `[STAThread]`。</span><span class="sxs-lookup"><span data-stu-id="970a2-1198">When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the `startInfo` parameter, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method.</span></span> <span data-ttu-id="970a2-1199">否则，托管线程可以处于 `unknown` 状态或置于 `MTA` 状态，后者与 `true`的 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 发生冲突。</span><span class="sxs-lookup"><span data-stu-id="970a2-1199">Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`.</span></span> <span data-ttu-id="970a2-1200">某些方法要求单元状态不 `unknown`。</span><span class="sxs-lookup"><span data-stu-id="970a2-1200">Some methods require that the apartment state not be `unknown`.</span></span> <span data-ttu-id="970a2-1201">如果未显式设置该状态，则当应用程序遇到此类方法时，它默认为 `MTA`，一旦设置，将无法更改单元状态。</span><span class="sxs-lookup"><span data-stu-id="970a2-1201">If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed.</span></span> <span data-ttu-id="970a2-1202">但 `MTA` 会导致在操作系统 shell 管理线程时引发异常。</span><span class="sxs-lookup"><span data-stu-id="970a2-1202">However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-1203">下面的示例首先生成 Internet Explorer 的一个实例，并在浏览器中显示 "收藏夹" 文件夹的内容。</span><span class="sxs-lookup"><span data-stu-id="970a2-1203">The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser.</span></span> <span data-ttu-id="970a2-1204">然后，它将启动其他一些 Internet Explorer 实例，并显示某些特定页面或站点。</span><span class="sxs-lookup"><span data-stu-id="970a2-1204">It then starts some other instances of Internet Explorer and displays some specific pages or sites.</span></span> <span data-ttu-id="970a2-1205">最后，当导航到特定站点时，它会在窗口最小化时启动 Internet Explorer。</span><span class="sxs-lookup"><span data-stu-id="970a2-1205">Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.</span></span>  
  
 <span data-ttu-id="970a2-1206">有关此方法的其他用法的其他示例，请参阅 <xref:System.Diagnostics.ProcessStartInfo> 类的各个属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-1206">For additional examples of other uses of this method, refer to the individual properties of the <xref:System.Diagnostics.ProcessStartInfo> class.</span></span>  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-1207">在 <paramref name="startInfo" /> 参数的 <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> 属性中未指定任何文件名。</span><span class="sxs-lookup"><span data-stu-id="970a2-1207">No file name was specified in the <paramref name="startInfo" /> parameter's <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property.</span></span>  
  
<span data-ttu-id="970a2-1208">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-1208">-or-</span></span> 
<span data-ttu-id="970a2-1209"><paramref name="startInfo" /> 参数的 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 属性值为 <see langword="true" />，且 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 或 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 属性的值也为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-1209">The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property of the <paramref name="startInfo" /> parameter is <see langword="true" /> and the <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />, or <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> property is also <see langword="true" />.</span></span>  
  
<span data-ttu-id="970a2-1210">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-1210">-or-</span></span> 
<span data-ttu-id="970a2-1211"><paramref name="startInfo" /> 参数的 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 属性值为 <see langword="true" />，且 <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> 属性值不为 <see langword="null" /> 或空，或者 <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> 属性值不为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-1211">The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property of the <paramref name="startInfo" /> parameter is <see langword="true" /> and the <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> property is not <see langword="null" /> or empty or the <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> property is not <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="970a2-1212"><paramref name="startInfo" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-1212">The <paramref name="startInfo" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="970a2-1213">已释放此进程对象。</span><span class="sxs-lookup"><span data-stu-id="970a2-1213">The process object has already been disposed.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="970a2-1214">打开关联的文件时出错。</span><span class="sxs-lookup"><span data-stu-id="970a2-1214">An error occurred when opening the associated file.</span></span>  

<span data-ttu-id="970a2-1215">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-1215">-or-</span></span> 
<span data-ttu-id="970a2-1216">在 <paramref name="startInfo" /> 参数的 <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> 属性中指定的文件未找到。</span><span class="sxs-lookup"><span data-stu-id="970a2-1216">The file specified in the <paramref name="startInfo" /> parameter's <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property could not be found.</span></span>
          
<span data-ttu-id="970a2-1217">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-1217">-or-</span></span> 
<span data-ttu-id="970a2-1218">自变量的长度与该进程的完整路径的长度的总和超过了 2080。</span><span class="sxs-lookup"><span data-stu-id="970a2-1218">The sum of the length of the arguments and the length of the full path to the process exceeds 2080.</span></span> <span data-ttu-id="970a2-1219">与此异常关联的错误消息可以是下面其中一项：“传递给系统调用的数据区域太小。”</span><span class="sxs-lookup"><span data-stu-id="970a2-1219">The error message associated with this exception can be one of the following: "The data area passed to a system call is too small."</span></span> <span data-ttu-id="970a2-1220">或“拒绝访问。”</span><span class="sxs-lookup"><span data-stu-id="970a2-1220">or "Access is denied."</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="970a2-1221">不支持 shell 的操作系统（如，仅适用于.NET Core 的 Nano Server）不支持此方法。</span><span class="sxs-lookup"><span data-stu-id="970a2-1221">Method not supported on operating systems without shell support such as Nano Server (.NET Core only).</span></span></exception>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member Start : string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="970a2-1222">要在进程中运行的文档或应用程序文件的名称。</span><span class="sxs-lookup"><span data-stu-id="970a2-1222">The name of a document or application file to run in the process.</span></span></param>
        <summary><span data-ttu-id="970a2-1223">通过指定文档或应用程序文件的名称来启动进程资源，并将资源与新的 <see cref="T:System.Diagnostics.Process" /> 组件关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-1223">Starts a process resource by specifying the name of a document or application file and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</span></span></summary>
        <returns><span data-ttu-id="970a2-1224">与进程资源关联的新 <see cref="T:System.Diagnostics.Process" />，如果未启动进程资源，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-1224">A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started.</span></span> <span data-ttu-id="970a2-1225">请注意，伴随同一进程中已运行的实例而启动的新进程将独立于其他进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1225">Note that a new process that's started alongside already running instances of the same process will be independent from the others.</span></span> <span data-ttu-id="970a2-1226">此外，启动可能返回一个 <see cref="P:System.Diagnostics.Process.HasExited" /> 属性已设置为 <see langword="true" /> 的非 null 进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1226">In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />.</span></span> <span data-ttu-id="970a2-1227">在这种情况下，启动的进程可能已激活现有实例自身，然后退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-1227">In this case, the started process may have activated an existing instance of itself and then exited.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-1228">使用此重载通过指定进程资源的文件名来启动进程资源。</span><span class="sxs-lookup"><span data-stu-id="970a2-1228">Use this overload to start a process resource by specifying its file name.</span></span> <span data-ttu-id="970a2-1229">重载将资源与新的 <xref:System.Diagnostics.Process> 对象相关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-1229">The overload associates the resource with a new <xref:System.Diagnostics.Process> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-1230">如果要启动的可执行文件的地址是 URL，则该进程将不会启动，并且将返回 `null`。</span><span class="sxs-lookup"><span data-stu-id="970a2-1230">If the address of the executable file to start is a URL, the process is not started and `null` is returned.</span></span>  
  
 <span data-ttu-id="970a2-1231">此重载使你可以在不先创建新的 <xref:System.Diagnostics.Process> 实例的情况下启动进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1231">This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="970a2-1232">重载是一种替代方法，用于创建新的 <xref:System.Diagnostics.Process> 实例，设置 <xref:System.Diagnostics.Process.StartInfo%2A> 属性的 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 成员，并为 <xref:System.Diagnostics.Process> 实例调用 <xref:System.Diagnostics.Process.Start%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-1232">The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.</span></span>  
  
 <span data-ttu-id="970a2-1233">可以通过将 `fileName` 参数设置为最初安装应用程序的位置（例如，Web 地址）来启动 ClickOnce 应用程序。</span><span class="sxs-lookup"><span data-stu-id="970a2-1233">You can start a ClickOnce application by setting the `fileName` parameter to the location (for example, a Web address) from which you originally installed the application.</span></span> <span data-ttu-id="970a2-1234">不要通过在硬盘驱动器上指定其安装位置来启动 ClickOnce 应用程序。</span><span class="sxs-lookup"><span data-stu-id="970a2-1234">Do not start a ClickOnce application by specifying its installed location on your hard drive.</span></span>  
  
 <span data-ttu-id="970a2-1235">通过指定其文件名来启动进程类似于在 Windows `Start` 菜单的 "`Run`" 对话框中键入信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-1235">Starting a process by specifying its file name is similar to typing the information in the `Run` dialog box of the Windows `Start` menu.</span></span> <span data-ttu-id="970a2-1236">因此，文件名不需要表示可执行文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1236">Therefore, the file name does not need to represent an executable file.</span></span> <span data-ttu-id="970a2-1237">它可以是与系统上安装的应用程序关联的任何文件类型。</span><span class="sxs-lookup"><span data-stu-id="970a2-1237">It can be of any file type for which the extension has been associated with an application installed on the system.</span></span> <span data-ttu-id="970a2-1238">例如，如果您已将文本文件与一个编辑器（如记事本）关联，则文件名可以具有 .txt 扩展名; 如果您已将 .doc 文件与 word 处理工具（如 Microsoft Word）相关联，则它可能具有 .doc。</span><span class="sxs-lookup"><span data-stu-id="970a2-1238">For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated .doc files with a word processing tool, such as Microsoft Word.</span></span> <span data-ttu-id="970a2-1239">同样，在 `fileName` 参数中，.exe 扩展名是可选的，这与 `Run` 对话框可以接受带有或不带 .exe 扩展名的可执行文件名的方式相同。</span><span class="sxs-lookup"><span data-stu-id="970a2-1239">Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter.</span></span> <span data-ttu-id="970a2-1240">例如，可以将 `fileName` 参数设置为 "Notepad.exe" 或 "Notepad"。</span><span class="sxs-lookup"><span data-stu-id="970a2-1240">For example, you can set the `fileName` parameter to either "Notepad.exe" or "Notepad".</span></span>  
  
 <span data-ttu-id="970a2-1241">此重载不允许进程的命令行参数。</span><span class="sxs-lookup"><span data-stu-id="970a2-1241">This overload does not allow command-line arguments for the process.</span></span> <span data-ttu-id="970a2-1242">如果需要为进程指定一个或多个命令行参数，请使用 <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> 或 <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> 重载。</span><span class="sxs-lookup"><span data-stu-id="970a2-1242">If you need to specify one or more command-line arguments for the process, use the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> or <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> overloads.</span></span>  
  
 <span data-ttu-id="970a2-1243">与其他重载不同，没有参数的 <xref:System.Diagnostics.Process.Start%2A> 的重载不是 `static` 成员。</span><span class="sxs-lookup"><span data-stu-id="970a2-1243">Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member.</span></span> <span data-ttu-id="970a2-1244">如果已创建 <xref:System.Diagnostics.Process> 实例和指定的开始信息（包括文件名），并且想要启动进程资源并将其与现有 <xref:System.Diagnostics.Process> 实例相关联，请使用此重载。</span><span class="sxs-lookup"><span data-stu-id="970a2-1244">Use that overload when you have already created a <xref:System.Diagnostics.Process> instance and specified start information (including the file name), and you want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="970a2-1245">若要创建新的 <xref:System.Diagnostics.Process> 组件，而不是为现有组件启动进程，请使用 `static` 重载之一。</span><span class="sxs-lookup"><span data-stu-id="970a2-1245">Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component.</span></span> <span data-ttu-id="970a2-1246">此重载和没有参数的重载都允许您指定要启动的进程资源的文件名。</span><span class="sxs-lookup"><span data-stu-id="970a2-1246">Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start.</span></span>  
  
 <span data-ttu-id="970a2-1247">如果在系统中使用引号声明了路径变量，则在启动在该位置找到的任何进程时必须完全限定该路径。</span><span class="sxs-lookup"><span data-stu-id="970a2-1247">If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location.</span></span> <span data-ttu-id="970a2-1248">否则，系统将找不到该路径。</span><span class="sxs-lookup"><span data-stu-id="970a2-1248">Otherwise, the system will not find the path.</span></span> <span data-ttu-id="970a2-1249">例如，如果 `c:\mypath` 不在你的路径中，而你使用引号添加它： `path = %path%;"c:\mypath"`，则在启动时必须完全限定 `c:\mypath` 中的任何进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1249">For example, if `c:\mypath` is not in your path, and you add it using quotation marks: `path = %path%;"c:\mypath"`, you must fully qualify any process in `c:\mypath` when starting it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-1250">ASP.NET 网页和服务器控制代码在 Web 服务器上的 ASP.NET 工作进程上下文中执行。</span><span class="sxs-lookup"><span data-stu-id="970a2-1250">ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.</span></span>  <span data-ttu-id="970a2-1251">如果在 ASP.NET 网页或服务器控件中使用 <xref:System.Diagnostics.Process.Start%2A> 方法，则新进程将在具有受限权限的 Web 服务器上执行。</span><span class="sxs-lookup"><span data-stu-id="970a2-1251">If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions.</span></span> <span data-ttu-id="970a2-1252">该进程不会在与客户端浏览器相同的上下文中启动，也不能访问用户桌面。</span><span class="sxs-lookup"><span data-stu-id="970a2-1252">The process does not start in the same context as the client browser, and does not have access to the user desktop.</span></span>  
  
 <span data-ttu-id="970a2-1253">无论何时使用 <xref:System.Diagnostics.Process.Start%2A> 来启动进程，都可能需要将其关闭或丢失系统资源。</span><span class="sxs-lookup"><span data-stu-id="970a2-1253">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="970a2-1254">使用 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 或 <xref:System.Diagnostics.Process.Kill%2A>关闭进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1254">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="970a2-1255">您可以使用其 <xref:System.Diagnostics.Process.HasExited%2A> 属性检查进程是否已关闭。</span><span class="sxs-lookup"><span data-stu-id="970a2-1255">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.</span></span>  
  
 <span data-ttu-id="970a2-1256">此处需要有关托管线程中的单元状态的说明。</span><span class="sxs-lookup"><span data-stu-id="970a2-1256">A note about apartment states in managed threads is necessary here.</span></span> <span data-ttu-id="970a2-1257">当在进程组件的 <xref:System.Diagnostics.Process.StartInfo%2A> 属性中 `true` <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 时，请确保已在应用程序上设置了线程模型，方法是在 `main()` 方法上设置属性 `[STAThread]`。</span><span class="sxs-lookup"><span data-stu-id="970a2-1257">When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method.</span></span> <span data-ttu-id="970a2-1258">否则，托管线程可以处于 `unknown` 状态或置于 `MTA` 状态，后者与 `true`的 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 发生冲突。</span><span class="sxs-lookup"><span data-stu-id="970a2-1258">Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`.</span></span> <span data-ttu-id="970a2-1259">某些方法要求单元状态不 `unknown`。</span><span class="sxs-lookup"><span data-stu-id="970a2-1259">Some methods require that the apartment state not be `unknown`.</span></span> <span data-ttu-id="970a2-1260">如果未显式设置该状态，则当应用程序遇到此类方法时，它默认为 `MTA`，一旦设置，将无法更改单元状态。</span><span class="sxs-lookup"><span data-stu-id="970a2-1260">If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed.</span></span> <span data-ttu-id="970a2-1261">但 `MTA` 会导致在操作系统 shell 管理线程时引发异常。</span><span class="sxs-lookup"><span data-stu-id="970a2-1261">However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-1262">下面的示例首先生成 Internet Explorer 的一个实例，并在浏览器中显示 "收藏夹" 文件夹的内容。</span><span class="sxs-lookup"><span data-stu-id="970a2-1262">The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser.</span></span> <span data-ttu-id="970a2-1263">然后，它将启动其他一些 Internet Explorer 实例，并显示某些特定页面或站点。</span><span class="sxs-lookup"><span data-stu-id="970a2-1263">It then starts some other instances of Internet Explorer and displays some specific pages or sites.</span></span> <span data-ttu-id="970a2-1264">最后，当导航到特定站点时，它会在窗口最小化时启动 Internet Explorer。</span><span class="sxs-lookup"><span data-stu-id="970a2-1264">Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.</span></span>  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="970a2-1265">打开关联的文件时出错。</span><span class="sxs-lookup"><span data-stu-id="970a2-1265">An error occurred when opening the associated file.</span></span>

<span data-ttu-id="970a2-1266">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-1266">-or-</span></span>

<span data-ttu-id="970a2-1267">找不到 <paramref name="fileName" /> 中指定的文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1267">The file specified in the <paramref name="fileName" /> could not be found.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="970a2-1268">已释放此进程对象。</span><span class="sxs-lookup"><span data-stu-id="970a2-1268">The process object has already been disposed.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="970a2-1269">PATH 环境变量具有一个包含引号的字符串。</span><span class="sxs-lookup"><span data-stu-id="970a2-1269">The PATH environment variable has a string containing quotes.</span></span></exception>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Start : string * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="970a2-1270">要在进程中运行的应用程序文件的名称。</span><span class="sxs-lookup"><span data-stu-id="970a2-1270">The name of an application file to run in the process.</span></span></param>
        <param name="arguments"><span data-ttu-id="970a2-1271">启动该进程时传递的命令行参数。</span><span class="sxs-lookup"><span data-stu-id="970a2-1271">Command-line arguments to pass when starting the process.</span></span></param>
        <summary><span data-ttu-id="970a2-1272">通过指定应用程序的名称和一组命令行参数来启动一个进程资源，并将该资源与新的 <see cref="T:System.Diagnostics.Process" /> 组件相关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-1272">Starts a process resource by specifying the name of an application and a set of command-line arguments, and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</span></span></summary>
        <returns><span data-ttu-id="970a2-1273">与进程资源关联的新 <see cref="T:System.Diagnostics.Process" />，如果未启动进程资源，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-1273">A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started.</span></span> <span data-ttu-id="970a2-1274">请注意，伴随同一进程中已运行的实例而启动的新进程将独立于其他进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1274">Note that a new process that's started alongside already running instances of the same process will be independent from the others.</span></span> <span data-ttu-id="970a2-1275">此外，启动可能返回一个 <see cref="P:System.Diagnostics.Process.HasExited" /> 属性已设置为 <see langword="true" /> 的非 null 进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1275">In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />.</span></span> <span data-ttu-id="970a2-1276">在这种情况下，启动的进程可能已激活现有实例自身，然后退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-1276">In this case, the started process may have activated an existing instance of itself and then exited.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-1277">使用此重载通过指定进程资源的文件名和命令行参数来启动进程资源。</span><span class="sxs-lookup"><span data-stu-id="970a2-1277">Use this overload to start a process resource by specifying its file name and command-line arguments.</span></span> <span data-ttu-id="970a2-1278">重载将资源与新的 <xref:System.Diagnostics.Process> 对象相关联。</span><span class="sxs-lookup"><span data-stu-id="970a2-1278">The overload associates the resource with a new <xref:System.Diagnostics.Process> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-1279">如果要启动的可执行文件的地址是 URL，则该进程将不会启动，并且将返回 `null`。</span><span class="sxs-lookup"><span data-stu-id="970a2-1279">If the address of the executable file to start is a URL, the process is not started and `null` is returned.</span></span>  
  
 <span data-ttu-id="970a2-1280">此重载使你可以在不先创建新的 <xref:System.Diagnostics.Process> 实例的情况下启动进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1280">This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="970a2-1281">重载是一种替代方法，用于创建新的 <xref:System.Diagnostics.Process> 实例、设置 <xref:System.Diagnostics.Process.StartInfo%2A> 属性的 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 和 <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> 成员以及调用 <xref:System.Diagnostics.Process.Start%2A> 实例的 <xref:System.Diagnostics.Process>。</span><span class="sxs-lookup"><span data-stu-id="970a2-1281">The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> members of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.</span></span>  
  
 <span data-ttu-id="970a2-1282">通过指定其文件名和参数启动进程类似于在 Windows `Start` 菜单的 "`Run`" 对话框中键入文件名和命令行参数。</span><span class="sxs-lookup"><span data-stu-id="970a2-1282">Starting a process by specifying its file name and arguments is similar to typing the file name and command-line arguments in the `Run` dialog box of the Windows `Start` menu.</span></span> <span data-ttu-id="970a2-1283">因此，文件名不需要表示可执行文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1283">Therefore, the file name does not need to represent an executable file.</span></span> <span data-ttu-id="970a2-1284">它可以是与系统上安装的应用程序关联的任何文件类型。</span><span class="sxs-lookup"><span data-stu-id="970a2-1284">It can be of any file type for which the extension has been associated with an application installed on the system.</span></span> <span data-ttu-id="970a2-1285">例如，如果您已将文本文件与一个编辑器（如记事本）关联，则文件名可以具有 .txt 扩展名; 如果您已将 .doc 文件与 word 处理工具（如 Microsoft Word）相关联，则它可能具有 .doc。</span><span class="sxs-lookup"><span data-stu-id="970a2-1285">For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated .doc files with a word processing tool, such as Microsoft Word.</span></span> <span data-ttu-id="970a2-1286">同样，在 `fileName` 参数中，.exe 扩展名是可选的，这与 `Run` 对话框可以接受带有或不带 .exe 扩展名的可执行文件名的方式相同。</span><span class="sxs-lookup"><span data-stu-id="970a2-1286">Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter.</span></span> <span data-ttu-id="970a2-1287">例如，可以将 `fileName` 参数设置为 "Notepad.exe" 或 "Notepad"。</span><span class="sxs-lookup"><span data-stu-id="970a2-1287">For example, you can set the `fileName` parameter to either "Notepad.exe" or "Notepad".</span></span> <span data-ttu-id="970a2-1288">如果 `fileName` 参数表示一个可执行文件，则 `arguments` 参数可能表示要对其执行操作的文件，如 `Notepad.exe myfile.txt`中的文本文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1288">If the `fileName` parameter represents an executable file, the `arguments` parameter might represent a file to act upon, such as the text file in `Notepad.exe myfile.txt`.</span></span> <span data-ttu-id="970a2-1289">如果 `fileName` 参数表示一个命令（.cmd）文件，则 `arguments` 参数必须包括一个 "`/c`" 或 "`/k`" 参数，以指定命令窗口是在完成后退出还是保留。</span><span class="sxs-lookup"><span data-stu-id="970a2-1289">If the `fileName` parameter represents a command (.cmd) file, the `arguments` parameter must include either a "`/c`" or "`/k`" argument to specify whether the command window exits or remains after completion.</span></span>  
  
 <span data-ttu-id="970a2-1290">与其他重载不同，没有参数的 <xref:System.Diagnostics.Process.Start%2A> 的重载不是 `static` 成员。</span><span class="sxs-lookup"><span data-stu-id="970a2-1290">Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member.</span></span> <span data-ttu-id="970a2-1291">如果已创建 <xref:System.Diagnostics.Process> 实例和指定的开始信息（包括文件名），并且想要启动进程资源并将其与现有 <xref:System.Diagnostics.Process> 实例相关联，请使用此重载。</span><span class="sxs-lookup"><span data-stu-id="970a2-1291">Use that overload when you have already created a <xref:System.Diagnostics.Process> instance and specified start information (including the file name), and you want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="970a2-1292">若要创建新的 <xref:System.Diagnostics.Process> 组件，而不是为现有组件启动进程，请使用 `static` 重载之一。</span><span class="sxs-lookup"><span data-stu-id="970a2-1292">Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component.</span></span> <span data-ttu-id="970a2-1293">此重载和没有参数的重载都允许您指定要启动的进程资源的文件名以及要传递的命令行参数。</span><span class="sxs-lookup"><span data-stu-id="970a2-1293">Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start and command-line arguments to pass.</span></span>  
  
 <span data-ttu-id="970a2-1294">如果在系统中使用引号声明了路径变量，则在启动在该位置找到的任何进程时必须完全限定该路径。</span><span class="sxs-lookup"><span data-stu-id="970a2-1294">If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location.</span></span> <span data-ttu-id="970a2-1295">否则，系统将找不到该路径。</span><span class="sxs-lookup"><span data-stu-id="970a2-1295">Otherwise, the system will not find the path.</span></span> <span data-ttu-id="970a2-1296">例如，如果 `c:\mypath` 不在你的路径中，而你使用引号添加它： `path = %path%;"c:\mypath"`，则在启动时必须完全限定 `c:\mypath` 中的任何进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1296">For example, if `c:\mypath` is not in your path, and you add it using quotation marks: `path = %path%;"c:\mypath"`, you must fully qualify any process in `c:\mypath` when starting it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-1297">ASP.NET 网页和服务器控制代码在 Web 服务器上的 ASP.NET 工作进程上下文中执行。</span><span class="sxs-lookup"><span data-stu-id="970a2-1297">ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.</span></span>  <span data-ttu-id="970a2-1298">如果在 ASP.NET 网页或服务器控件中使用 <xref:System.Diagnostics.Process.Start%2A> 方法，则新进程将在具有受限权限的 Web 服务器上执行。</span><span class="sxs-lookup"><span data-stu-id="970a2-1298">If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions.</span></span> <span data-ttu-id="970a2-1299">该进程不会在与客户端浏览器相同的上下文中启动，也不能访问用户桌面。</span><span class="sxs-lookup"><span data-stu-id="970a2-1299">The process does not start in the same context as the client browser, and does not have access to the user desktop.</span></span>  
  
 <span data-ttu-id="970a2-1300">无论何时使用 <xref:System.Diagnostics.Process.Start%2A> 来启动进程，都可能需要将其关闭或丢失系统资源。</span><span class="sxs-lookup"><span data-stu-id="970a2-1300">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="970a2-1301">使用 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 或 <xref:System.Diagnostics.Process.Kill%2A>关闭进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1301">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="970a2-1302">您可以使用其 <xref:System.Diagnostics.Process.HasExited%2A> 属性检查进程是否已关闭。</span><span class="sxs-lookup"><span data-stu-id="970a2-1302">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.</span></span> 
  
 <span data-ttu-id="970a2-1303">此处需要有关托管线程中的单元状态的说明。</span><span class="sxs-lookup"><span data-stu-id="970a2-1303">A note about apartment states in managed threads is necessary here.</span></span> <span data-ttu-id="970a2-1304">当在进程组件的 <xref:System.Diagnostics.Process.StartInfo%2A> 属性中 `true` <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 时，请确保已在应用程序上设置了线程模型，方法是在 `main()` 方法上设置属性 `[STAThread]`。</span><span class="sxs-lookup"><span data-stu-id="970a2-1304">When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method.</span></span> <span data-ttu-id="970a2-1305">否则，托管线程可以处于 `unknown` 状态或置于 `MTA` 状态，后者与 `true`的 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 发生冲突。</span><span class="sxs-lookup"><span data-stu-id="970a2-1305">Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`.</span></span> <span data-ttu-id="970a2-1306">某些方法要求单元状态不 `unknown`。</span><span class="sxs-lookup"><span data-stu-id="970a2-1306">Some methods require that the apartment state not be `unknown`.</span></span> <span data-ttu-id="970a2-1307">如果未显式设置该状态，则当应用程序遇到此类方法时，它默认为 `MTA`，一旦设置，将无法更改单元状态。</span><span class="sxs-lookup"><span data-stu-id="970a2-1307">If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed.</span></span> <span data-ttu-id="970a2-1308">但 `MTA` 会导致在操作系统 shell 管理线程时引发异常。</span><span class="sxs-lookup"><span data-stu-id="970a2-1308">However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-1309">下面的示例首先生成 Internet Explorer 的一个实例，并在浏览器中显示 "收藏夹" 文件夹的内容。</span><span class="sxs-lookup"><span data-stu-id="970a2-1309">The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser.</span></span> <span data-ttu-id="970a2-1310">然后，它将启动其他一些 Internet Explorer 实例，并显示某些特定页面或站点。</span><span class="sxs-lookup"><span data-stu-id="970a2-1310">It then starts some other instances of Internet Explorer and displays some specific pages or sites.</span></span> <span data-ttu-id="970a2-1311">最后，当导航到特定站点时，它会在窗口最小化时启动 Internet Explorer。</span><span class="sxs-lookup"><span data-stu-id="970a2-1311">Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.</span></span>  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-1312"><paramref name="fileName" /> 或 <paramref name="arguments" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-1312">The <paramref name="fileName" /> or <paramref name="arguments" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="970a2-1313">打开关联的文件时出错。</span><span class="sxs-lookup"><span data-stu-id="970a2-1313">An error occurred when opening the associated file.</span></span>  

<span data-ttu-id="970a2-1314">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-1314">-or-</span></span>

<span data-ttu-id="970a2-1315">找不到 <paramref name="fileName" /> 中指定的文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1315">The file specified in the <paramref name="fileName" /> could not be found.</span></span>
  
<span data-ttu-id="970a2-1316">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-1316">-or-</span></span> 
<span data-ttu-id="970a2-1317">自变量的长度与该进程的完整路径的长度的总和超过了 2080。</span><span class="sxs-lookup"><span data-stu-id="970a2-1317">The sum of the length of the arguments and the length of the full path to the process exceeds 2080.</span></span> <span data-ttu-id="970a2-1318">与此异常关联的错误消息可以是下面其中一项：“传递给系统调用的数据区域太小。”</span><span class="sxs-lookup"><span data-stu-id="970a2-1318">The error message associated with this exception can be one of the following: "The data area passed to a system call is too small."</span></span> <span data-ttu-id="970a2-1319">或“拒绝访问。”</span><span class="sxs-lookup"><span data-stu-id="970a2-1319">or "Access is denied."</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="970a2-1320">已释放此进程对象。</span><span class="sxs-lookup"><span data-stu-id="970a2-1320">The process object has already been disposed.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="970a2-1321">PATH 环境变量具有一个包含引号的字符串。</span><span class="sxs-lookup"><span data-stu-id="970a2-1321">The PATH environment variable has a string containing quotes.</span></span></exception>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="userName" Type="System.String" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="password" Type="System.Security.SecureString" Index="2" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="domain" Type="System.String" Index="3" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="970a2-1322">要在进程中运行的应用程序文件的名称。</span><span class="sxs-lookup"><span data-stu-id="970a2-1322">The name of an application file to run in the process.</span></span></param>
        <param name="userName"><span data-ttu-id="970a2-1323">启动进程时使用的用户名。</span><span class="sxs-lookup"><span data-stu-id="970a2-1323">The user name to use when starting the process.</span></span></param>
        <param name="password"><span data-ttu-id="970a2-1324">包含启动进程时要使用的密码的 <see cref="T:System.Security.SecureString" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-1324">A <see cref="T:System.Security.SecureString" /> that contains the password to use when starting the process.</span></span></param>
        <param name="domain"><span data-ttu-id="970a2-1325">启动进程时要使用的域。</span><span class="sxs-lookup"><span data-stu-id="970a2-1325">The domain to use when starting the process.</span></span></param>
        <summary><span data-ttu-id="970a2-1326">通过指定应用程序的名称、用户名、密码和域来启动一个进程资源，并将该资源与新的 <see cref="T:System.Diagnostics.Process" /> 组件关联起来。</span><span class="sxs-lookup"><span data-stu-id="970a2-1326">Starts a process resource by specifying the name of an application, a user name, a password, and a domain and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</span></span></summary>
        <returns><span data-ttu-id="970a2-1327">与进程资源关联的新 <see cref="T:System.Diagnostics.Process" />，如果未启动进程资源，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-1327">A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started.</span></span> <span data-ttu-id="970a2-1328">请注意，伴随同一进程中已运行的实例而启动的新进程将独立于其他进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1328">Note that a new process that's started alongside already running instances of the same process will be independent from the others.</span></span> <span data-ttu-id="970a2-1329">此外，启动可能返回一个 <see cref="P:System.Diagnostics.Process.HasExited" /> 属性已设置为 <see langword="true" /> 的非 null 进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1329">In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />.</span></span> <span data-ttu-id="970a2-1330">在这种情况下，启动的进程可能已激活现有实例自身，然后退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-1330">In this case, the started process may have activated an existing instance of itself and then exited.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-1331">使用此重载通过指定新进程的文件名、用户名、密码和域来创建新进程及其主线程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1331">Use this overload to create a new process and its primary thread by specifying its file name, user name, password, and domain.</span></span> <span data-ttu-id="970a2-1332">然后，新进程在指定凭据（用户、域和密码）的安全上下文中运行指定的可执行文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1332">The new process then runs the specified executable file in the security context of the specified credentials (user, domain, and password).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-1333">当可执行文件位于远程驱动器上时，必须使用统一资源标识符（URI）而不是链接驱动器号来标识网络共享。</span><span class="sxs-lookup"><span data-stu-id="970a2-1333">When the executable file is located on a remote drive, you must identify the network share by using a uniform resource identifier (URI), not a linked drive letter.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-1334">如果要启动的可执行文件的地址是 URL，则该进程将不会启动，并且将返回 `null`。</span><span class="sxs-lookup"><span data-stu-id="970a2-1334">If the address of the executable file to start is a URL, the process is not started and `null` is returned.</span></span>  
  
 <span data-ttu-id="970a2-1335">此重载使你可以在不先创建新的 <xref:System.Diagnostics.Process> 实例的情况下启动进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1335">This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="970a2-1336">重载是一种替代方法，用于创建新的 <xref:System.Diagnostics.Process> 实例、设置 <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> 属性的 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>、<xref:System.Diagnostics.ProcessStartInfo.UserName%2A>、<xref:System.Diagnostics.ProcessStartInfo.Password%2A>和 <xref:System.Diagnostics.Process.StartInfo%2A> 属性，以及调用 <xref:System.Diagnostics.Process.Start%2A> 实例的 <xref:System.Diagnostics.Process>。</span><span class="sxs-lookup"><span data-stu-id="970a2-1336">The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, and <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> properties of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.</span></span>  
  
 <span data-ttu-id="970a2-1337">同样，在 "**运行**" 对话框可以接受带有或不带 .exe 扩展名的可执行文件名的相同方式中，.exe 扩展名在 `fileName` 参数中是可选的。</span><span class="sxs-lookup"><span data-stu-id="970a2-1337">Similarly, in the same way that the **Run** dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter.</span></span> <span data-ttu-id="970a2-1338">例如，可以将 `fileName` 参数设置为 "Notepad.exe" 或 "Notepad"。</span><span class="sxs-lookup"><span data-stu-id="970a2-1338">For example, you can set the `fileName` parameter to either "Notepad.exe" or "Notepad".</span></span> <span data-ttu-id="970a2-1339">如果 `fileName` 参数表示一个可执行文件，则 `arguments` 参数可能表示要对其执行操作的文件，如 `Notepad.exe myfile.txt`中的文本文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1339">If the `fileName` parameter represents an executable file, the `arguments` parameter might represent a file to act upon, such as the text file in `Notepad.exe myfile.txt`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-1340">文件名必须在具有 `userName`、`password`和 `domain` 参数的 <xref:System.Diagnostics.Process.Start%2A> 重载中表示可执行文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1340">The file name must represent an executable file in the <xref:System.Diagnostics.Process.Start%2A> overloads that have `userName`, `password`, and `domain` parameters.</span></span>  
  
 <span data-ttu-id="970a2-1341">无论何时使用 <xref:System.Diagnostics.Process.Start%2A> 来启动进程，都可能需要将其关闭或丢失系统资源。</span><span class="sxs-lookup"><span data-stu-id="970a2-1341">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="970a2-1342">使用 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 或 <xref:System.Diagnostics.Process.Kill%2A>关闭进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1342">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="970a2-1343">您可以使用其 <xref:System.Diagnostics.Process.HasExited%2A> 属性检查进程是否已关闭。</span><span class="sxs-lookup"><span data-stu-id="970a2-1343">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.</span></span> 
  
   
  
## Examples  
 <span data-ttu-id="970a2-1344">下面的代码示例演示了如何使用此重载来启动可执行文件，还演示了在尝试启动与不可执行文件关联的应用程序时 <xref:System.ComponentModel.Win32Exception> 引发。</span><span class="sxs-lookup"><span data-stu-id="970a2-1344">The following code example shows the use of this overload to start an executable file and also demonstrates the throwing of a <xref:System.ComponentModel.Win32Exception> when an attempt is made to start an application associated with a nonexecutable file.</span></span>  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-1345">未指定文件名。</span><span class="sxs-lookup"><span data-stu-id="970a2-1345">No file name was specified.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="970a2-1346">打开关联的文件时出错。</span><span class="sxs-lookup"><span data-stu-id="970a2-1346">There was an error in opening the associated file.</span></span>

<span data-ttu-id="970a2-1347">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-1347">-or-</span></span>

<span data-ttu-id="970a2-1348">找不到 <paramref name="fileName" /> 中指定的文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1348">The file specified in the <paramref name="fileName" /> could not be found.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="970a2-1349">已释放此进程对象。</span><span class="sxs-lookup"><span data-stu-id="970a2-1349">The process object has already been disposed.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="970a2-1350">Linux 或 macOS（仅适用于.NET Core）不支持此成员。</span><span class="sxs-lookup"><span data-stu-id="970a2-1350">This member is not supported on Linux or macOS (.NET Core only).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arguments" Type="System.String" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="userName" Type="System.String" Index="2" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="password" Type="System.Security.SecureString" Index="3" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="domain" Type="System.String" Index="4" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="970a2-1351">要在进程中运行的应用程序文件的名称。</span><span class="sxs-lookup"><span data-stu-id="970a2-1351">The name of an application file to run in the process.</span></span></param>
        <param name="arguments"><span data-ttu-id="970a2-1352">启动该进程时传递的命令行参数。</span><span class="sxs-lookup"><span data-stu-id="970a2-1352">Command-line arguments to pass when starting the process.</span></span></param>
        <param name="userName"><span data-ttu-id="970a2-1353">启动进程时使用的用户名。</span><span class="sxs-lookup"><span data-stu-id="970a2-1353">The user name to use when starting the process.</span></span></param>
        <param name="password"><span data-ttu-id="970a2-1354">包含启动进程时要使用的密码的 <see cref="T:System.Security.SecureString" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-1354">A <see cref="T:System.Security.SecureString" /> that contains the password to use when starting the process.</span></span></param>
        <param name="domain"><span data-ttu-id="970a2-1355">启动进程时要使用的域。</span><span class="sxs-lookup"><span data-stu-id="970a2-1355">The domain to use when starting the process.</span></span></param>
        <summary><span data-ttu-id="970a2-1356">通过指定应用程序的名称、一组命令行自变量、用户名、密码和域来启动一个进程资源，并将该资源与新的 <see cref="T:System.Diagnostics.Process" /> 组件关联起来。</span><span class="sxs-lookup"><span data-stu-id="970a2-1356">Starts a process resource by specifying the name of an application, a set of command-line arguments, a user name, a password, and a domain and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</span></span></summary>
        <returns><span data-ttu-id="970a2-1357">与进程资源关联的新 <see cref="T:System.Diagnostics.Process" />，如果未启动进程资源，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-1357">A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started.</span></span> <span data-ttu-id="970a2-1358">请注意，伴随同一进程中已运行的实例而启动的新进程将独立于其他进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1358">Note that a new process that's started alongside already running instances of the same process will be independent from the others.</span></span> <span data-ttu-id="970a2-1359">此外，启动可能返回一个 <see cref="P:System.Diagnostics.Process.HasExited" /> 属性已设置为 <see langword="true" /> 的非 null 进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1359">In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />.</span></span> <span data-ttu-id="970a2-1360">在这种情况下，启动的进程可能已激活现有实例自身，然后退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-1360">In this case, the started process may have activated an existing instance of itself and then exited.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-1361">使用此重载通过指定新进程的文件名、命令行参数、用户名、密码和域来创建新进程及其主线程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1361">Use this overload to create a new process and its primary thread by specifying its file name, command-line arguments, user name, password, and domain.</span></span> <span data-ttu-id="970a2-1362">然后，新进程在指定凭据（用户、域和密码）的安全上下文中运行指定的可执行文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1362">The new process then runs the specified executable file in the security context of the specified credentials (user, domain, and password).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-1363">当可执行文件位于远程驱动器上时，必须使用统一资源标识符（URI）而不是链接驱动器号来标识网络共享。</span><span class="sxs-lookup"><span data-stu-id="970a2-1363">When the executable file is located on a remote drive, you must identify the network share by using a uniform resource identifier (URI), not a linked drive letter.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-1364">如果要启动的可执行文件的地址是 URL，则该进程将不会启动，并且将返回 `null`。</span><span class="sxs-lookup"><span data-stu-id="970a2-1364">If the address of the executable file to start is a URL, the process is not started and `null` is returned.</span></span>  
  
 <span data-ttu-id="970a2-1365">此重载使你可以在不先创建新的 <xref:System.Diagnostics.Process> 实例的情况下启动进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1365">This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="970a2-1366">重载是一种替代方法，用于创建新的 <xref:System.Diagnostics.Process> 实例、设置 <xref:System.Diagnostics.ProcessStartInfo.Password%2A>属性的 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>、<xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>、<xref:System.Diagnostics.ProcessStartInfo.UserName%2A>、<xref:System.Diagnostics.ProcessStartInfo.Domain%2A> 和 <xref:System.Diagnostics.Process.StartInfo%2A> 属性，以及调用 <xref:System.Diagnostics.Process.Start%2A> 实例的 <xref:System.Diagnostics.Process>。</span><span class="sxs-lookup"><span data-stu-id="970a2-1366">The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, and <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> properties of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.</span></span>  
  
 <span data-ttu-id="970a2-1367">同样，在 "**运行**" 对话框可以接受带有或不带 .exe 扩展名的可执行文件名的相同方式中，.exe 扩展名在 `fileName` 参数中是可选的。</span><span class="sxs-lookup"><span data-stu-id="970a2-1367">Similarly, in the same way that the **Run** dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter.</span></span> <span data-ttu-id="970a2-1368">例如，可以将 `fileName` 参数设置为 "Notepad.exe" 或 "Notepad"。</span><span class="sxs-lookup"><span data-stu-id="970a2-1368">For example, you can set the `fileName` parameter to either "Notepad.exe" or "Notepad".</span></span> <span data-ttu-id="970a2-1369">如果 `fileName` 参数表示一个可执行文件，则 `arguments` 参数可能表示要对其执行操作的文件，如 `Notepad.exe myfile.txt`中的文本文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1369">If the `fileName` parameter represents an executable file, the `arguments` parameter might represent a file to act upon, such as the text file in `Notepad.exe myfile.txt`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-1370">文件名必须在具有 `userName`、`password`和 `domain` 参数的 <xref:System.Diagnostics.Process.Start%2A> 重载中表示可执行文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1370">The file name must represent an executable file in the <xref:System.Diagnostics.Process.Start%2A> overloads that have `userName`, `password`, and `domain` parameters.</span></span>  
  
 <span data-ttu-id="970a2-1371">无论何时使用 <xref:System.Diagnostics.Process.Start%2A> 来启动进程，都可能需要将其关闭或丢失系统资源。</span><span class="sxs-lookup"><span data-stu-id="970a2-1371">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="970a2-1372">使用 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 或 <xref:System.Diagnostics.Process.Kill%2A>关闭进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1372">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="970a2-1373">您可以使用其 <xref:System.Diagnostics.Process.HasExited%2A> 属性检查进程是否已关闭。</span><span class="sxs-lookup"><span data-stu-id="970a2-1373">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.</span></span> 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-1374">未指定文件名。</span><span class="sxs-lookup"><span data-stu-id="970a2-1374">No file name was specified.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="970a2-1375">打开关联的文件时出错。</span><span class="sxs-lookup"><span data-stu-id="970a2-1375">An error occurred when opening the associated file.</span></span>  

<span data-ttu-id="970a2-1376">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-1376">-or-</span></span>

<span data-ttu-id="970a2-1377">找不到 <paramref name="fileName" /> 中指定的文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1377">The file specified in the <paramref name="fileName" /> could not be found.</span></span>
  
<span data-ttu-id="970a2-1378">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-1378">-or-</span></span> 
<span data-ttu-id="970a2-1379">参数的长度与该关联文件的完整路径的长度的总和超过了 2080。</span><span class="sxs-lookup"><span data-stu-id="970a2-1379">The sum of the length of the arguments and the length of the full path to the associated file exceeds 2080.</span></span> <span data-ttu-id="970a2-1380">与此异常关联的错误消息可以是下面其中一项：“传递给系统调用的数据区域太小。”</span><span class="sxs-lookup"><span data-stu-id="970a2-1380">The error message associated with this exception can be one of the following: "The data area passed to a system call is too small."</span></span> <span data-ttu-id="970a2-1381">或“拒绝访问。”</span><span class="sxs-lookup"><span data-stu-id="970a2-1381">or "Access is denied."</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="970a2-1382">已释放此进程对象。</span><span class="sxs-lookup"><span data-stu-id="970a2-1382">The process object has already been disposed.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="970a2-1383">Linux 或 macOS（仅适用于.NET Core）不支持此成员。</span><span class="sxs-lookup"><span data-stu-id="970a2-1383">This member is not supported on Linux or macOS (.NET Core only).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartInfo : System.Diagnostics.ProcessStartInfo with get, set" Usage="System.Diagnostics.Process.StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartInfo")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-1384">获取或设置要传递给 <see cref="M:System.Diagnostics.Process.Start" /> 的 <see cref="T:System.Diagnostics.Process" /> 方法的属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-1384">Gets or sets the properties to pass to the <see cref="M:System.Diagnostics.Process.Start" /> method of the <see cref="T:System.Diagnostics.Process" />.</span></span></summary>
        <value><span data-ttu-id="970a2-1385">表示启动进程时要使用的数据的 <see cref="T:System.Diagnostics.ProcessStartInfo" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-1385">The <see cref="T:System.Diagnostics.ProcessStartInfo" /> that represents the data with which to start the process.</span></span> <span data-ttu-id="970a2-1386">这些自变量包括用于启动该进程的可执行文件或文档的名称。</span><span class="sxs-lookup"><span data-stu-id="970a2-1386">These arguments include the name of the executable file or document used to start the process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-1387"><xref:System.Diagnostics.Process.StartInfo%2A> 表示要用于启动进程的参数集。</span><span class="sxs-lookup"><span data-stu-id="970a2-1387"><xref:System.Diagnostics.Process.StartInfo%2A> represents the set of parameters to use to start a process.</span></span> <span data-ttu-id="970a2-1388">调用 <xref:System.Diagnostics.Process.Start%2A> 时，<xref:System.Diagnostics.Process.StartInfo%2A> 用于指定要启动的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1388">When <xref:System.Diagnostics.Process.Start%2A> is called, the <xref:System.Diagnostics.Process.StartInfo%2A> is used to specify the process to start.</span></span> <span data-ttu-id="970a2-1389">要设置的唯一必需 <xref:System.Diagnostics.Process.StartInfo%2A> 成员是 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-1389">The only necessary <xref:System.Diagnostics.Process.StartInfo%2A> member to set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property.</span></span> <span data-ttu-id="970a2-1390">通过指定 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 属性启动进程类似于在 Windows "**开始**" 菜单的 "**运行**" 对话框中键入信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-1390">Starting a process by specifying the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property is similar to typing the information in the **Run** dialog box of the Windows **Start** menu.</span></span> <span data-ttu-id="970a2-1391">因此，<xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 属性不需要表示可执行文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1391">Therefore, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not need to represent an executable file.</span></span> <span data-ttu-id="970a2-1392">它可以是与系统上安装的应用程序关联的任何文件类型。</span><span class="sxs-lookup"><span data-stu-id="970a2-1392">It can be of any file type for which the extension has been associated with an application installed on the system.</span></span> <span data-ttu-id="970a2-1393">例如，如果您已将文本文件与一个编辑器（如记事本）关联，则 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 可以具有 .txt 扩展名; 如果您已将 .doc 文件与 word 处理工具（如 Microsoft Word）相关联，则它可能具有 .doc。</span><span class="sxs-lookup"><span data-stu-id="970a2-1393">For example the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated .doc files with a word processing tool, such as Microsoft Word.</span></span> <span data-ttu-id="970a2-1394">同样，在 "**运行**" 对话框可以接受带有或不带 .exe 扩展名的可执行文件名的相同方式中，.exe 扩展名在 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 成员中是可选的。</span><span class="sxs-lookup"><span data-stu-id="970a2-1394">Similarly, in the same way that the **Run** dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member.</span></span> <span data-ttu-id="970a2-1395">例如，可以将 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 属性设置为 "Notepad.exe" 或 "Notepad"。</span><span class="sxs-lookup"><span data-stu-id="970a2-1395">For example, you can set the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property to either "Notepad.exe" or "Notepad".</span></span>  
  
 <span data-ttu-id="970a2-1396">可以通过将 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 属性设置为最初安装应用程序的位置（例如，Web 地址）来启动 ClickOnce 应用程序。</span><span class="sxs-lookup"><span data-stu-id="970a2-1396">You can start a ClickOnce application by setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property to the location (for example, a Web address) from which you originally installed the application.</span></span> <span data-ttu-id="970a2-1397">不要通过在硬盘驱动器上指定其安装位置来启动 ClickOnce 应用程序。</span><span class="sxs-lookup"><span data-stu-id="970a2-1397">Do not start a ClickOnce application by specifying its installed location on your hard drive.</span></span>  
  
 <span data-ttu-id="970a2-1398">如果文件名涉及不可执行的文件（如 .doc 文件），则可以包含谓词来指定要对文件执行的操作。</span><span class="sxs-lookup"><span data-stu-id="970a2-1398">If the file name involves a nonexecutable file, such as a .doc file, you can include a verb specifying what action to take on the file.</span></span> <span data-ttu-id="970a2-1399">例如，可以将以 .doc 扩展名结尾的文件的 <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> 设置为 "Print"。</span><span class="sxs-lookup"><span data-stu-id="970a2-1399">For example, you could set the <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> to "Print" for a file ending in the .doc extension.</span></span> <span data-ttu-id="970a2-1400">如果手动输入 <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> 属性的值，则 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 属性中指定的文件名不需要具有扩展名。</span><span class="sxs-lookup"><span data-stu-id="970a2-1400">The file name specified in the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not need to have an extension if you manually enter a value for the <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> property.</span></span> <span data-ttu-id="970a2-1401">但是，如果使用 <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> 属性来确定哪些谓词可用，则必须包含该扩展。</span><span class="sxs-lookup"><span data-stu-id="970a2-1401">However, if you use the <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> property to determine what verbs are available, you must include the extension.</span></span>  
  
 <span data-ttu-id="970a2-1402">你可以将 <xref:System.Diagnostics.Process.StartInfo%2A> 属性中指定的参数更改为对进程调用 <xref:System.Diagnostics.Process.Start%2A> 方法的时间。</span><span class="sxs-lookup"><span data-stu-id="970a2-1402">You can change the parameters specified in the <xref:System.Diagnostics.Process.StartInfo%2A> property up to the time that you call the <xref:System.Diagnostics.Process.Start%2A> method on the process.</span></span> <span data-ttu-id="970a2-1403">开始该过程后，更改 <xref:System.Diagnostics.Process.StartInfo%2A> 的值不会影响或重启关联的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1403">After you start the process, changing the <xref:System.Diagnostics.Process.StartInfo%2A> values does not affect or restart the associated process.</span></span> <span data-ttu-id="970a2-1404">如果在设置了 <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> 和 <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> 属性的情况下调用 <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> 方法，则将调用非托管 `CreateProcessWithLogonW` 函数，这将在新窗口中启动该进程，即使 <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> 属性值 `true` 或 <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> 属性值 <xref:System.Diagnostics.ProcessWindowStyle.Hidden>。</span><span class="sxs-lookup"><span data-stu-id="970a2-1404">If you call the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> method with the <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> and <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> properties set, the unmanaged `CreateProcessWithLogonW` function is called, which starts the process in a new window even if the <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> property value is `true` or the <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> property value is <xref:System.Diagnostics.ProcessWindowStyle.Hidden>.</span></span>  
  
 <span data-ttu-id="970a2-1405">只应访问 <xref:System.Diagnostics.Process.Start%2A> 方法返回的 <xref:System.Diagnostics.Process> 对象的 <xref:System.Diagnostics.Process.StartInfo%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-1405">You should only access the <xref:System.Diagnostics.Process.StartInfo%2A> property on a <xref:System.Diagnostics.Process> object returned by the <xref:System.Diagnostics.Process.Start%2A> method.</span></span> <span data-ttu-id="970a2-1406">例如，不应访问 <xref:System.Diagnostics.Process.GetProcesses%2A>返回的 <xref:System.Diagnostics.Process> 对象的 <xref:System.Diagnostics.Process.StartInfo%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-1406">For example, you should not access the <xref:System.Diagnostics.Process.StartInfo%2A> property on a <xref:System.Diagnostics.Process> object returned by <xref:System.Diagnostics.Process.GetProcesses%2A>.</span></span> <span data-ttu-id="970a2-1407">否则，在 .NET Core 中，<xref:System.Diagnostics.Process.StartInfo%2A> 属性将引发 <xref:System.InvalidOperationException> 并在上 .NET Framework 它将返回一个虚拟 <xref:System.Diagnostics.ProcessStartInfo> 对象。</span><span class="sxs-lookup"><span data-stu-id="970a2-1407">Otherwise, on .NET Core the <xref:System.Diagnostics.Process.StartInfo%2A> property will throw an <xref:System.InvalidOperationException> and on .NET Framework it will return a dummy <xref:System.Diagnostics.ProcessStartInfo> object.</span></span>
  
 <span data-ttu-id="970a2-1408">当进程启动时，文件名是填充（只读） <xref:System.Diagnostics.Process.MainModule%2A> 属性的文件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1408">When the process is started, the file name is the file that populates the (read-only) <xref:System.Diagnostics.Process.MainModule%2A> property.</span></span> <span data-ttu-id="970a2-1409">如果要在启动进程后检索与进程关联的可执行文件，请使用 <xref:System.Diagnostics.Process.MainModule%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-1409">If you want to retrieve the executable file that is associated with the process after the process has started, use the <xref:System.Diagnostics.Process.MainModule%2A> property.</span></span> <span data-ttu-id="970a2-1410">如果要设置未启动关联进程的 <xref:System.Diagnostics.Process> 实例的可执行文件，请使用 <xref:System.Diagnostics.Process.StartInfo%2A> 属性的 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 成员。</span><span class="sxs-lookup"><span data-stu-id="970a2-1410">If you want to set the executable file of a <xref:System.Diagnostics.Process> instance for which an associated process has not been started, use the <xref:System.Diagnostics.Process.StartInfo%2A> property's <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member.</span></span> <span data-ttu-id="970a2-1411">由于 <xref:System.Diagnostics.Process.StartInfo%2A> 属性的成员是传递给进程的 <xref:System.Diagnostics.Process.Start%2A> 方法的参数，因此，在关联进程开始后更改 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 属性将不会重置 <xref:System.Diagnostics.Process.MainModule%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-1411">Because the members of the <xref:System.Diagnostics.Process.StartInfo%2A> property are arguments that are passed to the <xref:System.Diagnostics.Process.Start%2A> method of a process, changing the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property after the associated process has started will not reset the <xref:System.Diagnostics.Process.MainModule%2A> property.</span></span> <span data-ttu-id="970a2-1412">这些属性仅用于初始化关联的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1412">These properties are used only to initialize the associated process.</span></span>
  
## Examples  
 <span data-ttu-id="970a2-1413">下面的示例使用要执行的文件、对其执行的操作以及是否应显示用户界面来填充 <xref:System.Diagnostics.Process.StartInfo%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-1413">The following example populates a <xref:System.Diagnostics.Process.StartInfo%2A> with the file to execute, the action performed on it and whether it should displays a user interface.</span></span> <span data-ttu-id="970a2-1414">有关其他示例，请参阅 <xref:System.Diagnostics.ProcessStartInfo> 类的属性的参考页。</span><span class="sxs-lookup"><span data-stu-id="970a2-1414">For additional examples, refer to the reference pages for properties of the <xref:System.Diagnostics.ProcessStartInfo> class.</span></span>  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="970a2-1415">指定 <see cref="P:System.Diagnostics.Process.StartInfo" /> 的值为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-1415">The value that specifies the <see cref="P:System.Diagnostics.Process.StartInfo" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-1416">仅限 .NET Core：<see cref="M:System.Diagnostics.Process.Start" /> 方法未用于启动进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1416">.NET Core only: The <see cref="M:System.Diagnostics.Process.Start" /> method was not used to start the process.</span></span></exception>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.Process.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-1417">获取关联进程启动的时间。</span><span class="sxs-lookup"><span data-stu-id="970a2-1417">Gets the time that the associated process was started.</span></span></summary>
        <value><span data-ttu-id="970a2-1418">指示进程启动的时间的对象。</span><span class="sxs-lookup"><span data-stu-id="970a2-1418">An object  that indicates when the process started.</span></span> <span data-ttu-id="970a2-1419">如果进程未运行，将会引发异常。</span><span class="sxs-lookup"><span data-stu-id="970a2-1419">An exception is thrown if the process is not running.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="970a2-1420">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.StartTime" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-1420">You are attempting to access the <see cref="P:System.Diagnostics.Process.StartTime" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="970a2-1421">此属性仅可用于本地计算机上运行的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1421">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-1422">该进程已退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-1422">The process has exited.</span></span>  
  
 <span data-ttu-id="970a2-1423">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-1423">-or-</span></span>  
  
 <span data-ttu-id="970a2-1424">该进程尚未启动。</span><span class="sxs-lookup"><span data-stu-id="970a2-1424">The process has not been started.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="970a2-1425">调用 Windows 函数时出错。</span><span class="sxs-lookup"><span data-stu-id="970a2-1425">An error occurred in the call to the Windows function.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.Process.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-1426">获取或设置用于封送由于进程退出事件而发出的事件处理程序调用的对象。</span><span class="sxs-lookup"><span data-stu-id="970a2-1426">Gets or sets the object used to marshal the event handler calls that are issued as a result of a process exit event.</span></span></summary>
        <value><span data-ttu-id="970a2-1427"><see cref="T:System.ComponentModel.ISynchronizeInvoke" />，它用于封送由于进程上的 <see cref="E:System.Diagnostics.Process.Exited" /> 事件而发出的事件处理程序调用。</span><span class="sxs-lookup"><span data-stu-id="970a2-1427">The <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> used to marshal event handler calls that are issued as a result of an <see cref="E:System.Diagnostics.Process.Exited" /> event on the process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-1428">`null`<xref:System.Diagnostics.EventLog.SynchronizingObject%2A> 时，处理 <xref:System.Diagnostics.Process.Exited> 事件的方法将在系统线程池中的线程上调用。</span><span class="sxs-lookup"><span data-stu-id="970a2-1428">When <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> is `null`, methods that handle the <xref:System.Diagnostics.Process.Exited> event are called on a thread from the system thread pool.</span></span> <span data-ttu-id="970a2-1429">有关系统线程池的详细信息，请参阅 <xref:System.Threading.ThreadPool>。</span><span class="sxs-lookup"><span data-stu-id="970a2-1429">For more information about system thread pools, see <xref:System.Threading.ThreadPool>.</span></span>  
  
 <span data-ttu-id="970a2-1430">当 <xref:System.Diagnostics.Process.Exited> 事件由 visual Windows 窗体组件（如 <xref:System.Windows.Forms.Button>）处理时，通过系统线程池访问组件可能不起作用，或可能会导致异常。</span><span class="sxs-lookup"><span data-stu-id="970a2-1430">When the <xref:System.Diagnostics.Process.Exited> event is handled by a visual Windows Forms component, such as a <xref:System.Windows.Forms.Button>, accessing the component through the system thread pool might not work, or might result in an exception.</span></span> <span data-ttu-id="970a2-1431">通过将 <xref:System.Diagnostics.Process.SynchronizingObject%2A> 设置为 Windows 窗体组件来避免这种情况，这会导致在创建组件的线程上调用处理 <xref:System.Diagnostics.Process.Exited> 事件的方法。</span><span class="sxs-lookup"><span data-stu-id="970a2-1431">Avoid this by setting <xref:System.Diagnostics.Process.SynchronizingObject%2A> to a Windows Forms component, which causes the methods handling the <xref:System.Diagnostics.Process.Exited> event to be called on the same thread on which the component was created.</span></span>  
  
 <span data-ttu-id="970a2-1432">如果在 Windows 窗体设计器中的 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] 内使用 <xref:System.Diagnostics.Process>，则 <xref:System.Diagnostics.Process.SynchronizingObject%2A> 将自动设置为包含 <xref:System.Diagnostics.Process>的控件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1432">If the <xref:System.Diagnostics.Process> is used inside [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] in a Windows Forms designer, <xref:System.Diagnostics.Process.SynchronizingObject%2A> is automatically set to the control that contains the <xref:System.Diagnostics.Process>.</span></span> <span data-ttu-id="970a2-1433">例如，如果你将 <xref:System.Diagnostics.Process> 放置在 `Form1` 的设计器（从 <xref:System.Windows.Forms.Form>继承），则 <xref:System.Diagnostics.Process> 的 <xref:System.Diagnostics.Process.SynchronizingObject%2A> 属性将设置为 `Form1`的实例：</span><span class="sxs-lookup"><span data-stu-id="970a2-1433">For example, if you place a <xref:System.Diagnostics.Process> on a designer for `Form1` (which inherits from <xref:System.Windows.Forms.Form>) the <xref:System.Diagnostics.Process.SynchronizingObject%2A> property of <xref:System.Diagnostics.Process> is set to the instance of `Form1`:</span></span>  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 <span data-ttu-id="970a2-1434">通常，当组件置于控件或窗体内时，将设置此属性，因为这些组件绑定到特定线程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1434">Typically, this property is set when the component is placed inside a control or form, because those components are bound to a specific thread.</span></span>  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Threads : System.Diagnostics.ProcessThreadCollection" Usage="System.Diagnostics.Process.Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessThreads")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-1435">获取在关联进程中运行的一组线程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1435">Gets the set of threads that are running in the associated process.</span></span></summary>
        <value><span data-ttu-id="970a2-1436">类型 <see cref="T:System.Diagnostics.ProcessThread" /> 的数组，表示当前在关联进程中运行的操作系统线程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1436">An array of type <see cref="T:System.Diagnostics.ProcessThread" /> representing the operating system threads currently running in the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-1437">线程执行进程中的代码。</span><span class="sxs-lookup"><span data-stu-id="970a2-1437">A thread executes code in a process.</span></span> <span data-ttu-id="970a2-1438">每个进程都是使用单个线程（其主线程）启动的。</span><span class="sxs-lookup"><span data-stu-id="970a2-1438">Each process is started with a single thread, its primary thread.</span></span> <span data-ttu-id="970a2-1439">任何线程都可以创建其他线程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1439">Any thread can create additional threads.</span></span> <span data-ttu-id="970a2-1440">进程中的线程共享进程的地址空间。</span><span class="sxs-lookup"><span data-stu-id="970a2-1440">Threads within a process share the address space of the process.</span></span>  
  
 <span data-ttu-id="970a2-1441">使用 <xref:System.Diagnostics.ProcessThread> 获取与当前进程关联的所有线程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1441">Use <xref:System.Diagnostics.ProcessThread> to get all the threads associated with the current process.</span></span> <span data-ttu-id="970a2-1442">主线程不一定是数组中的索引零。</span><span class="sxs-lookup"><span data-stu-id="970a2-1442">The primary thread is not necessarily at index zero in the array.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException"><span data-ttu-id="970a2-1443">进程没有 <see cref="P:System.Diagnostics.Process.Id" />，或者没有与 <see cref="T:System.Diagnostics.Process" /> 实例关联的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1443">The process does not have an <see cref="P:System.Diagnostics.Process.Id" />, or no process is associated with the <see cref="T:System.Diagnostics.Process" /> instance.</span></span>  
  
<span data-ttu-id="970a2-1444">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-1444">-or-</span></span> 
<span data-ttu-id="970a2-1445">关联进程已退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-1445">The associated process has exited.</span></span></exception>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="process.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="970a2-1446">如果适用，则将进程的名称格式化为字符串，并与父组件类型组合。</span><span class="sxs-lookup"><span data-stu-id="970a2-1446">Formats the process's name as a string, combined with the parent component type, if applicable.</span></span></summary>
        <returns><span data-ttu-id="970a2-1447"><see cref="P:System.Diagnostics.Process.ProcessName" />，与基组件的 <see cref="M:System.Object.ToString" /> 返回值组合。</span><span class="sxs-lookup"><span data-stu-id="970a2-1447">The <see cref="P:System.Diagnostics.Process.ProcessName" />, combined with the base component's <see cref="M:System.Object.ToString" /> return value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="970a2-1448">下面的示例启动记事本的实例。</span><span class="sxs-lookup"><span data-stu-id="970a2-1448">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="970a2-1449">然后，该示例检索并显示关联进程的各种属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-1449">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="970a2-1450">该示例在进程退出时进行检测，并显示该进程的退出代码。</span><span class="sxs-lookup"><span data-stu-id="970a2-1450">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTotalProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-1451">获取此进程的总的处理器时间。</span><span class="sxs-lookup"><span data-stu-id="970a2-1451">Gets the total processor time for this process.</span></span></summary>
        <value><span data-ttu-id="970a2-1452"><see cref="T:System.TimeSpan" />，它指示关联进程使用 CPU 的时间。</span><span class="sxs-lookup"><span data-stu-id="970a2-1452">A <see cref="T:System.TimeSpan" /> that indicates the amount of time that the associated process has spent utilizing the CPU.</span></span> <span data-ttu-id="970a2-1453">此值是 <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> 和 <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> 的和。</span><span class="sxs-lookup"><span data-stu-id="970a2-1453">This value is the sum of the <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> and the <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="970a2-1454">下面的示例启动记事本的实例。</span><span class="sxs-lookup"><span data-stu-id="970a2-1454">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="970a2-1455">然后，该示例检索并显示关联进程的各种属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-1455">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="970a2-1456">该示例在进程退出时进行检测，并显示该进程的退出代码。</span><span class="sxs-lookup"><span data-stu-id="970a2-1456">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="970a2-1457">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-1457">You are attempting to access the <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="970a2-1458">此属性仅可用于本地计算机上运行的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1458">This property is available only for processes that are running on the local computer.</span></span></exception>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessUserProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-1459">获取此进程的用户处理器时间。</span><span class="sxs-lookup"><span data-stu-id="970a2-1459">Gets the user processor time for this process.</span></span></summary>
        <value><span data-ttu-id="970a2-1460"><see cref="T:System.TimeSpan" />，它指示关联进程在该进程的应用程序部分内(而不是在操作系统内核中)运行代码所用的时间。</span><span class="sxs-lookup"><span data-stu-id="970a2-1460">A <see cref="T:System.TimeSpan" /> that indicates the amount of time that the associated process has spent running code inside the application portion of the process (not inside the operating system core).</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="970a2-1461">下面的示例启动记事本的实例。</span><span class="sxs-lookup"><span data-stu-id="970a2-1461">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="970a2-1462">然后，该示例检索并显示关联进程的各种属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-1462">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="970a2-1463">该示例在进程退出时进行检测，并显示该进程的退出代码。</span><span class="sxs-lookup"><span data-stu-id="970a2-1463">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="970a2-1464">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-1464">You are attempting to access the <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="970a2-1465">此属性仅可用于本地计算机上运行的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1465">This property is available only for processes that are running on the local computer.</span></span></exception>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize : int" Usage="System.Diagnostics.Process.VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-1466">获取进程的虚拟内存大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-1466">Gets the size of the process's virtual memory, in bytes.</span></span></summary>
        <value><span data-ttu-id="970a2-1467">关联进程请求的虚拟内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-1467">The amount of virtual memory, in bytes, that the associated process has requested.</span></span></value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-1468">获取为关联进程分配的虚拟内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-1468">Gets the amount of the virtual memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="970a2-1469">为关联进程分配的虚拟内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-1469">The amount of virtual memory, in bytes, allocated for the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-1470">此属性返回的值表示进程使用的虚拟内存的当前大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-1470">The value returned by this property represents the current size of virtual memory used by the process, in bytes.</span></span> <span data-ttu-id="970a2-1471">操作系统将每个进程的虚拟地址空间映射到物理内存中加载的页，或映射到磁盘上的虚拟内存分页文件中存储的页。</span><span class="sxs-lookup"><span data-stu-id="970a2-1471">The operating system maps the virtual address space for each process either to pages loaded in physical memory, or to pages stored in the virtual memory paging file on disk.</span></span>  
  
 <span data-ttu-id="970a2-1472">此属性可用于监视包含32位处理器或64位处理器的计算机上的内存使用情况。</span><span class="sxs-lookup"><span data-stu-id="970a2-1472">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="970a2-1473">属性值等效于进程的**虚拟字节**性能计数器。</span><span class="sxs-lookup"><span data-stu-id="970a2-1473">The property value is equivalent to the **Virtual Bytes** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-1474">下面的代码示例启动记事本应用程序的实例。</span><span class="sxs-lookup"><span data-stu-id="970a2-1474">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="970a2-1475">然后，该示例检索并显示关联进程的各种属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-1475">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="970a2-1476">该示例在进程退出时进行检测，并显示其退出代码和高峰内存统计信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-1476">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="970a2-1477">设置等待关联进程退出的时间段，并在该段时间结束前或该进程退出前，阻止当前线程执行。</span><span class="sxs-lookup"><span data-stu-id="970a2-1477">Sets the period of time to wait for the associated process to exit, and blocks the current thread of execution until the time has elapsed or the process has exited.</span></span> <span data-ttu-id="970a2-1478">若要避免妨碍当前线程，请使用 <see cref="E:System.Diagnostics.Process.Exited" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1478">To avoid blocking the current thread, use the <see cref="E:System.Diagnostics.Process.Exited" /> event.</span></span>  
  
<span data-ttu-id="970a2-1479">有关代码示例，请参阅 <see cref="P:System.Diagnostics.Process.StandardError" /> 和 <see cref="P:System.Diagnostics.Process.ExitCode" /> 属性参考页。</span><span class="sxs-lookup"><span data-stu-id="970a2-1479">For code examples, see the <see cref="P:System.Diagnostics.Process.StandardError" /> and the <see cref="P:System.Diagnostics.Process.ExitCode" /> property reference pages.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : unit -&gt; unit" Usage="process.WaitForExit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="970a2-1480">指示 <see cref="T:System.Diagnostics.Process" /> 组件无限期地等待关联进程退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-1480">Instructs the <see cref="T:System.Diagnostics.Process" /> component to wait indefinitely for the associated process to exit.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-1481"><xref:System.Diagnostics.Process.WaitForExit> 使当前线程等待，直到关联进程终止。</span><span class="sxs-lookup"><span data-stu-id="970a2-1481"><xref:System.Diagnostics.Process.WaitForExit> makes the current thread wait until the associated process terminates.</span></span>  <span data-ttu-id="970a2-1482">在进程上调用所有其他方法之后，应调用此方法。</span><span class="sxs-lookup"><span data-stu-id="970a2-1482">It should be called after all other methods are called on the process.</span></span> <span data-ttu-id="970a2-1483">若要避免妨碍当前线程，请使用 <xref:System.Diagnostics.Process.Exited> 事件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1483">To avoid blocking the current thread, use the <xref:System.Diagnostics.Process.Exited> event.</span></span>  
  
 <span data-ttu-id="970a2-1484">此方法指示 <xref:System.Diagnostics.Process> 组件等待无限长的时间，以便进程和事件处理程序退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-1484">This method instructs the <xref:System.Diagnostics.Process> component to wait an infinite amount of time for the process and event handlers to exit.</span></span> <span data-ttu-id="970a2-1485">这可能导致应用程序停止响应。</span><span class="sxs-lookup"><span data-stu-id="970a2-1485">This can cause an application to stop responding.</span></span> <span data-ttu-id="970a2-1486">例如，如果对具有用户界面的进程调用 <xref:System.Diagnostics.Process.CloseMainWindow%2A>，则在将进程写入从不进入其消息循环的情况下，将不会处理对操作系统的终止关联进程的请求。</span><span class="sxs-lookup"><span data-stu-id="970a2-1486">For example, if you call <xref:System.Diagnostics.Process.CloseMainWindow%2A> for a process that has a user interface, the request to the operating system to terminate the associated process might not be handled if the process is written to never enter its message loop.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-1487">在 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 及更早版本中，<xref:System.Diagnostics.Process.WaitForExit> 重载等待 <xref:System.Int32.MaxValue> 毫秒（约24天），而不是无限期等待。</span><span class="sxs-lookup"><span data-stu-id="970a2-1487">In the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] and earlier versions, the <xref:System.Diagnostics.Process.WaitForExit> overload waited for <xref:System.Int32.MaxValue> milliseconds (approximately 24 days), not indefinitely.</span></span> <span data-ttu-id="970a2-1488">此外，如果已达到完全 <xref:System.Int32.MaxValue> 时间，则以前的版本不会等待事件处理程序退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-1488">Also, previous versions did not wait for the event handlers to exit if the full <xref:System.Int32.MaxValue> time was reached.</span></span>  
  
 <span data-ttu-id="970a2-1489">此重载确保所有处理都已完成，包括处理重定向标准输出的异步事件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1489">This overload ensures that all processing has been completed, including the handling of asynchronous events for redirected standard output.</span></span> <span data-ttu-id="970a2-1490">在将标准输出重定向到异步事件处理程序时，应在调用 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> 重载后使用此重载。</span><span class="sxs-lookup"><span data-stu-id="970a2-1490">You should use this overload after a call to the <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> overload when standard output has been redirected to asynchronous event handlers.</span></span>  
  
 <span data-ttu-id="970a2-1491">当关联进程退出时（即，当操作系统通过正常或异常终止关闭时），系统会存储有关进程的管理信息，并返回到已调用 <xref:System.Diagnostics.Process.WaitForExit>的组件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1491">When an associated process exits (that is, when it is shut down by the operation system through a normal or abnormal termination), the system stores administrative information about the process and returns to the component that had called <xref:System.Diagnostics.Process.WaitForExit>.</span></span> <span data-ttu-id="970a2-1492">然后，<xref:System.Diagnostics.Process> 组件可以通过使用退出过程的 <xref:System.Diagnostics.Process.Handle%2A> 来访问包含 <xref:System.Diagnostics.Process.ExitTime%2A>的信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-1492">The <xref:System.Diagnostics.Process> component can then access the information, which includes the <xref:System.Diagnostics.Process.ExitTime%2A>, by using the <xref:System.Diagnostics.Process.Handle%2A> to the exited process.</span></span>  
  
 <span data-ttu-id="970a2-1493">由于关联进程已退出，因此该组件的 <xref:System.Diagnostics.Process.Handle%2A> 属性不再指向现有进程资源。</span><span class="sxs-lookup"><span data-stu-id="970a2-1493">Because the associated process has exited, the <xref:System.Diagnostics.Process.Handle%2A> property of the component no longer points to an existing process resource.</span></span> <span data-ttu-id="970a2-1494">相反，句柄只能用来访问操作系统有关进程资源的信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-1494">Instead, the handle can be used only to access the operating system's information about the process resource.</span></span> <span data-ttu-id="970a2-1495">系统会注意到未由 <xref:System.Diagnostics.Process> 组件发布的已退出进程的句柄，因此它会将 <xref:System.Diagnostics.Process.ExitTime%2A> 和 <xref:System.Diagnostics.Process.Handle%2A> 信息保留在内存中，直到 <xref:System.Diagnostics.Process> 组件专门释放资源。</span><span class="sxs-lookup"><span data-stu-id="970a2-1495">The system is aware of handles to exited processes that have not been released by <xref:System.Diagnostics.Process> components, so it keeps the <xref:System.Diagnostics.Process.ExitTime%2A> and <xref:System.Diagnostics.Process.Handle%2A> information in memory until the <xref:System.Diagnostics.Process> component specifically frees the resources.</span></span> <span data-ttu-id="970a2-1496">出于此原因，无论何时为 <xref:System.Diagnostics.Process> 实例调用 <xref:System.Diagnostics.Process.Start%2A>，当关联进程终止并且不再需要有关其的任何管理信息时，请调用 <xref:System.Diagnostics.Process.Close%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-1496">For this reason, any time you call <xref:System.Diagnostics.Process.Start%2A> for a <xref:System.Diagnostics.Process> instance, call <xref:System.Diagnostics.Process.Close%2A> when the associated process has terminated and you no longer need any administrative information about it.</span></span> <span data-ttu-id="970a2-1497"><xref:System.Diagnostics.Process.Close%2A> 释放分配给退出进程的内存。</span><span class="sxs-lookup"><span data-stu-id="970a2-1497"><xref:System.Diagnostics.Process.Close%2A> frees the memory allocated to the exited process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-1498">请参阅 <xref:System.Diagnostics.Process.StandardError%2A> 属性参考 "页的" 备注 "部分。</span><span class="sxs-lookup"><span data-stu-id="970a2-1498">See the Remarks section of the <xref:System.Diagnostics.Process.StandardError%2A> property reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="970a2-1499">无法访问等待设置。</span><span class="sxs-lookup"><span data-stu-id="970a2-1499">The wait setting could not be accessed.</span></span></exception>
        <exception cref="T:System.SystemException"><span data-ttu-id="970a2-1500">尚未设置进程 <see cref="P:System.Diagnostics.Process.Id" />，而且不存在可从其确定 <see cref="P:System.Diagnostics.Process.Id" /> 属性的 <see cref="P:System.Diagnostics.Process.Handle" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-1500">No process <see cref="P:System.Diagnostics.Process.Id" /> has been set, and a <see cref="P:System.Diagnostics.Process.Handle" /> from which the <see cref="P:System.Diagnostics.Process.Id" /> property can be determined does not exist.</span></span>  
  
<span data-ttu-id="970a2-1501">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-1501">-or-</span></span> 
<span data-ttu-id="970a2-1502">没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1502">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span>  
  
<span data-ttu-id="970a2-1503">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-1503">-or-</span></span> 
<span data-ttu-id="970a2-1504">你正尝试为远程计算机上运行的进程调用 <see cref="M:System.Diagnostics.Process.WaitForExit" /> 。</span><span class="sxs-lookup"><span data-stu-id="970a2-1504">You are attempting to call <see cref="M:System.Diagnostics.Process.WaitForExit" /> for a process that is running on a remote computer.</span></span> <span data-ttu-id="970a2-1505">此方法仅对本地计算机上运行的进程可用。</span><span class="sxs-lookup"><span data-stu-id="970a2-1505">This method is available only for processes that are running on the local computer.</span></span></exception>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : int -&gt; bool" Usage="process.WaitForExit milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds"><span data-ttu-id="970a2-1506">等待关联进程退出的时间(以毫秒为单位)。</span><span class="sxs-lookup"><span data-stu-id="970a2-1506">The amount of time, in milliseconds, to wait for the associated process to exit.</span></span> <span data-ttu-id="970a2-1507">最大值为 32 位整数的最大可能值，这对于操作系统而言表示无限大。</span><span class="sxs-lookup"><span data-stu-id="970a2-1507">The maximum is the largest possible value of a 32-bit integer, which represents infinity to the operating system.</span></span></param>
        <summary><span data-ttu-id="970a2-1508">指示 <see cref="T:System.Diagnostics.Process" /> 组件在指定的毫秒数内等待关联进程退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-1508">Instructs the <see cref="T:System.Diagnostics.Process" /> component to wait the specified number of milliseconds for the associated process to exit.</span></span></summary>
        <returns><span data-ttu-id="970a2-1509">如果关联进程已退出，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-1509"><see langword="true" /> if the associated process has exited; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-1510"><xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> 使当前线程等待，直到关联进程终止。</span><span class="sxs-lookup"><span data-stu-id="970a2-1510"><xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> makes the current thread wait until the associated process terminates.</span></span> <span data-ttu-id="970a2-1511">在进程上调用所有其他方法之后，应调用此方法。</span><span class="sxs-lookup"><span data-stu-id="970a2-1511">It should be called after all other methods are called on the process.</span></span> <span data-ttu-id="970a2-1512">若要避免妨碍当前线程，请使用 <xref:System.Diagnostics.Process.Exited> 事件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1512">To avoid blocking the current thread, use the <xref:System.Diagnostics.Process.Exited> event.</span></span>  
  
 <span data-ttu-id="970a2-1513">此方法指示 <xref:System.Diagnostics.Process> 组件等待一定的时间，以便进程退出。</span><span class="sxs-lookup"><span data-stu-id="970a2-1513">This method instructs the <xref:System.Diagnostics.Process> component to wait a finite amount of time for the process to exit.</span></span> <span data-ttu-id="970a2-1514">如果在间隔结束时关联的进程未退出，因为终止请求被拒绝，`false` 将返回到调用过程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1514">If the associated process does not exit by the end of the interval because the request to terminate is denied, `false` is returned to the calling procedure.</span></span> <span data-ttu-id="970a2-1515">您可以为 `milliseconds`指定 <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>，<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> 将与 <xref:System.Diagnostics.Process.WaitForExit> 重载的行为相同。</span><span class="sxs-lookup"><span data-stu-id="970a2-1515">You can specify <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for `milliseconds`, and <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> will behave the same as the <xref:System.Diagnostics.Process.WaitForExit> overload.</span></span> <span data-ttu-id="970a2-1516">如果将0（零）传递给方法，则它仅在进程已退出时返回 `true`;否则，它会立即返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="970a2-1516">If you pass 0 (zero) to the method, it returns `true` only if the process has already exited; otherwise, it immediately returns `false`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="970a2-1517">在 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 及更早版本中，如果 `milliseconds` 为-1，<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> 重载将等待 <xref:System.Int32.MaxValue> 毫秒（约24天），而不是无限期等待。</span><span class="sxs-lookup"><span data-stu-id="970a2-1517">In the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] and earlier versions, if `milliseconds` was -1, the <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> overload waited for <xref:System.Int32.MaxValue> milliseconds (approximately 24 days), not indefinitely.</span></span>  
  
 <span data-ttu-id="970a2-1518">将标准输出重定向到异步事件处理程序后，在此方法返回时输出处理可能不会完成。</span><span class="sxs-lookup"><span data-stu-id="970a2-1518">When standard output has been redirected to asynchronous event handlers, it is possible that output processing will not have completed when this method returns.</span></span> <span data-ttu-id="970a2-1519">若要确保异步事件处理已完成，请在从此重载接收到 `true` 之后调用不带任何参数的 <xref:System.Diagnostics.Process.WaitForExit> 重载。</span><span class="sxs-lookup"><span data-stu-id="970a2-1519">To ensure that asynchronous event handling has been completed, call the <xref:System.Diagnostics.Process.WaitForExit> overload that takes no parameter after receiving a `true` from this overload.</span></span> <span data-ttu-id="970a2-1520">若要帮助确保在 Windows 窗体应用程序中正确地处理 <xref:System.Diagnostics.Process.Exited> 事件，请设置 <xref:System.Diagnostics.Process.SynchronizingObject%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-1520">To help ensure that the <xref:System.Diagnostics.Process.Exited> event is handled correctly in Windows Forms applications, set the <xref:System.Diagnostics.Process.SynchronizingObject%2A> property.</span></span>  
  
 <span data-ttu-id="970a2-1521">当关联进程退出时（由操作系统通过正常或异常终止关闭），系统会存储有关进程的管理信息，并返回到已调用 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>的组件。</span><span class="sxs-lookup"><span data-stu-id="970a2-1521">When an associated process exits (is shut down by the operating system through a normal or abnormal termination), the system stores administrative information about the process and returns to the component that had called <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>.</span></span> <span data-ttu-id="970a2-1522">然后，<xref:System.Diagnostics.Process> 组件可以通过使用退出过程的 <xref:System.Diagnostics.Process.Handle%2A> 来访问包含 <xref:System.Diagnostics.Process.ExitTime%2A>的信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-1522">The <xref:System.Diagnostics.Process> component can then access the information, which includes the <xref:System.Diagnostics.Process.ExitTime%2A>, by using the <xref:System.Diagnostics.Process.Handle%2A> to the exited process.</span></span>  
  
 <span data-ttu-id="970a2-1523">由于关联进程已退出，因此该组件的 <xref:System.Diagnostics.Process.Handle%2A> 属性不再指向现有进程资源。</span><span class="sxs-lookup"><span data-stu-id="970a2-1523">Because the associated process has exited, the <xref:System.Diagnostics.Process.Handle%2A> property of the component no longer points to an existing process resource.</span></span> <span data-ttu-id="970a2-1524">相反，句柄只能用来访问操作系统有关进程资源的信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-1524">Instead, the handle can be used only to access the operating system's information about the process resource.</span></span> <span data-ttu-id="970a2-1525">系统会注意到未由 <xref:System.Diagnostics.Process> 组件发布的已退出进程的句柄，因此它会将 <xref:System.Diagnostics.Process.ExitTime%2A> 和 <xref:System.Diagnostics.Process.Handle%2A> 信息保留在内存中，直到 <xref:System.Diagnostics.Process> 组件专门释放资源。</span><span class="sxs-lookup"><span data-stu-id="970a2-1525">The system is aware of handles to exited processes that have not been released by <xref:System.Diagnostics.Process> components, so it keeps the <xref:System.Diagnostics.Process.ExitTime%2A> and <xref:System.Diagnostics.Process.Handle%2A> information in memory until the <xref:System.Diagnostics.Process> component specifically frees the resources.</span></span> <span data-ttu-id="970a2-1526">出于此原因，无论何时为 <xref:System.Diagnostics.Process> 实例调用 <xref:System.Diagnostics.Process.Start%2A>，当关联进程终止并且不再需要有关其的任何管理信息时，请调用 <xref:System.Diagnostics.Process.Close%2A>。</span><span class="sxs-lookup"><span data-stu-id="970a2-1526">For this reason, any time you call <xref:System.Diagnostics.Process.Start%2A> for a <xref:System.Diagnostics.Process> instance, call <xref:System.Diagnostics.Process.Close%2A> when the associated process has terminated and you no longer need any administrative information about it.</span></span> <span data-ttu-id="970a2-1527"><xref:System.Diagnostics.Process.Close%2A> 释放分配给退出进程的内存。</span><span class="sxs-lookup"><span data-stu-id="970a2-1527"><xref:System.Diagnostics.Process.Close%2A> frees the memory allocated to the exited process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-1528">请参阅 <xref:System.Diagnostics.Process.ExitCode%2A> 属性的代码示例。</span><span class="sxs-lookup"><span data-stu-id="970a2-1528">See the code example for the <xref:System.Diagnostics.Process.ExitCode%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="970a2-1529">无法访问等待设置。</span><span class="sxs-lookup"><span data-stu-id="970a2-1529">The wait setting could not be accessed.</span></span></exception>
        <exception cref="T:System.SystemException"><span data-ttu-id="970a2-1530">尚未设置进程 <see cref="P:System.Diagnostics.Process.Id" />，而且不存在可从其确定 <see cref="P:System.Diagnostics.Process.Id" /> 属性的 <see cref="P:System.Diagnostics.Process.Handle" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-1530">No process <see cref="P:System.Diagnostics.Process.Id" /> has been set, and a <see cref="P:System.Diagnostics.Process.Handle" /> from which the <see cref="P:System.Diagnostics.Process.Id" /> property can be determined does not exist.</span></span>  
  
<span data-ttu-id="970a2-1531">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-1531">-or-</span></span> 
<span data-ttu-id="970a2-1532">没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1532">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span>  
  
<span data-ttu-id="970a2-1533">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-1533">-or-</span></span> 
<span data-ttu-id="970a2-1534">你正尝试为远程计算机上运行的进程调用 <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> 。</span><span class="sxs-lookup"><span data-stu-id="970a2-1534">You are attempting to call <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> for a process that is running on a remote computer.</span></span> <span data-ttu-id="970a2-1535">此方法仅对本地计算机上运行的进程可用。</span><span class="sxs-lookup"><span data-stu-id="970a2-1535">This method is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="970a2-1536"><paramref name="milliseconds" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</span><span class="sxs-lookup"><span data-stu-id="970a2-1536"><paramref name="milliseconds" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WaitForExitAsync (System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WaitForExitAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExitAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExitAsync (Optional cancellationToken As CancellationToken = null) As Task" />
      <MemberSignature Language="F#" Value="member this.WaitForExitAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="process.WaitForExitAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><span data-ttu-id="970a2-1537">用于取消异步操作的可选令牌。</span><span class="sxs-lookup"><span data-stu-id="970a2-1537">An optional token to cancel the asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="970a2-1538">指示进程组件等待关联进程退出，或指示等待 <paramref name="cancellationToken" /> 被取消。</span><span class="sxs-lookup"><span data-stu-id="970a2-1538">Instructs the process component to wait for the associated process to exit, or for the <paramref name="cancellationToken" /> to be cancelled.</span></span></summary>
        <returns><span data-ttu-id="970a2-1539">将在已退出进程、已请求取消或出现错误时完成的任务。</span><span class="sxs-lookup"><span data-stu-id="970a2-1539">A task that will complete when the process has exited, cancellation has been requested, or an error occurs.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="970a2-1540">调用此方法会将 <xref:System.Diagnostics.Process.EnableRaisingEvents> 设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="970a2-1540">Calling this method will set <xref:System.Diagnostics.Process.EnableRaisingEvents> to `true`.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="970a2-1541">使 <see cref="T:System.Diagnostics.Process" /> 组件等待关联进程进入空闲状态。</span><span class="sxs-lookup"><span data-stu-id="970a2-1541">Causes the <see cref="T:System.Diagnostics.Process" /> component to wait for the associated process to enter an idle state.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : unit -&gt; bool" Usage="process.WaitForInputIdle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="970a2-1542">使 <see cref="T:System.Diagnostics.Process" /> 组件无限期地等待关联进程进入空闲状态。</span><span class="sxs-lookup"><span data-stu-id="970a2-1542">Causes the <see cref="T:System.Diagnostics.Process" /> component to wait indefinitely for the associated process to enter an idle state.</span></span> <span data-ttu-id="970a2-1543">此重载仅适用于具有用户界面并因此具有消息循环的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1543">This overload applies only to processes with a user interface and, therefore, a message loop.</span></span></summary>
        <returns><span data-ttu-id="970a2-1544">如果关联进程已经达到空闲状态，则为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-1544"><see langword="true" /> if the associated process has reached an idle state.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-1545">使用 <xref:System.Diagnostics.Process.WaitForInputIdle> 强制对应用程序进行处理，直到消息循环返回到空闲状态。</span><span class="sxs-lookup"><span data-stu-id="970a2-1545">Use <xref:System.Diagnostics.Process.WaitForInputIdle> to force the processing of your application to wait until the message loop has returned to the idle state.</span></span> <span data-ttu-id="970a2-1546">如果执行具有用户界面的进程，则每次操作系统将 Windows 消息发送到该进程时，其消息循环都会执行。</span><span class="sxs-lookup"><span data-stu-id="970a2-1546">When a process with a user interface is executing, its message loop executes every time a Windows message is sent to the process by the operating system.</span></span> <span data-ttu-id="970a2-1547">然后，该进程返回到消息循环。</span><span class="sxs-lookup"><span data-stu-id="970a2-1547">The process then returns to the message loop.</span></span> <span data-ttu-id="970a2-1548">如果进程正在等待消息循环内的消息，则称该进程处于空闲状态。</span><span class="sxs-lookup"><span data-stu-id="970a2-1548">A process is said to be in an idle state when it is waiting for messages inside of a message loop.</span></span> <span data-ttu-id="970a2-1549">此状态非常有用，例如，当应用程序需要等待启动进程完成创建其主窗口之前，应用程序才能与该窗口通信。</span><span class="sxs-lookup"><span data-stu-id="970a2-1549">This state is useful, for example, when your application needs to wait for a starting process to finish creating its main window before the application communicates with that window.</span></span>  
  
 <span data-ttu-id="970a2-1550">如果进程没有消息循环，<xref:System.Diagnostics.Process.WaitForInputIdle> 会引发 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="970a2-1550">If a process does not have a message loop, <xref:System.Diagnostics.Process.WaitForInputIdle> throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="970a2-1551"><xref:System.Diagnostics.Process.WaitForInputIdle> 重载指示 <xref:System.Diagnostics.Process> 组件无限期地等待进程在消息循环中处于空闲状态。</span><span class="sxs-lookup"><span data-stu-id="970a2-1551">The <xref:System.Diagnostics.Process.WaitForInputIdle> overload instructs the <xref:System.Diagnostics.Process> component to wait indefinitely for the process to become idle in the message loop.</span></span> <span data-ttu-id="970a2-1552">此指令可能导致应用程序停止响应。</span><span class="sxs-lookup"><span data-stu-id="970a2-1552">This instruction can cause an application to stop responding.</span></span> <span data-ttu-id="970a2-1553">例如，如果将进程编写为始终立即退出其消息循环，如代码片段 `while(true)`中所示。</span><span class="sxs-lookup"><span data-stu-id="970a2-1553">For example, if the process is written to always exit its message loop immediately, as in the code fragment `while(true)`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-1554">进程不具有图形界面。</span><span class="sxs-lookup"><span data-stu-id="970a2-1554">The process does not have a graphical interface.</span></span>  
  
<span data-ttu-id="970a2-1555">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-1555">-or-</span></span> 
<span data-ttu-id="970a2-1556">发生未知错误。</span><span class="sxs-lookup"><span data-stu-id="970a2-1556">An unknown error occurred.</span></span> <span data-ttu-id="970a2-1557">进程无法进入空闲状态。</span><span class="sxs-lookup"><span data-stu-id="970a2-1557">The process failed to enter an idle state.</span></span>  
  
<span data-ttu-id="970a2-1558">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-1558">-or-</span></span> 
<span data-ttu-id="970a2-1559">已经退出该进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1559">The process has already exited.</span></span>  
  
<span data-ttu-id="970a2-1560">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-1560">-or-</span></span> 
<span data-ttu-id="970a2-1561">没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1561">No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span></exception>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : int -&gt; bool" Usage="process.WaitForInputIdle milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="milliseconds"><span data-ttu-id="970a2-1562">1 到 <see cref="F:System.Int32.MaxValue" /> 的值以毫秒为单位指定了等待关联进程变为空闲状态的时间量。</span><span class="sxs-lookup"><span data-stu-id="970a2-1562">A value of 1 to <see cref="F:System.Int32.MaxValue" /> that specifies the amount of time, in milliseconds, to wait for the associated process to become idle.</span></span> <span data-ttu-id="970a2-1563">0 值指定立即返回，而 -1 值则指定无限期等待。</span><span class="sxs-lookup"><span data-stu-id="970a2-1563">A value of 0 specifies an immediate return, and a value of -1 specifies an infinite wait.</span></span></param>
        <summary><span data-ttu-id="970a2-1564">使 <see cref="T:System.Diagnostics.Process" /> 组件在指定的毫秒数内等待关联进程进入空闲状态。</span><span class="sxs-lookup"><span data-stu-id="970a2-1564">Causes the <see cref="T:System.Diagnostics.Process" /> component to wait the specified number of milliseconds for the associated process to enter an idle state.</span></span> <span data-ttu-id="970a2-1565">此重载仅适用于具有用户界面并因此具有消息循环的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1565">This overload applies only to processes with a user interface and, therefore, a message loop.</span></span></summary>
        <returns><span data-ttu-id="970a2-1566">如果关联进程已经达到空闲状态，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="970a2-1566"><see langword="true" /> if the associated process has reached an idle state; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-1567">使用 <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> 强制对应用程序进行处理，直到消息循环返回到空闲状态。</span><span class="sxs-lookup"><span data-stu-id="970a2-1567">Use <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> to force the processing of your application to wait until the message loop has returned to the idle state.</span></span> <span data-ttu-id="970a2-1568">如果执行具有用户界面的进程，则每次操作系统将 Windows 消息发送到该进程时，其消息循环都会执行。</span><span class="sxs-lookup"><span data-stu-id="970a2-1568">When a process with a user interface is executing, its message loop executes every time a Windows message is sent to the process by the operating system.</span></span> <span data-ttu-id="970a2-1569">然后，该进程返回到消息循环。</span><span class="sxs-lookup"><span data-stu-id="970a2-1569">The process then returns to the message loop.</span></span> <span data-ttu-id="970a2-1570">如果进程正在等待消息循环内的消息，则称该进程处于空闲状态。</span><span class="sxs-lookup"><span data-stu-id="970a2-1570">A process is said to be in an idle state when it is waiting for messages inside of a message loop.</span></span> <span data-ttu-id="970a2-1571">此状态非常有用，例如，当应用程序需要等待启动进程完成创建其主窗口之前，应用程序才能与该窗口通信。</span><span class="sxs-lookup"><span data-stu-id="970a2-1571">This state is useful, for example, when your application needs to wait for a starting process to finish creating its main window before the application communicates with that window.</span></span>  
  
 <span data-ttu-id="970a2-1572">如果进程没有消息循环，<xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> 会引发 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="970a2-1572">If a process does not have a message loop, <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="970a2-1573"><xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> 重载指示 <xref:System.Diagnostics.Process> 组件等待一段有限的时间，以便进程在消息循环中处于空闲状态。</span><span class="sxs-lookup"><span data-stu-id="970a2-1573">The <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> overload instructs the <xref:System.Diagnostics.Process> component to wait a finite amount of time for the process to become idle in the message loop.</span></span> <span data-ttu-id="970a2-1574">如果在间隔结束时关联的进程未处于空闲状态，因为循环仍在处理消息，`false` 将返回到调用过程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1574">If the associated process has not become idle by the end of the interval because the loop is still processing messages, `false` is returned to the calling procedure.</span></span>  
  
 <span data-ttu-id="970a2-1575">有关处理事件的详细信息，请参阅[处理和引发事件](/dotnet/standard/events/)。</span><span class="sxs-lookup"><span data-stu-id="970a2-1575">For more information about handling events, see [Handling and Raising Events](/dotnet/standard/events/).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="970a2-1576">进程不具有图形界面。</span><span class="sxs-lookup"><span data-stu-id="970a2-1576">The process does not have a graphical interface.</span></span>  
  
<span data-ttu-id="970a2-1577">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-1577">-or-</span></span> 
<span data-ttu-id="970a2-1578">发生未知错误。</span><span class="sxs-lookup"><span data-stu-id="970a2-1578">An unknown error occurred.</span></span> <span data-ttu-id="970a2-1579">进程无法进入空闲状态。</span><span class="sxs-lookup"><span data-stu-id="970a2-1579">The process failed to enter an idle state.</span></span>  
  
<span data-ttu-id="970a2-1580">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-1580">-or-</span></span> 
<span data-ttu-id="970a2-1581">已经退出该进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1581">The process has already exited.</span></span>  
  
<span data-ttu-id="970a2-1582">- 或 -</span><span class="sxs-lookup"><span data-stu-id="970a2-1582">-or-</span></span> 
<span data-ttu-id="970a2-1583">没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</span><span class="sxs-lookup"><span data-stu-id="970a2-1583">No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span></exception>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int" Usage="System.Diagnostics.Process.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-1584">获取关联进程的物理内存使用量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-1584">Gets the associated process's physical memory usage, in bytes.</span></span></summary>
        <value><span data-ttu-id="970a2-1585">关联进程当前使用的物理内存总量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-1585">The total amount of physical memory the associated process is using, in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-1586">此属性返回的值表示进程使用的工作集内存的当前大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-1586">The value returned by this property represents the current size of working set memory used by the process, in bytes.</span></span> <span data-ttu-id="970a2-1587">进程的工作集是当前对物理 RAM 内存中的进程可见的内存页集。</span><span class="sxs-lookup"><span data-stu-id="970a2-1587">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="970a2-1588">这些页是常驻的，可供应用程序使用，而不会触发页面错误。</span><span class="sxs-lookup"><span data-stu-id="970a2-1588">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="970a2-1589">工作集包括共享数据和私人数据。</span><span class="sxs-lookup"><span data-stu-id="970a2-1589">The working set includes both shared and private data.</span></span> <span data-ttu-id="970a2-1590">共享数据包括包含进程执行的所有说明的页面，包括进程模块和系统库。</span><span class="sxs-lookup"><span data-stu-id="970a2-1590">The shared data includes the pages that contain all the instructions that the process executes, including the process modules and the system libraries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-1591">下面的示例启动记事本的实例。</span><span class="sxs-lookup"><span data-stu-id="970a2-1591">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="970a2-1592">然后，该示例检索并显示关联进程的各种属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-1592">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="970a2-1593">该示例在进程退出时进行检测，并显示进程的退出代码。</span><span class="sxs-lookup"><span data-stu-id="970a2-1593">The example detects when the process exits, and displays the process' exit code.</span></span>  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet64 : int64" Usage="System.Diagnostics.Process.WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="970a2-1594">获取为关联的进程分配的物理内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-1594">Gets the amount of physical memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="970a2-1595">为关的进程分配的物理内存量(以字节为单位)。</span><span class="sxs-lookup"><span data-stu-id="970a2-1595">The amount of physical memory, in bytes, allocated for the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="970a2-1596">此属性返回的值表示进程使用的工作集内存的当前大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="970a2-1596">The value returned by this property represents the current size of working set memory used by the process, in bytes.</span></span> <span data-ttu-id="970a2-1597">进程的工作集是当前对物理 RAM 内存中的进程可见的内存页集。</span><span class="sxs-lookup"><span data-stu-id="970a2-1597">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="970a2-1598">这些页是常驻的，可供应用程序使用，而不会触发页面错误。</span><span class="sxs-lookup"><span data-stu-id="970a2-1598">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="970a2-1599">工作集包括共享数据和私人数据。</span><span class="sxs-lookup"><span data-stu-id="970a2-1599">The working set includes both shared and private data.</span></span> <span data-ttu-id="970a2-1600">共享数据包括包含进程执行的所有说明的页面，包括进程模块和系统库中的说明。</span><span class="sxs-lookup"><span data-stu-id="970a2-1600">The shared data includes the pages that contain all the instructions that the process executes, including instructions in the process modules and the system libraries.</span></span>  
  
 <span data-ttu-id="970a2-1601">此属性可用于监视包含32位处理器或64位处理器的计算机上的内存使用情况。</span><span class="sxs-lookup"><span data-stu-id="970a2-1601">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="970a2-1602">属性值等效于进程的**工作集**性能计数器。</span><span class="sxs-lookup"><span data-stu-id="970a2-1602">The property value is equivalent to the **Working Set** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="970a2-1603">下面的代码示例启动记事本应用程序的实例。</span><span class="sxs-lookup"><span data-stu-id="970a2-1603">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="970a2-1604">然后，该示例检索并显示关联进程的各种属性。</span><span class="sxs-lookup"><span data-stu-id="970a2-1604">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="970a2-1605">该示例在进程退出时进行检测，并显示其退出代码和高峰内存统计信息。</span><span class="sxs-lookup"><span data-stu-id="970a2-1605">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>
