<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata><Meta Name="ms.openlocfilehash" Value="28c36fa650f85ead403b657b4a626a81e2e96fb6" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83956197" /></Metadata><TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component, IDisposable" FrameworkAlternate="net-5.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component implements class System.IDisposable" FrameworkAlternate="net-5.0" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component&#xA;Implements IDisposable" FrameworkAlternate="net-5.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component, IDisposable" FrameworkAlternate="net-5.0" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    inherit Component&#xA;    interface IDisposable" FrameworkAlternate="net-5.0" />
  <TypeSignature Language="C#" Value="public class Process : IDisposable" FrameworkAlternate="netcore-1.0;netcore-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.Object implements class System.IDisposable" FrameworkAlternate="netcore-1.0;netcore-1.1" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Implements IDisposable" FrameworkAlternate="netcore-1.0;netcore-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : IDisposable" FrameworkAlternate="netcore-1.0;netcore-1.1" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    interface IDisposable" FrameworkAlternate="netcore-1.0;netcore-1.1" />
  <TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    inherit Component" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Diagnostics.Process" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netcore-1.0;netcore-1.1">System.Object</BaseTypeName>
  </Base>
  <Interfaces>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("ProcessDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供对本地和远程进程的访问权限并使你能够启动和停止本地系统进程。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process> 组件提供对计算机上运行的进程的访问。 最简单的过程是正在运行的应用程序。 线程是操作系统向其分配处理器时间的基本单元。 线程可以执行进程的任何代码部分，包括当前由另一个线程执行的部分。  
  
 <xref:System.Diagnostics.Process> 组件是用于启动、停止、控制和监视应用程序的有用工具。 您可以使用 <xref:System.Diagnostics.Process> 组件获取正在运行的进程的列表，也可以启动新的进程。 <xref:System.Diagnostics.Process> 组件用于访问系统进程。 初始化 <xref:System.Diagnostics.Process> 组件后，可以使用它来获取有关正在运行的进程的信息。 此类信息包括一组线程、已加载的模块（.dll 和 .exe 文件）以及性能信息，如进程正在使用的内存量。  
  
 此类型实现 <xref:System.IDisposable> 接口。 在使用完类型后，您应直接或间接释放类型。 若要直接释放类型，请在 `try`/`finally` 块中调用其 <xref:System.IDisposable.Dispose%2A> 方法。 若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。 有关详细信息，请参阅 <xref:System.IDisposable> 接口主题中的“使用实现 IDisposable 的对象”一节。  
  
> [!NOTE]
>  32位进程无法访问64位进程的模块。 如果尝试从32位进程获取有关64位进程的信息，将会出现 <xref:System.ComponentModel.Win32Exception> 异常。 另一方面，64位进程可以访问32位进程的模块。  
  
 进程组件同时获取有关一组属性的信息。 在 <xref:System.Diagnostics.Process> 组件获取了有关任何组中的一个成员的信息后，它将缓存该组中其他属性的值，而不获取有关组中其他成员的新信息，直到您调用 <xref:System.Diagnostics.Process.Refresh%2A> 方法。 因此，属性值不能保证比最后一次调用 <xref:System.Diagnostics.Process.Refresh%2A> 方法更新。 组细目依赖于操作系统。  
  
 如果在系统中使用引号声明了路径变量，则在启动在该位置找到的任何进程时必须完全限定该路径。 否则，系统将找不到该路径。 例如，如果 `c:\mypath` 不在你的路径中，而你使用引号添加它： `path = %path%;"c:\mypath"`，则在启动时必须完全限定 `c:\mypath` 中的任何进程。  
  
 系统进程通过其进程标识符在系统上唯一标识。 与许多 Windows 资源一样，进程也由其句柄标识，该进程在计算机上可能不唯一。 句柄是资源标识符的一般术语。 操作系统将保留进程句柄，该句柄通过 <xref:System.Diagnostics.Process> 组件的 <xref:System.Diagnostics.Process.Handle%2A> 属性访问，即使进程已退出也是如此。 因此，你可以获取进程的管理信息，例如 <xref:System.Diagnostics.Process.ExitCode%2A> （通常为零表示成功或非零错误代码）和 <xref:System.Diagnostics.Process.ExitTime%2A>。 句柄是一个极其宝贵的资源，因此泄漏句柄比泄漏内存更 virulent。  
  
> [!NOTE]
>  此类包含应用于所有成员的类级别的链接要求和继承要求。 当直接调用方或派生类不具有完全信任权限时，将引发 <xref:System.Security.SecurityException>。 有关安全要求的详细信息，请参阅[链接需求](/dotnet/framework/misc/link-demands)。  
  
<a name="Core"></a>   
## <a name="net_core-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] 说明  
 在 .NET Framework 中，<xref:System.Diagnostics.Process> 类在默认情况下使用 <xref:System.Console> 编码，通常为输入、输出和错误流的代码页编码。 例如，在区域性为英语（美国）的系统上，代码页437是 <xref:System.Console> 类的默认编码。 但 [!INCLUDE[net_core](~/includes/net-core-md.md)] 只能提供这些编码的有限子集。 如果是这种情况，它将使用 <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> 作为默认编码。  
  
 如果 <xref:System.Diagnostics.Process> 对象依赖于特定的代码页编码，仍可以在调用任何 <xref:System.Diagnostics.Process> 方法*之前*执行以下操作，使其可用：  
  
1.  将对代码页程序集的引用添加到你的项目。  
  
2.  检索 <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> 属性中的 <xref:System.Text.EncodingProvider> 对象。  
  
3.  将 <xref:System.Text.EncodingProvider> 对象传递到 <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> 方法，以使编码提供程序支持的其他编码可用。  
  
 如果在调用任何 <xref:System.Diagnostics.Process> 方法之前已注册了编码提供程序，则 <xref:System.Diagnostics.Process> 类将自动使用默认系统编码，而不是 UTF8。  
  
   
  
## Examples  
 下面的示例使用 <xref:System.Diagnostics.Process> 类的实例来启动进程。  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 下面的示例使用 <xref:System.Diagnostics.Process> 类本身和静态 <xref:System.Diagnostics.Process.Start%2A> 方法来启动进程。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb)]  
  
 下面F#的示例定义了一个 `runProc` 函数，该函数启动进程、捕获所有输出和错误信息，并记录进程已运行的毫秒数。  `runProc` 函数有三个参数：要启动的应用程序的名称、要为应用程序提供的参数以及起始目录。  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 `runProc` 函数的代码由[ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment)编写，并在[Microsoft 公共许可证](https://opensource.org/licenses/ms-pl)下提供。  
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/windowsdesktop/Using-the-NET-Process-Class-d70597ef">使用 .NET 进程类</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Diagnostics.Process" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果未指定 <xref:System.Diagnostics.Process.MachineName%2A> 属性，则默认为本地计算机（"."）。  
  
 有两个选项可用于将新的 <xref:System.Diagnostics.Process> 组件与计算机上的进程相关联。 第一种方法是使用构造函数创建 <xref:System.Diagnostics.Process> 组件、设置 <xref:System.Diagnostics.Process.StartInfo%2A> 属性的相应成员并调用 <xref:System.Diagnostics.Process.Start%2A>，将 <xref:System.Diagnostics.Process> 与新的系统进程相关联。 第二种方法是使用 <xref:System.Diagnostics.Process.GetProcessById%2A> 或 <xref:System.Diagnostics.Process.GetProcesses%2A> 返回值之一将 <xref:System.Diagnostics.Process> 与正在运行的系统进程关联。  
  
 如果你使用 <xref:System.Diagnostics.Process.Start%2A> 方法的 `static` 重载来启动新系统进程，则该方法将创建新的 <xref:System.Diagnostics.Process> 组件并将其与进程关联。  
  
 如果将 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> 属性设置为其默认值，则 `true`，你可以以与使用 Windows `Start` 菜单的 `Run` 对话框相同的方式启动应用程序和文档。 `false`<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> 时，只能启动可执行文件。  
  
 可以通过以下两种方式之一来启动可从命令行调用的可执行文件：设置 <xref:System.Diagnostics.Process.StartInfo%2A> 属性的相应成员并调用不带参数的 <xref:System.Diagnostics.Process.Start%2A> 方法，或通过将相应参数传递到 `static`<xref:System.Diagnostics.Process.Start%2A> 成员。  
  
 您可以通过使用构造函数、静态 <xref:System.Diagnostics.Process.Start%2A> 重载之一或任意 <xref:System.Diagnostics.Process.GetProcessById%2A>、<xref:System.Diagnostics.Process.GetProcesses%2A>或 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 方法创建 <xref:System.Diagnostics.Process> 组件。 完成此操作后，就可以查看关联的进程。 这不是动态视图，当进程属性在内存中更改时，它会自动更新自身。 相反，你必须为组件调用 <xref:System.Diagnostics.Process.Refresh%2A>，以更新应用程序中的 <xref:System.Diagnostics.Process> 属性信息。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.Process.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessBasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程的基本优先级。</summary>
        <value>基本优先级，从关联进程的 <see cref="P:System.Diagnostics.Process.PriorityClass" /> 计算。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 进程的 <xref:System.Diagnostics.Process.BasePriority%2A> 是在关联进程中创建的线程的启动优先级。 你可以通过系统监视器的优先级基准计数器查看有关基本优先级的信息。  
  
 根据所用的时间或其他提升，操作系统可以在进程应置于其他位置时更改基本优先级。  
  
 利用 <xref:System.Diagnostics.Process.BasePriority%2A> 属性，您可以查看分配给进程的启动优先级。 但是，因为它是只读的，所以不能使用 <xref:System.Diagnostics.Process.BasePriority%2A> 来设置进程的优先级。 若要更改优先级，请使用 <xref:System.Diagnostics.Process.PriorityClass%2A> 属性。 使用系统监视器可查看 <xref:System.Diagnostics.Process.BasePriority%2A>，而 <xref:System.Diagnostics.Process.PriorityClass%2A> 则不可见。 可以通过编程方式查看 <xref:System.Diagnostics.Process.BasePriority%2A> 和 <xref:System.Diagnostics.Process.PriorityClass%2A>。 下表显示 <xref:System.Diagnostics.Process.BasePriority%2A> 值和 <xref:System.Diagnostics.Process.PriorityClass%2A> 值之间的关系。  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 下面的示例启动记事本的实例。 然后，该示例检索并显示关联进程的各种属性。 该示例在进程退出时进行检测，并显示该进程的退出代码。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">该进程已退出。  
  
 - 或 -  
  
 尚未启动进程，因此没有进程 ID。</exception>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginErrorReadLine : unit -&gt; unit" Usage="process.BeginErrorReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在应用程序的重定向 <see cref="P:System.Diagnostics.Process.StandardError" /> 流上开始进行异步读取操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardError%2A> 流可以同步或异步读取。 <xref:System.IO.StreamReader.Read%2A>、<xref:System.IO.StreamReader.ReadLine%2A>和 <xref:System.IO.StreamReader.ReadToEnd%2A> 等方法执行进程的错误输出流上的同步读取操作。 在关联的 <xref:System.Diagnostics.Process> 写入其 <xref:System.Diagnostics.Process.StandardError%2A> 流或关闭流之前，这些同步读取操作不会完成。  
  
 与此相反，<xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 会对 <xref:System.Diagnostics.Process.StandardError%2A> 流启动异步读取操作。 此方法将为流输出启用指定的事件处理程序，并立即返回到调用方，当流输出定向到事件处理程序时，该处理程序可以执行其他操作。  
  
 按照以下步骤对 <xref:System.Diagnostics.Process> 的 <xref:System.Diagnostics.Process.StandardError%2A> 执行异步读取操作：  
  
1.  将 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 设置为 `false`。  
  
2.  将 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> 设置为 `true`。  
  
3.  向 <xref:System.Diagnostics.Process.ErrorDataReceived> 事件添加事件处理程序。 事件处理程序必须与 <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> 委托签名匹配。  
  
4.  启动 <xref:System.Diagnostics.Process>。  
  
5.  为 <xref:System.Diagnostics.Process>调用 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>。 此调用启动 <xref:System.Diagnostics.Process.StandardError%2A>上的异步读取操作。  
  
 当异步读取操作开始时，每次关联 <xref:System.Diagnostics.Process> 将一行文本写入其 <xref:System.Diagnostics.Process.StandardError%2A> 流时，将调用事件处理程序。  
  
 可以通过调用 <xref:System.Diagnostics.Process.CancelErrorRead%2A>取消异步读取操作。 读取操作可由调用方或事件处理程序取消。 取消后，可以再次调用 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 以恢复异步读取操作。  
  
> [!NOTE]
>  不能对重定向的流混合使用异步和同步读取操作。 在异步或同步模式下打开 <xref:System.Diagnostics.Process> 的重定向流后，对该流进行的所有进一步读取操作都必须处于相同的模式下。 例如，不要在 <xref:System.Diagnostics.Process.StandardError%2A> 流的 <xref:System.IO.StreamReader.ReadLine%2A> 调用 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>，反之亦然。 但是，可以在不同模式下读取两个不同的流。 例如，可以调用 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>，然后调用 <xref:System.Diagnostics.Process.StandardOutput%2A> 流的 <xref:System.IO.StreamReader.ReadLine%2A>。  
  
   
  
## Examples  
 以下示例使用 `net view` 命令列出远程计算机上可用的网络资源。 用户以命令行参数的形式提供目标计算机名称。 用户还可以提供错误输出的文件名。 该示例收集 net 命令的输出，等待进程完成，然后将输出结果写入控制台。 如果用户提供了可选的错误文件，则该示例会将错误写入文件。  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 属性为 <see langword="false" />。  
  
- 或 - 
<see cref="P:System.Diagnostics.Process.StandardError" /> 流上已在进行异步读取操作。  
  
- 或 - 
同步读取操作已使用 <see cref="P:System.Diagnostics.Process.StandardError" /> 流。</exception>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginOutputReadLine : unit -&gt; unit" Usage="process.BeginOutputReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在应用程序的重定向 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 流上开始进行异步读取操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardOutput%2A> 流可以同步或异步读取。 <xref:System.IO.StreamReader.Read%2A>、<xref:System.IO.StreamReader.ReadLine%2A>和 <xref:System.IO.StreamReader.ReadToEnd%2A> 等方法在进程的输出流上执行同步读取操作。 在关联的 <xref:System.Diagnostics.Process> 写入其 <xref:System.Diagnostics.Process.StandardOutput%2A> 流或关闭流之前，这些同步读取操作不会完成。  
  
 与此相反，<xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 会对 <xref:System.Diagnostics.Process.StandardOutput%2A> 流启动异步读取操作。 此方法将为流输出启用指定的事件处理程序，并立即返回到调用方，当流输出定向到事件处理程序时，该处理程序可以执行其他操作。  
  
 按照以下步骤对 <xref:System.Diagnostics.Process> 的 <xref:System.Diagnostics.Process.StandardOutput%2A> 执行异步读取操作：  
  
1.  将 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 设置为 `false`。  
  
2.  将 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> 设置为 `true`。  
  
3.  向 <xref:System.Diagnostics.Process.OutputDataReceived> 事件添加事件处理程序。 事件处理程序必须与 <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> 委托签名匹配。  
  
4.  启动 <xref:System.Diagnostics.Process>。  
  
5.  为 <xref:System.Diagnostics.Process>调用 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>。 此调用启动 <xref:System.Diagnostics.Process.StandardOutput%2A>上的异步读取操作。  
  
 当异步读取操作开始时，每次关联 <xref:System.Diagnostics.Process> 将一行文本写入其 <xref:System.Diagnostics.Process.StandardOutput%2A> 流时，将调用事件处理程序。  
  
 可以通过调用 <xref:System.Diagnostics.Process.CancelOutputRead%2A>取消异步读取操作。 读取操作可由调用方或事件处理程序取消。 取消后，可以再次调用 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 以恢复异步读取操作。  
  
> [!NOTE]
>  不能对重定向的流混合使用异步和同步读取操作。 在异步或同步模式下打开 <xref:System.Diagnostics.Process> 的重定向流后，对该流进行的所有进一步读取操作都必须处于相同的模式下。 例如，不要在 <xref:System.Diagnostics.Process.StandardOutput%2A> 流的 <xref:System.IO.StreamReader.ReadLine%2A> 调用 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，反之亦然。 但是，可以在不同模式下读取两个不同的流。 例如，可以调用 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，然后调用 <xref:System.Diagnostics.Process.StandardError%2A> 流的 <xref:System.IO.StreamReader.ReadLine%2A>。  
  
   
  
## Examples  
 下面的示例演示如何对 `sort` 命令的重定向 <xref:System.Diagnostics.Process.StandardOutput%2A> 流执行异步读取操作。 `sort` 命令是一种控制台应用程序，用于读取和排序文本输入。  
  
 该示例创建 `SortOutputHandler` 事件处理程序的事件委托，并将其与 <xref:System.Diagnostics.Process.OutputDataReceived> 事件关联。 事件处理程序从重定向的 <xref:System.Diagnostics.Process.StandardOutput%2A> 流接收文本行，设置文本格式，并将文本写入屏幕。  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 属性为 <see langword="false" />。  
  
- 或 - 
<see cref="P:System.Diagnostics.Process.StandardOutput" /> 流上已在进行异步读取操作。  
  
- 或 - 
同步读取操作已使用 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 流。</exception>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberSignature Language="F#" Value="member this.CancelErrorRead : unit -&gt; unit" Usage="process.CancelErrorRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取消在应用程序的重定向 <see cref="P:System.Diagnostics.Process.StandardError" /> 流上执行的异步读取操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 对 <xref:System.Diagnostics.Process.StandardError%2A> 流启动异步读取操作。 <xref:System.Diagnostics.Process.CancelErrorRead%2A> 结束异步读取操作。  
  
 取消后，可以通过再次调用 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 恢复异步读取操作。  
  
 调用 <xref:System.Diagnostics.Process.CancelErrorRead%2A>时，将完成 <xref:System.Diagnostics.Process.StandardError%2A> 的所有正在进行的读取操作，并禁用事件处理程序。 将丢失所有进一步的重定向输出到 <xref:System.Diagnostics.Process.StandardError%2A>。 如果通过调用 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>重新启用事件处理程序，则会恢复异步读取操作。 如果要在恢复异步读取操作之前更改事件处理程序，则必须先删除现有的事件处理程序，然后再添加新的事件处理程序：  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  不能对重定向的 <xref:System.Diagnostics.Process.StandardError%2A> 流混合使用异步和同步读取操作。 在异步或同步模式下打开 <xref:System.Diagnostics.Process> 的重定向流后，对该流进行的所有进一步读取操作都必须处于相同的模式下。 如果取消对 <xref:System.Diagnostics.Process.StandardError%2A> 的异步读取操作，然后需要重新读取流，则必须使用 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 才能恢复异步读取操作。 不要跟随 <xref:System.Diagnostics.Process.CancelErrorRead%2A> 调用 <xref:System.Diagnostics.Process.StandardError%2A> 的同步读取方法，如 <xref:System.IO.StreamReader.Read%2A>、<xref:System.IO.StreamReader.ReadLine%2A>或 <xref:System.IO.StreamReader.ReadToEnd%2A>。  
  
   
  
## Examples  
 下面的示例用用户提供的参数启动 `nmake` 命令。 异步读取错误和输出流;收集的文本行将显示到控制台并写入日志文件。 如果命令输出超过指定的行数，则将取消异步读取操作。  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未针对异步读取操作启用 <see cref="P:System.Diagnostics.Process.StandardError" /> 流。</exception>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberSignature Language="F#" Value="member this.CancelOutputRead : unit -&gt; unit" Usage="process.CancelOutputRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取消在应用程序的重定向 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 流上执行的异步读取操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 对 <xref:System.Diagnostics.Process.StandardOutput%2A> 流启动异步读取操作。 <xref:System.Diagnostics.Process.CancelOutputRead%2A> 结束异步读取操作。  
  
 取消后，可以通过再次调用 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 恢复异步读取操作。  
  
 调用 <xref:System.Diagnostics.Process.CancelOutputRead%2A>时，将完成 <xref:System.Diagnostics.Process.StandardOutput%2A> 的所有正在进行的读取操作，并禁用事件处理程序。 所有进一步的重定向输出到 <xref:System.Diagnostics.Process.StandardOutput%2A> 都保存在一个缓冲区中。 如果使用对 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>重新启用事件处理程序，则会将保存的输出发送到事件处理程序，并恢复异步读取操作。 如果要在恢复异步读取操作之前更改事件处理程序，则必须先删除现有的事件处理程序，然后再添加新的事件处理程序：  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  不能对重定向的 <xref:System.Diagnostics.Process.StandardOutput%2A> 流混合使用异步和同步读取操作。 在异步或同步模式下打开 <xref:System.Diagnostics.Process> 的重定向流后，对该流进行的所有进一步读取操作都必须处于相同的模式下。 如果取消对 <xref:System.Diagnostics.Process.StandardOutput%2A> 的异步读取操作，然后需要重新读取流，则必须使用 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 才能恢复异步读取操作。 不要跟随 <xref:System.Diagnostics.Process.CancelOutputRead%2A> 调用 <xref:System.Diagnostics.Process.StandardOutput%2A> 的同步读取方法，如 <xref:System.IO.StreamReader.Read%2A>、<xref:System.IO.StreamReader.ReadLine%2A>或 <xref:System.IO.StreamReader.ReadToEnd%2A>。  
  
   
  
## Examples  
 下面的示例用用户提供的参数启动 `nmake` 命令。 异步读取错误和输出流;收集的文本行将显示到控制台并写入日志文件。 如果命令输出超过指定的行数，则将取消异步读取操作。  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未针对异步读取操作启用 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 流。</exception>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="process.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放与此组件关联的所有资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Close%2A> 方法会使进程在等待时停止等待退出，并关闭进程句柄，并清除特定于进程的属性。 <xref:System.Diagnostics.Process.Close%2A> 不会在外部引用标准输出、输入和错误读取器和编写器时关闭它们。  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.Dispose%2A> 方法调用 <xref:System.Diagnostics.Process.Close%2A>。 将 <xref:System.Diagnostics.Process> 对象置于 `using` 块会释放资源，而无需调用 <xref:System.Diagnostics.Process.Close%2A>。  
  
   
  
## Examples  
 下面的示例启动记事本的实例。 然后，它会以2秒的间隔检索关联进程的物理内存使用率，最大值为10秒。 该示例检测进程是否在10秒后退出。 如果10秒后仍在运行，则此示例将关闭进程。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberSignature Language="F#" Value="member this.CloseMainWindow : unit -&gt; bool" Usage="process.CloseMainWindow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通过向进程的主窗口发送关闭消息来关闭拥有用户界面的进程。</summary>
        <returns>如果成功发送了关闭消息，则为 <see langword="true" />；如果关联进程没有主窗口或禁用了主窗口(例如，如果当前显示模式对话框)，则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 进程执行时，其消息循环处于等待状态。 每次操作系统将 Windows 消息发送到该进程时，消息循环都会执行。 调用 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 将发送一个请求来关闭主窗口，该窗口在格式正确的应用程序中将关闭子窗口，并为应用程序撤消所有正在运行的消息循环。 通过调用 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 退出进程的请求不会强制应用程序退出。 应用程序可以在退出前要求用户进行验证，也可以拒绝退出。 若要强制退出应用程序，请使用 <xref:System.Diagnostics.Process.Kill%2A> 方法。 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 的行为与用户使用系统菜单关闭应用程序的主窗口的行为相同。 因此，通过关闭主窗口来退出进程的请求不会强制立即退出。  
  
 如果调用 <xref:System.Diagnostics.Process.Kill%2A>，则进程编辑的数据或分配给进程的资源可能会丢失。 <xref:System.Diagnostics.Process.Kill%2A> 导致异常进程终止，只应在必要时使用。 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 可以有序终止进程，并关闭所有窗口，因此更适合使用接口的应用程序。 如果 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 失败，则可以使用 <xref:System.Diagnostics.Process.Kill%2A> 终止进程。 <xref:System.Diagnostics.Process.Kill%2A> 是终止没有图形界面的进程的唯一方法。  
  
 只能对在本地计算机上运行的进程调用 <xref:System.Diagnostics.Process.Kill%2A> 和 <xref:System.Diagnostics.Process.CloseMainWindow%2A>。 不能使远程计算机上的进程退出。 只能查看远程计算机上运行的进程的信息。  
  
   
  
## Examples  
 下面的示例启动记事本的实例。 然后，它以2秒的间隔检索关联进程的物理内存使用率，最大值为10秒。 该示例检测进程是否在10秒后退出。 如果10秒后仍在运行，则此示例将关闭进程。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已经退出该进程。  
  
- 或 - 
没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="process.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。</param>
        <summary>释放此进程使用的所有资源。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessEnableRaisingEvents")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在进程终止时是否应引发 <see cref="E:System.Diagnostics.Process.Exited" /> 事件。</summary>
        <value>如果关联的进程终止（通过退出或者调用<see langword="true" /> ）时应引发 <see cref="E:System.Diagnostics.Process.Exited" /> 事件，则为 <see cref="M:System.Diagnostics.Process.Kill" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。 请注意，即使在用户执行 <see cref="P:System.Diagnostics.Process.HasExited" /> 检查的过程中，当进程退出时 <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> 的值 <see langword="false" />，也会引发 <see cref="E:System.Diagnostics.Process.Exited" /> 事件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
<xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 属性建议在操作系统关闭进程时是否应通知组件。 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 属性用于异步处理，以通知应用程序进程已退出。 若要强制您的应用程序以同步方式等待退出事件（这会中断应用程序的处理，直到发生退出事件），请使用 <xref:System.Diagnostics.Process.WaitForExit%2A> 方法。

> [!NOTE]
> 如果使用的是 Visual Studio 并双击项目中的 <xref:System.Diagnostics.Process> 组件，将自动生成 <xref:System.Diagnostics.Process.Exited> 事件委托和事件处理程序。 其他代码将 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 属性设置为 `false`。 您必须将此属性更改为 `true`，以便事件处理程序在关联进程退出时执行。

如果组件的 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 值为 `true`，或者当 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> `false` 并且组件调用了 <xref:System.Diagnostics.Process.HasExited%2A> 检查时，该组件可以访问关联进程的管理信息，该信息仍由操作系统存储。 此类信息包括 <xref:System.Diagnostics.Process.ExitTime%2A> 和 <xref:System.Diagnostics.Process.ExitCode%2A>。

关联进程退出后，该组件的 <xref:System.Diagnostics.Process.Handle%2A> 将不再指向现有进程资源。 相反，它只能用于访问有关进程资源的操作系统的信息。 操作系统会注意到，存在已被 <xref:System.Diagnostics.Process> 组件释放的退出进程的句柄，因此它会将 <xref:System.Diagnostics.Process.ExitTime%2A> 和 <xref:System.Diagnostics.Process.Handle%2A> 信息保留在内存中。

监视进程退出会产生相关费用。 如果 `true`<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>，则在关联进程终止时，将引发 <xref:System.Diagnostics.Process.Exited> 事件。 此时将运行 <xref:System.Diagnostics.Process.Exited> 事件的过程。

有时，应用程序会启动进程，但不需要通知结束。 例如，你的应用程序可以启动记事本，以允许用户执行文本编辑，但不会再进一步使用记事本应用程序。 你可以选择在进程退出时避免通知，因为它与你的应用程序的继续操作无关。 将 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 设置为 `false` 可以保存系统资源。

## Examples  
下面的代码示例创建打印文件的进程。 它设置 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 属性，使进程在退出时引发 <xref:System.Diagnostics.Process.Exited> 事件。 <xref:System.Diagnostics.Process.Exited> 事件处理程序显示进程信息。

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberSignature Language="F#" Value="static member EnterDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.EnterDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通过启用当前线程的本机属性 <see cref="T:System.Diagnostics.Process" />，将 <see langword="SeDebugPrivilege" /> 组件置于与以特殊模式运行的操作系统进程交互的状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 某些操作系统进程以特殊模式运行。 如果在组件上调用了 <xref:System.Diagnostics.Process.EnterDebugMode%2A>，则不可能尝试读取或附加到这些进程的属性。 如果不再需要访问以特殊模式运行的这些进程，请调用 <xref:System.Diagnostics.Process.LeaveDebugMode%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event ErrorDataReceived As DataReceivedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当应用程序写入其重定向 <see cref="P:System.Diagnostics.Process.StandardError" /> 流中时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ErrorDataReceived> 事件指示关联进程已写入其重定向的 <xref:System.Diagnostics.Process.StandardError%2A> 流。  
  
 此事件仅在 <xref:System.Diagnostics.Process.StandardError%2A>的异步读取操作过程中发生。 若要启动异步读取操作，必须重定向 <xref:System.Diagnostics.Process>的 <xref:System.Diagnostics.Process.StandardError%2A> 流，将事件处理程序添加到 <xref:System.Diagnostics.Process.ErrorDataReceived> 事件，并调用 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>。 此后，每次进程将行写入重定向的 <xref:System.Diagnostics.Process.StandardError%2A> 流时，<xref:System.Diagnostics.Process.ErrorDataReceived> 事件都会发出信号，直到进程退出或调用 <xref:System.Diagnostics.Process.CancelErrorRead%2A>。  
  
> [!NOTE]
>  处理异步输出的应用程序应调用 <xref:System.Diagnostics.Process.WaitForExit> 方法，以确保刷新了输出缓冲区。 请注意，通过使用 <xref:System.Diagnostics.Process.WaitForExit(System.Int32)> 重载来指定超时*不*会确保输出缓冲区已刷新。
  
   
  
## Examples  
 以下示例使用 `net view` 命令列出远程计算机上可用的网络资源。 用户以命令行参数的形式提供目标计算机名称。 用户还可以提供错误输出的文件名。 该示例收集 net 命令的输出，等待进程完成，然后将输出结果写入控制台。 如果用户提供了可选的错误文件，则该示例会将错误写入文件。  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int" Usage="System.Diagnostics.Process.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitCode")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程终止时指定的值。</summary>
        <value>关联进程终止时指定的代码。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Diagnostics.Process.ExitCode%2A> 获取系统进程在退出时返回的状态。 您可以使用退出代码，这与 `main()` 过程中的整数返回值非常类似。  
  
 进程的 <xref:System.Diagnostics.Process.ExitCode%2A> 值反映了该进程的应用程序开发人员实现的特定约定。 如果使用退出代码值在代码中做出决策，请确保了解应用程序进程使用的退出代码约定。  
  
 开发人员通常会指示 <xref:System.Diagnostics.Process.ExitCode%2A> 值为零的成功退出，并通过非零值指定错误，调用方法可以使用该值来识别异常进程终止的原因。 不需要遵循这些准则，但它们是约定。  
  
 如果尝试在进程退出之前获取 <xref:System.Diagnostics.Process.ExitCode%2A>，尝试会引发异常。 首先检查 <xref:System.Diagnostics.Process.HasExited%2A> 属性以验证关联的进程是否已终止。  
  
> [!NOTE]
>  将标准输出重定向到异步事件处理程序后，在 <xref:System.Diagnostics.Process.HasExited%2A> 返回 `true`时，输出处理可能不会完成。 若要确保异步事件处理已完成，请在检查 <xref:System.Diagnostics.Process.HasExited%2A>之前调用不带任何参数的 <xref:System.Diagnostics.Process.WaitForExit> 重载。  
  
 您可以使用 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 或 <xref:System.Diagnostics.Process.Kill%2A> 方法来使关联进程退出。  
  
 关联进程退出时，有两种通知方式：同步和异步。 同步通知依赖于调用 <xref:System.Diagnostics.Process.WaitForExit%2A> 方法来暂停应用程序的处理，直到关联的组件退出。 异步通知依赖于 <xref:System.Diagnostics.Process.Exited> 事件。 使用异步通知时，必须将 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 设置为 `true`，才能让 <xref:System.Diagnostics.Process> 组件收到进程已退出的通知。  
  
   
  
## Examples  
 下面的示例启动记事本的实例。 然后，该示例检索并显示关联进程的各种属性。 该示例在进程退出时进行检测，并显示该进程的退出代码。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">进程尚未退出。  
  
- 或 - 
进程 <see cref="P:System.Diagnostics.Process.Handle" /> 无效。</exception>
        <exception cref="T:System.NotSupportedException">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.ExitCode" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberSignature Language="F#" Value="member this.Exited : EventHandler " Usage="member this.Exited : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExited")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在进程退出时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Exited> 事件指示关联进程已退出。 此事件表示进程已终止（中止）或已成功关闭。 仅当 `true`<xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 属性的值时，才会发生此事件。  
  
 关联进程退出时，有两种通知方式：同步和异步。 同步通知意味着调用 <xref:System.Diagnostics.Process.WaitForExit%2A> 方法阻止当前线程，直到进程退出。 异步通知使用 <xref:System.Diagnostics.Process.Exited> 事件，该事件允许调用线程同时继续执行。 在后一种情况下，<xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 必须设置为 `true` 以便调用应用程序接收退出的事件。  
  
 当操作系统关闭进程时，它会通知所有其他进程已退出事件的已注册处理程序。 目前，可以使用刚刚退出的进程的句柄来访问某些属性（如 <xref:System.Diagnostics.Process.ExitTime%2A>），并 <xref:System.Diagnostics.Process.HasExited%2A> 操作系统维护，直到它完全释放该句柄。  
  
> [!NOTE]
>  即使您具有已退出进程的句柄，也不能再次调用 <xref:System.Diagnostics.Process.Start%2A> 来重新连接到同一进程。 调用 <xref:System.Diagnostics.Process.Start%2A> 会自动释放关联的进程，并使用同一文件而不是全新的 <xref:System.Diagnostics.Process.Handle%2A>连接到进程。  
  
 有关在 Windows 窗体应用程序中使用 <xref:System.Diagnostics.Process.Exited> 事件的详细信息，请参阅 <xref:System.Diagnostics.Process.SynchronizingObject%2A> 属性。  
  
   
  
## Examples  
 下面的代码示例创建打印文件的进程。 此方法在进程退出时引发 <xref:System.Diagnostics.Process.Exited> 事件，因为在创建进程时设置了 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 属性。 <xref:System.Diagnostics.Process.Exited> 事件处理程序显示进程信息。  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitTime : DateTime" Usage="System.Diagnostics.Process.ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程退出的时间。</summary>
        <value><see cref="T:System.DateTime" />，它指示关联进程终止的时间。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果进程尚未终止，尝试检索 <xref:System.Diagnostics.Process.ExitTime%2A> 属性会引发异常。 请在获取 <xref:System.Diagnostics.Process.ExitTime%2A> 属性之前使用 <xref:System.Diagnostics.Process.HasExited%2A> 来确定关联进程是否已终止。  
  
   
  
## Examples  
 下面的代码示例创建打印文件的进程。 进程在退出时引发 <xref:System.Diagnostics.Process.Exited> 事件，事件处理程序显示 <xref:System.Diagnostics.Process.ExitTime%2A> 属性和其他进程信息。  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.ExitTime" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcess : unit -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetCurrentProcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取新的 <see cref="T:System.Diagnostics.Process" /> 组件并将其与当前活动的进程关联。</summary>
        <returns>与运行调用应用程序的进程资源关联的新的 <see cref="T:System.Diagnostics.Process" /> 组件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法创建新的 <xref:System.Diagnostics.Process> 实例，并将其与本地计算机上的进程资源关联。  
  
 与类似的 <xref:System.Diagnostics.Process.GetProcessById%2A>，<xref:System.Diagnostics.Process.GetProcessesByName%2A>和 <xref:System.Diagnostics.Process.GetProcesses%2A> 方法一样，<xref:System.Diagnostics.Process.GetCurrentProcess%2A> 将现有资源与新的 <xref:System.Diagnostics.Process> 组件相关联。  
  
   
  
## Examples  
 下面的示例检索当前进程的信息、在本地计算机上运行的进程、在本地计算机上运行的所有 Notepad 实例，以及本地计算机上的特定进程。 然后，它将检索远程计算机上相同进程的信息。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建新的 <see cref="T:System.Diagnostics.Process" /> 组件，并将其与您指定的现有进程资源关联。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById processId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">进程资源的系统唯一标识符。</param>
        <summary>返回新的 <see cref="T:System.Diagnostics.Process" /> 组件(给定本地计算机上某个进程的标识符)。</summary>
        <returns>与 <paramref name="processId" /> 参数标识的本地进程资源关联的 <see cref="T:System.Diagnostics.Process" /> 组件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法创建新的 <xref:System.Diagnostics.Process> 组件，并将其与本地计算机上的进程资源关联。 进程资源必须已存在于计算机上，因为 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> 不会创建系统资源，而是将资源与应用程序生成的 <xref:System.Diagnostics.Process> 组件相关联。 只能为当前在计算机上运行的进程检索进程 <xref:System.Diagnostics.Process.Id%2A>。 进程终止后，如果向其传递的是过期标识符，<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> 会引发异常。  
  
 在任何特定计算机上，进程的标识符都是唯一的。 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> 最多返回一个进程。 如果要获取运行特定应用程序的所有进程，请使用 <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>。 如果运行指定应用程序的计算机上存在多个进程，<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> 将返回包含所有关联进程的数组。 你可以依次查询每个进程的标识符。 可以在 Windows 任务管理器的 "`Processes`" 面板中查看进程标识符。 "`PID`" 列显示分配给进程的进程标识符。  
  
 `processId` 参数是一个 <xref:System.Int32> （32位有符号整数），尽管基础 Windows API 对类似的 Api 使用 `DWORD` （无符号32位整数）。 这是出于历史原因。
  
## Examples  
 下面的示例检索当前进程的信息、在本地计算机上运行的进程、在本地计算机上运行的所有 Notepad 实例，以及本地计算机上的特定进程。 然后，它将检索远程计算机上相同进程的信息。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="processId" /> 参数指定的进程未运行。 此标识符可能已过期。</exception>
        <exception cref="T:System.InvalidOperationException">此对象未启动该进程。</exception>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById (processId, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">进程资源的系统唯一标识符。</param>
        <param name="machineName">网络上计算机的名称。</param>
        <summary>返回新的 <see cref="T:System.Diagnostics.Process" /> 组件(给定进程标识符和网络中计算机的名称)。</summary>
        <returns>与 <paramref name="processId" /> 参数标识的远程进程资源关联的 <see cref="T:System.Diagnostics.Process" /> 组件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法创建新的 <xref:System.Diagnostics.Process> 组件，并将其与网络上远程计算机上的进程资源关联。 进程资源必须已存在于指定的计算机上，因为 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> 不会创建系统资源，而是将资源与应用程序生成的 <xref:System.Diagnostics.Process> 组件相关联。 只能为当前在计算机上运行的进程检索进程 <xref:System.Diagnostics.Process.Id%2A>。 进程终止后，如果向其传递的是过期标识符，<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> 会引发异常。  
  
 在任何特定计算机上，进程的标识符都是唯一的。 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> 最多返回一个进程。 如果要获取运行特定应用程序的所有进程，请使用 <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>。 如果运行指定应用程序的计算机上存在多个进程，<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> 将返回包含所有关联进程的数组。 你可以依次查询每个进程的标识符。 可以在 Windows 任务管理器的 "`Processes`" 面板中查看进程标识符。 "`PID`" 列显示分配给进程的进程标识符。  
  
 如果未指定 `machineName`，则使用本地计算机。 或者，您可以通过将 `machineName` 设置为值 "." 或空字符串（""）来指定本地计算机。  
  
 `processId` 参数是一个 <xref:System.Int32> （32位有符号整数），尽管基础 Windows API 对类似的 Api 使用 `DWORD` （无符号32位整数）。 这是出于历史原因。   
  
## Examples  
 下面的示例检索当前进程的信息、在本地计算机上运行的进程、在本地计算机上运行的所有 Notepad 实例，以及本地计算机上的特定进程。 然后，它将检索远程计算机上相同进程的信息。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="processId" /> 参数指定的进程未运行。 此标识符可能已过期。  
  
- 或 - 
<paramref name="machineName" /> 参数的语法无效。 名称的长度可能为零 (0)。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="machineName" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">此对象未启动该进程。</exception>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建新的 <see cref="T:System.Diagnostics.Process" /> 组件的数组，并将它们与现有进程资源关联。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberSignature Language="F#" Value="static member GetProcesses : unit -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为本地计算机上的每个进程资源创建一个新的 <see cref="T:System.Diagnostics.Process" /> 组件。</summary>
        <returns>类型 <see cref="T:System.Diagnostics.Process" /> 的数组，表示本地计算机上运行的所有进程资源。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法创建新的 <xref:System.Diagnostics.Process> 组件的数组，并将它们与本地计算机上的所有进程资源关联。 进程资源必须已存在于本地计算机上，因为 <xref:System.Diagnostics.Process.GetProcesses%2A> 不会创建系统资源，而是将资源与应用程序生成的 <xref:System.Diagnostics.Process> 组件相关联。 由于操作系统本身正在运行后台进程，此数组绝不会为空。  
  
 如果您不想检索计算机上运行的所有进程，则可以使用 <xref:System.Diagnostics.Process.GetProcessById%2A> 或 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 方法来限制它们的数量。 <xref:System.Diagnostics.Process.GetProcessById%2A> 创建一个 <xref:System.Diagnostics.Process> 组件，该组件通过传递给方法的进程标识符与系统上标识的进程相关联。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 创建一个 <xref:System.Diagnostics.Process> 组件的数组，这些组件的关联进程资源共享你传递给方法的可执行文件。  
  
> [!NOTE]
>  在服务主机进程（svchost.exe）的同一个实例中，可以加载多个 Windows 服务。 GetProcesses 不标识这些单独的服务;为此，请参阅 <xref:System.ServiceProcess.ServiceController.GetServices%2A>。  
  
   
  
## Examples  
 下面的示例检索当前进程的信息、在本地计算机上运行的进程、在本地计算机上运行的所有 Notepad 实例，以及本地计算机上的特定进程。 然后，它将检索远程计算机上相同进程的信息。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcesses : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">从其中读取进程列表的计算机。</param>
        <summary>为指定计算机上的每个进程资源创建一个新的 <see cref="T:System.Diagnostics.Process" /> 组件。</summary>
        <returns>类型 <see cref="T:System.Diagnostics.Process" /> 的数组，表示指定计算机上运行的所有进程资源。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法创建新的 <xref:System.Diagnostics.Process> 组件的数组，并将它们与指定（通常为远程）计算机上的所有进程资源关联。 进程资源必须已存在于本地计算机上，因为 <xref:System.Diagnostics.Process.GetProcesses%2A> 不会创建系统资源，而是将资源与应用程序生成的 <xref:System.Diagnostics.Process> 组件相关联。 由于操作系统本身正在运行后台进程，此数组绝不会为空。  
  
 如果您不想检索计算机上运行的所有进程，则可以使用 <xref:System.Diagnostics.Process.GetProcessById%2A> 或 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 方法来限制它们的数量。 <xref:System.Diagnostics.Process.GetProcessById%2A> 创建一个 <xref:System.Diagnostics.Process> 组件，该组件通过传递给方法的进程标识符与系统上标识的进程相关联。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 创建一个 <xref:System.Diagnostics.Process> 组件的数组，这些组件的关联进程资源共享你传递给方法的可执行文件。  
  
 <xref:System.Diagnostics.Process.GetProcesses%2A> 方法的此重载通常用于检索在网络上的远程计算机上运行的进程资源的列表，但你可以通过传递 "." 来指定本地计算机。  
  
> [!NOTE]
>  在服务主机进程（svchost.exe）的同一个实例中，可以加载多个 Windows 服务。 GetProcesses 不标识这些单独的服务;为此，请参阅 <xref:System.ServiceProcess.ServiceController.GetServices%2A>。  
  
   
  
## Examples  
 下面的示例检索当前进程的信息、在本地计算机上运行的进程、在本地计算机上运行的所有 Notepad 实例，以及本地计算机上的特定进程。 然后，它将检索远程计算机上相同进程的信息。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> 参数的语法无效。 其长度可能为零 (0)。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="machineName" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.PlatformNotSupportedException">操作系统平台不支持在远程计算机上进行此操作。</exception>
        <exception cref="T:System.InvalidOperationException">访问用于获取进程信息的性能计数器 API 时遇到问题。 此异常特定于 Windows NT、Windows 2000 和 Windows XP。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">访问基础系统 API 时出现问题。</exception>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建新的 <see cref="T:System.Diagnostics.Process" /> 组件的数组，并将它们与共享指定的进程名称的所有现有进程资源关联。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName processName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">该进程的友好名称。</param>
        <summary>创建新的 <see cref="T:System.Diagnostics.Process" /> 组件的数组，并将它们与本地计算机上共享指定的进程名称的所有进程资源关联。</summary>
        <returns>类型 <see cref="T:System.Diagnostics.Process" /> 的数组，表示运行指定应用程序或文件的进程资源。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法创建新的 <xref:System.Diagnostics.Process> 组件的数组，并将它们与本地计算机上运行相同可执行文件的所有进程资源关联。 进程资源必须已存在于计算机上，因为 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 不会创建系统资源，而是将它们与应用程序生成的 <xref:System.Diagnostics.Process> 组件相关联。 可以为当前未在本地计算机上运行的可执行文件指定 `processName`，因此该方法返回的数组可能为空。  
  
 进程名称是进程（例如 Outlook）的友好名称，该名称不包括 .exe 扩展名或路径。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 有助于获取和操作与相同可执行文件关联的所有进程。 例如，可以将可执行文件名作为 `processName` 参数传递，以便关闭该可执行文件的所有正在运行的实例。  
  
 尽管进程 <xref:System.Diagnostics.Process.Id%2A> 对于系统上的单个进程资源是唯一的，但本地计算机上的多个进程可以运行 `processName` 参数指定的应用程序。 因此，<xref:System.Diagnostics.Process.GetProcessById%2A> 最多返回一个进程，但 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 返回包含所有关联进程的数组。 如果需要使用标准 API 调用来操作进程，可以依次查询每个进程的标识符。 你不能只通过进程名称访问进程资源，但一旦检索到与进程资源关联的 <xref:System.Diagnostics.Process> 组件数组，就可以启动、终止，并以其他方式处理系统资源。  
  
   
  
## Examples  
 下面的示例检索当前进程的信息、在本地计算机上运行的进程、在本地计算机上运行的所有 Notepad 实例，以及本地计算机上的特定进程。 然后，它将检索远程计算机上相同进程的信息。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">访问用于获取进程信息的性能计数器 API 时遇到问题。 此异常特定于 Windows NT、Windows 2000 和 Windows XP。</exception>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string * string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName (processName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">该进程的友好名称。</param>
        <param name="machineName">网络上计算机的名称。</param>
        <summary>创建新的 <see cref="T:System.Diagnostics.Process" /> 组件的数组，并将它们与远程计算机上共享指定进程名称的所有进程资源关联。</summary>
        <returns>类型 <see cref="T:System.Diagnostics.Process" /> 的数组，表示运行指定应用程序或文件的进程资源。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法创建新的 <xref:System.Diagnostics.Process> 组件的数组，并将其与在指定计算机上运行相同可执行文件的所有进程资源关联。 进程资源必须已存在于计算机上，因为 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 不会创建系统资源，而是将它们与应用程序生成的 <xref:System.Diagnostics.Process> 组件相关联。 可以为当前未在本地计算机上运行的可执行文件指定 `processName`，因此该方法返回的数组可能为空。  
  
 进程名称是进程（例如 Outlook）的友好名称，该名称不包括 .exe 扩展名或路径。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 有助于获取和操作与相同可执行文件关联的所有进程。 例如，可以将可执行文件名作为 `processName` 参数传递，以便关闭该可执行文件的所有正在运行的实例。  
  
 尽管进程 <xref:System.Diagnostics.Process.Id%2A> 对于系统上的单个进程资源是唯一的，但本地计算机上的多个进程可以运行 `processName` 参数指定的应用程序。 因此，<xref:System.Diagnostics.Process.GetProcessById%2A> 最多返回一个进程，但 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 返回包含所有关联进程的数组。 如果需要使用标准 API 调用来操作进程，可以依次查询每个进程的标识符。 你不能只通过进程名称访问进程资源，但一旦检索到与进程资源关联的 <xref:System.Diagnostics.Process> 组件数组，就可以启动、终止，并以其他方式处理系统资源。  
  
 您可以使用此重载获取本地计算机以及远程计算机上的进程。 使用 "." 指定本地计算机。 默认情况下，存在使用本地计算机的另一个重载。  
  
 您可以访问远程计算机上的进程，以便查看有关进程的信息（例如统计信息）。 不能关闭、终止（使用 <xref:System.Diagnostics.Process.Kill%2A>）或启动远程计算机上的进程。  
  
   
  
## Examples  
 下面的示例检索当前进程的信息、在本地计算机上运行的进程、在本地计算机上运行的所有 Notepad 实例，以及本地计算机上的特定进程。 然后，它将检索远程计算机上相同进程的信息。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> 参数的语法无效。 其长度可能为零 (0)。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="machineName" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.PlatformNotSupportedException">操作系统平台不支持在远程计算机上进行此操作。</exception>
        <exception cref="T:System.InvalidOperationException">尝试连接到 <paramref name="machineName" /> 失败。

- 或 - 
访问用于获取进程信息的性能计数器 API 时遇到问题。 此异常特定于 Windows NT、Windows 2000 和 Windows XP。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">访问基础系统 API 时出现问题。</exception>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Diagnostics.Process.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程的本机句柄。</summary>
        <value>进程启动时操作系统向关联进程分配的句柄。 系统使用此句柄来跟踪进程特性。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应用程序可以获取进程的句柄，该句柄可用作多个进程信息和控制函数的参数。 您可以使用此句柄来初始化 <xref:System.Threading.WaitHandle> 或使用平台调用来调用本机方法。  
  
 此进程句柄专用于应用程序，换言之，无法共享进程句柄。 进程还具有一个与 <xref:System.Diagnostics.Process.Handle%2A>不同的进程 <xref:System.Diagnostics.Process.Id%2A>，因此它在整个系统中有效。  
  
 只有通过对的调用启动的进程 <xref:System.Diagnostics.Process.Start%2A> 设置相应 <xref:System.Diagnostics.Process> 实例的 <xref:System.Diagnostics.Process.Handle%2A> 属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">该进程尚未启动或已退出。 不能读取 <see cref="P:System.Diagnostics.Process.Handle" /> 属性，因为没有与此 <see cref="T:System.Diagnostics.Process" /> 实例关联的进程。  
  
- 或 - 
<see cref="T:System.Diagnostics.Process" /> 实例已附加到正在运行的进程，但你没有获取具有完全访问权限的句柄所需的权限。</exception>
        <exception cref="T:System.NotSupportedException">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.Handle" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HandleCount : int" Usage="System.Diagnostics.Process.HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandleCount")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取由进程打开的句柄数。</summary>
        <value>进程打开的操作系统句柄数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 句柄为进程提供了引用对象的方法。 进程可以获取文件、资源、消息队列以及许多其他操作系统对象的句柄。 仅当句柄计数为零时，操作系统才回收与进程关联的内存。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasExited : bool" Usage="System.Diagnostics.Process.HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTerminated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示关联进程是否已终止的值。</summary>
        <value>如果 <see cref="T:System.Diagnostics.Process" /> 组件引用的操作系统进程已终止，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.HasExited%2A> 的 `true` 值指示关联进程已终止（正常或异常）。 可以通过调用 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 或 <xref:System.Diagnostics.Process.Kill%2A>来请求或强制关联进程退出。 如果句柄已打开到进程，则在进程退出后，操作系统将释放进程内存，但会保留有关进程的管理信息，例如句柄、退出代码和退出时间。 若要获取此信息，可以使用 "<xref:System.Diagnostics.Process.ExitCode%2A>" 和 "<xref:System.Diagnostics.Process.ExitTime%2A>" 属性。 对于此组件启动的进程，会自动填充这些属性。 当所有与系统进程关联的 <xref:System.Diagnostics.Process> 组件都被销毁并且不将更多的句柄保留到已退出的进程时，管理信息将被释放。  
  
 进程可以独立于你的代码而终止。 如果使用此组件启动了进程，则系统会自动更新 <xref:System.Diagnostics.Process.HasExited%2A> 的值，即使关联的进程独立退出也是如此。  
  
> [!NOTE]
>  将标准输出重定向到异步事件处理程序后，当此属性返回 `true`时，输出处理可能不会完成。 若要确保异步事件处理已完成，请在检查 <xref:System.Diagnostics.Process.HasExited%2A>之前调用不带任何参数的 <xref:System.Diagnostics.Process.WaitForExit> 重载。  
  
   
  
## Examples  
 下面的示例启动记事本的实例。 然后，它以2秒的间隔检索关联进程的物理内存使用率，最大值为10秒。 该示例检测进程是否在10秒后退出。 如果10秒后仍在运行，则此示例将关闭进程。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">没有与此对象关联的进程。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">无法检索该进程的退出代码。</exception>
        <exception cref="T:System.NotSupportedException">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.HasExited" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.Process.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程的唯一标识符。</summary>
        <value>此 <see cref="T:System.Diagnostics.Process" /> 实例引用的、由系统生成的进程的唯一标识符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果关联的进程未运行，则进程 <xref:System.Diagnostics.Process.Id%2A> 无效。 因此，在尝试检索 <xref:System.Diagnostics.Process.Id%2A> 属性之前，应确保该进程正在运行。 在进程终止之前，进程标识符唯一标识整个系统中的进程。  
  
 可以通过将进程标识符传递到 <xref:System.Diagnostics.Process.GetProcessById%2A> 方法，将本地或远程计算机上运行的进程连接到新的 <xref:System.Diagnostics.Process> 实例。 <xref:System.Diagnostics.Process.GetProcessById%2A> 是一种 `static` 方法，该方法创建新的组件，并自动为新的 <xref:System.Diagnostics.Process> 实例设置 <xref:System.Diagnostics.Process.Id%2A> 属性。  
  
 系统可以重新使用进程标识符。 仅当关联的进程正在运行时，<xref:System.Diagnostics.Process.Id%2A> 属性值才是唯一的。 进程终止后，系统可以为不相关的进程重用 <xref:System.Diagnostics.Process.Id%2A> 属性值。  
  
 由于标识符在系统中是唯一的，因此你可以将其作为传递 <xref:System.Diagnostics.Process> 实例的替代方法传递给其他线程。 此操作可以保存系统资源，并保证正确地标识该进程。  
  
   
  
## Examples  
 下面的示例演示如何获取应用程序的所有正在运行的实例的 <xref:System.Diagnostics.Process.Id%2A>。 该代码将创建一个新的记事本实例，列出记事本的所有实例，然后允许用户输入 <xref:System.Diagnostics.Process.Id%2A> 号以删除特定的实例。  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尚未设置此进程的 <see cref="P:System.Diagnostics.Process.Id" /> 属性。  
  
- 或 - 
没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</exception>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Kill">
      <Docs>
        <summary>强制终止基础进程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

`Kill` 方法强制终止进程，而 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 只请求终止。 当执行具有图形界面的进程时，其消息循环处于等待状态。 每次操作系统将 Windows 消息发送到该进程时，消息循环都会执行。 调用 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 将发送一个请求来关闭主窗口，该窗口在格式正确的应用程序中将关闭子窗口，并为应用程序撤消所有正在运行的消息循环。 通过调用 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 退出进程的请求不会强制应用程序退出。
应用程序可以在退出前要求用户进行验证，也可以拒绝退出。 若要强制退出应用程序，请使用 `Kill` 方法。

<xref:System.Diagnostics.Process.CloseMainWindow%2A> 的行为与用户使用系统菜单关闭应用程序的主窗口的行为相同。
因此，通过关闭主窗口来退出进程的请求不会强制立即退出。
  
> [!NOTE]
> <xref:System.Diagnostics.Process.Kill%2A> 方法以异步方式执行。 调用 `Kill` 方法后，调用 <xref:System.Diagnostics.Process.WaitForExit%2A> 方法以等待进程退出，或检查 <xref:System.Diagnostics.Process.HasExited%2A> 属性以确定进程是否已退出。

> [!NOTE]
> <xref:System.Diagnostics.Process.WaitForExit%2A> 方法和 <xref:System.Diagnostics.Process.HasExited%2A> 属性不反映后代进程的状态。
> 使用 `Kill(entireProcessTree: true)` 时，<xref:System.Diagnostics.Process.WaitForExit%2A> 和 <xref:System.Diagnostics.Process.HasExited%2A> 将指示在给定进程退出后退出已完成，即使所有子代尚未退出也是如此。
  
如果调用 `Kill`，则进程编辑的数据或分配给进程的资源可能会丢失。 
`Kill` 会导致异常进程终止，只应在必要时使用。
<xref:System.Diagnostics.Process.CloseMainWindow%2A> 可以有序终止进程，并关闭所有窗口，因此更适合使用接口的应用程序。 如果 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 失败，则可以使用 `Kill` 终止进程。
`Kill` 是终止没有图形界面的进程的唯一方法。
  
只能对在本地计算机上运行的进程调用 `Kill` 和 <xref:System.Diagnostics.Process.CloseMainWindow%2A>。
不能使远程计算机上的进程退出。 只能查看远程计算机上运行的进程的信息。
  
> [!NOTE]
> 如果在进程当前正在终止时对 `Kill` 方法的调用，则会引发 <xref:System.ComponentModel.Win32Exception>，拒绝访问。
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberSignature Language="F#" Value="member this.Kill : unit -&gt; unit" Usage="process.Kill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>立即停止关联的进程。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">无法终止相关联的进程。  
  
 - 或 -  
  
 进程将终止。</exception>
        <exception cref="T:System.NotSupportedException">你正尝试为远程计算机上运行的进程调用 <see cref="M:System.Diagnostics.Process.Kill" />。 该方法仅对本地计算机上运行的进程可用。</exception>
        <exception cref="T:System.InvalidOperationException">已经退出该进程。  
  
- 或 - 
没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</exception>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill (bool entireProcessTree);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill(bool entireProcessTree) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (entireProcessTree As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill(bool entireProcessTree);" />
      <MemberSignature Language="F#" Value="member this.Kill : bool -&gt; unit" Usage="process.Kill entireProcessTree" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entireProcessTree" Type="System.Boolean" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="entireProcessTree"><see langword="true" /> 终止相关联进程及其后代；<see langword="false" /> 仅终止相关联进程。</param>
        <summary>立即停止关联的进程，并可选择停止其子/后代进程。</summary>
        <remarks>如果将 <paramref name="entireProcessTree" /> 设置为 <see langword="true" />，则在后代终止过程中，将自动跳过调用缺少查看详细信息的权限的进程，因为终止进程无法确定这些进程是否为后代。</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">无法终止相关联的进程。  
  
 - 或 -  
  
 进程将终止。</exception>
        <exception cref="T:System.NotSupportedException">你正尝试为远程计算机上运行的进程调用 <see cref="M:System.Diagnostics.Process.Kill" />。 该方法仅对本地计算机上运行的进程可用。</exception>
        <exception cref="T:System.InvalidOperationException">已经退出该进程。  
  
- 或 -

没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。

- 或 -

调用进程是关联进程的后代树的成员。</exception>
        <exception cref="T:System.AggregateException">并非关联进程的后代树中的所有进程都可以终止。</exception>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberSignature Language="F#" Value="static member LeaveDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.LeaveDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使 <see cref="T:System.Diagnostics.Process" /> 组件离开允许它与以特殊模式运行的操作系统进程交互的状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 某些操作系统进程以特殊模式运行。 如果在组件上调用了 <xref:System.Diagnostics.Process.EnterDebugMode%2A>，则不可能尝试读取或附加到这些进程的属性。 如果不再需要访问以特殊模式运行的这些进程，请调用 <xref:System.Diagnostics.Process.LeaveDebugMode%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Diagnostics.Process.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程正在其上运行的计算机的名称。</summary>
        <value>关联进程正在其上运行的计算机的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以查看远程计算机上运行的进程的统计数据和进程信息，但不能在远程计算机上调用 <xref:System.Diagnostics.Process.Start%2A>、<xref:System.Diagnostics.Process.CloseMainWindow%2A>或 <xref:System.Diagnostics.Process.Kill%2A>。  
  
> [!NOTE]
>  当关联的进程在本地计算机上执行时，此属性将为计算机名称返回句点（"."）。 应使用 <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> 属性来获取正确的计算机名称。  
  
   
  
## Examples  
 若要使用下面的示例，必须首先在远程计算机上至少启动记事本的一个实例。 该示例请求记事本正在其上运行的远程计算机的名称，然后显示每个实例各自的 <xref:System.Diagnostics.Process.ProcessName%2A>、<xref:System.Diagnostics.Process.Id%2A>和 <xref:System.Diagnostics.Process.MachineName%2A> 属性。  
  
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</exception>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainModule : System.Diagnostics.ProcessModule" Usage="System.Diagnostics.Process.MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainModule")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程的主模块。</summary>
        <value>用于启动进程的 <see cref="T:System.Diagnostics.ProcessModule" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 进程模块表示加载到特定进程中的 .dll 或 .exe 文件。 利用 <xref:System.Diagnostics.Process.MainModule%2A> 属性，您可以查看用于启动进程的可执行文件的相关信息，包括模块名称、文件名和模块内存详细信息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.MainModule" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">32 位进程正尝试访问 64 位进程的模块。</exception>
        <exception cref="T:System.InvalidOperationException">进程 <see cref="P:System.Diagnostics.Process.Id" /> 不可用。  
  
- 或 - 
该进程已退出。</exception>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowHandle : nativeint" Usage="System.Diagnostics.Process.MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程主窗口的窗口句柄。</summary>
        <value>关联进程主窗口的系统生成的窗口句柄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 主窗口是由当前具有焦点的进程打开的窗口（<xref:System.Windows.Forms.Form.TopLevel%2A> 窗体）。 如果已更改，则必须使用 <xref:System.Diagnostics.Process.Refresh%2A> 方法刷新 <xref:System.Diagnostics.Process> 对象以获取当前的主窗口句柄。 通常情况下，因为窗口句柄已缓存，所以请事先使用 <xref:System.Diagnostics.Process.Refresh%2A> 以保证检索当前句柄。  
  
 只能获取本地计算机上运行的进程的 <xref:System.Diagnostics.Process.MainWindowHandle%2A> 属性。 <xref:System.Diagnostics.Process.MainWindowHandle%2A> 属性是唯一标识与进程关联的窗口的值。  
  
 仅当进程具有图形界面时，才有一个与之关联的主窗口。 如果关联进程没有主窗口，则 <xref:System.Diagnostics.Process.MainWindowHandle%2A> 值为零。 对于已隐藏的进程（即，任务栏中不显示的进程），值也为零。 这种情况可能会出现在通知区域中任务栏最右侧的图标。  
  
 如果刚启动了一个进程，并想要使用其主窗口句柄，请考虑使用 <xref:System.Diagnostics.Process.WaitForInputIdle%2A> 方法来允许该进程开始，确保已创建了主窗口句柄。 否则，将引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未定义 <see cref="P:System.Diagnostics.Process.MainWindowHandle" />，因为已退出进程。</exception>
        <exception cref="T:System.NotSupportedException">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowTitle : string" Usage="System.Diagnostics.Process.MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowTitle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取进程的主窗口标题。</summary>
        <value>进程的主窗口标题。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 仅当进程具有图形界面时，才有一个与之关联的主窗口。 如果关联进程没有主窗口（因此 <xref:System.Diagnostics.Process.MainWindowHandle%2A> 为零），或者系统无法确定是否存在主窗口（例如，某些 Unix 平台上可能出现这种情况），则 <xref:System.Diagnostics.Process.MainWindowTitle%2A> 为空字符串（""）。
 
 如果刚启动了一个进程，并想要使用其主窗口标题，请考虑使用 <xref:System.Diagnostics.Process.WaitForInputIdle%2A> 方法来允许该过程开始，并确保已创建主窗口句柄。 否则，系统将引发异常。  
  
> [!NOTE]
>  主窗口是当前具有焦点的窗口;请注意，这可能不是进程的主窗口。 如果已更改，则必须使用 <xref:System.Diagnostics.Process.Refresh%2A> 方法刷新 <xref:System.Diagnostics.Process> 对象以获取当前的主窗口句柄。  
  
   
  
## Examples  
 下面的示例启动记事本实例，并检索进程主窗口的标题。  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未定义 <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> 属性，因为进程已退出。</exception>
        <exception cref="T:System.NotSupportedException">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMaxWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置关联进程允许的最大工作集大小（以字节为单位）。</summary>
        <value>内存中允许的进程的最大工作集大小（以字节为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 进程的工作集是当前对物理 RAM 内存中的进程可见的内存页集。 这些页是常驻的，可供应用程序使用，而不会触发页面错误。  
  
 工作集包括共享数据和私人数据。 共享数据包括包含应用程序执行的所有说明的页面，包括 .dll 文件中的页面和系统 .dll 文件。 随着工作集大小的增加，内存需求也会增加。  
  
 进程具有最小和最大工作集大小。 每次创建进程资源时，系统会保留相当于进程的最小工作集大小的内存量。 当进程处于活动状态时，虚拟内存管理器将尝试至少保留最少的内存，但不会超过最大大小。  
  
 系统设置默认的工作集大小。 您可以使用 <xref:System.Diagnostics.Process.MaxWorkingSet%2A> 和 <xref:System.Diagnostics.Process.MinWorkingSet%2A> 成员修改这些大小。 但是，设置这些值不能保证保留或驻留内存。  
  
> [!NOTE]
>  增大进程的工作集大小时，会从系统的其余部分中取出物理内存。 请确保未请求的最小或最大工作集大小太大，因为这样做可能会降低系统性能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">最大的工作集大小无效。 它必须大于或等于最小的工作集大小。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">无法从关联的进程资源中检索工作集信息。  
  
 - 或 -  
  
 进程标识符或进程句柄为零，因为尚未启动该进程。</exception>
        <exception cref="T:System.NotSupportedException">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <exception cref="T:System.InvalidOperationException">进程 <see cref="P:System.Diagnostics.Process.Id" /> 不可用。  
  
- 或 - 
该进程已退出。</exception>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MinWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMinWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置关联进程允许的最小工作集大小（以字节为单位）。</summary>
        <value>内存中进程所需的最小工作集大小（以字节为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 进程的工作集是当前对物理 RAM 内存中的进程可见的内存页集。 这些页是常驻的，可供应用程序使用，而不会触发页面错误。  
  
 工作集包括共享数据和私人数据。 共享数据包括包含应用程序执行的所有说明的页面，包括 .dll 文件中的页面和系统 .dll 文件。 随着工作集大小的增加，内存需求也会增加。  
  
 进程具有最小和最大工作集大小。 每次创建进程资源时，系统会保留相当于进程的最小工作集大小的内存量。 当进程处于活动状态时，虚拟内存管理器将尝试至少保留最少的内存，但不会超过最大大小。  
  
 系统设置默认的工作集大小。 您可以使用 <xref:System.Diagnostics.Process.MaxWorkingSet%2A> 和 <xref:System.Diagnostics.Process.MinWorkingSet%2A> 成员修改这些大小。 但是，设置这些值不能保证保留或驻留内存。  
  
> [!NOTE]
>  增大进程的工作集大小时，会从系统的其余部分中取出物理内存。 请确保未请求的最小或最大工作集大小太大，因为这样做可能会降低系统性能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">最小工作集大小无效。 它必须小于或等于最大工作集大小。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">无法从关联的进程资源中检索工作集信息。  
  
 - 或 -  
  
 进程标识符或进程句柄为零，因为尚未启动该进程。</exception>
        <exception cref="T:System.NotSupportedException">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <exception cref="T:System.InvalidOperationException">进程 <see cref="P:System.Diagnostics.Process.Id" /> 不可用。  
  
- 或 - 
该进程已退出。</exception>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : System.Diagnostics.ProcessModuleCollection" Usage="System.Diagnostics.Process.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessModules")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取已由关联进程加载的模块。</summary>
        <value>类型 <see cref="T:System.Diagnostics.ProcessModule" /> 的数组，表示已由关联进程加载的模块。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 进程模块表示加载到特定进程中的 .dll 或 .exe 文件。 <xref:System.Diagnostics.ProcessModule> 实例使你可以查看模块的相关信息，包括模块名称、文件名和模块内存详细信息。  
  
 进程可以将多个模块加载到内存中。 例如，加载其他 .dll 文件的 .exe 文件具有多个模块。  
  
 启动进程后，在系统加载进程之前，此集合为空。 如果该进程具有主窗口，您可以在检索此属性之前调用 <xref:System.Diagnostics.Process.WaitForInputIdle%2A>，以确保获取该列表时该集合是非空的。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.Modules" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <exception cref="T:System.InvalidOperationException">进程 <see cref="P:System.Diagnostics.Process.Id" /> 不可用。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">您尝试访问系统进程或 Idle 进程的 <see cref="P:System.Diagnostics.Process.Modules" /> 属性。 这些进程没有模块。</exception>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize : int" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联的进程分配的非分页系统内存量（以字节为单位）。</summary>
        <value>系统已为无法写入到虚拟内存分页文件的关联进程分配的内存量（以字节为单位）。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联的进程分配的非分页系统内存量（以字节为单位）。</summary>
        <value>为关联的进程分配的、不能写入虚拟内存分页文件中的系统内存量（以字节为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回的值表示进程使用的非分页系统内存的当前大小（以字节为单位）。 系统内存是操作系统使用的物理内存，分为分页和非分页的池。 非分页的内存分配将保留在系统内存中，并且不会分页到虚拟内存分页文件中。  
  
 此属性可用于监视包含32位处理器或64位处理器的计算机上的内存使用情况。 属性值等效于进程的 "**池非分页字节数**" 性能计数器。  
  
   
  
## Examples  
 下面的代码示例启动记事本应用程序的实例。 然后，该示例检索并显示关联进程的各种属性。 该示例在进程退出时进行检测，并显示其退出代码和高峰内存统计信息。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberSignature Language="F#" Value="member this.OnExited : unit -&gt; unit" Usage="process.OnExited " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>引发 <see cref="E:System.Diagnostics.Process.Exited" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A> 是引发 <xref:System.Diagnostics.Process.Exited> 事件的 API 方法。 调用 <xref:System.Diagnostics.Process.OnExited%2A> 会导致 <xref:System.Diagnostics.Process.Exited> 事件发生，并且是使用 <xref:System.Diagnostics.Process> 组件引发事件的唯一方法。 <xref:System.Diagnostics.Process.OnExited%2A> 主要在从组件派生类时使用。  
  
 作为 <xref:System.Diagnostics.Process.OnExited%2A>的替代方法，可以编写自己的事件处理程序。 创建自己的事件处理程序委托和自己的事件处理方法。  
  
> [!NOTE]
>  如果你使用的是 Visual Studio 环境，则在将 <xref:System.Diagnostics.Process> 组件拖到窗体上并双击该图标时，将为你创建事件处理程序委托（AddOnExited）和事件处理方法（Process1_Exited）。 当 <xref:System.Diagnostics.Process.Exited> 事件发生时，你创建的代码将输入到 Process1_Exited 过程中。 您无需创建 <xref:System.Diagnostics.Process.OnExited%2A> 成员，因为它是为您实现的。  
  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的示例演示如何在派生类中使用 <xref:System.Diagnostics.Process.OnExited%2A> 方法。  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberSignature Language="F#" Value="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event OutputDataReceived As DataReceivedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>每次应用程序向其重定向 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 流中写入行时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OutputDataReceived> 事件指示关联的 <xref:System.Diagnostics.Process> 已写入一个行，并以换行符结尾，并将其重定向 <xref:System.Diagnostics.Process.StandardOutput%2A> 流中。  
  
 <xref:System.Diagnostics.Process.StandardOutput%2A>上的异步读取操作期间，会启用该事件。 若要启动异步读取操作，必须重定向 <xref:System.Diagnostics.Process>的 <xref:System.Diagnostics.Process.StandardOutput%2A> 流，将事件处理程序添加到 <xref:System.Diagnostics.Process.OutputDataReceived> 事件，并调用 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>。 此后，每次进程将行写入重定向的 <xref:System.Diagnostics.Process.StandardOutput%2A> 流时，<xref:System.Diagnostics.Process.OutputDataReceived> 事件都会发出信号，直到进程退出或调用 <xref:System.Diagnostics.Process.CancelOutputRead%2A>。  
  
> [!NOTE]
>  处理异步输出的应用程序应调用 <xref:System.Diagnostics.Process.WaitForExit%2A> 方法，以确保刷新了输出缓冲区。  
  
   
  
## Examples  
 下面的示例演示如何对 `ipconfig` 命令的重定向 <xref:System.Diagnostics.Process.StandardOutput%2A> 流执行异步读取操作。  
  
 该示例创建 `OutputHandler` 事件处理程序的事件委托，并将其与 <xref:System.Diagnostics.Process.OutputDataReceived> 事件关联。 该事件处理程序从重定向的 <xref:System.Diagnostics.Process.StandardOutput%2A> 流接收文本行，设置文本的格式，并将其保存到稍后显示在此示例控制台窗口中的输出字符串。  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize : int" Usage="System.Diagnostics.Process.PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联的进程分配的分页内存量（以字节为单位）。</summary>
        <value>由可写入到虚拟内存分页文件的关联进程分配的内存量（以字节为单位）。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联的进程分配的分页内存量（以字节为单位）。</summary>
        <value>在虚拟内存分页文件中为关联进程分配的内存量(以字节为单位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回的值表示进程使用的虚拟内存分页文件中的当前内存大小（以字节为单位）。 操作系统将虚拟内存分页文件与物理内存一起使用，以管理每个进程的虚拟地址空间。 当不可分页内存未使用时，可以将其传输到磁盘上的虚拟内存分页文件中。 若要获取由操作系统用于进程的内存大小，请使用 <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A> 属性。  
  
 此属性可用于监视包含32位处理器或64位处理器的计算机上的内存使用情况。 属性值等效于进程的**Page File Bytes**性能计数器。  
  
   
  
## Examples  
 下面的代码示例启动记事本应用程序的实例，然后检索并显示关联进程的各种属性。 该示例在进程退出时进行检测，并显示其退出代码和高峰内存统计信息。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize : int" Usage="System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联进程分配的可分页系统内存量（以字节为单位）。</summary>
        <value>系统已为可写入到虚拟内存页面文件的关联进程分配的内存量(以字节为单位)。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联进程分配的可分页系统内存量（以字节为单位）。</summary>
        <value>为可写入虚拟内存分页文件的关联内存分配的系统内存量（以字节为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性值返回的值表示进程使用的可分页系统内存的当前大小（以字节为单位）。 系统内存是操作系统使用的物理内存，分为分页和非分页的池。 当不可分页内存未使用时，可以将其传输到磁盘上的虚拟内存分页文件中。 若要获取进程使用的应用程序内存大小，请使用 <xref:System.Diagnostics.Process.PagedMemorySize64%2A> 属性。  
  
 此属性可用于监视包含32位处理器或64位处理器的计算机上的内存使用情况。 属性值等效于进程的 "**池分页字节数**" 性能计数器。  
  
   
  
## Examples  
 下面的代码示例启动记事本应用程序的实例。 然后，该示例检索并显示关联进程的各种属性。 该示例在进程退出时进行检测，并显示其退出代码和高峰内存统计信息。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize : int" Usage="System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联的进程使用的虚拟内存分页文件中的最大内存量（以字节为单位）。</summary>
        <value>由可写入到虚拟内存分页文件的关联进程分配的最大内存量（以字节为单位）。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联的进程使用的虚拟内存分页文件中的最大内存量（以字节为单位）。</summary>
        <value>从启动关联的进程以来在为虚拟内存分页文件中关联进程分配的最大内存量（以字节为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性值返回的值表示进程自启动以来使用的虚拟内存分页文件中的最大内存大小（以字节为单位）。 操作系统将虚拟内存分页文件与物理内存一起使用，以管理每个进程的虚拟地址空间。 当不可分页内存未使用时，可以将其传输到磁盘上的虚拟内存分页文件中。  
  
 此属性可用于监视包含32位处理器或64位处理器的计算机上的内存使用情况。 属性值等效于进程的 "**页文件字节峰值**" 性能计数器。  
  
   
  
## Examples  
 下面的代码示例启动记事本应用程序的实例。 然后，该示例检索并显示关联进程的各种属性。 该示例在进程退出时进行检测，并显示其退出代码和高峰内存统计信息。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize : int" Usage="System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程使用的最大虚拟内存量（以字节为单位）。</summary>
        <value>关联进程请求的最大虚拟内存量（以字节为单位）。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程使用的最大虚拟内存量（以字节为单位）。</summary>
        <value>从关联进程启动以来为关联进程分配的最大虚拟内存量（以字节为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回的值表示进程自启动以来使用的最大虚拟内存大小（以字节为单位）。 操作系统将每个进程的虚拟地址空间映射到物理内存中加载的页，或映射到磁盘上的虚拟内存分页文件中存储的页。  
  
 此属性可用于监视包含32位处理器或64位处理器的计算机上的内存使用情况。 属性值等效于进程的 "**虚拟字节峰值**" 性能计数器。  
  
   
  
## Examples  
 下面的代码示例启动记事本应用程序的实例。 然后，该示例检索并显示关联进程的各种属性。 该示例在进程退出时进行检测，并显示其退出代码和高峰内存统计信息。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet : int" Usage="System.Diagnostics.Process.PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程的峰值工作集大小（以字节为单位）。</summary>
        <value>关联进程一次所需的最大物理内存量（以字节为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 进程的工作集是当前对物理 RAM 内存中的进程可见的内存页集。 这些页是常驻的，可供应用程序使用，而不会触发页面错误。  
  
 工作集包括共享数据和私人数据。 共享数据包括包含进程执行的所有说明的页面，包括进程模块和系统库。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet64 : int64" Usage="System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程使用的最大物理内存量（以字节为单位）。</summary>
        <value>从启动关联进程以来为关联进程分配的最大物理内存量（以字节为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回的值表示进程自启动以来使用的工作集内存的最大大小（以字节为单位）。 进程的工作集是当前对物理 RAM 内存中的进程可见的内存页集。 这些页是常驻的，可供应用程序使用，而不会触发页面错误。  
  
 工作集包括共享数据和私人数据。 共享数据包括包含进程所执行的所有指令的页面，包括进程模块和系统库中的说明。  
  
 此属性可用于监视包含32位处理器或64位处理器的计算机上的内存使用情况。 属性值等效于进程的 "**工作集峰值**" 性能计数器。  
  
   
  
## Examples  
 下面的代码示例启动记事本应用程序的实例。 然后，该示例检索并显示关联进程的各种属性。 该示例在进程退出时进行检测，并显示其退出代码和高峰内存统计信息。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityBoostEnabled")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示主窗口拥有焦点时是否应由操作系统暂时提升关联进程优先级。</summary>
        <value>如果进程离开等待状态时应动态提升进程优先级别，则为<see langword="true" /> ；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当某个线程在优先级类具有一个或多个动态优先级枚举值（<xref:System.Diagnostics.ProcessPriorityClass.Normal>、<xref:System.Diagnostics.ProcessPriorityClass.High>或 <xref:System.Diagnostics.ProcessPriorityClass.RealTime>）的进程中运行时，系统会在该线程退出等待状态时暂时提升该线程的优先级。 此操作可防止其他进程中断当前线程的处理。 "<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>" 设置会影响所有现有线程以及此进程随后创建的所有线程。 若要还原正常行为，请将 <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> 属性设置为 `false`。  
  
> [!NOTE]
>  提升优先级过高可能会耗尽基本操作系统和网络功能的资源，导致其他操作系统任务出现问题。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">未能从关联的进程资源检索到优先级提升信息。</exception>
        <exception cref="T:System.PlatformNotSupportedException">进程标识符或进程句柄为零。 （进程尚未启动。）</exception>
        <exception cref="T:System.NotSupportedException">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <exception cref="T:System.InvalidOperationException">进程 <see cref="P:System.Diagnostics.Process.Id" /> 不可用。</exception>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityClass : System.Diagnostics.ProcessPriorityClass with get, set" Usage="System.Diagnostics.Process.PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityClass")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置关联进程的总体优先级类别。</summary>
        <value>关联进程的优先级类别，可从该类别计算进程的 <see cref="P:System.Diagnostics.Process.BasePriority" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 进程优先级类包含一系列线程优先级别。 进程中运行的具有不同优先级的线程相对于进程的优先级类运行。 Win32 使用四个优先级类，每个类具有7个基本优先级别。 这些进程优先级类在 <xref:System.Diagnostics.ProcessPriorityClass> 枚举中捕获，这使你可以将进程优先级设置为 <xref:System.Diagnostics.ProcessPriorityClass.Idle>、<xref:System.Diagnostics.ProcessPriorityClass.Normal>、<xref:System.Diagnostics.ProcessPriorityClass.High>、<xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>、<xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>或 <xref:System.Diagnostics.ProcessPriorityClass.RealTime>。 根据所用的时间或其他提升，操作系统在需要将进程移到其他进程以访问处理器时，可以更改基本优先级级别。 此外，还可以设置 <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>，以暂时提升从等待状态中获取的线程的优先级。 当进程返回到等待状态时，将重置此优先级。  
  
 利用 <xref:System.Diagnostics.Process.BasePriority%2A> 属性，您可以查看分配给进程的启动优先级。 但是，因为它是只读的，所以不能使用 <xref:System.Diagnostics.Process.BasePriority%2A> 属性设置进程的优先级。 若要更改优先级，请使用 <xref:System.Diagnostics.Process.PriorityClass%2A> 属性，该属性可获取或设置进程的总体优先级类别。  
  
 无法使用系统监视器查看优先级类。 下表显示 <xref:System.Diagnostics.Process.BasePriority%2A> 和 <xref:System.Diagnostics.Process.PriorityClass%2A> 值之间的关系。  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 下面的示例启动记事本的实例。 然后，该示例检索并显示关联进程的各种属性。 该示例在进程退出时进行检测，并显示该进程的退出代码。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">无法从关联的进程资源中设置或检索进程优先级信息。  
  
 - 或 -  
  
 进程标识符或进程句柄为零。 （进程尚未启动。）</exception>
        <exception cref="T:System.NotSupportedException">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.PriorityClass" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <exception cref="T:System.InvalidOperationException">进程 <see cref="P:System.Diagnostics.Process.Id" /> 不可用。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">无法设置优先级类，因为它不使用有效的值，如 <see cref="T:System.Diagnostics.ProcessPriorityClass" /> 枚举中所定义。</exception>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize : int" Usage="System.Diagnostics.Process.PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联的进程分配的专用内存量（以字节为单位）。</summary>
        <value>由关联的进程分配的、不能与其他进程共享的字节数。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize64 : int64" Usage="System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联的进程分配的专用内存量（以字节为单位）。</summary>
        <value>为关联进程分配的不能与其他进程共享的内存量（以字节为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回的值表示进程使用的内存的当前大小（以字节为单位），该内存大小不能与其他进程共享。  
  
 此属性可用于监视包含32位处理器或64位处理器的计算机上的内存使用情况。 属性值等效于进程的**专用字节**性能计数器。  
  
   
  
## Examples  
 下面的代码示例启动记事本应用程序的实例。 然后，该示例检索并显示关联进程的各种属性。 该示例在进程退出时进行检测，并显示其退出代码和高峰内存统计信息。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivilegedProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此进程的特权处理器时间。</summary>
        <value><see cref="T:System.TimeSpan" />，它指示进程在操作系统内核中运行代码所用的时间。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例启动记事本的实例。 然后，该示例检索并显示关联进程的各种属性。 该示例在进程退出时进行检测，并显示该进程的退出代码。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessName : string" Usage="System.Diagnostics.Process.ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取该进程的名称。</summary>
        <value>系统用以向用户标识该进程的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ProcessName%2A> 属性保留一个可执行文件名（如 Outlook），该名称不包括 .exe 扩展名或路径。 它有助于获取和操作与同一可执行文件关联的所有进程。  
  
> [!NOTE]
>  在 [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] 操作系统上，如果无法获取进程模块信息，则 <xref:System.Diagnostics.Process.ProcessName%2A> 属性可能会被截断为15个字符。  
  
 可以调用 <xref:System.Diagnostics.Process.GetProcessesByName%2A>，并向其传递可执行文件的名称，以检索包含指定计算机上每个正在运行的实例的数组。 例如，你可以使用此数组关闭可执行文件的所有正在运行的实例。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">进程没有标识符，或者没有与 <see cref="T:System.Diagnostics.Process" /> 关联的进程。  
  
- 或 - 
关联进程已退出。</exception>
        <exception cref="T:System.NotSupportedException">进程不在此计算机上。</exception>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint with get, set" Usage="System.Diagnostics.Process.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessorAffinity")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一些处理器，此进程中的线程可以按计划在这些处理器上运行。</summary>
        <value>位掩码，表示关联进程内的线程可以在其上运行的处理器。 默认值取决于计算机上的处理器数。 默认值为 2 <sup>n</sup> -1，其中 n 是处理器数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Windows 2000 和更高版本中，进程中的线程可以从处理器迁移到处理器，每次迁移都重新加载处理器缓存。 在负载过重的系统负载下，通过减少重新加载处理器缓存的次数来指定哪个处理器应运行特定的线程，从而提高性能。 处理器和线程之间的关联称为处理器关联。  
  
 每个处理器都表示为一个位。 位0为 processor one，位1为 processor 2，依此类推。 如果将某个位设置为值1，则会为线程分配选择相应的处理器。 将 <xref:System.Diagnostics.Process.ProcessorAffinity%2A> 值设置为零时，操作系统的计划算法会设置线程的关联。 如果将 <xref:System.Diagnostics.Process.ProcessorAffinity%2A> 值设置为任何非零值，则该值将解释为指定可供选择的处理器的位掩码。  
  
 下表显示了对八处理器系统的 <xref:System.Diagnostics.Process.ProcessorAffinity%2A> 值的选择。  
  
|位|二进制值|合格处理器|  
|-------------|------------------|-------------------------|  
|0x0001|00000000 00000001|1|  
|0x0003|00000000 00000011|1和2|  
|0x0007|00000000 00000111|1、2和3|  
|0x0009|00000000 00001001|1和4|  
|0x007F|00000000 01111111|1、2、3、4、5、6和7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">未能从关联的进程资源设置或检索 <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> 信息。  
  
- 或 - 
进程标识符或进程句柄为零。 （进程尚未启动。）</exception>
        <exception cref="T:System.NotSupportedException">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <exception cref="T:System.InvalidOperationException">进程 <see cref="P:System.Diagnostics.Process.Id" /> 不可用。  
  
- 或 - 
该进程已退出。</exception>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="process.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>放弃已缓存到进程组件的关联仅存的任何相关信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用 <xref:System.Diagnostics.Process.Refresh%2A> 后，有关每个属性的信息的第一个请求将导致进程组件从关联进程获取新值。  
  
 当 <xref:System.Diagnostics.Process> 组件与某个进程资源关联时，将根据关联进程的状态立即填充 <xref:System.Diagnostics.Process> 的属性值。 如果有关关联进程的信息随后发生更改，则这些更改不会反映在 <xref:System.Diagnostics.Process> 组件的缓存值中。 <xref:System.Diagnostics.Process> 组件是进程资源关联时的快照。 若要查看关联进程的当前值，请调用 <xref:System.Diagnostics.Process.Refresh%2A> 方法。  
  
   
  
## Examples  
 下面的示例启动记事本的实例。 然后，它以2秒的间隔检索关联进程的物理内存使用率，最大值为10秒。 该示例检测进程是否在10秒后退出。 如果10秒后仍在运行，则此示例将关闭进程。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Responding : bool" Usage="System.Diagnostics.Process.Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessResponding")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示进程的用户界面当前是否响应的值。</summary>
        <value>如果关联进程的用户界面当前响应系统，则为<see langword="true" /> ；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果某个进程具有用户界面，则 <xref:System.Diagnostics.Process.Responding%2A> 属性将与用户界面联系，以确定该进程是否正在响应用户输入。 如果接口未立即响应，则 <xref:System.Diagnostics.Process.Responding%2A> 属性将返回 `false`。 使用此属性来确定关联进程的接口是否已停止响应。  
  
 如果该进程没有 <xref:System.Diagnostics.Process.MainWindowHandle%2A>，则此属性将返回 `true`。  
  
   
  
## Examples  
 下面的示例启动记事本的实例。 然后，该示例检索并显示关联进程的各种属性。 该示例在进程退出时进行检测，并显示该进程的退出代码。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</exception>
        <exception cref="T:System.NotSupportedException">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.Responding" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : Microsoft.Win32.SafeHandles.SafeProcessHandle" Usage="System.Diagnostics.Process.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此进程的本机句柄。</summary>
        <value>此进程的本机句柄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 句柄仅在调用组件启动进程时可用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SessionId : int" Usage="System.Diagnostics.Process.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSessionId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程的终端服务会话标识符。</summary>
        <value>关联进程的终端服务会话标识符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.SessionId%2A> 属性标识当前正在其中运行应用程序的会话。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">没有与此进程关联的会话。</exception>
        <exception cref="T:System.InvalidOperationException">没有与此会话标识符关联的进程。  
  
 - 或 -  
  
 关联的进程不在此计算机上。</exception>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardError : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardError")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于读取应用程序错误输出的流。</summary>
        <value>可用于读取应用程序的标准错误流的 <see cref="T:System.IO.StreamReader" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当 <xref:System.Diagnostics.Process> 向其标准错误流写入文本时，该文本通常会显示在控制台上。 通过重定向 <xref:System.Diagnostics.Process.StandardError%2A> 流，你可以操作或取消进程的错误输出。 例如，你可以筛选文本，以不同的方式对其进行格式设置，或者将输出写入控制台和指定的日志文件。  
  
> [!NOTE]
>  若要使用 <xref:System.Diagnostics.Process.StandardError%2A>，你必须将 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> 设置为 `false`，并且必须将 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType> 设置为 `true`。 否则，从 <xref:System.Diagnostics.Process.StandardError%2A> 流中读取会引发异常。  
  
 重定向的 <xref:System.Diagnostics.Process.StandardError%2A> 流可以同步或异步读取。 <xref:System.IO.StreamReader.Read%2A>、<xref:System.IO.StreamReader.ReadLine%2A>和 <xref:System.IO.StreamReader.ReadToEnd%2A> 等方法执行进程的错误输出流上的同步读取操作。 在关联的 <xref:System.Diagnostics.Process> 写入其 <xref:System.Diagnostics.Process.StandardError%2A> 流或关闭流之前，这些同步读取操作不会完成。  
  
 与此相反，<xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 会对 <xref:System.Diagnostics.Process.StandardError%2A> 流启动异步读取操作。 此方法将为流输出启用指定的事件处理程序，并立即返回到调用方，当流输出定向到事件处理程序时，该处理程序可以执行其他操作。  
  
 同步读取操作会在调用方之间引入依赖关系，从 <xref:System.Diagnostics.Process.StandardError%2A> 流读取，子进程写入该流。 这些依赖项可能会导致死锁情况。 当调用方从子进程的重定向流中进行读取时，它依赖于子进程。 调用方等待读取操作，直到子级写入流或关闭流为止。 当子进程写入足够的数据以填充其重定向流时，它依赖于父进程。 子进程将在下一次写入操作之前等待，直到父进程从整个流中读取或关闭流为止。 当调用方和子进程等待彼此完成操作时，会发生死锁条件，并且这两个情况都无法继续。 您可以通过计算调用方和子进程之间的依赖关系来避免死锁。  

本节中的最后两个示例使用 <xref:System.Diagnostics.Process.Start%2A> 方法来启动一个名为*Write500Lines*的可执行文件。 下面的示例包含它的源代码。

[!code-csharp[Executable launched by Process.Start](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/write500lines.cs)]
[!code-vb[Executable launched by Process.Start](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/write500lines.vb)]

下面的示例演示如何从重定向的错误流中读取并等待子进程退出。 它通过在 `p.WaitForExit`之前调用 `p.StandardError.ReadToEnd` 来避免死锁情况。 如果父进程在 `p.StandardError.ReadToEnd` 之前调用了 `p.WaitForExit`，并且子进程写入足够多的文本以填充重定向的流，则会导致死锁情况。 父进程会无限期地等待子进程退出。 子进程会无限期地等待父进程从完整的 <xref:System.Diagnostics.Process.StandardError%2A> 流中读取。   

[!code-csharp[Reading from the error stream](~/samples/snippets/csharp/api/system.diagnostics/process/standarderror/stderror-sync.cs)]
[!code-vb[Reading from the error stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standarderror/stderror-sync.vb)]  

从标准输出和标准错误流中读取所有文本时，会出现类似的问题。 下面的示例对两个流执行读取操作。 它通过对 <xref:System.Diagnostics.Process.StandardError%2A> 流执行异步读取操作来避免死锁情况。 如果父进程调用 `p.StandardOutput.ReadToEnd` 后跟 `p.StandardError.ReadToEnd` 并且子进程写入足够多的文本以填充其错误流，则会导致死锁情况。 父进程会无限期地等待子进程关闭其 <xref:System.Diagnostics.Process.StandardOutput%2A> 流。 子进程会无限期地等待父进程从完整的 <xref:System.Diagnostics.Process.StandardError%2A> 流中读取。  
[!code-csharp[Reading from both streams](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-async.cs)]
[!code-vb[Reading from both streams](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-async.vb)]  

您可以使用异步读取操作来避免这些依赖项及其死锁。 或者，您可以通过创建两个线程并在单独的线程上读取每个流的输出来避免出现死锁情况。  
  
> [!NOTE]
>  不能对重定向的流混合使用异步和同步读取操作。 在异步或同步模式下打开 <xref:System.Diagnostics.Process> 的重定向流后，对该流进行的所有进一步读取操作都必须处于相同的模式下。 例如，不要在 <xref:System.Diagnostics.Process.StandardError%2A> 流的 <xref:System.IO.StreamReader.ReadLine%2A> 调用 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>，反之亦然。 但是，可以在不同模式下读取两个不同的流。 例如，可以调用 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，然后调用 <xref:System.Diagnostics.Process.StandardError%2A> 流的 <xref:System.IO.StreamReader.ReadLine%2A>。  
  
   
  
## Examples  
 下面的示例将 `net use` 命令与用户提供的参数一起使用，以映射网络资源。 然后，它读取 net 命令的标准错误流并将其写入控制台。  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尚未对 <see cref="P:System.Diagnostics.Process.StandardError" /> 流进行重定向定义；请确保 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 设置为 <see langword="true" /> 且 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 设置为 <see langword="false" />。  
  
- 或 - 
已打开 <see cref="P:System.Diagnostics.Process.StandardError" /> 流，以使用 <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" /> 进行异步读取操作。</exception>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardInput : System.IO.StreamWriter" Usage="System.Diagnostics.Process.StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardInput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于写入应用程序输入的流。</summary>
        <value><see cref="T:System.IO.StreamWriter" />，可用于写入应用程序的标准输入流。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process> 可以从其标准输入流（通常是键盘）读取输入文本。 通过重定向 <xref:System.Diagnostics.Process.StandardInput%2A> 流，你可以通过编程方式指定输入。 例如，可以从指定文件的内容或其他应用程序的输出中提供文本，而不使用键盘输入。  
  
> [!NOTE]
>  若要使用 <xref:System.Diagnostics.Process.StandardInput%2A>，你必须将 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> 设置为 `false`，并且必须将 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType> 设置为 `true`。 否则，写入 <xref:System.Diagnostics.Process.StandardInput%2A> 流时将引发异常。  
  
   
  
## Examples  
 下面的示例演示如何重定向进程的 <xref:System.Diagnostics.Process.StandardInput%2A> 流。 该示例通过重定向的输入启动 `sort` 命令。 然后，它会提示用户输入文本，并通过重定向的 <xref:System.Diagnostics.Process.StandardInput%2A> 流将其传递到 `sort` 进程。 `sort` 结果在控制台上显示给用户。  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.Process.StandardInput" /> 流尚未定义，因为 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> 设置为 <see langword="false" />。</exception>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutput : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardOutput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于读取应用程序文本输出的流。</summary>
        <value><see cref="T:System.IO.StreamReader" />，可用于读取应用程序的标准输出流。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当 <xref:System.Diagnostics.Process> 将文本写入其标准流时，该文本通常会显示在控制台上。 通过重定向 <xref:System.Diagnostics.Process.StandardOutput%2A> 流，你可以操作或取消进程的输出。 例如，你可以筛选文本，以不同的方式对其进行格式设置，或者将输出写入控制台和指定的日志文件。  
  
> [!NOTE]
>  若要使用 <xref:System.Diagnostics.Process.StandardOutput%2A>，你必须将 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> 设置为 `false`，并且必须将 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType> 设置为 `true`。 否则，从 <xref:System.Diagnostics.Process.StandardOutput%2A> 流中读取会引发异常。  
  
 重定向的 <xref:System.Diagnostics.Process.StandardOutput%2A> 流可以同步或异步读取。 <xref:System.IO.StreamReader.Read%2A>、<xref:System.IO.StreamReader.ReadLine%2A>和 <xref:System.IO.StreamReader.ReadToEnd%2A> 等方法在进程的输出流上执行同步读取操作。 在关联的 <xref:System.Diagnostics.Process> 写入其 <xref:System.Diagnostics.Process.StandardOutput%2A> 流或关闭流之前，这些同步读取操作不会完成。  
  
 与此相反，<xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 会对 <xref:System.Diagnostics.Process.StandardOutput%2A> 流启动异步读取操作。 此方法将为流输出启用指定的事件处理程序，并立即返回到调用方，当流输出定向到事件处理程序时，该处理程序可以执行其他操作。  
  
 同步读取操作会在调用方之间引入依赖关系，从 <xref:System.Diagnostics.Process.StandardOutput%2A> 流读取，子进程写入该流。 这些依赖项可能会导致死锁情况。 当调用方从子进程的重定向流中进行读取时，它依赖于子进程。 调用方等待读取操作，直到子级写入流或关闭流为止。 当子进程写入足够的数据以填充其重定向流时，它依赖于父进程。 子进程将在下一次写入操作之前等待，直到父进程从整个流中读取或关闭流为止。 当调用方和子进程等待彼此完成操作时，会发生死锁条件，并且这两个情况都无法继续。 您可以通过计算调用方和子进程之间的依赖关系来避免死锁。  

本节中的最后两个示例使用 <xref:System.Diagnostics.Process.Start%2A> 方法来启动一个名为*Write500Lines*的可执行文件。 下面的示例包含它的源代码。

[!code-csharp[Executable launched by Process.Start](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/write500lines.cs)]
[!code-vb[Executable launched by Process.Start](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/write500lines.vb)]

下面的示例演示如何从重定向流中读取并等待子进程退出。 该示例通过在 `p.WaitForExit`之前调用 `p.StandardOutput.ReadToEnd` 来避免死锁情况。 如果父进程在 `p.StandardOutput.ReadToEnd` 之前调用了 `p.WaitForExit`，并且子进程写入足够多的文本以填充重定向的流，则会导致死锁情况。 父进程会无限期地等待子进程退出。 子进程会无限期地等待父进程从完整的 <xref:System.Diagnostics.Process.StandardOutput%2A> 流中读取。  

[!code-csharp[Reading synchronously from a redirected output stream](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-sync.cs)]  
[!code-vb[Reading synchronously from a redirected output stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-sync.vb)]  

从标准输出和标准错误流中读取所有文本时，会出现类似的问题。 下面的示例对两个流执行读取操作。 它通过对 <xref:System.Diagnostics.Process.StandardError%2A> 流执行异步读取操作来避免死锁情况。 如果父进程调用 `p.StandardOutput.ReadToEnd` 后跟 `p.StandardError.ReadToEnd` 并且子进程写入足够多的文本以填充其错误流，则会导致死锁情况。 父进程会无限期地等待子进程关闭其 <xref:System.Diagnostics.Process.StandardOutput%2A> 流。 子进程会无限期地等待父进程从完整的 <xref:System.Diagnostics.Process.StandardError%2A> 流中读取。   
[!code-csharp[Reading from a redirected output and error stream](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-async.cs)]  
[!code-vb[Reading from a redirected output and error stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-async.vb)]    
  
 您可以使用异步读取操作来避免这些依赖项及其死锁。 或者，您可以通过创建两个线程并在单独的线程上读取每个流的输出来避免出现死锁情况。  
  
> [!NOTE]
>  不能对重定向的流混合使用异步和同步读取操作。 在异步或同步模式下打开 <xref:System.Diagnostics.Process> 的重定向流后，对该流进行的所有进一步读取操作都必须处于相同的模式下。 例如，不要在 <xref:System.Diagnostics.Process.StandardOutput%2A> 流的 <xref:System.IO.StreamReader.ReadLine%2A> 调用 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，反之亦然。 但是，可以在不同模式下读取两个不同的流。 例如，可以调用 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，然后调用 <xref:System.Diagnostics.Process.StandardError%2A> 流的 <xref:System.IO.StreamReader.ReadLine%2A>。  
  
   
  
## Examples  
 下面的示例运行 ipconfig 命令，并将其标准输出重定向到该示例的控制台窗口。  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尚未对 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 流进行重定向定义；请确保 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 设置为 <see langword="true" /> 且 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 设置为 <see langword="false" />。  
  
- 或 - 
已打开 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 流，以使用 <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" /> 进行异步读取操作。</exception>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>启动进程资源并将其与 <see cref="T:System.Diagnostics.Process" /> 组件关联。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; bool" Usage="process.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>启动(或重用)此 <see cref="T:System.Diagnostics.Process" /> 组件的 <see cref="P:System.Diagnostics.Process.StartInfo" /> 属性指定的进程资源，并将其与该组件关联。</summary>
        <returns>如果启动了进程资源，则为 <see langword="true" />；如果没有启动新的进程资源(例如，如果重用了现有进程)，则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载来启动进程资源，并将其与当前 <xref:System.Diagnostics.Process> 组件相关联。 返回值 `true` 指示已启动新的进程资源。 如果 <xref:System.Diagnostics.Process.StartInfo%2A> 属性的 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 成员指定的进程资源已在计算机上运行，则不会启动其他进程资源。 相反，将重用正在运行的进程资源并返回 `false`。  
  
 可以通过指定最初安装应用程序的位置（例如，Web 地址）来启动 ClickOnce 应用程序。 不要通过在硬盘驱动器上指定其安装位置来启动 ClickOnce 应用程序。  
  
> [!NOTE]
>  如果使用的是 Visual Studio，则 <xref:System.Diagnostics.Process.Start%2A> 方法的重载是在将 <xref:System.Diagnostics.Process> 组件拖到设计器上后插入代码中的方法。 使用 "`Properties`" 窗口展开 "`StartInfo`" 类别，并将适当的值写入 `FileName` 属性。 您所做的更改将显示在窗体的 `InitializeComponent` 过程中。  
  
 <xref:System.Diagnostics.Process.Start%2A> 的此重载不是 `static` 方法。 必须从 <xref:System.Diagnostics.Process> 类的实例调用它。 在调用 <xref:System.Diagnostics.Process.Start%2A>之前，必须先为此 <xref:System.Diagnostics.Process> 实例指定 <xref:System.Diagnostics.Process.StartInfo%2A> 属性信息，因为该信息用于确定要启动的进程资源。  
  
 <xref:System.Diagnostics.Process.Start%2A> 方法的其他重载 `static` 成员。 在调用方法的重载之前，无需创建 <xref:System.Diagnostics.Process> 组件的实例。 相反，你可以为 <xref:System.Diagnostics.Process> 类本身调用 <xref:System.Diagnostics.Process.Start%2A>，并在进程启动时创建新的 <xref:System.Diagnostics.Process> 组件。 或者，如果重复使用进程，则返回 `null`。 进程资源与 <xref:System.Diagnostics.Process.Start%2A> 方法返回的新 <xref:System.Diagnostics.Process> 组件自动关联。  
  
 <xref:System.Diagnostics.Process.StartInfo%2A> 成员可用于复制 Windows `Start` 菜单的 "`Run`" 对话框的功能。 可以通过在 "<xref:System.Diagnostics.Process.StartInfo%2A>" 属性中设置相应的值，来启动可键入到命令行中的任何内容。 唯一必须设置的 <xref:System.Diagnostics.Process.StartInfo%2A> 属性是 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 属性。 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 属性不必是可执行文件。 它可以是其扩展插件与系统上安装的应用程序关联的任何文件类型。 例如，如果您已将文本文件与一个编辑器（如记事本）关联，则 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 属性可以具有 .txt 扩展名; 如果您已将 .doc 文件与 word 处理工具（如 Microsoft Word）关联，则它可能具有 .doc 扩展名。  
  
 在命令行中，可以指定要对某些类型的文件执行的操作。 例如，可以打印文档或编辑文本文件。 使用 <xref:System.Diagnostics.Process.StartInfo%2A> 属性的 <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> 成员指定这些操作。 对于其他类型的文件，您可以在从 "`Run`" 对话框启动文件时指定命令行参数。 例如，如果将浏览器指定为 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>，则可以将 URL 作为参数传递。 可以在 <xref:System.Diagnostics.Process.StartInfo%2A> 属性的 <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> 成员中指定这些参数。  
  
 如果在系统中使用引号声明了路径变量，则在启动在该位置找到的任何进程时必须完全限定该路径。 否则，系统将找不到该路径。 例如，如果 `c:\mypath` 不在你的路径中，而你使用引号添加它： `path = %path%;"c:\mypath"`，则在启动时必须完全限定 `c:\mypath` 中的任何进程。  
  
> [!NOTE]
>  ASP.NET 网页和服务器控制代码在 Web 服务器上的 ASP.NET 工作进程上下文中执行。  如果在 ASP.NET 网页或服务器控件中使用 <xref:System.Diagnostics.Process.Start%2A> 方法，则新进程将在具有受限权限的 Web 服务器上执行。 该进程不会在与客户端浏览器相同的上下文中启动，也不能访问用户桌面。  
  
 无论何时使用 <xref:System.Diagnostics.Process.Start%2A> 来启动进程，都可能需要将其关闭或丢失系统资源。 使用 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 或 <xref:System.Diagnostics.Process.Kill%2A>关闭进程。 您可以使用其 <xref:System.Diagnostics.Process.HasExited%2A> 属性检查进程是否已关闭。  
  
 此处需要有关托管线程中的单元状态的说明。 当在进程组件的 <xref:System.Diagnostics.Process.StartInfo%2A> 属性中 `true` <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 时，请确保已在应用程序上设置了线程模型，方法是在 `main()` 方法上设置属性 `[STAThread]`。 否则，托管线程可以处于 `unknown` 状态或置于 `MTA` 状态，后者与 `true`的 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 发生冲突。 某些方法要求单元状态不 `unknown`。 如果未显式设置该状态，则当应用程序遇到此类方法时，它默认为 `MTA`，一旦设置，将无法更改单元状态。 但 `MTA` 会导致在操作系统 shell 管理线程时引发异常。  
  
   
  
## Examples  
 下面的示例使用 <xref:System.Diagnostics.Process> 类的实例来启动进程。  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在 <see cref="T:System.Diagnostics.Process" /> 组件的 <see cref="P:System.Diagnostics.Process.StartInfo" /> 中未指定任何文件名。

- 或 -

当 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 、 <see cref="P:System.Diagnostics.Process.StartInfo" /> 或 <see langword="true" /> 的值为 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />时， <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />属性的 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 成员的值为 <see langword="true" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">打开关联的文件时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">已释放此进程对象。</exception>
        <exception cref="T:System.PlatformNotSupportedException">不支持 shell 的操作系统（如，仅适用于.NET Core 的 Nano Server）不支持此方法。</exception>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberSignature Language="F#" Value="static member Start : System.Diagnostics.ProcessStartInfo -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start startInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo"><see cref="T:System.Diagnostics.ProcessStartInfo" />，包含用于启动进程的信息(包括文件名和任何命令行参数)。</param>
        <summary>启动由包含进程启动信息(例如，要启动的进程的文件名)的参数指定的进程资源，并将该资源与新的 <see cref="T:System.Diagnostics.Process" /> 组件关联。</summary>
        <returns>与进程资源关联的新 <see cref="T:System.Diagnostics.Process" />，如果未启动进程资源，则为 <see langword="null" />。 请注意，伴随同一进程中已运行的实例而启动的新进程将独立于其他进程。 此外，启动可能返回一个 <see cref="P:System.Diagnostics.Process.HasExited" /> 属性已设置为 <see langword="true" /> 的非 null 进程。 在这种情况下，启动的进程可能已激活现有实例自身，然后退出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载通过指定 <xref:System.Diagnostics.ProcessStartInfo> 实例来启动进程资源。 重载将资源与新的 <xref:System.Diagnostics.Process> 对象相关联。  
  
> [!NOTE]
>  如果要启动的可执行文件的地址是 URL，则该进程将不会启动，并且将返回 `null`。  
  
 此重载使你可以在不先创建新的 <xref:System.Diagnostics.Process> 实例的情况下启动进程。 将此重载与 <xref:System.Diagnostics.ProcessStartInfo> 参数一起使用是创建新的 <xref:System.Diagnostics.Process> 实例、设置其 <xref:System.Diagnostics.Process.StartInfo%2A> 属性和调用 <xref:System.Diagnostics.Process> 实例的 <xref:System.Diagnostics.Process.Start%2A> 的显式步骤的替代方法。  
  
 使用 <xref:System.Diagnostics.ProcessStartInfo> 实例作为参数，可以调用 <xref:System.Diagnostics.Process.Start%2A>，最大程度地控制传递到调用以启动进程的内容。 如果需要只传递文件名或文件名和参数，则无需创建新的 <xref:System.Diagnostics.ProcessStartInfo> 实例，尽管这是一个选项。 唯一必须设置的 <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType> 属性是 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 属性。 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 属性不需要表示可执行文件。 它可以是其扩展插件与系统上安装的应用程序关联的任何文件类型。 例如，如果您已将文本文件与一个编辑器（如记事本）关联，则 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 属性可以具有 .txt 扩展名; 如果您已将 .doc 文件与 word 处理工具（如 Microsoft Word）关联，则它可能具有 .doc 扩展名。  
  
 可以通过指定最初安装应用程序的位置（例如，Web 地址）来启动 ClickOnce 应用程序。 不要通过在硬盘驱动器上指定其安装位置来启动 ClickOnce 应用程序。  
  
 如果设置了 <xref:System.Diagnostics.Process.StartInfo%2A> 实例的 <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> 和 <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> 属性，则会调用非托管 `CreateProcessWithLogonW` 函数，这将在新窗口中启动该进程，即使 <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> 属性值 `true` 或 <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType> 属性值 <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>也是如此。 如果 `null`<xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType> 属性，<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> 属性必须为 UPN 格式，*用户*@*DNS_domain_name*。   
  
 与其他重载不同，没有参数的 <xref:System.Diagnostics.Process.Start%2A> 的重载不是 `static` 成员。 如果已创建 <xref:System.Diagnostics.Process> 实例和指定的开始信息（包括文件名），并且想要启动进程资源并将其与现有 <xref:System.Diagnostics.Process> 实例相关联，请使用此重载。 若要创建新的 <xref:System.Diagnostics.Process> 组件，而不是为现有组件启动进程，请使用 `static` 重载之一。 此重载和没有参数的重载都允许使用 <xref:System.Diagnostics.ProcessStartInfo> 实例指定进程资源的启动信息。  
  
 如果在系统中使用引号声明了路径变量，则在启动在该位置找到的任何进程时必须完全限定该路径。 否则，系统将找不到该路径。 例如，如果 `c:\mypath` 不在你的路径中，而你使用引号添加它： `path = %path%;"c:\mypath"`，则在启动时必须完全限定 `c:\mypath` 中的任何进程。  
  
> [!NOTE]
>  ASP.NET 网页和服务器控制代码在 Web 服务器上的 ASP.NET 工作进程上下文中执行。  如果在 ASP.NET 网页或服务器控件中使用 <xref:System.Diagnostics.Process.Start%2A> 方法，则新进程将在具有受限权限的 Web 服务器上执行。 该进程不会在与客户端浏览器相同的上下文中启动，也不能访问用户桌面。  
  
 无论何时使用 <xref:System.Diagnostics.Process.Start%2A> 来启动进程，都可能需要将其关闭或丢失系统资源。 使用 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 或 <xref:System.Diagnostics.Process.Kill%2A>关闭进程。 您可以使用其 <xref:System.Diagnostics.Process.HasExited%2A> 属性检查进程是否已关闭。  
  
 此处需要有关托管线程中的单元状态的说明。 当 `true` `startInfo` 参数上 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 时，请确保已在应用程序上设置了线程模型，方法是在 `main()` 方法上设置属性 `[STAThread]`。 否则，托管线程可以处于 `unknown` 状态或置于 `MTA` 状态，后者与 `true`的 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 发生冲突。 某些方法要求单元状态不 `unknown`。 如果未显式设置该状态，则当应用程序遇到此类方法时，它默认为 `MTA`，一旦设置，将无法更改单元状态。 但 `MTA` 会导致在操作系统 shell 管理线程时引发异常。  
  
   
  
## Examples  
 下面的示例首先生成 Internet Explorer 的一个实例，并在浏览器中显示 "收藏夹" 文件夹的内容。 然后，它将启动其他一些 Internet Explorer 实例，并显示某些特定页面或站点。 最后，当导航到特定站点时，它会在窗口最小化时启动 Internet Explorer。  
  
 有关此方法的其他用法的其他示例，请参阅 <xref:System.Diagnostics.ProcessStartInfo> 类的各个属性。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在 <paramref name="startInfo" /> 参数的 <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> 属性中未指定任何文件名。  
  
- 或 - 
<paramref name="startInfo" /> 参数的 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 属性值为 <see langword="true" />，且 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 或 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 属性的值也为 <see langword="true" />。  
  
- 或 - 
<paramref name="startInfo" /> 参数的 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 属性值为 <see langword="true" />，且 <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> 属性值不为 <see langword="null" /> 或空，或者 <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> 属性值不为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="startInfo" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException">已释放此进程对象。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">打开关联的文件时出错。  

- 或 - 
在 <paramref name="startInfo" /> 参数的 <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> 属性中指定的文件未找到。
          
- 或 - 
自变量的长度与该进程的完整路径的长度的总和超过了 2080。 与此异常关联的错误消息可以是下面其中一项：“传递给系统调用的数据区域太小。” 或“拒绝访问。”</exception>
        <exception cref="T:System.PlatformNotSupportedException">不支持 shell 的操作系统（如，仅适用于.NET Core 的 Nano Server）不支持此方法。</exception>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member Start : string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要在进程中运行的文档或应用程序文件的名称。</param>
        <summary>通过指定文档或应用程序文件的名称来启动进程资源，并将资源与新的 <see cref="T:System.Diagnostics.Process" /> 组件关联。</summary>
        <returns>与进程资源关联的新 <see cref="T:System.Diagnostics.Process" />，如果未启动进程资源，则为 <see langword="null" />。 请注意，伴随同一进程中已运行的实例而启动的新进程将独立于其他进程。 此外，启动可能返回一个 <see cref="P:System.Diagnostics.Process.HasExited" /> 属性已设置为 <see langword="true" /> 的非 null 进程。 在这种情况下，启动的进程可能已激活现有实例自身，然后退出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载通过指定进程资源的文件名来启动进程资源。 重载将资源与新的 <xref:System.Diagnostics.Process> 对象相关联。  
  
> [!NOTE]
>  如果要启动的可执行文件的地址是 URL，则该进程将不会启动，并且将返回 `null`。  
  
 此重载使你可以在不先创建新的 <xref:System.Diagnostics.Process> 实例的情况下启动进程。 重载是一种替代方法，用于创建新的 <xref:System.Diagnostics.Process> 实例，设置 <xref:System.Diagnostics.Process.StartInfo%2A> 属性的 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 成员，并为 <xref:System.Diagnostics.Process> 实例调用 <xref:System.Diagnostics.Process.Start%2A>。  
  
 可以通过将 `fileName` 参数设置为最初安装应用程序的位置（例如，Web 地址）来启动 ClickOnce 应用程序。 不要通过在硬盘驱动器上指定其安装位置来启动 ClickOnce 应用程序。  
  
 通过指定其文件名来启动进程类似于在 Windows `Start` 菜单的 "`Run`" 对话框中键入信息。 因此，文件名不需要表示可执行文件。 它可以是与系统上安装的应用程序关联的任何文件类型。 例如，如果您已将文本文件与一个编辑器（如记事本）关联，则文件名可以具有 .txt 扩展名; 如果您已将 .doc 文件与 word 处理工具（如 Microsoft Word）相关联，则它可能具有 .doc。 同样，在 `fileName` 参数中，.exe 扩展名是可选的，这与 `Run` 对话框可以接受带有或不带 .exe 扩展名的可执行文件名的方式相同。 例如，可以将 `fileName` 参数设置为 "Notepad.exe" 或 "Notepad"。  
  
 此重载不允许进程的命令行参数。 如果需要为进程指定一个或多个命令行参数，请使用 <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> 或 <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> 重载。  
  
 与其他重载不同，没有参数的 <xref:System.Diagnostics.Process.Start%2A> 的重载不是 `static` 成员。 如果已创建 <xref:System.Diagnostics.Process> 实例和指定的开始信息（包括文件名），并且想要启动进程资源并将其与现有 <xref:System.Diagnostics.Process> 实例相关联，请使用此重载。 若要创建新的 <xref:System.Diagnostics.Process> 组件，而不是为现有组件启动进程，请使用 `static` 重载之一。 此重载和没有参数的重载都允许您指定要启动的进程资源的文件名。  
  
 如果在系统中使用引号声明了路径变量，则在启动在该位置找到的任何进程时必须完全限定该路径。 否则，系统将找不到该路径。 例如，如果 `c:\mypath` 不在你的路径中，而你使用引号添加它： `path = %path%;"c:\mypath"`，则在启动时必须完全限定 `c:\mypath` 中的任何进程。  
  
> [!NOTE]
>  ASP.NET 网页和服务器控制代码在 Web 服务器上的 ASP.NET 工作进程上下文中执行。  如果在 ASP.NET 网页或服务器控件中使用 <xref:System.Diagnostics.Process.Start%2A> 方法，则新进程将在具有受限权限的 Web 服务器上执行。 该进程不会在与客户端浏览器相同的上下文中启动，也不能访问用户桌面。  
  
 无论何时使用 <xref:System.Diagnostics.Process.Start%2A> 来启动进程，都可能需要将其关闭或丢失系统资源。 使用 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 或 <xref:System.Diagnostics.Process.Kill%2A>关闭进程。 您可以使用其 <xref:System.Diagnostics.Process.HasExited%2A> 属性检查进程是否已关闭。  
  
 此处需要有关托管线程中的单元状态的说明。 当在进程组件的 <xref:System.Diagnostics.Process.StartInfo%2A> 属性中 `true` <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 时，请确保已在应用程序上设置了线程模型，方法是在 `main()` 方法上设置属性 `[STAThread]`。 否则，托管线程可以处于 `unknown` 状态或置于 `MTA` 状态，后者与 `true`的 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 发生冲突。 某些方法要求单元状态不 `unknown`。 如果未显式设置该状态，则当应用程序遇到此类方法时，它默认为 `MTA`，一旦设置，将无法更改单元状态。 但 `MTA` 会导致在操作系统 shell 管理线程时引发异常。  
  
   
  
## Examples  
 下面的示例首先生成 Internet Explorer 的一个实例，并在浏览器中显示 "收藏夹" 文件夹的内容。 然后，它将启动其他一些 Internet Explorer 实例，并显示某些特定页面或站点。 最后，当导航到特定站点时，它会在窗口最小化时启动 Internet Explorer。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">打开关联的文件时出错。

- 或 -

找不到 <paramref name="fileName" /> 中指定的文件。</exception>
        <exception cref="T:System.ObjectDisposedException">已释放此进程对象。</exception>
        <exception cref="T:System.IO.FileNotFoundException">PATH 环境变量具有一个包含引号的字符串。</exception>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Start : string * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要在进程中运行的应用程序文件的名称。</param>
        <param name="arguments">启动该进程时传递的命令行参数。</param>
        <summary>通过指定应用程序的名称和一组命令行参数来启动一个进程资源，并将该资源与新的 <see cref="T:System.Diagnostics.Process" /> 组件相关联。</summary>
        <returns>与进程资源关联的新 <see cref="T:System.Diagnostics.Process" />，如果未启动进程资源，则为 <see langword="null" />。 请注意，伴随同一进程中已运行的实例而启动的新进程将独立于其他进程。 此外，启动可能返回一个 <see cref="P:System.Diagnostics.Process.HasExited" /> 属性已设置为 <see langword="true" /> 的非 null 进程。 在这种情况下，启动的进程可能已激活现有实例自身，然后退出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载通过指定进程资源的文件名和命令行参数来启动进程资源。 重载将资源与新的 <xref:System.Diagnostics.Process> 对象相关联。  
  
> [!NOTE]
>  如果要启动的可执行文件的地址是 URL，则该进程将不会启动，并且将返回 `null`。  
  
 此重载使你可以在不先创建新的 <xref:System.Diagnostics.Process> 实例的情况下启动进程。 重载是一种替代方法，用于创建新的 <xref:System.Diagnostics.Process> 实例、设置 <xref:System.Diagnostics.Process.StartInfo%2A> 属性的 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 和 <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> 成员以及调用 <xref:System.Diagnostics.Process.Start%2A> 实例的 <xref:System.Diagnostics.Process>。  
  
 通过指定其文件名和参数启动进程类似于在 Windows `Start` 菜单的 "`Run`" 对话框中键入文件名和命令行参数。 因此，文件名不需要表示可执行文件。 它可以是与系统上安装的应用程序关联的任何文件类型。 例如，如果您已将文本文件与一个编辑器（如记事本）关联，则文件名可以具有 .txt 扩展名; 如果您已将 .doc 文件与 word 处理工具（如 Microsoft Word）相关联，则它可能具有 .doc。 同样，在 `fileName` 参数中，.exe 扩展名是可选的，这与 `Run` 对话框可以接受带有或不带 .exe 扩展名的可执行文件名的方式相同。 例如，可以将 `fileName` 参数设置为 "Notepad.exe" 或 "Notepad"。 如果 `fileName` 参数表示一个可执行文件，则 `arguments` 参数可能表示要对其执行操作的文件，如 `Notepad.exe myfile.txt`中的文本文件。 如果 `fileName` 参数表示一个命令（.cmd）文件，则 `arguments` 参数必须包括一个 "`/c`" 或 "`/k`" 参数，以指定命令窗口是在完成后退出还是保留。  
  
 与其他重载不同，没有参数的 <xref:System.Diagnostics.Process.Start%2A> 的重载不是 `static` 成员。 如果已创建 <xref:System.Diagnostics.Process> 实例和指定的开始信息（包括文件名），并且想要启动进程资源并将其与现有 <xref:System.Diagnostics.Process> 实例相关联，请使用此重载。 若要创建新的 <xref:System.Diagnostics.Process> 组件，而不是为现有组件启动进程，请使用 `static` 重载之一。 此重载和没有参数的重载都允许您指定要启动的进程资源的文件名以及要传递的命令行参数。  
  
 如果在系统中使用引号声明了路径变量，则在启动在该位置找到的任何进程时必须完全限定该路径。 否则，系统将找不到该路径。 例如，如果 `c:\mypath` 不在你的路径中，而你使用引号添加它： `path = %path%;"c:\mypath"`，则在启动时必须完全限定 `c:\mypath` 中的任何进程。  
  
> [!NOTE]
>  ASP.NET 网页和服务器控制代码在 Web 服务器上的 ASP.NET 工作进程上下文中执行。  如果在 ASP.NET 网页或服务器控件中使用 <xref:System.Diagnostics.Process.Start%2A> 方法，则新进程将在具有受限权限的 Web 服务器上执行。 该进程不会在与客户端浏览器相同的上下文中启动，也不能访问用户桌面。  
  
 无论何时使用 <xref:System.Diagnostics.Process.Start%2A> 来启动进程，都可能需要将其关闭或丢失系统资源。 使用 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 或 <xref:System.Diagnostics.Process.Kill%2A>关闭进程。 您可以使用其 <xref:System.Diagnostics.Process.HasExited%2A> 属性检查进程是否已关闭。 
  
 此处需要有关托管线程中的单元状态的说明。 当在进程组件的 <xref:System.Diagnostics.Process.StartInfo%2A> 属性中 `true` <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 时，请确保已在应用程序上设置了线程模型，方法是在 `main()` 方法上设置属性 `[STAThread]`。 否则，托管线程可以处于 `unknown` 状态或置于 `MTA` 状态，后者与 `true`的 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 发生冲突。 某些方法要求单元状态不 `unknown`。 如果未显式设置该状态，则当应用程序遇到此类方法时，它默认为 `MTA`，一旦设置，将无法更改单元状态。 但 `MTA` 会导致在操作系统 shell 管理线程时引发异常。  
  
   
  
## Examples  
 下面的示例首先生成 Internet Explorer 的一个实例，并在浏览器中显示 "收藏夹" 文件夹的内容。 然后，它将启动其他一些 Internet Explorer 实例，并显示某些特定页面或站点。 最后，当导航到特定站点时，它会在窗口最小化时启动 Internet Explorer。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="fileName" /> 或 <paramref name="arguments" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">打开关联的文件时出错。  

- 或 -

找不到 <paramref name="fileName" /> 中指定的文件。
  
- 或 - 
自变量的长度与该进程的完整路径的长度的总和超过了 2080。 与此异常关联的错误消息可以是下面其中一项：“传递给系统调用的数据区域太小。” 或“拒绝访问。”</exception>
        <exception cref="T:System.ObjectDisposedException">已释放此进程对象。</exception>
        <exception cref="T:System.IO.FileNotFoundException">PATH 环境变量具有一个包含引号的字符串。</exception>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="userName" Type="System.String" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="password" Type="System.Security.SecureString" Index="2" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="domain" Type="System.String" Index="3" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName">要在进程中运行的应用程序文件的名称。</param>
        <param name="userName">启动进程时使用的用户名。</param>
        <param name="password">包含启动进程时要使用的密码的 <see cref="T:System.Security.SecureString" />。</param>
        <param name="domain">启动进程时要使用的域。</param>
        <summary>通过指定应用程序的名称、用户名、密码和域来启动一个进程资源，并将该资源与新的 <see cref="T:System.Diagnostics.Process" /> 组件关联起来。</summary>
        <returns>与进程资源关联的新 <see cref="T:System.Diagnostics.Process" />，如果未启动进程资源，则为 <see langword="null" />。 请注意，伴随同一进程中已运行的实例而启动的新进程将独立于其他进程。 此外，启动可能返回一个 <see cref="P:System.Diagnostics.Process.HasExited" /> 属性已设置为 <see langword="true" /> 的非 null 进程。 在这种情况下，启动的进程可能已激活现有实例自身，然后退出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载通过指定新进程的文件名、用户名、密码和域来创建新进程及其主线程。 然后，新进程在指定凭据（用户、域和密码）的安全上下文中运行指定的可执行文件。  
  
> [!NOTE]
>  当可执行文件位于远程驱动器上时，必须使用统一资源标识符（URI）而不是链接驱动器号来标识网络共享。  
  
> [!NOTE]
>  如果要启动的可执行文件的地址是 URL，则该进程将不会启动，并且将返回 `null`。  
  
 此重载使你可以在不先创建新的 <xref:System.Diagnostics.Process> 实例的情况下启动进程。 重载是一种替代方法，用于创建新的 <xref:System.Diagnostics.Process> 实例、设置 <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> 属性的 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>、<xref:System.Diagnostics.ProcessStartInfo.UserName%2A>、<xref:System.Diagnostics.ProcessStartInfo.Password%2A>和 <xref:System.Diagnostics.Process.StartInfo%2A> 属性，以及调用 <xref:System.Diagnostics.Process.Start%2A> 实例的 <xref:System.Diagnostics.Process>。  
  
 同样，在 "**运行**" 对话框可以接受带有或不带 .exe 扩展名的可执行文件名的相同方式中，.exe 扩展名在 `fileName` 参数中是可选的。 例如，可以将 `fileName` 参数设置为 "Notepad.exe" 或 "Notepad"。 如果 `fileName` 参数表示一个可执行文件，则 `arguments` 参数可能表示要对其执行操作的文件，如 `Notepad.exe myfile.txt`中的文本文件。  
  
> [!NOTE]
>  文件名必须在具有 `userName`、`password`和 `domain` 参数的 <xref:System.Diagnostics.Process.Start%2A> 重载中表示可执行文件。  
  
 无论何时使用 <xref:System.Diagnostics.Process.Start%2A> 来启动进程，都可能需要将其关闭或丢失系统资源。 使用 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 或 <xref:System.Diagnostics.Process.Kill%2A>关闭进程。 您可以使用其 <xref:System.Diagnostics.Process.HasExited%2A> 属性检查进程是否已关闭。 
  
   
  
## Examples  
 下面的代码示例演示了如何使用此重载来启动可执行文件，还演示了在尝试启动与不可执行文件关联的应用程序时 <xref:System.ComponentModel.Win32Exception> 引发。  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未指定文件名。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">打开关联的文件时出错。

- 或 -

找不到 <paramref name="fileName" /> 中指定的文件。</exception>
        <exception cref="T:System.ObjectDisposedException">已释放此进程对象。</exception>
        <exception cref="T:System.PlatformNotSupportedException">Linux 或 macOS（仅适用于.NET Core）不支持此成员。</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arguments" Type="System.String" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="userName" Type="System.String" Index="2" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="password" Type="System.Security.SecureString" Index="3" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="domain" Type="System.String" Index="4" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName">要在进程中运行的应用程序文件的名称。</param>
        <param name="arguments">启动该进程时传递的命令行参数。</param>
        <param name="userName">启动进程时使用的用户名。</param>
        <param name="password">包含启动进程时要使用的密码的 <see cref="T:System.Security.SecureString" />。</param>
        <param name="domain">启动进程时要使用的域。</param>
        <summary>通过指定应用程序的名称、一组命令行自变量、用户名、密码和域来启动一个进程资源，并将该资源与新的 <see cref="T:System.Diagnostics.Process" /> 组件关联起来。</summary>
        <returns>与进程资源关联的新 <see cref="T:System.Diagnostics.Process" />，如果未启动进程资源，则为 <see langword="null" />。 请注意，伴随同一进程中已运行的实例而启动的新进程将独立于其他进程。 此外，启动可能返回一个 <see cref="P:System.Diagnostics.Process.HasExited" /> 属性已设置为 <see langword="true" /> 的非 null 进程。 在这种情况下，启动的进程可能已激活现有实例自身，然后退出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载通过指定新进程的文件名、命令行参数、用户名、密码和域来创建新进程及其主线程。 然后，新进程在指定凭据（用户、域和密码）的安全上下文中运行指定的可执行文件。  
  
> [!NOTE]
>  当可执行文件位于远程驱动器上时，必须使用统一资源标识符（URI）而不是链接驱动器号来标识网络共享。  
  
> [!NOTE]
>  如果要启动的可执行文件的地址是 URL，则该进程将不会启动，并且将返回 `null`。  
  
 此重载使你可以在不先创建新的 <xref:System.Diagnostics.Process> 实例的情况下启动进程。 重载是一种替代方法，用于创建新的 <xref:System.Diagnostics.Process> 实例、设置 <xref:System.Diagnostics.ProcessStartInfo.Password%2A>属性的 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>、<xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>、<xref:System.Diagnostics.ProcessStartInfo.UserName%2A>、<xref:System.Diagnostics.ProcessStartInfo.Domain%2A> 和 <xref:System.Diagnostics.Process.StartInfo%2A> 属性，以及调用 <xref:System.Diagnostics.Process.Start%2A> 实例的 <xref:System.Diagnostics.Process>。  
  
 同样，在 "**运行**" 对话框可以接受带有或不带 .exe 扩展名的可执行文件名的相同方式中，.exe 扩展名在 `fileName` 参数中是可选的。 例如，可以将 `fileName` 参数设置为 "Notepad.exe" 或 "Notepad"。 如果 `fileName` 参数表示一个可执行文件，则 `arguments` 参数可能表示要对其执行操作的文件，如 `Notepad.exe myfile.txt`中的文本文件。  
  
> [!NOTE]
>  文件名必须在具有 `userName`、`password`和 `domain` 参数的 <xref:System.Diagnostics.Process.Start%2A> 重载中表示可执行文件。  
  
 无论何时使用 <xref:System.Diagnostics.Process.Start%2A> 来启动进程，都可能需要将其关闭或丢失系统资源。 使用 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 或 <xref:System.Diagnostics.Process.Kill%2A>关闭进程。 您可以使用其 <xref:System.Diagnostics.Process.HasExited%2A> 属性检查进程是否已关闭。 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未指定文件名。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">打开关联的文件时出错。  

- 或 -

找不到 <paramref name="fileName" /> 中指定的文件。
  
- 或 - 
参数的长度与该关联文件的完整路径的长度的总和超过了 2080。 与此异常关联的错误消息可以是下面其中一项：“传递给系统调用的数据区域太小。” 或“拒绝访问。”</exception>
        <exception cref="T:System.ObjectDisposedException">已释放此进程对象。</exception>
        <exception cref="T:System.PlatformNotSupportedException">Linux 或 macOS（仅适用于.NET Core）不支持此成员。</exception>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartInfo : System.Diagnostics.ProcessStartInfo with get, set" Usage="System.Diagnostics.Process.StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartInfo")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置要传递给 <see cref="M:System.Diagnostics.Process.Start" /> 的 <see cref="T:System.Diagnostics.Process" /> 方法的属性。</summary>
        <value>表示启动进程时要使用的数据的 <see cref="T:System.Diagnostics.ProcessStartInfo" />。 这些自变量包括用于启动该进程的可执行文件或文档的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A> 表示要用于启动进程的参数集。 调用 <xref:System.Diagnostics.Process.Start%2A> 时，<xref:System.Diagnostics.Process.StartInfo%2A> 用于指定要启动的进程。 要设置的唯一必需 <xref:System.Diagnostics.Process.StartInfo%2A> 成员是 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 属性。 通过指定 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 属性启动进程类似于在 Windows "**开始**" 菜单的 "**运行**" 对话框中键入信息。 因此，<xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 属性不需要表示可执行文件。 它可以是与系统上安装的应用程序关联的任何文件类型。 例如，如果您已将文本文件与一个编辑器（如记事本）关联，则 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 可以具有 .txt 扩展名; 如果您已将 .doc 文件与 word 处理工具（如 Microsoft Word）相关联，则它可能具有 .doc。 同样，在 "**运行**" 对话框可以接受带有或不带 .exe 扩展名的可执行文件名的相同方式中，.exe 扩展名在 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 成员中是可选的。 例如，可以将 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 属性设置为 "Notepad.exe" 或 "Notepad"。  
  
 可以通过将 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 属性设置为最初安装应用程序的位置（例如，Web 地址）来启动 ClickOnce 应用程序。 不要通过在硬盘驱动器上指定其安装位置来启动 ClickOnce 应用程序。  
  
 如果文件名涉及不可执行的文件（如 .doc 文件），则可以包含谓词来指定要对文件执行的操作。 例如，可以将以 .doc 扩展名结尾的文件的 <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> 设置为 "Print"。 如果手动输入 <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> 属性的值，则 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 属性中指定的文件名不需要具有扩展名。 但是，如果使用 <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> 属性来确定哪些谓词可用，则必须包含该扩展。  
  
 你可以将 <xref:System.Diagnostics.Process.StartInfo%2A> 属性中指定的参数更改为对进程调用 <xref:System.Diagnostics.Process.Start%2A> 方法的时间。 开始该过程后，更改 <xref:System.Diagnostics.Process.StartInfo%2A> 的值不会影响或重启关联的进程。 如果在设置了 <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> 和 <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> 属性的情况下调用 <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> 方法，则将调用非托管 `CreateProcessWithLogonW` 函数，这将在新窗口中启动该进程，即使 <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> 属性值 `true` 或 <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> 属性值 <xref:System.Diagnostics.ProcessWindowStyle.Hidden>。  
  
 只应访问 <xref:System.Diagnostics.Process.Start%2A> 方法返回的 <xref:System.Diagnostics.Process> 对象的 <xref:System.Diagnostics.Process.StartInfo%2A> 属性。 例如，不应访问 <xref:System.Diagnostics.Process.GetProcesses%2A>返回的 <xref:System.Diagnostics.Process> 对象的 <xref:System.Diagnostics.Process.StartInfo%2A> 属性。 否则，在 .NET Core 中，<xref:System.Diagnostics.Process.StartInfo%2A> 属性将引发 <xref:System.InvalidOperationException> 并在上 .NET Framework 它将返回一个虚拟 <xref:System.Diagnostics.ProcessStartInfo> 对象。
  
 当进程启动时，文件名是填充（只读） <xref:System.Diagnostics.Process.MainModule%2A> 属性的文件。 如果要在启动进程后检索与进程关联的可执行文件，请使用 <xref:System.Diagnostics.Process.MainModule%2A> 属性。 如果要设置未启动关联进程的 <xref:System.Diagnostics.Process> 实例的可执行文件，请使用 <xref:System.Diagnostics.Process.StartInfo%2A> 属性的 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 成员。 由于 <xref:System.Diagnostics.Process.StartInfo%2A> 属性的成员是传递给进程的 <xref:System.Diagnostics.Process.Start%2A> 方法的参数，因此，在关联进程开始后更改 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 属性将不会重置 <xref:System.Diagnostics.Process.MainModule%2A> 属性。 这些属性仅用于初始化关联的进程。
  
## Examples  
 下面的示例使用要执行的文件、对其执行的操作以及是否应显示用户界面来填充 <xref:System.Diagnostics.Process.StartInfo%2A>。 有关其他示例，请参阅 <xref:System.Diagnostics.ProcessStartInfo> 类的属性的参考页。  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">指定 <see cref="P:System.Diagnostics.Process.StartInfo" /> 的值为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">仅限 .NET Core：<see cref="M:System.Diagnostics.Process.Start" /> 方法未用于启动进程。</exception>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.Process.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程启动的时间。</summary>
        <value>指示进程启动的时间的对象。 如果进程未运行，将会引发异常。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.StartTime" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <exception cref="T:System.InvalidOperationException">该进程已退出。  
  
 - 或 -  
  
 该进程尚未启动。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">调用 Windows 函数时出错。</exception>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.Process.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于封送由于进程退出事件而发出的事件处理程序调用的对象。</summary>
        <value><see cref="T:System.ComponentModel.ISynchronizeInvoke" />，它用于封送由于进程上的 <see cref="E:System.Diagnostics.Process.Exited" /> 事件而发出的事件处理程序调用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `null`<xref:System.Diagnostics.EventLog.SynchronizingObject%2A> 时，处理 <xref:System.Diagnostics.Process.Exited> 事件的方法将在系统线程池中的线程上调用。 有关系统线程池的详细信息，请参阅 <xref:System.Threading.ThreadPool>。  
  
 当 <xref:System.Diagnostics.Process.Exited> 事件由 visual Windows 窗体组件（如 <xref:System.Windows.Forms.Button>）处理时，通过系统线程池访问组件可能不起作用，或可能会导致异常。 通过将 <xref:System.Diagnostics.Process.SynchronizingObject%2A> 设置为 Windows 窗体组件来避免这种情况，这会导致在创建组件的线程上调用处理 <xref:System.Diagnostics.Process.Exited> 事件的方法。  
  
 如果在 Windows 窗体设计器中的 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] 内使用 <xref:System.Diagnostics.Process>，则 <xref:System.Diagnostics.Process.SynchronizingObject%2A> 将自动设置为包含 <xref:System.Diagnostics.Process>的控件。 例如，如果你将 <xref:System.Diagnostics.Process> 放置在 `Form1` 的设计器（从 <xref:System.Windows.Forms.Form>继承），则 <xref:System.Diagnostics.Process> 的 <xref:System.Diagnostics.Process.SynchronizingObject%2A> 属性将设置为 `Form1`的实例：  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 通常，当组件置于控件或窗体内时，将设置此属性，因为这些组件绑定到特定线程。  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Threads : System.Diagnostics.ProcessThreadCollection" Usage="System.Diagnostics.Process.Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessThreads")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在关联进程中运行的一组线程。</summary>
        <value>类型 <see cref="T:System.Diagnostics.ProcessThread" /> 的数组，表示当前在关联进程中运行的操作系统线程。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 线程执行进程中的代码。 每个进程都是使用单个线程（其主线程）启动的。 任何线程都可以创建其他线程。 进程中的线程共享进程的地址空间。  
  
 使用 <xref:System.Diagnostics.ProcessThread> 获取与当前进程关联的所有线程。 主线程不一定是数组中的索引零。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">进程没有 <see cref="P:System.Diagnostics.Process.Id" />，或者没有与 <see cref="T:System.Diagnostics.Process" /> 实例关联的进程。  
  
- 或 - 
关联进程已退出。</exception>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="process.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果适用，则将进程的名称格式化为字符串，并与父组件类型组合。</summary>
        <returns><see cref="P:System.Diagnostics.Process.ProcessName" />，与基组件的 <see cref="M:System.Object.ToString" /> 返回值组合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例启动记事本的实例。 然后，该示例检索并显示关联进程的各种属性。 该示例在进程退出时进行检测，并显示该进程的退出代码。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTotalProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此进程的总的处理器时间。</summary>
        <value><see cref="T:System.TimeSpan" />，它指示关联进程使用 CPU 的时间。 此值是 <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> 和 <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> 的和。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例启动记事本的实例。 然后，该示例检索并显示关联进程的各种属性。 该示例在进程退出时进行检测，并显示该进程的退出代码。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessUserProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此进程的用户处理器时间。</summary>
        <value><see cref="T:System.TimeSpan" />，它指示关联进程在该进程的应用程序部分内(而不是在操作系统内核中)运行代码所用的时间。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例启动记事本的实例。 然后，该示例检索并显示关联进程的各种属性。 该示例在进程退出时进行检测，并显示该进程的退出代码。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize : int" Usage="System.Diagnostics.Process.VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取进程的虚拟内存大小（以字节为单位）。</summary>
        <value>关联进程请求的虚拟内存量（以字节为单位）。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联进程分配的虚拟内存量（以字节为单位）。</summary>
        <value>为关联进程分配的虚拟内存量（以字节为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回的值表示进程使用的虚拟内存的当前大小（以字节为单位）。 操作系统将每个进程的虚拟地址空间映射到物理内存中加载的页，或映射到磁盘上的虚拟内存分页文件中存储的页。  
  
 此属性可用于监视包含32位处理器或64位处理器的计算机上的内存使用情况。 属性值等效于进程的**虚拟字节**性能计数器。  
  
   
  
## Examples  
 下面的代码示例启动记事本应用程序的实例。 然后，该示例检索并显示关联进程的各种属性。 该示例在进程退出时进行检测，并显示其退出代码和高峰内存统计信息。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>设置等待关联进程退出的时间段，并在该段时间结束前或该进程退出前，阻止当前线程执行。 若要避免妨碍当前线程，请使用 <see cref="E:System.Diagnostics.Process.Exited" /> 事件。  
  
有关代码示例，请参阅 <see cref="P:System.Diagnostics.Process.StandardError" /> 和 <see cref="P:System.Diagnostics.Process.ExitCode" /> 属性参考页。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : unit -&gt; unit" Usage="process.WaitForExit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>指示 <see cref="T:System.Diagnostics.Process" /> 组件无限期地等待关联进程退出。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit> 使当前线程等待，直到关联进程终止。  在进程上调用所有其他方法之后，应调用此方法。 若要避免妨碍当前线程，请使用 <xref:System.Diagnostics.Process.Exited> 事件。  
  
 此方法指示 <xref:System.Diagnostics.Process> 组件等待无限长的时间，以便进程和事件处理程序退出。 这可能导致应用程序停止响应。 例如，如果对具有用户界面的进程调用 <xref:System.Diagnostics.Process.CloseMainWindow%2A>，则在将进程写入从不进入其消息循环的情况下，将不会处理对操作系统的终止关联进程的请求。  
  
> [!NOTE]
>  在 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 及更早版本中，<xref:System.Diagnostics.Process.WaitForExit> 重载等待 <xref:System.Int32.MaxValue> 毫秒（约24天），而不是无限期等待。 此外，如果已达到完全 <xref:System.Int32.MaxValue> 时间，则以前的版本不会等待事件处理程序退出。  
  
 此重载确保所有处理都已完成，包括处理重定向标准输出的异步事件。 在将标准输出重定向到异步事件处理程序时，应在调用 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> 重载后使用此重载。  
  
 当关联进程退出时（即，当操作系统通过正常或异常终止关闭时），系统会存储有关进程的管理信息，并返回到已调用 <xref:System.Diagnostics.Process.WaitForExit>的组件。 然后，<xref:System.Diagnostics.Process> 组件可以通过使用退出过程的 <xref:System.Diagnostics.Process.Handle%2A> 来访问包含 <xref:System.Diagnostics.Process.ExitTime%2A>的信息。  
  
 由于关联进程已退出，因此该组件的 <xref:System.Diagnostics.Process.Handle%2A> 属性不再指向现有进程资源。 相反，句柄只能用来访问操作系统有关进程资源的信息。 系统会注意到未由 <xref:System.Diagnostics.Process> 组件发布的已退出进程的句柄，因此它会将 <xref:System.Diagnostics.Process.ExitTime%2A> 和 <xref:System.Diagnostics.Process.Handle%2A> 信息保留在内存中，直到 <xref:System.Diagnostics.Process> 组件专门释放资源。 出于此原因，无论何时为 <xref:System.Diagnostics.Process> 实例调用 <xref:System.Diagnostics.Process.Start%2A>，当关联进程终止并且不再需要有关其的任何管理信息时，请调用 <xref:System.Diagnostics.Process.Close%2A>。 <xref:System.Diagnostics.Process.Close%2A> 释放分配给退出进程的内存。  
  
   
  
## Examples  
 请参阅 <xref:System.Diagnostics.Process.StandardError%2A> 属性参考 "页的" 备注 "部分。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">无法访问等待设置。</exception>
        <exception cref="T:System.SystemException">尚未设置进程 <see cref="P:System.Diagnostics.Process.Id" />，而且不存在可从其确定 <see cref="P:System.Diagnostics.Process.Id" /> 属性的 <see cref="P:System.Diagnostics.Process.Handle" />。  
  
- 或 - 
没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。  
  
- 或 - 
你正尝试为远程计算机上运行的进程调用 <see cref="M:System.Diagnostics.Process.WaitForExit" /> 。 此方法仅对本地计算机上运行的进程可用。</exception>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : int -&gt; bool" Usage="process.WaitForExit milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">等待关联进程退出的时间(以毫秒为单位)。 最大值为 32 位整数的最大可能值，这对于操作系统而言表示无限大。</param>
        <summary>指示 <see cref="T:System.Diagnostics.Process" /> 组件在指定的毫秒数内等待关联进程退出。</summary>
        <returns>如果关联进程已退出，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> 使当前线程等待，直到关联进程终止。 在进程上调用所有其他方法之后，应调用此方法。 若要避免妨碍当前线程，请使用 <xref:System.Diagnostics.Process.Exited> 事件。  
  
 此方法指示 <xref:System.Diagnostics.Process> 组件等待一定的时间，以便进程退出。 如果在间隔结束时关联的进程未退出，因为终止请求被拒绝，`false` 将返回到调用过程。 您可以为 `milliseconds`指定 <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>，<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> 将与 <xref:System.Diagnostics.Process.WaitForExit> 重载的行为相同。 如果将0（零）传递给方法，则它仅在进程已退出时返回 `true`;否则，它会立即返回 `false`。  
  
> [!NOTE]
>  在 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 及更早版本中，如果 `milliseconds` 为-1，<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> 重载将等待 <xref:System.Int32.MaxValue> 毫秒（约24天），而不是无限期等待。  
  
 将标准输出重定向到异步事件处理程序后，在此方法返回时输出处理可能不会完成。 若要确保异步事件处理已完成，请在从此重载接收到 `true` 之后调用不带任何参数的 <xref:System.Diagnostics.Process.WaitForExit> 重载。 若要帮助确保在 Windows 窗体应用程序中正确地处理 <xref:System.Diagnostics.Process.Exited> 事件，请设置 <xref:System.Diagnostics.Process.SynchronizingObject%2A> 属性。  
  
 当关联进程退出时（由操作系统通过正常或异常终止关闭），系统会存储有关进程的管理信息，并返回到已调用 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>的组件。 然后，<xref:System.Diagnostics.Process> 组件可以通过使用退出过程的 <xref:System.Diagnostics.Process.Handle%2A> 来访问包含 <xref:System.Diagnostics.Process.ExitTime%2A>的信息。  
  
 由于关联进程已退出，因此该组件的 <xref:System.Diagnostics.Process.Handle%2A> 属性不再指向现有进程资源。 相反，句柄只能用来访问操作系统有关进程资源的信息。 系统会注意到未由 <xref:System.Diagnostics.Process> 组件发布的已退出进程的句柄，因此它会将 <xref:System.Diagnostics.Process.ExitTime%2A> 和 <xref:System.Diagnostics.Process.Handle%2A> 信息保留在内存中，直到 <xref:System.Diagnostics.Process> 组件专门释放资源。 出于此原因，无论何时为 <xref:System.Diagnostics.Process> 实例调用 <xref:System.Diagnostics.Process.Start%2A>，当关联进程终止并且不再需要有关其的任何管理信息时，请调用 <xref:System.Diagnostics.Process.Close%2A>。 <xref:System.Diagnostics.Process.Close%2A> 释放分配给退出进程的内存。  
  
   
  
## Examples  
 请参阅 <xref:System.Diagnostics.Process.ExitCode%2A> 属性的代码示例。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">无法访问等待设置。</exception>
        <exception cref="T:System.SystemException">尚未设置进程 <see cref="P:System.Diagnostics.Process.Id" />，而且不存在可从其确定 <see cref="P:System.Diagnostics.Process.Id" /> 属性的 <see cref="P:System.Diagnostics.Process.Handle" />。  
  
- 或 - 
没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。  
  
- 或 - 
你正尝试为远程计算机上运行的进程调用 <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> 。 此方法仅对本地计算机上运行的进程可用。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="milliseconds" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</exception>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WaitForExitAsync (System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WaitForExitAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExitAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExitAsync (Optional cancellationToken As CancellationToken = null) As Task" />
      <MemberSignature Language="F#" Value="member this.WaitForExitAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="process.WaitForExitAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">用于取消异步操作的可选令牌。</param>
        <summary>指示进程组件等待关联进程退出，或指示等待 <paramref name="cancellationToken" /> 被取消。</summary>
        <returns>将在已退出进程、已请求取消或出现错误时完成的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

调用此方法会将 <xref:System.Diagnostics.Process.EnableRaisingEvents> 设置为 `true`。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使 <see cref="T:System.Diagnostics.Process" /> 组件等待关联进程进入空闲状态。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : unit -&gt; bool" Usage="process.WaitForInputIdle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使 <see cref="T:System.Diagnostics.Process" /> 组件无限期地等待关联进程进入空闲状态。 此重载仅适用于具有用户界面并因此具有消息循环的进程。</summary>
        <returns>如果关联进程已经达到空闲状态，则为 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Diagnostics.Process.WaitForInputIdle> 强制对应用程序进行处理，直到消息循环返回到空闲状态。 如果执行具有用户界面的进程，则每次操作系统将 Windows 消息发送到该进程时，其消息循环都会执行。 然后，该进程返回到消息循环。 如果进程正在等待消息循环内的消息，则称该进程处于空闲状态。 此状态非常有用，例如，当应用程序需要等待启动进程完成创建其主窗口之前，应用程序才能与该窗口通信。  
  
 如果进程没有消息循环，<xref:System.Diagnostics.Process.WaitForInputIdle> 会引发 <xref:System.InvalidOperationException>。  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle> 重载指示 <xref:System.Diagnostics.Process> 组件无限期地等待进程在消息循环中处于空闲状态。 此指令可能导致应用程序停止响应。 例如，如果将进程编写为始终立即退出其消息循环，如代码片段 `while(true)`中所示。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">进程不具有图形界面。  
  
- 或 - 
发生未知错误。 进程无法进入空闲状态。  
  
- 或 - 
已经退出该进程。  
  
- 或 - 
没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</exception>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : int -&gt; bool" Usage="process.WaitForInputIdle milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="milliseconds">1 到 <see cref="F:System.Int32.MaxValue" /> 的值以毫秒为单位指定了等待关联进程变为空闲状态的时间量。 0 值指定立即返回，而 -1 值则指定无限期等待。</param>
        <summary>使 <see cref="T:System.Diagnostics.Process" /> 组件在指定的毫秒数内等待关联进程进入空闲状态。 此重载仅适用于具有用户界面并因此具有消息循环的进程。</summary>
        <returns>如果关联进程已经达到空闲状态，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> 强制对应用程序进行处理，直到消息循环返回到空闲状态。 如果执行具有用户界面的进程，则每次操作系统将 Windows 消息发送到该进程时，其消息循环都会执行。 然后，该进程返回到消息循环。 如果进程正在等待消息循环内的消息，则称该进程处于空闲状态。 此状态非常有用，例如，当应用程序需要等待启动进程完成创建其主窗口之前，应用程序才能与该窗口通信。  
  
 如果进程没有消息循环，<xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> 会引发 <xref:System.InvalidOperationException>。  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> 重载指示 <xref:System.Diagnostics.Process> 组件等待一段有限的时间，以便进程在消息循环中处于空闲状态。 如果在间隔结束时关联的进程未处于空闲状态，因为循环仍在处理消息，`false` 将返回到调用过程。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](/dotnet/standard/events/)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">进程不具有图形界面。  
  
- 或 - 
发生未知错误。 进程无法进入空闲状态。  
  
- 或 - 
已经退出该进程。  
  
- 或 - 
没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</exception>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int" Usage="System.Diagnostics.Process.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程的物理内存使用量（以字节为单位）。</summary>
        <value>关联进程当前使用的物理内存总量（以字节为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回的值表示进程使用的工作集内存的当前大小（以字节为单位）。 进程的工作集是当前对物理 RAM 内存中的进程可见的内存页集。 这些页是常驻的，可供应用程序使用，而不会触发页面错误。  
  
 工作集包括共享数据和私人数据。 共享数据包括包含进程执行的所有说明的页面，包括进程模块和系统库。  
  
   
  
## Examples  
 下面的示例启动记事本的实例。 然后，该示例检索并显示关联进程的各种属性。 该示例在进程退出时进行检测，并显示进程的退出代码。  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet64 : int64" Usage="System.Diagnostics.Process.WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联的进程分配的物理内存量（以字节为单位）。</summary>
        <value>为关的进程分配的物理内存量(以字节为单位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回的值表示进程使用的工作集内存的当前大小（以字节为单位）。 进程的工作集是当前对物理 RAM 内存中的进程可见的内存页集。 这些页是常驻的，可供应用程序使用，而不会触发页面错误。  
  
 工作集包括共享数据和私人数据。 共享数据包括包含进程执行的所有说明的页面，包括进程模块和系统库中的说明。  
  
 此属性可用于监视包含32位处理器或64位处理器的计算机上的内存使用情况。 属性值等效于进程的**工作集**性能计数器。  
  
   
  
## Examples  
 下面的代码示例启动记事本应用程序的实例。 然后，该示例检索并显示关联进程的各种属性。 该示例在进程退出时进行检测，并显示其退出代码和高峰内存统计信息。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>
