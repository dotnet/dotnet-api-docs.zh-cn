<Type Name="DiagnosticSource" FullName="System.Diagnostics.DiagnosticSource">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d6b4dc1248ba7b80c71b46d4c635ed51acffcb11" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86850410" /></Metadata><TypeSignature Language="C#" Value="public abstract class DiagnosticSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit DiagnosticSource extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.DiagnosticSource" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class DiagnosticSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class DiagnosticSource abstract" />
  <TypeSignature Language="F#" Value="type DiagnosticSource = class" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.1</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.0.4.0</AssemblyVersion>
    <AssemblyVersion>4.0.5.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="6e9bc-101">一个抽象类，它允许针对丰富数据有效负载的生产时日志记录检测代码，以在被检测的进程中使用。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-101">An abstract class that allows code to be instrumented for production-time logging of rich data payloads for consumption within the process that was instrumented.</span></span></summary>
    <remarks><span data-ttu-id="6e9bc-102">有关详细信息，请参阅 [DiagnosticSource 用户指南](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md)。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-102">For more information, see [DiagnosticSource User's Guide](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md).</span></span></remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DiagnosticSource ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DiagnosticSource();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6e9bc-103">初始化 <see cref="T:System.Diagnostics.DiagnosticSource" /> 类的实例。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-103">Initializes an instance of the <see cref="T:System.Diagnostics.DiagnosticSource" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public abstract bool IsEnabled (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnabled(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.IsEnabled(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function IsEnabled (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool IsEnabled(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member IsEnabled : string -&gt; bool" Usage="diagnosticSource.IsEnabled name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="6e9bc-104">正在写入的事件的名称。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-104">The name of the event being written.</span></span></param>
        <summary><span data-ttu-id="6e9bc-105">验证通知事件是否已启用。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-105">Verifies if the notification event is enabled.</span></span></summary>
        <returns><span data-ttu-id="6e9bc-106">如果通知事件已启用，为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-106"><see langword="true" /> if the notification event is enabled, <see langword="false" /> otherwise.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

<span data-ttu-id="6e9bc-107">如果有大量的通知设置，可以在执行此设置之前调用 IsEnabled。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-107">If there is expensive setup for the notification, you can call IsEnabled before performing this setup.</span></span> <span data-ttu-id="6e9bc-108">使用者不应假定他们仅获取 IsEnabled 为 true 的通知。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-108">Consumers should not assume that they only get notifications for which IsEnabled is true.</span></span> <span data-ttu-id="6e9bc-109">不过，对于创建者调用此 API，它是可选的。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-109">However, it is optional for producers to call this API.</span></span> <span data-ttu-id="6e9bc-110">该名称应与传递给的名称相同 <see cref="M:System.Diagnostics.DiagnosticSource.Write(System.String,System.Object)" /> 。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-110">The name should be the same as that passed to <see cref="M:System.Diagnostics.DiagnosticSource.Write(System.String,System.Object)" />.</span></span>

           ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public virtual bool IsEnabled (string? name, object arg1, object arg2 = default);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnabled(string name, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.IsEnabled(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnabled (name As String, arg1 As Object, Optional arg2 As Object = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member IsEnabled : string * obj * obj -&gt; bool&#xA;override this.IsEnabled : string * obj * obj -&gt; bool" Usage="diagnosticSource.IsEnabled (name, arg1, arg2)" />
      <MemberSignature Language="C#" Value="public virtual bool IsEnabled (string name, object arg1, object arg2 = default);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
        <Parameter Name="arg1" Type="System.Object" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
        <Parameter Name="arg2" Type="System.Object" Index="2" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="6e9bc-111">正在写入的事件的名称。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-111">The name of the event being written.</span></span></param>
        <param name="arg1"><span data-ttu-id="6e9bc-112">一个对象，它表示 IsEnabled 的附加上下文。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-112">An object that represents the additional context for IsEnabled.</span></span> <span data-ttu-id="6e9bc-113">使用者应会收到 <see langword="null" />，它可能表示生成方已调用纯 IsEnabled(string) 来检查使用者是否确实要获取此类事件的通知。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-113">Consumers should expect to receive <see langword="null" /> which may indicate that producer called pure IsEnabled(string) to check if consumer wants to get notifications for such events at all.</span></span> <span data-ttu-id="6e9bc-114">基于此，生成方可使用非 <see langword="null" /> 上下文再次调用 IsEnabled(string, object, object)。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-114">Based on that, producer may call IsEnabled(string, object, object) again with non-<see langword="null" /> context.</span></span></param>
        <param name="arg2"><span data-ttu-id="6e9bc-115">可选。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-115">Optional.</span></span> <span data-ttu-id="6e9bc-116">一个对象，它表示 IsEnabled 的附加上下文。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-116">An object that represents the additional context for IsEnabled.</span></span> <span data-ttu-id="6e9bc-117">默认值为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-117"><see langword="null" /> by default.</span></span> <span data-ttu-id="6e9bc-118">使用者应会收到 <see langword="null" />，它可能表示生成方已调用纯 IsEnabled(string) 或者已在 <paramref name="arg1" /> 中传递所有必要的上下文。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-118">Consumers should expect to receive <see langword="null" /> which may indicate that producer called pure IsEnabled(string) or producer passed all necessary context in <paramref name="arg1" />.</span></span></param>
        <summary><span data-ttu-id="6e9bc-119">验证通知事件是否已启用。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-119">Verifies it the notification event is enabled.</span></span></summary>
        <returns><span data-ttu-id="6e9bc-120">如果通知事件已启用，为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-120"><see langword="true" /> if the notification event is enabled, <see langword="false" /> otherwise.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
          
<span data-ttu-id="6e9bc-121">如果有大量的通知设置，可以在执行安装程序之前调用此方法并提供上下文。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-121">If there is expensive setup for the notification, you can call this method and provide context before performing the setup.</span></span>
          
           ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnActivityExport">
      <MemberSignature Language="C#" Value="public virtual void OnActivityExport (System.Diagnostics.Activity activity, object? payload);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnActivityExport(class System.Diagnostics.Activity activity, object payload) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.OnActivityExport(System.Diagnostics.Activity,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnActivityExport (activity As Activity, payload As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnActivityExport(System::Diagnostics::Activity ^ activity, System::Object ^ payload);" />
      <MemberSignature Language="F#" Value="abstract member OnActivityExport : System.Diagnostics.Activity * obj -&gt; unit&#xA;override this.OnActivityExport : System.Diagnostics.Activity * obj -&gt; unit" Usage="diagnosticSource.OnActivityExport (activity, payload)" />
      <MemberSignature Language="C#" Value="public virtual void OnActivityExport (System.Diagnostics.Activity activity, object payload);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Diagnostics.Activity" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="payload" Type="System.Object" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="activity"><span data-ttu-id="6e9bc-122">受外部事件影响的活动。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-122">The activity affected by an external event.</span></span></param>
        <param name="payload"><span data-ttu-id="6e9bc-123">一个表示传出请求的对象。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-123">An object that represents the outgoing request.</span></span></param>
        <summary><span data-ttu-id="6e9bc-124">将状态从活动转移到将在进程外发生的某些事件或操作，例如传出 HTTP 请求。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-124">Transfers state from an activity to some event or operation, such as an outgoing HTTP request, that will occur outside the process.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="6e9bc-125">如果检测站点位于活动离开进程 (如) 传出 HTTP 请求的位置，则该站点将需要将状态从活动传输到传出请求。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-125">If an instrumentation site is at a location where activities leave the process (such as outgoing HTTP requests), that site will want to transfer state from the activity to the outgoing request.</span></span>

<span data-ttu-id="6e9bc-126">在可能的情况下，应通过检测站点来完成此操作，因为在 <xref:System.Diagnostics.Activity> 检测站点的和 ougoing 请求逻辑之间存在一个约定。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-126">To the extent possible, this should be done by the instrumentation site, because there is a contract between an <xref:System.Diagnostics.Activity> and the ougoing request logic at the instrumentation site.</span></span>   <span data-ttu-id="6e9bc-127">不过，检测站点无法处理策略 (例如，出于兼容性原因，是否应禁用或以较旧的格式编写活动信息) 。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-127">However, the instrumentation site can't handle policy (for example, whether activity information should be disabled or written in an older format for compatibility reasons).</span></span>
<span data-ttu-id="6e9bc-128">为此，检测站点需要回调到日志记录系统，并要求它解析策略。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-128">For this, the instrumentation site needs to call back out to the logging system and ask it to resolve policy.</span></span> <span data-ttu-id="6e9bc-129">这是方法的用途 `OnActivityExport` 。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-129">This is the purpose of the `OnActivityExport` method.</span></span>

<span data-ttu-id="6e9bc-130">为 `OnActivityExport` 方法提供了 <xref:System.Diagnostics.Activity> 和表示传出请求的负载对象。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-130">The `OnActivityExport` method is given the <xref:System.Diagnostics.Activity> as well as a payload object that represents the outgoing request.</span></span> <span data-ttu-id="6e9bc-131"><xref:System.Diagnostics.DiagnosticSource>然后，订阅服务器能够在发送传出请求之前对其进行更新。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-131">A <xref:System.Diagnostics.DiagnosticSource> subscriber then has the ability to update the outgoing request before it is sent.</span></span>
 
<span data-ttu-id="6e9bc-132">请注意，在检测站点中很少使用此方法， (仅) 进程的传出边界上的那些站点。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-132">Note that this method is rarely used at instrumentation sites (only those sites that are on an outgoing boundary of the process).</span></span>   <span data-ttu-id="6e9bc-133">此外，通常情况下，检测站点执行的默认策略 (例如，将所有活动状态传输到特定传出约定) 可能会很好。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-133">Moreover, typically the default policy that the instrumentation site performs (for example, to transfer all activity state in a particular outgoing convention) is likely to be fine.</span></span> <span data-ttu-id="6e9bc-134">此方法仅适用于这是问题的情况。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-134">This method is only for cases where that is a problem.</span></span> <span data-ttu-id="6e9bc-135">因此，应该很少使用此方法，并且在这里，我们的 symetry `OnActivityImport` 和未来的校对。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-135">Thus, this method should be used very rarely and is mostly here for symetry with `OnActivityImport` and future-proofing.</span></span>

<span data-ttu-id="6e9bc-136">请注意， `payload` 在此处键入为 <xref:System.Object> ，但任何特定检测站点和订阅服务器应该知道有效负载的类型，因此在必要时对其进行强制转换和解码。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-136">Note that `payload` is typed as an <xref:System.Object> here, but any particular instrumentation site and subscriber should know the type of the payload and thus cast and decode it if necessary.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnActivityImport">
      <MemberSignature Language="C#" Value="public virtual void OnActivityImport (System.Diagnostics.Activity activity, object? payload);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnActivityImport(class System.Diagnostics.Activity activity, object payload) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.OnActivityImport(System.Diagnostics.Activity,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnActivityImport (activity As Activity, payload As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnActivityImport(System::Diagnostics::Activity ^ activity, System::Object ^ payload);" />
      <MemberSignature Language="F#" Value="abstract member OnActivityImport : System.Diagnostics.Activity * obj -&gt; unit&#xA;override this.OnActivityImport : System.Diagnostics.Activity * obj -&gt; unit" Usage="diagnosticSource.OnActivityImport (activity, payload)" />
      <MemberSignature Language="C#" Value="public virtual void OnActivityImport (System.Diagnostics.Activity activity, object payload);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Diagnostics.Activity" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="payload" Type="System.Object" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="activity"><span data-ttu-id="6e9bc-137">受外部事件影响的活动。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-137">The activity affected by an external event.</span></span></param>
        <param name="payload"><span data-ttu-id="6e9bc-138">表示传入请求的有效负载。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-138">A payload that represents the incoming request.</span></span></param>
        <summary><span data-ttu-id="6e9bc-139">将状态从将在进程外发生的某些事件或操作（例如传入请求）转移到活动。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-139">Transfers state to an activity from some event or operation, such as an incoming request, that occurred outside the process.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="6e9bc-140">如果检测站点创建新活动以响应进程外的某个事件，例如) 的传入 HTTP 请求，则该 `OnActivityImport` 方法将允许该站点创建新的活动并将传入请求的状态传输到活动。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-140">If an instrumentation site creates a new activity in response to some event outside the process, such as an incomming HTTP request), the `OnActivityImport` method allows that site will want to create a new activity and transfer state from the incoming request to the activity.</span></span> 

<span data-ttu-id="6e9bc-141">在可能的情况下，应通过检测站点来完成此操作，因为在 <xref:System.Diagnostics.Activity> 检测站点的和传入请求逻辑之间存在一个约定。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-141">To the extent possible, this should be done by the instrumentation site, because there is a contract between the <xref:System.Diagnostics.Activity> and the incomming request logic at the instrumentation site.</span></span>   <span data-ttu-id="6e9bc-142">不过，检测站点无法处理策略。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-142">However, the instrumentation site can't handle policy.</span></span> <span data-ttu-id="6e9bc-143"> (例如，如果执行了采样，应确切地对哪些请求进行抽样？ ) 在这种情况下，检测站点需要回调日志记录系统，并要求它解析策略 (例如，决定是否应将活动的 "采样" 位设置) 。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-143">(For example, if sampling is done, exactly which requests should be sampled?) In these cases, the instrumentation site needs to call back out to the logging system and ask it to resolve policy (for example, to decide if the activity's "sampling" bit should be set).</span></span> <span data-ttu-id="6e9bc-144">这是方法的用途 `OnActivityImport` 。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-144">This is the purpose of the `OnActivityImport` method.</span></span> <span data-ttu-id="6e9bc-145">向其提供活动以及表示传入请求的负载对象。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-145">It is given the activity as well as a payload object that represents the incomming request.</span></span> <span data-ttu-id="6e9bc-146">然后，订阅者可以 <xref:System.Diagnostics.DiagnosticSource> 根据需要更新此活动。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-146">The subscribers to the <xref:System.Diagnostics.DiagnosticSource> then have the opportunity to update this activity as desired.</span></span> 

<span data-ttu-id="6e9bc-147">此方法在检测站点中很少使用， (仅在进程) 的站点上，instrumetation 站点实现某些默认策略 (它以 *某种* 方式在) 中设置活动，因此，如果该默认策略正常，则不需要重写此方法。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-147">This method is rarely used at instrumentation sites (only those sites that are on the boundary of the process), and the instrumetation site implements some default policy (it sets the activity in *some* way), and so it is not necessary to override this method if that default policy is fine.</span></span> <span data-ttu-id="6e9bc-148">换句话说，应在极少数 (中重写此方法，但通常) 情况下要重写。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-148">In other words, this method should be overridden in very rare (but often important) cases.</span></span>

<span data-ttu-id="6e9bc-149">请注意， `payload` 在 <xref:System.Object> 此处键入，但任何特定检测站点和订阅服务器都将知道有效负载的类型，因此在必要时对其进行强制转换和解码。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-149">Note that `payload` is typed as <xref:System.Object> here, but any particular instrumentation site and subscriber will know the type of the payload and thus cast and decode it if necessary.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartActivity">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Activity StartActivity (System.Diagnostics.Activity activity, object? args);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Activity StartActivity(class System.Diagnostics.Activity activity, object args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.StartActivity(System.Diagnostics.Activity,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartActivity (activity As Activity, args As Object) As Activity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Diagnostics::Activity ^ StartActivity(System::Diagnostics::Activity ^ activity, System::Object ^ args);" />
      <MemberSignature Language="F#" Value="member this.StartActivity : System.Diagnostics.Activity * obj -&gt; System.Diagnostics.Activity" Usage="diagnosticSource.StartActivity (activity, args)" />
      <MemberSignature Language="C#" Value="public System.Diagnostics.Activity StartActivity (System.Diagnostics.Activity activity, object args);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Activity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Diagnostics.Activity" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
        <Parameter Name="args" Type="System.Object" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="activity"><span data-ttu-id="6e9bc-150">要启动的 <see cref="T:System.Diagnostics.Activity" />。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-150">The <see cref="T:System.Diagnostics.Activity" /> to be started.</span></span></param>
        <param name="args"><span data-ttu-id="6e9bc-151">一个对象，它表示作为事件的有效负载传递的值。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-151">An object that represent the value being passed as a payload for the event.</span></span></param>
        <summary><span data-ttu-id="6e9bc-152">启动 <see cref="T:System.Diagnostics.Activity" /> 并写入启动事件。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-152">Starts an <see cref="T:System.Diagnostics.Activity" /> and writes a start event.</span></span></summary>
        <returns><span data-ttu-id="6e9bc-153">便于链接的已启动的活动。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-153">The started activity for convenient chaining.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
           
<span data-ttu-id="6e9bc-154"><xref:System.Diagnostics.Activity>描述逻辑操作、其上下文和父关系，当前在 <xref:System.Diagnostics.Activity> 处理操作过程中流动。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-154">The <xref:System.Diagnostics.Activity> describes the logical operation, its context, and parent relation; the current <xref:System.Diagnostics.Activity> flows through the operation processing.</span></span>

<span data-ttu-id="6e9bc-155">此方法启动给定的 <xref:System.Diagnostics.Activity> ，维护给定的全局 <xref:System.Diagnostics.Activity.Current?displayProperty=nameWithType> 和 <xref:System.Diagnostics.Activity.Parent?displayProperty=nameWithType> 活动 <xref:System.Diagnostics.Activity> ，并通知使用者已开始新的 <xref:System.Diagnostics.Activity> 。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-155">This method starts the given <xref:System.Diagnostics.Activity>, maintains a global <xref:System.Diagnostics.Activity.Current?displayProperty=nameWithType> and <xref:System.Diagnostics.Activity.Parent?displayProperty=nameWithType> activity for the given <xref:System.Diagnostics.Activity>, and notifies consumers that a new <xref:System.Diagnostics.Activity> was started.</span></span> <span data-ttu-id="6e9bc-156">使用者可以访问 <xref:System.Diagnostics.Activity.Current?displayProperty=nameWithType> 添加上下文和/或增加遥测数据。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-156">Consumers can access <xref:System.Diagnostics.Activity.Current?displayProperty=nameWithType> to add context and/or augment telemetry.</span></span>

<span data-ttu-id="6e9bc-157">创建者可以向有效负载中的使用者传递其他详细信息。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-157">Producers may pass additional details to the consumer in the payload.</span></span>

           ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StopActivity">
      <MemberSignature Language="C#" Value="public void StopActivity (System.Diagnostics.Activity activity, object? args);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StopActivity(class System.Diagnostics.Activity activity, object args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.StopActivity(System.Diagnostics.Activity,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StopActivity (activity As Activity, args As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StopActivity(System::Diagnostics::Activity ^ activity, System::Object ^ args);" />
      <MemberSignature Language="F#" Value="member this.StopActivity : System.Diagnostics.Activity * obj -&gt; unit" Usage="diagnosticSource.StopActivity (activity, args)" />
      <MemberSignature Language="C#" Value="public void StopActivity (System.Diagnostics.Activity activity, object args);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Diagnostics.Activity" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
        <Parameter Name="args" Type="System.Object" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="activity"><span data-ttu-id="6e9bc-158">要停止的活动。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-158">The activity to be stopped.</span></span></param>
        <param name="args"><span data-ttu-id="6e9bc-159">一个对象，它表示作为事件的有效负载传递的值。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-159">An object that represents the value passed as a payload for the event.</span></span></param>
        <summary><span data-ttu-id="6e9bc-160">停止给定的 <see cref="T:System.Diagnostics.Activity" />，维护全局 <see cref="P:System.Diagnostics.Activity.Current" /> 活动，并通知使用者 <see cref="T:System.Diagnostics.Activity" /> 已停止。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-160">Stops the given <see cref="T:System.Diagnostics.Activity" />, maintains the global <see cref="P:System.Diagnostics.Activity.Current" /> activity, and notifies consumers that the <see cref="T:System.Diagnostics.Activity" /> was stopped.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="6e9bc-161">创建者可以向有效负载中的使用者传递其他详细信息。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-161">Producers may pass additional details to the consumer in the payload.</span></span>

<span data-ttu-id="6e9bc-162">使用者可以访问 <xref:System.Diagnostics.Activity.Current?displayProperty=nameWithType> 添加上下文和/或增加遥测数据。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-162">Consumers can access <xref:System.Diagnostics.Activity.Current?displayProperty=nameWithType> to add context and/or augment telemetry.</span></span>


         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public abstract void Write (string name, object? value);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(string name, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.Write(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Write (name As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Write(System::String ^ name, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Write : string * obj -&gt; unit" Usage="diagnosticSource.Write (name, value)" />
      <MemberSignature Language="C#" Value="public abstract void Write (string name, object value);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="6e9bc-163">正在写入的事件的名称。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-163">The name of the event being written.</span></span></param>
        <param name="value"><span data-ttu-id="6e9bc-164">一个对象，它表示作为事件的有效负载传递的值。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-164">An object that represents the value being passed as a payload for the event.</span></span> <span data-ttu-id="6e9bc-165">这通常是一个包含多个子值的匿名类型。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-165">This is often an anonymous type which contains several sub-values.</span></span></param>
        <summary><span data-ttu-id="6e9bc-166">提供记录复杂有效负载的通用方法。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-166">Provides a generic way of logging complex payloads.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="6e9bc-167">将为每个通知提供一个标识它的名称，以及一个对象 (通常是匿名类型) ，该类型提供任意信息以传递到通知。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-167">Each notification is given a name that identifies it, as well as an object (typically an anonymous type) that provides arbitrary information to pass to the notification.</span></span>  

<span data-ttu-id="6e9bc-168">`name` 应为 short。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-168">`name` should be short.</span></span> <span data-ttu-id="6e9bc-169">不要使用完全限定的名称，除非 `name` 必须是全局唯一的。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-169">Don't use a fully qualified name unless you have to to avoid ambiguity, since `name` must be globally unique.</span></span> <span data-ttu-id="6e9bc-170">通常， *componentName*（其中 *ComponentName* 和 *事件名称* 是小于10个字符的字符串）是一个很好的折衷。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-170">Typically, *componentName.eventName*, where *componentName* and *eventName* are strings less than 10 characters, are a good compromise.</span></span>

<span data-ttu-id="6e9bc-171">通知名称不应包含 `.` 在其中，因为组件名称具有点，并且它们都具有点来导致歧义。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-171">Notification names should not have `.` in them because component names have dots, and for them both to have dots leads to ambiguity.</span></span> <span data-ttu-id="6e9bc-172">建议改用 `_` 。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-172">We suggest that you use `_` instead.</span></span>

<span data-ttu-id="6e9bc-173">假定侦听器将使用字符串前缀来筛选组。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-173">Assume that listeners will use string prefixing to filter groups.</span></span> <span data-ttu-id="6e9bc-174">因此，具有组件名称的层次结构是一种很好的做法。</span><span class="sxs-lookup"><span data-stu-id="6e9bc-174">Therefore, having a hierarchy of component names is a good practice.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
