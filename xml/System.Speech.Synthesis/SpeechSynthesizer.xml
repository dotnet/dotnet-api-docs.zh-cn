<Type Name="SpeechSynthesizer" FullName="System.Speech.Synthesis.SpeechSynthesizer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9d3ca5fa899ed39eb78dde170e1d685bfb3cd925" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86589587" /></Metadata><TypeSignature Language="C#" Value="public sealed class SpeechSynthesizer : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SpeechSynthesizer extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Speech.Synthesis.SpeechSynthesizer" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SpeechSynthesizer&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SpeechSynthesizer sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type SpeechSynthesizer = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Speech</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>提供对已安装的语音合成引擎的功能的访问。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你创建新的 <xref:System.Speech.Synthesis.SpeechSynthesizer> 对象时，它将使用默认系统声音。 若要将配置 <xref:System.Speech.Synthesis.SpeechSynthesizer> 为使用其中一个安装的语音合成 (文本到语音) 声音，请使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.SelectVoice%2A> 或 <xref:System.Speech.Synthesis.SpeechSynthesizer.SelectVoiceByHints%2A> 方法。 若要获取有关已安装的声音的信息，请使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> 方法和 <xref:System.Speech.Synthesis.VoiceInfo> 类。  
  
 此类还可控制语音合成的以下方面：  
  
-   若要为对象配置输出 <xref:System.Speech.Synthesis.SpeechSynthesizer> ，请使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToAudioStream%2A> 、、 <xref:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToDefaultAudioDevice%2A> <xref:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToNull%2A> 和 <xref:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToWaveFile%2A> 方法。  
  
-   若要生成语音，请使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.Speak%2A> 、 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsync%2A> 、 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakSsml%2A> 或 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakSsmlAsync%2A> 方法。 <xref:System.Speech.Synthesis.SpeechSynthesizer>可以从文本、 <xref:System.Speech.Synthesis.Prompt> 或 <xref:System.Speech.Synthesis.PromptBuilder> 对象或[语音合成标记语言（ (SSML) 版本 1.0](https://go.microsoft.com/fwlink/?LinkId=201763)）生成语音。  
  
-   若要暂停和继续语音合成，请使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.Pause%2A> 和 <xref:System.Speech.Synthesis.SpeechSynthesizer.Resume%2A> 方法。  
  
-   若要添加或删除字典，请使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.AddLexicon%2A> 和 <xref:System.Speech.Synthesis.SpeechSynthesizer.RemoveLexicon%2A> 方法。 <xref:System.Speech.Synthesis.SpeechSynthesizer>可以使用一个或多个词典来指导其单词的发音。  
  
-   若要修改语音输出的传送，请使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.Rate%2A> 和 <xref:System.Speech.Synthesis.SpeechSynthesizer.Volume%2A> 属性。  
  
 在出现 <xref:System.Speech.Synthesis.SpeechSynthesizer> 提示时，引发事件时引发事件： (<xref:System.Speech.Synthesis.SpeechSynthesizer.BookmarkReached> 、 <xref:System.Speech.Synthesis.SpeechSynthesizer.PhonemeReached> 、 <xref:System.Speech.Synthesis.SpeechSynthesizer.VisemeReached> 和 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakProgress>) 。 它还会引发报告开始 (的事件 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakStarted>) 和结束 (<xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakCompleted> 说话操作的) ，并在说话语音 (<xref:System.Speech.Synthesis.SpeechSynthesizer.VoiceChange>) 。  
  
> [!NOTE]
>  每次释放对 <xref:System.Speech.Synthesis.SpeechSynthesizer.Dispose%2A> 的最后一个引用前，均应调用 <xref:System.Speech.Synthesis.SpeechSynthesizer>。 否则，在垃圾回收器调用 <xref:System.Speech.Synthesis.SpeechSynthesizer> 对象的 <xref:System.Object.Finalize%2A> 方法之前，该对象正在使用的资源不会被释放。  
  
   
  
## Examples  
 下面的示例是一个控制台应用程序的一部分，该应用程序初始化 <xref:System.Speech.Synthesis.SpeechSynthesizer> 对象并讲述一个字符串。  
  
```csharp  
  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      SpeechSynthesizer synth = new SpeechSynthesizer();  
  
      // Configure the audio output.   
      synth.SetOutputToDefaultAudioDevice();  
  
      // Speak a string.  
      synth.Speak("This example demonstrates a basic use of Speech Synthesizer");  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Speech.Synthesis.InstalledVoice" />
    <altmember cref="T:System.Speech.Synthesis.Prompt" />
    <altmember cref="T:System.Speech.Synthesis.PromptBuilder" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361644(v%3doffice.14)">语音合成</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SpeechSynthesizer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SpeechSynthesizer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Speech.Synthesis.SpeechSynthesizer" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 初始化新的实例时 <xref:System.Speech.Synthesis.SpeechSynthesizer> ，它将使用默认系统语音。 若要将配置 <xref:System.Speech.Synthesis.SpeechSynthesizer> 为使用其中一个安装的语音合成 (文本到语音) 声音，请使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.SelectVoice%2A> 或 <xref:System.Speech.Synthesis.SpeechSynthesizer.SelectVoiceByHints%2A> 方法。 若要获取有关已安装的声音的信息，请使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> 方法和 <xref:System.Speech.Synthesis.VoiceInfo> 类。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Synthesis.InstalledVoice" />
        <altmember cref="M:System.Speech.Synthesis.SpeechSynthesizer.SelectVoice(System.String)" />
        <altmember cref="M:System.Speech.Synthesis.SpeechSynthesizer.SelectVoiceByHints(System.Speech.Synthesis.VoiceGender)" />
        <altmember cref="M:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices" />
      </Docs>
    </Member>
    <Member MemberName="AddLexicon">
      <MemberSignature Language="C#" Value="public void AddLexicon (Uri uri, string mediaType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLexicon(class System.Uri uri, string mediaType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.AddLexicon(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLexicon (uri As Uri, mediaType As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLexicon(Uri ^ uri, System::String ^ mediaType);" />
      <MemberSignature Language="F#" Value="member this.AddLexicon : Uri * string -&gt; unit" Usage="speechSynthesizer.AddLexicon (uri, mediaType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
        <Parameter Name="mediaType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uri">词典信息的位置。</param>
        <param name="mediaType">词典的媒体类型。 媒体类型值不区分大小写。</param>
        <summary>将 <see cref="T:System.Speech.Synthesis.SpeechSynthesizer" /> 添加到该对象的词典中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 发音词典是单词或短语的集合及其发音，其中包括来自支持的拼音字母表中的字母和字符。 在应用程序中，可以使用字典为专用词汇指定自定义发音。  
  
 外部词典文件中指定的发音优先于语音合成器的内部词典或词典的发音。 但是，在使用、或方法创建的提示中，以内联方式指定的发音 <xref:System.Speech.Synthesis.PromptBuilder.AppendTextWithPronunciation%2A> <xref:System.Speech.Synthesis.PromptBuilder.AppendSsmlMarkup%2A> <xref:System.Speech.Synthesis.PromptBuilder.AppendSsml%2A> 优先于在任何词典中指定的发音。 内嵌发音仅适用于单词的单个匹配项。 有关详细信息，请参阅 [词典和拼音字母表](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh378335(v%3doffice.14)) 。  
  
 您可以向一个对象添加多个词典 <xref:System.Speech.Synthesis.SpeechSynthesizer> 。对于参数，当前支持两个值 `mediaType` ：  
  
-   值 `application/pls+xml` 指示词典符合 [发音词典规范 (PLS) 版本 1.0](https://go.microsoft.com/fwlink/?LinkId=201766)。 这是要使用的首选格式。  
  
-   该值 `application/vdn.ms-sapi-lex` 指示词典格式是一种 Microsoft 专有格式的未压缩词典。 这是旧格式，建议使用上述 PLS 格式。  
  
   
  
## Examples  
 下面的示例演示添加和删除包含单词 "blue" 的自定义发音的字典的效果。 字典将 "blue" 的发音定义为 "bleep"。 加载词典时，语音合成器使用词典中定义的发音。  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToDefaultAudioDevice();  
  
        // Speak the prompt.  
        synth.Speak("My favorite color is blue.");  
  
        // Add a lexicon that changes the pronunciation of "blue".  
        synth.AddLexicon(new Uri("C:\\test\\Blue.pls"), "application/pls+xml");  
  
        // Speak the prompt.  
        synth.Speak("My favorite color is blue.");  
  
        // Remove the lexicon.  
        synth.RemoveLexicon(new Uri("C:\\test\\Blue.pls"));  
  
        // Speak the prompt.  
        synth.Speak("My favorite color is blue.");  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
```  
  
 以下是词典文件 pls 的内容：  
  
```xml  
<?xml version="1.0" encoding="UTF-8"?>  
  
<lexicon version="1.0"   
      xmlns="http://www.w3.org/2005/01/pronunciation-lexicon"  
      alphabet="x-microsoft-ups" xml:lang="en-US">  
  
  <lexeme>  
    <grapheme> blue </grapheme>  
    <phoneme> B L I P </phoneme>  
  </lexeme>  
  
</lexicon>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Synthesis.SpeechSynthesizer.RemoveLexicon(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="BookmarkReached">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Speech.Synthesis.BookmarkReachedEventArgs&gt; BookmarkReached;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Speech.Synthesis.BookmarkReachedEventArgs&gt; BookmarkReached" />
      <MemberSignature Language="DocId" Value="E:System.Speech.Synthesis.SpeechSynthesizer.BookmarkReached" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BookmarkReached As EventHandler(Of BookmarkReachedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Speech::Synthesis::BookmarkReachedEventArgs ^&gt; ^ BookmarkReached;" />
      <MemberSignature Language="F#" Value="member this.BookmarkReached : EventHandler&lt;System.Speech.Synthesis.BookmarkReachedEventArgs&gt; " Usage="member this.BookmarkReached : System.EventHandler&lt;System.Speech.Synthesis.BookmarkReachedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Speech.Synthesis.BookmarkReachedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Speech.Synthesis.SpeechSynthesizer" /> 在提示中遇到书签时引发。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Synthesis.SpeechSynthesizer>当处理 <xref:System.Speech.Synthesis.SpeechSynthesizer.Speak%2A> 、、 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsync%2A> <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakSsml%2A> 或方法中的任何时，将引发此事件 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakSsmlAsync%2A> 。 有关与事件关联的数据的信息，请参阅 <xref:System.Speech.Synthesis.BookmarkReachedEventArgs> 。  
  
 您可以使用方法添加书签 <xref:System.Speech.Synthesis.PromptBuilder.AppendBookmark%2A> 。  
  
   
  
## Examples  
 下面的示例创建一个提示，其中包含两个书签，并将输出发送到 WAV 文件以进行播放。 事件的处理程序会 <xref:System.Speech.Synthesis.SpeechSynthesizer.BookmarkReached> 在事件引发到控制台时写入书签的名称及其在音频流中的位置。  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToWaveFile(@"C:\test\weather.wav");  
  
        // Create a SoundPlayer instance to play the output audio file.  
        System.Media.SoundPlayer m_SoundPlayer =  
          new System.Media.SoundPlayer(@"C:\test\weather.wav");  
  
        // Build a prompt and append bookmarks.  
        PromptBuilder builder = new PromptBuilder(  
          new System.Globalization.CultureInfo("en-US"));  
        builder.AppendText(  
          "The weather forecast for today is partly cloudy with some sun breaks.");  
        builder.AppendBookmark("Daytime forecast");  
        builder.AppendText(  
          "Tonight's weather will be cloudy with a 30% chance of showers.");  
        builder.AppendBookmark("Nighttime forecast");  
  
        // Add a handler for the BookmarkReached event.  
        synth.BookmarkReached +=  
          new EventHandler<BookmarkReachedEventArgs>(synth_BookmarkReached);  
  
        // Speak the prompt and play back the output file.  
        synth.Speak(builder);  
        m_SoundPlayer.Play();  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  
    // Write the name and position of the bookmark to the console.  
    static void synth_BookmarkReached(object sender, BookmarkReachedEventArgs e)  
    {  
      Console.WriteLine("Bookmark ({0}) reached at: {1} ",  
        e.Bookmark, e.AudioPosition);  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="speechSynthesizer.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>处置 <see cref="T:System.Speech.Synthesis.SpeechSynthesizer" /> 对象并释放会话期间使用的资源。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~SpeechSynthesizer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!SpeechSynthesizer ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="speechSynthesizer.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>方法在未能调用 <see cref="M:System.Speech.Synthesis.SpeechSynthesizer.Dispose" /> 的情况下的事件中充当防护措施来清理资源。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentlySpokenPrompt">
      <MemberSignature Language="C#" Value="public System.Speech.Synthesis.Prompt GetCurrentlySpokenPrompt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Speech.Synthesis.Prompt GetCurrentlySpokenPrompt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.GetCurrentlySpokenPrompt" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentlySpokenPrompt () As Prompt" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Speech::Synthesis::Prompt ^ GetCurrentlySpokenPrompt();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentlySpokenPrompt : unit -&gt; System.Speech.Synthesis.Prompt" Usage="speechSynthesizer.GetCurrentlySpokenPrompt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Synthesis.Prompt</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取 <see cref="T:System.Speech.Synthesis.SpeechSynthesizer" /> 正在讲话的提示。</summary>
        <returns>返回当前正在朗读的提示对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
  
```csharp  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInstalledVoices">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回系统上当前安装的语音合成（文字到语音）语音的集合。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当应用程序调用时 <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> ，该方法将验证每个声音 (的文本到语音转换引擎是否在注册表中找到) 满足某些最低标准。 对于验证失败的任何语音， <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> 将其 <xref:System.Speech.Synthesis.InstalledVoice.Enabled%2A> 属性设置为 `False` 。 应用程序无法选择其 <xref:System.Speech.Synthesis.InstalledVoice.Enabled%2A> 属性为的声音 `False` 。 通常，应用程序不会设置语音的 <xref:System.Speech.Synthesis.InstalledVoice.Enabled%2A> 属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInstalledVoices">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Speech.Synthesis.InstalledVoice&gt; GetInstalledVoices ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Speech.Synthesis.InstalledVoice&gt; GetInstalledVoices() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInstalledVoices () As ReadOnlyCollection(Of InstalledVoice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Speech::Synthesis::InstalledVoice ^&gt; ^ GetInstalledVoices();" />
      <MemberSignature Language="F#" Value="member this.GetInstalledVoices : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Speech.Synthesis.InstalledVoice&gt;" Usage="speechSynthesizer.GetInstalledVoices " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Speech.Synthesis.InstalledVoice&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回所有安装的语音合成（文字到语音）语音。</summary>
        <returns>返回当前安装在系统的语音的只读集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 语音是系统上安装的语音合成 (文本到语音转换或 TTS) 的引擎。  
  
   
  
## Examples  
 下面的示例是一个控制台应用程序的一部分，该应用程序初始化 <xref:System.Speech.Synthesis.SpeechSynthesizer> 对象并输出到控制台，其中列出了语音) 合成 (引擎，并演示了每个语音可用的信息。  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
using System.Speech.AudioFormat;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Output information about all of the installed voices.   
        Console.WriteLine("Installed voices -");  
        foreach (InstalledVoice voice in synth.GetInstalledVoices())  
        {  
          VoiceInfo info = voice.VoiceInfo;  
          string AudioFormats = "";  
          foreach (SpeechAudioFormatInfo fmt in info.SupportedAudioFormats)  
          {  
            AudioFormats += String.Format("{0}\n",  
            fmt.EncodingFormat.ToString());  
          }  
  
          Console.WriteLine(" Name:          " + info.Name);  
          Console.WriteLine(" Culture:       " + info.Culture);  
          Console.WriteLine(" Age:           " + info.Age);  
          Console.WriteLine(" Gender:        " + info.Gender);  
          Console.WriteLine(" Description:   " + info.Description);  
          Console.WriteLine(" ID:            " + info.Id);  
          Console.WriteLine(" Enabled:       " + voice.Enabled);  
          if (info.SupportedAudioFormats.Count != 0)  
          {  
            Console.WriteLine( " Audio formats: " + AudioFormats);  
          }  
          else  
          {  
            Console.WriteLine(" No supported audio formats found");  
          }  
  
          string AdditionalInfo = "";  
          foreach (string key in info.AdditionalInfo.Keys)  
          {  
            AdditionalInfo += String.Format("  {0}: {1}\n", key, info.AdditionalInfo[key]);  
          }  
  
          Console.WriteLine(" Additional Info - " + AdditionalInfo);  
          Console.WriteLine();  
        }  
      }  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Synthesis.InstalledVoice" />
        <altmember cref="M:System.Speech.Synthesis.SpeechSynthesizer.SelectVoice(System.String)" />
        <altmember cref="Overload:System.Speech.Synthesis.SpeechSynthesizer.SelectVoiceByHints" />
        <altmember cref="Overload:System.Speech.Synthesis.PromptBuilder.StartVoice" />
      </Docs>
    </Member>
    <Member MemberName="GetInstalledVoices">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Speech.Synthesis.InstalledVoice&gt; GetInstalledVoices (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Speech.Synthesis.InstalledVoice&gt; GetInstalledVoices(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInstalledVoices (culture As CultureInfo) As ReadOnlyCollection(Of InstalledVoice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Speech::Synthesis::InstalledVoice ^&gt; ^ GetInstalledVoices(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.GetInstalledVoices : System.Globalization.CultureInfo -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Speech.Synthesis.InstalledVoice&gt;" Usage="speechSynthesizer.GetInstalledVoices culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Speech.Synthesis.InstalledVoice&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">语音必须支持的区域设置。</param>
        <summary>返回支持特定区域设置的所有安装的语音合成（文字到语音）语音。</summary>
        <returns>返回当前安装在支持指定区域设置的系统的语音的只读集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果任何已安装的声音都不支持指定的区域设置，则此方法将返回一个空集合。  
  
 Microsoft Windows 和 Speech API 接受所有有效的语言-国家/地区代码。 若要使用 Culture 属性中指定的语言执行文本到语音转换，必须安装支持该语言-国家/地区代码的语音合成引擎。 Microsoft Windows 7 随附的语音合成引擎使用以下语言-国家/地区代码：  
  
-   en-us。 英语（美国）  
  
-   zh-chs-CN。 中文（中国）  
  
-   zh-chs-幼圆。 中文（台湾）  
  
 还允许使用两个字母的语言代码，例如 "en"。  
  
   
  
## Examples  
 下面的示例是一个控制台应用程序的一部分，该应用程序初始化 <xref:System.Speech.Synthesis.SpeechSynthesizer> 对象并向控制台输出支持 en-us 区域设置的已安装语音列表。  
  
```csharp  
using System;  
using System.Globalization;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the speech synthesizer.  
      using (SpeechSynthesizer synthesizer = new SpeechSynthesizer())  
      {  
  
        // Output information about all of the installed voices that  
        // support the en-US locale.   
        Console.WriteLine("Installed voices for the en-US locale:");  
        foreach (InstalledVoice voice in  
          synthesizer.GetInstalledVoices(new CultureInfo("en-US")))  
        {  
          VoiceInfo info = voice.VoiceInfo;  
          OutputVoiceInfo(info);  
        }  
  
        // Output information about the current voice.  
        Console.WriteLine();  
        Console.WriteLine("Current voice:");  
        OutputVoiceInfo(synthesizer.Voice);  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  
    // Display information about a synthesizer voice.  
    private static void OutputVoiceInfo(VoiceInfo info)  
    {  
      Console.WriteLine("  Name: {0}, culture: {1}, gender: {2}, age: {3}.",  
        info.Name, info.Culture, info.Gender, info.Age);  
      Console.WriteLine("    Description: {0}", info.Description);  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Synthesis.InstalledVoice" />
      </Docs>
    </Member>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.Pause" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause();" />
      <MemberSignature Language="F#" Value="member this.Pause : unit -&gt; unit" Usage="speechSynthesizer.Pause " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>暂停 <see cref="T:System.Speech.Synthesis.SpeechSynthesizer" /> 对象。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Speech.Synthesis.SpeechSynthesizer.Resume" />
        <altmember cref="P:System.Speech.Synthesis.SpeechSynthesizer.State" />
        <altmember cref="E:System.Speech.Synthesis.SpeechSynthesizer.StateChanged" />
      </Docs>
    </Member>
    <Member MemberName="PhonemeReached">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Speech.Synthesis.PhonemeReachedEventArgs&gt; PhonemeReached;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Speech.Synthesis.PhonemeReachedEventArgs&gt; PhonemeReached" />
      <MemberSignature Language="DocId" Value="E:System.Speech.Synthesis.SpeechSynthesizer.PhonemeReached" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PhonemeReached As EventHandler(Of PhonemeReachedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Speech::Synthesis::PhonemeReachedEventArgs ^&gt; ^ PhonemeReached;" />
      <MemberSignature Language="F#" Value="member this.PhonemeReached : EventHandler&lt;System.Speech.Synthesis.PhonemeReachedEventArgs&gt; " Usage="member this.PhonemeReached : System.EventHandler&lt;System.Speech.Synthesis.PhonemeReachedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Speech.Synthesis.PhonemeReachedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当音素达到时引发。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 音素是书写语言的基本组成部分，通常是字母 (或表示一个或多个不同声音的两个字母) 的组合。 例如，字母 "c" 是在 "cinder" 中听起来像 "s" 的音素，或类似于 "catch" 中的 "k"。 书面字词是音素的行为。 更改 word 中的音素将更改其拼写。  
  
 <xref:System.Speech.Synthesis.SpeechSynthesizer>实例 <xref:System.Speech.Synthesis.SpeechSynthesizer.PhonemeReached> 为构成音素的单词的每个部分生成一个事件。 例如，对于 "主题" 一词，会生成三个 <xref:System.Speech.Synthesis.SpeechSynthesizer.PhonemeReached> 事件：一个用于 "th" 声音，一个用于 "e" 声，另一个用于 "m" 声 (我的) 。  
  
 有关与事件关联的数据的示例和信息，请参阅 <xref:System.Speech.Synthesis.PhonemeReachedEventArgs> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rate">
      <MemberSignature Language="C#" Value="public int Rate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rate" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Synthesis.SpeechSynthesizer.Rate" />
      <MemberSignature Language="VB.NET" Value="Public Property Rate As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rate { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Rate : int with get, set" Usage="System.Speech.Synthesis.SpeechSynthesizer.Rate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Speech.Synthesis.SpeechSynthesizer" /> 对象的语速。</summary>
        <value>返回 <see cref="T:System.Speech.Synthesis.SpeechSynthesizer" /> 对象的语速，在 -10 到 10 之间。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例将讲话速率设置为-2 的字符串讲述。  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      SpeechSynthesizer synth = new SpeechSynthesizer();  
  
      // Set a value for the speaking rate.  
      synth.Rate = -2;  
  
      // Configure the audio output.   
      synth.SetOutputToDefaultAudioDevice();  
  
      // Speak a text string synchronously.  
      synth.Speak("This example speaks a string with the speaking rate set to -2.");  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }     
  }    
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Synthesis.PromptStyle" />
        <altmember cref="T:System.Speech.Synthesis.PromptRate" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLexicon">
      <MemberSignature Language="C#" Value="public void RemoveLexicon (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveLexicon(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.RemoveLexicon(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveLexicon (uri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveLexicon(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="member this.RemoveLexicon : Uri -&gt; unit" Usage="speechSynthesizer.RemoveLexicon uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">词典文档的位置。</param>
        <summary>从 <see cref="T:System.Speech.Synthesis.SpeechSynthesizer" /> 对象中移除词典。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关示例，请参见 <xref:System.Speech.Synthesis.SpeechSynthesizer.AddLexicon%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Synthesis.SpeechSynthesizer.AddLexicon(System.Uri,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="speechSynthesizer.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>继续 <see cref="T:System.Speech.Synthesis.SpeechSynthesizer" /> 对象（在它暂停后）。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Speech.Synthesis.SpeechSynthesizer.Pause" />
        <altmember cref="P:System.Speech.Synthesis.SpeechSynthesizer.State" />
        <altmember cref="E:System.Speech.Synthesis.SpeechSynthesizer.StateChanged" />
      </Docs>
    </Member>
    <Member MemberName="SelectVoice">
      <MemberSignature Language="C#" Value="public void SelectVoice (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SelectVoice(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.SelectVoice(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SelectVoice (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SelectVoice(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.SelectVoice : string -&gt; unit" Usage="speechSynthesizer.SelectVoice name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要选择该的语音的名称。</param>
        <summary>通过名称选择特定语音。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> 方法和 <xref:System.Speech.Synthesis.VoiceInfo> 类获取可选择的已安装的文本到语音 (TTS) 语音的名称。 若要选择一种语音，请将该属性的全部内容 <xref:System.Speech.Synthesis.VoiceInfo.Name%2A> 作为该方法的参数进行传递 <xref:System.Speech.Synthesis.SpeechSynthesizer.SelectVoice%2A> 。 <xref:System.Speech.Synthesis.SpeechSynthesizer>对象选择 `name` 语音的属性中包含的第一个已安装语音 <xref:System.Speech.Synthesis.VoiceInfo.Name%2A?displayProperty=nameWithType> 。 <xref:System.Speech.Synthesis.SpeechSynthesizer>执行区分大小写的子字符串比较以确定声音是否与匹配 `name` 。  
  
 当应用程序调用时 <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> ，该方法会验证它在注册表中找到的每个声音是否满足某些最小标准。 对于验证失败的任何语音， <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> 将其 <xref:System.Speech.Synthesis.InstalledVoice.Enabled%2A> 属性设置为 `False` 。 应用程序无法选择其 <xref:System.Speech.Synthesis.InstalledVoice.Enabled%2A> 属性为的声音 `False` 。 通常，应用程序不会设置语音的 <xref:System.Speech.Synthesis.InstalledVoice.Enabled%2A> 属性。  
  
 若要选择按性别、年龄或区域设置的语音，请使用其中一种 <xref:System.Speech.Synthesis.SpeechSynthesizer.SelectVoiceByHints%2A> 方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices" />
        <altmember cref="M:System.Speech.Synthesis.SpeechSynthesizer.SelectVoiceByHints(System.Speech.Synthesis.VoiceGender)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SelectVoiceByHints">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>选择具有特定性格的语音。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> 方法和 <xref:System.Speech.Synthesis.VoiceInfo> 类获取可选择的已安装的文本到语音 (TTS) 语音的名称。 <xref:System.Speech.Synthesis.SpeechSynthesizer>对象选择与指定特性匹配的第一个已安装语音。  
  
 当应用程序调用时 <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> ，该方法会验证它在注册表中找到的每个声音是否满足某些最小标准。 对于验证失败的任何语音， <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> 将其 <xref:System.Speech.Synthesis.InstalledVoice.Enabled%2A> 属性设置为 `False` 。 应用程序无法选择其 <xref:System.Speech.Synthesis.InstalledVoice.Enabled%2A> 属性为的声音 `False` 。 通常，应用程序不会设置语音的 <xref:System.Speech.Synthesis.InstalledVoice.Enabled%2A> 属性。  
  
 若要按名称选择语音，请使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.SelectVoice%2A> 方法  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SelectVoiceByHints">
      <MemberSignature Language="C#" Value="public void SelectVoiceByHints (System.Speech.Synthesis.VoiceGender gender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SelectVoiceByHints(valuetype System.Speech.Synthesis.VoiceGender gender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.SelectVoiceByHints(System.Speech.Synthesis.VoiceGender)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SelectVoiceByHints (gender As VoiceGender)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SelectVoiceByHints(System::Speech::Synthesis::VoiceGender gender);" />
      <MemberSignature Language="F#" Value="member this.SelectVoiceByHints : System.Speech.Synthesis.VoiceGender -&gt; unit" Usage="speechSynthesizer.SelectVoiceByHints gender" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gender" Type="System.Speech.Synthesis.VoiceGender" />
      </Parameters>
      <Docs>
        <param name="gender">选择语音的性别。</param>
        <summary>选择具有特定性别的语音。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> 方法和 <xref:System.Speech.Synthesis.VoiceInfo> 类获取可选择的已安装的文本到语音 (TTS) 语音的名称。 <xref:System.Speech.Synthesis.SpeechSynthesizer>对象选择其 <xref:System.Speech.Synthesis.VoiceInfo.Gender%2A> 属性与参数匹配的第一个已安装语音 `gender` 。  
  
 当应用程序调用时 <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> ，该方法会验证它在注册表中找到的每个声音是否满足某些最小标准。 对于验证失败的任何语音， <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> 将其 <xref:System.Speech.Synthesis.InstalledVoice.Enabled%2A> 属性设置为 `False` 。 应用程序无法选择其 <xref:System.Speech.Synthesis.InstalledVoice.Enabled%2A> 属性为的声音 `False` 。 通常，应用程序不会设置语音的 <xref:System.Speech.Synthesis.InstalledVoice.Enabled%2A> 属性。  
  
 若要根据其他特征选择语音，请参阅其他 <xref:System.Speech.Synthesis.SpeechSynthesizer.SelectVoiceByHints%2A> 方法。  
  
 若要按名称选择语音，请使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.SelectVoice%2A> 方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Synthesis.VoiceGender" />
        <altmember cref="T:System.Speech.Synthesis.VoiceInfo" />
        <altmember cref="M:System.Speech.Synthesis.SpeechSynthesizer.SelectVoice(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SelectVoiceByHints">
      <MemberSignature Language="C#" Value="public void SelectVoiceByHints (System.Speech.Synthesis.VoiceGender gender, System.Speech.Synthesis.VoiceAge age);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SelectVoiceByHints(valuetype System.Speech.Synthesis.VoiceGender gender, valuetype System.Speech.Synthesis.VoiceAge age) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.SelectVoiceByHints(System.Speech.Synthesis.VoiceGender,System.Speech.Synthesis.VoiceAge)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SelectVoiceByHints (gender As VoiceGender, age As VoiceAge)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SelectVoiceByHints(System::Speech::Synthesis::VoiceGender gender, System::Speech::Synthesis::VoiceAge age);" />
      <MemberSignature Language="F#" Value="member this.SelectVoiceByHints : System.Speech.Synthesis.VoiceGender * System.Speech.Synthesis.VoiceAge -&gt; unit" Usage="speechSynthesizer.SelectVoiceByHints (gender, age)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gender" Type="System.Speech.Synthesis.VoiceGender" />
        <Parameter Name="age" Type="System.Speech.Synthesis.VoiceAge" />
      </Parameters>
      <Docs>
        <param name="gender">选择语音的性别。</param>
        <param name="age">要选择该的语音的年龄。</param>
        <summary>选择具有特定性别和年龄的语音。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> 方法和 <xref:System.Speech.Synthesis.VoiceInfo> 类获取可选择的已安装的文本到语音 (TTS) 语音的名称。 <xref:System.Speech.Synthesis.SpeechSynthesizer>对象选择第一个安装的语音 <xref:System.Speech.Synthesis.VoiceInfo.Gender%2A> ，其和 <xref:System.Speech.Synthesis.VoiceInfo.Age%2A> 属性与 `gender` 和 `age` 参数匹配。  
  
 当应用程序调用时 <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> ，该方法会验证它在注册表中找到的每个声音是否满足某些最小标准。 对于验证失败的任何语音， <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> 将其 <xref:System.Speech.Synthesis.InstalledVoice.Enabled%2A> 属性设置为 `False` 。 应用程序无法选择其 <xref:System.Speech.Synthesis.InstalledVoice.Enabled%2A> 属性为的声音 `False` 。 通常，应用程序不会设置语音的 <xref:System.Speech.Synthesis.InstalledVoice.Enabled%2A> 属性。  
  
 若要根据其他特征选择语音，请参阅其他 <xref:System.Speech.Synthesis.SpeechSynthesizer.SelectVoiceByHints%2A> 方法。  
  
 若要按名称选择语音，请使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.SelectVoice%2A> 方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Synthesis.VoiceAge" />
        <altmember cref="T:System.Speech.Synthesis.VoiceGender" />
        <altmember cref="T:System.Speech.Synthesis.VoiceInfo" />
        <altmember cref="M:System.Speech.Synthesis.SpeechSynthesizer.SelectVoice(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SelectVoiceByHints">
      <MemberSignature Language="C#" Value="public void SelectVoiceByHints (System.Speech.Synthesis.VoiceGender gender, System.Speech.Synthesis.VoiceAge age, int voiceAlternate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SelectVoiceByHints(valuetype System.Speech.Synthesis.VoiceGender gender, valuetype System.Speech.Synthesis.VoiceAge age, int32 voiceAlternate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.SelectVoiceByHints(System.Speech.Synthesis.VoiceGender,System.Speech.Synthesis.VoiceAge,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SelectVoiceByHints (gender As VoiceGender, age As VoiceAge, voiceAlternate As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SelectVoiceByHints(System::Speech::Synthesis::VoiceGender gender, System::Speech::Synthesis::VoiceAge age, int voiceAlternate);" />
      <MemberSignature Language="F#" Value="member this.SelectVoiceByHints : System.Speech.Synthesis.VoiceGender * System.Speech.Synthesis.VoiceAge * int -&gt; unit" Usage="speechSynthesizer.SelectVoiceByHints (gender, age, voiceAlternate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gender" Type="System.Speech.Synthesis.VoiceGender" />
        <Parameter Name="age" Type="System.Speech.Synthesis.VoiceAge" />
        <Parameter Name="voiceAlternate" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="gender">选择语音的性别。</param>
        <param name="age">要选择该的语音的年龄。</param>
        <param name="voiceAlternate">要选择该语音的位置。</param>
        <summary>根据语音的排序位置选择具有特定性别和年龄的语音。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> 方法和 <xref:System.Speech.Synthesis.VoiceInfo> 类获取可选择的已安装的文本到语音 (TTS) 语音的名称。 <xref:System.Speech.Synthesis.SpeechSynthesizer>对象将查找其 <xref:System.Speech.Synthesis.VoiceInfo.Gender%2A> 和 <xref:System.Speech.Synthesis.VoiceInfo.Age%2A> 属性与 `gender` 和参数匹配 `age` 的已安装语音。 <xref:System.Speech.Synthesis.SpeechSynthesizer>计算所找到的匹配项的数目，并在计数等于参数时返回声音 `voiceAlternate` 。  
  
 当应用程序调用时 <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> ，该方法会验证它在注册表中找到的每个声音是否满足某些最小标准。 对于验证失败的任何语音， <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> 将其 <xref:System.Speech.Synthesis.InstalledVoice.Enabled%2A> 属性设置为 `False` 。 应用程序无法选择其 <xref:System.Speech.Synthesis.InstalledVoice.Enabled%2A> 属性为的声音 `False` 。 通常，应用程序不会设置语音的 <xref:System.Speech.Synthesis.InstalledVoice.Enabled%2A> 属性。  
  
 若要根据其他特征选择语音，请参阅其他 <xref:System.Speech.Synthesis.SpeechSynthesizer.SelectVoiceByHints%2A> 重载。  
  
 若要按名称选择语音，请使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.SelectVoice%2A> 方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Synthesis.VoiceAge" />
        <altmember cref="T:System.Speech.Synthesis.VoiceGender" />
        <altmember cref="T:System.Speech.Synthesis.VoiceInfo" />
        <altmember cref="M:System.Speech.Synthesis.SpeechSynthesizer.SelectVoice(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SelectVoiceByHints">
      <MemberSignature Language="C#" Value="public void SelectVoiceByHints (System.Speech.Synthesis.VoiceGender gender, System.Speech.Synthesis.VoiceAge age, int voiceAlternate, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SelectVoiceByHints(valuetype System.Speech.Synthesis.VoiceGender gender, valuetype System.Speech.Synthesis.VoiceAge age, int32 voiceAlternate, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.SelectVoiceByHints(System.Speech.Synthesis.VoiceGender,System.Speech.Synthesis.VoiceAge,System.Int32,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SelectVoiceByHints (gender As VoiceGender, age As VoiceAge, voiceAlternate As Integer, culture As CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SelectVoiceByHints(System::Speech::Synthesis::VoiceGender gender, System::Speech::Synthesis::VoiceAge age, int voiceAlternate, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.SelectVoiceByHints : System.Speech.Synthesis.VoiceGender * System.Speech.Synthesis.VoiceAge * int * System.Globalization.CultureInfo -&gt; unit" Usage="speechSynthesizer.SelectVoiceByHints (gender, age, voiceAlternate, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gender" Type="System.Speech.Synthesis.VoiceGender" />
        <Parameter Name="age" Type="System.Speech.Synthesis.VoiceAge" />
        <Parameter Name="voiceAlternate" Type="System.Int32" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="gender">选择语音的性别。</param>
        <param name="age">要选择该的语音的年龄。</param>
        <param name="voiceAlternate">要选择该语音的位置。</param>
        <param name="culture">要选择该的语音的区域设置。</param>
        <summary>根据语音的排序位置选择具有特定性别、年龄和区域设置的语音。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Synthesis.SpeechSynthesizer>对象查找其 <xref:System.Speech.Synthesis.VoiceInfo.Gender%2A> 、 <xref:System.Speech.Synthesis.VoiceInfo.Age%2A> 和 <xref:System.Speech.Synthesis.VoiceInfo.Culture%2A> 属性与 `gender` 、 `age` 和 `culture` 参数匹配的声音。 <xref:System.Speech.Synthesis.SpeechSynthesizer>计算所找到的匹配项的数目，并在计数等于参数时返回声音 `voiceAlternate` 。  
  
 Microsoft Windows 和 Speech API 接受所有有效的语言-国家/地区代码。 若要使用参数中指定的语言执行文本到语音转换 `culture` ，必须安装支持该语言-国家/地区代码的语音合成引擎。 Microsoft Windows 7 随附的语音合成引擎使用以下语言-国家/地区代码：  
  
-   en-us。 英语（美国）  
  
-   zh-chs-CN。 中文（中国）  
  
-   zh-chs-幼圆。 中文（台湾）  
  
 还允许使用两个字母的语言代码，例如 "en"。  
  
 当应用程序调用时 <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> ，该方法会验证它在注册表中找到的每个声音是否满足某些最小标准。 对于验证失败的任何语音， <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> 将其 <xref:System.Speech.Synthesis.InstalledVoice.Enabled%2A> 属性设置为 `False` 。 应用程序无法选择其 <xref:System.Speech.Synthesis.InstalledVoice.Enabled%2A> 属性为的声音 `False` 。 通常，应用程序不会设置语音的 <xref:System.Speech.Synthesis.InstalledVoice.Enabled%2A> 属性。  
  
 若要根据其他特征选择语音，请参阅其他 <xref:System.Speech.Synthesis.SpeechSynthesizer.SelectVoiceByHints%2A> 重载。  
  
 若要按名称选择语音，请使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.SelectVoice%2A> 方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Speech.Synthesis.VoiceAge" />
        <altmember cref="T:System.Speech.Synthesis.VoiceGender" />
        <altmember cref="T:System.Speech.Synthesis.VoiceInfo" />
        <altmember cref="M:System.Speech.Synthesis.SpeechSynthesizer.SelectVoice(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetOutputToAudioStream">
      <MemberSignature Language="C#" Value="public void SetOutputToAudioStream (System.IO.Stream audioDestination, System.Speech.AudioFormat.SpeechAudioFormatInfo formatInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetOutputToAudioStream(class System.IO.Stream audioDestination, class System.Speech.AudioFormat.SpeechAudioFormatInfo formatInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToAudioStream(System.IO.Stream,System.Speech.AudioFormat.SpeechAudioFormatInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetOutputToAudioStream (audioDestination As Stream, formatInfo As SpeechAudioFormatInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetOutputToAudioStream(System::IO::Stream ^ audioDestination, System::Speech::AudioFormat::SpeechAudioFormatInfo ^ formatInfo);" />
      <MemberSignature Language="F#" Value="member this.SetOutputToAudioStream : System.IO.Stream * System.Speech.AudioFormat.SpeechAudioFormatInfo -&gt; unit" Usage="speechSynthesizer.SetOutputToAudioStream (audioDestination, formatInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="audioDestination" Type="System.IO.Stream" />
        <Parameter Name="formatInfo" Type="System.Speech.AudioFormat.SpeechAudioFormatInfo" />
      </Parameters>
      <Docs>
        <param name="audioDestination">要追加合成输出的流。</param>
        <param name="formatInfo">用于合成输出的格式。</param>
        <summary>配置 <see cref="T:System.Speech.Synthesis.SpeechSynthesizer" /> 对象以追加输出到音频流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用 <xref:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToNull%2A> 以释放对 <xref:System.Speech.Synthesis.SpeechSynthesizer> 流的引用。  
  
 有关其他输出配置选项，请参阅 <xref:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToDefaultAudioDevice%2A> 、 <xref:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToNull%2A> 、 <xref:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToWaveFile%2A> 和 <xref:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToWaveStream%2A> 方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetOutputToDefaultAudioDevice">
      <MemberSignature Language="C#" Value="public void SetOutputToDefaultAudioDevice ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetOutputToDefaultAudioDevice() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToDefaultAudioDevice" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetOutputToDefaultAudioDevice ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetOutputToDefaultAudioDevice();" />
      <MemberSignature Language="F#" Value="member this.SetOutputToDefaultAudioDevice : unit -&gt; unit" Usage="speechSynthesizer.SetOutputToDefaultAudioDevice " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>配置 <see cref="T:System.Speech.Synthesis.SpeechSynthesizer" /> 对象以发送输出到默认音频设备。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用 Windows "**控制面板**" 中的 "**声音**" 窗口配置计算机的默认音频设备。  
  
 有关其他输出配置选项，请参阅 <xref:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToAudioStream%2A> 、 <xref:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToNull%2A> 、 <xref:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToWaveFile%2A> 和 <xref:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToWaveStream%2A> 方法。  
  
   
  
## Examples  
 下面的示例使用合成器将短语告诉默认音频输出。  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the speech synthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the synthesizer to send output to the default audio device.  
        synth.SetOutputToDefaultAudioDevice();  
  
        // Speak a phrase.  
        synth.Speak("This is sample text-to-speech output.");  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetOutputToNull">
      <MemberSignature Language="C#" Value="public void SetOutputToNull ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetOutputToNull() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToNull" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetOutputToNull ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetOutputToNull();" />
      <MemberSignature Language="F#" Value="member this.SetOutputToNull : unit -&gt; unit" Usage="speechSynthesizer.SetOutputToNull " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>配置 <see cref="T:System.Speech.Synthesis.SpeechSynthesizer" /> 对象以不从对设备、文件或流的聚合操作中发送输出。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可释放对 <xref:System.Speech.Synthesis.SpeechSynthesizer> 文件或流的引用。 有关示例，请参见 <xref:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToWaveStream%2A>。  
  
 有关其他输出配置选项，请参阅 <xref:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToAudioStream%2A> 、 <xref:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToDefaultAudioDevice%2A> 、 <xref:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToWaveFile%2A> 和 <xref:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToWaveStream%2A> 方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetOutputToWaveFile">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>配置 <see cref="T:System.Speech.Synthesis.SpeechSynthesizer" /> 对象以追加输出到波形音频格式文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要释放对 <xref:System.Speech.Synthesis.SpeechSynthesizer> 文件的引用，请重新配置 <xref:System.Speech.Synthesis.SpeechSynthesizer> 的输出，例如通过调用来重新配置 <xref:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToNull%2A> 。  
  
 有关其他输出配置选项，请参阅 <xref:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToAudioStream%2A> 、 <xref:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToDefaultAudioDevice%2A> 、 <xref:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToNull%2A> 和 <xref:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToWaveStream%2A> 方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetOutputToWaveFile">
      <MemberSignature Language="C#" Value="public void SetOutputToWaveFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetOutputToWaveFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToWaveFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetOutputToWaveFile (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetOutputToWaveFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetOutputToWaveFile : string -&gt; unit" Usage="speechSynthesizer.SetOutputToWaveFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">文件的路径。</param>
        <summary>配置 <see cref="T:System.Speech.Synthesis.SpeechSynthesizer" /> 对象以追加输出到包含波形格式音频的文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要配置输出并指定音频格式，请使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToWaveFile%2A> 方法。  
  
   
  
## Examples  
 下面的示例使用实例 <xref:System.Media.SoundPlayer> 来播放已输出到 .wav 文件的提示。 由于 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsync%2A> 调用是异步的，因此 <xref:System.Media.SoundPlayer> (创建实例，并在 <xref:System.Media.SoundPlayer.Play%2A> 事件的处理程序中) 调用方法 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakCompleted> 。  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      SpeechSynthesizer synth = new SpeechSynthesizer();  
  
      // Configure the audio output.   
      synth.SetOutputToWaveFile(@"C:\Test\Sample.wav");  
  
      // Register for the SpeakCompleted event.  
      synth.SpeakCompleted += new EventHandler<SpeakCompletedEventArgs>(synth_SpeakCompleted);  
  
      // Build a prompt.  
      PromptBuilder builder = new PromptBuilder();  
      builder.AppendText("This sample asynchronously speaks a prompt to a WAVE file.");  
  
      // Speak the string asynchronously.  
      synth.SpeakAsync(builder);  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  
    // Handle the SpeakCompleted event.  
    static void synth_SpeakCompleted(object sender, SpeakCompletedEventArgs e)  
    {  
  
      // Create a SoundPlayer instance to play the output audio file.  
      System.Media.SoundPlayer m_SoundPlayer =  
        new System.Media.SoundPlayer(@"C:\Test\Sample.wav");  
  
      //  Play the output file.  
      m_SoundPlayer.Play();  
    }  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToAudioStream(System.IO.Stream,System.Speech.AudioFormat.SpeechAudioFormatInfo)" />
        <altmember cref="M:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToDefaultAudioDevice" />
        <altmember cref="M:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToNull" />
        <altmember cref="M:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToWaveStream(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="SetOutputToWaveFile">
      <MemberSignature Language="C#" Value="public void SetOutputToWaveFile (string path, System.Speech.AudioFormat.SpeechAudioFormatInfo formatInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetOutputToWaveFile(string path, class System.Speech.AudioFormat.SpeechAudioFormatInfo formatInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToWaveFile(System.String,System.Speech.AudioFormat.SpeechAudioFormatInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetOutputToWaveFile (path As String, formatInfo As SpeechAudioFormatInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetOutputToWaveFile(System::String ^ path, System::Speech::AudioFormat::SpeechAudioFormatInfo ^ formatInfo);" />
      <MemberSignature Language="F#" Value="member this.SetOutputToWaveFile : string * System.Speech.AudioFormat.SpeechAudioFormatInfo -&gt; unit" Usage="speechSynthesizer.SetOutputToWaveFile (path, formatInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="formatInfo" Type="System.Speech.AudioFormat.SpeechAudioFormatInfo" />
      </Parameters>
      <Docs>
        <param name="path">文件的路径。</param>
        <param name="formatInfo">音频格式信息。</param>
        <summary>配置 <see cref="T:System.Speech.Synthesis.SpeechSynthesizer" /> 对象以追加输出到指定格式中的波形音频格式文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例指定了语音合成的输出格式，并将其发送到 WAV 文件。  
  
```csharp  
using System;  
using System.IO;  
using System.Speech.Synthesis;  
using System.Speech.AudioFormat;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToWaveFile(@"C:\temp\test.wav",   
          new SpeechAudioFormatInfo(32000, AudioBitsPerSample.Sixteen, AudioChannel.Mono));  
  
        // Create a SoundPlayer instance to play output audio file.  
        System.Media.SoundPlayer m_SoundPlayer =   
          new System.Media.SoundPlayer(@"C:\temp\test.wav");  
  
        // Build a prompt.  
        PromptBuilder builder = new PromptBuilder();  
        builder.AppendText("This is sample output to a WAVE file.");  
  
        // Speak the prompt.  
        synth.Speak(builder);  
        m_SoundPlayer.Play();  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToAudioStream(System.IO.Stream,System.Speech.AudioFormat.SpeechAudioFormatInfo)" />
        <altmember cref="M:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToDefaultAudioDevice" />
        <altmember cref="M:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToNull" />
        <altmember cref="M:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToWaveStream(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="SetOutputToWaveStream">
      <MemberSignature Language="C#" Value="public void SetOutputToWaveStream (System.IO.Stream audioDestination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetOutputToWaveStream(class System.IO.Stream audioDestination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToWaveStream(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetOutputToWaveStream (audioDestination As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetOutputToWaveStream(System::IO::Stream ^ audioDestination);" />
      <MemberSignature Language="F#" Value="member this.SetOutputToWaveStream : System.IO.Stream -&gt; unit" Usage="speechSynthesizer.SetOutputToWaveStream audioDestination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="audioDestination" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="audioDestination">要追加合成输出的流。</param>
        <summary>配置 <see cref="T:System.Speech.Synthesis.SpeechSynthesizer" /> 对象以追加输出到包含波形格式音频的流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要释放对 <xref:System.Speech.Synthesis.SpeechSynthesizer> 流的引用，请重新配置合成器的输出，例如通过调用来重新配置 <xref:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToNull%2A> 。  
  
 有关其他输出配置选项，请参阅 <xref:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToAudioStream%2A> 、 <xref:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToDefaultAudioDevice%2A> 、 <xref:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToNull%2A> 和 <xref:System.Speech.Synthesis.SpeechSynthesizer.SetOutputToWaveFile%2A> 方法。  
  
   
  
## Examples  
 下面的示例将短语输出到 WAV 流。  
  
```csharp  
using System;  
using System.IO;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the speech synthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      using (MemoryStream streamAudio = new MemoryStream())  
      {  
  
        // Create a SoundPlayer instance to play the output audio file.  
        System.Media.SoundPlayer m_SoundPlayer = new System.Media.SoundPlayer();  
  
        // Configure the synthesizer to output to an audio stream.  
        synth.SetOutputToWaveStream(streamAudio);  
  
        // Speak a phrase.  
        synth.Speak("This is sample text-to-speech output.");  
        streamAudio.Position = 0;  
        m_SoundPlayer.Stream = streamAudio;  
        m_SoundPlayer.Play();  
  
        // Set the synthesizer output to null to release the stream.   
        synth.SetOutputToNull();  
  
        // Insert code to persist or process the stream contents here.  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Speak">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>从字符串、 <see cref="T:System.Speech.Synthesis.Prompt" /> 对象或 <see cref="T:System.Speech.Synthesis.PromptBuilder" /> 对象同步生成语音输出。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Synthesis.SpeechSynthesizer.Speak%2A>方法以同步方式生成语音。 方法不会返回，直到实例的内容 <xref:System.Speech.Synthesis.SpeechSynthesizer.Speak%2A> 完全被播讲。 这是生成语音的最简单方法。 但是，如果应用程序需要在说话时执行任务（例如突出显示文本、绘制动画、监视器控件或其他任务），请使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsync%2A> 方法或 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakSsmlAsync%2A> 方法以异步方式生成语音。  
  
 在调用此方法的过程中， <xref:System.Speech.Synthesis.SpeechSynthesizer> 可能会引发以下事件：  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.StateChanged>. 合成器的讲述状态更改时引发。  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakStarted>. 合成器开始生成语音时引发。  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.PhonemeReached>. 每次合成器达到一种语言的字母或字母组合时引发。  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakProgress>. 每次合成器完成字词时引发。  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.VisemeReached>. 每次出现口述输出时，需要更改嘴或用于生成语音的面部肌肉的位置。  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.BookmarkReached>. 当合成器在提示符处遇到书签时引发。  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.VoiceChange>. 合成器的说话声音发生变化时引发。  
  
 在 <xref:System.Speech.Synthesis.SpeechSynthesizer> <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakCompleted> 处理任何方法时不会引发事件 <xref:System.Speech.Synthesis.SpeechSynthesizer.Speak%2A> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Speak">
      <MemberSignature Language="C#" Value="public void Speak (System.Speech.Synthesis.Prompt prompt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Speak(class System.Speech.Synthesis.Prompt prompt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.Speak(System.Speech.Synthesis.Prompt)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Speak (prompt As Prompt)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Speak(System::Speech::Synthesis::Prompt ^ prompt);" />
      <MemberSignature Language="F#" Value="member this.Speak : System.Speech.Synthesis.Prompt -&gt; unit" Usage="speechSynthesizer.Speak prompt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prompt" Type="System.Speech.Synthesis.Prompt" />
      </Parameters>
      <Docs>
        <param name="prompt">要朗读的内容。</param>
        <summary>同步使用 <see cref="T:System.Speech.Synthesis.Prompt" /> 对象内容的语言。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要异步朗读对象的内容 <xref:System.Speech.Synthesis.Prompt> ，请使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsync%2A> 。  
  
   
  
## Examples  
 下面的示例 <xref:System.Speech.Synthesis.Prompt> 从字符串创建对象并将该对象作为参数传递给 <xref:System.Speech.Synthesis.SpeechSynthesizer.Speak%2A> 方法。  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToDefaultAudioDevice();  
  
        // Create a prompt from a string.  
        Prompt color = new Prompt("What is your favorite color?");  
  
        // Speak the contents of the prompt synchronously.  
        synth.Speak(color);  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Speak">
      <MemberSignature Language="C#" Value="public void Speak (System.Speech.Synthesis.PromptBuilder promptBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Speak(class System.Speech.Synthesis.PromptBuilder promptBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.Speak(System.Speech.Synthesis.PromptBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Speak (promptBuilder As PromptBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Speak(System::Speech::Synthesis::PromptBuilder ^ promptBuilder);" />
      <MemberSignature Language="F#" Value="member this.Speak : System.Speech.Synthesis.PromptBuilder -&gt; unit" Usage="speechSynthesizer.Speak promptBuilder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="promptBuilder" Type="System.Speech.Synthesis.PromptBuilder" />
      </Parameters>
      <Docs>
        <param name="promptBuilder">要朗读的内容。</param>
        <summary>同步使用 <see cref="T:System.Speech.Synthesis.PromptBuilder" /> 对象内容的语言。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要异步朗读对象的内容 <xref:System.Speech.Synthesis.PromptBuilder> ，请使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsync%2A> 。  
  
   
  
## Examples  
 下面的示例 <xref:System.Speech.Synthesis.PromptBuilder> 从字符串创建对象并将该对象作为参数传递给 <xref:System.Speech.Synthesis.SpeechSynthesizer.Speak%2A> 方法。  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToDefaultAudioDevice();  
  
        // Create a PromptBuilder object and append a text string.  
        PromptBuilder song = new PromptBuilder();  
        song.AppendText("Say the name of the song you want to hear");  
  
        // Speak the contents of the prompt synchronously.  
        synth.Speak(song);  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Speak">
      <MemberSignature Language="C#" Value="public void Speak (string textToSpeak);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Speak(string textToSpeak) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.Speak(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Speak (textToSpeak As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Speak(System::String ^ textToSpeak);" />
      <MemberSignature Language="F#" Value="member this.Speak : string -&gt; unit" Usage="speechSynthesizer.Speak textToSpeak" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textToSpeak" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textToSpeak">要朗读的文本。</param>
        <summary>同步使用字符串内容的语言。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要同步朗读包含 SSML 标记的字符串，请使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakSsml%2A> 方法。 若要以异步方式说出字符串的内容，请使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsync%2A> 方法。  
  
   
  
## Examples  
 如下面的示例中所示， <xref:System.Speech.Synthesis.SpeechSynthesizer.Speak%2A> 方法提供了同步生成语音输出的最简单方法。  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToDefaultAudioDevice();  
  
        // Speak a string synchronously.  
        synth.Speak("What is your favorite color?");  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SpeakAsync">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>从字符串、 <see cref="T:System.Speech.Synthesis.Prompt" /> 对象或 <see cref="T:System.Speech.Synthesis.PromptBuilder" /> 对象异步生成语音输出。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsync%2A>方法以异步方式生成语音。 方法会立即返回，而不会等待对象的内容 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsync%2A> 完成说话。 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsync%2A>如果你的应用程序需要在说话时执行任务，例如突出显示文本、绘制动画、监视器控件或其他任务，请使用。  
  
 在调用此方法的过程中， <xref:System.Speech.Synthesis.SpeechSynthesizer> 可能会引发以下事件：  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.StateChanged>. 合成器的讲述状态更改时引发。  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakStarted>. 合成器开始生成语音时引发。  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.PhonemeReached>. 每次合成器达到一种语言的字母或字母组合时引发。  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakProgress>. 每次合成器完成字词时引发。  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.VisemeReached>. 每次出现口述输出时，需要更改嘴或用于生成语音的面部肌肉的位置。  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.BookmarkReached>. 当合成器在提示符处遇到书签时引发。  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.VoiceChange>. 合成器的说话声音发生变化时引发。  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakCompleted>. 合成器完成操作时引发 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsync%2A> 。  
  
 如果你的应用程序不需要在说话时执行任务，则可以使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.Speak%2A> 方法或 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakSsml%2A> 方法同步生成语音。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Speech.Synthesis.SpeechSynthesizer.BookmarkReached" />
        <altmember cref="E:System.Speech.Synthesis.SpeechSynthesizer.PhonemeReached" />
        <altmember cref="E:System.Speech.Synthesis.SpeechSynthesizer.SpeakCompleted" />
        <altmember cref="E:System.Speech.Synthesis.SpeechSynthesizer.SpeakProgress" />
        <altmember cref="E:System.Speech.Synthesis.SpeechSynthesizer.SpeakStarted" />
        <altmember cref="E:System.Speech.Synthesis.SpeechSynthesizer.StateChanged" />
        <altmember cref="E:System.Speech.Synthesis.SpeechSynthesizer.VisemeReached" />
        <altmember cref="E:System.Speech.Synthesis.SpeechSynthesizer.VoiceChange" />
      </Docs>
    </MemberGroup>
    <Member MemberName="SpeakAsync">
      <MemberSignature Language="C#" Value="public void SpeakAsync (System.Speech.Synthesis.Prompt prompt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SpeakAsync(class System.Speech.Synthesis.Prompt prompt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsync(System.Speech.Synthesis.Prompt)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SpeakAsync (prompt As Prompt)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SpeakAsync(System::Speech::Synthesis::Prompt ^ prompt);" />
      <MemberSignature Language="F#" Value="member this.SpeakAsync : System.Speech.Synthesis.Prompt -&gt; unit" Usage="speechSynthesizer.SpeakAsync prompt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prompt" Type="System.Speech.Synthesis.Prompt" />
      </Parameters>
      <Docs>
        <param name="prompt">要朗读的内容。</param>
        <summary>异步使用 <see cref="T:System.Speech.Synthesis.Prompt" /> 对象内容的语言。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用或方法取消对提示的异步处理 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsyncCancel%2A> <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsyncCancelAll%2A> 。  
  
 若要同步朗读对象的内容 <xref:System.Speech.Synthesis.Prompt> ，请使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.Speak%2A> 。  
  
   
  
## Examples  
 下面的示例 <xref:System.Speech.Synthesis.Prompt> 从字符串创建对象并将该对象作为参数传递给 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsync%2A> 方法。  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      SpeechSynthesizer synth = new SpeechSynthesizer();  
  
      // Configure the audio output.   
      synth.SetOutputToDefaultAudioDevice();  
  
      // Create a prompt from a string.  
      Prompt color = new Prompt("What is your favorite color?");  
  
      // Speak the contents of the prompt asynchronously.  
      synth.SpeakAsync(color);  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SpeakAsync">
      <MemberSignature Language="C#" Value="public System.Speech.Synthesis.Prompt SpeakAsync (System.Speech.Synthesis.PromptBuilder promptBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Speech.Synthesis.Prompt SpeakAsync(class System.Speech.Synthesis.PromptBuilder promptBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsync(System.Speech.Synthesis.PromptBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function SpeakAsync (promptBuilder As PromptBuilder) As Prompt" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Speech::Synthesis::Prompt ^ SpeakAsync(System::Speech::Synthesis::PromptBuilder ^ promptBuilder);" />
      <MemberSignature Language="F#" Value="member this.SpeakAsync : System.Speech.Synthesis.PromptBuilder -&gt; System.Speech.Synthesis.Prompt" Usage="speechSynthesizer.SpeakAsync promptBuilder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Synthesis.Prompt</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="promptBuilder" Type="System.Speech.Synthesis.PromptBuilder" />
      </Parameters>
      <Docs>
        <param name="promptBuilder">要朗读的内容。</param>
        <summary>异步使用 <see cref="T:System.Speech.Synthesis.PromptBuilder" /> 对象内容的语言。</summary>
        <returns>返回包含要使用的内容的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要同步朗读对象的内容 <xref:System.Speech.Synthesis.PromptBuilder> ，请使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.Speak%2A> 。  
  
   
  
## Examples  
 下面的示例 <xref:System.Speech.Synthesis.PromptBuilder> 从字符串创建对象并将该对象作为参数传递给 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsync%2A> 方法。  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      SpeechSynthesizer synth = new SpeechSynthesizer();  
  
      // Configure the audio output.   
      synth.SetOutputToDefaultAudioDevice();  
  
      // Create a PromptBuilder object and append a text string.  
      PromptBuilder song = new PromptBuilder();  
      song.AppendText("Say the name of the song you want to hear");  
  
      // Speak the contents of the prompt asynchronously.  
      synth.SpeakAsync(song);  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SpeakAsync">
      <MemberSignature Language="C#" Value="public System.Speech.Synthesis.Prompt SpeakAsync (string textToSpeak);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Speech.Synthesis.Prompt SpeakAsync(string textToSpeak) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsync(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SpeakAsync (textToSpeak As String) As Prompt" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Speech::Synthesis::Prompt ^ SpeakAsync(System::String ^ textToSpeak);" />
      <MemberSignature Language="F#" Value="member this.SpeakAsync : string -&gt; System.Speech.Synthesis.Prompt" Usage="speechSynthesizer.SpeakAsync textToSpeak" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Synthesis.Prompt</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textToSpeak" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textToSpeak">要朗读的文本。</param>
        <summary>异步使用字符串内容的语言。</summary>
        <returns>返回包含要使用的内容的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要以异步方式口述包含 SSML 标记的字符串，请使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakSsmlAsync%2A> 方法。 若要同步朗读字符串的内容，请使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.Speak%2A> 方法。 您可以使用或方法取消对提示的异步处理 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsyncCancel%2A> <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsyncCancelAll%2A> 。  
  
   
  
## Examples  
 如下面的示例中所示， <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsync%2A> 方法提供了异步生成语音输出的最简单方法。  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      SpeechSynthesizer synth = new SpeechSynthesizer();  
  
      // Configure the audio output.   
      synth.SetOutputToDefaultAudioDevice();  
  
      // Speak a string asynchronously.  
      synth.SpeakAsync("What is your favorite color?");  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Speech.Synthesis.SpeechSynthesizer.Speak" />
      </Docs>
    </Member>
    <Member MemberName="SpeakAsyncCancel">
      <MemberSignature Language="C#" Value="public void SpeakAsyncCancel (System.Speech.Synthesis.Prompt prompt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SpeakAsyncCancel(class System.Speech.Synthesis.Prompt prompt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsyncCancel(System.Speech.Synthesis.Prompt)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SpeakAsyncCancel (prompt As Prompt)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SpeakAsyncCancel(System::Speech::Synthesis::Prompt ^ prompt);" />
      <MemberSignature Language="F#" Value="member this.SpeakAsyncCancel : System.Speech.Synthesis.Prompt -&gt; unit" Usage="speechSynthesizer.SpeakAsyncCancel prompt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prompt" Type="System.Speech.Synthesis.Prompt" />
      </Parameters>
      <Docs>
        <param name="prompt">内容中移除调用操作。</param>
        <summary>取消一个排队的提示的异步合成操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你还可以使用此方法为以下项取消异步操作：  
  
-   <xref:System.String>由方法指定的的内容 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsync%2A?displayProperty=nameWithType> 。  
  
-   <xref:System.Speech.Synthesis.PromptBuilder>由方法指定的的内容 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsync%2A?displayProperty=nameWithType> 。  
  
-   <xref:System.String>包含由方法指定的 SSML 的的内容 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakSsmlAsync%2A> 。  
  
 当你调用 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsync%2A?displayProperty=nameWithType> 、 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsync%2A?displayProperty=nameWithType> 或时 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakSsmlAsync%2A> ，系统将创建一个 <xref:System.Speech.Synthesis.Prompt> 对象并使用该方法的参数的内容填充该对象，并返回该 <xref:System.Speech.Synthesis.Prompt> 对象。 如果保留返回的的副本 <xref:System.Speech.Synthesis.Prompt> ，则可以将其传递到， <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsyncCancel%2A> 以取消或对象中指定的内容 <xref:System.String> <xref:System.Speech.Synthesis.PromptBuilder> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SpeakAsyncCancelAll">
      <MemberSignature Language="C#" Value="public void SpeakAsyncCancelAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SpeakAsyncCancelAll() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsyncCancelAll" />
      <MemberSignature Language="VB.NET" Value="Public Sub SpeakAsyncCancelAll ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SpeakAsyncCancelAll();" />
      <MemberSignature Language="F#" Value="member this.SpeakAsyncCancelAll : unit -&gt; unit" Usage="speechSynthesizer.SpeakAsyncCancelAll " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取消所有排队、异步、语音合成操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsyncCancelAll%2A> 如何使用来取消异步的提示，以便能够口述新提示符。 请注意，在 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakCompleted> 取消操作时，将激发该事件 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsync%2A> 。  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
using System.Threading;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      SpeechSynthesizer synth = new SpeechSynthesizer();  
  
      // Configure the audio output.   
      synth.SetOutputToDefaultAudioDevice();  
  
      // Subscribe to the StateChanged event.  
      synth.StateChanged += new EventHandler<StateChangedEventArgs>(synth_StateChanged);  
  
      // Subscribe to the SpeakProgress event.  
      synth.SpeakProgress += new EventHandler<SpeakProgressEventArgs>(synth_SpeakProgress);  
  
      // Subscribe to the SpeakCompleted event.  
      synth.SpeakCompleted += new EventHandler<SpeakCompletedEventArgs>(synth_SpeakCompleted);  
  
      // Begin speaking a text string asynchronously.  
      synth.SpeakAsync("Speech is an effective and natural way for people to interact with applications, " +  
        "complementing or even replacing the use of mice, keyboards, controllers, and gestures.");  
  
      // Speak for four seconds.  
      Thread.Sleep(4000);  
  
      // Cancel the SpeakAsync operation and wait one second.  
      synth.SpeakAsyncCancelAll();  
      Thread.Sleep(1000);  
  
      // Speak a new text string.  
      synth.Speak("An urgent email message has arrived. Do you want to hear it?");  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  
    // Write to the console when the SpeakAsync operation has been cancelled.  
    static void synth_SpeakCompleted(object sender, SpeakCompletedEventArgs e)  
    {  
      Console.WriteLine("\nThe SpeakAsync operation was cancelled!!");  
    }  
  
    // When it changes, write the state of the SpeechSynthesizer to the console.  
    static void synth_StateChanged(object sender, StateChangedEventArgs e)  
    {  
      Console.WriteLine("\nSynthesizer State: {0}    Previous State: {1}\n", e.State, e.PreviousState);  
    }  
  
    // Write the text being spoken by the SpeechSynthesizer to the console.  
    static void synth_SpeakProgress(object sender, SpeakProgressEventArgs e)  
    {  
      Console.WriteLine(e.Text);  
    }      
  }    
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SpeakCompleted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Speech.Synthesis.SpeakCompletedEventArgs&gt; SpeakCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Speech.Synthesis.SpeakCompletedEventArgs&gt; SpeakCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Speech.Synthesis.SpeechSynthesizer.SpeakCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SpeakCompleted As EventHandler(Of SpeakCompletedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Speech::Synthesis::SpeakCompletedEventArgs ^&gt; ^ SpeakCompleted;" />
      <MemberSignature Language="F#" Value="member this.SpeakCompleted : EventHandler&lt;System.Speech.Synthesis.SpeakCompletedEventArgs&gt; " Usage="member this.SpeakCompleted : System.EventHandler&lt;System.Speech.Synthesis.SpeakCompletedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Speech.Synthesis.SpeakCompletedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="T:System.Speech.Synthesis.SpeechSynthesizer" /> 完成提示的讲话的时候引发。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 <xref:System.Speech.Synthesis.SpeechSynthesizer> <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakCompleted> 任何或方法完成时引发事件 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsync%2A>  <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakSsmlAsync%2A> 。  
  
 <xref:System.Speech.Synthesis.SpeakCompletedEventArgs>类没有属性，并且不会从事件返回数据 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakCompleted> 。 提供它是为了使应用程序作者能够编写事件的事件处理程序 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakCompleted> 。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Synthesis.SpeakCompletedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="SpeakProgress">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Speech.Synthesis.SpeakProgressEventArgs&gt; SpeakProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Speech.Synthesis.SpeakProgressEventArgs&gt; SpeakProgress" />
      <MemberSignature Language="DocId" Value="E:System.Speech.Synthesis.SpeechSynthesizer.SpeakProgress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SpeakProgress As EventHandler(Of SpeakProgressEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Speech::Synthesis::SpeakProgressEventArgs ^&gt; ^ SpeakProgress;" />
      <MemberSignature Language="F#" Value="member this.SpeakProgress : EventHandler&lt;System.Speech.Synthesis.SpeakProgressEventArgs&gt; " Usage="member this.SpeakProgress : System.EventHandler&lt;System.Speech.Synthesis.SpeakProgressEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Speech.Synthesis.SpeakProgressEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 <see cref="T:System.Speech.Synthesis.SpeechSynthesizer" /> 使用提示的每个单词后引发。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Synthesis.SpeechSynthesizer>使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.Speak%2A> 、 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsync%2A> 、 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakSsml%2A> 或方法中的任何一个在提示符下讲述的新字词，都将引发此事件 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakSsmlAsync%2A> 。 有关与事件关联的数据的示例和详细信息，请参阅 <xref:System.Speech.Synthesis.SpeakProgressEventArgs> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SpeakSsml">
      <MemberSignature Language="C#" Value="public void SpeakSsml (string textToSpeak);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SpeakSsml(string textToSpeak) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.SpeakSsml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SpeakSsml (textToSpeak As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SpeakSsml(System::String ^ textToSpeak);" />
      <MemberSignature Language="F#" Value="member this.SpeakSsml : string -&gt; unit" Usage="speechSynthesizer.SpeakSsml textToSpeak" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textToSpeak" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textToSpeak">要朗读的 SSML。</param>
        <summary>同步包含 SSML 标记的 <see cref="T:System.String" /> 的语言。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参数的内容 `textToSpeak` 必须包括一个 `speak` 元素，并且必须符合 [语音合成标记语言 (SSML) 版本 1.0](https://go.microsoft.com/fwlink/?LinkId=201763)。 有关详细信息，请参阅 [语音合成标记语言参考](https://msdn.microsoft.com/library/0c51279e-84d2-4f73-a924-8832039abf94)。  
  
 若要以异步方式口述包含 SSML 标记的字符串，请使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakSsmlAsync%2A> 方法。 您可以使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.Speak%2A> 来启动同步，而不包含 SSML 标记的字符串。  
  
 在调用此方法的过程中， <xref:System.Speech.Synthesis.SpeechSynthesizer> 可能会引发以下事件：  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.StateChanged>. 合成器的讲述状态更改时引发。  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakStarted>. 合成器开始生成语音时引发。  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.PhonemeReached>. 每次合成器达到一种语言的字母或字母组合时引发。  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakProgress>. 每次合成器完成字词时引发。  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.VisemeReached>. 每次出现口述输出时，需要更改嘴或用于生成语音的面部肌肉的位置。  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.BookmarkReached>. 当合成器在提示符处遇到书签时引发。  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.VoiceChange>. 合成器的说话声音发生变化时引发。  
  
 在 <xref:System.Speech.Synthesis.SpeechSynthesizer> <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakCompleted> 处理方法时不会引发事件 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakSsml%2A> 。  
  
   
  
## Examples  
 下面的示例将日期1/29/2009 呈现为日期，以月、日、年顺序显示。  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      SpeechSynthesizer synth = new SpeechSynthesizer();  
  
      // Configure the audio output.   
      synth.SetOutputToDefaultAudioDevice();  
  
      // Build an SSML prompt in a string.  
      string str = "<speak version=\"1.0\"";  
      str += " xmlns=\"http://www.w3.org/2001/10/synthesis\"";  
      str += " xml:lang=\"en-US\">";  
      str += "<say-as type=\"date:mdy\"> 1/29/2009 </say-as>";  
      str += "</speak>";  
  
      // Speak the contents of the prompt synchronously.
      synth.SpeakSsml(str);  
  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SpeakSsmlAsync">
      <MemberSignature Language="C#" Value="public System.Speech.Synthesis.Prompt SpeakSsmlAsync (string textToSpeak);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Speech.Synthesis.Prompt SpeakSsmlAsync(string textToSpeak) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.SpeechSynthesizer.SpeakSsmlAsync(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SpeakSsmlAsync (textToSpeak As String) As Prompt" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Speech::Synthesis::Prompt ^ SpeakSsmlAsync(System::String ^ textToSpeak);" />
      <MemberSignature Language="F#" Value="member this.SpeakSsmlAsync : string -&gt; System.Speech.Synthesis.Prompt" Usage="speechSynthesizer.SpeakSsmlAsync textToSpeak" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Synthesis.Prompt</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textToSpeak" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textToSpeak">要朗读的 SMML 标记。</param>
        <summary>异步使用包含 SSML 标记的 <see cref="T:System.String" /> 的语言。</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参数的内容 `textToSpeak` 必须包括一个 `speak` 元素，并且必须符合 [语音合成标记语言 (SSML) 版本 1.0](https://go.microsoft.com/fwlink/?LinkId=201763)。 有关详细信息，请参阅 [语音合成标记语言参考](https://msdn.microsoft.com/library/0c51279e-84d2-4f73-a924-8832039abf94)。  
  
 若要同步朗读包含 SSML 标记的字符串，请使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakSsml%2A> 方法。 可以使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsync%2A> 启动不包含 SSML 标记的字符串的异步播放。  
  
 在调用此方法的过程中， <xref:System.Speech.Synthesis.SpeechSynthesizer> 可能会引发以下事件：  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.StateChanged>. 合成器的讲述状态更改时引发。  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakStarted>. 合成器开始生成语音时引发。  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.PhonemeReached>. 每次合成器达到一种语言的字母或字母组合时引发。  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakProgress>. 每次合成器完成字词时引发。  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.VisemeReached>. 每次出现口述输出时，需要更改嘴或用于生成语音的面部肌肉的位置。  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.BookmarkReached>. 当合成器在提示符处遇到书签时引发。  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.VoiceChange>. 合成器的说话声音发生变化时引发。  
  
-   <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakCompleted>. 合成器完成操作处理后引发 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakSsmlAsync%2A> 。  
  
 如果应用程序的 dos 不需要在说话时执行任务，则可以使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.Speak%2A> 或 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakSsml%2A> 方法来同步生成语音。  
  
   
  
## Examples  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      SpeechSynthesizer synth = new SpeechSynthesizer();  
  
      // Configure the audio output.   
      synth.SetOutputToDefaultAudioDevice();  
  
      // Build an SSML prompt in a string.  
      string str = "<speak version=\"1.0\"";  
      str += " xmlns=\"http://www.w3.org/2001/10/synthesis\"";  
      str += " xml:lang=\"en-US\">";  
      str += "<say-as type=\"date:mdy\"> 1/29/2009 </say-as>";  
      str += "</speak>";  
  
      // Speak the contents of the prompt asynchronously.  
      synth.SpeakSsmlAsync(str);  
  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SpeakStarted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Speech.Synthesis.SpeakStartedEventArgs&gt; SpeakStarted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Speech.Synthesis.SpeakStartedEventArgs&gt; SpeakStarted" />
      <MemberSignature Language="DocId" Value="E:System.Speech.Synthesis.SpeechSynthesizer.SpeakStarted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SpeakStarted As EventHandler(Of SpeakStartedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Speech::Synthesis::SpeakStartedEventArgs ^&gt; ^ SpeakStarted;" />
      <MemberSignature Language="F#" Value="member this.SpeakStarted : EventHandler&lt;System.Speech.Synthesis.SpeakStartedEventArgs&gt; " Usage="member this.SpeakStarted : System.EventHandler&lt;System.Speech.Synthesis.SpeakStartedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Speech.Synthesis.SpeakStartedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="T:System.Speech.Synthesis.SpeechSynthesizer" /> 开始提示的讲话的时候引发。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Synthesis.SpeechSynthesizer>当使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.Speak%2A> 、 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsync%2A> 、 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakSsml%2A> 或方法之一开始处理提示符时，将引发此事件 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakSsmlAsync%2A> 。  
  
 <xref:System.Speech.Synthesis.SpeakStartedEventArgs>类没有属性，并且不会从事件返回数据 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakStarted> 。 提供它是为了使应用程序作者能够编写事件的事件处理程序 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakStarted> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="State">
      <MemberSignature Language="C#" Value="public System.Speech.Synthesis.SynthesizerState State { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Speech.Synthesis.SynthesizerState State" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Synthesis.SpeechSynthesizer.State" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property State As SynthesizerState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Speech::Synthesis::SynthesizerState State { System::Speech::Synthesis::SynthesizerState get(); };" />
      <MemberSignature Language="F#" Value="member this.State : System.Speech.Synthesis.SynthesizerState" Usage="System.Speech.Synthesis.SpeechSynthesizer.State" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Synthesis.SynthesizerState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Speech.Synthesis.SpeechSynthesizer" /> 对象的当前语速。</summary>
        <value>返回 <see cref="T:System.Speech.Synthesis.SpeechSynthesizer" /> 对象的当前语速。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要在更改后获取的新状态 <xref:System.Speech.Synthesis.SpeechSynthesizer> ，请使用 <xref:System.Speech.Synthesis.StateChangedEventArgs.State%2A> 类的属性 <xref:System.Speech.Synthesis.StateChangedEventArgs> 。  
  
   
  
## Examples  
 下面的示例演示了在 <xref:System.Speech.Synthesis.SpeechSynthesizer> 出现提示之前、期间和之后的状态。  
  
```csharp  
using System;  
using System.Threading;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      SpeechSynthesizer synth = new SpeechSynthesizer() ;  
  
      // Configure the audio output.   
      synth.SetOutputToDefaultAudioDevice();  
  
      // Subscribe to the SpeakProgress event.         
      synth.SpeakProgress += new EventHandler<SpeakProgressEventArgs>(synth_SpeakProgress);  
  
      // Write the state of the SpeechSynthesizer to the console.  
      Console.WriteLine("Current Synthesizer state: " + synth.State + "\n");  
  
      // Speak a string asynchronously.  
      synth.SpeakAsync("What is your favorite color?");  
  
      // Write the state of the SpeechSynthesizer to the console while it is speaking.  
      Thread.Sleep(1000);  
      Console.WriteLine("\n - Current Synthesizer state: " + synth.State + " - \n");  
  
      // Write the state of the SpeechSynthesizer to the console after it is done speaking.  
      Thread.Sleep(2000);  
      Console.WriteLine("\nCurrent Synthesizer state: " + synth.State);  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  
    static void synth_SpeakProgress(object sender, SpeakProgressEventArgs e)  
    {  
      Console.WriteLine(e.Text);  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Speech.Synthesis.StateChangedEventArgs&gt; StateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Speech.Synthesis.StateChangedEventArgs&gt; StateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Speech.Synthesis.SpeechSynthesizer.StateChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StateChanged As EventHandler(Of StateChangedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Speech::Synthesis::StateChangedEventArgs ^&gt; ^ StateChanged;" />
      <MemberSignature Language="F#" Value="member this.StateChanged : EventHandler&lt;System.Speech.Synthesis.StateChangedEventArgs&gt; " Usage="member this.StateChanged : System.EventHandler&lt;System.Speech.Synthesis.StateChangedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Speech.Synthesis.StateChangedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="T:System.Speech.Synthesis.SpeechSynthesizer" /> 的状态更改的时候引发。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Synthesis.SpeechSynthesizer>当其讲话发生更改时，将引发此事件 <xref:System.Speech.Synthesis.SpeechSynthesizer.State%2A> 。 有关与事件关联的数据的示例和详细信息，请参阅 <xref:System.Speech.Synthesis.StateChangedEventArgs> 。  
  
 若要暂停和继续语音合成，请使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.Pause%2A> 和 <xref:System.Speech.Synthesis.SpeechSynthesizer.Resume%2A> 方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisemeReached">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Speech.Synthesis.VisemeReachedEventArgs&gt; VisemeReached;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Speech.Synthesis.VisemeReachedEventArgs&gt; VisemeReached" />
      <MemberSignature Language="DocId" Value="E:System.Speech.Synthesis.SpeechSynthesizer.VisemeReached" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event VisemeReached As EventHandler(Of VisemeReachedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Speech::Synthesis::VisemeReachedEventArgs ^&gt; ^ VisemeReached;" />
      <MemberSignature Language="F#" Value="member this.VisemeReached : EventHandler&lt;System.Speech.Synthesis.VisemeReachedEventArgs&gt; " Usage="member this.VisemeReached : System.EventHandler&lt;System.Speech.Synthesis.VisemeReachedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Speech.Synthesis.VisemeReachedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 viseme 达到时引发。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Viseme 是 pronouncing 音素时，嘴的基本位置。 Visemes 是音素的直观表示形式。  
  
 对于美国英语，visemes 支持21个，其中每个都对应于一个或多个音素。  <xref:System.Speech.Synthesis.SpeechSynthesizer.VisemeReached> 当到达新的音素时，将引发事件，而与以前的音素不同，则会引发 viseme。 由于某些 visemes 表示多个音素，因此， <xref:System.Speech.Synthesis.SpeechSynthesizer.VisemeReached> 如果到达的下一个音素与上一个音素相同的 viseme，则不会生成事件。 例如，对于说词 "this zone"，将为 " <xref:System.Speech.Synthesis.SpeechSynthesizer.PhonemeReached> this" 中的 "s" 和 "zone" 中的 "z" 引发事件。 但是， <xref:System.Speech.Synthesis.SpeechSynthesizer.VisemeReached> 不会为 "区域" 中的 "z" 引发事件，因为它对应于 "this" 中与 "s" 相同的 viseme。  
  
 下面是21个 SAPI 音素和音素组的列表，它们对应于美国英语的 viseme。  
  
|Viseme|音素 (s) |  
|------------|------------------|  
|0|黑屏|  
|1|ae，ax，ah|  
|2|aa|  
|3|ao|  
|4|3om-ey-2vk，eh，糟糕|  
|5|l|  
|6|y、url-iy-ung、ih、ix|  
|7|w，uw|  
|8|ow|  
|9|aw|  
|10|oy|  
|11|ay|  
|12|h|  
|13|r|  
|14|l|  
|15|s、z|  
|16|sh、ch、yey-jh-tfz、zh-chs|  
|17|th，dh|  
|18|f、v|  
|19|d、t、n|  
|20|k、g、ng|  
|21|p，b，m|  
  
 有关与事件关联的数据的信息 `VisemeReached` ，请参阅 <xref:System.Speech.Synthesis.VisemeReachedEventArgs> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Voice">
      <MemberSignature Language="C#" Value="public System.Speech.Synthesis.VoiceInfo Voice { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Speech.Synthesis.VoiceInfo Voice" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Synthesis.SpeechSynthesizer.Voice" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Voice As VoiceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Speech::Synthesis::VoiceInfo ^ Voice { System::Speech::Synthesis::VoiceInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Voice : System.Speech.Synthesis.VoiceInfo" Usage="System.Speech.Synthesis.SpeechSynthesizer.Voice" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Synthesis.VoiceInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取有关当前 <see cref="T:System.Speech.Synthesis.SpeechSynthesizer" /> 对象的语音的信息。</summary>
        <value>返回有关当前 <see cref="T:System.Speech.Synthesis.SpeechSynthesizer" /> 对象的语音的信息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 初始化新的时 <xref:System.Speech.Synthesis.SpeechSynthesizer> ，它将使用默认系统声音。 若要将 <xref:System.Speech.Synthesis.SpeechSynthesizer> 对象配置为使用其中一个已安装的语音合成声音，请使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.SelectVoice%2A> 或 <xref:System.Speech.Synthesis.SpeechSynthesizer.SelectVoiceByHints%2A> 方法。 若要获取有关已安装的声音的信息，请使用 <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> 方法和 <xref:System.Speech.Synthesis.VoiceInfo> 类。  
  
   
  
## Examples  
 下面的示例初始化实例 <xref:System.Speech.Synthesis.SpeechSynthesizer> ，并获取有关当前语音的信息。  
  
```csharp  
using System;  
using System.IO;  
using System.Speech.Synthesis;  
using System.Speech.AudioFormat;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Get information about supported audio formats.  
        string AudioFormats = "";  
        foreach (SpeechAudioFormatInfo fmt in synth.Voice.SupportedAudioFormats)  
        {  
          AudioFormats += String.Format("{0}\n",  
          fmt.EncodingFormat.ToString());  
        }  
  
        // Write information about the voice to the console.  
        Console.WriteLine(" Name:          " + synth.Voice.Name);  
        Console.WriteLine(" Culture:       " + synth.Voice.Culture);  
        Console.WriteLine(" Age:           " + synth.Voice.Age);  
        Console.WriteLine(" Gender:        " + synth.Voice.Gender);  
        Console.WriteLine(" Description:   " + synth.Voice.Description);  
        Console.WriteLine(" ID:            " + synth.Voice.Id);  
        if (synth.Voice.SupportedAudioFormats.Count != 0)  
        {  
          Console.WriteLine(" Audio formats: " + AudioFormats);  
        }  
        else  
        {  
          Console.WriteLine(" No supported audio formats found");  
        }  
  
        // Get additional information about the voice.  
        string AdditionalInfo = "";  
        foreach (string key in synth.Voice.AdditionalInfo.Keys)  
        {  
          AdditionalInfo += String.Format("  {0}: {1}\n",  
            key, synth.Voice.AdditionalInfo[key]);  
        }  
  
        Console.WriteLine(" Additional Info - " + AdditionalInfo);  
        Console.WriteLine();  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Synthesis.SpeechSynthesizer.SelectVoice(System.String)" />
        <altmember cref="M:System.Speech.Synthesis.SpeechSynthesizer.SelectVoiceByHints(System.Speech.Synthesis.VoiceGender)" />
        <altmember cref="M:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices" />
        <altmember cref="E:System.Speech.Synthesis.SpeechSynthesizer.VoiceChange" />
      </Docs>
    </Member>
    <Member MemberName="VoiceChange">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Speech.Synthesis.VoiceChangeEventArgs&gt; VoiceChange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Speech.Synthesis.VoiceChangeEventArgs&gt; VoiceChange" />
      <MemberSignature Language="DocId" Value="E:System.Speech.Synthesis.SpeechSynthesizer.VoiceChange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event VoiceChange As EventHandler(Of VoiceChangeEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Speech::Synthesis::VoiceChangeEventArgs ^&gt; ^ VoiceChange;" />
      <MemberSignature Language="F#" Value="member this.VoiceChange : EventHandler&lt;System.Speech.Synthesis.VoiceChangeEventArgs&gt; " Usage="member this.VoiceChange : System.EventHandler&lt;System.Speech.Synthesis.VoiceChangeEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Speech.Synthesis.VoiceChangeEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="T:System.Speech.Synthesis.SpeechSynthesizer" /> 的语音更改的时候引发。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关与事件关联的数据的示例和信息，请参阅 <xref:System.Speech.Synthesis.VoiceChangeEventArgs> 。  
  
 可以更改 <xref:System.Speech.Synthesis.SpeechSynthesizer> 使用的任何 <xref:System.Speech.Synthesis.PromptBuilder> <xref:System.Speech.Synthesis.PromptBuilder.StartVoice%2A> 方法或 <xref:System.Speech.Synthesis.SpeechSynthesizer> <xref:System.Speech.Synthesis.SpeechSynthesizer.SelectVoice%2A> 或 <xref:System.Speech.Synthesis.SpeechSynthesizer.SelectVoiceByHints%2A> 方法的语音。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volume">
      <MemberSignature Language="C#" Value="public int Volume { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Volume" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Synthesis.SpeechSynthesizer.Volume" />
      <MemberSignature Language="VB.NET" Value="Public Property Volume As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Volume { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Volume : int with get, set" Usage="System.Speech.Synthesis.SpeechSynthesizer.Volume" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Speech.Synthesis.SpeechSynthesizer" /> 对象的输出量。</summary>
        <value>返回 <see cref="T:System.Speech.Synthesis.SpeechSynthesizer" /> 的量（0 到 100）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例设置 <xref:System.Speech.Synthesis.SpeechSynthesizer> 合成声音和 WAV 文件的音频输出量。  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToDefaultAudioDevice();  
  
        // Set the volume of the SpeechSynthesizer's ouput.  
        synth.Volume = 60;  
  
        // Build a prompt containing recorded audio and synthesized speech.  
        PromptBuilder builder = new PromptBuilder(  
          new System.Globalization.CultureInfo("en-US"));  
        builder.AppendAudio("C:\\Test\\WelcomeToContosoRadio.wav");  
        builder.AppendText(  
          "The weather forecast for today is partly cloudy with some sun breaks.");  
  
        // Speak the prompt.  
        synth.Speak(builder);  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
