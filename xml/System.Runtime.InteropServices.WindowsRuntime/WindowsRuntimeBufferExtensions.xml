<Type Name="WindowsRuntimeBufferExtensions" FullName="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions">
  <Metadata><Meta Name="ms.openlocfilehash" Value="db306bc087b5dcc7cc43b94c5a0d9d5d4de897ab" /><Meta Name="ms.sourcegitcommit" Value="c982ad9e10a242d90f1e631b5981570f9e5d9f34" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/10/2020" /><Meta Name="ms.locfileid" Value="89692422" /></Metadata><TypeSignature Language="C#" Value="public static class WindowsRuntimeBufferExtensions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit WindowsRuntimeBufferExtensions extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions" />
  <TypeSignature Language="VB.NET" Value="Public Module WindowsRuntimeBufferExtensions" />
  <TypeSignature Language="C++ CLI" Value="public ref class WindowsRuntimeBufferExtensions abstract sealed" />
  <TypeSignature Language="F#" Value="type WindowsRuntimeBufferExtensions = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.14.0</AssemblyVersion>
    <AssemblyVersion>4.0.15.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="dotnet-uwp-10.0">
      <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供对 Windows 运行时缓冲区（Windows.Storage.Streams.IBuffer 接口）执行操作的扩展方法。</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="AsBuffer">
      <MemberSignature Language="C#" Value="public static Windows.Storage.Streams.IBuffer AsBuffer (this byte[] source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Windows.Storage.Streams.IBuffer AsBuffer(unsigned int8[] source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.AsBuffer(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsBuffer (source As Byte()) As IBuffer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Windows::Storage::Streams::IBuffer ^ AsBuffer(cli::array &lt;System::Byte&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsBuffer : byte[] -&gt; Windows.Storage.Streams.IBuffer" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.AsBuffer source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
        <AssemblyVersion>4.0.15.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Windows.Storage.Streams.IBuffer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Byte[]" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要表示的数组。</param>
        <summary>返回一个 Windows.Storage.Streams.IBuffer 接口，该接口表示指定字节数组。</summary>
        <returns>表示指定字节数组的 Windows.Storage.Streams.IBuffer 接口。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 null。</exception>
      </Docs>
    </Member>
    <Member MemberName="AsBuffer">
      <MemberSignature Language="C#" Value="public static Windows.Storage.Streams.IBuffer AsBuffer (this byte[] source, int offset, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Windows.Storage.Streams.IBuffer AsBuffer(unsigned int8[] source, int32 offset, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.AsBuffer(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsBuffer (source As Byte(), offset As Integer, length As Integer) As IBuffer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Windows::Storage::Streams::IBuffer ^ AsBuffer(cli::array &lt;System::Byte&gt; ^ source, int offset, int length);" />
      <MemberSignature Language="F#" Value="static member AsBuffer : byte[] * int * int -&gt; Windows.Storage.Streams.IBuffer" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.AsBuffer (source, offset, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
        <AssemblyVersion>4.0.15.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Windows.Storage.Streams.IBuffer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Byte[]" RefType="this" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">包含 IBuffer 表示的字节范围的数组。</param>
        <param name="offset">在范围开头的 <paramref name="source" /> 中的偏移量。</param>
        <param name="length">由 IBuffer 表示的范围长度。</param>
        <summary>返回一个 Windows.Storage.Streams.IBuffer 接口，该接口在指定字节数组中表示某个字节范围。</summary>
        <returns>IBuffer 接口表示 <paramref name="source" /> 中的指定字节范围。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 null。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 或 <paramref name="length" /> 小于 0（零）。</exception>
        <exception cref="T:System.ArgumentException">数组不够大，无法作为 IBuffer 的后背存储；即 <paramref name="source" /> 中自 <paramref name="offset" /> 开始的字节数小于 <paramref name="length" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="AsBuffer">
      <MemberSignature Language="C#" Value="public static Windows.Storage.Streams.IBuffer AsBuffer (this byte[] source, int offset, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Windows.Storage.Streams.IBuffer AsBuffer(unsigned int8[] source, int32 offset, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.AsBuffer(System.Byte[],System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsBuffer (source As Byte(), offset As Integer, length As Integer, capacity As Integer) As IBuffer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Windows::Storage::Streams::IBuffer ^ AsBuffer(cli::array &lt;System::Byte&gt; ^ source, int offset, int length, int capacity);" />
      <MemberSignature Language="F#" Value="static member AsBuffer : byte[] * int * int * int -&gt; Windows.Storage.Streams.IBuffer" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.AsBuffer (source, offset, length, capacity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
        <AssemblyVersion>4.0.15.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Windows.Storage.Streams.IBuffer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Byte[]" RefType="this" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">包含 IBuffer 表示的字节范围的数组。</param>
        <param name="offset">在范围开头的 <paramref name="source" /> 中的偏移量。</param>
        <param name="length">IBuffer 的 Length 属性的值。</param>
        <param name="capacity">由 IBuffer 表示的范围大小。 IBuffer 的 Capacity 属性设置为此值。</param>
        <summary>返回一个 Windows.Storage.Streams.IBuffer 接口，该接口在指定字节数组中表示某个字节范围。 可以选择将 IBuffer 的 Length 属性设置为小于该容量的值。</summary>
        <returns>表示 <paramref name="source" /> 中的指定字节范围以及具有指定 Length 属性值的 IBuffer 接口。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 null。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />、<paramref name="length" /> 或 <paramref name="capacity" /> 小于 0（零）。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> 大于 <paramref name="capacity" />。 -或-数组不够大，无法作为 IBuffer 的后背存储；即 <paramref name="source" /> 中自 <paramref name="offset" /> 开始的字节数小于 <paramref name="length" /> 或 <paramref name="capacity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="AsStream">
      <MemberSignature Language="C#" Value="public static System.IO.Stream AsStream (this Windows.Storage.Streams.IBuffer source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream AsStream(class Windows.Storage.Streams.IBuffer source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.AsStream(Windows.Storage.Streams.IBuffer)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsStream (source As IBuffer) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::IO::Stream ^ AsStream(Windows::Storage::Streams::IBuffer ^ source);" />
      <MemberSignature Language="F#" Value="static member AsStream : Windows.Storage.Streams.IBuffer -&gt; System.IO.Stream" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.AsStream source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
        <AssemblyVersion>4.0.15.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Windows.Storage.Streams.IBuffer" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要表示为流的 IBuffer。</param>
        <summary>返回一个流，该流表示 Windows.Storage.Streams.IBuffer 接口所表示的同一内存。</summary>
        <returns>表示指定 Windows.Storage.Streams.IBuffer 接口所表示的同一内存的流。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 null。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public static void CopyTo (this byte[] source, Windows.Storage.Streams.IBuffer destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyTo(unsigned int8[] source, class Windows.Storage.Streams.IBuffer destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo(System.Byte[],Windows.Storage.Streams.IBuffer)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CopyTo (source As Byte(), destination As IBuffer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void CopyTo(cli::array &lt;System::Byte&gt; ^ source, Windows::Storage::Streams::IBuffer ^ destination);" />
      <MemberSignature Language="F#" Value="static member CopyTo : byte[] * Windows.Storage.Streams.IBuffer -&gt; unit" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo (source, destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
        <AssemblyVersion>4.0.15.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Byte[]" RefType="this" />
        <Parameter Name="destination" Type="Windows.Storage.Streams.IBuffer" />
      </Parameters>
      <Docs>
        <param name="source">从中复制数据的数组。</param>
        <param name="destination">向其复制数据的缓冲区。</param>
        <summary>将源数组中的所有字节复制到目标缓冲区 (Windows.Storage.Streams.IBuffer)，数组和缓冲区都从 0（零）偏移量处开始。 该方法不会更新目标缓冲区的长度。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 或 <paramref name="destination" /> 为 null。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 的大小超过了 <paramref name="destination" /> 的容量。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public static void CopyTo (this Windows.Storage.Streams.IBuffer source, byte[] destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyTo(class Windows.Storage.Streams.IBuffer source, unsigned int8[] destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo(Windows.Storage.Streams.IBuffer,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CopyTo (source As IBuffer, destination As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void CopyTo(Windows::Storage::Streams::IBuffer ^ source, cli::array &lt;System::Byte&gt; ^ destination);" />
      <MemberSignature Language="F#" Value="static member CopyTo : Windows.Storage.Streams.IBuffer * byte[] -&gt; unit" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo (source, destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
        <AssemblyVersion>4.0.15.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Windows.Storage.Streams.IBuffer" RefType="this" />
        <Parameter Name="destination" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="source">从中复制数据的缓冲区。</param>
        <param name="destination">向其复制数据的数组。</param>
        <summary>将源缓冲区中的所有字节复制到目标数组 (Windows.Storage.Streams.IBuffer)，缓冲区和数组都从 0（零）偏移量处开始。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 或 <paramref name="destination" /> 为 null。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 的大小超出 <paramref name="destination" /> 的大小。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public static void CopyTo (this Windows.Storage.Streams.IBuffer source, Windows.Storage.Streams.IBuffer destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyTo(class Windows.Storage.Streams.IBuffer source, class Windows.Storage.Streams.IBuffer destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo(Windows.Storage.Streams.IBuffer,Windows.Storage.Streams.IBuffer)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CopyTo (source As IBuffer, destination As IBuffer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void CopyTo(Windows::Storage::Streams::IBuffer ^ source, Windows::Storage::Streams::IBuffer ^ destination);" />
      <MemberSignature Language="F#" Value="static member CopyTo : Windows.Storage.Streams.IBuffer * Windows.Storage.Streams.IBuffer -&gt; unit" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo (source, destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
        <AssemblyVersion>4.0.15.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Windows.Storage.Streams.IBuffer" RefType="this" />
        <Parameter Name="destination" Type="Windows.Storage.Streams.IBuffer" />
      </Parameters>
      <Docs>
        <param name="source">源缓冲区。</param>
        <param name="destination">目标缓冲区。</param>
        <summary>将源缓冲区中的所有字节复制到目标缓冲区 (Windows.Storage.Streams.IBuffer)，这两个缓冲区都从 0（零）偏移量处开始。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 或 <paramref name="destination" /> 为 null。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 的大小超过了 <paramref name="destination" /> 的容量。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public static void CopyTo (this byte[] source, int sourceIndex, Windows.Storage.Streams.IBuffer destination, uint destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyTo(unsigned int8[] source, int32 sourceIndex, class Windows.Storage.Streams.IBuffer destination, unsigned int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo(System.Byte[],System.Int32,Windows.Storage.Streams.IBuffer,System.UInt32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CopyTo (source As Byte(), sourceIndex As Integer, destination As IBuffer, destinationIndex As UInteger, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void CopyTo(cli::array &lt;System::Byte&gt; ^ source, int sourceIndex, Windows::Storage::Streams::IBuffer ^ destination, System::UInt32 destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="static member CopyTo : byte[] * int * Windows.Storage.Streams.IBuffer * uint32 * int -&gt; unit" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo (source, sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
        <AssemblyVersion>4.0.15.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Byte[]" RefType="this" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="Windows.Storage.Streams.IBuffer" />
        <Parameter Name="destinationIndex" Type="System.UInt32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">从中复制数据的数组。</param>
        <param name="sourceIndex">在 <paramref name="source" /> 中从其开始复制数据的索引。</param>
        <param name="destination">向其复制数据的缓冲区。</param>
        <param name="destinationIndex">在 <paramref name="destination" /> 中开始向其复制数据的索引。</param>
        <param name="count">要复制的字节数。</param>
        <summary>将源数组中的字节复制到目标缓冲区 (Windows.Storage.Streams.IBuffer)，指定该源数组的起始索引、目标缓冲区的起始索引和要复制的字节数。 该方法不会更新目标缓存区的 Length 属性。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 或 <paramref name="destination" /> 为 null。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />、<paramref name="sourceIndex" /> 或 <paramref name="destinationIndex" /> 小于 0（零）。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceIndex" /> 大于或等于 <paramref name="source" /> 的长度。 -或-<paramref name="sourceIndex" /> 中自 <paramref name="source" /> 开始的字节数小于 <paramref name="count" />。 -或-从 <paramref name="destinationIndex" /> 开始复制 <paramref name="count" /> 字节将超出 <paramref name="destination" /> 的容量。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public static void CopyTo (this Windows.Storage.Streams.IBuffer source, uint sourceIndex, byte[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyTo(class Windows.Storage.Streams.IBuffer source, unsigned int32 sourceIndex, unsigned int8[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo(Windows.Storage.Streams.IBuffer,System.UInt32,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CopyTo (source As IBuffer, sourceIndex As UInteger, destination As Byte(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void CopyTo(Windows::Storage::Streams::IBuffer ^ source, System::UInt32 sourceIndex, cli::array &lt;System::Byte&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="static member CopyTo : Windows.Storage.Streams.IBuffer * uint32 * byte[] * int * int -&gt; unit" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo (source, sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
        <AssemblyVersion>4.0.15.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Windows.Storage.Streams.IBuffer" RefType="this" />
        <Parameter Name="sourceIndex" Type="System.UInt32" />
        <Parameter Name="destination" Type="System.Byte[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">从中复制数据的缓冲区。</param>
        <param name="sourceIndex">在 <paramref name="source" /> 中从其开始复制数据的索引。</param>
        <param name="destination">向其复制数据的数组。</param>
        <param name="destinationIndex">在 <paramref name="destination" /> 中开始向其复制数据的索引。</param>
        <param name="count">要复制的字节数。</param>
        <summary>将源缓冲区 (Windows.Storage.Streams.IBuffer) 的字节复制到目标数组，指定该源缓冲区的起始索引、目标数组的起始索引和要复制的字节数。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 或 <paramref name="destination" /> 为 null。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />、<paramref name="sourceIndex" /> 或 <paramref name="destinationIndex" /> 小于 0（零）。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceIndex" /> 大于或等于 <paramref name="source" /> 的容量。 -或-<paramref name="destinationIndex" /> 大于或等于 <paramref name="destination" /> 的长度。 -或-<paramref name="sourceIndex" /> 中自 <paramref name="source" /> 开始的字节数小于 <paramref name="count" />。 -或-从 <paramref name="destinationIndex" /> 开始复制 <paramref name="count" /> 字节将超出 <paramref name="destination" /> 的大小。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public static void CopyTo (this Windows.Storage.Streams.IBuffer source, uint sourceIndex, Windows.Storage.Streams.IBuffer destination, uint destinationIndex, uint count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyTo(class Windows.Storage.Streams.IBuffer source, unsigned int32 sourceIndex, class Windows.Storage.Streams.IBuffer destination, unsigned int32 destinationIndex, unsigned int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo(Windows.Storage.Streams.IBuffer,System.UInt32,Windows.Storage.Streams.IBuffer,System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CopyTo (source As IBuffer, sourceIndex As UInteger, destination As IBuffer, destinationIndex As UInteger, count As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void CopyTo(Windows::Storage::Streams::IBuffer ^ source, System::UInt32 sourceIndex, Windows::Storage::Streams::IBuffer ^ destination, System::UInt32 destinationIndex, System::UInt32 count);" />
      <MemberSignature Language="F#" Value="static member CopyTo : Windows.Storage.Streams.IBuffer * uint32 * Windows.Storage.Streams.IBuffer * uint32 * uint32 -&gt; unit" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo (source, sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
        <AssemblyVersion>4.0.15.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Windows.Storage.Streams.IBuffer" RefType="this" />
        <Parameter Name="sourceIndex" Type="System.UInt32" />
        <Parameter Name="destination" Type="Windows.Storage.Streams.IBuffer" />
        <Parameter Name="destinationIndex" Type="System.UInt32" />
        <Parameter Name="count" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="source">从中复制数据的缓冲区。</param>
        <param name="sourceIndex">在 <paramref name="source" /> 中从其开始复制数据的索引。</param>
        <param name="destination">向其复制数据的缓冲区。</param>
        <param name="destinationIndex">在 <paramref name="destination" /> 中开始向其复制数据的索引。</param>
        <param name="count">要复制的字节数。</param>
        <summary>将源缓冲区 (Windows.Storage.Streams.IBuffer) 的字节复制到目标缓冲区，指定该源的起始索引、目标的起始索引和要复制的字节数。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 或 <paramref name="destination" /> 为 null。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />、<paramref name="sourceIndex" /> 或 <paramref name="destinationIndex" /> 小于 0（零）。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceIndex" /> 大于或等于 <paramref name="source" /> 的容量。 -或-<paramref name="destinationIndex" /> 大于或等于 <paramref name="destination" /> 的容量。 -或-<paramref name="sourceIndex" /> 中自 <paramref name="source" /> 开始的字节数小于 <paramref name="count" />。 -或-从 <paramref name="destinationIndex" /> 开始复制 <paramref name="count" /> 字节将超出 <paramref name="destination" /> 的容量。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetByte">
      <MemberSignature Language="C#" Value="public static byte GetByte (this Windows.Storage.Streams.IBuffer source, uint byteOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 GetByte(class Windows.Storage.Streams.IBuffer source, unsigned int32 byteOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.GetByte(Windows.Storage.Streams.IBuffer,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetByte (source As IBuffer, byteOffset As UInteger) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Byte GetByte(Windows::Storage::Streams::IBuffer ^ source, System::UInt32 byteOffset);" />
      <MemberSignature Language="F#" Value="static member GetByte : Windows.Storage.Streams.IBuffer * uint32 -&gt; byte" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.GetByte (source, byteOffset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
        <AssemblyVersion>4.0.15.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Windows.Storage.Streams.IBuffer" RefType="this" />
        <Parameter Name="byteOffset" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="source">从其中获取字节的缓冲区。</param>
        <param name="byteOffset">字节的偏移量。</param>
        <summary>返回在指定 Windows.Storage.Streams.IBuffer 接口中位于指定偏移量处的字节。</summary>
        <returns>位于指定偏移量处的字节。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 null。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteOffset" /> 小于 0（零）。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="byteOffset" /> 大于或等于 <paramref name="source" /> 的容量。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetWindowsRuntimeBuffer">
      <MemberSignature Language="C#" Value="public static Windows.Storage.Streams.IBuffer GetWindowsRuntimeBuffer (this System.IO.MemoryStream underlyingStream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Windows.Storage.Streams.IBuffer GetWindowsRuntimeBuffer(class System.IO.MemoryStream underlyingStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.GetWindowsRuntimeBuffer(System.IO.MemoryStream)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetWindowsRuntimeBuffer (underlyingStream As MemoryStream) As IBuffer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Windows::Storage::Streams::IBuffer ^ GetWindowsRuntimeBuffer(System::IO::MemoryStream ^ underlyingStream);" />
      <MemberSignature Language="F#" Value="static member GetWindowsRuntimeBuffer : System.IO.MemoryStream -&gt; Windows.Storage.Streams.IBuffer" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.GetWindowsRuntimeBuffer underlyingStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
        <AssemblyVersion>4.0.15.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Windows.Storage.Streams.IBuffer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="underlyingStream" Type="System.IO.MemoryStream" RefType="this" />
      </Parameters>
      <Docs>
        <param name="underlyingStream">为 IBuffer 提供备份内存的流。</param>
        <summary>返回一个 Windows.Storage.Streams.IBuffer 接口，该接口将同一内存表示为指定内存流。</summary>
        <returns>由支持指定内存流的同一内存支持的 Windows.Storage.Streams.IBuffer 接口。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWindowsRuntimeBuffer">
      <MemberSignature Language="C#" Value="public static Windows.Storage.Streams.IBuffer GetWindowsRuntimeBuffer (this System.IO.MemoryStream underlyingStream, int positionInStream, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Windows.Storage.Streams.IBuffer GetWindowsRuntimeBuffer(class System.IO.MemoryStream underlyingStream, int32 positionInStream, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.GetWindowsRuntimeBuffer(System.IO.MemoryStream,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetWindowsRuntimeBuffer (underlyingStream As MemoryStream, positionInStream As Integer, length As Integer) As IBuffer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Windows::Storage::Streams::IBuffer ^ GetWindowsRuntimeBuffer(System::IO::MemoryStream ^ underlyingStream, int positionInStream, int length);" />
      <MemberSignature Language="F#" Value="static member GetWindowsRuntimeBuffer : System.IO.MemoryStream * int * int -&gt; Windows.Storage.Streams.IBuffer" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.GetWindowsRuntimeBuffer (underlyingStream, positionInStream, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
        <AssemblyVersion>4.0.15.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Windows.Storage.Streams.IBuffer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="underlyingStream" Type="System.IO.MemoryStream" RefType="this" />
        <Parameter Name="positionInStream" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="underlyingStream">与 IBuffer 共享内存的流。</param>
        <param name="positionInStream">共享内存区域在 <paramref name="underlyingStream" /> 中的位置。</param>
        <param name="length">共享内存区域的最大大小。 如果 <paramref name="underlyingStream" /> 中自 <paramref name="positionInStream" /> 开始的字节数小于 <paramref name="length" />，则返回的 IBuffer 只表示可用字节数。</param>
        <summary>返回一个 Windows.Storage.Streams.IBuffer 接口，该接口表示由指定内存流所表示的内存中的一个区域。</summary>
        <returns>由支持指定内存流的内存中的一个区域支持的 Windows.Storage.Streams.IBuffer 接口。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="underlyingStream" /> 为 null。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="positionInStream" /> 或 <paramref name="length" /> 小于 0（零）。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="positionInStream" /> 超出 <paramref name="source" /> 的末尾。</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="underlyingStream" /> 无法公开其基础的内存缓冲区。</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="underlyingStream" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSameData">
      <MemberSignature Language="C#" Value="public static bool IsSameData (this Windows.Storage.Streams.IBuffer buffer, Windows.Storage.Streams.IBuffer otherBuffer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSameData(class Windows.Storage.Streams.IBuffer buffer, class Windows.Storage.Streams.IBuffer otherBuffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.IsSameData(Windows.Storage.Streams.IBuffer,Windows.Storage.Streams.IBuffer)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsSameData (buffer As IBuffer, otherBuffer As IBuffer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsSameData(Windows::Storage::Streams::IBuffer ^ buffer, Windows::Storage::Streams::IBuffer ^ otherBuffer);" />
      <MemberSignature Language="F#" Value="static member IsSameData : Windows.Storage.Streams.IBuffer * Windows.Storage.Streams.IBuffer -&gt; bool" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.IsSameData (buffer, otherBuffer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
        <AssemblyVersion>4.0.15.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="Windows.Storage.Streams.IBuffer" RefType="this" />
        <Parameter Name="otherBuffer" Type="Windows.Storage.Streams.IBuffer" />
      </Parameters>
      <Docs>
        <param name="buffer">第一个缓冲区。</param>
        <param name="otherBuffer">第二个缓冲区。</param>
        <summary>返回一个值，该值指示两个缓冲区（Windows.Storage.Streams.IBuffer 对象）是否表示相同的基础内存区域。</summary>
        <returns>如果由两个缓冲区表示的内存区域具有相同的起始点，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public static byte[] ToArray (this Windows.Storage.Streams.IBuffer source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] ToArray(class Windows.Storage.Streams.IBuffer source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.ToArray(Windows.Storage.Streams.IBuffer)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToArray (source As IBuffer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static cli::array &lt;System::Byte&gt; ^ ToArray(Windows::Storage::Streams::IBuffer ^ source);" />
      <MemberSignature Language="F#" Value="static member ToArray : Windows.Storage.Streams.IBuffer -&gt; byte[]" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.ToArray source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
        <AssemblyVersion>4.0.15.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Windows.Storage.Streams.IBuffer" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">其内容填充新数组的缓冲区。</param>
        <summary>返回一个新数组，该数组根据指定缓冲区 (Windows.Storage.Streams.IBuffer) 的内容创建。 数组的大小是 IBuffer 的 Length 属性值。</summary>
        <returns>包含指定 IBuffer 中的字节的字节数组，自 0（零）偏移量处开始并包括与 IBuffer 的 Length 属性值相等的字节数。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 null。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public static byte[] ToArray (this Windows.Storage.Streams.IBuffer source, uint sourceIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] ToArray(class Windows.Storage.Streams.IBuffer source, unsigned int32 sourceIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.ToArray(Windows.Storage.Streams.IBuffer,System.UInt32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToArray (source As IBuffer, sourceIndex As UInteger, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static cli::array &lt;System::Byte&gt; ^ ToArray(Windows::Storage::Streams::IBuffer ^ source, System::UInt32 sourceIndex, int count);" />
      <MemberSignature Language="F#" Value="static member ToArray : Windows.Storage.Streams.IBuffer * uint32 * int -&gt; byte[]" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.ToArray (source, sourceIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
        <AssemblyVersion>4.0.15.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Windows.Storage.Streams.IBuffer" RefType="this" />
        <Parameter Name="sourceIndex" Type="System.UInt32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">其内容填充新数组的缓冲区。</param>
        <param name="sourceIndex">在 <paramref name="source" /> 中从其开始复制数据的索引。</param>
        <param name="count">要复制的字节数。</param>
        <summary>返回一个新数组，该数组根据指定缓冲区 (Windows.Storage.Streams.IBuffer) 的内容创建，在指定的偏移量处开始并包含指定的字节数。</summary>
        <returns>包含指定的字节范围的字节数组。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 null。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 或 <paramref name="sourceIndex" /> 小于 0（零）。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceIndex" /> 大于或等于 <paramref name="source" /> 的容量。 -或-<paramref name="sourceIndex" /> 中自 <paramref name="source" /> 开始的字节数小于 <paramref name="count" />。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
